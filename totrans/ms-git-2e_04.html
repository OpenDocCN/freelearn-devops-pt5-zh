<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-47"><a id="_idTextAnchor049" class="pcalibre1 pcalibre calibre6"/>3</h1>
<h1 id="_idParaDest-48" class="calibre5"><a id="_idTextAnchor050" class="pcalibre1 pcalibre calibre6"/>Managing Your Worktrees</h1>
<p class="calibre3">The previous chapter, <em class="italic">Developing with Git</em>, described how you can use Git for project development, including how to create new revisions. In this chapter, we will focus on learning how to manage a working directory (worktree) so that you can prepare content for a new commit. This chapter will teach you how to manage your files in detail. It will also show you how to care for files that require special handling while introducing the concepts of ignored files and file attributes. Then, you will learn how to fix mistakes in handling files, both in the working directory and in the staging area, as well as how to fix or split the latest commit. Finally, you will learn how to safely handle interruptions in the workflow with stashes and multiple working directories.</p>
<p class="calibre3">The previous chapter also taught you how to examine changes. In this chapter, you will learn how to undo and redo those changes selectively, as well as how to view different versions of a file.</p>
<p class="calibre3">This chapter will cover the following topics:</p>
<ul class="calibre16">
<li class="calibre15">Ignoring files – marking files as intentionally not being under version control</li>
<li class="calibre15">File attributes – path-specific configuration</li>
<li class="calibre15">Using various modes of the <strong class="source-inline1">git </strong><strong class="source-inline1">reset</strong> command</li>
<li class="calibre15">Stashing away your changes to handle interruptions</li>
<li class="calibre15">Managing the working directory’s contents and the staging area</li>
<li class="calibre15">Multiple working directories (worktrees)</li>
</ul>
<h1 id="_idParaDest-49" class="calibre5"><a id="_idTextAnchor051" class="pcalibre1 pcalibre calibre6"/>Ignoring files</h1>
<p class="calibre3">The files inside your <strong class="bold">working area</strong> (also <a id="_idIndexMarker139" class="pcalibre1 pcalibre calibre6"/>known as the <strong class="bold">worktree</strong>) can be <em class="italic">tracked</em> or <em class="italic">untracked</em> by Git. <strong class="bold">Tracked files</strong>, as the name suggests, are those files whose changes Git will follow. For Git, if a<a id="_idIndexMarker140" class="pcalibre1 pcalibre calibre6"/> file is present in the <strong class="bold">staging area</strong> (also known as <strong class="bold">the index</strong>), it will be tracked, and – unless specified otherwise – it will be a part of the<a id="_idIndexMarker141" class="pcalibre1 pcalibre calibre6"/> next revision. You <em class="italic">add</em> files to be tracked, to have them<a id="_idIndexMarker142" class="pcalibre1 pcalibre calibre6"/> as a part of the project history.</p>
<p class="callout-heading">The purpose of the staging area</p>
<p class="callout">The <strong class="bold">index</strong>, or the <strong class="bold">staging area</strong>, is used <a id="_idIndexMarker143" class="pcalibre1 pcalibre calibre6"/>not only for Git to know which files to track, but also as a kind of scratchpad to<a id="_idIndexMarker144" class="pcalibre1 pcalibre calibre6"/> create new <strong class="bold">commits</strong>, as described in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>, and to help resolve merge conflicts, as shown in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging </em><em class="italic">Changes Together</em>.</p>
<p class="calibre3">Often, you will have <a id="_idIndexMarker145" class="pcalibre1 pcalibre calibre6"/>some individual files or a class of files that you never want to be a part of the project history, and never want to track. These can be your editor backup files, or automatically generated files that are produced by the project’s build system (executables, object files, minified sources, source maps, and so on).</p>
<p class="calibre3">You don’t want Git to automatically add such files, for example, when doing <code>git add :/</code> (adding the entire working tree) or with <code>git add .</code> (adding the current directory), or when updating the index to the worktree’s state with <code>git </code><code>add --all</code>.</p>
<p class="calibre3">Quite the opposite: you want Git to actively prevent you from accidentally adding them. You also want such files to be absent from the <code>git status</code> output as there can be many of them. They could otherwise drown out legitimate new <em class="italic">unknown</em> files there. You want such files to be intentionally untracked – that is, <em class="italic">ignored</em>.</p>
<p class="callout-heading">Un-tracking and re-tracking files</p>
<p class="callout">If you want to <a id="_idIndexMarker146" class="pcalibre1 pcalibre calibre6"/>start ignoring a file that was formerly tracked, such as when you’re moving <a id="_idIndexMarker147" class="pcalibre1 pcalibre calibre6"/>from a hand-generated HTML file to using a lightweight markup language such as <strong class="bold">Markdown</strong> instead, you usually need to <strong class="bold">un-track</strong> the file without removing it from the working directory while adding it to the list of ignored files. You can do this with <strong class="source-inline1">git rm --cached &lt;file&gt;</strong> (as shown in the output of <strong class="source-inline1">git status</strong>). This <a id="_idIndexMarker148" class="pcalibre1 pcalibre calibre6"/>command removes the named file from the staging area.</p>
<p class="callout">To add (start tracking) an<a id="_idIndexMarker149" class="pcalibre1 pcalibre calibre6"/> intentionally untracked (that is, ignored) file, you need to use <strong class="source-inline1">git add --force &lt;file&gt;</strong>, as Git will tell you.</p>
<h2 id="_idParaDest-50" class="calibre7"><a id="_idTextAnchor052" class="pcalibre1 pcalibre calibre6"/>Marking files as intentionally untracked (ignored)</h2>
<p class="calibre3">If you want to mark a file or a set of files as<a id="_idIndexMarker150" class="pcalibre1 pcalibre calibre6"/> intentionally ignored, you need to add a <strong class="bold">shell glob pattern</strong> that matches files that you want to have ignored by <a id="_idIndexMarker151" class="pcalibre1 pcalibre calibre6"/>Git to one of the following <strong class="bold">gitignore</strong> files, one<a id="_idIndexMarker152" class="pcalibre1 pcalibre calibre6"/> pattern per line:</p>
<ul class="calibre16">
<li class="calibre15">The per-user file, which can be specified by the <strong class="source-inline1">core.excludesFile</strong> configuration variable. If this configuration variable is not set, then the default value of <strong class="source-inline1">$XDG_CONFIG_HOME/git/ignore</strong> is used. This, in turn, defaults to <strong class="source-inline1">$HOME/.config/git/ignore</strong> if the <strong class="source-inline1">$XDG_CONFIG_HOME</strong> environment variable is not set or empty (where <strong class="source-inline1">$HOME</strong> is the current user’s home directory).</li>
<li class="calibre15">The per-local repository <strong class="source-inline1">$GIT_DIR/info/exclude</strong> file in the administrative area of the local clone of the repository (in most cases, <strong class="source-inline1">$GIT_DIR</strong> points to the <strong class="source-inline1">.git/</strong> directory in the top-level directory of the project).</li>
<li class="calibre15">The <strong class="source-inline1">.gitignore</strong> files in the working directories of a project. These are usually tracked, and in this case, they are shared among all developers.</li>
</ul>
<p class="calibre3">Some commands, such as <code>git clean</code>, also allow us to specify ignore patterns from a command line with the <code>--</code><code>exclude=&lt;pattern&gt;</code> option.</p>
<p class="calibre3">When deciding whether to ignore a path, Git checks all those sources in the order specified in the preceding list, with the last matching pattern deciding the outcome. The <code>.gitignore</code> files are checked in order, starting from the top directory of the project down to the directory of files to be examined.</p>
<p class="calibre3">To make <code>.gitignore</code> files more readable, you can use blank lines to separate groups of files (a blank line matches no files). You can also describe patterns or groups of patterns with comments; a line starting with the hash character, <code>#</code>, serves as one (to ignore a pattern beginning with <code>#</code>, escape the first hash character with a backslash, <code>\</code> – for example, <code>\#*#</code>). Trailing spaces (at the end of the line) are ignored unless escaped with a backslash, <code>\</code>.</p>
<p class="calibre3">Each line in the <code>.gitignore</code> file specifies a Unix glob pattern, a shell wildcard. The <code>*</code> wildcard matches zero or more characters (any string), while the <code>?</code> wildcard matches any single character. You can also use character classes with brackets, <code>[...]</code>. Take, for example, the following list of patterns:</p>
<pre class="source-code">
*.[oa]
*~</pre>
<p class="calibre3">Here, the first line tells Git to ignore all files with the <code>.a</code> or <code>.o</code> extension – <code>*.a</code> files are archive files (for example, a static library), and <code>*.o</code> files are object files that may be the products of compiling your code. The second line tells Git to ignore all files ending with a tilde, <code>~</code>; this is used by many Unix text editors to mark temporary backup files.</p>
<p class="calibre3">If the pattern does not<a id="_idIndexMarker153" class="pcalibre1 pcalibre calibre6"/> contain a slash, <code>/</code>, which is a path component<a id="_idIndexMarker154" class="pcalibre1 pcalibre calibre6"/> separator, Git treats it as a <code>.gitignore</code> file location if the pattern is in such a file, or the top level of the repository otherwise). The exception is patterns ending with a slash, <code>/</code>, which is used to have the pattern only matched against directories but otherwise treated as if the trailing slash was removed.</p>
<p class="calibre3">A leading slash matches the beginning of the pathname. This means the following:</p>
<ul class="calibre16">
<li class="calibre15">Patterns not containing a slash match everywhere in the repository; we can say that the pattern is recursive.<p class="calibre3">For example, the <code>*.o</code> pattern matches object files anywhere, both at the <code>.gitignore</code> file level and in subdirectories such as <code>file.o</code>, <code>obj/file.o</code>, and others.</p></li>
<li class="calibre15">Patterns ending with a slash only match directories but are otherwise recursive (unless they contain other slashes).<p class="calibre3">For example, the <code>auto/</code> pattern will match both the top-level <code>auto</code> directory and the <code>src/auto</code> directory but will not match the <code>auto</code> file (or a symbolic link either).</p></li>
<li class="calibre15">To <em class="italic">anchor</em> a pattern and make it non-recursive, add a leading slash.<p class="calibre3">For example, the <code>/TODO</code> pattern will match and make Git ignore the current-level <code>TODO</code> file, but not files in subdirectories, such as <code>src/TODO</code>.</p></li>
<li class="calibre15">Patterns containing <a id="_idIndexMarker155" class="pcalibre1 pcalibre calibre6"/>a slash inside are anchored and non-recursive, and wildcard characters (<code>doc/*.html</code>  matches the <code>doc/index.html</code> file but not <code>doc/api/index.html</code>; to match HTML files anywhere inside the <code>doc</code> directory, you can use the <code>doc/**/*.html</code> pattern (or put the <code>*.html</code> pattern in the <code>doc/.gitignore</code> file).</p></li>
</ul>
<p class="calibre3">You can also negate a pattern by prefixing it with an exclamation mark, <code>!</code>; any matching file excluded by the earlier rule is then included (non-ignored) again. For example, to ignore all generated HTML files, but include the one HTML file generated by hand, you can put the following in the <code>.</code><code>gitignore</code> file:</p>
<pre class="source-code">
# ignore html files, generated from AsciiDoc sources
*.html
# except for the files below which are generated by hand
!welcome.html</pre>
<p class="callout-heading">Note</p>
<p class="callout">For performance reasons, Git doesn’t go into excluded directories, and (up until <em class="italic">Git 2.7</em>) this means that you cannot re-include a file if a parent directory is excluded.</p>
<p class="calibre3">This means that to ignore <a id="_idIndexMarker156" class="pcalibre1 pcalibre calibre6"/>everything except for the subdirectory, you need to write the following:</p>
<pre class="source-code">
# exclude everything except directory t0001/bin
/*
!/t0001
/t0001/*
!/t0001/bin</pre>
<p class="calibre3">To match a pattern beginning with <code>!</code>, escape it with a backslash, similar to what you need to do for the <code>#</code> character – for example, use the <code>\!important!.md</code> pattern to match the file named <code>!important!.md</code>.</p>
<h2 id="_idParaDest-51" class="calibre7"><a id="_idTextAnchor053" class="pcalibre1 pcalibre calibre6"/>Which types of files should be ignored?</h2>
<p class="calibre3">Now that we know how to<a id="_idIndexMarker157" class="pcalibre1 pcalibre calibre6"/> mark files as intentionally untracked (ignored), there is the question of <em class="italic">which</em> files (or classes of files) should be marked as such. Another issue is <em class="italic">where</em> we should add a pattern for ignoring specific types of files – that is, in which of the three types of <code>.</code><code>gitignore</code> files.</p>
<p class="calibre3">The first rule is that you should never track <em class="italic">automatically generated files</em> (usually generated by the build system of a project). If you add such files to the repository and if you track them, there is a high chance that they will get out of sync with their source. Besides, they are not necessary, as you can always re-generate them. The only possible exception is generated files where the source rarely changes and generating them requires extra tools that developers might not have (if the source changes more often, you can use an orphan branch to store these generated files and refresh this branch only at release time; see <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing With Git</em>, the <em class="italic">Creating orphan branches</em> section for more information).</p>
<p class="calibre3">Those automatically generated files are the files that <em class="italic">all developers</em> will want to ignore. Therefore, they should go into a tracked <code>.gitignore</code> file. This list of patterns will be version-controlled and distributed to other developers via a clone; this way, all developers will get it. You can find a collection of useful <code>.gitignore</code> templates for different programming languages at <a href="https://github.com/github/gitignore" class="pcalibre1 pcalibre calibre6">https://github.com/github/gitignore</a>, or you can use the web app at <a href="https://gitignore.io" class="pcalibre1 pcalibre calibre6">https://gitignore.io</a>.</p>
<p class="calibre3">Second, there are <em class="italic">temporary files</em> and byproducts specific to one user’s toolchain; those should usually not be shared with other developers. If the pattern is specific to both the repository and the user – for example, auxiliary files that live inside the repository but are specific to the workflow of a user (for example, to the IDE used for the project) – it should go into the per-clone <code>$</code><code>GIT_DIR/info/exclude</code> file.</p>
<p class="calibre3">Patterns that the user <a id="_idIndexMarker158" class="pcalibre1 pcalibre calibre6"/>wants to ignore in all situations and are not specific to the repository (or to the project) should generally go into a per-user <code>.gitignore</code> file specified by the <code>core.excludesFile</code> config variable, set in the per-user (global) <code>~/.gitconfig</code> config file (or <code>~/.config/git/config</code>). This is usually <code>~/.config/git/ignore</code> by default.</p>
<p class="callout-heading">Important note about the per-user .gitignore file</p>
<p class="callout">The per-user ignore file cannot be <strong class="source-inline1">~/.gitignore</strong> as this would be the in-repository <strong class="source-inline1">.gitignore</strong> file for the <a id="_idIndexMarker159" class="pcalibre1 pcalibre calibre6"/>versioned user’s home directory if the user wants to keep the <strong class="source-inline1">~/</strong> directory (<strong class="source-inline1">$HOME</strong>) under version control.</p>
<p class="calibre3">This is the place where you can put patterns that match the backup or temporary files generated by your editor or IDE of choice.</p>
<p class="callout-heading">Ignored files are considered expendable</p>
<p class="callout">Warning: Do not add <em class="italic">precious files</em> – that is, those you do not want to track in a given repository but whose contents are important – to the list of ignored files! The types of files that are ignored (excluded) by Git are either easy to regenerate (build products and other generated files) or not important to the user (temporary or backup files).</p>
<p class="callout">Therefore, Git considers ignored files <em class="italic">expendable</em> and will remove them without warning when required to do a requested command – for example, if the ignored file conflicts with the contents of the revision being checked out.</p>
<h2 id="_idParaDest-52" class="calibre7"><a id="_idTextAnchor054" class="pcalibre1 pcalibre calibre6"/>Listing ignored files</h2>
<p class="calibre3">You can list untracked ignored<a id="_idIndexMarker160" class="pcalibre1 pcalibre calibre6"/> files by appending the <code>--ignored</code> option to <a id="_idIndexMarker161" class="pcalibre1 pcalibre calibre6"/>the <code>git </code><code>status</code> command:</p>
<pre class="console">
$ git status --ignored
On branch master
Ignored files:
  (use "git add -f &lt;file&gt;..." to include in what will be committed)
        rand.c~
no changes added to commit (use "git add" and/or "git commit -a")
$ git status --short --branch --ignored
## master
!! rand.c~</pre>
<p class="calibre3">Instead of using <code>git status --ignored</code>, you can use the dry-run option of cleaning ignored files, <code>git clean -Xnd</code>, or the low-level (plumbing) <code>git </code><code>ls-files</code> command:</p>
<pre class="console">
$ git ls-files --others --ignored --exclude-standard
rand.c~</pre>
<p class="calibre3">The latter command can also be used to list <em class="italic">tracked files</em> that match <em class="italic">ignore patterns</em>. If there are any such files, it might mean that some files need to be un-tracked (perhaps because what was once a source file is now generated), or that ignore patterns are too broad. Since Git uses the existence of a file in the staging area (<em class="italic">cache</em>) to know which files to track, this can be done with the following command:</p>
<pre class="console">
$ git ls-files --cached --ignored --exclude-standard</pre>
<p class="calibre3">An empty result, like what’s shown here, means that everything is fine.</p>
<p class="callout-heading">Plumbing versus porcelain commands</p>
<p class="callout">Git commands can be divided into two sets: high-level <strong class="bold">porcelain</strong> commands intended for interactive usage by the end user and low-level <strong class="bold">plumbing</strong> commands intended mainly for shell scripting. The major difference is that high-level commands have outputs that can change and are constantly <a id="_idIndexMarker162" class="pcalibre1 pcalibre calibre6"/>improving. For example, the<a id="_idIndexMarker163" class="pcalibre1 pcalibre calibre6"/> output of the <strong class="source-inline1">git branch</strong> command in the detached <strong class="source-inline1">HEAD</strong> case changed from (<strong class="source-inline1">no branch</strong>) to (<strong class="source-inline1">detached from HEAD</strong>). Their output and behavior are also subject to the configuration. Note that some porcelain commands have the option to switch to unchanging output via <strong class="source-inline1">--porcelain</strong>.</p>
<p class="callout">Another important difference is that plumbing commands try to guess what you meant, they have default parameters, use the default configuration, and so on. This isn’t the case with plumbing commands. You need to pass the <strong class="source-inline1">--exclude-standard</strong> option to the <strong class="source-inline1">git ls-files</strong> command to make it respect the default set of ignore files.</p>
<p class="callout">You can find more on this topic in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and </em><em class="italic">Extending Git</em>.</p>
<h2 id="_idParaDest-53" class="calibre7"><a id="_idTextAnchor055" class="pcalibre1 pcalibre calibre6"/>Trick – ignoring changes in tracked files</h2>
<p class="calibre3">You might have files in your repository that are changed but rarely committed. These can be various local configuration <a id="_idIndexMarker164" class="pcalibre1 pcalibre calibre6"/>files that are edited to match the local setup but should never be committed upstream. This can be a file containing the proposed name for a new release, to be committed later when tagging the next released version.</p>
<p class="calibre3">You would want to keep such files in a <em class="italic">dirty</em> state most of the time, but you would like Git not to tell you about their changes all the time in case you miss other changes because you’re used to ignoring such messages.</p>
<p class="callout-heading">Dirty working directory</p>
<p class="callout">The working directory is considered <strong class="bold">clean</strong> if it is the same as the committed and staged version and <strong class="bold">dirty</strong> if any modifications or changes have been made.</p>
<p class="calibre3">Git can be configured – or rather tricked in this case – to skip checking the worktree (to assume that it is always up to date), and to use the staged version of the file instead. This can be done by setting the aptly named <code>skip-worktree</code> flag for a file. For this, you would need to<a id="_idIndexMarker165" class="pcalibre1 pcalibre calibre6"/> use the low-level <code>git update-index</code> command, which is the plumbing equivalent of the user-facing <code>git add</code> porcelain. You can check file status and flags with <code>git ls-files</code>, which will use the letter <code>S</code> for files with this flag set:</p>
<pre class="console">
$ git update-index --skip-worktree GIT-VERSION-NAME
$ git ls-files -v
S GIT-VERSION-NAME
H …</pre>
<p class="calibre3">Note that this elision of the worktree also includes the <code>git stash</code> command; to stash away your changes and make the working directory <em class="italic">clean</em>, you need to disable this flag (at least temporarily). To make Git look at the working directory version and start tracking changes to the file, use the following command:</p>
<pre class="console">
$ git update-index --no-skip-worktree GIT-VERSION-NAME</pre>
<p class="calibre3">This problem is caused by the fact that this use of the <code>skip-worktree</code> flag is not intended use; this flag was<a id="_idIndexMarker166" class="pcalibre1 pcalibre calibre6"/> created to manage so-called sparse checkout – more on that in <a href="B21194_12.xhtml#_idTextAnchor302" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing </em><em class="italic">Large Repositories</em>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">There is a similar <strong class="source-inline1">assume-unchanged</strong> flag that can be used to make Git completely ignore any changes to the file, or rather <em class="italic">assume that it is unchanged</em>. Files marked with this flag never show as changed in the output of the <strong class="source-inline1">git status</strong> or <strong class="source-inline1">git diff</strong> command. The changes to such files will not be staged, nor committed.</p>
<p class="callout">This is sometimes useful when you’re working with a big project on a filesystem that’s very slow at checking for changes. However, do not use <strong class="source-inline1">assume-unchanged</strong> to <em class="italic">ignore</em> changes to tracked files. You are promising that the file didn’t change, lying to Git. This means, for example, that with <strong class="source-inline1">git stash save</strong> believing what you stated, you would lose your precious local changes.</p>
<h1 id="_idParaDest-54" class="calibre5"><a id="_idTextAnchor056" class="pcalibre1 pcalibre calibre6"/>File attributes</h1>
<p class="calibre3">There are some settings and options in Git that can be specified on a per-path basis, similar to how ignoring files (marking files as<a id="_idIndexMarker167" class="pcalibre1 pcalibre calibre6"/> intentionally untracked) works. These path-specific settings are called <strong class="bold">attributes</strong>.</p>
<p class="calibre3">To specify attributes for files matching a given pattern, you need to add a line with a pattern, separated by a space and followed by a <a id="_idIndexMarker168" class="pcalibre1 pcalibre calibre6"/>whitespace-separated list of attributes, to one of the <code>.gitignore</code> files work):</p>
<ul class="calibre16">
<li class="calibre15">The per-user file, for attributes that should affect all repositories for a single user, specified by the <strong class="source-inline1">core.attributesFile</strong> configuration variable. By default, this is <strong class="source-inline1">~/.config/git/attributes</strong></li>
<li class="calibre15">The per-repository <strong class="source-inline1">.git/info/attributes</strong> file in the administrative area of the local clone of the repository, for attributes that should only affect a single specific clone of the repository (for one user’s workflow).</li>
<li class="calibre15">The <strong class="source-inline1">.gitattributes</strong> files in the working directories of a project, for those attributes that should be shared among developers.</li>
</ul>
<p class="calibre3">The rules for how patterns are used to match files are the same as for the <code>.gitignore</code> files, as described previously, except that there is no support for negative patterns, and that patterns matching the directory do not recursively match paths inside that directory.</p>
<p class="calibre3">Each attribute can be in one of the following states for a given path: set (special value true), unset (special value false), set to a given value, or unspecified:</p>
<pre class="source-code">
pattern*  set -unset set-to=value !unspecified</pre>
<p class="callout-heading">Note</p>
<p class="callout">There can be no whitespace around the equals sign, <strong class="source-inline1">=</strong>, when setting an attribute to a string value!</p>
<p class="calibre3">When more than one pattern matches the path, a later line overrides an earlier line on a per-attribute basis. <code>.gitattributes</code> files are used in order, from the per-user, through per-repository, to the <code>.gitattributes</code> file in a given directory, like for <code>.</code><code>gitignore</code> files.</p>
<h2 id="_idParaDest-55" class="calibre7"><a id="_idTextAnchor057" class="pcalibre1 pcalibre calibre6"/>Identifying binary files and end-of-line conversions</h2>
<p class="calibre3">Different operating systems and different applications can differ in how they represent newlines in text files. Unix and Unix-like systems (including Mac OS X) use a single control character LF (<code>\n</code>), while Windows uses CRLF – that is, CR followed by LF (<code>\n\r</code>); macOS up to version 9 used CR alone (<code>\r</code>).</p>
<p class="calibre3">That might be a problem<a id="_idIndexMarker169" class="pcalibre1 pcalibre calibre6"/> for developing portable applications if different developers use different operating systems. We don’t want to have spurious changes<a id="_idIndexMarker170" class="pcalibre1 pcalibre calibre6"/> because of different end-of-line conventions. Therefore, Git makes it possible to automatically normalize end-of-line characters to be LF in the repository on commit (check-in), and optionally to convert them to <code>CR + LF</code> in the working directory on checkout.</p>
<p class="calibre3">You can control whether a file should be considered for end-of-line conversion with the <code>text</code> attribute. Setting it enables end-of-line conversion, and unsetting it disables it. Setting it to the <code>auto</code> value makes Git guess if the given file is a text file; if it is, end-of-line conversion is enabled. For files where the <code>text</code> attribute is unspecified, Git uses <code>core.autocrlf</code> to decide whether to treat them as <code>text=auto</code> case.</p>
<p class="callout-heading">How Git detects if a file contains binary data</p>
<p class="callout">To decide whether a file contains binary data, Git examines the beginning of the file for an occurrence of a zero byte (the <strong class="source-inline1">null</strong>/<strong class="source-inline1">NUL</strong> character or <strong class="source-inline1">\0</strong>). When deciding whether to convert a file (as in end-of-line conversion), the criterion is stricter: for a file to be considered text, it must have no nulls, and no more than around 1% of it should be non-printable characters.</p>
<p class="callout">However, this means that Git usually considers files saved in the UTF-16 encoding to be binary.</p>
<p class="calibre3">To decide what line ending type Git should use in the working directory for text files, you need to set up the <code>core.eol</code> configuration variable. This can be set to <code>crlf</code>, <code>lf</code>, or <code>native</code> (the last is the default). You can also force a specific line ending for a given file with the <code>eol=lf</code> or <code>eol=crlf</code> attribute:</p>
<table class="no-table-style" id="table001-2">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre17">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Old </strong><strong class="bold">crlf attribute</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">New text and </strong><strong class="bold">eol attributes</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>crlf</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>text</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>-</code><code>crlf</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>-</code><code>text</code></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><code>crlf=input</code></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><code>eol=lf</code></p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 3.1 – Backward compatibility of the text and eof attributes with the crlf attribute</p>
<p class="calibre3">End-of-line conversion bears a slight <a id="_idIndexMarker171" class="pcalibre1 pcalibre calibre6"/>chance of corrupting data. If you want Git to warn or prevent conversion for<a id="_idIndexMarker172" class="pcalibre1 pcalibre calibre6"/> files with a mixture of <code>LF</code> and <code>CRLF</code> line endings, use the <code>core.safecrlf</code> configuration variable.</p>
<p class="calibre3">Sometimes, Git might not detect that a file is binary correctly, or there may be some type of file that is nominally text, but which is opaque to a human reader. Examples include PostScript documents (<code>*.ps</code>) and Xcode build settings (<code>*.pbxproj</code>). Such files should not be normalized and using textual <code>diff</code> for them doesn’t make sense. You can mark such files explicitly as binary with the <code>binary</code> attribute macro (which is equivalent to <code>-</code><code>text -diff</code>):</p>
<pre class="source-code">
*.ps binary
*.pbxproj binary</pre>
<p class="callout-heading">What to do if files start without end-of-line normalization</p>
<p class="callout">When the normalization of line endings is turned on in the repository (by editing the <strong class="source-inline1">.gitattributes</strong> file), you should also force the <strong class="bold">normalization</strong> of files. Otherwise, the change in newline representation<a id="_idIndexMarker173" class="pcalibre1 pcalibre calibre6"/> will be misattributed to the next change to the file. This can be done, for <a id="_idIndexMarker174" class="pcalibre1 pcalibre calibre6"/>example, with the <strong class="source-inline1">git add --renormalize</strong> command. This should also be done when changing which files have the <strong class="source-inline1">text</strong> attribute.</p>
<h2 id="_idParaDest-56" class="calibre7"><a id="_idTextAnchor058" class="pcalibre1 pcalibre calibre6"/>Diff and merge configuration</h2>
<p class="calibre3">In Git, you can use the attributes functionality to configure how to show differences between different versions of a file, and how to do a three-way merge of its contents. This can be used to enhance that <a id="_idIndexMarker175" class="pcalibre1 pcalibre calibre6"/>operation, making <code>diff</code> more attractive and <code>merge</code> less likely to conflict. It can even be used to make it possible to <a id="_idIndexMarker176" class="pcalibre1 pcalibre calibre6"/>effectively <code>diff</code> binary files, or to describe differences in a specific way.</p>
<p class="calibre3">In both cases, we would usually need to set up the <code>diff</code> and/or <code>merge</code> driver. The attributes file only tells us which driver to use; the rest of the information is contained in the configuration file, and this configuration is not automatically shared among developers, unlike the <code>.gitattributes</code> file (though you can create a shared configuration fragment, add it to the repository, and have developers include it in their local per-repository config via the relative <code>include.path</code>). The reason for this behavior is easy to understand – the tool’s configuration may be different on different computers, and some tools may be not available for the developer’s operating system of choice. But this means that some information needs to be distributed out-of-band.</p>
<p class="calibre3">There are, however, a few<a id="_idIndexMarker177" class="pcalibre1 pcalibre calibre6"/> built-in <strong class="bold">diff drivers</strong> and <strong class="bold">merge drivers</strong> that anyone can use without<a id="_idIndexMarker178" class="pcalibre1 pcalibre calibre6"/> further configuration.</p>
<h3 class="calibre9">Generating diffs and binary files</h3>
<p class="calibre3">Diffs that are generated for particular files are<a id="_idIndexMarker179" class="pcalibre1 pcalibre calibre6"/> affected by the <code>diff</code> attribute. If this attribute is unset, Git will treat files as binary concerning generating diffs and show just <code>\</code><code>0</code>) character.</p>
<p class="calibre3">You can use the <code>diff</code> attribute to make Git more effectively describe the differences between two versions of a binary file via a <code>diff</code> command. Even though conversion to text usually loses some information, the resulting differences is useful for human viewing (even though it is not information about all the changes).</p>
<p class="calibre3">This can be done with the <code>textconv</code> config key for a <code>diff</code> driver, where you specify a program that takes the name of the file as an argument and returns a text representation on its output.</p>
<p class="calibre3">For example, you might want to see the difference in the contents of Microsoft Word documents and see the difference in metadata for JPEG images. First, you need to put something like this in your <code>.</code><code>gitattributes</code> file:</p>
<pre class="source-code">
*.doc  diff=word2text
*.jpg  diff=exif</pre>
<p class="calibre3">For example, you can use the <code>catdoc</code> program to extract text from binary Microsoft Word documents and <code>exiftool</code> to extract EXIF metadata from JPEG images.</p>
<p class="calibre3">Because conversion can be slow, Git provides a<a id="_idIndexMarker182" class="pcalibre1 pcalibre calibre6"/> mechanism to cache the output in the form of the Boolean <code>cachetextconv</code> attribute; the cached data is stored using <strong class="bold">notes</strong> (this mechanism will be explained in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>). The part of the configuration file that’s responsible for this setup looks like this:</p>
<pre class="source-code">
[diff "word2text"]
    textconv = catdoc
# cached data will be stored in refs/notes/textconv/exif
[diff "exif"]
    textconv = exiftool
    cachetextconv = true</pre>
<p class="calibre3">You can see what the output of the <code>textconv</code> filter looks like with <code>git show</code>, or with <code>git cat-file -p</code> with the <code>--</code><code>textconv</code> option.</p>
<p class="calibre3">The more complicated but also more powerful <a id="_idIndexMarker183" class="pcalibre1 pcalibre calibre6"/>option is to use an <code>GIT_EXTERNAL_DIFF</code> environment variable or the <code>diff.external</code> configuration variable) with the <code>command</code> option of the <code>diff</code> driver. However, when choosing to use this option, you lose some options that Git <code>diff</code> gives for free: colorization, word diff, and combined diff for merges.</p>
<p class="calibre3">Such a program will be called with seven parameters: <code>path</code>, <code>old-file</code>, <code>old-hex</code>, <code>old-mode</code>, <code>new-file</code>, <code>new-hex</code>, and <code>new-mode</code>. Here, <code>old-file</code> and <code>new-file</code> are files that the <code>diff</code> driver can use to read the contents of two versions of the differing  file, <code>old-hex</code> and <code>new-hex</code> are SHA-1 identifiers of file contents, and <code>old-mode</code> and <code>new-mode</code> are octal representations of file modes. The command is expected to generate a <code>diff</code>-like output. For example, you might want to use the XML-aware <code>diff</code> tool to compare XML files:</p>
<pre class="console">
$ echo "*.xml diff=xmldiff" &gt;&gt;.gitattributes
$ git config diff.xmldiff.command xmldiff-wrapper.sh</pre>
<p class="calibre3">This example assumes that you have written the <code>xmldiff-wrapper.sh</code> shell script to reorder options so that they fit the expectations of the XML <code>diff</code> tool.</p>
<h3 class="calibre9">Configuring diff output</h3>
<p class="calibre3">The <code>diff</code> format that Git uses to show changes for <a id="_idIndexMarker184" class="pcalibre1 pcalibre calibre6"/>users was described in detail in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>. Each group of<a id="_idIndexMarker185" class="pcalibre1 pcalibre calibre6"/> changes (called a hunk) in textual <code>diff</code> output is preceded by the hunk header line, as shown here:</p>
<pre class="console">
@@ -18,6 +19,8 @@ int cmd_http_fetch(int argc, const char **argv,</pre>
<p class="calibre3">The text after the second <code>@@</code> is meant to describe the section of the file where the chunk is; for C source files, it is the start of the function. The decision on how to detect the beginning of such a section depends on the type of file. Git allows you to configure this by setting the <code>xfuncname</code> configuration option of the <code>diff</code> driver to the regular expression, which matches the description of the section of the file. For example, for LaTeX documents, you might want to<a id="_idIndexMarker186" class="pcalibre1 pcalibre calibre6"/> use the following configuration for the <code>tex</code> <code>diff</code> driver (you don’t need to as <code>tex</code> is one of the pre-defined, built-in <code>diff</code> drivers):</p>
<pre class="source-code">
[diff "tex"]
    xfuncname = "^(\\\\(sub)*section\\{.*)$"
    wordRegex = "\\\\[a-zA-Z]+|[{}]|\\\\.|[^\\{}[:space:]]+"</pre>
<p class="calibre3">The <code>wordRegex</code> configuration defines what <code>word</code> is to define it for the <code>git diff --word-diff</code> command (described in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>, near the end of the <em class="italic">Unified diff output</em> section). Here, it’s being used for LaTeX documents.</p>
<p class="callout-heading">Note</p>
<p class="callout">You would need to double the backslashes: <strong class="source-inline1">\\</strong> matches the literal backslash, <strong class="source-inline1">\</strong>, in a regexp, so you need to use <strong class="source-inline1">\\\\</strong> here (which is typical for storing regexps in strings).</p>
<h3 class="calibre9">Performing a three-way merge</h3>
<p class="calibre3">You can also use the <code>merge</code> attribute to tell <a id="_idIndexMarker187" class="pcalibre1 pcalibre calibre6"/>Git to use specific merge strategies for specific files or classes of files in your project. By default, Git will use the thee-way merge driver (similar to <code>rcsmerge</code>) for text files, and it will take our (being merged) version and mark the result as a conflicted merge for binary files. You can force a three-way merge by setting the <code>merge</code> attribute (or by using <code>merge=text</code>); you can force binary-like merging by unsetting this attribute (with <code>-merge</code>, which is equivalent to <code>merge=binary</code>).</p>
<p class="calibre3">You can also write your <code>ChangeLog</code> file in your repository (with a curated list of changes with their description), you can use the <code>git-merge-changelog</code> command<a id="_idIndexMarker188" class="pcalibre1 pcalibre calibre6"/> from the G<strong class="bold">NU Portability Library </strong>(<strong class="bold">Gnulib</strong>). You need to add the following to the appropriate Git config file:</p>
<pre class="source-code">
[merge "merge-changelog"]
    name = GNU-style ChangeLog merge driver
    driver = git-merge-changelog %O %A %B</pre>
<p class="calibre3">Here, the token, <code>%O</code>, in <code>merge.merge-changelog.driver</code> will be expanded to the name of the temporary file holding the contents of the merge ancestor’s (old) version.   The <code>%A</code> and <code>%B</code> tokens expand to the names of temporary files holding contents being merged – that is, the current (ours, merged into) version and the other branches’ (theirs, merged) version, respectively. The <code>merge</code> driver is expected to leave the merged version<a id="_idIndexMarker189" class="pcalibre1 pcalibre calibre6"/> in the <code>%A</code> file, exiting with a non-zero status if there is a merge conflict. You can also use <code>%L</code> to denote the conflict marker size and <code>%P</code> to find a pathname where the merged results will be stored.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can use a different driver for an internal merge between common ancestors (when there is more than one). You can do this by setting the <strong class="source-inline1">merge.*.recursive</strong> configuration variable for a given driver. For example, here, you can use the predefined <strong class="source-inline1">binary</strong> driver.</p>
<p class="calibre3">Of course, you will also need to tell Git to use this driver for <code>ChangeLog</code> files, adding the following line to <code>.gitattributes</code>:</p>
<pre class="source-code">
ChangeLog merge=merge-changelog</pre>
<h2 id="_idParaDest-57" class="calibre7"><a id="_idTextAnchor059" class="pcalibre1 pcalibre calibre6"/>Transforming files (content filtering)</h2>
<p class="calibre3">Sometimes, the format of the content you want to put in a version control system may depend on where it is stored, be it<a id="_idIndexMarker190" class="pcalibre1 pcalibre calibre6"/> on disk or in the repository, with different shapes in different places that are more convenient for Git, the platform (operating system), the filesystem, and the user to use. End-of-line conversion can be considered a special case for such an operation.</p>
<p class="calibre3">To do this, you need to set the <code>filter</code> attribute for appropriate paths and configure the <code>clean</code> and <code>smudge</code> commands of the specified filter driver (either command can be left unspecified for a pass-through filter). When checking out the file matching the given pattern, the <code>smudge</code> command is fed file contents from the repository in its standard input, and its standard output is used to update the file in the working directory. See <em class="italic">Figure 3</em><em class="italic">.1</em> for details:</p>
<div><div><img alt="Figure 3.1 – The “smudge” filter is run on checkout (when writing files to the working directory)" src="img/B21194_03_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1 – The “smudge” filter is run on checkout (when writing files to the working directory)</p>
<p class="calibre3">Similarly, the <code>clean</code> command of a<a id="_idIndexMarker191" class="pcalibre1 pcalibre calibre6"/> filter is used to convert the contents of the worktree file into a shape suitable to be stored in the repository; see <em class="italic">Figure 3</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 3.2 – The “clean” filter is run when files are staged (added to the index, also known as the staging area)" src="img/B21194_03_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2 – The “clean” filter is run when files are staged (added to the index, also known as the staging area)</p>
<p class="calibre3">When specifying a command, you can use the <code>%f</code> token, which will be replaced by the name of the file the filter is working on.</p>
<p class="calibre3">One simple example of how you can use this feature is to use the <code>rezip</code> script for <strong class="bold">OpenDocument Format</strong> (<strong class="bold">ODF</strong>) files. ODF <a id="_idIndexMarker192" class="pcalibre1 pcalibre calibre6"/>documents are ZIP archives of mainly XML files. Git uses compression itself and also does deltaification (but cannot do it on already compressed files); the idea is to store uncompressed files in the repository but to check out compressed files:</p>
<pre class="source-code">
[filter "opendocument"]
    clean = "rezip -p ODF_UNCOMPRESS"
    smudge = "rezip -p ODF_COMPRESS"</pre>
<p class="calibre3">Of course, you also need to tell Git to use this filter for all kinds of ODF files:</p>
<pre class="source-code">
*.odt filter=opendocument
*.ods filter=opendocument
*.odp filter=opendocument</pre>
<p class="calibre3">Another example of an <em class="italic">advisory</em> filter is to use the <code>indent</code> program to force a code formatting convention, as shown in the following example, or <code>gofmt</code> for the Go programming language. A similar example would be to replace tabs with spaces on check-in:</p>
<pre class="source-code">
[filter "indent"]
    clean = indent</pre>
<p class="calibre3">Yet another example is <code>nbdev_clean</code> command to<a id="_idIndexMarker194" class="pcalibre1 pcalibre calibre6"/> strip metadata and cell output from <strong class="bold">Jupyter Notebook</strong> files. This is <a id="_idIndexMarker195" class="pcalibre1 pcalibre calibre6"/>done to reduce the number of merge conflicts and to avoid storing generated data in the repository.</p>
<h3 class="calibre9">Obligatory file transformations</h3>
<p class="calibre3">Another use of content filtering is to store the content that cannot be directly used in the repository and turn it into a usable form <a id="_idIndexMarker196" class="pcalibre1 pcalibre calibre6"/>upon checkout.</p>
<p class="calibre3">One such example might be to use <code>.gitattributes</code> files to configure Git so that it stores large binary files outside the Git repository (such files are often only used by a subset of developers); inside the repository, there is only an identifier that allows us to get file contents from external storage. That’s how <code>git-media</code> works:</p>
<pre class="console">
$ git config filter.media.clean  "git-media filter-clean"
$ git config filter.media.smudge "git-media filter-smudge"
$ echo "*.mov filter=media -crlf" &gt;&gt; .gitattributes</pre>
<p class="callout-heading">Tip</p>
<p class="callout">You can find the <strong class="source-inline1">git-media</strong> tool at <a href="https://github.com/alebedev/git-media" class="pcalibre1 pcalibre calibre6">https://github.com/alebedev/git-media</a>. Other similar tools will be mentioned in <a href="B21194_12.xhtml#_idTextAnchor302" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing Large Repositories</em>, as one of the possible solutions to the problem of handling large files.</p>
<p class="calibre3">Another example of <a id="_idIndexMarker197" class="pcalibre1 pcalibre calibre6"/>obligatory transformations would be encrypting sensitive content or replacing a local sensitive program configuration that is required for an application to work (for example, a database password) with a placeholder. Because running such a filter is, like in the preceding example, <em class="italic">required</em> to get useful content, you can mark it as such:</p>
<pre class="source-code">
[[filter "clean-password"]
    clean = sed -e 's/^pass = .*$/pass = @PASSWORD@/'
    smudge = sed -e 's/^pass = @PASSWORD@/pass = passw0rd/'
    <strong class="bold1">required</strong></pre>
<p class="callout-heading">Important note</p>
<p class="callout">This is only a simplified example; in real use, you would have to consider the security of the config file itself if you do this or store the real password in an external smudge script. In such a case, you should also set up <strong class="source-inline1">pre-commit</strong>, <strong class="source-inline1">pre-push</strong>, and <strong class="source-inline1">update</strong> hooks to ensure that the password won’t make it to the public repository (see <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and Extending Git</em>, for details).</p>
<p class="calibre3">If many files need to be processed, and the time it takes to invoke and run the <code>clean</code> and <code>smudge</code> scripts becomes a problem, you can configure Git to use a program that will process all files with a single filter invocation for the entire lifetime of a Git command. You can define such a filter with a <code>process</code> key in place of <code>clean</code> and <code>smudge</code>.</p>
<h2 id="_idParaDest-58" class="calibre7"><a id="_idTextAnchor060" class="pcalibre1 pcalibre calibre6"/>Keyword expansion and substitution</h2>
<p class="calibre3">Sometimes, though rare, there is <a id="_idIndexMarker198" class="pcalibre1 pcalibre calibre6"/>a need to have a piece of dynamic information about the versioned file in the contents of the file itself. To keep such information <a id="_idIndexMarker199" class="pcalibre1 pcalibre calibre6"/>up to date, you can request the version control system to perform <code>$Keyword$</code>, with the keyword inside dollar characters (keyword anchor). This is usually replaced by a version-control system with <code>$Keyword: value$</code>, which is a keyword followed by its expansion.</p>
<p class="calibre3">The main problem with doing this in Git is that you cannot modify the file contents stored in the repository with information about the commit after you’ve committed because of the way Git works (more information about this can be found in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>). This <a id="_idIndexMarker201" class="pcalibre1 pcalibre calibre6"/>means that keyword anchors must be stored in the repository as-is, and only expanded in the worktree on checkout. However, this is also an advantage; you would get no spurious differences due to keyword expansion when examining the history.</p>
<p class="calibre3">The only built-in keyword that Git supports is <code>$Id$</code>: its value is the SHA-1 identifier of the file contents (the SHA-1 checksum of the blob object representing the file contents, which is not the same as the SHA-1 of the file; see <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>, to learn how objects are constructed). You need to request this keyword expansion by setting the <code>ident</code> attribute for a file.</p>
<p class="calibre3">However, you can write your keyword expansion support with an appropriate <code>filter</code> while defining the <code>smudge</code> command, which would expand the keyword, and the <code>clean</code> command, which would replace the expanded keyword with its keyword anchor.</p>
<p class="calibre3">With this mechanism you can, for example, implement support for the <code>$Date$</code> keyword, expanding it on checkout to the date when the file was last modified:</p>
<pre class="source-code">
[filter "dater"]
    clean = sed -e 's/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/'
    smudge = expand_date %f</pre>
<p class="calibre3">The <code>expand_date</code> script, which is passed the name of the file as an argument, could run the <code>git log --pretty=format:"%ad" "$1"</code> command to get the substitution value, for example.</p>
<p class="calibre3">However, you need to remember another limitation: for better performance, Git does not touch files that did not change, be it on commit, on switching the branch (on checkout), or on rewinding the branch (on reset). This means that this trick cannot support keyword expansion for the date of the last revision of a project (as opposed to the last revision that changed the file).</p>
<p class="calibre3">If you need to have such information in distributed sources (for example, the description of the current commit, or how long <a id="_idIndexMarker202" class="pcalibre1 pcalibre calibre6"/>it was since the tagged release), you can either make it a part of the build system, or use <code>git archive</code> command. The latter is quite a<a id="_idIndexMarker203" class="pcalibre1 pcalibre calibre6"/> generic feature: if the <code>export-subst</code> attribute is set for a file, Git will expand the <code>$Format:&lt;PLACEHOLDERS&gt;$</code> generalized keyword when adding the file to an archive.</p>
<p class="callout-heading">Limitation of the keyword expansion with export-subst</p>
<p class="callout">The expansion of the <strong class="source-inline1">$Format$</strong> meta-keyword<a id="_idIndexMarker204" class="pcalibre1 pcalibre calibre6"/> depends on the availability of the revision identifier; it cannot be done if you, for example, pass the SHA-1 identifier of a tree object to the <strong class="source-inline1">git </strong><strong class="source-inline1">archive</strong> command.</p>
<p class="calibre3">The placeholders are the same as for the <code>--pretty=format:</code> custom formats for <code>git log</code>, which are described in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>. For example, the <code>$Format:%H$</code> string will be <em class="italic">replaced</em> (not expanded) by the commit hash. It is an irreversible keyword substitution; there is no trace of the keyword in the result of the archive (export) operation.</p>
<h2 id="_idParaDest-59" class="calibre7"><a id="_idTextAnchor061" class="pcalibre1 pcalibre calibre6"/>Other built-in attributes</h2>
<p class="calibre3">You can also tell Git not to add certain files or directories when generating an archive. For example, in the user-facing archive, you may not want to include the directory with distribution tests, which are useful for the developer but not for end users (those tests may require additional tools or checking the quality of the program and processing it rather than checking the correctness<a id="_idIndexMarker205" class="pcalibre1 pcalibre calibre6"/> of the application behavior). This can be done by setting the <code>export-ignore</code> attribute – for example, by adding the following line to the <code>.</code><code>gitattributes</code> file:</p>
<pre class="source-code">
# Do not include extra tests in the archive
xt/  export-ignore</pre>
<p class="calibre3">Another thing that can be configured with file attributes is defining what <code>diff</code> and <code>apply</code> should consider a <code>core.whitespace</code> configuration variable. Note that the list of common whitespace problems to take notice of should use commas as an element separator, without any surrounding whitespace, when put in the <code>.gitattributes</code> file. See the following example (taken from the Git project):</p>
<pre class="source-code">
* whitespace=!indent,trail,space
*.[ch] whitespace=indent,trail,space
*.sh whitespace=indent,trail,space</pre>
<p class="calibre3">With file attributes, you can also specify the <code>encoding</code> attribute. Git can use it to select how to display<a id="_idIndexMarker208" class="pcalibre1 pcalibre calibre6"/> the file in GUI tools (for example, <code>gitk</code> and <code>git gui</code>). This is a fine-grained version of the <code>gui.encoding</code> configuration variable and is only used when explicitly asked for due to performance considerations. For <a id="_idIndexMarker209" class="pcalibre1 pcalibre calibre6"/>example, GNU gettext <strong class="bold">Portable Object</strong> (<strong class="bold">.po</strong>) files holding translations should use the UTF-8 encoding:</p>
<pre class="source-code">
/po/*.po encoding=UTF-8</pre>
<p class="calibre3">To have Git convert between UTF-8 encoding in the staging area and the repository, as well as specify the encoding of a file in the working directory on checkout, you can use the <code>working-tree-encoding</code> attribute. For example, <code>diff</code> and other commands to work correctly, you might want to use the following command:</p>
<pre class="source-code">
*.ps1 text working-tree-encoding=UTF-16LE eol=CRLF</pre>
<p class="callout-heading">Note</p>
<p class="callout">Reencoding might slow down certain Git operations.</p>
<h2 id="_idParaDest-60" class="calibre7"><a id="_idTextAnchor062" class="pcalibre1 pcalibre calibre6"/>Defining attribute macros</h2>
<p class="calibre3">In the <em class="italic">Identifying binary files and end-of-line conversions</em> section, we learned how to mark binary files with the <code>binary</code> attribute. The <code>binary</code> attribute is <a id="_idIndexMarker211" class="pcalibre1 pcalibre calibre6"/>the <code>-diff -merge -text</code> (unsetting three file attributes). It would be nice to define such macros for arbitrary combinations of attributes. There can be more than one pattern matching a given type of file, but one <code>.gitattributes</code> line can contain only one file<a id="_idIndexMarker212" class="pcalibre1 pcalibre calibre6"/> pattern. If we want to have the same attributes for different types of files, attribute macros allow avoiding duplication.</p>
<p class="calibre3">Git allows us to define such macros, but only in top-level <code>.gitattributes</code> files, namely <code>core.attributesFile</code>, <code>.git/info/attributes</code>, or <code>.gitattributes</code> in the main (top-level) directory of a project. The built-in <code>binary</code> macro could have been defined as follows:</p>
<pre class="source-code">
[attr]binary -diff -merge -text</pre>
<p class="calibre3">You can also define your own attributes. In this case, you can use the <code>git check-attr</code> command to programmatically check which attributes are set for a given file, or what the value is of an attribute for a set of files.</p>
<h1 id="_idParaDest-61" class="calibre5"><a id="_idTextAnchor063" class="pcalibre1 pcalibre calibre6"/>Fixing mistakes with the reset command</h1>
<p class="calibre3">At any stage during <a id="_idIndexMarker213" class="pcalibre1 pcalibre calibre6"/>development, you might want to <code>git undo</code> command in core Git, and neither is there support for the universal <code>--undo</code> option in Git commands, though many commands have an <code>--abort</code> option to abandon current <strong class="bold">work in progress</strong> (<strong class="bold">WIP</strong>). One of the<a id="_idIndexMarker214" class="pcalibre1 pcalibre calibre6"/> reasons why there is no such command or option yet is the ambiguity on what needs to be undone (especially for multi-step operations).</p>
<p class="calibre3">Many mistakes can be fixed with the help of the <code>git reset</code> command. It can be used for various purposes and in various ways; understanding how this command works will help you in using it in any situation, which is not limited to the provided example usage.</p>
<p class="calibre3">Note that this section only<a id="_idIndexMarker215" class="pcalibre1 pcalibre calibre6"/> covers the full-tree mode of <code>git reset</code>; the description of what <code>git reset -- &lt;file&gt;</code> does, which is an alternative to using the more modern <code>git restore &lt;file&gt;</code> command, has been left for the <em class="italic">Managing worktree and staging area</em> section at the end of this chapter.</p>
<h2 id="_idParaDest-62" class="calibre7"><a id="_idTextAnchor064" class="pcalibre1 pcalibre calibre6"/>Rewinding the branch head, softly</h2>
<p class="calibre3">The <code>git reset</code> command in its full-tree mode affects the current branch head, and can also affect the index (the staging area) and the <a id="_idIndexMarker216" class="pcalibre1 pcalibre calibre6"/>working directory. This reset does not change which branch is current, as opposed to <code>git checkout</code> or <code>git switch</code>.</p>
<p class="calibre3">To reset only the current branch head and not touch the index or the working tree, you can use <code>git reset --soft [&lt;revision&gt;]</code> (if a revision is not given, it defaults to <code>HEAD</code>):</p>
<div><div><img alt="Figure 3.3 – Before and after a soft reset" src="img/B21194_03_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Before and after a soft reset</p>
<p class="calibre3">Effectively, we are just changing the pointer of the current branch (<code>master</code> in the example shown in <em class="italic">Figure 3</em><em class="italic">.3</em>) to point to a given revision (<code>HEAD^</code> – the previous commit in the example). Neither the staging area nor the working directory is affected. This leaves all your changed files (and all files that differ between the old and new revision pointed by branch) in the <code>git status</code> would put it.</p>
<h3 class="calibre9">Removing or amending a commit</h3>
<p class="calibre3">The way the<a id="_idIndexMarker217" class="pcalibre1 pcalibre calibre6"/> command works means that a <code>--amend</code> option of <code>git commit</code>.</p>
<p class="calibre3">Let’s take a look at the        following command:</p>
<pre class="console">
$ git commit --amend [&lt;options&gt;]</pre>
<p class="calibre3">This is equivalent to the following:</p>
<pre class="console">
$ git reset --soft HEAD^
$ git commit --reedit-message=ORIG_HEAD [&lt;options&gt;]</pre>
<p class="calibre3">The <code>git commit --amend</code> command also works for merge commits as opposed to using a soft reset. When amending a commit, if you want to just fix the commit message, there will be no additional options. If you want to include a fix from the working directory without changing the commit message, you can add <code>--all --no-edit</code>. If you want to fix the authorship information after correcting the Git configuration, use <code>--</code><code>reset-author --no-edit</code>.</p>
<p class="calibre3">You learned how amending a commit changes the graph of revisions in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing With Git</em>, in the <em class="italic">Amending a </em><em class="italic">commit</em> section.</p>
<h3 class="calibre9">Squashing commits with reset</h3>
<p class="calibre3">You are not limited to<a id="_idIndexMarker220" class="pcalibre1 pcalibre calibre6"/> rewinding the branch head to just the previous commit. Using a soft reset, you can squash a few earlier commits (for example, commit and bugfix, or introducing new functionality and using it), making one commit out of two (or more); alternatively, you can instead use the <code>squash</code> instruction of <code>merge --squash</code> for this.</p>
<h2 id="_idParaDest-63" class="calibre7"><a id="_idTextAnchor065" class="pcalibre1 pcalibre calibre6"/>Resetting the branch head and the index</h2>
<p class="calibre3">The default mode of reset <a id="_idIndexMarker222" class="pcalibre1 pcalibre calibre6"/>command – the so-called <strong class="bold">mixed reset</strong> (because it is between the soft and <a id="_idIndexMarker223" class="pcalibre1 pcalibre calibre6"/>hard forms) – changes the current branch<a id="_idIndexMarker224" class="pcalibre1 pcalibre calibre6"/> head so that it points to a given revision, and also resets the index, putting the contents of that revision into the staging area. This mode is shown in <em class="italic">Figure 3</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 3.4 – Before and after a mixed reset" src="img/B21194_03_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Before and after a mixed reset</p>
<p class="calibre3">This leaves all your <a id="_idIndexMarker225" class="pcalibre1 pcalibre calibre6"/>changed files (and all files that differ between the old and new revision pointed by branch) in the <code>git status</code> would put it. The <code>git reset --mixed</code> command will also report<a id="_idIndexMarker226" class="pcalibre1 pcalibre calibre6"/> what has not been updated using the short status format:</p>
<pre class="console">
$ git reset HEAD^
Unstaged changes after reset:
M       README.md</pre>
<p class="calibre3">This version of the <code>reset</code> command can be used, for example, to undo all additions of new files. This can be done by running <code>git reset</code>, if you didn’t stage any changes (or that you can put up with losing them). If you want to un-add a particular file, use <code>git rm --</code><code>cached &lt;file&gt;</code>.</p>
</div>


<div><h3 class="calibre9">Splitting a commit in two with reset</h3>
<p class="calibre3">You can use a mixed reset to split a commit in two. First, run <code>git reset HEAD^</code> to reset the branch head and the index to<a id="_idIndexMarker227" class="pcalibre1 pcalibre calibre6"/> the previous revision. Then, interactively add changes that you want to have in the first commit, and then create this first commit from the index (<code>git add -i</code> and <code>git commit</code>). A second commit can then be created from the working directory state (<code>git </code><code>commit -a</code>).</p>
<p class="calibre3">If it is easier to interactively remove changes, that’s also an option. Use <code>git reset --soft HEAD^</code>, interactively un-stage changes with an interactive per-file reset, create the first commit from the constructed state in the index, and create the second commit from the working directory.</p>
<p class="calibre3">Here, again, like for<a id="_idIndexMarker228" class="pcalibre1 pcalibre calibre6"/> squashing commits, you can use the interactive rebase to split commits further in the history. The rebase operation will switch to the appropriate commit, at which point the actual splitting can be done, as described here.</p>
<h3 class="calibre9">Saving and restoring state with the WIP commit</h3>
<p class="calibre3">Suppose you are interrupted by <a id="_idIndexMarker229" class="pcalibre1 pcalibre calibre6"/>an urgent bugfix request while you are in the middle of work on the development branch. You don’t want to lose your changes, but the worktree is a bit of a mess, and you are unable to finish the commit in time. One possible solution is to save the current state of the working area by creating a temporary commit:</p>
<pre class="console">
$ git commit -a -m 'snapshot WIP (Work In Progress)'</pre>
<p class="calibre3">Then, you can handle the interruption, switching to the maintenance branch and creating a commit to fix the issue. At this point, you need to go back to the previous branch (by using checkout), remove the WIP commit from the history (using a soft reset), and go back to the un-staged starting state (with a mixed reset), as follows:</p>
<pre class="console">
$ git switch -
$ git reset --soft HEAD^
$ git reset</pre>
<p class="calibre3">Usually, though it is much easier to just use <code>git stash</code> instead to handle interruptions, see the <em class="italic">Stashing away your changes</em> section in this chapter. On the other hand, such temporary commits can be shared with other developers, as opposed to stash (because stash stack is based on purely local data – the reflog).</p>
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor066" class="pcalibre1 pcalibre calibre6"/>Discarding changes and rewinding the branch</h2>
<p class="calibre3">Sometimes, your files will get in<a id="_idIndexMarker230" class="pcalibre1 pcalibre calibre6"/> such a mess that you want to discard all changes <a id="_idIndexMarker231" class="pcalibre1 pcalibre calibre6"/>and return the working directory and the staging area (the index) to the last committed state to the last good version. In other cases, you might want to rewind the state of the repository to an earlier version. In such instances, a <strong class="bold">hard reset</strong> is what you need; it will change the current branch head<a id="_idIndexMarker232" class="pcalibre1 pcalibre calibre6"/> while resetting the index and the working tree. Any changes to any tracked <a id="_idIndexMarker233" class="pcalibre1 pcalibre calibre6"/>files will be discarded:</p>
<div><div><img alt="Figure 3.5 – Before and after a hard reset" src="img/B21194_03_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Before and after a hard reset</p>
<p class="calibre3">This command can be used to undo a commit as if it had never happened, by removing it. Running <code>git reset --hard HEAD^</code> will effectively discard the last commit (though it will be available for a limited time via reflog) unless this commit can be reached from some other branch.</p>
<p class="calibre3">Another common usage is to discard changes to the working directory with <code>git reset --hard</code>, which resets to the last committed state.</p>
<p class="callout-heading">Important note</p>
<p class="callout">It is very important to remember that a hard reset would irrecoverably remove all changes from the staging area and working directory. You cannot undo this part of the operation! Changes are lost forever!</p>
<h3 class="calibre9">Moving commits to a feature branch</h3>
<p class="calibre3">Say that you<a id="_idIndexMarker234" class="pcalibre1 pcalibre calibre6"/> were working on something on the <code>master</code> branch, and you have already created a sequence of commits. You have realized that the feature you are working on is more involved, and you want to continue polishing it on a separate topic branch, as described in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>. You want to move all those commits that are in <code>master</code> (let’s say, the last three revisions) to the aforementioned feature branch.</p>
<p class="calibre3">You need to create the feature branch, save uncommitted changes (if any), rewind the <code>master</code> branch while <a id="_idIndexMarker235" class="pcalibre1 pcalibre calibre6"/>removing those topical commits from it, and switch to the feature branch to continue working (or you can use rebase instead):</p>
<pre class="console">
$ git branch feature/topic
$ git stash
No local changes to save
$ git reset --hard HEAD~3
HEAD is now at f82887f before
$ git switch feature/topic
Switched to branch 'feature/topic'</pre>
<p class="calibre3">Of course, if there were local changes to save (there were none in the preceding example), this preceding series of commands would have to be followed by <code>git </code><code>stash pop</code>.</p>
<h3 class="calibre9">Undoing a merge or a pull</h3>
<p class="calibre3">Hard resets can also be used to abort a failed merge. You can use <code>git reset --hard HEAD</code> (here, <code>HEAD</code> is the default value for revision and can be omitted), for example, if you decide<a id="_idIndexMarker236" class="pcalibre1 pcalibre calibre6"/> that you don’t want to resolve the merge conflict at this time (though with modern Git you can use <code>git merge --</code><code>abort</code> instead).</p>
<p class="calibre3">You can also remove a successful fast-forward pull or undo a rebase (and many other operations while moving the branch head) with <code>git reset --hard ORIG_HEAD</code>. (Here, you can use <code>HEAD@{1}</code> instead of <code>ORIG_HEAD</code>.)</p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor067" class="pcalibre1 pcalibre calibre6"/>Safer reset – keeping your changes</h2>
<p class="calibre3">A hard reset will discard <a id="_idIndexMarker237" class="pcalibre1 pcalibre calibre6"/>your local changes, similar to how <code>git switch --discard-changes</code> or <code>git checkout --force</code> would. Sometimes, you might want to rewind the current branch while keeping the local changes: that’s what <code>git reset --keep</code> is for.</p>
<div><div><img alt="Figure 3.6 – Before and after a successful git reset --keep HEAD^ command" src="img/B21194_03_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Before and after a successful git reset --keep HEAD^ command</p>
<p class="calibre3">This mode resets the staging<a id="_idIndexMarker238" class="pcalibre1 pcalibre calibre6"/> area (index entries) but retains the unstaged (local) changes that are currently in the working directory; see <em class="italic">Figure 3</em><em class="italic">.6</em>. If it is not possible, the reset operation is aborted:</p>
<pre class="console">
$ git reset --keep HEAD^
error: Entry 'README' not uptodate. Cannot merge.
fatal: Could not reset index file to revision 'HEAD^'.</pre>
<p class="calibre3">This means that local changes in the worktree are preserved and moved to the new commit, in a similar way to how <code>git checkout &lt;branch&gt;</code> works with uncommitted changes. The successful case is a bit like stashing changes away, hard resetting, and then unstashing (but with a single atomic command).</p>
<p class="callout-heading">How does safe reset work?</p>
<p class="callout">The way <strong class="source-inline1">git reset --keep &lt;revision&gt;</strong> works is by updating the version (in the working directory) of only those files that are <a id="_idIndexMarker239" class="pcalibre1 pcalibre calibre6"/>different between the revision we rewind to and <strong class="source-inline1">HEAD</strong>. The reset is aborted if there is any file that is different between <strong class="source-inline1">HEAD</strong> and <strong class="source-inline1">&lt;revision&gt;</strong> (and thus would need to be updated) and has local uncommitted changes.</p>
<h3 class="calibre9">Rebasing current changes to an earlier revision</h3>
<p class="calibre3">Suppose that you are working on something but you realize that what you have in your working directory should be in another branch, unrelated to a previous commit. For example, you might have started <a id="_idIndexMarker240" class="pcalibre1 pcalibre calibre6"/>to work on a bug while on the <code>master</code> branch, and only then realized that it also affects the maintenance branch, <code>maint</code>.</p>
<p class="calibre3">This means that the fix should be put earlier in a branch, starting from the common ancestor of those branches (or a place where the bug was introduced). This would make it possible to merge the same fix both into <code>master</code> and <code>maint</code>, as described in <a href="B21194_15.xhtml#_idTextAnchor371" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 15</em></a>, <em class="italic">Git </em><em class="italic">Best Practices</em>:</p>
<pre class="console">
$ edit
$ git checkout -b bugfix-127
$ git reset --keep start</pre>
<p class="calibre3">An alternate solution would be to simply use <code>git stash</code> to move changes:</p>
<pre class="console">
$ edit
$ git stash
$ git switch -c bugfix-127 start
$ git stash pop</pre>
<h1 id="_idParaDest-66" class="calibre5"><a id="_idTextAnchor068" class="pcalibre1 pcalibre calibre6"/>Stashing away your changes</h1>
<p class="calibre3">Often, when you’ve been working on a project, and things are in a messy state not suitable for a permanent commit, you want to temporarily save the current state and go to work on something else. The answer to this problem is the <code>git </code><code>stash</code> command.</p>
<p class="calibre3">Stashing takes the <a id="_idIndexMarker241" class="pcalibre1 pcalibre calibre6"/>dirty state of your working area – that is, your modified <em class="italic">tracked</em> files in your worktree and the state of the staging area – saves this state, and resets both the working directory and the index to the last committed version (to match the <code>HEAD</code> commit), effectively running <code>git reset --hard HEAD</code>. You can then reapply the stashed changes at any time.</p>
<p class="calibre3">You can also stash <em class="italic">untracked</em> files with the <code>--</code><code>include-untracked</code> option.</p>
<p class="calibre3">Stashes are saved on a stack: by default, you apply the last stashed changes (<code>stash@{0}</code>), though you can list stashed changes (with <code>git stash list</code>) and explicitly select any of the stashes.</p>
<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor069" class="pcalibre1 pcalibre calibre6"/>Using git stash</h2>
<p class="calibre3">If you don’t expect the interruption to last long, you can simply <strong class="bold">stash away</strong> your changes, handle the<a id="_idIndexMarker242" class="pcalibre1 pcalibre calibre6"/> interruption, and then unstash them:</p>
<pre class="console">
$ git stash
$ # ... handle interruption ...
$ git stash pop</pre>
<p class="calibre3">By default, <code>git stash pop</code> will apply the last stashed changes and delete the stash if applied successfully. To see what stashes you have stored, you can use <code>git </code><code>stash list</code>:</p>
<pre class="console">
$ git stash list
stash@{0}: WIP on master: 049d078 atoi() is deprecated
stash@{1}: WIP on master: c264051 Add error checking</pre>
<p class="calibre3">You can use any of the older stashes by specifying the stash name as an argument, or simply its number. For example, you can run <code>git stash apply stash@{1}</code> or <code>git stash apply 1</code> to apply it, and you can drop it (remove it from the list of stashes) with <code>git stash drop stash@{1}</code> or <code>git stash drop 1</code>; the <code>git stash pop</code> command is just a shortcut for <code>apply</code> + <code>drop</code>.</p>
<p class="calibre3">The default description that Git gives to stashed changes (namely <code>git stash show -p</code>. But if you expect that the interruption might be more involved, you should save the current state to a stash while describing what you were working on:</p>
<pre class="console">
$ git stash push -m 'Add &lt;count&gt;'
Saved working directory and index state On master: Add &lt;count&gt;
HEAD is now at 049d078 atoi() is deprecated</pre>
<p class="calibre3">Git would then use the provided message to describe stashed changes when listing stashes:</p>
<pre class="console">
$ git stash list
stash@{0}: On master: Add &lt;count&gt;
stash@{1}: WIP on master: c264051 Add error checking</pre>
<p class="calibre3">Sometimes, the branch you were working on when you ran <code>git stash save</code> has changed enough that <code>git stash pop</code> fails because there are too many new revisions past the commit you were on when stashing the changes. If you want to create a regular commit out of the<a id="_idIndexMarker243" class="pcalibre1 pcalibre calibre6"/> stashed changes, or just test stashed changes, you can use <code>git stash branch &lt;branch name&gt;</code>. This will create a new branch at the revision you were at when saving the changes, switch to this branch, reapply your work there, and drop stashed changes.</p>
<h2 id="_idParaDest-68" class="calibre7"><a id="_idTextAnchor070" class="pcalibre1 pcalibre calibre6"/>Stash and the staging area</h2>
<p class="calibre3">By default, stashing resets both the working directory and the staging area to the  <code>HEAD</code> version. You can make <code>git stash</code> keep the state of the index and reset the working area to the staged<a id="_idIndexMarker244" class="pcalibre1 pcalibre calibre6"/> state with the <code>--</code><code>keep-index</code> option:</p>
<div><div><img alt="Figure 3.7 – The difference between git stash with and without --keep-index" src="img/B21194_03_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.7 – The difference between git stash with and without --keep-index</p>
<p class="calibre3">This is very useful if you used the staging area to untangle changes in the working directory, as described in the <em class="italic">Selective commit</em> section in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>,<em class="italic"> Developing with Git</em>, or if you want to split the commit in two, as described in the <em class="italic">Splitting a commit with reset</em> section in this chapter. In both cases, you would want to test each change before committing.</p>
<p class="calibre3">The workflow would look like this:</p>
<pre class="console">
$ git add --interactive
$ git stash --keep-index
$ make test
$ git commit -m 'First part'
$ git stash pop</pre>
<p class="calibre3">You can also use <code>git stash --patch</code> to select how the working area should look after stashing away the changes.</p>
<p class="calibre3">When restoring stashed<a id="_idIndexMarker245" class="pcalibre1 pcalibre calibre6"/> changes, Git will ordinarily try to apply only saved worktree changes, adding them to the current state of the working directory (which must match the staging area). If there are conflicts while applying the state, they are stored in the index as usual – Git won’t drop the stash if there are conflicts.</p>
<p class="calibre3">You can also try to restore the saved state of the staging area with the <code>--index</code> option; this will fail if there are conflicts when you’re applying working tree changes (because there is no place to store conflicts since the staging area is busy).</p>
<h2 id="_idParaDest-69" class="calibre7"><a id="_idTextAnchor071" class="pcalibre1 pcalibre calibre6"/>Stash internals</h2>
<p class="calibre3">Perhaps you applied stashed <a id="_idIndexMarker246" class="pcalibre1 pcalibre calibre6"/>changes, did some work, and then for some reason want to un-apply those changes that originally came from the stash. Maybe you mistakenly dropped the stash or cleared all stashes (which you can do with <code>git stash clear</code>) and would like to recover them. Or perhaps you want to see how the file looked when you stashed away changes. To do any of this, you will need to know what Git does when creating a stash entry.</p>
<p class="calibre3">To stash away your changes, Git creates two automatic commits: one for the index (staging area) and one for the working directory. With <code>git stash --include-untracked</code>, Git creates an additional third automatic commit for untracked files.</p>
<p class="calibre3">The commit containing the work in progress (WIP) in the working directory (the state of files tracked from there) has the commit with the contents of the staging area (the index) as its second parent. This WIP containing commit is stored in a special ref: <code>refs/stash</code>. Both the WIP (stash) and index commits have the revision you were on when saving changes as their first parent.</p>
<p class="calibre3">We can see this by running <code>git log --graph</code> or <code>gitk --all</code>:</p>
<pre class="console">
$ git stash save --quiet 'Add &lt;count&gt;'
$ git show-ref --abbrev
765b095 refs/heads/master
81ef667 refs/stash
$ gitk --all</pre>
<p class="calibre3">This can be seen in the following figure:</p>
<div><div><img alt="Figure 3.8 – The structure of the stash without and with untracked file information. Graphs were generated with gitk --all on a newly created repository with a single commit and a stash" src="img/B21194_03_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.8 – The structure of the stash without and with untracked file information. Graphs were generated with gitk --all on a newly created repository with a single commit and a stash</p>
<p class="calibre3">We had to use <code>git show-ref</code> here (we could have used <code>git for-each-ref</code> instead) because <code>git branch -a</code> only shows branches, not arbitrary refs.</p>
<p class="calibre3">When saving <a id="_idIndexMarker247" class="pcalibre1 pcalibre calibre6"/>untracked changes, with <code>git stash --include-untracked</code>, the situation is similar. <em class="italic">Figure 3</em><em class="italic">.8</em> shows that the untracked file commit is the third parent of the WIP commit and that it doesn’t have any parents. It only consists of untracked files, which you can check with <code>git ls-tree -</code><code>r stash@{&lt;n&gt;}^3</code>.</p>
<p class="calibre3">Well, that’s how stashing works, but how does Git maintain the stack of stashes? You may have noticed that the <code>git stash list</code> output and the <code>stash@{&lt;n&gt;}</code> notation therein looks like reflog; Git finds older stashes in the reflog for the <code>refs/stash</code> reference:</p>
<pre class="console">
$ git reflog stash --no-decorate
81ef667 stash@{0}: On master: Add &lt;count&gt;
bb76632 stash@{1}: WIP on master: Added .gitignore</pre>
<p class="calibre3">This is why you cannot <a id="_idIndexMarker248" class="pcalibre1 pcalibre calibre6"/>share the stack of stashes: reflogs are local to the repository and are not and cannot be synchronized when pushing or fetching.</p>
<h3 class="calibre9">Un-applying a stash</h3>
<p class="calibre3">Let’s take the first example from the beginning of this section: un-applying changes from the earlier <code>git stash apply</code>. One possible <a id="_idIndexMarker249" class="pcalibre1 pcalibre calibre6"/>solution to achieve the required effect is to retrieve the patch associated with working directory changes from a stash, and apply it in reverse:</p>
<pre class="console">
$ git stash show -p stash@{0} | git apply -R -</pre>
<p class="calibre3">Note the <code>-p</code> option that was applied to the <code>git stash show</code> command – it forces patch output instead of a summary of changes. We could use <code>git show -m stash@{0}</code> (the <code>-m</code> option is necessary because a WIP commit representing the stash is a merge commit), or even simply <code>git diff stash@{0}^-1</code>, in place of <code>git stash </code><code>show -p</code>.</p>
<h3 class="calibre9">Recovering stashes that were dropped erroneously</h3>
<p class="calibre3">Let’s try the second example: recovering<a id="_idIndexMarker250" class="pcalibre1 pcalibre calibre6"/> stashes that were accidentally dropped or cleared. If they are still in your repository and were not removed during the repository maintenance phase, you can search all commit objects that are unreachable from other refs and look like stashes (that is, they are merged commits and have a commit message using a strict pattern).</p>
<p class="calibre3">A simplified solution<a id="_idIndexMarker251" class="pcalibre1 pcalibre calibre6"/> might look like this:</p>
<pre class="console">
$ git fsck --unreachable |
grep "unreachable commit " | cut -d" " -f3 |
git log --stdin --merges --no-walk --grep="WIP on "</pre>
<p class="calibre3">The first line of this pipeline finds all unreachable (lost) objects, the second one filters out everything but commits and extracts their SHA-1 identifiers, and the third line filters out even more, showing only merge commits with a commit message containing the <code>"WIP on "</code> string.</p>
<p class="calibre3">This solution would not, however, find stashes with a custom message (those created with <code>git stash save "message"</code>); you would need to add another <code>--grep</code>.</p>
<h1 id="_idParaDest-70" class="calibre5"><a id="_idTextAnchor072" class="pcalibre1 pcalibre calibre6"/>Managing worktrees and the staging area</h1>
<p class="calibre3">In <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>, we learned that, besides the <em class="italic">working directory</em> (<em class="italic">worktree</em>) where you work on changes and the local repository where you store committed changes as revisions, there is also a third section between them: the <em class="italic">staging area</em>, sometimes called the <em class="italic">index</em>.</p>
<p class="calibre3">In the same chapter, we learned how to examine the status of the working directory, as well as how to view the differences. We saw <a id="_idIndexMarker252" class="pcalibre1 pcalibre calibre6"/>how to create a new commit out of the working directory or out of the staging area.</p>
<p class="calibre3">Now, it is time to learn how to examine and modify the state of individual files.</p>
<h2 id="_idParaDest-71" class="calibre7"><a id="_idTextAnchor073" class="pcalibre1 pcalibre calibre6"/>Examining files and directories</h2>
<p class="calibre3">It is easy to examine the<a id="_idIndexMarker253" class="pcalibre1 pcalibre calibre6"/> contents of the working directory: you can just use the standard tools for viewing files (for example, an editor or pager) and examining directories (for example, a file manager or the <code>dir</code> command). But how do we view the staged contents of a file or the last committed version?</p>
<p class="calibre3">One possible solution is to use the <code>git show</code> command with the appropriate selector. <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>, will introduce and explain the <code>&lt;revision&gt;:&lt;pathname&gt; </code>syntax to examine the contents of a file at a given revision. A similar syntax can be used to retrieve the staged contents, namely <code>:&lt;pathname&gt;</code> (or <code>:&lt;stage&gt;:&lt;pathname&gt;</code> if there is a merge conflict involving the given file; <code>:&lt;pathname&gt;</code> in itself is equivalent to <code>:0:&lt;pathname&gt;</code>).</p>
<p class="calibre3">Let’s assume that we are in the <code>src/</code> subdirectory and want to see the contents of the <code>rand.c</code> file there as it’s in the working directory, in the staging area (using the absolute and relative path), and in the last commit (also using the absolute and the relative path):</p>
<pre class="console">
src $ less -FRX rand.c
src $ git show :src/rand.c
src $ git show :./rand.c
src $ git show HEAD:src/rand.c
src $ git show HEAD:./rand.c</pre>
<p class="calibre3">To see the list of files that are staged in the index, there is the <code>git ls-files</code> command. By default, it operates on the staging area contents, but it can also be used to examine the working directory. The latter feature can, as we have seen in this chapter, be used to list ignored files. This command lists all files in the specified directory. Alternatively, in the<a id="_idIndexMarker254" class="pcalibre1 pcalibre calibre6"/> current directory, you can use <code>:/</code> to denote the top-level directory of a project. The recursive behavior is caused by the fact that the index is a flat list of files, similar to <code>MANIFEST</code> files.</p>
<p class="calibre3">Without using the <code>--full-name</code> option, it would show filenames relative to the current directory (or the one specified as a parameter). In all examples, it is assumed that we are in the <code>src/</code> subdirectory, as seen in the command prompt:</p>
<pre class="console">
src $ git ls-files
rand.c
src $ git ls-files --full-name :/
COPYRIGHT
Makefile
README
src/rand.c</pre>
<p class="calibre3">What about committed changes? How can we examine which files were in a given revision? This is where <code>git ls-tree</code> comes to the rescue (note that it is a plumbing command and does not default to the <code>HEAD</code> revision):</p>
<pre class="console">
src $ git ls-tree --name-only HEAD
rand.c
src $ git ls-tree --abbrev --full-tree -r -t HEAD
100644 blob 862aafd     COPYRIGHT
100644 blob 25c3d1b     Makefile
100644 blob bdf2c76     README
040000 tree 7e44d2e     src
100644 blob b2c087f     src/rand.c</pre>
<p class="calibre3">Note that <code>git ls-tree</code> is not recursive by default; you need to use the <code>-</code><code>r</code> option.</p>
<h2 id="_idParaDest-72" class="calibre7"><a id="_idTextAnchor074" class="pcalibre1 pcalibre calibre6"/>Searching file contents</h2>
<p class="calibre3">Let’s assume that you were reviewing <a id="_idIndexMarker255" class="pcalibre1 pcalibre calibre6"/>code in the project and noticed an erroneous doubled semicolon, <code>;;</code>, in the C source code. Or perhaps you were editing the file and noticed a bug nearby. You fixed it, but you’re wondering, “<em class="italic">How many of those mistakes are there?</em>” You would like to create a commit to fix such errors.</p>
<p class="calibre3">Or perhaps you want to search the version that was scheduled for the next commit – that is the contents of the staging area. Perhaps you want to examine how it looks in the <code>next</code> branch.</p>
<p class="calibre3">With Git, you can use the <code>git </code><code>grep</code> command:</p>
<pre class="console">
$ git grep -e ';;'</pre>
<p class="calibre3">By default, this command will search tracked files in the working directory, from the current directory downwards, recursively. Note that when running the example command, we will get many false positives from shell scripts, for example. So, let’s limit the search space to only C source files:</p>
<pre class="console">
$ git grep -e ';;' -- '*.c'</pre>
<p class="calibre3">The quotes around <code>*.c</code> are necessary for Git to do the glob pattern expansion (path limiting) instead of <code>git grep</code> getting the list of files expanded by the shell. We still have many false matches from the forever loop C idiom:</p>
<pre class="source-code">
for (;;) {</pre>
<p class="calibre3">With <code>git grep</code>, you <a id="_idIndexMarker256" class="pcalibre1 pcalibre calibre6"/>can construct complex conditions, excluding false positives. Say that we want to search the whole project, not only the current directory, and avoid false positives:</p>
<pre class="console">
$ git grep -e ';;' --and --not 'for *(.*;;' -- '**/*.c'</pre>
<p class="calibre3">To search the staging area, use <code>git grep --cached</code> or the equivalent – and perhaps easier to remember – <code>git grep --staged</code>. To search the <code>next</code> branch, use <code>git grep next --</code>; this construction can be used to search any version.</p>
<h2 id="_idParaDest-73" class="calibre7"><a id="_idTextAnchor075" class="pcalibre1 pcalibre calibre6"/>Un-tracking, un-staging, and un-modifying files</h2>
<p class="calibre3">If you want to undo<a id="_idIndexMarker257" class="pcalibre1 pcalibre calibre6"/> some file-level operation (if, for example, you have changed your mind about<a id="_idIndexMarker258" class="pcalibre1 pcalibre calibre6"/> tracking files or staging changes), then look <a id="_idIndexMarker259" class="pcalibre1 pcalibre calibre6"/>no further than <code>git status</code> hints (add <code>--ignored</code> to get advice about ignored files):</p>
<pre class="console">
$ git status --ignored
On branch master
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
Ignored files:
  (use "git add -f &lt;file&gt;..." to include in what will be committed)</pre>
<p class="calibre3">You need to remember that only the contents of the working directory and the staging area can be changed. Committed changes are immutable (though you can <em class="italic">rewind</em> the history or replace it).</p>
<p class="calibre3">If you want to undo adding a previously untracked file to the index – or remove a formerly tracked file from the staging area so that it will be deleted (not present) in the next commit while keeping it in the working directory – use <code>git rm --</code><code>cached &lt;file&gt;</code>.</p>
<p class="callout-heading">The difference between the --cached (--staged) and --index options</p>
<p class="callout">Many Git commands, including <strong class="source-inline1">git diff</strong>, <strong class="source-inline1">git grep</strong>, and <strong class="source-inline1">git rm</strong>, support the <strong class="source-inline1">--cached</strong> option (or its alias, <strong class="source-inline1">--staged</strong>). Others, such as <strong class="source-inline1">git stash</strong>, have the <strong class="source-inline1">--index</strong> option (the index is an alternate name for the staging area). These are <em class="italic">not</em> synonyms (as we <a id="_idIndexMarker260" class="pcalibre1 pcalibre calibre6"/>will later see with <strong class="source-inline1">git apply</strong> command, which supports both).</p>
<p class="callout">The <strong class="source-inline1">--cached</strong> option is used to<a id="_idIndexMarker261" class="pcalibre1 pcalibre calibre6"/> ask the command that usually works on files in the working directory to <em class="italic">only</em> work on the staged contents <em class="italic">instead</em>. For example, <strong class="source-inline1">git grep --cached</strong> will search the staging area instead of the working directory, and <strong class="source-inline1">git rm --cached</strong> will only remove a file from the index, leaving it in the<a id="_idIndexMarker262" class="pcalibre1 pcalibre calibre6"/> worktree.</p>
<p class="callout">The <strong class="source-inline1">--index</strong> option is used to ask the command that usually works on files in the working directory to <em class="italic">also</em> affect the index, <em class="italic">additionally</em>. For example, <strong class="source-inline1">git stash apply --index</strong> not only restores stashed working directory changes but also restores the index.</p>
<p class="calibre3">If you asked Git to record the state of some file in the staging area but changed your mind, you can reset the staged contents of the file to the committed version with <code>git restore --staged &lt;file&gt;</code> (<code>--source=HEAD</code> is the default) or <code>git reset HEAD -- &lt;</code><code>file&gt;</code>.</p>
<p class="calibre3">If you edited a file incorrectly <a id="_idIndexMarker263" class="pcalibre1 pcalibre calibre6"/>to the point that the working directory version is a mess and you want to restore it to the version from the index, use <code>git restore &lt;file&gt;</code> (<code>--worktree</code> is the default if <code>--staged</code> is not given) or <code>git checkout -- &lt;file&gt;</code>. If you staged some of this mess and would like to reset both the worktree and the staging area to the last committed version, use <code>git restore --worktree --staged &lt;file&gt;</code> or <code>git checkout HEAD -- &lt;</code><code>file&gt;</code> instead.</p>
<p class="callout-heading">Important note</p>
<p class="callout">These commands do <em class="italic">not undo operations</em>; they restore the previous state based on a backup that is the worktree, the index, or the committed version. For example, if you staged some changes, modified a file, and then added modifications to the staging area, you can reset the index to the committed version, but not to the state after the first and before the second <strong class="source-inline1">git add</strong>.</p>
<h2 id="_idParaDest-74" class="calibre7"><a id="_idTextAnchor076" class="pcalibre1 pcalibre calibre6"/>Resetting a file to the old version</h2>
<p class="calibre3">You can use any revision<a id="_idIndexMarker264" class="pcalibre1 pcalibre calibre6"/> when restoring a file, with a per-file reset and per-file checkout. For example, to replace the current worktree version of the <code>src/rand.c</code> file with the one from the previous commit, you can use <code>git restore -s HEAD^ src/rand.c</code> or <code>git checkout HEAD^ -- src/rand.c</code> (or redirect the output of <code>git show HEAD^:src/rand.c</code> to a file). To put the version from the <code>next</code> branch into the staging area, run <code>git restore -s next src/rand.c</code> or <code>git reset next -- </code><code>src/rand.c</code>.</p>
<p class="calibre3">Note that <code>git add &lt;file&gt;</code>,  <code>git restore &lt;file&gt;</code>, <code>git reset &lt;file</code>&gt;, and <code>git checkout &lt;file&gt;</code> all enter interactive mode for a given file when invoked with the <code>--patch</code> option. This can be used to hand-craft a staged or worktree version of a file by selecting which changes should be applied (or un-applied).</p>
<p class="callout-heading">Tip</p>
<p class="callout">When using Git from the command line, you might need to put a double dash, <strong class="source-inline1">--</strong>, after other options and before the filename if, for example, you have a file with the same name as a branch.</p>
<h2 id="_idParaDest-75" class="calibre7"><a id="_idTextAnchor077" class="pcalibre1 pcalibre calibre6"/>Cleaning the working area</h2>
<p class="calibre3">Untracked files and directories may pile up in your working directory. They can be leftovers from merges or be <a id="_idIndexMarker265" class="pcalibre1 pcalibre calibre6"/>temporary files, proof of concept work, or perhaps mistakenly put there. Whatever the case, often, there is no pattern to them, and you don’t need and don’t want to make Git ignore them (see the <em class="italic">Ignoring files</em> section of this chapter); you just want to remove them. You can use the <code>git clean</code> command for that.</p>
<p class="calibre3">Because untracked files do not have a backup in the repository, and you cannot undo their removal (unless the operating system or the filesystem supports undo or trashcan), it’s advisable to first check which files <em class="italic">can be removed</em> with <code>--dry-run</code>/<code>-n</code>. By default, actual removal requires the <code>--</code><code>force</code>/<code>-f</code> option:</p>
<pre class="console">
$ git clean --dry-run
Would remove patch-1.diff</pre>
<p class="calibre3">Git will clean all untracked files recursively, starting from the current directory. You can select which paths are affected by listing them as an argument; you can also exclude additional types of<a id="_idIndexMarker266" class="pcalibre1 pcalibre calibre6"/> files with the <code>--exclude=&lt;pattern&gt;</code> option. You can also interactively select which untracked files to delete with the <code>--</code><code>interactive</code> option:</p>
<pre class="console">
$ git clean --interactive
Would remove the following items:
  src/rand.c~
  screenlog.0
*** Commands ***
    1: clean       2: filter by pattern    3: select by numbers
    4: ask each    5: quit                 6: help
What now&gt;</pre>
<p class="calibre3">The <code>clean</code> command also allows us to only remove ignored files, for example, to remove build products but keep manually tracked files, with the <code>-X</code> option. However, usually, it is better to<a id="_idIndexMarker267" class="pcalibre1 pcalibre calibre6"/> leave removing build byproducts to the build system, so that the project files can be cleaned without having to clone the repository.</p>
<p class="calibre3">You can also use <code>git clean -x</code> in conjunction with <code>git reset --hard</code> to create a pristine working directory to test a clean build by removing both ignored and not-ignored untracked files and resetting tracked files to the committed version.</p>
<h2 id="_idParaDest-76" class="calibre7"><a id="_idTextAnchor078" class="pcalibre1 pcalibre calibre6"/>Multiple working directories</h2>
<p class="calibre3">For a long time, Git allowed you to <a id="_idIndexMarker268" class="pcalibre1 pcalibre calibre6"/>specify where to find the administrative area of the repository (the <code>.git</code> directory). This can be done by appending the <code>--git-dir=&lt;path&gt;</code> option to the <code>git</code> command (that is, the <code>git --git-dir=&lt;path&gt; &lt;command&gt;</code> construct), or by setting the <code>GIT_DIR</code> environment variable. This feature makes it possible to<a id="_idIndexMarker269" class="pcalibre1 pcalibre calibre6"/> work from the <strong class="bold">detached </strong><strong class="bold">working directory</strong>.</p>
<p class="calibre3">With modern Git, you have a better solution to creating a new linked work tree than manual configuration: <code>git worktree add &lt;path&gt; &lt;branch&gt;</code>. This feature allows us to have more than one branch checked out. For convenience, if you omit the <code>&lt;branch&gt;</code> argument, then the new branch will be created based on the name of the created worktree.</p>
<p class="calibre3">This mechanism can be used instead of <code>git stash</code> if you need to switch to a different branch, but your current working directory, and possibly also the staging area, is in a state of high disarray. Instead of disturbing it, you can create a temporary linked working tree to make a fix and remove it when you’re done. For example, you might need to do this to urgently fix a security bug in a separate branch.</p>
<p class="calibre3">Each detached <a id="_idIndexMarker270" class="pcalibre1 pcalibre calibre6"/>worktree should be associated with and have checked out different branches or be on the anonymous branch (detached <code>HEAD</code>) to avoid problems. You can override this safety with the <code>--</code><code>force</code> option.</p>
<p class="calibre3">You can remove any detached worktree with <code>git worktree remove</code> or by removing its directory and allowing it to be pruned. If a working tree is on a portable device or network disk, which<a id="_idIndexMarker271" class="pcalibre1 pcalibre calibre6"/> may not always be available, we can <code>lock</code> the worktree so that it can’t be pruned (and <code>unlock</code> if it is no longer needed).</p>
<p class="calibre3">To examine details about each working directory, such as the currently checked-out branch, and see if it is locked, you can use the <code>git worktree </code><code>list</code> command.</p>
<h1 id="_idParaDest-77" class="calibre5"><a id="_idTextAnchor079" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we learned how to better manage the contents of the working directory and the staging area in preparation for creating a new commit.</p>
<p class="calibre3">We now know how to undo the last commit, how to drop changes to the working area, how to retroactively change the branch we are working on, and other uses of the <code>git reset</code> command. We also understand the three (and a half) forms of reset.</p>
<p class="calibre3">We also learned how to examine and search the contents of the working directory, the staging area, and committed changes. We now know how to use Git to copy the file version from the worktree, the index, or the <code>HEAD</code> commit into the worktree or the index. We can use Git to clean (remove) untracked files.</p>
<p class="calibre3">This chapter explained how to configure how files are handled in the working directory and how to make Git ignore files (by making them intentionally untracked) and why. It described how to handle the differences between line-ending formats between operating systems. It also explained how to enable (and write) keyword expansion, how to configure how binary files are handled, and how to enhance <code>diff</code> and <code>merge</code> specific classes of files.</p>
<p class="calibre3">Finally, we learned to stash away changes to handle interruptions and to make it possible to test interactively prepared commits, before creating a commit. This chapter explained how Git manages stashes, enabling us to go beyond built-in operations.</p>
<p class="calibre3">This chapter, together with <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>, taught you how to contribute to a project.</p>
<p class="calibre3">The following chapters will teach you how to collaborate with other people, how to send what you contributed, and how to merge changes from other developers. We will start with two chapters explaining how to explore ad search project history with <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a><em class="italic">, Exploring Project History</em> and <a href="B21194_05.xhtml#_idTextAnchor113" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 5</em></a><em class="italic">, Searching Through </em><em class="italic">the Repository</em>.</p>
<h1 id="_idParaDest-78" class="calibre5"><a id="_idTextAnchor080" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">How can you avoid having a large number of build artifacts appear in the <strong class="source-inline1">git </strong><strong class="source-inline1">status</strong> output?</li>
<li class="calibre15">Let’s assume that you use a custom <strong class="bold">domain-specific language</strong> (<strong class="bold">DSL</strong>) or a programming language without built-in support in Git, such as Julia. How can you configure Git so that it provides better support for this language?</li>
<li class="calibre15">How can you squash the two most recent commits while making one commit out of them?</li>
<li class="calibre15">How can you split the most recent commit into two commits?</li>
<li class="calibre15">What should you do if an urgent change is needed (for example, because of a security bug) but the working area is in a messy state and you don’t want to lose your work?</li>
<li class="calibre15">How can you search through an old revision of the project – for example, a version tagged <strong class="source-inline1">v0.1</strong> – without checking out that revision?</li>
</ol>
<h1 id="_idParaDest-79" class="calibre5"><a id="_idTextAnchor081" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li class="calibre15">Add patterns matching the pathnames of those build artifacts to a <strong class="source-inline1">.</strong><strong class="source-inline1">gitignore</strong> file.</li>
<li class="calibre15">Define a custom <strong class="source-inline1">diff</strong> driver and provide the regular expression pattern matching the main “sections” of code with <strong class="source-inline1">xfuncname</strong>. Also, add an appropriate regular expression defining words in that programming language with <strong class="source-inline1">wordRegex</strong>, and perhaps also define whitespace problems with the <strong class="source-inline1">whitespace</strong> attribute.</li>
<li class="calibre15">Use <strong class="source-inline1">git reset --soft HEAD~2</strong> to rewind the branch and create a joined commit with <strong class="source-inline1">git commit</strong>, or use interactive rebase.</li>
<li class="calibre15">Perform a soft reset, <strong class="source-inline1">git reset --soft HEAD^</strong>, construct the first commit with <strong class="source-inline1">interactive add</strong>, test the code with <strong class="source-inline1">git stash --keep-index</strong>, pop the stash if the tests pass, and create the first commit with <strong class="source-inline1">git commit</strong> and the second with <strong class="source-inline1">git commit -a</strong>; there are other solutions.</li>
<li class="calibre15">Use <strong class="source-inline1">git stash</strong> to stash away current changes, create a WIP commit, or create a new detached working area for the urgent work with <strong class="source-inline1">git </strong><strong class="source-inline1">worktree add</strong>.</li>
<li class="calibre15">To search file contents from a revision tagged as v0.1, you can use <strong class="source-inline1">git grep -e &lt;</strong><strong class="source-inline1">pattern&gt; v0.1</strong>.</li>
</ol>
<h1 id="_idParaDest-80" class="calibre5"><a id="_idTextAnchor082" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Scott Chacon and Ben Straub, <em class="italic">Pro Git</em>, <em class="italic">2.2 Git Basics – Recording Changes to the Repository</em>, the <em class="italic">Ignoring files</em> section: <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#_ignoring" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository#_ignoring</a></li>
<li class="calibre15">Scott Chacon and Ben Straub, <em class="italic">Pro Git</em>, <em class="italic">7.3 Git Tools – Stashing and </em><em class="italic">Cleaning</em>: <a href="https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning</a></li>
<li class="calibre15">Scott Chacon and Ben Straub, <em class="italic">Pro Git</em>, <em class="italic">8.2 Customizing Git – Git </em><em class="italic">Attributes</em>: <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2/Customizing-Git-Git-Attributes</a></li>
<li class="calibre15"><em class="italic">gitattributes manpage - Defining attributes per </em><em class="italic">path</em>: <a href="https://www.git-scm.com/docs/gitattributes" class="pcalibre1 pcalibre calibre6">https://www.git-scm.com/docs/gitattributes</a></li>
<li class="calibre15"><em class="italic">gitignore manpage - Specifies intentionally untracked files to </em><em class="italic">ignore</em>: <a href="https://www.git-scm.com/docs/gitignore" class="pcalibre1 pcalibre calibre6">https://www.git-scm.com/docs/gitignore</a></li>
<li class="calibre15">Pragati Verma, <em class="italic">A Guide to Git Stash</em> (2021): <a href="https://dev.to/pragativerma18/a-guide-to-git-stash-2h5d" class="pcalibre1 pcalibre calibre6">https://dev.to/pragativerma18/a-guide-to-git-stash-2h5d</a></li>
<li class="calibre15">Andrew Knight, <em class="italic">Ignoring Files with Git</em> (2018): <a href="https://automationpanda.com/2018/09/19/ignoring-files-with-git/" class="pcalibre1 pcalibre calibre6">https://automationpanda.com/2018/09/19/ignoring-files-with-git/</a></li>
<li class="calibre15">Dragos Barosan, <em class="italic">New in Git: switch and restore</em> (2021): <a href="https://www.banterly.net/2021/07/31/new-in-git-switch-and-restore/" class="pcalibre1 pcalibre calibre6">https://www.banterly.net/2021/07/31/new-in-git-switch-and-restore/</a></li>
</ul>
</div>
</body></html>