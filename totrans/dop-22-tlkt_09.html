<html><head></head><body>
<div class="calibre6">
<h2 id="leanpub-auto-defining-cluster-wide-alerts" class="calibre15">Defining Cluster-Wide Alerts</h2>

<p class="calibre3">A common mistake is to focus on dashboards as the primary means of noticing when something is wrong. Dashboards have their place in the big scheme of things and are an indispensable part of any monitoring solution. However, they are not as critical as we think.</p>

<p class="calibre3">Monitoring systems are not meant to be a substitute for Netflix. They are not supposed to be watched. Instead, they should collect data and, if certain conditions are met, create alerts. Those alerts should try to communicate with the system and trigger a set of actions that will correct the problem automatically. Notifications should be sent to humans only if the system does not know how to fix the issue. In other words, we should strive to create a self-healing system that consults doctors (us, humans) only when it cannot fix itself.</p>

<p class="calibre3">Dashboards come in handy when we know that there is a problem. If the system is working as expected, looking at dashboards is a waste of time that could be better spent on improving the system.</p>

<p class="calibre3">Imagine a Slack notification that would say that “there is no available memory in the cluster and the system failed to create additional VMs.” Please notice the second part of that sentence. The system detected a problem and failed to correct it. Something went wrong, and it could not scale up. It failed to create new VMs. That was a good example of a type of notification that should be sent to a human operator. If the system managed to heal itself, there would be no need for that Slack notification.</p>

<p class="calibre3">We should consult dashboards only after we receive a message stating that the system failed to heal itself. Until that moment, everything is fine, and we can work on the next big improvement of the system. After receiving the message, we should visit a dashboard or two. We should try to get the high-level picture of the system. Sometimes, information from a dashboard is all we need. More often than not, we need more. We need to visit Prometheus and start querying it for additional information. Finally, once the culprit is found, we can create a fix, test it, employ it in production, improve the self-healing system so that the problem is fixed automatically the next time it happens, and write “post-mortem” report.</p>

<p class="calibre3">As you can see, it all starts with a single alert, and that will be the focus of this chapter. For now, we will not distinguish alerts fired to a system that will auto-correct itself from those that are sending notifications to human operators. That will come later. For now, we’ll focus on creating alerts without defining events they should fire.</p>

<h3 id="leanpub-auto-creating-the-cluster-and-deploying-services-1" class="calibre20">Creating The Cluster And Deploying Services</h3>

<p class="calibre3">We’ll start by recreating the cluster and deploying the stacks that we used in the previous chapter.</p>

<aside class="information">
    <p class="calibre3">All the commands from this chapter are available in the <a href="https://gist.github.com/vfarcic/cc5b51283a2555b8d5963c41afdf097d">05-alerts.sh</a> Gist.</p>

</aside>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>chmod +x scripts/dm-swarm-05.sh
<code class="lineno">2 </code>
<code class="lineno">3 </code>./scripts/dm-swarm-05.sh
<code class="lineno">4 </code>
<code class="lineno">5 </code><code class="nb">eval</code> <code class="k">$(</code>docker-machine env swarm-1<code class="k">)</code>
</pre></div>

</figure>

<p class="calibre3">We executed the <code class="calibre19">dm-swarm-05.sh</code> script which, in turn, created a Swarm cluster composed of Docker Machines, created the networks, and deployed the stacks. Now we should wait a few moments until all the services in the <code class="calibre19">monitor</code> stack are up and running. Please use <code class="calibre19">docker stack ps monitor</code> command to confirm that the status of all the services in the stack is <em class="calibre21">Running</em>.</p>

<p class="calibre3">Finally, we’ll confirm that everything is deployed correctly by opening Prometheus in a browser.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor"</code>
</pre></div>

</figure>

<p class="calibre3">Now the state of our cluster is the same as it was at the end of the previous chapter and we can proceed towards deploying exporters.</p>

<h3 id="leanpub-auto-creating-alerts-based-on-metrics" class="calibre20">Creating Alerts Based On Metrics</h3>

<p class="calibre3">Let us create the first alert. We’ll update our <code class="calibre19">go-demo_main</code> service by adding a few labels.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker service update <code class="se">\</code>
<code class="lineno">2 </code>    --label-add com.df.alertName<code class="o">=</code>mem <code class="se">\</code>
<code class="lineno">3 </code>    --label-add com.df.alertIf<code class="o">=</code><code class="s">'container_memory_usage_bytes{container_label_com\</code>
<code class="lineno">4 </code><code class="s">_docker_swarm_service_name="go-demo_main"} &gt; 20000000'</code> <code class="se">\</code>
<code class="lineno">5 </code>    go-demo_main
</pre></div>

</figure>

<aside class="tip">
    <p class="calibre3">Normally, we should have labels defined inside our stack file. However, since we’ll do quite a few iterations with different values, we’ll be updating the service instead modifying the stack file. That way we’ll be able to iterate faster.</p>

</aside>

<p class="calibre3">The label <code class="calibre19">com.df.alertName</code> is the name of the alert. It will be prefixed with the name of the service stripped from underscores and dashes (<code class="calibre19">godemomem</code>). That way, a unique alert name is guaranteed.</p>

<p class="calibre3">The second label (<code class="calibre19">com.df.alertIf</code>) is more important. It defines the expression. Translated to plain words, it takes the memory usage limited to the <code class="calibre19">go-demo_main</code> service and checks whether it is bigger than 20MB (20000000 bytes). An alert will be launched if the expression is true.</p>

<aside class="information">
    <p class="calibre3">For more info about <em class="calibre21">Docker Flow Monitor</em> alert parameters, please visit <a href="http://monitor.dockerflow.com/usage/#alert-parameters">Alert Parameters</a> section of the documentation.</p>

</aside>

<p class="calibre3">Let’s take a look at the Prometheus configuration.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/config"</code>
</pre></div>

</figure>

<p class="calibre3">As you can see, <code class="calibre19">alert.rules</code> file was added to the <code class="calibre19">rule_files</code> section.</p>


<figure class="image">
  <img src="../images/00022.jpeg" alt="Figure 5-1: Prometheus configuration with alert rules" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-1: Prometheus configuration with alert rules</figcaption>
</figure>


<p class="calibre3">Let us explore the rules we created so far.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/rules"</code>
</pre></div>

</figure>

<p class="calibre3">As you can see, the expression we specified with the <code class="calibre19">com.df.alertIf</code> label reached <em class="calibre21">Docker Flow Monitor</em>.</p>


<figure class="image">
  <img src="../images/00023.jpeg" alt="Figure 5-2: Prometheus rule with go-demo memory usage" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-2: Prometheus rule with go-demo memory usage</figcaption>
</figure>


<p class="calibre3">Finally, let’s take a look at the alerts.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">The <em class="calibre21">godemomainmem</em> alert is green meaning that none of the <code class="calibre19">go-demo_main</code> containers are using over 20MB of memory. Please click the <em class="calibre21">godemomainmem</em> link to expand the alert definition.</p>


<figure class="image1">
  <img src="../images/00024.jpeg" alt="Figure 5-3: Prometheus alerts with go-demo memory usage" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-3: Prometheus alerts with go-demo memory usage</figcaption>
</figure>


<p class="calibre3">The alert is green meaning that the service uses less than 20MB of memory. If we’d like to see how much memory it uses, we need to go back to the graph screen.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/graph"</code>
</pre></div>

</figure>

<p class="calibre3">Once inside the graph screen, please type the expression that follows, and press the <em class="calibre21">Execute</em> button.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>container_memory_usage_bytes{container_label_com_docker_swarm_service_name="go-d\
<code class="lineno">2 </code>emo_main"}
</pre></div>

</figure>

<p class="calibre3">The exact value will vary from one case to another. No matter which one you got, it should be below 20MB.</p>

<p class="calibre3">Let’s change the alert so that it is triggered when <code class="calibre19">go-demo_main</code> service uses more than 1MB.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker service update <code class="se">\</code>
<code class="lineno">2 </code>    --label-add com.df.alertName<code class="o">=</code>mem <code class="se">\</code>
<code class="lineno">3 </code>    --label-add com.df.alertIf<code class="o">=</code><code class="s">'container_memory_usage_bytes{container_label_com\</code>
<code class="lineno">4 </code><code class="s">_docker_swarm_service_name="go-demo_main"} &gt; 1000000'</code> <code class="se">\</code>
<code class="lineno">5 </code>    go-demo_main
</pre></div>

</figure>

<p class="calibre3">Since we are updating the same service and using the same <code class="calibre19">alertName</code>, the previous alert definition was overwritten with the new one.</p>

<p class="calibre3">Let’s go back to the alerts screen.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">This time, the alert is red, meaning that the condition is fulfilled. If it is still green, please wait for a few moments and refresh your screen.</p>

<p class="calibre3">Our service is using more than 1MB of memory and, therefore, the <code class="calibre19">ALERT IF</code> statement is fulfilled, and the alert is firing.</p>

<p class="calibre3">Please click the <em class="calibre21">godemomainmem</em> link to expand the alert and see more details.</p>


<figure class="image">
  <img src="../images/00025.jpeg" alt="Figure 5-4: Prometheus alerts screen with go-demo memory usage in firing state" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-4: Prometheus alerts screen with go-demo memory usage in firing state</figcaption>
</figure>


<p class="calibre3">The flow of the events can be described through the figure 5-5.</p>


<figure class="image">
  <img src="../images/00026.jpeg" alt="Figure 5-5: The flow of the events that result in a service alert being fired" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-5: The flow of the events that result in a service alert being fired</figcaption>
</figure>


<p class="calibre3">Let’s take a look at the graph screen.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/graph"</code>
</pre></div>

</figure>

<p class="calibre3">Let us quickly review <code class="calibre19">go-demo_main</code> service memory reservations and limits. They might be useful in defining alerts.</p>

<p class="calibre3">Please type the expression that follows, and press the <em class="calibre21">Execute</em> button.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>container_spec_memory_limit_bytes{container_label_com_docker_swarm_service_name=\
<code class="lineno">2 </code>"go-demo_main"}
</pre></div>

</figure>

<p class="calibre3">As you can see, memory metric is set to 10MB. Soon, we’ll use those metrics to our benefit.</p>

<p class="calibre3">Next, we’ll check the metrics of the “real” memory usage of the service.</p>

<p class="calibre3">Please type the expression that follows, and press the <em class="calibre21">Execute</em> button.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>container_memory_usage_bytes{container_label_com_docker_swarm_service_name="go-d\
<code class="lineno">2 </code>emo_main"}
</pre></div>

</figure>

<p class="calibre3">Memory consumption will vary from one case to another. In my case it ranges from 1MB to 3.5MB.</p>


<figure class="image">
  <img src="../images/00027.jpeg" alt="Figure 5-6: go-demo memory usage" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-6: go-demo memory usage</figcaption>
</figure>


<p class="calibre3">If we go back to the <code class="calibre19">alertIf</code> label we specified, there is an apparent duplication of data. Both the <code class="calibre19">alertIf</code> label and the service reservations are defining the thresholds of the service. As you probably already know, duplication is not a good idea because it increases the chances of an error and complicates future updates that would need to be performed in multiple places.</p>

<p class="calibre3">A better definition of the <code class="calibre19">alertIf</code> statement is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker service update <code class="se">\</code>
<code class="lineno">2 </code>    --label-add com.df.alertName<code class="o">=</code>mem_limit <code class="se">\</code>
<code class="lineno">3 </code>    --label-add com.df.alertIf<code class="o">=</code><code class="s">'container_memory_usage_bytes{container_label_com\</code>
<code class="lineno">4 </code><code class="s">_docker_swarm_service_name="go-demo"}/container_spec_memory_limit_bytes{containe\</code>
<code class="lineno">5 </code><code class="s">r_label_com_docker_swarm_service_name="go-demo"} &gt; 0.8'</code> <code class="se">\</code>
<code class="lineno">6 </code>    go-demo_main
</pre></div>

</figure>

<p class="calibre3">This time we defined that the <code class="calibre19">mem_limit</code> alert should be triggered if memory usage is higher than 80% of the memory limit. We avoided duplicating the value that is already defined as service’ memory limit. That way, if, at some later stage, we change the value of the <code class="calibre19">--limit-memory</code> argument, the alert will continue working properly.</p>

<p class="calibre3">Let’s confirm that <em class="calibre21">Docker Flow Swarm Listener</em> sent the notification and that <em class="calibre21">Docker Flow Monitor</em> was reconfigured accordingly.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">Please click the <em class="calibre21">godemo_main_mem_limit</em> link to see the new definition of the alert.</p>


<figure class="image">
  <img src="../images/00028.jpeg" alt="Figure 5-7: go-demo alert based on memory limit and usage" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-7: go-demo alert based on memory limit and usage</figcaption>
</figure>


<h3 id="leanpub-auto-defining-multiple-alerts-for-a-service" class="calibre20">Defining Multiple Alerts For A Service</h3>

<p class="calibre3">In many cases, one alert per service is not enough. We need to be able to define multiple specifications. <em class="calibre21">Docker Flow Monitor</em> allows us that by adding an index to labels. We can, for example, define labels <code class="calibre19">com.df.alertName.1</code>, <code class="calibre19">com.df.alertName.2</code>, and <code class="calibre19">com.df.alertName.3</code>. As a result, <em class="calibre21">Docker Flow Monitor</em> would create three alerts.</p>

<p class="calibre3">Let’s see it in action.</p>

<p class="calibre3">We’ll update the <code class="calibre19">node-exporter</code> service in the <code class="calibre19">exporter</code> stack so that it registers two alerts.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker service update <code class="se">\</code>
<code class="lineno">2 </code>    --label-add com.df.alertName.1<code class="o">=</code>mem_load <code class="se">\</code>
<code class="lineno">3 </code>    --label-add com.df.alertIf.1<code class="o">=</code><code class="s">'(sum by (instance) (node_memory_MemTotal) - su\</code>
<code class="lineno">4 </code><code class="s">m by (instance) (node_memory_MemFree + node_memory_Buffers + node_memory_Cached)\</code>
<code class="lineno">5 </code><code class="s">) / sum by (instance) (node_memory_MemTotal) &gt; 0.8'</code> <code class="se">\</code>
<code class="lineno">6 </code>    --label-add com.df.alertName.2<code class="o">=</code>diskload <code class="se">\</code>
<code class="lineno">7 </code>    --label-add com.df.alertIf.2<code class="o">=</code><code class="s">'(node_filesystem_size{fstype="aufs"} - node_fi\</code>
<code class="lineno">8 </code><code class="s">lesystem_free{fstype="aufs"}) / node_filesystem_size{fstype="aufs"} &gt; 0.8'</code> <code class="se">\</code>
<code class="lineno">9 </code>    exporter_node-exporter
</pre></div>

</figure>

<p class="calibre3">This time, <code class="calibre19">alertName</code> and <code class="calibre19">alertIf</code> labels got an index suffix (e.g. <code class="calibre19">.1</code> and <code class="calibre19">.2</code>). The first one (<code class="calibre19">mem_load</code>) will create an alert if memory usage is over 80% of the total available memory. The second alert will fire if disk usage is over 80%.</p>

<p class="calibre3">Let’s explore the <em class="calibre21">alerts</em> screen.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">As you can see, two new alerts were registered.</p>


<figure class="image1">
  <img src="../images/00029.jpeg" alt="Figure 5-8: Node exporter alerts" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-8: Node exporter alerts</figcaption>
</figure>


<p class="calibre3">The flow of the events can be described through the figure 5-9.</p>


<figure class="image">
  <img src="../images/00030.jpeg" alt="Figure 5-9: The flow of the events that result in an exporter alert being fired" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-9: The flow of the events that result in an exporter alert being fired</figcaption>
</figure>


<h3 id="leanpub-auto-postponing-alerts-firing" class="calibre20">Postponing Alerts Firing</h3>

<p class="calibre3">Firing an alert as soon as the condition is met is often not the best idea. The conditions of the system might change temporarily and go back to “normal” shortly afterward. A spike in memory is not bad in itself. We should not worry if memory utilization jumps to 95% only to go back to 70% a few moments later. On the other hand, if it continues being over 80% for, let’s say, five minutes, some actions should be taken.</p>

<p class="calibre3">We’ll modify the <code class="calibre19">go-demo_main</code> service so that it fires an alert only if memory threshold is reached and the condition continues for at least one minute.</p>

<p class="calibre3">The relevant parts of the <code class="calibre19">go-demo</code> stack file are as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="calibre19">services</code><code class="o">:</code>
<code class="lineno"> 2 </code>
<code class="lineno"> 3 </code>  <code class="calibre19">main</code><code class="o">:</code>
<code class="lineno"> 4 </code>    <code class="o">...</code>
<code class="lineno"> 5 </code>    <code class="calibre19">deploy</code><code class="o">:</code>
<code class="lineno"> 6 </code>      <code class="o">...</code>
<code class="lineno"> 7 </code>      <code class="calibre19">labels</code><code class="o">:</code>
<code class="lineno"> 8 </code>        <code class="o">...</code>
<code class="lineno"> 9 </code>        <code class="o">-</code> <code class="calibre19">com</code><code class="o">.</code><code class="na">df</code><code class="o">.</code><code class="na">alertName</code><code class="o">=</code><code class="calibre19">mem_limit</code>
<code class="lineno">10 </code>        <code class="o">-</code> <code class="calibre19">com</code><code class="o">.</code><code class="na">df</code><code class="o">.</code><code class="na">alertIf</code><code class="o">=</code><code class="calibre19">container_memory_usage_bytes</code><code class="o">{</code><code class="calibre19">container_label_com_docker</code><code class="o">\</code>
<code class="lineno">11 </code><code class="calibre19">_swarm_service_name</code><code class="o">=</code><code class="s">"go-demo"</code><code class="o">}/</code><code class="calibre19">container_spec_memory_limit_bytes</code><code class="o">{</code><code class="calibre19">container_label</code><code class="o">\</code>
<code class="lineno">12 </code><code class="calibre19">_com_docker_swarm_service_name</code><code class="o">=</code><code class="s">"go-demo"</code><code class="o">}</code> <code class="o">&gt;</code> <code class="o">0.8</code>
<code class="lineno">13 </code>        <code class="o">-</code> <code class="calibre19">com</code><code class="o">.</code><code class="na">df</code><code class="o">.</code><code class="na">alertFor</code><code class="o">=</code><code class="o">30</code><code class="calibre19">s</code>
<code class="lineno">14 </code><code class="o">...</code>
</pre></div>

</figure>

<p class="calibre3">We set the <code class="calibre19">com.df.alertName</code> and <code class="calibre19">com.df.alertIf</code> labels to the same values as those we used to update the service. The new addition is the <code class="calibre19">com.df.alertFor</code> label that specifies the period Prometheus should wait before firing an alert. In this case, the condition would need to persist for thirty seconds before the alert is fired. Until then, the alert will be in the pending state.</p>

<p class="calibre3">Let’s deploy the new stack.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker stack deploy <code class="se">\</code>
<code class="lineno">2 </code>    -c stacks/go-demo-alert-long.yml <code class="se">\</code>
<code class="lineno">3 </code>    go-demo
</pre></div>

</figure>

<p class="calibre3">After a few moments, the <code class="calibre19">go-demo_main</code> service will be rescheduled, and the <code class="calibre19">alert</code> labels will be propagated to the Prometheus instance. Let’s take a look at the alerts screen.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">The <code class="calibre19">go-demo</code> memory limit alert with the <code class="calibre19">FOR</code> statement set to thirty seconds is registered.</p>


<figure class="image">
  <img src="../images/00031.jpeg" alt="Figure 5-10: go-demo memory limit aert with the `FOR` statement" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-10: go-demo memory limit aert with the <code class="calibre19">FOR</code> statement</figcaption>
</figure>


<p class="calibre3">We should test whether the alert indeed works. We’ll temporarily decrease the threshold to five percent. That should certainly trigger the alert.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker service update <code class="se">\</code>
<code class="lineno">2 </code>    --label-add com.df.alertIf<code class="o">=</code><code class="s">'container_memory_usage_bytes{container_label_com\</code>
<code class="lineno">3 </code><code class="s">_docker_swarm_service_name="go-demo_main"}/container_spec_memory_limit_bytes{con\</code>
<code class="lineno">4 </code><code class="s">tainer_label_com_docker_swarm_service_name="go-demo_main"} &gt; 0.05'</code> <code class="se">\</code>
<code class="lineno">5 </code>    go-demo_main
</pre></div>

</figure>

<p class="calibre3">Let us take another look at the alerts screen.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">If you opened the screen within thirty seconds since the update, you should see that there are three alerts in the <em class="calibre21">PENDING</em> state. Once thirty seconds expire, the status will change to <em class="calibre21">FIRING</em>. Unfortunately, there is no destination Prometheus can fire those alerts. We’ll fix that in the next chapter. For now, we’ll have to be content by simply observing the alerts from Prometheus.</p>


<figure class="image">
  <img src="../images/00032.jpeg" alt="Figure 5-11: go-demo alerts in the PENDING state" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-11: go-demo alerts in the PENDING state</figcaption>
</figure>


<h3 id="leanpub-auto-defining-additional-alert-information-through-labels-and-annotations" class="calibre20">Defining Additional Alert Information Through Labels And Annotations</h3>

<p class="calibre3">We might want to specify supplementary information to our alerts. We can accomplish that through the usage of alert labels and annotations.</p>

<p class="calibre3">Alert labels clause allows specifying a set of additional labels to be attached to the alert. The annotations clause specifies another set of labels that are not identifying for an alert instance. They are used to store longer additional information such as alert descriptions or runbook links.</p>

<p class="calibre3">We can, for example, update our <code class="calibre19">go-demo</code> stack by adding service labels that follow.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code>...
<code class="lineno"> 2 </code>services:
<code class="lineno"> 3 </code>
<code class="lineno"> 4 </code>  main:
<code class="lineno"> 5 </code>    ...
<code class="lineno"> 6 </code>    deploy:
<code class="lineno"> 7 </code>      ...
<code class="lineno"> 8 </code>      labels:
<code class="lineno"> 9 </code>        ...
<code class="lineno">10 </code>        - com.df.alertLabels=severity=high,receiver=system
<code class="lineno">11 </code>        - com.df.alertAnnotations=summary=Service memory is high,description=Do \
<code class="lineno">12 </code>something or start panicking
<code class="lineno">13 </code>      ...
</pre></div>

</figure>

<p class="calibre3">Let’s deploy the updated stack.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker stack deploy <code class="se">\</code>
<code class="lineno">2 </code>    -c stacks/go-demo-alert-info.yml <code class="se">\</code>
<code class="lineno">3 </code>    go-demo
</pre></div>

</figure>

<p class="calibre3">A few moments later, the alert definition reached Prometheus, and we can explore it from a browser.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">Please expand the <code class="calibre19">godemo_main_mem_limit</code> alert, and you’ll see that it contains the labels and annotations we specified through service labels.</p>

<p class="calibre3">Besides serving as additional information, alert labels and annotations can be used with <em class="calibre21">Alertmanager</em> which we’ll explore in the next chapter. For now, just remember that they are available.</p>


<figure class="image">
  <img src="../images/00033.jpeg" alt="Figure 5-12: go-demo alerts with labels and annotations" class="calibre17"/>
  <figcaption class="calibre18">Figure 5-12: go-demo alerts with labels and annotations</figcaption>
</figure>


<h3 id="leanpub-auto-using-shortcuts-to-define-alerts" class="calibre20">Using Shortcuts To Define Alerts</h3>

<p class="calibre3">Setting alerts as service labels is great but, as you probably noticed, a bit cumbersome. Alert conditions can get pretty long and repetitive. I, for one, got tired of writing the same statement over and over again. So, I created shortcuts that accomplish the same functionality. Let’s see them in action.</p>

<p class="calibre3">The modified version of the <code class="calibre19">go-demo</code> stack definition is as follows (restricted to relevant parts).</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code>version: '3'
<code class="lineno"> 2 </code>
<code class="lineno"> 3 </code>services:
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code>  main:
<code class="lineno"> 6 </code>    ...
<code class="lineno"> 7 </code>    deploy:
<code class="lineno"> 8 </code>      ...
<code class="lineno"> 9 </code>      labels:
<code class="lineno">10 </code>        - com.df.alertIf=@service_mem_limit:0.8
<code class="lineno">11 </code>        ...
</pre></div>

</figure>

<p class="calibre3">We simplified the definition by replacing the expression that follows with <code class="calibre19">com.df.alertIf=@service_mem_limit:0.8</code>.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>com.df.alertIf=container_memory_usage_bytes{container_label_com_docker_swarm_ser\
<code class="lineno">2 </code>vice_name="go-demo_main"}/container_spec_memory_limit_bytes{container_label_com_\
<code class="lineno">3 </code>docker_swarm_service_name="go-demo_main"} &gt; 0.8
</pre></div>

</figure>

<p class="calibre3">Similarly, the modified version of the <code class="calibre19">exporter</code> stack definition is as follows (limited to relevant parts).</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code>version: "3"
<code class="lineno"> 2 </code>
<code class="lineno"> 3 </code>services:
<code class="lineno"> 4 </code>
<code class="lineno"> 5 </code>  ...
<code class="lineno"> 6 </code>  node-exporter:
<code class="lineno"> 7 </code>    ...
<code class="lineno"> 8 </code>    deploy:
<code class="lineno"> 9 </code>      ...
<code class="lineno">10 </code>      labels:
<code class="lineno">11 </code>        ...
<code class="lineno">12 </code>        - com.df.alertIf.1=@node_mem_limit:0.8
<code class="lineno">13 </code>        ...
<code class="lineno">14 </code>        - com.df.alertIf.2=@node_fs_limit:0.8
<code class="lineno">15 </code>      ...
</pre></div>

</figure>

<p class="calibre3">Just as with the <code class="calibre19">go-demo</code>, we simplified the stack definition by replacing <code class="calibre19">alertIf</code> labels with shortcut values.</p>

<p class="calibre3">Now we can deploy the modified stacks.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker stack deploy <code class="se">\</code>
<code class="lineno">2 </code>    -c stacks/exporters-alert.yml <code class="se">\</code>
<code class="lineno">3 </code>    exporter
<code class="lineno">4 </code>
<code class="lineno">5 </code>docker stack deploy <code class="se">\</code>
<code class="lineno">6 </code>    -c stacks/go-demo-alert.yml <code class="se">\</code>
<code class="lineno">7 </code>    go-demo
</pre></div>

</figure>

<p class="calibre3">Let’s check the outcome in the Prometheus <em class="calibre21">Alerts</em> screen.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/alerts"</code>
</pre></div>

</figure>

<p class="calibre3">If you check the details of the alerts, you’ll notice that they are the same as they were before. The shortcuts were sent to Prometheus and expanded into their full syntax.</p>

<aside class="information">
    <p class="calibre3">For more info about <em class="calibre21">Docker Flow Monitor</em> alert shortcuts, please visit <a href="http://monitor.dockerflow.com/usage/#alertif-parameter-shortcuts">AlertIf Parameter Shortcuts</a> section of the documentation.</p>

</aside>

<h3 id="leanpub-auto-what-now-4" class="calibre20">What Now?</h3>

<p class="calibre3">We are moving forwards. Alerts are an important step towards a self-healing system. However, at this moment, we can only see them. They are not firing any events. Prometheus is aware of the conditions that should create an alert but is unaware what to do with them. We’ll fix that in the next chapter.</p>

<p class="calibre3">Take another break. Remove the machines we created, do something fun, and come back fresh. A brain needs a rest every once in a while.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker-machine rm -f <code class="se">\</code>
<code class="lineno">2 </code>    swarm-1 swarm-2 swarm-3
</pre></div>

</figure>



</div>
</body></html>