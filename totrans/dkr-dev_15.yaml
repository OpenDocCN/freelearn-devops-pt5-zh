- en: '*Chapter 12*: Introduction to Container Security'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第12章*：容器安全介绍'
- en: When developing technical projects, security should be a fundamental concern.
    We live in a world surrounded by security threats, from malware and viruses to
    data breaches. Being the victim of cybercrime or information leaks can have increasingly
    negative consequences, especially under regulations such as the EU's **General
    Data Protection Regulation** (**GDPR**).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发技术项目时，安全性应是一个基本关注点。我们生活在一个被安全威胁环绕的世界，从恶意软件和病毒到数据泄露，各种安全威胁层出不穷。成为网络犯罪或信息泄露的受害者可能会带来越来越严重的后果，特别是在欧盟的**通用数据保护条例**（**GDPR**）等法规下。
- en: When breaches or compromises do happen, having the ability to limit their scope
    through good architectural practices is a must. This is achieved through the concept
    of limiting what is called lateral movement. By this, we mean using one breached
    system to access another, thereby providing the attacker with the ability to traverse
    through your system, compromising further systems and stealing data.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生侵犯或妥协时，通过良好的架构实践限制其范围的能力至关重要。这通过所谓的横向移动限制概念来实现。我们指的是利用一个被入侵系统访问另一个系统，从而使攻击者能够在您的系统中穿越，进一步侵害系统并窃取数据。
- en: Thankfully, containerization, when deployed correctly, can help you improve
    your security posture through a variety of features that will be explored in the
    final section of this book. First, however, we should explore the technical fundamentals
    of Docker's security architecture so that we can start to build upon it. Some
    of the concepts in this chapter will be a recap of ideas we have explored elsewhere
    in this book, framed in a security setting. This should help to not only cement
    those concepts in your learning process but also help you to understand how to
    secure your application development projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，正确部署的容器化可以通过多种功能帮助您通过本书最后一部分将要探讨的功能提高安全姿态。但是，首先，我们应该探讨Docker安全架构的技术基础，以便开始构建。本章中的一些概念将是我们在本书其他地方探讨的想法的总结，并以安全设置的方式呈现。这不仅有助于巩固您的学习过程中的这些概念，还有助于您理解如何保护您的应用开发项目。
- en: In this chapter, we're going to cover a brief overview of the security architecture
    of containers and how this relates and compares to virtualization, as well as
    how Docker Engine and containerd work from a security perspective and the concepts
    they have inherited from Linux. We will also look at an overview of best practices
    that you can implement that leverage Docker's security architecture. This will
    provide a foundation for exploring the topic deeper in the following chapters.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要概述容器的安全架构及其与虚拟化的关系和比较，以及Docker Engine和containerd从安全角度工作的方式及其从Linux继承的概念。我们还将查看您可以实施的利用Docker安全架构的最佳实践概述。这将为后续章节深入探讨该主题奠定基础。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中涵盖以下主题：
- en: Virtualization and hypervisor security models
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟化和hypervisor安全模型
- en: Container security models
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器安全模型
- en: Docker Engine and containerd – Linux security features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Engine和containerd – Linux安全功能
- en: A note on cgroups
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: cgroups说明
- en: An overview of best practices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最佳实践概述
- en: So, let's start by reviewing how containers and virtualization differ and how
    security is a fundamental component of both.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先回顾容器和虚拟化的区别，以及安全如何成为两者的基本组成部分。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you will need to have access to a Linux machine running Docker.
    We recommend that you use the setup you have been using so far in this book.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，您需要访问运行Docker的Linux机器。我们建议您继续使用本书中迄今为止使用的设置。
- en: If you have jumped to the security section as your starting point, we recommend
    you install the Docker Community Edition from [https://docs.docker.com/v17.09/engine/installation/](https://docs.docker.com/v17.09/engine/installation/).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已跳转到安全部分作为起点，我们建议您从[https://docs.docker.com/v17.09/engine/installation/](https://docs.docker.com/v17.09/engine/installation/)安装Docker
    Community Edition。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码实际操作：
- en: '[https://bit.ly/3gW33FD](https://bit.ly/3gW33FD)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3gW33FD](https://bit.ly/3gW33FD)'
- en: Virtualization and hypervisor security models
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟化和hypervisor安全模型
- en: In previous chapters, we explored how Docker works and how it compares to other
    technologies, such as FreeBSD jails and virtualization. Building on what we learned
    here, we will now seek to understand the security model that underpins Docker
    better.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的章节中，我们探讨了 Docker 是如何工作的，以及它与其他技术（如 FreeBSD jail 和虚拟化）的比较。基于我们在这里学到的内容，我们现在将进一步理解支撑
    Docker 的安全模型。
- en: To start with, let's look at how security is implemented by virtualization tools
    so that we can then understand how Docker matches and differs from them.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们来看看虚拟化工具是如何实现安全性的，这样我们就能理解 Docker 与这些工具的相似与不同之处。
- en: Virtualization and protection rings
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟化与保护环
- en: When using **virtual machines** (**VMs**), you may have come across the term
    hypervisor. This is a program that orchestrates how the VMs run on your system
    and interact with the underlying hardware. Some hypervisor products, known as
    type 1 hypervisors, run directly on top of the hardware. Others, such as VirtualBox,
    are installed via your existing operating system and allow you to load additional
    operating systems as VMs.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用**虚拟机**（**VMs**）时，你可能会遇到“超管程序”（hypervisor）这个术语。它是一个协调虚拟机如何在系统上运行以及如何与底层硬件交互的程序。有些超管程序产品被称为类型
    1 超管程序，它们直接运行在硬件之上。其他的，如 VirtualBox，是通过现有操作系统安装的，可以让你加载额外的操作系统作为虚拟机。
- en: How the hypervisor works with the underlying hardware is governed by what is
    known as protection rings. These rings dictate the layers of privilege, effectively
    deciding which aspects of a computer system's software, such as the operating
    system, drivers, and desktop applications, can access which parts of the underlying
    hardware.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 超管程序如何与底层硬件协作，是由所谓的保护环来决定的。这些保护环决定了特权的层级，实际上决定了计算机系统的软件（例如操作系统、驱动程序和桌面应用程序）能够访问底层硬件的哪些部分。
- en: 'Typically, you will see the protection ring modeled as a set of concentric
    circles, such as the following:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会看到保护环被建模为一组同心圆，如下所示：
- en: '![](img/B11641_12_001.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_12_001.jpg)'
- en: Figure 12.1 – Protection ring example
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 保护环示例
- en: Sometimes the **device drivers** ring may show as two separate rings as well
    (denoted by the dotted circle in the diagram).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有时**设备驱动程序**环也可能会显示为两个独立的环（如图中的虚线圆圈所示）。
- en: Each hardware architecture will differ slightly in its adaptation of the protection
    ring model and, in turn, the operating systems that run on it may also run code
    at different levels than expected. However, it is typical to find ring 0—that
    is, the ring at the center with the most privilege—denoted as the **kernel ring**
    (sometimes called **kernel land**).
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每种硬件架构在适应保护环模型时会有所不同，因此，运行在其上的操作系统可能也会在不同的层级上运行代码。然而，通常会看到环 0——即位于中心、特权最高的环——被称为**内核环**（有时也叫做**内核空间**）。
- en: Malicious software will often try to attack the kernel in order to gain full
    access over the system and run low-level system processes. This software is usually
    known as kernel-mode rootkits. Therefore, protecting the kernel is a must, as
    well as ensuring that if a system is breached with a malicious application, library,
    or package, it cannot escalate privileges to gain kernel access is paramount.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 恶意软件通常会尝试攻击内核，以便获得对系统的完全访问权限并执行低级系统进程。这类软件通常被称为内核模式根套件。因此，保护内核至关重要，同时也要确保如果系统被恶意应用程序、库或软件包攻破，它无法提升特权以获取对内核的访问权限，这是至关重要的。
- en: Outer rings may then handle device drivers and applications. Each is assigned
    a ring and the outer ring containing user applications is often known as **user
    land**. Gates handle how each ring can speak to the ring below it. As with the
    kernel, there is a risk of malicious software infecting applications that run
    at these levels including user-mode rootkits that run at level 3.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 外层环则可能处理设备驱动程序和应用程序。每个环都有其对应的层级，而包含用户应用程序的外层环通常被称为**用户空间**。网关处理每个环如何与下层环进行交互。与内核一样，恶意软件有可能感染运行在这些层级上的应用程序，包括运行在第
    3 层的用户模式根套件（rootkit）。
- en: With these threats in mind, the protection ring model helps prevent the programs
    that you install on your desktop from maliciously accessing the underlying hardware
    and bypassing the kernel. Therefore, malware writers are forced to look for security
    holes and other means of obfuscating their attacks, such as injecting their code
    into other processes. You can think of these layers of security as providing a
    set of doors that need to be breached, rather than an attacker just being able
    to walk in and be given direct access to the underlying hardware.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这些威胁，保护环模型有助于防止你在桌面上安装的程序恶意访问底层硬件并绕过内核。因此，恶意软件编写者被迫寻找安全漏洞和其他混淆其攻击手段的方式，比如将他们的代码注入到其他进程中。你可以把这些安全层看作是需要突破的一道道门，而不是攻击者能直接进入并获得底层硬件的访问权限。
- en: These layers of segmentation, while not foolproof, help to provide what is known
    as a layered approach to security. The idea here is that by adding one layer of
    security to another, we make it increasingly difficult for an attack to be pulled
    off.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这些分层的隔离措施，虽然不是万无一失的，但有助于提供所谓的分层安全方法。其思路是通过在一个安全层上再增加另一个安全层，我们使得攻击变得越来越难以实现。
- en: Virtualization and malware
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 虚拟化与恶意软件
- en: Since we are interested in virtualization and subsequently, how this compares
    to Docker containers, we are, of course, interested in how virtualization fits
    into this model. How does virtualization protect against rootkits and other malware?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们关注虚拟化以及虚拟化与Docker容器的比较，我们自然会关注虚拟化如何融入这个模型。那么，虚拟化如何防御根套件（rootkits）和其他恶意软件呢？
- en: Many modern hardware architectures, such as the ARMv7-A, include a hypervisor
    as a privilege level in our ring model that is more privileged than the operating
    system level. This allows the hypervisor to switch between operating systems that
    are running at the next ring above.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现代硬件架构，如ARMv7-A，包含一个超管程序（hypervisor）作为我们的环模型中的一个权限级别，这个权限级别比操作系统权限更高。这使得超管程序能够在上面一环的操作系统之间切换。
- en: Some architectures also implement what is known as **ring -1**. This allows
    the hypervisor to run at a further deeper security ring, with the guest operating
    system kernels running at ring 0\. If, for example, you are running VirtualBox
    on top of an x86 platform, depending on whether hardware virtualization exists,
    VirtualBox will run either at ring -1 or ring 0.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 一些架构还实现了被称为**环-1**的机制。这允许超管程序运行在一个更深的安全环中，而客操作系统内核运行在环0。例如，如果你在x86平台上运行VirtualBox，取决于是否支持硬件虚拟化，VirtualBox将运行在环-1或环0。
- en: VMs are useful for conducting malware analysis for a number of reasons, including
    the fact the machine can be locked down, so it is a self-contained environment.
    Once the investigator is done analyzing the code and its effects, the VM can be
    deleted without having to reinstall the whole operating system of the machine,
    or (if configured correctly) risk the malware gaining access to the underlying
    hardware.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机（VM）由于多种原因在进行恶意软件分析时非常有用，其中之一是机器可以被锁定，因此它是一个自包含的环境。一旦分析人员完成对代码及其效果的分析，虚拟机可以被删除，而无需重新安装整台机器的操作系统，或者（如果正确配置）避免恶意软件访问底层硬件的风险。
- en: So, in summary, protection rings provide a mechanism to provide a way to segment
    software so that it can only access certain resources. In a virtualization model,
    a hypervisor can run in the ring with the most privilege to switch between operating
    systems. A hypervisor can be installed via an existing operating system, such
    as Windows, or be deployed on bare metal, such as the VMware ESXi product. It
    can also be used to create a sandbox environment that prevents malicious code
    from infecting the underlying hardware or operating system.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，保护环提供了一种机制，用于将软件进行分段，使其只能访问某些特定资源。在虚拟化模型中，超管程序可以运行在权限最高的环中，以便在操作系统之间切换。超管程序可以通过现有的操作系统（如Windows）安装，或部署在裸机上，如VMware
    ESXi产品。它也可以用来创建一个沙箱环境，防止恶意代码感染底层硬件或操作系统。
- en: So, how does this compare to Docker and how does the protection ring model apply?
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这与Docker有什么关系，保护环模型如何应用到Docker中？
- en: Docker and protection rings
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker与保护环
- en: Like VMs, Docker containers provide an isolated environment for running your
    code on top of an existing operating system. This operating system can be either
    virtualized or installed directly onto bare metal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 和虚拟机一样，Docker容器提供了一个隔离的环境，用于在现有操作系统上运行你的代码。这个操作系统可以是虚拟化的，也可以直接安装在裸机上。
- en: So, how does this work? You may remember that Docker containers run on top of
    Docker Engine, which in turn sits on top of the operating system via an intermediate
    component called **containerd**. This is in comparison to the type 1 hypervisor,
    which runs on top of the infrastructure, as we discussed previously, with the
    guest operating systems running on top of the hypervisor.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这究竟是如何运作的呢？你可能还记得，Docker 容器运行在 Docker Engine 上，而 Docker Engine 又通过一个名为 **containerd**
    的中间组件运行在操作系统之上。这与我们之前讨论的类型 1 虚拟化程序不同，类型 1 虚拟化程序运行在基础设施之上，而客户操作系统则运行在虚拟化程序之上。
- en: Docker containers, therefore, all run on top of the same operating system, regardless
    of whether it is virtualized or not. In fact, in some instances, such as if you
    run Linux containers on Docker on Windows, you may notice that it uses an intermediary
    step. This consists of running a virtualized version of Linux, which in turn runs
    the Docker engine. In this scenario, all the containers are running on the same
    virtualized Linux operating system.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker 容器都在同一个操作系统上运行，无论它是否被虚拟化。事实上，在某些情况下，例如在 Windows 上运行 Linux 容器时，你可能会注意到它使用了一个中间步骤。这包括运行一个虚拟化版本的
    Linux，进而运行 Docker 引擎。在这种情况下，所有容器都运行在同一个虚拟化的 Linux 操作系统上。
- en: Note
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Docker Engine Enterprise Edition also supports native Windows containers. You
    can read more about them at [https://www.docker.com/products/windows-containers](https://www.docker.com/products/windows-containers).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Engine 企业版也支持原生 Windows 容器。你可以在[https://www.docker.com/products/windows-containers](https://www.docker.com/products/windows-containers)阅读更多关于它们的信息。
- en: The key concept to all of this is that isolation happens at the container level,
    rather than—or in addition to—the VM level. So, at a basic level, Docker does
    not provide the same sandboxing that the VM itself does.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这一切的关键概念是，隔离发生在容器级别，而不是（或除了）虚拟机级别。因此，从基础层面来看，Docker 并不提供与虚拟机本身相同的沙箱功能。
- en: 'The following diagram demonstrates the difference:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了两者的区别：
- en: '![](img/B11641_12_002.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_12_002.jpg)'
- en: Figure 12.2 – Example of isolation in Docker and VMs
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.2 – Docker 和虚拟机中的隔离示例
- en: In the preceding diagram, if we run Docker on the VM stack, we would replace
    the **Applications** layer with the **Docker Engine**/**Containerd** and container
    layers.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，如果我们在虚拟机堆栈上运行 Docker，我们将用 **Docker Engine**/**Containerd** 和容器层替换 **应用程序**
    层。
- en: As you can probably see, this provides a layer of security in addition to that
    provided by the underlying host operating system or, when applicable, the additional
    layer of the hypervisor. However, this layer of security when operating on top
    of the host operating system and not via a VM does mean that if the Docker Engine
    contains a security vulnerability, you have an additional layer of risk.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你可能看到的，这提供了一个额外的安全层，除了由底层主机操作系统提供的安全性之外，或者在适用时由虚拟化层提供的额外安全层。然而，当这个安全层在主机操作系统上运行而不是通过虚拟机时，这意味着如果
    Docker Engine 存在安全漏洞，你将面临额外的风险。
- en: The Docker containers' access to the underlying system/kernel, therefore, is
    mediated by the engine, which in turn makes system calls via containerd (and,
    in most cases, is called via `runc`).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Docker 容器访问底层系统/内核是通过引擎进行调节的，而引擎则通过 containerd 发出系统调用（在大多数情况下，是通过 `runc`
    调用的）。
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to read about containerd and runc in more detail, check out the
    official website at [https://containerd.io/](https://containerd.io/).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想更详细地了解 containerd 和 runc，可以查看官方网页 [https://containerd.io/](https://containerd.io/)。
- en: Here, we have provided a level of isolation between each container and the underlying
    operating system and hardware. Docker Engine does not run at ring 0 or ring -1,
    but rather at ring 3, meaning while it is susceptible to other forms of attack,
    it does not have direct access to the hardware as the hypervisor does.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为每个容器与底层操作系统和硬件之间提供了一个隔离层。Docker Engine 不运行在 ring 0 或 ring -1，而是运行在 ring
    3，这意味着尽管它容易受到其他形式的攻击，但它不像虚拟化程序那样直接访问硬件。
- en: Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Even with this layered approach to security, flaws have been found in the past.
    You can read more at [https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/](https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 即便采用这种分层的安全方式，过去也曾发现漏洞。你可以在[https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/](https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/)了解更多信息。
- en: Additionally, each container is a separate self-contained set of libraries and
    applications that can only communicate with each other via Docker Engine. By default,
    as we noted, the containers do not have access to the underlying operating system
    that Docker Engine is hosted on. In fact, any calls to access system resources
    at the underlying OS level have to be explicitly configured when setting up the
    Dockerfile. The Docker containers, therefore, run at ring level 3, aka user land,
    with additional layers of security in place.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个容器都是一个独立的自包含库和应用程序集合，它们只能通过 Docker 引擎相互通信。如我们所提到的，容器默认情况下无法访问 Docker 引擎所在的底层操作系统。事实上，任何对底层操作系统资源的访问调用，必须在设置
    Dockerfile 时显式配置。因此，Docker 容器运行在环级 3，即用户空间，并且在此基础上增加了额外的安全层。
- en: Now that we have an understanding of the ring model and how Docker and virtualization
    work in conjunction with it, let's look at container security models and what
    they have inherited from Linux's best practices and techniques.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了环模型以及 Docker 和虚拟化如何与之协作，接下来让我们看看容器安全模型以及它们从 Linux 的最佳实践和技术中继承了什么。
- en: Container security models
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器安全模型
- en: 'Moving up from the hardware layer and how the hypervisor and base operating
    system mediate access to it, we can begin to review what happens at the software
    layer running at ring level 3\. To explore this, there are two key features of
    Docker''s container security model that we need to understand:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 从硬件层开始，经过虚拟机管理程序和基础操作系统如何调解访问的方式，我们可以开始审视在环级 3 上运行的软件层发生了什么。为了深入了解这一点，我们需要理解
    Docker 容器安全模型中的两个关键特性：
- en: Applications are isolated from the underlying host system.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序与底层宿主系统隔离。
- en: Containerized applications are isolated from each other.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化应用程序相互隔离。
- en: 'So, how does Docker achieve these objectives? The answer to this is, as you
    may have guessed, via Docker Engine and related components, such as containerd.
    These components have inherited a number of key Linux features and concepts with
    major benefits for security, including the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Docker 是如何实现这些目标的呢？答案正如你所猜测的，通过 Docker 引擎和相关组件，如 containerd。这些组件继承了 Linux
    的许多关键特性和概念，并在安全性方面带来了主要好处，包括以下内容：
- en: '**runc**: A lightweight container runtime'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**runc**：轻量级容器运行时'
- en: '**Namespaces**: A Linux method for partitioning kernel resources'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Namespaces**：Linux 用于分割内核资源的方法'
- en: '**Control groups (cgroups)**: A kernel feature for limiting resources such
    as CPU usage'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制组（cgroups）**：限制 CPU 使用等资源的内核特性'
- en: 'Additionally, it also allows the implementation of other security features
    found in the Linux kernel, such as the following:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还允许实现 Linux 内核中发现的其他安全特性，例如：
- en: '**SELinux**: The Linux kernel security module for handling access control security
    policies'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SELinux**：用于处理访问控制安全策略的 Linux 内核安全模块'
- en: '**AppArmor**: A Linux feature for restricting application capabilities'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AppArmor**：用于限制应用程序能力的 Linux 特性'
- en: '**TOMOYO**: A Linux security module for handling **mandatory access control**
    (**MAC**)'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TOMOYO**：用于处理**强制访问控制**（**MAC**）的 Linux 安全模块'
- en: '**GRSEC**: A collection of security enhancements for the Linux kernel'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GRSEC**：为 Linux 内核提供的一系列安全增强功能'
- en: These tried and true best practices allow containers to be isolated from one
    another and from the host operating system in a secure fashion. We will now delve
    deeper into Docker Engine and containerd to get a better understanding of how
    these security features are implemented.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些经过验证的最佳实践确保容器能够以安全的方式彼此隔离，并与宿主操作系统隔离。接下来我们将深入探讨 Docker 引擎和 containerd，以更好地理解这些安全特性是如何实现的。
- en: Docker Engine and containerd – Linux security features
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 引擎和 containerd – Linux 安全特性
- en: Docker Engine, which you installed previously, acts as the coordinator for all
    your application containers. In addition to the engine are other key components
    that make up the Docker ecosystem. Initially, many of the components were baked
    into Docker Engine, but over the years, in order to make the engine smaller and
    faster, some components, such as the runtime mechanism for managing containers,
    were broken down into separate projects.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你之前安装的 Docker 引擎作为所有应用容器的协调者。除了引擎外，还有其他一些关键组件构成了 Docker 生态系统。最初，许多组件被集成到 Docker
    引擎中，但随着时间的推移，为了使引擎更小更快，一些组件，如用于管理容器的运行时机制，被拆分为独立的项目。
- en: One example of this is the containerd project. containerd, which implements
    `runc`, allows container management and is used in a number of related projects
    beyond Docker, including Kubernetes CRI.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个例子是 containerd 项目。containerd 实现了 `runc`，它支持容器管理，并且被多个与 Docker 相关的项目使用，包括
    Kubernetes CRI。
- en: Note
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can download and view the source code for containerd from GitHub at [https://github.com/docker/containerd](https://github.com/docker/containerd)
    and `runc` at [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 GitHub 下载并查看 containerd 的源代码，链接为 [https://github.com/docker/containerd](https://github.com/docker/containerd)，以及
    `runc` 的源代码，链接为 [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc)。
- en: containerd solves the problem of aggregating a number of features in the Linux
    kernel and providing an abstraction layer to handle **system calls** (**syscalls**).
    Docker Engine, therefore, sits on top of this and uses it to interact with the
    underlying operating system. An example of a task handed off to it from Docker
    Engine is attaching a process to an existing container.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: containerd 解决了聚合 Linux 内核中多个功能并提供一个抽象层来处理 **系统调用** (**syscalls**) 的问题。因此，Docker
    引擎位于其上方，并利用它与底层操作系统进行交互。一个由 Docker 引擎交给它的任务例子是将进程附加到现有容器上。
- en: This modular approach is not limited to the engine and how it interacts with
    the operating system. For example, containers and the engine do not need to reside
    on the same machine. Therefore, hosting options can be broken up.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模块化的方法不限于引擎及其与操作系统的交互。例如，容器和引擎不需要位于同一台机器上。因此，可以对托管选项进行拆分。
- en: 'This distributed model works as Docker implements a client-server model with
    the engine being the server and each of your containers acting as clients. Some
    of the key features of this architecture are as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分布式模型的运作方式是，Docker 实现了客户端-服务器模型，容器引擎作为服务器，而每个容器作为客户端。此架构的一些关键特性如下：
- en: The server running as a Linux daemon process ([https://man7.org/linux/man-pages/man7/daemon.7.html](https://man7.org/linux/man-pages/man7/daemon.7.html)).
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器作为 Linux 守护进程运行 ([https://man7.org/linux/man-pages/man7/daemon.7.html](https://man7.org/linux/man-pages/man7/daemon.7.html))。
- en: A Docker `docker` command in your terminal.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 终端中的 Docker `docker` 命令。
- en: Communication between the containers and the engine handled over a REST API.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器与引擎之间通过 REST API 进行通信。
- en: It is important to note that the communication channel between the containers
    and the engine can be encrypted using SSL/TLS.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，容器与引擎之间的通信通道可以通过 SSL/TLS 加密。
- en: SSL/TLS is the de facto standard for encrypting traffic between web endpoints.
    You will have seen it used on websites when accessing content via the HTTPS protocol.
    Later on, we will explore how you can enable SSL/TLS to help protect the Docker
    daemon socket.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: SSL/TLS 是加密 Web 端点之间流量的事实标准。当你通过 HTTPS 协议访问网站内容时，可能已经见过它的应用。稍后，我们将探讨如何启用 SSL/TLS
    来帮助保护 Docker 守护进程套接字。
- en: Docker provides an extensive set of features for configuring complex networks,
    and you can read more about it in detail at the Docker website at [https://docs.docker.com/v17.09/engine/userguide/networking/](https://docs.docker.com/v17.09/engine/userguide/networking/).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 提供了一整套用于配置复杂网络的功能，关于这一点的详细信息可以在 Docker 网站上阅读：[https://docs.docker.com/v17.09/engine/userguide/networking/](https://docs.docker.com/v17.09/engine/userguide/networking/)。
- en: The isolation that this client-server architecture provides between the host
    OS and your various containers (whether located on the same machine or distributed)
    works on the premise of least access. This means that each Docker container effectively
    only has access to the resources it needs, such as to the disk or network resources,
    and nothing more. Additionally, one Docker container cannot access the processes
    of another container.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端-服务器架构提供的隔离性，使得主机操作系统与各个容器之间（无论是否位于同一台机器上或分布式）可以基于最小访问原则进行操作。这意味着每个 Docker
    容器仅能访问其所需的资源，如磁盘或网络资源，而无法访问其他资源。此外，一个 Docker 容器无法访问另一个容器的进程。
- en: This model of least access is aided by the implementation of Linux namespaces
    to isolate processes from one another. Running Docker on Windows via a virtualized
    Linux environment hosting the engine is one way that Windows users can reap the
    benefits of this technology.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最小访问模型的实现得益于 Linux 命名空间，它用于将进程隔离开来。通过虚拟化的 Linux 环境托管引擎在 Windows 上运行 Docker，是
    Windows 用户能够享受此技术的方式之一。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you would like to learn more about how native Windows containers achieve
    process and Hyper-V isolation, you can refer to the Windows Containers website
    at [https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于原生Windows容器如何实现进程和Hyper-V隔离的信息，可以访问Windows容器网站：[https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container)。
- en: 'Docker Engine, when deploying a container, will generate a number of these
    Linux namespaces. They are as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当Docker引擎部署一个容器时，它会生成一些Linux命名空间。这些命名空间如下：
- en: The **process ID** (**PID**) namespace
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程ID**（**PID**）命名空间'
- en: The **mount** (**MNT**) namespace
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**挂载**（**MNT**）命名空间'
- en: The **networking** (**NET**) namespace
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**（**NET**）命名空间'
- en: The **inter-process communication** (**IPC**) namespace
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程间通信**（**IPC**）命名空间'
- en: The **Unix time-sharing** (**UTS**) namespace
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unix时分共享**（**UTS**）命名空间'
- en: The `USER` namespace
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER`命名空间'
- en: We'll now look at each of these in a little more detail to understand the security
    implications.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将更详细地了解这些命名空间，以理解它们的安全影响。
- en: PID namespaces
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: PID命名空间
- en: As you may know, each process in the Linux operating system resides in a tree
    structure and is assigned an ID called the PID. The PID namespace allows the separation
    of processes. By implementing the PID namespace, we can prevent our container
    from viewing the system processes. Aside from the security benefit of this, it
    has the additional benefit that system PIDs, such as PID 1, can be reused.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知道的，Linux操作系统中的每个进程都位于一个树形结构中，并被分配一个称为PID的ID。PID命名空间允许进程的隔离。通过实现PID命名空间，我们可以防止容器查看系统进程。除了安全性上的好处外，它还带来了额外的好处，即可以重用系统PID，如PID
    1。
- en: If you want to grant your containers access to system processes, you will, therefore,
    have to encode this into your Dockerfile explicitly. This follows the previously
    mentioned principle of granting the least access. So, think carefully before you
    implement any features this way.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望允许容器访问系统进程，那么你必须在Dockerfile中显式地编码这一点。这遵循了前面提到的最小权限原则。因此，在以这种方式实现任何功能之前，请仔细考虑。
- en: MNT namespaces
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MNT命名空间
- en: The MNT namespace allows a container to have access to its own collection of
    root directories and file mounts. This method allows you to create a private filesystem
    and so segment which files are accessible to which container, reducing the risk
    of a compromised container getting access to files it shouldn't or accidental
    file corruption.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: MNT命名空间允许容器访问自己的根目录集合和文件挂载。这种方法使你可以创建一个私有文件系统，从而隔离哪些文件可以被哪些容器访问，减少了被攻破的容器访问不该访问的文件或造成意外文件损坏的风险。
- en: NET namespaces
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NET命名空间
- en: Docker, as we discussed briefly, has a variety of networking tools at its disposal.
    By default, when you deploy a container, it will have its networking features
    enabled. This will allow them to make outgoing connections. By default, the container
    will use the same DNS servers as configured by the host and have a MAC address
    assigned to it. The IP address in IPv4 and IPv6 can be set using the relevant
    flags. If you chose to override the MAC address via the available flag, you should
    be aware that there is no mechanism to automatically check whether the MAC address
    is unique. Duplicate MAC addresses will likely result in a MAC address collision.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: Docker，如我们简要讨论过的，提供了多种网络工具。默认情况下，当你部署一个容器时，它将启用网络功能。这将允许容器进行外部连接。默认情况下，容器将使用主机配置的相同DNS服务器，并且会为其分配一个MAC地址。IPv4和IPv6的IP地址可以通过相关标志进行设置。如果你选择通过可用标志覆盖MAC地址，你应该知道，系统没有机制自动检查MAC地址是否唯一。重复的MAC地址可能会导致MAC地址冲突。
- en: If you wish to disable networking as part of your security posture for a particular
    container, this can be achieved by overriding the settings using the `--network`
    flag when you execute the `run` command. Setting the flag to `none` will disable
    all external access, leaving only the loopback address accessible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望禁用特定容器的网络功能作为安全防护的一部分，可以在执行`run`命令时，通过覆盖设置`--network`标志来实现。将该标志设置为`none`将禁用所有外部访问，仅保留环回地址可访问。
- en: A number of other configuration options are available to customize your container
    network settings, and these can be accessed under the help menu.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多其他配置选项可用于自定义容器网络设置，这些选项可以通过帮助菜单进行访问。
- en: IPC namespaces
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IPC命名空间
- en: The IPC namespace is used to provide separation of named shared memory segments,
    along with message queues.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: IPC 命名空间用于提供命名共享内存段的隔离，以及消息队列。
- en: IPC namespaces are locked down to prevent processes in one namespace accessing
    those within another. The benefit of this model is that a container can safely
    deploy a set of services that require memory segment utilization, such as the
    types of applications you might find in FinTech.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: IPC 命名空间被锁定，以防止一个命名空间中的进程访问另一个命名空间中的进程。这个模型的好处是，容器可以安全地部署一组需要使用内存段的服务，例如你在金融科技领域可能会遇到的应用程序类型。
- en: UTS namespaces
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UTS 命名空间
- en: The UTS namespace allows us to set the domain and hostname for processes running
    in the namespace. This namespace is a default feature, so all containers have
    it enabled, and it allows you to assign a different hostname per container.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: UTS 命名空间允许我们为在该命名空间中运行的进程设置域名和主机名。这个命名空间是默认功能，因此所有容器都有启用，它允许你为每个容器分配不同的主机名。
- en: USER namespaces
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: USER 命名空间
- en: The final category of namespace we will discuss is the `USER` namespace. This
    is a mechanism that allows you to map users and groups to a container. Once mapped,
    users can be assigned different user IDs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一个命名空间类别是 `USER` 命名空间。这是一种机制，允许你将用户和用户组映射到容器中。一旦映射，用户可以被分配不同的用户 ID。
- en: One extremely useful benefit of this feature from a security perspective is
    that it helps to prevent your container from being leveraged for privilege escalation
    attacks. Examples of how to achieve this include not only running applications
    as an unprivileged user but also mapping the root user within the container to
    a less-privileged user at the Docker host level. Therefore, processes running
    at root within the container have this privilege level limited to the container
    they operate within.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 从安全角度来看，这个功能的一个非常有用的好处是，它有助于防止容器被用于特权升级攻击。实现这一点的示例不仅包括以非特权用户身份运行应用程序，还包括在 Docker
    主机级别将容器内的 root 用户映射到一个较低权限的用户。因此，容器内以 root 身份运行的进程，其特权级别被限制在它们所在的容器内。
- en: A note on cgroups
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于 cgroups 的说明
- en: Linux **cgroups** are a mechanism used to control the number of processes that
    can be spawned and so prevent a system from suffering severe performance loss
    or worse, crashing.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Linux **cgroups** 是一种机制，用于控制可生成的进程数量，从而防止系统出现严重的性能损失，甚至崩溃。
- en: By using cgroups, we can set a limit to the number of processes that can be
    spawned through the `fork()` and `clone()` operations. Once a limit is hit, it's
    not possible to generate any further processes under the cgroup. Additionally,
    cgroups support the ability to set CPU and memory limits. You can read about their
    comprehensive list of options at [https://www.man7.org/linux/man-pages/man7/cgroups.7.html](https://www.man7.org/linux/man-pages/man7/cgroups.7.html)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 cgroups，我们可以限制通过 `fork()` 和 `clone()` 操作生成的进程数量。一旦达到限制，就无法在该 cgroup 下生成更多进程。此外，cgroups
    支持设置 CPU 和内存限制。你可以在[https://www.man7.org/linux/man-pages/man7/cgroups.7.html](https://www.man7.org/linux/man-pages/man7/cgroups.7.html)阅读它们的完整选项列表。
- en: Using this feature enables you to have more granular control over the system
    resources that your container is using. In an unfortunate event where a container
    is compromised, preventing it from over-consuming system resources is a useful
    mechanism to limit the damage until you can remediate the problem.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个功能可以让你更精细地控制容器所使用的系统资源。在容器遭到入侵的情况下，防止其过度消耗系统资源是一个有用的机制，可以在你修复问题之前限制损害。
- en: Having looked at how Docker Engine and containerd use best practices from Linux,
    let's now move on to look at some best practices that we can use that also implement
    some of the features we have discussed so far.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解了 Docker 引擎和 containerd 如何使用 Linux 最佳实践之后，我们现在来看一下我们可以使用的一些最佳实践，这些实践也实现了我们迄今为止讨论的一些功能。
- en: An overview of best practices
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最佳实践概述
- en: In the following chapters, we will be delving into techniques to ensure your
    containers are secure. You'll be happy to know that there are a number of best
    practices that you can use off the bat to ensure that you are thinking about and
    implementing security at the most basic level.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨确保容器安全的技术。你会高兴地知道，有许多最佳实践可以让你从一开始就确保你在最基本的层面上思考并实施安全性。
- en: The first thing to understand, and that you may have already picked up on, is
    that Docker containers, compared to VMs, do not provide the same level of security.
    We gave an example earlier of how a VM can be used for malware analysis due to
    its sandboxed environment. Therefore, from a security perspective, you should
    approach containers as a mechanism that is used to optimally package system resources
    and applications for development and delivery (with some very useful security
    built in) but not treat them as a micro-VM.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要理解的一点是，您可能已经注意到了，Docker 容器与虚拟机相比，提供的安全性并不相同。我们之前举过一个例子，说明虚拟机如何因其沙盒化环境被用来进行恶意软件分析。因此，从安全的角度来看，您应将容器视为一种用于优化系统资源和应用程序开发及交付的机制（内置了一些非常有用的安全性），而不是把它当作微型虚拟机来使用。
- en: With this in mind, let's look at some best practices we can apply when using
    Docker.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 记住这一点后，让我们来看一些在使用 Docker 时可以应用的最佳实践。
- en: Keeping Docker patched
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持 Docker 更新
- en: As with any application you run, it is important to keep Docker patched. Unpatched
    security vulnerabilities in Docker Engine, for example, can be leveraged by nefarious
    actors who gain access to one of your containers in the case of a breach.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 与您运行的任何应用程序一样，保持 Docker 更新非常重要。例如，Docker Engine 中未打补丁的安全漏洞可以被恶意行为者利用，在发生安全事件时，通过访问您的某个容器进行攻击。
- en: 'The Docker Desktop application in macOS, for example, provides an option to
    check for updates, and the preferences allow you to automatically check for updates:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在 macOS 中，Docker Desktop 应用程序提供了检查更新的选项，并且偏好设置允许您自动检查更新：
- en: '![](img/B11641_12_003.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B11641_12_003.jpg)'
- en: Figure 12.3 – Example of checking for updates on macOS
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – macOS 上检查更新的示例
- en: When implementing Docker, you may also wish to manually upgrade the software
    based on security patches or whether you are using the Docker Enterprise edition.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在实施 Docker 时，您可能还希望根据安全补丁或是否使用 Docker 企业版来手动升级软件。
- en: 'A list of each patch/release can be found on the Docker website with a list
    of the features added or issues addressed:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 每个补丁/版本的列表可以在 Docker 网站上找到，包含新增的功能或已解决的问题：
- en: '[https://docs.docker.com/engine/release-notes/](https://docs.docker.com/engine/release-notes/)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/release-notes/](https://docs.docker.com/engine/release-notes/)'
- en: You will notice here that some of the items are listed with the **CVE** prefix,
    which stands for **common vulnerabilities and exposures**. The CVE list is a collection
    of publicly disclosed security issues. When a security problem with Docker is
    identified, it may be listed in the CVE database, and then when it is fixed, the
    CVE ID for the issue will be listed in the release notes.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到，这里列出的一些项目带有 **CVE** 前缀，代表 **常见漏洞和暴露**。CVE 列表是公开披露的安全问题集合。当 Docker 的安全问题被发现时，它可能会列在
    CVE 数据库中，并且在修复后，问题的 CVE ID 会出现在发布说明中。
- en: As a final note on this topic, also remember to keep the underlying operating
    system that Docker is running on patched and hardened, too.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个话题的最后一点，请记得也要保持 Docker 运行所在的底层操作系统的补丁和加固。
- en: Securing the Docker daemon socket
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保护 Docker 守护进程套接字
- en: In addition to ensuring that Docker is regularly patched, we also need to safeguard
    the daemon socket. This means locking it down to prevent an attacker from using
    it to gain root access to the underlying host. Docker security documentation provides
    an extensive guide to doing this; however, we will summarize it here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 除了确保 Docker 定期打补丁外，我们还需要保护守护进程套接字。这意味着要对其进行锁定，防止攻击者利用它获得对底层主机的 root 权限。Docker
    安全文档提供了一个详尽的指南来实现这一点；但在此我们将做一个总结。
- en: Note
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: To read more about the daemon socket, review the official documentation on Docker's
    website at [https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于守护进程套接字的信息，请参考 Docker 网站上的官方文档：[https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option)。
- en: You can find the domain socket file on Linux systems at `/var/run/docker.sock`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 Linux 系统中找到域套接字文件，路径为 `/var/run/docker.sock`。
- en: This file should only be accessible via root permissions or accounts in the
    Docker group.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件应仅通过 root 权限或 Docker 组中的账户访问。
- en: We are now going to set up encrypted access over TLS/SSL to the Docker daemon
    to add another layer of protection.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将设置通过 TLS/SSL 加密访问 Docker 守护进程，以增加额外的保护层。
- en: As you may be aware, unencrypted TCP sockets are enabled through using the `-H`
    flag and include the TCP protocol, host, and port number. The port for unencrypted
    connections by convention is `2375`. Going forward, if you have been using that
    method, we recommend you stop and use the built-in TLS/SSL support.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所知，通过使用`-H`标志启用未加密的TCP套接字，包括TCP协议、主机和端口号。按惯例，未加密连接的端口是`2375`。往后，如果您一直使用这种方法，建议您停止使用，并改用内建的TLS/SSL支持。
- en: 'Before we can connect over the secure channel between our client and host,
    we need to generate the following files:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们能够通过安全通道连接客户端和主机之前，需要生成以下文件：
- en: '**Certificate authority** (**CA**) private and public keys'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**证书授权中心**（**CA**）私钥和公钥'
- en: Server key
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器密钥
- en: Server **certificate signing request** (**CSR**)
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器**证书签名请求**（**CSR**）
- en: Signed certificates
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名证书
- en: Client key
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端密钥
- en: Client CSR
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端CSR
- en: 'Depending on your operating system, the steps to generate these OpenSSL files
    will be different. The Docker website provides a handy list of steps for this
    process. Windows users can use a Linux VM to perform these steps as well:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的操作系统，生成这些OpenSSL文件的步骤会有所不同。Docker网站提供了一个方便的步骤列表。Windows用户也可以使用Linux虚拟机执行这些步骤：
- en: '[https://docs.docker.com/engine/security/https/](https://docs.docker.com/engine/security/https/)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.docker.com/engine/security/https/](https://docs.docker.com/engine/security/https/)'
- en: 'Implementing encryption can be achieved in the following fashion by enabling
    the Docker daemon to use the CA, server certificate, and server key. In this example,
    we will run the daemon on `0.0.0.0` and on port `2376`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过启用Docker守护进程使用CA、服务器证书和服务器密钥，可以以以下方式实现加密。在此示例中，我们将在`0.0.0.0`上运行守护进程，并使用端口`2376`：
- en: '[PRE0]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can test connecting to it. First, make sure that the client certificate,
    key, and CA are available. Then, run the following command:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以测试连接。首先，确保客户端证书、密钥和CA可用。然后，运行以下命令：
- en: '[PRE1]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You should now be able to successfully connect to the Docker daemon over the
    encrypted channel.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您应该能够通过加密通道成功连接到Docker守护进程。
- en: Docker won't fix bad code
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker无法修复糟糕的代码
- en: Docker can do a lot to help negate the effects of security problems, but it
    cannot fix bad code. The same best practices apply when writing applications that
    apply when deploying on an EC2 instance, VMware, or any other platform.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Docker可以做很多事情来帮助缓解安全问题的影响，但它不能修复糟糕的代码。在编写应用程序时，适用于部署在EC2实例、VMware或任何其他平台上的最佳实践同样适用于应用程序开发。
- en: A great place to start with application security is the OWASP top 10\. OWASP
    also offers a number of helpful cheat sheet guides for application security development,
    in addition to their standard documentation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序安全的一个好起点是OWASP十大漏洞。除了标准文档，OWASP还提供了许多有用的备忘单指南，用于应用程序安全开发。
- en: You can find them at [https://cheatsheetseries.owasp.org/](https://cheatsheetseries.owasp.org/).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://cheatsheetseries.owasp.org/](https://cheatsheetseries.owasp.org/)找到它们。
- en: Always set an unprivileged user
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 始终设置无特权用户
- en: We touched on the subject of the `USER` namespace and how it can aid you in
    securing your Docker setup. One practice you should implement is to make sure
    you configure containers to use an unprivileged user where possible. Doing this
    from the start will help you get into good habits.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要讨论了`USER`命名空间的主题，以及它如何帮助您提高Docker配置的安全性。您应该实施的一项实践是确保尽可能配置容器使用无特权用户。从一开始就这样做，将有助于养成良好的习惯。
- en: 'The two easiest methods to do this are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 实现这一点的两种最简单方法如下：
- en: Add a user to the Dockerfile.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向Dockerfile中添加用户。
- en: When running Docker, add the `--user` flag to the `run` command.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行Docker时，在`run`命令中添加`--user`标志。
- en: 'In the first case, this can be achieved in the following fashion:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，可以通过以下方式实现：
- en: '[PRE2]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the second option, we can apply the flag to the command line as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二种选项，我们可以将标志应用于命令行，如下所示：
- en: '[PRE3]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, we have included the user ID and group ID.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们包含了用户ID和组ID。
- en: Now that we have some basics in place, let's quickly review what we have learned
    before we further dig into some of the fundamentals and get our hands dirty.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了一些基础知识，在进一步深入一些基本原理并动手实践之前，让我们快速回顾一下我们已经学到的内容。
- en: Summary
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Over the course of this chapter, we learned about how VMs and Docker work in
    conjunction with the underlying operating system, hardware, and each other.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章过程中，我们了解了虚拟机和Docker如何与底层操作系统、硬件以及彼此协同工作。
- en: Following this, we explored the various features that Docker has implemented
    from Linux to bake in security concerns.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了 Docker 从 Linux 到实现的各种功能，以解决安全问题。
- en: Finally, we looked at some best practices that apply regardless of the applications
    we are developing. Now, let's jump into some security fundamentals and learn about
    Docker image security, commands, and the build process in the next chapter.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了一些适用于我们开发的应用程序的最佳实践。现在，让我们进入一些安全基础知识，并在下一章学习 Docker 镜像安全、命令以及构建过程。
