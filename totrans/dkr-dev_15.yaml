- en: '*Chapter 12*: Introduction to Container Security'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When developing technical projects, security should be a fundamental concern.
    We live in a world surrounded by security threats, from malware and viruses to
    data breaches. Being the victim of cybercrime or information leaks can have increasingly
    negative consequences, especially under regulations such as the EU's **General
    Data Protection Regulation** (**GDPR**).
  prefs: []
  type: TYPE_NORMAL
- en: When breaches or compromises do happen, having the ability to limit their scope
    through good architectural practices is a must. This is achieved through the concept
    of limiting what is called lateral movement. By this, we mean using one breached
    system to access another, thereby providing the attacker with the ability to traverse
    through your system, compromising further systems and stealing data.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, containerization, when deployed correctly, can help you improve
    your security posture through a variety of features that will be explored in the
    final section of this book. First, however, we should explore the technical fundamentals
    of Docker's security architecture so that we can start to build upon it. Some
    of the concepts in this chapter will be a recap of ideas we have explored elsewhere
    in this book, framed in a security setting. This should help to not only cement
    those concepts in your learning process but also help you to understand how to
    secure your application development projects.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to cover a brief overview of the security architecture
    of containers and how this relates and compares to virtualization, as well as
    how Docker Engine and containerd work from a security perspective and the concepts
    they have inherited from Linux. We will also look at an overview of best practices
    that you can implement that leverage Docker's security architecture. This will
    provide a foundation for exploring the topic deeper in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization and hypervisor security models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Container security models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Engine and containerd – Linux security features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A note on cgroups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's start by reviewing how containers and virtualization differ and how
    security is a fundamental component of both.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have access to a Linux machine running Docker.
    We recommend that you use the setup you have been using so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: If you have jumped to the security section as your starting point, we recommend
    you install the Docker Community Edition from [https://docs.docker.com/v17.09/engine/installation/](https://docs.docker.com/v17.09/engine/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3gW33FD](https://bit.ly/3gW33FD)'
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization and hypervisor security models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we explored how Docker works and how it compares to other
    technologies, such as FreeBSD jails and virtualization. Building on what we learned
    here, we will now seek to understand the security model that underpins Docker
    better.
  prefs: []
  type: TYPE_NORMAL
- en: To start with, let's look at how security is implemented by virtualization tools
    so that we can then understand how Docker matches and differs from them.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization and protection rings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using **virtual machines** (**VMs**), you may have come across the term
    hypervisor. This is a program that orchestrates how the VMs run on your system
    and interact with the underlying hardware. Some hypervisor products, known as
    type 1 hypervisors, run directly on top of the hardware. Others, such as VirtualBox,
    are installed via your existing operating system and allow you to load additional
    operating systems as VMs.
  prefs: []
  type: TYPE_NORMAL
- en: How the hypervisor works with the underlying hardware is governed by what is
    known as protection rings. These rings dictate the layers of privilege, effectively
    deciding which aspects of a computer system's software, such as the operating
    system, drivers, and desktop applications, can access which parts of the underlying
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, you will see the protection ring modeled as a set of concentric
    circles, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.1 – Protection ring example
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes the **device drivers** ring may show as two separate rings as well
    (denoted by the dotted circle in the diagram).
  prefs: []
  type: TYPE_NORMAL
- en: Each hardware architecture will differ slightly in its adaptation of the protection
    ring model and, in turn, the operating systems that run on it may also run code
    at different levels than expected. However, it is typical to find ring 0—that
    is, the ring at the center with the most privilege—denoted as the **kernel ring**
    (sometimes called **kernel land**).
  prefs: []
  type: TYPE_NORMAL
- en: Malicious software will often try to attack the kernel in order to gain full
    access over the system and run low-level system processes. This software is usually
    known as kernel-mode rootkits. Therefore, protecting the kernel is a must, as
    well as ensuring that if a system is breached with a malicious application, library,
    or package, it cannot escalate privileges to gain kernel access is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: Outer rings may then handle device drivers and applications. Each is assigned
    a ring and the outer ring containing user applications is often known as **user
    land**. Gates handle how each ring can speak to the ring below it. As with the
    kernel, there is a risk of malicious software infecting applications that run
    at these levels including user-mode rootkits that run at level 3.
  prefs: []
  type: TYPE_NORMAL
- en: With these threats in mind, the protection ring model helps prevent the programs
    that you install on your desktop from maliciously accessing the underlying hardware
    and bypassing the kernel. Therefore, malware writers are forced to look for security
    holes and other means of obfuscating their attacks, such as injecting their code
    into other processes. You can think of these layers of security as providing a
    set of doors that need to be breached, rather than an attacker just being able
    to walk in and be given direct access to the underlying hardware.
  prefs: []
  type: TYPE_NORMAL
- en: These layers of segmentation, while not foolproof, help to provide what is known
    as a layered approach to security. The idea here is that by adding one layer of
    security to another, we make it increasingly difficult for an attack to be pulled
    off.
  prefs: []
  type: TYPE_NORMAL
- en: Virtualization and malware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since we are interested in virtualization and subsequently, how this compares
    to Docker containers, we are, of course, interested in how virtualization fits
    into this model. How does virtualization protect against rootkits and other malware?
  prefs: []
  type: TYPE_NORMAL
- en: Many modern hardware architectures, such as the ARMv7-A, include a hypervisor
    as a privilege level in our ring model that is more privileged than the operating
    system level. This allows the hypervisor to switch between operating systems that
    are running at the next ring above.
  prefs: []
  type: TYPE_NORMAL
- en: Some architectures also implement what is known as **ring -1**. This allows
    the hypervisor to run at a further deeper security ring, with the guest operating
    system kernels running at ring 0\. If, for example, you are running VirtualBox
    on top of an x86 platform, depending on whether hardware virtualization exists,
    VirtualBox will run either at ring -1 or ring 0.
  prefs: []
  type: TYPE_NORMAL
- en: VMs are useful for conducting malware analysis for a number of reasons, including
    the fact the machine can be locked down, so it is a self-contained environment.
    Once the investigator is done analyzing the code and its effects, the VM can be
    deleted without having to reinstall the whole operating system of the machine,
    or (if configured correctly) risk the malware gaining access to the underlying
    hardware.
  prefs: []
  type: TYPE_NORMAL
- en: So, in summary, protection rings provide a mechanism to provide a way to segment
    software so that it can only access certain resources. In a virtualization model,
    a hypervisor can run in the ring with the most privilege to switch between operating
    systems. A hypervisor can be installed via an existing operating system, such
    as Windows, or be deployed on bare metal, such as the VMware ESXi product. It
    can also be used to create a sandbox environment that prevents malicious code
    from infecting the underlying hardware or operating system.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this compare to Docker and how does the protection ring model apply?
  prefs: []
  type: TYPE_NORMAL
- en: Docker and protection rings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like VMs, Docker containers provide an isolated environment for running your
    code on top of an existing operating system. This operating system can be either
    virtualized or installed directly onto bare metal.
  prefs: []
  type: TYPE_NORMAL
- en: So, how does this work? You may remember that Docker containers run on top of
    Docker Engine, which in turn sits on top of the operating system via an intermediate
    component called **containerd**. This is in comparison to the type 1 hypervisor,
    which runs on top of the infrastructure, as we discussed previously, with the
    guest operating systems running on top of the hypervisor.
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers, therefore, all run on top of the same operating system, regardless
    of whether it is virtualized or not. In fact, in some instances, such as if you
    run Linux containers on Docker on Windows, you may notice that it uses an intermediary
    step. This consists of running a virtualized version of Linux, which in turn runs
    the Docker engine. In this scenario, all the containers are running on the same
    virtualized Linux operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine Enterprise Edition also supports native Windows containers. You
    can read more about them at [https://www.docker.com/products/windows-containers](https://www.docker.com/products/windows-containers).
  prefs: []
  type: TYPE_NORMAL
- en: The key concept to all of this is that isolation happens at the container level,
    rather than—or in addition to—the VM level. So, at a basic level, Docker does
    not provide the same sandboxing that the VM itself does.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates the difference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.2 – Example of isolation in Docker and VMs
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, if we run Docker on the VM stack, we would replace
    the **Applications** layer with the **Docker Engine**/**Containerd** and container
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: As you can probably see, this provides a layer of security in addition to that
    provided by the underlying host operating system or, when applicable, the additional
    layer of the hypervisor. However, this layer of security when operating on top
    of the host operating system and not via a VM does mean that if the Docker Engine
    contains a security vulnerability, you have an additional layer of risk.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker containers' access to the underlying system/kernel, therefore, is
    mediated by the engine, which in turn makes system calls via containerd (and,
    in most cases, is called via `runc`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you want to read about containerd and runc in more detail, check out the
    official website at [https://containerd.io/](https://containerd.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we have provided a level of isolation between each container and the underlying
    operating system and hardware. Docker Engine does not run at ring 0 or ring -1,
    but rather at ring 3, meaning while it is susceptible to other forms of attack,
    it does not have direct access to the hardware as the hypervisor does.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Even with this layered approach to security, flaws have been found in the past.
    You can read more at [https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/](https://www.twistlock.com/labs-blog/breaking-docker-via-runc-explaining-cve-2019-5736/).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, each container is a separate self-contained set of libraries and
    applications that can only communicate with each other via Docker Engine. By default,
    as we noted, the containers do not have access to the underlying operating system
    that Docker Engine is hosted on. In fact, any calls to access system resources
    at the underlying OS level have to be explicitly configured when setting up the
    Dockerfile. The Docker containers, therefore, run at ring level 3, aka user land,
    with additional layers of security in place.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an understanding of the ring model and how Docker and virtualization
    work in conjunction with it, let's look at container security models and what
    they have inherited from Linux's best practices and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Container security models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Moving up from the hardware layer and how the hypervisor and base operating
    system mediate access to it, we can begin to review what happens at the software
    layer running at ring level 3\. To explore this, there are two key features of
    Docker''s container security model that we need to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Applications are isolated from the underlying host system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerized applications are isolated from each other.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, how does Docker achieve these objectives? The answer to this is, as you
    may have guessed, via Docker Engine and related components, such as containerd.
    These components have inherited a number of key Linux features and concepts with
    major benefits for security, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**runc**: A lightweight container runtime'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Namespaces**: A Linux method for partitioning kernel resources'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Control groups (cgroups)**: A kernel feature for limiting resources such
    as CPU usage'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, it also allows the implementation of other security features
    found in the Linux kernel, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SELinux**: The Linux kernel security module for handling access control security
    policies'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AppArmor**: A Linux feature for restricting application capabilities'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**TOMOYO**: A Linux security module for handling **mandatory access control**
    (**MAC**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GRSEC**: A collection of security enhancements for the Linux kernel'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tried and true best practices allow containers to be isolated from one
    another and from the host operating system in a secure fashion. We will now delve
    deeper into Docker Engine and containerd to get a better understanding of how
    these security features are implemented.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine and containerd – Linux security features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Engine, which you installed previously, acts as the coordinator for all
    your application containers. In addition to the engine are other key components
    that make up the Docker ecosystem. Initially, many of the components were baked
    into Docker Engine, but over the years, in order to make the engine smaller and
    faster, some components, such as the runtime mechanism for managing containers,
    were broken down into separate projects.
  prefs: []
  type: TYPE_NORMAL
- en: One example of this is the containerd project. containerd, which implements
    `runc`, allows container management and is used in a number of related projects
    beyond Docker, including Kubernetes CRI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can download and view the source code for containerd from GitHub at [https://github.com/docker/containerd](https://github.com/docker/containerd)
    and `runc` at [https://github.com/opencontainers/runc](https://github.com/opencontainers/runc).
  prefs: []
  type: TYPE_NORMAL
- en: containerd solves the problem of aggregating a number of features in the Linux
    kernel and providing an abstraction layer to handle **system calls** (**syscalls**).
    Docker Engine, therefore, sits on top of this and uses it to interact with the
    underlying operating system. An example of a task handed off to it from Docker
    Engine is attaching a process to an existing container.
  prefs: []
  type: TYPE_NORMAL
- en: This modular approach is not limited to the engine and how it interacts with
    the operating system. For example, containers and the engine do not need to reside
    on the same machine. Therefore, hosting options can be broken up.
  prefs: []
  type: TYPE_NORMAL
- en: 'This distributed model works as Docker implements a client-server model with
    the engine being the server and each of your containers acting as clients. Some
    of the key features of this architecture are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The server running as a Linux daemon process ([https://man7.org/linux/man-pages/man7/daemon.7.html](https://man7.org/linux/man-pages/man7/daemon.7.html)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker `docker` command in your terminal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication between the containers and the engine handled over a REST API.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is important to note that the communication channel between the containers
    and the engine can be encrypted using SSL/TLS.
  prefs: []
  type: TYPE_NORMAL
- en: SSL/TLS is the de facto standard for encrypting traffic between web endpoints.
    You will have seen it used on websites when accessing content via the HTTPS protocol.
    Later on, we will explore how you can enable SSL/TLS to help protect the Docker
    daemon socket.
  prefs: []
  type: TYPE_NORMAL
- en: Docker provides an extensive set of features for configuring complex networks,
    and you can read more about it in detail at the Docker website at [https://docs.docker.com/v17.09/engine/userguide/networking/](https://docs.docker.com/v17.09/engine/userguide/networking/).
  prefs: []
  type: TYPE_NORMAL
- en: The isolation that this client-server architecture provides between the host
    OS and your various containers (whether located on the same machine or distributed)
    works on the premise of least access. This means that each Docker container effectively
    only has access to the resources it needs, such as to the disk or network resources,
    and nothing more. Additionally, one Docker container cannot access the processes
    of another container.
  prefs: []
  type: TYPE_NORMAL
- en: This model of least access is aided by the implementation of Linux namespaces
    to isolate processes from one another. Running Docker on Windows via a virtualized
    Linux environment hosting the engine is one way that Windows users can reap the
    benefits of this technology.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you would like to learn more about how native Windows containers achieve
    process and Hyper-V isolation, you can refer to the Windows Containers website
    at [https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container](https://docs.microsoft.com/en-us/virtualization/windowscontainers/manage-containers/hyperv-container).
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Engine, when deploying a container, will generate a number of these
    Linux namespaces. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The **process ID** (**PID**) namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **mount** (**MNT**) namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **networking** (**NET**) namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **inter-process communication** (**IPC**) namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Unix time-sharing** (**UTS**) namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `USER` namespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We'll now look at each of these in a little more detail to understand the security
    implications.
  prefs: []
  type: TYPE_NORMAL
- en: PID namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may know, each process in the Linux operating system resides in a tree
    structure and is assigned an ID called the PID. The PID namespace allows the separation
    of processes. By implementing the PID namespace, we can prevent our container
    from viewing the system processes. Aside from the security benefit of this, it
    has the additional benefit that system PIDs, such as PID 1, can be reused.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to grant your containers access to system processes, you will, therefore,
    have to encode this into your Dockerfile explicitly. This follows the previously
    mentioned principle of granting the least access. So, think carefully before you
    implement any features this way.
  prefs: []
  type: TYPE_NORMAL
- en: MNT namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The MNT namespace allows a container to have access to its own collection of
    root directories and file mounts. This method allows you to create a private filesystem
    and so segment which files are accessible to which container, reducing the risk
    of a compromised container getting access to files it shouldn't or accidental
    file corruption.
  prefs: []
  type: TYPE_NORMAL
- en: NET namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker, as we discussed briefly, has a variety of networking tools at its disposal.
    By default, when you deploy a container, it will have its networking features
    enabled. This will allow them to make outgoing connections. By default, the container
    will use the same DNS servers as configured by the host and have a MAC address
    assigned to it. The IP address in IPv4 and IPv6 can be set using the relevant
    flags. If you chose to override the MAC address via the available flag, you should
    be aware that there is no mechanism to automatically check whether the MAC address
    is unique. Duplicate MAC addresses will likely result in a MAC address collision.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to disable networking as part of your security posture for a particular
    container, this can be achieved by overriding the settings using the `--network`
    flag when you execute the `run` command. Setting the flag to `none` will disable
    all external access, leaving only the loopback address accessible.
  prefs: []
  type: TYPE_NORMAL
- en: A number of other configuration options are available to customize your container
    network settings, and these can be accessed under the help menu.
  prefs: []
  type: TYPE_NORMAL
- en: IPC namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The IPC namespace is used to provide separation of named shared memory segments,
    along with message queues.
  prefs: []
  type: TYPE_NORMAL
- en: IPC namespaces are locked down to prevent processes in one namespace accessing
    those within another. The benefit of this model is that a container can safely
    deploy a set of services that require memory segment utilization, such as the
    types of applications you might find in FinTech.
  prefs: []
  type: TYPE_NORMAL
- en: UTS namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The UTS namespace allows us to set the domain and hostname for processes running
    in the namespace. This namespace is a default feature, so all containers have
    it enabled, and it allows you to assign a different hostname per container.
  prefs: []
  type: TYPE_NORMAL
- en: USER namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final category of namespace we will discuss is the `USER` namespace. This
    is a mechanism that allows you to map users and groups to a container. Once mapped,
    users can be assigned different user IDs.
  prefs: []
  type: TYPE_NORMAL
- en: One extremely useful benefit of this feature from a security perspective is
    that it helps to prevent your container from being leveraged for privilege escalation
    attacks. Examples of how to achieve this include not only running applications
    as an unprivileged user but also mapping the root user within the container to
    a less-privileged user at the Docker host level. Therefore, processes running
    at root within the container have this privilege level limited to the container
    they operate within.
  prefs: []
  type: TYPE_NORMAL
- en: A note on cgroups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Linux **cgroups** are a mechanism used to control the number of processes that
    can be spawned and so prevent a system from suffering severe performance loss
    or worse, crashing.
  prefs: []
  type: TYPE_NORMAL
- en: By using cgroups, we can set a limit to the number of processes that can be
    spawned through the `fork()` and `clone()` operations. Once a limit is hit, it's
    not possible to generate any further processes under the cgroup. Additionally,
    cgroups support the ability to set CPU and memory limits. You can read about their
    comprehensive list of options at [https://www.man7.org/linux/man-pages/man7/cgroups.7.html](https://www.man7.org/linux/man-pages/man7/cgroups.7.html)
  prefs: []
  type: TYPE_NORMAL
- en: Using this feature enables you to have more granular control over the system
    resources that your container is using. In an unfortunate event where a container
    is compromised, preventing it from over-consuming system resources is a useful
    mechanism to limit the damage until you can remediate the problem.
  prefs: []
  type: TYPE_NORMAL
- en: Having looked at how Docker Engine and containerd use best practices from Linux,
    let's now move on to look at some best practices that we can use that also implement
    some of the features we have discussed so far.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the following chapters, we will be delving into techniques to ensure your
    containers are secure. You'll be happy to know that there are a number of best
    practices that you can use off the bat to ensure that you are thinking about and
    implementing security at the most basic level.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to understand, and that you may have already picked up on, is
    that Docker containers, compared to VMs, do not provide the same level of security.
    We gave an example earlier of how a VM can be used for malware analysis due to
    its sandboxed environment. Therefore, from a security perspective, you should
    approach containers as a mechanism that is used to optimally package system resources
    and applications for development and delivery (with some very useful security
    built in) but not treat them as a micro-VM.
  prefs: []
  type: TYPE_NORMAL
- en: With this in mind, let's look at some best practices we can apply when using
    Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping Docker patched
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with any application you run, it is important to keep Docker patched. Unpatched
    security vulnerabilities in Docker Engine, for example, can be leveraged by nefarious
    actors who gain access to one of your containers in the case of a breach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Desktop application in macOS, for example, provides an option to
    check for updates, and the preferences allow you to automatically check for updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B11641_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 12.3 – Example of checking for updates on macOS
  prefs: []
  type: TYPE_NORMAL
- en: When implementing Docker, you may also wish to manually upgrade the software
    based on security patches or whether you are using the Docker Enterprise edition.
  prefs: []
  type: TYPE_NORMAL
- en: 'A list of each patch/release can be found on the Docker website with a list
    of the features added or issues addressed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/release-notes/](https://docs.docker.com/engine/release-notes/)'
  prefs: []
  type: TYPE_NORMAL
- en: You will notice here that some of the items are listed with the **CVE** prefix,
    which stands for **common vulnerabilities and exposures**. The CVE list is a collection
    of publicly disclosed security issues. When a security problem with Docker is
    identified, it may be listed in the CVE database, and then when it is fixed, the
    CVE ID for the issue will be listed in the release notes.
  prefs: []
  type: TYPE_NORMAL
- en: As a final note on this topic, also remember to keep the underlying operating
    system that Docker is running on patched and hardened, too.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the Docker daemon socket
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to ensuring that Docker is regularly patched, we also need to safeguard
    the daemon socket. This means locking it down to prevent an attacker from using
    it to gain root access to the underlying host. Docker security documentation provides
    an extensive guide to doing this; however, we will summarize it here.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To read more about the daemon socket, review the official documentation on Docker's
    website at [https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option](https://docs.docker.com/engine/reference/commandline/dockerd/#daemon-socket-option).
  prefs: []
  type: TYPE_NORMAL
- en: You can find the domain socket file on Linux systems at `/var/run/docker.sock`.
  prefs: []
  type: TYPE_NORMAL
- en: This file should only be accessible via root permissions or accounts in the
    Docker group.
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to set up encrypted access over TLS/SSL to the Docker daemon
    to add another layer of protection.
  prefs: []
  type: TYPE_NORMAL
- en: As you may be aware, unencrypted TCP sockets are enabled through using the `-H`
    flag and include the TCP protocol, host, and port number. The port for unencrypted
    connections by convention is `2375`. Going forward, if you have been using that
    method, we recommend you stop and use the built-in TLS/SSL support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can connect over the secure channel between our client and host,
    we need to generate the following files:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Certificate authority** (**CA**) private and public keys'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server **certificate signing request** (**CSR**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed certificates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client CSR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depending on your operating system, the steps to generate these OpenSSL files
    will be different. The Docker website provides a handy list of steps for this
    process. Windows users can use a Linux VM to perform these steps as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/security/https/](https://docs.docker.com/engine/security/https/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing encryption can be achieved in the following fashion by enabling
    the Docker daemon to use the CA, server certificate, and server key. In this example,
    we will run the daemon on `0.0.0.0` and on port `2376`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can test connecting to it. First, make sure that the client certificate,
    key, and CA are available. Then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You should now be able to successfully connect to the Docker daemon over the
    encrypted channel.
  prefs: []
  type: TYPE_NORMAL
- en: Docker won't fix bad code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker can do a lot to help negate the effects of security problems, but it
    cannot fix bad code. The same best practices apply when writing applications that
    apply when deploying on an EC2 instance, VMware, or any other platform.
  prefs: []
  type: TYPE_NORMAL
- en: A great place to start with application security is the OWASP top 10\. OWASP
    also offers a number of helpful cheat sheet guides for application security development,
    in addition to their standard documentation.
  prefs: []
  type: TYPE_NORMAL
- en: You can find them at [https://cheatsheetseries.owasp.org/](https://cheatsheetseries.owasp.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Always set an unprivileged user
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We touched on the subject of the `USER` namespace and how it can aid you in
    securing your Docker setup. One practice you should implement is to make sure
    you configure containers to use an unprivileged user where possible. Doing this
    from the start will help you get into good habits.
  prefs: []
  type: TYPE_NORMAL
- en: 'The two easiest methods to do this are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a user to the Dockerfile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When running Docker, add the `--user` flag to the `run` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the first case, this can be achieved in the following fashion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With the second option, we can apply the flag to the command line as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have included the user ID and group ID.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some basics in place, let's quickly review what we have learned
    before we further dig into some of the fundamentals and get our hands dirty.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the course of this chapter, we learned about how VMs and Docker work in
    conjunction with the underlying operating system, hardware, and each other.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we explored the various features that Docker has implemented
    from Linux to bake in security concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we looked at some best practices that apply regardless of the applications
    we are developing. Now, let's jump into some security fundamentals and learn about
    Docker image security, commands, and the build process in the next chapter.
  prefs: []
  type: TYPE_NORMAL
