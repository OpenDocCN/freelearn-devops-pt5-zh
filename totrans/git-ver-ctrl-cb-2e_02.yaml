- en: Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration targets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Querying the existing configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A .git directory template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A few configuration examples
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Git aliases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The refspec exemplified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git, while serving a basic and crucial role in the life of a developer, is also
    quite complex and highly configurable. This chapter will give an overview of the
    most important options available and will provide the right tools for learning
    and navigating the multitude of configuration flags and fields available, in order
    to tailor your Git experience to your own needs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration targets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will look at the different layers that can be configured.
    The layers are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SYSTEM`: This layer is system-wide and can be found in `/etc/gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GLOBAL`: This layer is global for the user and can be found in `~/.gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LOCAL`: This layer is local to the current repository and can be found in
    `.git/config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the `jgit` repository for this example; clone it, or use the clone
    you already have from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we saw how we could use the command `git config --list`
    to list configuration entries. This list is actually made from three different
    levels of configuration that Git offers: system-wide configuration, `SYSTEM`;
    global configuration for the user, `GLOBAL`; and local repository configuration,
    `LOCAL`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For each of the configuration layers, we can query the existing configuration.
    On a Windows box with a default installation of the Git extensions, the different
    configuration layers will look something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also query a single key and limit the scope to one of the three layers,
    by using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can set the email address of the user to a different one for the current
    repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, listing the `GLOBAL` layer `user.email` will return `john.doe@example.com`,
    listing `LOCAL` will give `john@example.com`, and listing `user.email` without
    specifying the layer will give the effective value that is used in the operations
    on this repository; in this case, the `LOCAL` value `john@example.com`. The effective
    value will take precedence when needed. When two or more values are specified
    for the same key, but on different layers, the lowest layer takes precedence.
    When a configuration value is needed, Git will first look in the `LOCAL` configuration.
    If not found here, the `GLOBAL` configuration is queried. If it is not found in
    the `GLOBAL` configuration, the `SYSTEM` configuration is used.
  prefs: []
  type: TYPE_NORMAL
- en: If none of this works, the default value in Git is used.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous example, `user.email` is specified in both the `GLOBAL` and
    `LOCAL` layers. Therefore, the `LOCAL` layer will be used.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Querying the three layers of configuration simply returns the content of the
    configuration files; `/etc/gitconfig` for system-wide configuration, `~/.gitconfig`
    for user-specific configuration, and `.git/config` for repository-specific configuration.
    When not specifying the configuration layer, the returned value will be the effective
    value.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Instead of setting all the configuration values on the command line by the
    key value, it is possible to set them by just editing the configuration file directly.
    Open the configuration file in your favorite editor and set the configuration
    you need, or use the built-in `git config -e` repository to edit the configuration
    directly in the Git-configured editor. You can set the editor to the editor of
    your choice either by changing the $`EDITOR` environment variable or with the
    `core.editor` configuration target, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Querying the existing configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will look at how we can query the existing configuration
    and set the configuration values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use `jgit` again by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can use `git config` to query your local and global Git configuration. In
    this section, we will show a couple of examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'To view all the effective configurations for the current Git repository, run
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The previous output will, of course, reflect the user running the command. Instead
    of `John Doe` as the name and the email, the output should reflect your settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are just interested in a single configuration item, we can just query
    it by its `section.key` or `section.subsection.key`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git''s configuration is stored in plain text files and works like a key-value
    storage. You can set/query by key and get the value back. An example of the text-based
    configuration file is shown as follows (from the `jgit` repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is also easy to set configuration values. You can use the same syntax as
    you did when querying the configuration, except you need to add an argument to
    the value. To set a new email address on the `LOCAL` layer, we can execute the
    following command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `LOCAL` layer is the default, if nothing else is specified. If you require
    whitespaces in the value, you can enclose the string in quotation marks, as you
    would do when configuring your name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even set your own configuration, which does not have any effect on
    the core Git, but which can be useful for scripting/builds, and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'List the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also very easy to delete/unset configuration entries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'List the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we will see how to create a template commit message that will
    be displayed in the editor when creating a commit. The template is only for the
    local user and not distributed with the repository in general.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will use the example repository from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use the following command as a commit message template for commit messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Save the commit message template in `$HOME/.gitcommitmsg.txt`. The filename
    isn't fixed and you can choose a filename of your liking.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To let Git know about our new commit message template, we can set the configuration
    variable `commit.template` to point at the file we just created with that template;
    we''ll do it globally so it is applicable to all our repositories:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try to change a file, add it, and create a commit. This will bring
    up our preferred editor with the commit message template preloaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can now edit the message according to our commit and save to complete the
    commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When `commit.template` is set, Git simply uses the content of the template file
    as a starting point for all commit messages. This is quite convenient if you have
    a commit-message policy, as it greatly increases the chances of the policy being
    followed. You can even have different templates tied to different repositories
    since you can just set the configuration at the local level.
  prefs: []
  type: TYPE_NORMAL
- en: A .git directory template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, having a global configuration isn't enough. You will also need to
    trigger the execution of scripts (also known as Git hooks), exclude files, and
    so on. It is possible to achieve this with the template option set to `git init`.
    It can be given as a command-line option to `git clone` and `git init`, or as
    the `$GIT_TEMPLATE_DIR` environment variable, or as the configuration option `init.templatedir`.
    It defaults to `/usr/share/git-core/templates`. The template option works by copying
    files in the template directory to the `.git ($GIT_DIR)` folder after it has been
    created. The default directory contains sample hooks and some suggested exclude
    patterns. In the following example, we'll see how we can set up a new template
    directory, and add a commit message hook and an exclude file.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will create the template directory. We can use any name we want,
    and we''ll use `~/.git_template`, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we need to populate the directory with some template files. This could
    be a hook or an exclude file. We will create one hook file and one exclude file.
    The hook file is located in `.git/hooks/name-of-hook` and the exclude file in
    `.git/info/exclude`. Create the two directories needed, `hooks` and `info`, as
    shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep the sample hooks provided by the default template directory (the Git
    installation), we copy the files in the default template directory to the new
    one. When we use our newly created template directory, we''ll override the default
    one. So, copying the default files to our template directory will make sure that,
    excepting our specific changes, the template directory is similar to the default
    one, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use the `commit-msg` hook as the example hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The hook is very simple and will just add `Hi from the template commit-msg
    hook` to the end of the commit message. Save it as `commit-msg` in the `~/.git_template/hooks`
    directory and make it executable by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now that the commit message hook is done, let's also add an exclude file to
    the example. The exclude file works like the `.gitignore` file, but is not tracked
    in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll create an exclude file that excludes all the `*.txt` files, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Now, our template directory is ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our template directory is ready, and we can use it, as described earlier, as
    a command-line option, an environment variable or, as in this example, to be set
    as a configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, all Git repositories we create using `init` or `clone` will have the default
    files of the template directory. We can test whether it works by creating a new
    repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to create a `.txt` file and see what `git status` tells us. It should
    be ignored by the exclude file from the template directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The exclude file worked! You can put in the file endings yourself, or just leave
    it blank and keep to the `.gitignore` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test whether the `commit-msg` hook works, let''s try to create a commit.
    First, we need a file to commit. So, let''s create that and commit it as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now check the history with `git log`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When Git creates a new repository, either via `init` or `clone`, it will copy
    the files from the `template` directory (the default location is `/usr/share/git-core/templates`)
    to the new repository when creating the directory structure. The template directory
    can be defined either by a command-line argument, an environment variable, or
    a configuration option. If nothing is specified, the default template directory
    will be used (distributed with the Git installation). By setting the configuration
    as a `--global` option, the template directory defined will apply to all of the
    user's (new) repositories. This is a very nice way to distribute the same hooks
    across repositories, but it also has some drawbacks. As the files in the template
    directory are only copied to the Git repositories, updates to the template directory
    do not affect the existing repositories. This can be solved by running `git init`
    in each existing repository to reinitialize the repository, but this can be quite
    cumbersome. Also, the template directory can enforce hooks on some repositories
    where you don't want them. This is quite easily solved by simply deleting the
    hook files in `.git/hooks` of that repository.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For more information on hooks in Git, please refer to [Chapter 7](fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml),
    *Enhancing Your Daily Work with Git Hooks, Aliases, and Scripts*.
  prefs: []
  type: TYPE_NORMAL
- en: A few configuration examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are configuration targets in the core Git system. In this section, we'll
    take a closer look at a few of them that might be useful in your daily work.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at the following three different configuration areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Rebase and merge setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expiry of objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autocorrect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll just set a few configurations. We''ll use the data
    model repository from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's take a closer look at the previously mentioned configuration areas.
  prefs: []
  type: TYPE_NORMAL
- en: Rebase and merge setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, when performing `git pull`, a merge commit will be created if the
    history of the local branch has diverged from the remote one. However, to avoid
    all these merge commits, a repository can be configured so that it will default
    to rebase instead of merging when doing `git pull`. Several configuration targets
    related to the option are available as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pull.rebase`: This configuration, when set to `true`, will pull to rebase
    the current branch on top of the fetched one when performing a `git pull`. It
    can also be set to `preserve` so that the local merge commit will not be flattened
    in the rebase, by passing `--preserve-merges` to `git rebase`. The default value
    is `false`,as the configuration is not set. To set this option in your local repository,
    run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '`branch.autosetuprebase`: When this configuration is set to `always`, any new
    branch created with `<git branch` or `git checkout` that tracks another branch
    will be set up to pull to rebase (instead of merge). The valid options are as
    follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`never`: This is set to pull to rebase (default)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`local`: This is set to pull to rebase for local tracked branches'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`remote`: This is set to pull to rebase for remote tracked branches'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`always`: This is set to pull to rebase for all tracked branches'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To set this option for all the new branches regardless of tracking remote or
    local branches, run the following command:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`branch.<name>.rebase`: This configuration, when set to `true`, applies only
    to the `<name>` branch and tells Git to pull to rebase when performing `git pull`
    on the given branch. It can also be set to `preserve` so that the local merge
    commit will not be flattened when running `git pull`. By default, the configuration
    is not set for any branch. To set the `feature/2` branch in the repository to
    default to rebase, instead of merge, we can run the following command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Expiry of objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, Git will perform garbage collection on unreferenced objects and
    clean `reflog` for entries that are more than 90 days old. For an object to be
    referenced, something must point to it; a tree, a commit, a tag, a branch, or
    some of the internal Git bookkeeping, such as `stash` or `reflog`. There are three
    settings that can be used to change this time as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gc.reflogexpire`: This is the general setting to know for how long a branch''s
    history is kept in `reflog`. The default time is 90 days. The setting is a length
    of time, for example, `10 days, 6 months`, and it can be turned completely with
    the value `never`. The setting can be set to match a `refs` pattern by supplying
    the pattern in the configuration setting. `gc.<pattern>.reflogexpire`: This pattern
    can, for example, be `/refs/remotes/*`,and the expire setting would then only
    apply for those refs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gc.reflogexpireunreachable`: This setting controls how long the `reflog` entries
    that are not a part of the current branch history should be available in the repository.
    The default value is `30 days`, and similar to the previous option, it is expressed
    as a length of time or set to `never` in order to turn it off. This setting can,
    as the previous one, be set to match a `refs` pattern.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gc.pruneexpire`: This option tells `git gc` to prune objects older than the
    value. The default is `2.weeks.ago`, and the value can be expressed as a relative
    date, such as `3.months.ago`. To disable the grace period, the value `now` can
    be used. To set a non-default expiry date on remote branches only, use the following
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set a date so `git gc` will prune objects sooner:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Autocorrect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This configuration is useful when you get tired of messages such as the following
    one just because you made a typo on the keyboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting the configuration to `help.autocorrect`, you can control how Git
    will behave when you accidentally send a typo to it. By default, the value is
    `0` and it means to list the possible options similar to the input (if `statis`is
    given, `status` will be shown). A negative value means to immediately execute
    the corresponding command. A positive value means to wait the given number of
    deciseconds (0.1 sec) before running the command (so there is an amount of time
    in which to cancel it). If several commands can be deduced from the text entered,
    nothing will happen. Setting the value to half a second gives you some time to
    cancel a wrong command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting the configuration targets will change the way Git behaves. The previous
    examples describe a few useful methods to get Git to act differently than its
    default behavior. You should be sure when you are changing a configuration that
    you completely understand what that configuration does. Therefore, check the Git
    configuration help page by using `git help config`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a lot of configuration targets available in Git. You can run `git
    help config` and all of them will be displayed and explained over a few pages.
  prefs: []
  type: TYPE_NORMAL
- en: Git aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An alias is a nice way to configure long and/or complicated Git commands to
    represent short useful ones. An alias is simply a configuration entry under the
    alias section. It is usually configured to `--global` to apply it everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we will use the `jgit` repository, which was also used in
    [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml), *Navigating Git*, with
    the `master` branch pointing at `b14a93971837610156e815ae2eee3baaa5b7a44b`. Either
    use the clone from [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml), *Navigating
    Git*, or clone the repository again, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll create a few simple aliases, then a couple of more special ones,
    and finally, a couple of aliases using external commands. Instead of writing `git
    checkout` every time we need to switch branches, we can create an alias of that
    command and call it `git co`. We can do the same for `git branch`, `git commit`,
    and `git status` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, try to run `git st` in the `jgit` repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The `alias` method is also good for creating the Git commands you think are
    missing in Git. One of the common Git aliases is `unstage`, which is used to move
    a file out of the staging area, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Try to edit the `README.md` file in the root of the `jgit` repository and add
    it to the root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, `git status/git st` should display something like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to unstage `README.md` and then look at `git st` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'A common use case for aliases is to format the history of Git in specific ways.
    Let''s say you want the number of lines added and deleted for each file in the
    commit displayed along with some common commit data. For this, we can create the
    following alias so we don''t have to type everything each time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute `git ll` in the terminal and get a nice stat output, as
    shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to use an external command instead of a Git command. So,
    small shell scripts and so on can be embedded. To create an `alias` method with
    an external command, the alias must start with an exclamation mark `!`. The examples
    can be used when resolving conflicts from a rebase or merge. In your `~/.gitconfig`
    file under `[alias]`, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This will bring up your configured $`EDITOR` with all the files that are in
    the conflict state due to the merge/rebase. This quickly allows you to fix the
    conflicts and get on with the merge/rebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `jgit` repository, we can create two branches at an earlier point in
    time and merge these two branches:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now, you'll see that this fails to perform the merge, and you can run `git st`
    to check the statuses of a lot of files that are in a conflicted state, `both
    modified`. To open and edit all the conflicted files, we can now run `git editconflicted`.
    This brings up `$EDITOR` with the files. If your environment variable isn't set,
    use the `EDITOR=<your-favorite-editor>` export to set it.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we don't actually resolve the conflicts. Just check that the
    alias works and you're ready for the next alias.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have solved all the merge conflicts, it is time to add all of those
    files before we conclude the merge. Luckily, we can create an `alias` method that
    can help us with that, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can run `git addconflicted`. Later, `git status` will tell us that
    all the conflicted files are added:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git simply runs the command the alias is short for. It is very convenient for
    long Git commands, or Git commands that are hard to remember exactly how to write.
    Now, all you have to remember is the alias and you can always look in the configuration
    file for it.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another way to create a kind of Git alias is to make a shell script and save
    the file with the name `git-<your-alias-name>`. Make the file executable and place
    it somewhere in your `$PATH`. You can now run that file simply by running `git<your-alias-name>` from
    the command line.
  prefs: []
  type: TYPE_NORMAL
- en: The refspec exemplified
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though the `refspec` isn''t the first thing that comes to mind when thinking
    about the Git configuration, it is actually quite close. In a lot of the Git commands,
    the `refspec` is used, but often implicitly, that is, the `refspec` is taken from
    the configuration file. If you don''t remember setting a `refspec` configuration,
    you are probably right, but if you cloned the repository or added a remote, you''ll
    have a section in `.git/config` that looks something like the following (this
    is for the `jgit` repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The fetch line contains the configured `refspec` to fetch in relation to this
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll be using the `jgit` repository as our server repository,
    but we have to make a clone of it to a bare repository so we can push it. You
    can't push to the checked-out branch on a non-bare repository, as this can overwrite
    the work area and index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a bare repository from the `jgit` repository and create a new Git repository
    where we can play with the `refspec` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to change the branch names on some of the branches to match the
    example for namespacing; the following will rename the `stable-xxx` branches to
    `stable/xxx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In the previous shell scripting, the `$new` and `$br` variables aren't placed
    in double quotes (`"`), as good practice for shell scripting would otherwise suggest.
    This is okay, as the variables reflect the names of the branches in the repository
    and branch names cannot contain spaces.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s set up our new repository to only fetch the `master` branch. We do this
    by changing the fetch line under `[remote "origin"]` in the configuration file
    (`.git/config`), as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will only fetch the `master` branch and not all the other branches
    when executing a `git fetch`, `git pull`, or a `git remote` update origin, as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also set up a separate refspec to fetch all the `stable/*` branches
    to the local repository as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, fetch the branches locally, as shown in the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also set up a push `refspec` that specifies where branches are pushed
    to by default. Let''s create a branch called `develop` and create one commit,
    as shown in the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a push `refspec` that will send the content of the `develop`
    branch to `integration/master` on origin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s push our commit on `develop` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As the `integration/master` branch didn't exist on the remote side, it was created
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The format of the `refspec` is in the form of `<source>:<destination>`. For
    a fetch `refspec`, this means that `<source>` is the source on the remote side
    and `<destination>` is `local`. For a push `refspec`, `<source>` is `local` and
    `<destination>` is `remote`. The `refspec` can be prefixed by a `+` to indicate
    that the `ref` pattern can be updated even though it isn''t a fast-forward update.
    It is not possible to use partial globs in the `refspec` pattern, as shown in
    the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it is possible to use namespacing. That''s why we had to rewrite the
    `stable-xxx` branches to `stable/xxx` to fit into a namespace pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
