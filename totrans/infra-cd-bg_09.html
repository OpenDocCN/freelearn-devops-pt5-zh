<html><head></head><body>
<div><div><div><h1 id="_idParaDest-133" class="chapter-number"><a id="_idTextAnchor545"/>9</h1>
			<h1 id="_idParaDest-134"><a id="_idTextAnchor546"/>Exploring Alternative Infrastructure-as-Code Tools</h1>
			<p>Welcome to the final chapter of our <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) journey! By now, you should be familiar with the basics of IaC and have gained hands-on experience with Terraform and Ansible.</p>
			<p>As you progress in your career, being aware of and adept with tools in the market is crucial. This chapter aims to expand your IaC toolset by introducing you to three additional tools: <strong class="bold">Pulumi</strong>, <strong class="bold">Azure Bicep</strong>, and <strong class="bold">AWS CloudFormation</strong>.</p>
			<p>While the previous tools we explored were cloud-agnostic, Azure Bicep and AWS CloudFormation are specific to their respective cloud providers. On the other hand, Pulumi sets itself apart by enabling you to use familiar programming languages such as Python to define and manage your infrastructure in actual code.</p>
			<p>In this chapter, we are going to cover the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor547"/>Getting a hands-on understanding of Pulumi</li>
				<li><a id="_idTextAnchor548"/>Getting hands-on knowledge of Azure Bicep</li>
				<li><a id="_idTextAnchor549"/>Getting hands-on expertise in AWS CloudFormation</li>
			</ul>
			<p>Before discussing the next steps in your IaC journey, as we have a lot to cover in this chapter, let’s dive straight in and discuss Pulumi, which is, at the time of writing, the new kid on the block when it comes to IaC tools.</p>
			<h1 id="_idParaDest-135"><a id="_idTextAnchor550"/>Technical requirements</h1>
			<p>The source code for this chapter is available here: <a href="https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09">https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners-/tree/main/Chapter09</a>.</p>
			<h1 id="_idParaDest-136">Getting hands-on with <a id="_idTextAnchor551"/>Pulumi</h1>
			<p><em class="italic">So, what is Pulumi, and why has it yet to be mentioned up </em><em class="italic">until now?</em></p>
			<p>Pulumi is <a id="_idIndexMarker469"/>an open source IaC platform that allows developers to define, provision, and manage cloud infrastructure; however, rather than using a descriptive language with YAML (Ansible) or HCL (Terraform), it allows you to use popular programming languages<a id="_idTextAnchor552"/> such as JavaScript, TypeScript, Python, Go, and C#, as well as YAML for non-programmers.</p>
			<p>With Pulumi, you <a id="_idIndexMarker470"/>can build, manage, and deploy IaC more familiarly and expressively, making it easier to reason about complex cloud architectures.</p>
			<p>Pulumi supports popular cloud providers such as AWS, Azure, and Google Cloud. There is also support for tools such as Kubernetes, among others, all of which enable you to define and manage resources across multiple platforms using a single tool.</p>
			<p>Great, you may be thinking to yourself – but why hasn’t it been mentioned until now?</p>
			<p>The answer is that it should be considered something other than a beginner’s tool – given the number of different ways you can interact with it, it can be highly complex. It would require a dedicated book to do more than scratch the surface.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Links to the instructions on installing Pulumi can be found in the <em class="italic">Further reading</em> section at the end of this chapter if you would like to follow along.</p>
			<p>To give you an idea of how you would use Pulumi, let’s look at launching a few resources in Microsoft Azure, as we did in the early examples of Terraform and Ansible we covered; we will be creating a resource group and a storage account.</p>
			<p>We will start by using YAML and then look at the same deployment in Python<a id="_idTextAnchor553"/>.</p>
			<h2 id="_idParaDest-137"><a id="_idTextAnchor554"/>Using Pulumi and YAML</h2>
			<p>We have <a id="_idIndexMarker471"/>two files, both of which can be found in the GitHub <a id="_idIndexMarker472"/>repository accompanying this book. The first file, which defines some environment-specific configurations, is cal<a id="_idTextAnchor555"/>led <code>Pulumi.dev.yaml</code> and, for our example, contains the following co<a id="_idTextAnchor556"/>de:</p>
			<pre class="source-code">
config<a id="_idTextAnchor557"/>:
  azure-native:location: UKSouth</pre>
			<p>As you can see, all we are doing is defining the default <code>location</code> to be used by the Azure Native provider.</p>
			<p>The second of the two files<a id="_idTextAnchor558"/> is called <code>Pulumi.yaml</code>, and it starts by defining some information <a id="_idTextAnchor559"/>and settings for our project:</p>
			<pre class="source-code">
name: pulumi-yaml
runtime: yaml
description: A minimal Azure Native Pulumi YAML program
outputs<a id="_idTextAnchor560"/>:
  primaryStorageKey<a id="_idTextAnchor561"/>: ${storageAccountKeys.keys[0].value}</pre>
			<p>The<a id="_idIndexMarker473"/> first <a id="_idIndexMarker474"/>three lines, <code>name</code>, <code>runtime</code>, and <code>description</code>, all define some basic meta information about our deployment.</p>
			<p>The following two lines define the output, which in our case will be the primary key of the storage account that will be created.</p>
			<p>Here, we are defining an output variable of <code>primaryStorageKey</code>, which is taking its value from a variable we will define at the end; this variable will contain the outpoint of a function we will be running once the storage account has been created.</p>
			<p>Now that we have the basics in place, let’s define the resources using a resource block, starting with the Azure Resource Group:</p>
			<pre class="source-code">
resourc<a id="_idTextAnchor562"/>es:
  resourceGroup:
    <a id="_idTextAnchor563"/>type: azure-native:resources:ResourceGrou<a id="_idTextAnchor564"/>p
    properties:
<a id="_idTextAnchor565"/>      resourceGroupName: rg-pulumi-yaml</pre>
			<p>As you can see, this is not too dissimilar structurally from Terraform and Ansible – here, we are defining a resource that will be referred to as <code>resourceGroup</code>, which has a type of <code>azure-native:resources:ResourceGroup</code>, before finally setting a single property that contains the <code>resourceGroupName</code> key.</p>
			<p>Now that <a id="_idIndexMarker475"/>the Resource Group has been defined, we can add the storage account resource, which we are going to refer to as <code>sa</code>:</p>
			<pre class="source-code">
  sa:
   type: azure-native:storage:StorageAcco<a id="_idTextAnchor566"/>unt
   properties:
      kind: StorageV2<a id="_idTextAnchor567"/>
      resourceGrou<a id="_idTextAnchor568"/>pName: ${resourceGroup.name}
      sku:
        name: Standard_LRS</pre>
			<p>Again, it<a id="_idIndexMarker476"/> follows the same pattern as before; we set the resource reference and the type of resource we want to create and then define our <code>properties</code>.</p>
			<p>In this case, rather than the name of the resource, which Pulumi will create for us, we are passing in a <code>sku</code> name, the kind of storage account we want to create (via <code>kind</code>), and the <code>resourceGroupName</code> key to add the resource.</p>
			<p>To do this, we must us<a id="_idTextAnchor569"/>e the <code>${resourceGroup.name}</code> variable, which takes the name of the resource group we referenced as <code>resourceGroup</code>. Like in Terraform, this ensures that the resource group is created before the storage account.</p>
			<p>The final part of the <code>Pulumi.yaml</code> file sets the <code>storageAccountKeys</code> variable, which is used by the output section we start at the start of the file.</p>
			<p>To do this, we need to define a <code>variables</code> s<a id="_idTextAnchor570"/>ection:</p>
			<pre class="source-code">
variables:
  storageAccountKeys:
<a id="_idTextAnchor571"/>    fn::azure<a id="_idTextAnchor572"/>-native:<a id="_idTextAnchor573"/>storage:listStorageAccountKeys<a id="_idTextAnchor574"/>:
      accou<a id="_idTextAnchor575"/>ntName: ${sa.name<a id="_idTextAnchor576"/>}
      resourceGro<a id="_idTextAnchor577"/>upName: ${resourceGroup.name}</pre>
			<p>Here, we are setting the function (<code>fn</code>), which is an <code>azure-native</code> one that deals with <code>storage</code> and is called <code>listStorageAccountKeys</code>. It requires two inputs – <code>accountName</code>, which we pass in using <code>${sa.name}</code> and, as most things need in Azure, the <code>resourceGroupName</code> key. So, as before, we pass this in programmatically by using the <code>${</code><code>resourceGroup.name}</code> va<a id="_idTextAnchor578"/>riable.</p>
			<p>Now that <a id="_idIndexMarker477"/>we have all of the code, let’s launch the resources. To do this, we need to issue the following command:</p>
			<pre class="source-code">
$ pulumi up -c Pulumi.dev.yaml</pre>
			<p>This is <a id="_idIndexMarker478"/>where things get a little different than Terraform and Ansible; the first thing that happens is that you are asked to log in, as shown in the following scree<a id="_idTextAnchor579"/>nshot:</p>
			<div><div><img src="img/Figure_9.01_B19537.jpg" alt="Figure 9.1 – Running Pulumi up for the first time" width="1648" height="225"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.1 – Running Pulumi up for the first time</p>
			<p>Follow the onscreen prompts and press the <em class="italic">Enter</em> key to be taken to the login page. Here, you can sign up or log in using one of the many supported identity providers; I used GitHub. Once you have logged in or signed up, you should get the option to create a s<a id="_idTextAnchor580"/>tack:</p>
			<div><div><img src="img/Figure_9.02_B19537.jpg" alt="Figure 9.2 – Time to create a stack" width="1650" height="643"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.2 – Time to create a stack</p>
			<p>Once you have created your stack, Pulumi will run a check against your code and give you the option to deploy the update. In this case, this is going to create three resources – the two in <a id="_idIndexMarker479"/>Azure and our <a id="_idTextAnchor581"/>ou<a id="_idTextAnchor582"/>tput:</p>
			<div><div><img src="img/Figure_9.03_B19537.jpg" alt="" width="1650" height="674"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US"> </p>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Should we run the update?</p>
			<p>If you use the arrow<a id="_idIndexMarker480"/> keys to select <strong class="bold">yes</strong> and then hit the <em class="italic">Enter</em> key, Pulumi will deploy the resou<a id="_idTextAnchor583"/>rces:</p>
			<div><div><img src="img/Figure_9.04_B19537.jpg" alt="Figure 9.4 – The deployment has been completed" width="1650" height="584"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.4 – The deployment has been completed</p>
			<p>As shown in the preceding output, we have the output (which I have blurred out the value of) and an overview of the deployment. The eagle-eyed among you may have also noticed a URL – clicking on it opens an overview of the deployment in your browser. For me, this looked like t<a id="_idTextAnchor584"/>his:</p>
			<div><div><img src="img/Figure_9.05_B19537.jpg" alt="Figure 9.5 – Viewing the deployment in a browser" width="1638" height="1065"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.5 – Viewing the deployment in a browser</p>
			<p>I <a id="_idIndexMarker481"/>recommend <a id="_idIndexMarker482"/>having a look around your stack in the browser. Once you have finished, you can remove the resources by running the following command:</p>
			<pre class="source-code">
$ pulumi destroy</pre>
			<p>This will remove the Azure resources but not the stack on the Pulumi website.</p>
			<p>Now, let’s look at deploying the same resources again, but instead of using YAML, we will use Python.</p>
			<h2 id="_idParaDest-138"><a id="_idTextAnchor585"/>Using Pulumi and Python</h2>
			<p>This, as you <a id="_idIndexMarker483"/>may have already guessed, is where things start to<a id="_idIndexMarker484"/> get a little more advanced.</p>
			<p>In the repository that accompanies the book, you will find several files; these are as follows:</p>
			<ul>
				<li><code>.gitignore</code>: This contains entries for the <code>venv</code> and <code>__pycache__</code> folders, which we do not need to check into versi<a id="_idTextAnchor586"/>on control</li>
				<li><code>__main__.py</code>: This is the main Python code; we will cover this in more detail shortly</li>
				<li><code>Pulumi.dev.yaml</code>: This contains the environment config and has the same contents as we used YAML rather t<a id="_idTextAnchor587"/>han Python</li>
				<li><code>Pulumi.yaml</code>: This contains the basic metadata for our deployment</li>
				<li><code>requirements.txt</code>: Like most Python scripts, there ar<a id="_idTextAnchor588"/>e external dependencies; this file lists these so that they can be installed using <code>pip</code></li>
			</ul>
			<p>Let’s<a id="_idIndexMarker485"/> start by <a id="_idIndexMarker486"/>looking at the <code>requirements.txt</code> file. As mentioned, this contains the dependencies needed to run our Python code:</p>
			<pre class="source-code">
pulumi&gt;=3.0.0,&lt;4.0.0
pulumi-azure-native&gt;=1.0.0,&lt;2.0.0</pre>
			<p>As you can see, there are just two dependencies – Pulumi and the Azure Native provider.</p>
			<p>As already mentioned, we have the <code>Pulumi.yaml</code> file. Even though we are using Python, it contains the basic information and settings for the project:</p>
			<pre class="source-code">
name: pulumi-python
runtime:
  name: python
  <a id="_idTextAnchor589"/>options:
    virtualenv: venv
description: A minimal Azure Native Python Pulumi program</pre>
			<p>As you can see, <code>runtime</code> is now <code>python</code>, and some settings define the folder where the Python virtual environment (<code>virtualenv</code>) will be stored. In our case, this is <code>venv</code> and is in the same folder as the rest of our project files.</p>
			<p>The final file is the <code>__main__.py</code> file and is where our resources are defined. The first part of the file imports the Python libraries needed to deploy the resources:</p>
			<pre class="source-code">
"""An Azure RM Python Pulumi progr<a id="_idTextAnchor590"/>am"""
import pulumi
from pulumi_azure_n<a id="_idTextAnchor591"/>ative import <a id="_idTextAnchor592"/>storage
from pulumi_azure_n<a id="_idTextAnchor593"/>ative import resources</pre>
			<p>As you<a id="_idIndexMarker487"/> can <a id="_idIndexMarker488"/>see, of the two dependencies defined in the <code>requirements.txt</code> file, we are importing all of the <code>pulumi</code> library; however, <code>storage</code> and <code>resources</code> from the <code>pulum<a id="_idTextAnchor594"/>i_azure_native</code> <a id="_idTextAnchor595"/>library as the Resource Group and storage account, respectively, are the only two resources that we are launching. Therefore, we do not need to load the entire library.</p>
			<p>Next up, we must define the Resource Group:</p>
			<pre class="source-code">
resource_group = resources.ResourceGroup(
    "resource_group",
    resource_group_name="rg-pulumi-python",
)</pre>
			<p>I wouldn’t call myself a Python programmer – I know enough to be dangerous and run the basics – but I am sure you will agree that the code looks simple enough.</p>
			<p>Now, let’s define the storage account:</p>
			<pre class="source-code">
account = storage.StorageAccount(
    "sa",
    resource_group_name=resource_group.name,
    sku=storage.SkuArgs(
        name=storage.SkuName.STANDARD_LRS,
    ),
    kind=storage.Kind.STORAGE_V2,
)</pre>
			<p>Again, it is a little different from what we dealt with when defining our infrastructure in YAML or HCL.</p>
			<p>But again, it is <a id="_idIndexMarker489"/>simple enough to follow what is going on within<a id="_idIndexMarker490"/> the code, mainly as we have already deployed this same project using Pulumi and YAML.</p>
			<p>This also means you should have an idea of what is coming up next – that is, the function to grab the storage account key:</p>
			<pre class="source-code">
primary_key = (
    pulumi.Output.all(resource_group.name, account.name)
    .apply(
        lambda args: storage.list_storage_account_keys(
            resource_group_name=args[0], account_name=args[1]
        )
    )
    .apply(lambda accountKeys: accountKeys.keys[0].value)
)
pulumi.export("primary_storage_key", primary_key)</pre>
			<p>This is where things turn a little more in<a id="_idTextAnchor596"/>to a traditional Python script; it is still relatively straightforward to follow what is going on but if, like me, you are not a Python developer, you may find it a little more challenging to write the preceding code from scratch.</p>
			<p>Let’s try deploying the code. To do this, we simply use the same comm<a id="_idTextAnchor597"/>and as before:</p>
			<pre class="source-code">
$ pulumi up -c Pulumi.dev.yaml</pre>
			<p>You will notice some differences when you first run<a id="_idTextAnchor598"/> the command:</p>
			<div><div><img src="img/Figure_9.06_B19537.jpg" alt="Figure 9.6 – Installing the dependencies" width="1650" height="345"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.6 – Installing the dependencies</p>
			<p>As you may have already gues<a id="_idTextAnchor599"/>sed, first, the dependencies defined in the <code>requirements.txt</code> file must be installed.</p>
			<p>Once <a id="_idIndexMarker491"/>our <a id="_idIndexMarker492"/>dependencies have been installed, we drop back to the same options as we were presented with when we deployed the YAML version o<a id="_idTextAnchor600"/>f the project:</p>
			<div><div><img src="img/Figure_9.07_B19537.jpg" alt="Figure 9.7 – Back in familiar territory" width="1650" height="734"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.7 – Back in familiar territory</p>
			<p>Again, you get a URL to view your stack on the Pulumi website, and you can terminate the resources by running the <code>pulumi </code><code>destroy</code> command.</p>
			<p>So, why do this?</p>
			<p>Most of the audience for this book, I imagine, comes from an operations or system administration background rather than a programming one – this means you are more familiar with working with configuration files of all types and understand the steps you need to take to deploy your infrastructure.</p>
			<p>Pulumi aims to appeal to people from that background as well as developers by offering them a way of defining their infrastructure in a language that is familiar to them; as you may recall from <a id="_idIndexMarker493"/>the start of this section, JavaScript, TypeScript<a id="_idTextAnchor601"/>, Python, Go, and C# are all supported.</p>
			<p>Another<a id="_idIndexMarker494"/> advantage is that you can move your IaC into your existing build and deployment pipelines. For example, let’s say you have a mature C# build, test, and deployment workflow. If you are using Pulumi, you should be able to introduce your IaC into the process quickly.</p>
			<p>As mentioned at the start of this section, we have yet to begin to unlock the power of Pulumi in this section – but I am sure you will agree that it opens up many possibilities when approaching your IaC deployments.</p>
			<p>Now that we have looked at the last of the cloud-agnostic tools, let’s look at the two cloud-native tools before we finish.</p>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor602"/>Getting hands-on knowledge of Azure Bicep</h1>
			<p><strong class="bold">Azure Bicep</strong> is the<a id="_idIndexMarker495"/> first of the two cloud-specific IaC tools we will be looking at in this chapter. For quite a while, if you wanted to use the native tool provided by Microsoft, you would need to write an ARM template.</p>
			<p>When we discussed Microsoft Azure in <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Microsoft Azure</em>, we stated that ARM is short for Azure Resource Manager – that is, the API that powers all of Azure. You will have been using ARM when using the Azure portal, command-line tools, PowerShell, or any IaC tool we have covered to launch or manage your Microsoft Azure resources.</p>
			<p>The best way I can think to describe ARM templates is that they are the JSON payloads that are sent to the API – I won’t include an example of what an ARM template looks like as there is a lot of it, but I have included an example file called <code>arm-template-example.json</code> in the same folder as the Bicep file in the accompanying repository. As you can see, there is a lot of it; the file is just short of 120 lines of code – and all that does is define a storage account.</p>
			<p>So, now that we have provided a quick explanation of ARM templates, let’s look at Bicep.</p>
			<p>Bicep is a <code>main.bicep</code>.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor603"/>Working through the Bicep file</h2>
			<p>The first part<a id="_idIndexMarker498"/> of our Bicep code sets the parameters, of which we are going to set three up, starting with the type of storage account we will be launching:</p>
			<pre class="source-code">
@description('Storage Account type')
@allowed([
  'Premium_LRS'
  'Premium_ZRS'
  'Standard_GRS'
  'Standard_GZRS'
  'Standard_LRS'
  'Standard_RAGRS'
  'Standard_RAGZRS'
  'Standard_ZRS'
])
param storageAccountType string = 'Standard_LRS'</pre>
			<p>As you can see, here, we provide an array of the <code>allowed</code> possible va<a id="_idTextAnchor604"/>lues before defining a parameter (<code>param</code>) called <code>storageAccountType</code> with a string value of <code>Standard_LRS</code>. This means that if we override the default parameter at runtime, it will only accept one of the allowed parameters rather than just any old string.</p>
			<p>The second and third parameters are as follows:</p>
			<pre class="source-code">
@description('The storage account location.')
param location string = resourceGroup().location</pre>
			<p>The former sets the <code>location</code> parameter by inheriting the location of the Resource Group; we also use the ID of the Resource Group to generate a unique string for the storage account’s name:</p>
			<pre class="source-code">
@description('The name of the storage account')
param storageAcc<a id="_idTextAnchor605"/>ountName string = 'sa${uniqueString(resourceGroup().id)}'</pre>
			<p>The <code>uniqueStr<a id="_idTextAnchor606"/>ing</code> function<a id="_idIndexMarker499"/> takes the Resource Group ID, which in itself is unique to your deployment, and uses that to generate a string. This means that you know a consistent string is being generated rather than a random string each time the Bicep code is executed. However, as it is based on the Resource Group ID that is unique to your deployment, you should never have two strings that are the same.</p>
			<p>So, now that we have defined our three parameters, we can add the code to create the storage account resource.</p>
			<p>The block to do this looks<a id="_idTextAnchor607"/> like this:</p>
			<pre class="source-code">
resource sa 'Microsoft.Storage/storageAccounts@2022-09-01' = {
  name: storageAccountName
  location: location
  sku: {
    name: storageAccountType
  }
  kind: 'StorageV2'
  properties: {}
}</pre>
			<p>Here, we are creating a <code>resource</code> block that is going to be referred to as <code>sa</code>; it uses the <code>Microsoft.Storage/storageAccounts@2022-09-01</code> API endpoint. We are also passing in the parameters for <code>name</code>, <code>location</code>, and <code>sku</code>.</p>
			<p>The final two  lines of code set some output, which is the storage account <a id="_idTextAnchor608"/>name and the ID:</p>
			<pre class="source-code">
output storageAccountName string = storageAccountName
output storageAccountId string = sa.id</pre>
			<p>You may <a id="_idIndexMarker500"/>have noticed that’s something missing… have you guessed what it is?</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor609"/>Deploying the Bicep file</h2>
			<p>If you guessed the following, then you would be correct:</p>
			<p>“<em class="italic">Hang on a minute; we are referencing a Resource Group, but we are not defining a block </em><em class="italic">for one.</em>”</p>
			<p>By default, both<a id="_idIndexMarker501"/> Bicep and ARM templates expect you to deploy into a resource rather than have one defined within the Bicep file.</p>
			<p>Another thing that you may have noticed is that I haven’t given any instructions on how to install Azure Bicep.</p>
			<p>The reason for this is that Bicep i<a id="_idTextAnchor610"/>s built into the Azure CLI, which we will also use to create a resource group. Do this by runni<a id="_idTextAnchor611"/>ng the following command:</p>
			<pre class="source-code">
$ az g<a id="_idTextAnchor612"/>roup create -l uksouth -n rg-bicep-example</pre>
			<p>When I ran the command, I got the following output:</p>
			<pre class="source-code">
{
  "id": "/subscriptions/3e3c9f50-1a27-4e7e-af2e-e0d3f3e4a8f4/resourceGroups/rg-bicep-example",
  "location": "uksouth",
  "managedBy": null,
  "name": "rg-bicep-example",
  "properties": {
    "provisioningState": "Succeeded"
  },
  "tags": null,
  "type": "Microsoft.Resources/resourceGroups"
}</pre>
			<p>The<a id="_idIndexMarker502"/> command will create a resource group called <code>rg-bicep-example</code> in the UK South region, which we can now deploy our Bicep file into by running the following code:</p>
			<pre class="source-code">
$ az deployment group create --resource-group rg-bicep-example --template-file main.bicep</pre>
			<p>This will output quite a bit of information, but the two import bits we are interested in are the outputs. For me, these looked <a id="_idTextAnchor613"/>like this:</p>
			<pre class="source-code">
"outputs": {
  "storageAccountId": {
    "type": "String",
    "value": "/subscriptions/ce7aa0b9-3545-4104-99dc-d4d082339a05/resourceGroups/rg-bicep-example/providers/Microsoft.Storage/storageAccount<a id="_idTextAnchor614"/>s/saljkmvlrqknl2y"
  },
  "storageAccountName": {
    "type<a id="_idTextAnchor615"/>": "String",
    "value": "saljkmvlrqknl2y"
  }
},</pre>
			<p>As you can see, <code>storageAccountId</code> and <code>storageAccountName</code> are visible.</p>
			<p class="callout-heading">Important</p>
			<p class="callout">The following command deletes the whole resource group and everything within it, so please be careful and only run if you want everything to be deleted.</p>
			<p>You can remove the resources we launched with Bicep by running the following command:</p>
			<pre class="source-code">
$ az group delete -n rg-bicep-example</pre>
			<p>Again, this<a id="_idIndexMarker503"/> section wasn’t planned to be a deep dive into Bicep; I wanted to give a basic example to show you how IaC tools are not just limited to the “big two” of Terraform and Ansible. We have yet to come close to scratching the surface of what is possible with Bicep.</p>
			<p>Since Microsoft first launched the alpha release of Bicep in August 2020, it has quickly grown and become a first-class citizen within the Azure ecosystem; for example, all of the official Azure documentation now includes references to and examples of both ARM templates and Bicep code for launching and interacting with your Azure resources.</p>
			<p>Also, as we have experienced, it is built directly into the Azure CLI, meaning you already have it at your disposal if you are already working with Microsoft Azure.</p>
			<p>Before we discuss why you should use Bicep over one of the other tools, let’s look at the other cloud-native option – AWS CloudForma<a id="_idTextAnchor616"/>tion.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor617"/>Getting hands-on with AWS CloudFormation</h1>
			<p><strong class="bold">AWS CloudFormation</strong> is a <a id="_idIndexMarker504"/>service provided by Amazon Web Services that enables you to manage and provision your AWS resources using templates.</p>
			<p>Of all the tools we have looked at in this book, AWS CloudFormation is the oldest, with its original public release in May 2010. Also, in the description, I described it as a service that uses templates – this all makes the approach slightly different than the other tools we have covered.</p>
			<p>CloudFormation <a id="_idIndexMarker505"/>uses JSON or YAML templates to describe your desired AWS resources and their configurations. These templates define a stack, which is a collection of related resources that can be created, updated, or deleted together.</p>
			<p>It provides automatic rollback and drift detection capabilities to help you maintain the desired state of your infrastructure. CloudFormation can automatically revert to the previous working state if a stack update fails. Drift detection allows you to identify and correct discrepancies between the actual infrastructure and the desired state defined in the template.</p>
			<p>Also, before<a id="_idIndexMarker506"/> deploying a stack, you can estimate the cost of the resources defined in your template. Additionally, you can use tags to categorize and track costs associated with specific resources, projects, or environments.</p>
			<p>We will look at deploying a single Amazon S3 bucket using both the AWS command line and the AWS Management Console.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor618"/>AWS CloudFormation template</h2>
			<p>First, let’s<a id="_idIndexMarker507"/> look at the template file we will be using. I prefer to use YAML over JSON as it is much easier to read and follow what is going on.</p>
			<p>The template we will be using is split into four small sections. The template is a small 20-line file; I have seen templates containing several hundred lines of code, so this is the most basic example we can use.</p>
			<p>The start of the template contains some basic information, including a description of what the template does and which format to use:</p>
			<pre class="source-code">
AWSTemplateFormatVersion: "2010-09-09"
Description: Creates a basic S3 bucket using CloudFormation</pre>
			<p>Next, we must set some <code>Parameters</code>; in our case, this is just going to be <code>BucketName</code>:</p>
			<pre class="source-code">
Parameters:
  BucketName: { Type: String, Default: "my-example-bucket-name" }</pre>
			<p>Next, we have the resources, where we define our S3 bucket:</p>
			<pre class="source-code">
Resources:
  ExampleBucket:
    Type: "AWS::S3::Bucket"
  <a id="_idTextAnchor619"/>  Properties:
      BucketName: !Ref BucketName
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256</pre>
			<p>Finally, we <a id="_idIndexMarker508"/>must set an output that returns the name of the bucket we created:</p>
			<pre class="source-code">
Outputs:
  ExampleBucketName:
    Description: Name of the example bucket
    Value: !Ref ExampleBucket</pre>
			<p>As you can see, there are some differences in how parameters are referenced; I am not a fan of using syntax such as <code>!Ref BucketName</code> only because the other tools, all of which came after, use a similar way of referencing parameters/variables.</p>
			<p>Now that we have our template, let’s look at using <a id="_idTextAnchor620"/>the AWS CLI to deploy the stack.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor621"/>Using the AWS CLI to deploy</h2>
			<p>The <a id="_idIndexMarker509"/>AWS CLI makes it easy to deploy our template. To deploy the S3 bucket, run the following command, making sure you update the name of the bucket at the end of the command to your own. This is because bucket names need to be unique:</p>
			<pre class="source-code">
$ aws cloudformation create-stack --stack-name iaccloudform --template-body file://cftemplate.yaml --parameters ParameterKey=BucketName,ParameterValue=iac230404</pre>
			<p>Once deployed, you should get some output that looks like this:</p>
			<pre class="source-code">
{
    "StackId": "arn:aws:cloudformation:us-west-2:687011238589:stack/iaccloudform/ca605040-d2fa-11ed-84fd-027270021b81"
}</pre>
			<p>We have just deployed the stack but not the resources – the stack, which is an AWS service, will be deploying those for you in the background.</p>
			<p>To delete <a id="_idIndexMarker510"/>the stack we just launched and the resources managed by it, run the following command:</p>
			<pre class="source-code">
$ aws cloudformation delete-stack --stack-name iaccloudform</pre>
			<p>Let’s see what creating a stack in the AWS Management Console looks like.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor622"/>Using the AWS Management Console to deploy</h2>
			<p>Once logged into<a id="_idIndexMarker511"/> the AWS Management Console, go to CloudFormation and click the <strong class="bold">Create </strong><strong class="bold">stack</strong> button.</p>
			<p>The first step of creating a stack is to define your template. Since you already have one, ensure that <strong class="bold">Template is ready</strong> is selected. Then, select the <strong class="bold">Upload a template file</strong> option and press the <strong class="bold">Choose <a id="_idTextAnchor623"/>file</strong> button to upload your file:</p>
			<div><div><img src="img/Figure_9.08_B19537.jpg" alt="Figure 9.8 – Completing step one" width="1639" height="810"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.8 – Completing step one</p>
			<p>The second step is to provide some details about the s<a id="_idTextAnchor624"/>tack and update any parameters:</p>
			<div><div><img src="img/Figure_9.09_B19537.jpg" alt="Figure 9.9 – Entering details of the stack" width="1653" height="796"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.9 – Entering details of the stack</p>
			<p>Step <a id="_idIndexMarker512"/>three is where you configure options for the stack; here, you can define tags and permissions and control the actions taken should a deployment fail.</p>
			<p>For our deployment, you can leave all of the options at their defaults – however, I recommend that you review them before clicking on the <strong class="bold">Next</strong> butto<a id="_idTextAnchor625"/>n to proceed to the final step:</p>
			<div><div><img src="img/Figure_9.10_B19537.jpg" alt="Figure 9.10 – Reviewing the stack options" width="1635" height="1114"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.10 – Reviewing the stack options</p>
			<p>The final step is to review your stack before clicking the <strong class="bold">Submit</strong> button, tr<a id="_idTextAnchor626"/>iggering the stack’s creation:</p>
			<div><div><img src="img/Figure_9.11_B19537.jpg" alt="Figure 9.11 – Reviewing the deployment" width="1627" height="1016"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.11 – Reviewing the deployment</p>
			<p>From<a id="_idIndexMarker513"/> here, you can review your resources. Once you have finished, clicking on <strong class="bold">Delete</strong> will remove the stack.</p>
			<p>One thing that you will have noticed is that there are some sample templates, as well as a template designer. Loading one of the samples into the designer gives you a graphical view of the template and a drag-and-drop interface that you can use to design your templates:</p>
			<div><div><img src="img/Figure_9.12_B19537.jpg" alt="Figure 9.12 – Designing your template" width="1631" height="1119"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 9.12 – Designing your template</p>
			<p>As you <a id="_idIndexMarker514"/>can see, there are options to export your finished template as JSON or YAML; in our example, there are just over 700 lines of code in the YAML file.</p>
			<p>This is the biggest reason you want to use the designer and AWS Management Console.</p>
			<p>AWS CloudFormation can quickly become very complex, and it doesn’t lend itself well to sitting in front of an empty file and starting to code – I find it very overwhelming.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor627"/>Summary</h1>
			<p>In this final chapter, we looked at three additional IaC tools, all of which work slightly differently from the two primary tools we looked at in previous chapters. So, why would you choose these over Terraform or Ansible?</p>
			<p>In <a href="B19537_02.xhtml#_idTextAnchor085"><em class="italic">Chapter 2</em></a>, <em class="italic">Ansible and Terraform beyond the Documentation</em>, we concluded that you should choose the best tool for the job rather than trying to fit your project to the tool; the same goes for the tools we have discussed in this chapter.</p>
			<p>When planning your IaC project, having an excellent working knowledge of more than one tool is always a bonus; throughout this book, there have been occasions when either Terraform or Ansible hasn’t supported a task we were trying to perform, so we had to use the built-in tools that provide support for the target cloud’s API.</p>
			<p>If you have a project in Azure, for example, where coverage for the latest services in the tools may be behind by several months, then using Azure Bicep may be the best choice as you know you are exclusively targeting Azure; Bicep has day 1 support for 99.9% of all new Azure services.</p>
			<p>Likewise, you may have to work alongside developers who want to bring your deployments into their existing processes and procedures; therefore, using Pulumi may be more suitable than introducing one of the other tools.</p>
			<p>So, what should your immediate next steps be?</p>
			<p>Suppose you have access to a lab or a free cloud account. In that case, I recommend choosing a typical deployment and working through the steps covered in the first three chapters to define your project and then execute your IaC project.</p>
			<p>Before starting, ensure you know what your end deployment will look like and how it needs to be configured. From there, you should be able to break it down into tasks, w<a id="_idTextAnchor628"/>hich will give you an idea of the dependencies.</p>
			<p>Once you have an idea of the tasks and dependencies, this should allow you to work out the order in which the tasks would need to be executed – this is where you should choose which tool to use. However, you shouldn’t do this before as you need to know if you need a decorative or imperative tool and you must know the compatibility and service support each tool would need for your deployment to succeed.</p>
			<p>Once you know what it is you are deploying, in which order, and using which tool, you can open a blank file and start to write your code.</p>
			<p>I recommend writing some code and doing a test deployment – to deal with any issues – and then terminating the resources once you have resolved the problem.</p>
			<p>Do not leave it to the end to try and debug your code. Also, ensure that when you do test deployments, you remove them – otherwise, you may end up introducing dependency issues into your deployments as resources may already exist, and therefore any issues or errors within your code may not reveal themselves.</p>
			<p>Expect a lot of trial and error, especially if you are new to IaC deployments. Many considerations may not be completely apparent if you are used to deploying resources using the Azure portal or AWS Management Console, as these interfaces take a lot of the heavy lifting from you and do quite a bit of work in the background to make the process of launching your resources as smooth as possible.</p>
			<p>Finally, once you have something up and running, make sure you show as many people as possible, give them access to your code if appropriate – show them it being deployed, try and sell them on the benefits of taking an IaC approach to their projects, and be as supportive as possible.</p>
			<p>Thank you for allowing me to accompany you on this journey; I wish you every success with your projects.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor629"/>Further reading</h1>
			<p>Pu<a href="https://www.pulumi.com/docs/get-started/install/">lumi:</a></p>
			<ul>
				<li><a href="https://www.pulumi.com/docs/get-started/install/">Download and installation instructions: </a><a href="https://www.pulumi.com/docs/get-started/install/"/>https://www.pulumi.com/docs/get-started/install/</li>
				<li>Getting started with Azure: <a href="https://www.pulumi.com/docs/get-started/azure/">https://www.pulumi.com/docs/get-started/azure/</a></li>
				<li>Getting started with AWS: <a href="https://www.pulumi.com/docs/get-started/aws/">https://www.pulumi.com/docs/get-started/aws/</a></li>
				<li>Importing your infrastructure and converting your existing IaC: <a href="https://www.pulumi.com/docs/guides/adopting/">https://www.pulumi.com/docs/guides/adopting/</a></li>
			</ul>
			<p>Azure Bicep:</p>
			<ul>
				<li>Bicep overview: <a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep">https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/overview?tabs=bicep</a></li>
				<li>Download and install: <a href="https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install">https://learn.microsoft.com/en-us/azure/azure-resource-manager/bicep/install</a></li>
				<li>Learn Bicep Live: <a href="https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/">https://learn.microsoft.com/en-us/events/learn-events/learnlive-iac-and-bicep/</a></li>
			</ul>
			<p>AWS CloudFormation:</p>
			<ul>
				<li>Product page: <a href="https://aws.amazon.com/cloudformation/">https://aws.amazon.com/cloudformation/</a></li>
				<li>Full documentation: <a href="https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html">https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/Introduction.html</a></li>
			</ul>
		</div>
	</div>
</div>
</body></html>