<html><head></head><body>
		<div><h1 id="_idParaDest-148"><em class="italic"><a id="_idTextAnchor127"/>Chapter 8</em>: Integrating with DevOps Tools</h1>
			<p>One of the core tenets of DevOps, beyond cultivating the associated culture within your organization, is the practice of automating and optimizing processes through the use of technology. Using automation rules in Jira, we can optimize the process of software development by connecting DevOps tools such as Bitbucket and GitHub to issues in Jira, thereby allowing us to synchronize the status of issues automatically.</p>
			<p>Beyond keeping issue statuses automatically synchronized to code commits, we can also make use of automation to keep track of and synchronize pull requests, create tasks to track these, and send notifications to the team to ensure maximum visibility of the process. All of this enables developers to spend more time focused on writing and delivering software and less time managing administrative tasks.</p>
			<p>While integration with certain DevOps processes has been (and still is) possible in Jira using workflow triggers, in this chapter we will look at how automation rules can be used to create more flexible integrations than what has previously been possible. This will keep your workflow configuration clean and prevent lengthy workflow updates, especially when the workflow affects a large number of issues.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Synchronizing issues and Git commits</li>
				<li>Keeping track of pull requests</li>
				<li>Automatically releasing versions using GitHub</li>
				<li>Synchronizing deployments with sprint completion</li>
			</ul>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor128"/>Technical requirements</h1>
			<p>The requirements for this chapter are as follows:</p>
			<ul>
				<li><strong class="bold">Jira Cloud environment</strong>: If you don't already have access to Jira, you can create a free Jira Cloud account at <a href="https://www.atlassian.com/software/jira/free">https://www.atlassian.com/software/jira/free</a> and ensure that you have both Jira Software and Jira Service Management selected.</li>
				<li><strong class="bold">Jira Server environment</strong>: If you are using Jira Server (available from <a href="https://www.atlassian.com/software/jira/download">https://www.atlassian.com/software/jira/download</a>), ensure that you have licenses for both Jira Software and Jira Service Management. In addition, you will also need to ensure that you install the <em class="italic">Automation for Jira</em> app, available from the Atlassian Marketplace.</li>
			</ul>
			<p>For Jira, you will need to have at least <strong class="bold">Project Administrator</strong> access to a Scrum Software project and be able to follow the examples in this chapter. For the examples in this chapter, we have used the <em class="italic">Scrum project template</em> to create the software project.</p>
			<p>You will also need access to the following tools:</p>
			<ul>
				<li><strong class="bold">Bitbucket Cloud</strong>: Bitbucket Cloud is a hosted Git-based version control service from Atlassian. You can sign up for a Bitbucket account at <a href="https://bitbucket.org">https://bitbucket.org</a> or by using the application switcher from your Jira Cloud account.</li>
				<li><strong class="bold">GitHub</strong>: GitHub is a hosted software development and Git-based version control service from Microsoft. You can sign up for a GitHub account at <a href="https://github.com">https://github.com</a>.</li>
				<li><strong class="bold">Jenkins</strong>: Jenkins is a popular free, open source automation server that is used to facilitate <strong class="bold">Continuous Integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">Continuous Delivery</strong> (<strong class="bold">CD</strong>) by automating the building, testing, and deploying of software projects. You can download Jenkins from <a href="https://www.jenkins.io">https://www.jenkins.io</a>.</li>
			</ul>
			<p>You can download the latest code samples for this chapter from this book's official GitHub repository at <a href="https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira">https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira</a>. Please visit the following link to check the CiA videos: <a href="https://bit.ly/2XWeuW7">https://bit.ly/2XWeuW7</a></p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor129"/>Synchronizing issues and Git commits</h1>
			<p>In the normal <a id="_idIndexMarker410"/>course of writing software, developers <a id="_idIndexMarker411"/>will normally move a story or task to an <strong class="bold">In Progress</strong> state, do the actual work of writing the code, commit the changes to a source repository such as Bitbucket or GitHub, and then switch back to Jira to move the story or task to the next status in the workflow.</p>
			<p>All of this manual work requires unnecessary context switching, and because the process requires the developer to remember to switch between the various tools, it is very likely that sometimes issues are not updated, which makes it harder to track actual progress on the project.</p>
			<p>Jira has, for some time, had the ability to integrate with tools such as Bitbucket and GitHub by allowing administrators to configure the underlying Jira workflows with triggers on various transitions.</p>
			<p>While this <a id="_idIndexMarker412"/>approach does allow for automation of the process and frees up the developer from having to manually update their task statuses, it is limited to <a id="_idIndexMarker413"/>the transition on which the trigger is configured. Additionally, making adjustments to workflows is not always a straightforward task.</p>
			<p>By using automation rules instead, we gain a lot more flexibility in how we synchronize code commits with their corresponding Jira issues.</p>
			<p>Let's take a look at how we can leverage automation rules to achieve this.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor130"/>Creating a rule to transition issues on code commits</h2>
			<p>For this example, we will create a rule that listens for a commit created using Bitbucket Cloud <a id="_idIndexMarker414"/>and transitions <a id="_idIndexMarker415"/>the corresponding issue to <strong class="bold">In Progress</strong> if it is not already in that status.</p>
			<p>In addition, we will send a message for every commit to the <em class="italic">#sprint-updates</em> Slack channel, which we set up in <a href="B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 4</em></a>, <em class="italic">Sending Automated Notifications</em>. In reality though, you would probably not want to spam the developers with commit notifications and rather wait for a more significant event, such as the creation of a pull request.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For automation rules to recognize the issue that needs to be updated, the commit message needs to include the issue key as part of the message.If your developers create a branch for each issue they work on, the issue key needs to be a part of the branch name.In both instances, the issue key must follow the standard Jira format of the project key, followed by a dash and then the issue number. For example, if the project key is PROJ and the issue number is 123, the issue key will be <em class="italic">PROJ-123</em>.</p>
			<p>Let's firstly take a look at the rule in <em class="italic">Jira Cloud</em> using the DevOps triggers available to automation rules:</p>
			<ol>
				<li>In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the <strong class="bold">Project Settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <strong class="bold">Commit created</strong> trigger and then click <strong class="bold">Save</strong>.<p class="callout-heading">Tip</p><p class="callout">If you do not already have a Git provider configured for your project, the commit created trigger will prompt you to create a connection, which you can do by clicking on the <strong class="bold">Connect now</strong> link.</p></li>
				<li>Next, we'll send a Slack message to the <code>#sprint-updates</code></p></li>
				<li>In this step, we'll add a condition to check that the current status of the issue is not <code>Status</code></p><p><code>does not equal</code></p><p><code>In Progress</code></p></li>
				<li>Next, if <a id="_idIndexMarker418"/>the condition from <em class="italic">step 4</em> is satisfied, we'll transition the issue to <strong class="bold">In Progress</strong>.<p>Click <a id="_idIndexMarker419"/>on <strong class="bold">New action</strong> and then select <strong class="bold">Transition issue</strong>. Set the <strong class="bold">Destination</strong> field to <strong class="bold">In Progress</strong> and then click <strong class="bold">Save</strong>.</p><p>Your rule should now look similar to the following screenshot:</p><div><img src="img/B16551_Figure_8.1.jpg" alt="Figure 8.1 – Using the DevOps trigger to synchronize commits&#13;&#10;"/></div><p class="figure-caption">Figure 8.1 – Using the DevOps trigger to synchronize commits</p></li>
				<li>Finally, name the rule <code>Transition to In Progress on commit</code> and click <strong class="bold">Turn it on</strong> to save and publish the rule.</li>
			</ol>
			<p>Automation rules for Jira Server and Data Center do not currently include DevOps triggers, and so we need to make use of the incoming webhook trigger to achieve a similar result.</p>
			<p>In this example, we'll first set up the incoming webhook automation rule in Jira, after which we'll copy the generated webhook URL, which we'll need to set up the outgoing webhook in the Bitbucket Cloud repository.</p>
			<p>Let's now <a id="_idIndexMarker420"/>take a look at <a id="_idIndexMarker421"/>how we build this rule in <em class="italic">Jira Server</em> or <em class="italic">Jira Data Center</em>:</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Project automation</strong> link in the <strong class="bold">Project Settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Bitbucket Cloud sends a <em class="italic">push</em> webhook when a commit is created and sends a webhook payload, which <a id="_idIndexMarker422"/>you can read more about at <a href="https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository">https://support.atlassian.com/bitbucket-cloud/docs/event-payloads/#EventPayloads-entity_repository</a>.<p>In this example, we are assuming that the issue key is present in the commit message rather than the branch name. We will need to extract the issue key from the commit message in order to look up the correct Jira issue. Based on the Bitbucket payload structure detailed in the preceding link, we can find the commit message and extract the issue key using the following smart value:</p><pre>{{webhookData.push.changes.first().new.target.message.match("([A-Z][A-Z0-9]+-\d+)")}}</pre><p class="callout-heading">Tip</p><p class="callout">If you are using branches per issue and the issue key is encoded in the branch name, you can extract the issue key from the branch name with the following smart value instead: <code>{{webhookData.push.changes.first().new.target.name.match("([A-Z][A-Z0-9]+-\d+)")}}</code>.</p><p>Select the <code>Issues provided by running the following JQL search</code></p><p><code>key = {{webhookData.push.changes.first().new.target.message.match("([A-Z][A-Z0-9]+-\d+)")}}</code></p></li>
				<li>Next, we'll send a Slack message to the <code>#sprint-updates</code></p></li>
				<li>In this step, we'll add a condition to check that the current status of the issue is not <code>Status</code></p><p><code>does not equal</code></p><p><code>In Progress</code></p></li>
				<li>Next, if the condition from <em class="italic">step 4</em> is satisfied, we'll transition the issue to <strong class="bold">In Progress</strong>.<p>Click <a id="_idIndexMarker425"/>on <strong class="bold">New action</strong> and then select <strong class="bold">Transition issue</strong>. Set the <strong class="bold">Destination</strong> field to <strong class="bold">In Progress</strong> and then click <strong class="bold">Save</strong>.</p><p>Your <a id="_idIndexMarker426"/>rule should now look similar to the following screenshot:</p><div><img src="img/B16551_Figure_8.2.jpg" alt="Figure 8.2 – Using an incoming webhook trigger to synchronize commits&#13;&#10;"/></div><p class="figure-caption">Figure 8.2 – Using an incoming webhook trigger to synchronize commits</p></li>
				<li>Name the rule <code>Transition to In Progress on commit</code> and click <strong class="bold">Turn it on</strong> to save and publish the rule.</li>
				<li>Next, we need to configure the outgoing webhook in Bitbucket Cloud.<p>Navigate <a id="_idIndexMarker427"/>to your <a id="_idIndexMarker428"/>repository in Bitbucket Cloud and click on <code>Transition Jira issue on commit</code> and paste the Incoming webhook URL, which was generated in step 2, into the <strong class="bold">URL</strong> field.</p><p>Leave the rest of the fields set to their default values and click <strong class="bold">Save</strong>.</p><p>Your Bitbucket Cloud webhook should look similar to the following screenshot:</p></li>
			</ol>
			<div><div><img src="img/B16551_Figure_8.3.jpg" alt="Figure 8.3 – Configuring the push webhook in Bitbucket Cloud&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.3 – Configuring the push webhook in Bitbucket Cloud</p>
			<p>Now that we have completed the webhook setup in Bitbucket Cloud, any commits pushed to <a id="_idIndexMarker429"/>the Bitbucket <a id="_idIndexMarker430"/>repository will send a request to the <strong class="bold">Webhook URL</strong> that was autogenerated in <em class="italic">step 2</em>, causing our automation rule to fire and transition the issue related to the commit.</p>
			<p>In this section, we have learned how to use the DevOps triggers available in Jira Cloud to automatically keep issues in Jira in sync with commits to a Git repository hosted in Bitbucket Cloud.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">The DevOps triggers such as Commit created in Jira Cloud work with most major Git repositories, including Bitbucket Cloud, GitHub, and Gitlab, and the example we have looked at using Jira Cloud will work unchanged for any of these tools.</p>
			<p>We also <a id="_idIndexMarker431"/>looked at how we <a id="_idIndexMarker432"/>can achieve a similar result for Jira Server and Jira Data Center using an incoming webhook for Bitbucket Cloud using issue keys in commit messages specifically.</p>
			<p>In the next section, we'll look at how to use automation rules to keep track of pull requests created in Git-based repositories.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor131"/>Keeping track of pull requests</h1>
			<p>A common feature of DevOps practices is the use of the so-called trunk-based development method, which is a key enabler for the application of <strong class="bold">Continuous Integration</strong><strong class="bold"> </strong>and <strong class="bold">Continuous Delivery</strong> or <strong class="bold">Development (CI/CD)</strong> to the software development process.</p>
			<p>One of the ways <a id="_idIndexMarker433"/>to achieve this is by making use of short-lived branches taken from the master (or trunk) branch to perform development tasks. Jira facilitates this by allowing developers to automatically create branches for each development task when a source control repository such as Bitbucket or GitHub is configured for the software project.</p>
			<p>These short-lived branches are usually merged back into the master/trunk branch by way of pull requests, which allow developers to review the changes introduced into the software before merging them into the master branch.</p>
			<p>In this section, we will see how using automation rules allows us to keep track of these pull requests, which typically happen directly inside the source control repository, and to automatically synchronize and transition the affected issues in Jira.</p>
			<p>We'll also see how to create automated tasks to track pull requests. These tracking tasks will allow product owners and the team to quickly see which issues have been merged without pull requests, or which issues have outstanding pull requests without leaving Jira.</p>
			<p>Let's take a look at the first rule, which will synchronize the development issue and create the tracking task.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor132"/>Creating a rule to track new pull requests</h2>
			<p>In this example, the first thing we want to achieve when managing pull requests is to transition the<a id="_idIndexMarker434"/> corresponding development issue into a <strong class="bold">Waiting for review</strong> status and then create a tracking task in Jira that <a id="_idIndexMarker435"/>is linked to the development issue under review.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="bold">Waiting for review</strong> status will need to be added to your workflow for this example to work correctly. If you have used the default workflow from the <em class="italic">Scrum software project template</em>, you can do this by adding a new column to your scrum board through the board configuration. If you have a custom workflow, you will need to edit the workflow to add this status.</p>
			<p>Additionally, we'll send a Slack message to the team to notify them that a new pull request task has been created. This will allow any member of the development team to pick up and review the pull request.</p>
			<p>Let's take a look at how we build this rule:</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the project settings menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <strong class="bold">Pull request created</strong> trigger and then click <strong class="bold">Save</strong>.</li>
				<li>Next, we want to transition the development issue to the <strong class="bold">Waiting for review</strong> status.<p>Select <strong class="bold">New action</strong>, followed by <strong class="bold">Transition issue</strong> and then, in the <strong class="bold">Destination status</strong> field, select the <strong class="bold">Waiting for review</strong> option and then click <strong class="bold">Save</strong>.</p></li>
				<li>Then we need to create the Jira task to track this pull request.<p>Select <code>Same project</code></p><p><code>Task</code></p><p><code>Review PR: {{pullRequest.title}}</code></p><p><code>Review is required for PR: {{pullRequest.title}}</code></p><p><code>Source branch: {{pullRequest.sourceBranch}}</code></p><p><code>Destination branch: {{pullRequest.destinationBranch}}</code></p><p><code>Access the PR here: {{pullRequest.url}}</code></p><p><code>blocks</code></p><p><code>Trigger issue</code></p></li>
				<li>To send<a id="_idIndexMarker436"/> a notification to the <a id="_idIndexMarker437"/>team via Slack, we'll select <code>:bellhop_bell: A new pull request has been created and is ready for review &lt;{{createdIssue.url}}|{{createdIssue.key}}&gt;</code></p><p><code>#slack-updates</code>.</p><p>Your rule should look similar to the following screenshot:</p><div><img src="img/B16551_Figure_8.4.jpg" alt="Figure 8.4 – Rule to track new pull requests&#13;&#10;"/></div><p class="figure-caption">Figure 8.4 – Rule to track new pull requests</p></li>
				<li>Finally, name the rule <code>Track new pull requests</code> and click <strong class="bold">Turn it on</strong> to save and enable the rule.</li>
			</ol>
			<p>In this example, we have learned how to use the built in DevOps triggers available in Jira Cloud to <a id="_idIndexMarker438"/>trigger rules when new pull requests <a id="_idIndexMarker439"/>are created in connected Git tools such as Bitbucket and GitHub, provided these tools are configured in Jira and connected to the software project.</p>
			<p>The second rule we'll look at in this section will complete the loop of managing pull requests by handling the case when a pull request has been approved and merged.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor133"/>Creating a rule to manage merged pull requests</h2>
			<p>In this <a id="_idIndexMarker440"/>example, we'll create an <a id="_idIndexMarker441"/>automation rule that will trigger when a pull request is merged. At this point, we want to transition the development issue from <strong class="bold">Waiting for review</strong> to <strong class="bold">Waiting for deploy</strong>.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The <strong class="bold">Waiting for deploy</strong> status will need to be added to your workflow in order for this example to work correctly. If you have used the default workflow from the <em class="italic">Scrum software project template</em>, you can do this by adding a new column to your scrum board through the board configuration. If you have a custom workflow, you will need to edit the workflow to add this status.</p>
			<p>Additionally, we also want to automatically transition the tracking task that we created in the <strong class="bold">Track new pull requests</strong> rule to <strong class="bold">Done</strong>.</p>
			<p>Let's now <a id="_idIndexMarker442"/>take a look at how <a id="_idIndexMarker443"/>we can build a rule to achieve this.</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the <strong class="bold">Project Settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <strong class="bold">Pull request merged</strong> trigger and then click <strong class="bold">Save</strong>.</li>
				<li>As we only want to transition the issue if it is in <em class="italic">Waiting for review</em> status, we need to have a condition to check for this.<p>Select <code>Status</code></p><p><code>equals</code></p><p><code>Waiting for review</code></p></li>
				<li>Next, select <strong class="bold">New action</strong> followed by <strong class="bold">Transition issue</strong> and then, in the <strong class="bold">Destination status</strong> field, select <strong class="bold">Waiting for deploy</strong> and then click <strong class="bold">Save</strong>.</li>
				<li>Now we want to automatically transition the tracking task that we created in the <em class="italic">Creating a rule to track new pull requests</em> section to <code>Linked issues</code></p><p><code>is blocked by</code></p></li>
				<li>As <a id="_idIndexMarker444"/>there might be <a id="_idIndexMarker445"/>other tasks linked to this issue using the same link type, we want to ensure that we only automatically transition the tracking task, so we'll need another condition.<p>Select <code>Summary</code></p><p><code>starts with</code></p><p><code>Review PR:</code></p></li>
				<li>Now select <strong class="bold">New action</strong> followed by <strong class="bold">Transition issue</strong>. In the <strong class="bold">Destination status</strong> field, select <strong class="bold">Done</strong> and then click <strong class="bold">Save</strong>.<p>The rule should now look similar to the following screenshot:</p><div><img src="img/B16551_Figure_8.5.jpg" alt="Figure 8.5 – Rule to manage pull request merges&#13;&#10;"/></div><p class="figure-caption">Figure 8.5 – Rule to manage pull request merges</p></li>
				<li>Finally, name the rule <code>Manage pull request merges</code> and click <strong class="bold">Turn it on</strong> to save and enable the rule.</li>
			</ol>
			<p>We now <a id="_idIndexMarker446"/>know how to integrate pull requests with Jira using automation rules. Firstly, to ensure that the development <a id="_idIndexMarker447"/>issues are synchronized with the actual work being done by the development team, and secondly, to keep track of which issues have been or still need to be merged into the master branch. In the next section, we'll see how to specifically use automation rules to integrate with the release functionality available in GitHub.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor134"/>Automatically releasing versions using GitHub</h1>
			<p>Version control tools allow developers to tag specific revisions of their source code, which, in effect, creates a snapshot of the repository at a point in time. The most common use for tags is to identify the source components and files that make up a particular version <a id="_idIndexMarker448"/>or release of the software and tools such as GitHub and GitLab take this a step further by allowing developers <a id="_idIndexMarker449"/>to create a release based on a particular tag. These typically consist of the list of changes applicable to this particular release in the form of release notes. They can also include links to the list of assets that make up the release, which are typically downloadable binary packages.</p>
			<p>Releases can be created using the tool's user interface, but most commonly are created automatically by build tools such as Bitbucket Pipelines or Jenkins upon the successful completion of a deployment build. These tools can, in turn, fire webhook events to notify other tools when a release has been created.</p>
			<p>With automation rules in Jira, we can use incoming webhooks to receive these notifications and automatically release the corresponding version in Jira and simultaneously transition all the affected issues linked to that version to <em class="italic">Done</em>. Let's now take a look at a rule that will allow us to achieve that.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor135"/>Creating a rule to synchronize version releases to GitHub releases</h2>
			<p>In this rule, we'll create an incoming webhook that can be called by GitHub when a release <a id="_idIndexMarker450"/>is created. The <a id="_idIndexMarker451"/>GitHub release webhook contains a JSON payload from which we'll be able to extract the name of the tag that identifies the release. In turn, this tag name should correspond to the versions in your Jira Software project.</p>
			<p>The structure of the GitHub release payload is similar to the following, and we'll be using the <code>action</code> and <code>tag_name</code> fields in our rule:</p>
			<pre>{
  "action": "published",
  "release": {
    ...
    "tag_name": "1.0",
    ...
  }
}</pre>
			<p>You can read <a id="_idIndexMarker452"/>more about the event payload at the following URL: <a href="mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release">https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/webhook-events-and-payloads#release</a>.</p>
			<p>You can also learn <a id="_idIndexMarker453"/>more about GitHub webhooks and events in general at the following URL: <a href="mailto:https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks">https://docs.github.com/en/free-pro-team@latest/developers/webhooks-and-events/about-webhooks</a>.</p>
			<p>Let's <a id="_idIndexMarker454"/>take a look at the <a id="_idIndexMarker455"/>steps required to build an automation rule to synchronize the release of a Jira version when a version is released from GitHub:</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the <strong class="bold">Project settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <strong class="bold">Incoming webhook</strong> trigger and, in the <strong class="bold">Execute this automation rule with</strong> field, select the <strong class="bold">No issues from the webhook</strong> option and then click <strong class="bold">Save</strong>.<p>Make sure to copy the webhook URL that was automatically generated as we'll need this later to configure the GitHub webhook.</p></li>
				<li>GitHub will send a webhook event for different states of the release; however, for this rule, we are only interested in acting on the event when the release is published, which we can check by looking at the <code>{{webhookData.action}}</code></p><p><code>equals</code></p><p><code>published</code></p></li>
				<li>The first thing we want to do if the condition in <em class="italic">step 3</em> matches is to automatically transition all the issues that belong to the release and are currently waiting to be deployed to <code>JQL</code></p><p><code>fixVersion = {{webhookData.release.tag_name}} AND status = "Waiting for deploy"</code></p></li>
				<li>Then <a id="_idIndexMarker456"/>we select <strong class="bold">New action</strong>, followed by <strong class="bold">Transition issue</strong>, and set the <strong class="bold">Destination status</strong> field to <strong class="bold">Done</strong> before clicking <strong class="bold">Save</strong>.</li>
				<li>Next, we <a id="_idIndexMarker457"/>want to release the Jira version that corresponds to the tag name of the GitHub release.<p>We need to do this outside the <code>{{webhookData.release.tag_name}}</code> and then click <strong class="bold">Save</strong>.</p><p>The rule should now look similar to the following screenshot:</p><div><img src="img/B16551_Figure_8.6.jpg" alt="Figure 8.6 – Automatically releasing a Jira version from GitHub&#13;&#10;"/></div><p class="figure-caption">Figure 8.6 – Automatically releasing a Jira version from GitHub</p></li>
				<li>Finally, name the rule <code>Synchronize versions with GitHub releases</code> and click <strong class="bold">Turn it on</strong> to save and enable the rule.</li>
			</ol>
			<p>Now that <a id="_idIndexMarker458"/>we have the <a id="_idIndexMarker459"/>automation rule in Jira, we will need to complete the configuration in GitHub using the webhook URL generated previously in <em class="italic">step 2</em>.</p>
			<p>Let's now configure our GitHub repository to send release notifications to our automation rule in Jira:</p>
			<ol>
				<li value="1">Navigate to your repository in GitHub, click on <strong class="bold">Settings</strong>, select the <strong class="bold">Webhooks</strong> tab from the menu on the left, and then click on the <strong class="bold">Add webhook</strong> button.</li>
				<li>Complete the webhook fields as follows:<p><code>application/json</code></p><p><code>Enable SSL verification</code></p></li>
				<li>To <a id="_idIndexMarker460"/>ensure that <a id="_idIndexMarker461"/>we receive the correct event in the automation rule, select the <strong class="bold">Let me select individual events</strong> option in the <strong class="bold">Which events would you like to trigger this webhook</strong> field.<p>Make sure to deselect the <strong class="bold">Pushes</strong> option, select the <strong class="bold">Releases</strong> option, and then click <strong class="bold">Add webhook</strong>.</p><p>Your GitHub configuration should look similar to the following screenshot:</p></li>
			</ol>
			<div><div><img src="img/B16551_Figure_8.7.jpg" alt="Figure 8.7 – Configuring the releases webhook in GitHub&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.7 – Configuring the releases webhook in GitHub</p>
			<p>We have <a id="_idIndexMarker462"/>now learned <a id="_idIndexMarker463"/>how to integrate Jira with GitHub releases and how we can use automation rules to release the corresponding version in Jira after transitioning all the affected development tasks to <strong class="bold">Done</strong>. In the next section, we'll look at how to automatically kick off deployment builds using Jenkins when a sprint is completed.</p>
			<h1 id="_idParaDest-157"><a id="_idTextAnchor136"/>Synchronizing deployments with sprint completion</h1>
			<p>In Agile scrum, one of the artifacts created during a sprint is the <strong class="bold">Product increment</strong>, which is <a id="_idIndexMarker464"/>the deliverable produced by completion of the product backlog tasks during a sprint. In this section, we'll learn <a id="_idIndexMarker465"/>how to integrate with Jenkins using automation rules to automatically initiate the final deployment build when the sprint in Jira is closed.</p>
			<p>During a sprint, in a trunk-based development model, developers will commit code to the branch in the source repository associated with the development task, which will generally initiate automated tests to verify that the new code does not negatively affect the build process. When pull requests are created and merged, further automated tests can be initiated followed by automated deployments to QA or staging servers. By the time the sprint is completed, all these processes result in the final task of deploying the resultant product increment to production, or by using a tool such as GitHub to create a release.</p>
			<p>Let's take a look at how this is achievable using automation rules.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor137"/>Creating a rule to start a deployment build</h2>
			<p>In this example, we'll create a rule that will initiate a production build of a software project <a id="_idIndexMarker466"/>each time a sprint is completed. To <a id="_idIndexMarker467"/>achieve this, we first need to configure the job in Jenkins to allow builds to be triggered remotely by scripts.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you do not already have a Jenkins instance, you can sign up for an AWS account at <a href="https://aws.amazon.com">https://aws.amazon.com</a> and launch a new EC2 instance based on the <em class="italic">Jenkins Certified by Bitnami</em> AMI. This AMI contains full instructions on how to get up and running with Jenkins in AWS.</p>
			<p>We'll start by navigating to the project in Jenkins. In the project's <strong class="bold">Configuration</strong> screen, select the <strong class="bold">Build Triggers</strong> tab and then select the <strong class="bold">Trigger builds remotely</strong> option. Jenkins requires an authentication token to be provided to ensure that only remote systems that know this token can kick off the build job.</p>
			<p>This token <a id="_idIndexMarker468"/>can be any text string of your <a id="_idIndexMarker469"/>choosing. In our example, we're going to use <code>MY_SECURE_AUTH_TOKEN</code> as the <strong class="bold">Authentication Token</strong>. Once you have configured Jenkins, the <strong class="bold">Build Triggers</strong> section should look similar to the following screenshot:</p>
			<div><div><img src="img/B16551_Figure_8.8.jpg" alt="Figure 8.8 – Configuring Jenkins to allow the triggering of builds remotely&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 8.8 – Configuring Jenkins to allow the triggering of builds remotely</p>
			<p>Now that we have Jenkins configured, let's build the automation rule to initiate deployment when our sprint is completed:</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the <strong class="bold">Project settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <strong class="bold">Sprint completed</strong> trigger and, in the <strong class="bold">Boards</strong> field, select the Scrum board for your project and then click <strong class="bold">Save</strong>. In this example, we'll select <strong class="bold">My Application Scrum Board</strong>.</li>
				<li>Sending API requests to Jenkins requires us to acquire an API crumb from the Jenkins crumb issuer service. This service returns a crumb that we later need to use to interact with the API in the following format:<pre>{
    "_class": "hudson.security.csrf.DefaultCrumbIssuer",
    "crumb": "18b1846…",
    "crumbRequestField": "Jenkins-Crumb"
}</pre><p>To do <a id="_idIndexMarker470"/>this, select <code>https://&lt;your_jenkins_host&gt;/crumbIssuer/api/json</code></p><p><code>Authorization</code></p><p><code>Basic &lt;your base64-encoded credentials&gt;</code></p><p><code>GET</code></p><p><code>Empty</code></p><p><code>{{webhookResponse}}</code> smart value.</p></li>
				<li>Next, we need to make the call to the Jenkins API to kick off the deployment build that we configured in Jenkins.<p>We will also need to send the Jenkins crumb that we retrieved in <em class="italic">step 3</em> in the <em class="italic">Jenkins-Crumb</em> header.</p><p>Again, select <code>https://&lt;your_jenkins_host&gt;/job/&lt;your_job_name&gt;/build?token=&lt;YOUR_AUTHORIZATION_TOKEN&gt;</code></p><p>Fill the following in the first <code>Authorization</code></p><p><code>Basic &lt;your base64-encoded credentials&gt;</code></p><p>Fill in <a id="_idIndexMarker472"/>the following second <code>Jenkins-Crumb</code></p><p><code>{{webhookResponse.body.crumb}}</code></p><p><code>POST</code></p><p><code>Empty</code></p><p><code>{{webhookResponse}}</code> smart value.</p></li>
				<li>If the build is successfully kicked off in Jenkins, we want to transition all the issues in the sprint that were waiting for deployment to <code>{{webhookResponse}}</code> smart value will always contain the response from the latest <code>{{webhookResponses}}</code> list, which will contain the responses in order of the web request actions, starting from position zero (0). Also note that responses will only be added to this list if you have checked the <code>{{webhookResponse.status}}</code></p><p><code>exactly matches regular expression</code></p><p><code>2\d\d</code></p></li>
				<li>Next, select <strong class="bold">Branch rule / related issues</strong> followed by <strong class="bold">Issues in the sprint</strong> in the <strong class="bold">Type of related issues</strong> field and then click <strong class="bold">Save</strong>.</li>
				<li>Then, select <code>Status</code></p><p><code>equals</code></p><p><code>Waiting for deploy</code></p></li>
				<li>Now we need to transition the issues if they match the condition in <em class="italic">step 7</em>.<p>Select <strong class="bold">New action</strong> followed by <strong class="bold">Transition issue</strong>. In the <strong class="bold">Destination status</strong> field, select <strong class="bold">Done</strong> and then click <strong class="bold">Save</strong>.</p><p>Your rule should look similar to the following screenshot:</p><div><img src="img/B16551_Figure_8.9.jpg" alt="Figure 8.9 – Rule to start Jenkins deployment upon sprint closure&#13;&#10;"/></div><p class="figure-caption">Figure 8.9 – Rule to start Jenkins deployment upon sprint closure</p></li>
				<li>Finally, name the rule <code>Start deployment on sprint closure</code> and click <strong class="bold">Turn it on</strong> to save and enable the rule.</li>
			</ol>
			<p>This concludes <a id="_idIndexMarker476"/>the final section of <a id="_idIndexMarker477"/>this chapter, in which we have learned how to use automation rules to integrate with Jenkins to automatically kick off deployment builds when a sprint is completed and to transition all the affected development tasks to <strong class="bold">Done</strong>.</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor138"/>Summary</h1>
			<p>In this chapter, we have learned how using automation rules can help us with DevOps practices by optimizing our development and operations processes.</p>
			<p>We have covered how to use the built-in DevOps automation triggers available in Jira Cloud to integrate with our source repositories, such as Bitbucket or GitHub. This allows us to keep development issues in Jira in sync with the code as it is committed to the source repository.</p>
			<p>In addition, we have also learned how we can achieve similar integrations when using Jira Server or Data Center by using incoming webhooks in our rules in place of the DevOps triggers available to Jira Cloud.</p>
			<p>Next, we learned how we could use the DevOps pull request triggers available in Jira Cloud to automatically synchronize the development tasks in Jira. We also learned how to create and manage tracking tasks, which provide greater visibility into the overall development process within Jira.</p>
			<p>We then learned how, when using GitHub to manage software releases, we can also use automation rules to release transition the affected issues in Jira to <strong class="bold">Done</strong> and how to automatically keep the version in Jira in sync when creating a GitHub release. Finally, we learned how to automatically initiate a deployment build of a software project in Jenkins whenever a sprint in Jira is completed.</p>
			<p>By introducing automation rules into our Jira processes, we can streamline our DevOps processes and drastically reduce the amount of time developers need to perform tasks in multiple tools.</p>
			<p>In the next chapter, we will be exploring some best practices to follow when creating automation rules in Jira.</p>
		</div>
	</body></html>