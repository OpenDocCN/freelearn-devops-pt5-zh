- en: Advanced Docker Usage Scenarios
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Docker 使用场景
- en: In the last chapter, we showed you how you can use tools to perform administrative
    tasks without having to install those tools on the host computer. We also illustrated
    the use of containers that host and run test scripts or code used to test and
    validate application services running in containers. Finally, we guided you through
    the task of building a simple Docker-based CI/CD pipeline using Jenkins as the
    automation server.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们向你展示了如何使用工具执行管理任务，而不需要在主机计算机上安装这些工具。我们还说明了如何使用容器来托管和运行测试脚本或代码，用于测试和验证在容器中运行的应用服务。最后，我们引导你完成了使用
    Jenkins 作为自动化服务器，构建一个简单的基于 Docker 的 CI/CD 流水线的任务。
- en: In this chapter, we will introduce advanced tips, tricks, and concepts that
    are useful when containerizing complex distributed applications, or when using
    Docker to automate sophisticated tasks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍在容器化复杂的分布式应用程序时，或者使用 Docker 自动化复杂任务时，有用的高级技巧、窍门和概念。
- en: 'This is a quick overview of all of the subjects we are going to touch on in
    this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在本章中涉及的所有主题的快速概览：
- en: All of the tips and tricks of a Docker pro
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为 Docker 专家的所有技巧和窍门
- en: Running your Terminal in a remote container and accessing it via HTTPS
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程容器中运行你的终端，并通过 HTTPS 访问它
- en: Running your development environment inside a container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行你的开发环境
- en: Running your code editor in a remote container and accessing it via HTTPS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在远程容器中运行你的代码编辑器，并通过 HTTPS 访问它
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做以下事情：
- en: Successfully restore your Docker environment after it has been messed up completely
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功恢复被彻底破坏的 Docker 环境
- en: Run a remote Terminal in a container and access it with your browser via HTTPS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行远程终端，并通过 HTTPS 使用浏览器访问它
- en: Edit code remotely with Visual Studio Code with your browser via HTTPS
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 HTTPS 使用浏览器与 Visual Studio Code 远程编辑代码
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, if you want to follow along with the code, you need Docker
    for Desktop on your Mac or Windows machine and the Visual Studio Code editor.
    The example will also work on a Linux machine with Docker and Visual Studio Code
    installed. Docker Toolbox is not supported in this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果你想跟着代码一起操作，你需要在 Mac 或 Windows 机器上安装 Docker for Desktop 以及 Visual Studio
    Code 编辑器。这个示例也可以在安装了 Docker 和 Visual Studio Code 的 Linux 机器上运行。本章不支持使用 Docker
    Toolbox。
- en: All of the tips and tricks of a Docker pro
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为 Docker 专家的所有技巧和窍门
- en: In this section, I will present a few very useful tips and tricks that make
    the lives of advanced Docker users so much easier. We will start with some guidance
    on how to keep your Docker environment clean.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一节中，我将介绍一些非常实用的技巧和窍门，这些技巧让高级 Docker 用户的生活更加轻松。我们将从一些关于如何保持 Docker 环境清洁的指导开始。
- en: Keeping your Docker environment clean
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持你的 Docker 环境干净
- en: 'First, we want to learn how we can delete dangling images. According to Docker,
    dangling images are layers that have no relationship to any tagged images. Such
    image layers are certainly useless to us and can quickly fill up our disk—it''s
    better to remove them from time to time. Here is the command:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要了解如何删除悬挂的镜像。根据 Docker 的定义，悬挂镜像是指没有与任何已标记镜像关联的层。这些镜像层对我们来说显然是没有用的，并且会迅速填满我们的磁盘——最好定期删除它们。以下是删除命令：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Please note that I have added the `-f` parameter to the `prune` command. This
    is to prevent the CLI from asking for a confirmation that we really want to delete
    those superfluous layers.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我已将 `-f` 参数添加到 `prune` 命令中。这是为了防止命令行界面询问我们是否确认真的要删除那些多余的层。
- en: 'Stopped containers can waste precious resources too. If you''re sure that you
    don''t need these containers anymore, then you should remove them, either individually
    with the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 停止的容器也可能浪费宝贵的资源。如果你确定这些容器不再需要，应该将它们删除，可以使用以下命令逐个删除：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Or, you can remove them as a batch with the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用以下命令批量删除它们：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is worth mentioning once again that, instead of `<container-id>`, we can
    also use `<container-name>` to identify a container.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次提到的是，我们可以使用 `<container-name>` 来代替 `<container-id>` 来识别一个容器。
- en: 'Unused Docker volumes too can quickly fill up disk space. It is a good practice
    to tender your volumes, specifically in a development or CI environment where
    you create a lot of mostly temporary volumes. But I have to warn you, Docker volumes
    are meant to store data. Often, this data must live longer than the life cycle
    of a container. This is specifically true in a production or production-like environment
    where the data is often mission-critical. Hence, be 100% sure of what you''re
    doing when using the following command to prune volumes on your Docker host:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的 Docker 卷也会迅速占满磁盘空间。在开发或 CI 环境中，创建大量大多是临时卷的情况，定期清理卷是一个很好的做法。但我必须提醒你，Docker
    卷是用来存储数据的。通常，这些数据的生命周期需要长于容器的生命周期。这在生产或类生产环境中尤为重要，因为数据往往是至关重要的。因此，在使用以下命令清理 Docker
    主机上的卷时，一定要确保自己完全了解自己在做什么：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: I recommend using this command without the `-f` (or `--force`) flag. It is a
    dangerous and terminal operation and it's better to give yourself a second chance
    to reconsider your action. Without the flag, the CLI outputs the warning you see
    in the preceding. You have to explicitly confirm by typing `y` and pressing the
    *Enter* key.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议在没有 `-f`（或 `--force`）标志的情况下使用此命令。这是一个危险且不可逆的操作，最好给自己一个重新考虑的机会。如果没有这个标志，CLI
    会输出你在前面看到的警告。你需要显式确认，通过输入 `y` 并按下 *Enter* 键。
- en: 'On production or production-like systems, you should abstain from the preceding
    command and rather delete unwanted volumes one at a time by using this command:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产或类生产系统中，你应该避免使用前面的命令，而是使用以下命令逐一删除不需要的卷：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: I should also mention that there is a command to prune Docker networks. But
    since we have not yet officially introduced networks, I will defer this to [chapter
    10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *Single-Host Networking*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到，有一个命令可以清理 Docker 网络。但由于我们还没有正式介绍网络内容，所以我将把它留到 [第十章](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)，*单主机网络*。
- en: In the next section, we are going to show how we can automate Docker from within
    a container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将展示如何在容器内部自动化 Docker 操作。
- en: Running Docker in Docker
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Docker 中运行 Docker
- en: At times, we may want to run a container hosting an application that automates
    certain Docker tasks. How can we do that? The Docker Engine and the Docker CLI
    are installed on the host, yet the application runs inside the container. Well,
    from early on, Docker has provided a means to bind-mount Linux sockets from the
    host into the container. On Linux, sockets are used as very efficient data communications
    endpoints between processes that run on the same host. The Docker CLI uses a socket
    to communicate with the Docker Engine; it is often called the Docker socket. If
    we can give access to the Docker socket to an application running inside a container
    then we can just install the Docker CLI inside this container, and we will then
    be able to run an application in the same container that uses this locally installed
    Docker CLI to automate container-specific tasks.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能想要运行一个托管应用程序的容器，这个应用程序可以自动化某些 Docker 任务。我们该如何实现呢？Docker 引擎和 Docker CLI
    安装在主机上，但应用程序运行在容器内。实际上，Docker 从一开始就提供了一种方法，可以将 Linux 套接字从主机绑定到容器内。在 Linux 上，套接字作为进程间通信的高效数据传输端点，用于同一主机上运行的进程之间。Docker
    CLI 使用套接字与 Docker 引擎通信，通常称为 Docker 套接字。如果我们能够让容器内部的应用程序访问 Docker 套接字，那么我们就可以在容器内部安装
    Docker CLI，之后我们就能够在同一容器内运行一个应用程序，使用本地安装的 Docker CLI 来自动化与容器相关的任务。
- en: It is important to note that here we are not talking about running the Docker
    Engine inside the container but rather only the Docker CLI and bind-mount the
    Docker socket from the host into the container so that the CLI can communicate
    with the Docker Engine running on the host computer. This is an important distinction.
    Running the Docker Engine inside a container, although possible, is not recommended.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，我们在这里并不是在谈论在容器内运行 Docker 引擎，而只是运行 Docker CLI，并将主机上的 Docker 套接字绑定挂载到容器中，以便
    CLI 可以与运行在主机上的 Docker 引擎进行通信。这是一个重要的区别。尽管可以，但不建议在容器内运行 Docker 引擎。
- en: 'Let''s assume we have the following script, called `pipeline.sh`, automating
    the building, testing, and pushing of a Docker image:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个名为 `pipeline.sh` 的脚本，用于自动化构建、测试和推送 Docker 镜像：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we're using four environment variables: `$HUB_USER` and `$HUB_PWD`
    being the credentials for Docker Hub and `$REPOSITORY` and `$TAG` being the name
    and tag of the Docker image we want to build. Eventually, we will have to pass
    values for those environment variables in the `docker run` command.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们使用了四个环境变量：`$HUB_USER` 和 `$HUB_PWD` 是 Docker Hub 的凭据，而 `$REPOSITORY` 和 `$TAG`
    是我们要构建的 Docker 镜像的名称和标签。最终，我们必须在 `docker run` 命令中传递这些环境变量的值。
- en: 'We want to run that script inside a builder container. Since the script uses
    the Docker CLI, our builder container must have the Docker CLI installed, and
    to access the Docker Engine, the builder container must have the Docker socket
    bind-mounted. Let''s start creating a Docker image for such a builder container:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在 builder 容器中运行该脚本。由于脚本使用了 Docker CLI，因此我们的 builder 容器必须安装 Docker CLI，并且为了访问
    Docker 引擎，builder 容器必须绑定挂载 Docker 套接字。让我们开始为这样的 builder 容器创建一个 Docker 镜像：
- en: 'First, create a `builder` folder and navigate to it:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个 `builder` 文件夹并导航到该文件夹：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Inside this folder, create a `Dockerfile` that looks like this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内，创建一个如下所示的 `Dockerfile`：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now create a `pipeline.sh` file in the `builder` folder and add as content the
    pipeline script we have presented in the preceding file.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `builder` 文件夹中创建一个 `pipeline.sh` 文件，并将我们在前一个文件中呈现的管道脚本作为内容添加进去。
- en: 'Save and make the file an executable:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并使文件成为可执行文件：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Building an image is straightforward:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建镜像非常简单：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We are now ready to try `builder` out with a real Node.js application, for
    example, the sample app we defined in the `ch08/sample-app` folder. Make sure
    you replace `<user>` and `<password>` with your own credentials for Docker Hub:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好使用真实的 Node.js 应用程序来尝试 `builder`，例如，我们在 `ch08/sample-app` 文件夹中定义的示例应用程序。确保将
    `<user>` 和 `<password>` 替换为你自己的 Docker Hub 凭据：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Notice how, in the preceding command, we mounted the Docker socket into the
    container with `-v /var/run/docker.sock:/var/run/docker.sock`. If everything goes
    well, you should have a container image built for the sample application, the
    test should have been run, and the image should have been pushed to Docker Hub.
    This is only one of the many use cases where it is very useful to be able to bind-mount
    the Docker socket.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在前面的命令中，我们使用 `-v /var/run/docker.sock:/var/run/docker.sock` 将 Docker 套接字挂载到容器内。如果一切顺利，你应该已经为示例应用程序构建了容器镜像，测试已经运行，镜像也已经推送到
    Docker Hub。这仅仅是许多情况下，能够绑定挂载 Docker 套接字非常有用的一种用例。
- en: 'A special notice to all those of you who want to try Windows containers. On
    Docker for Windows, you can create a similar environment by bind-mounting Docker''s **named
    pipe** instead of a socket. A named pipe on Windows is roughly the same as a socket
    on a Unix-based system. Assuming you''re using a PowerShell Terminal, the command
    to bind-mount a named pipe when running a Windows container hosting Jenkins looks
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 特别提醒所有想尝试 Windows 容器的用户。在 Docker for Windows 上，你可以通过绑定挂载 Docker 的**命名管道**来创建一个类似的环境，而不是使用套接字。Windows
    上的命名管道大致相当于基于 Unix 的系统中的套接字。假设你正在使用 PowerShell 终端，运行 Windows 容器并托管 Jenkins 时，绑定挂载命名管道的命令如下所示：
- en: '``**PS>** **docker container run `** **--name jenkins `** **-p 8080:8080 `**
    **-v \\.\pipe\docker_engine:\\.\pipe\docker_engine ` friism/jenkins**``'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '``**PS>** **docker container run `** **--name jenkins `** **-p 8080:8080 `**
    **-v \\.\pipe\docker_engine:\\.\pipe\docker_engine ` friism/jenkins**``'
- en: Note the special syntax, `\\.\pipe\docker_engine`, to access Docker's named
    pipe.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意特殊语法，`\\.\pipe\docker_engine`，以访问 Docker 的命名管道。
- en: Formatting the output of common Docker commands
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 格式化常见 Docker 命令的输出
- en: 'Have you at times wished that your Terminal window was infinitely wide since
    the output of a Docker command such as `docker container ps` is scrambled across
    several lines per item? Worry not, as you can customize the output to your liking.
    Almost all commands that produce an output have a `--format` argument, which accepts
    a so-called Go template as a parameter. If you wonder why a Go template, it''s
    because most of Docker is written in this popular low-level language. Let''s look
    at an example. Assume we want to only show the name of the container, the name
    of the image, and the state of the container, separated by tabs, output by the
    `docker container ps` command. The format would then look like this:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾希望你的终端窗口是无限宽的，因为像 `docker container ps` 这样的 Docker 命令的输出会跨多行显示每个项目？不用担心，你可以根据自己的喜好自定义输出。几乎所有生成输出的命令都有一个
    `--format` 参数，该参数接受所谓的 Go 模板作为参数。如果你想知道为什么是 Go 模板，那是因为 Docker 的大部分代码都是用这种流行的低级语言编写的。让我们看一个例子。假设我们只想显示容器的名称、镜像的名称以及容器的状态，用制表符分隔，由
    `docker container ps` 命令输出。那么格式应该是这样的：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Please be aware that the `format` string is case sensitive. Also, note the
    addition of the `-a` parameter to include stopped containers in the output. A
    sample output could look like this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`format` 字符串是区分大小写的。此外，注意新增了 `-a` 参数，以便在输出中包括已停止的容器。一个示例输出可能如下所示：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is definitely nicer to display even on a narrow Terminal window than the
    unformatted one scattering wildly over multiple lines.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在较窄的终端窗口中，这种输出格式也比未格式化的输出更加美观，后者会在多行之间乱七八糟地分散。
- en: Filtering the output of common Docker commands
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤常见 Docker 命令的输出
- en: 'Similar to what we have done in the previous section by pretty-printing the
    output of Docker commands, we can also filter what is output. There are quite
    a few filters that are supported. Please find the full list for each command in
    the Docker online documentation. The format of filters is straightforward and
    of the type `--filter <key>=<value>`. If we need to combine more than one filter,
    we can just combine multiple of these statements. Let''s do an example with the
    `docker image ls` command as I have a lot of images on my workstation:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们在前一节通过漂亮打印 Docker 命令输出所做的，我们也可以过滤输出内容。有相当多的过滤器是支持的。请在 Docker 在线文档中查找每个命令的完整列表。过滤器的格式非常简单，类型为
    `--filter <key>=<value>`。如果我们需要组合多个过滤器，只需将这些语句组合起来即可。让我们通过 `docker image ls` 命令做一个示例，因为我的工作站上有很多镜像：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding filter only outputs images that are not dangling, that is, real
    images whose fully qualified name is of the form `<registry>/<user|org><repository>:<tag>`,
    and the tag is equal to `latest`. The output on my machine looks like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 上述过滤器只输出非悬挂的镜像，即真实镜像，其完整名称的形式为 `<registry>/<user|org><repository>:<tag>`，并且标签为
    `latest`。我机器上的输出如下所示：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Having shown how to pretty print and filter output generated by the Docker CLI,
    it is now time to talk once more about building Docker images and how to optimize
    this process.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示如何漂亮地打印和过滤由 Docker CLI 生成的输出后，现在是时候再次讨论如何构建 Docker 镜像以及如何优化这个过程了。
- en: Optimizing your build process
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化构建过程
- en: 'Many Docker beginners make the following mistake when crafting their first
    `Dockerfile`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Docker 初学者在编写他们的第一个 `Dockerfile` 时会犯以下错误：
- en: '[PRE15]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Can you spot the weak point in this typical `Dockerfile` for a Node.js application?
    In [Chapter 4](527543ae-a569-47dc-975d-65c96d0f6ff0.xhtml), *Creating and Managing
    Container Images*, we have learned that an image consists of a series of layers.
    Each (logical) line in a `Dockerfile` creates a layer, except the lines with the
    `CMD` and/or `ENTRYPOINT` keyword. We have also learned that the Docker builder
    tries to do its best by caching layers and reusing them if they have not changed
    between subsequent builds. But the caching only uses cached layers that occur
    before the first changed layer. All subsequent layers need to be rebuilt. That
    said, the preceding structure of the `Dockerfile` busts the image layer cache!
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现这个典型的 Node.js 应用程序的 `Dockerfile` 中的弱点吗？在 [第 4 章](527543ae-a569-47dc-975d-65c96d0f6ff0.xhtml)《创建和管理容器镜像》中，我们学到了一张镜像由一系列层组成。每一行（逻辑上）都会创建一层，除了包含
    `CMD` 和/或 `ENTRYPOINT` 关键字的行。我们还学到，Docker 构建器尽力通过缓存层并在后续构建之间重用它们来提高效率。但缓存只会使用发生在第一个更改层之前的缓存层。所有后续层都需要重新构建。也就是说，上述
    `Dockerfile` 结构会破坏镜像层的缓存！
- en: 'Why? Well, from experience, you certainly know that `npm install` can be a
    pretty expensive operation in a typical Node.js application with many external
    dependencies. The execution of this command can take from seconds to many minutes.
    That said, each time one of the source files changes, and we know that happens
    frequently during development, line 3 in the `Dockerfile` causes the corresponding
    image layer to change. Hence, the Docker builder cannot reuse this layer from
    cache, nor can it reuse the subsequent layer created by `RUN npm install`. Any
    minor change in code causes a complete rerun of `npm install`. That can be avoided.
    The `package.json` file containing the list of external dependencies rarely changes.
    With all of that information, let''s fix the `Dockerfile`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？嗯，根据经验，你一定知道，在一个典型的Node.js应用程序中，`npm install`可能是一个相当耗费资源的操作，尤其是当有许多外部依赖时。这个命令的执行可能需要几秒钟到几分钟不等。也就是说，每当其中一个源文件发生变化，而我们知道在开发过程中这会经常发生时，第3行的`Dockerfile`会导致相应的镜像层发生变化。因此，Docker构建器无法重用这个缓存中的层，也无法重用由`RUN
    npm install`创建的后续层。任何代码的小改动都会导致`npm install`的完整重跑。这是可以避免的。包含外部依赖列表的`package.json`文件很少变化。根据这些信息，我们来修复`Dockerfile`：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This time, on line 3, we only copy the `package.json` file into the container,
    which rarely changes. Hence, the subsequent `npm install` command has to be executed
    equally rarely. The `COPY` command on line 5 then is a very fast operation and
    hence rebuilding an image after some code has changed only needs to rebuild this
    last layer. Build times reduce to merely a fraction of a second.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，在第3行，我们只将`package.json`文件复制到容器中，这个文件很少变化。因此，后续的`npm install`命令也只需很少执行一次。第5行的`COPY`命令是一个非常快速的操作，因此在代码发生变化后重新构建镜像只需要重新构建最后一层。构建时间缩短到仅仅几分之一秒。
- en: The very same principle applies to most languages or frameworks, such as Python,
    .NET, or Java. Avoid busting your image layer cache!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原理适用于大多数语言或框架，如Python、.NET或Java。避免破坏你的镜像层缓存！
- en: Limiting resources consumed by a container
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制容器使用的资源
- en: 'One of the great features of a container, apart from encapsulating application
    processes, is the possibility of limiting the resources a single container can
    consume at. This includes CPU and memory consumption. Let''s have a look at how
    limiting the amount of memory (RAM) works:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 除了封装应用程序进程，容器的一个重要特点是能够限制单个容器消耗的资源，包括CPU和内存。让我们来看一下限制内存（RAM）消耗是如何工作的：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Once inside the container, install the `stress` tool, which we will use to
    simulate memory pressure:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 进入容器后，安装`stress`工具，我们将用它来模拟内存压力：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Open another Terminal window and execute the `docker stats` command. You should
    see something like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端窗口并执行`docker stats`命令。你应该会看到类似以下的内容：
- en: '![](img/8a674500-7732-44f7-98fd-a13d1aa38450.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a674500-7732-44f7-98fd-a13d1aa38450.png)'
- en: docker stats showing a resource-limited container
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: docker stats显示一个资源受限的容器
- en: 'Look at  `MEM USAGE` and `LIMIT`. Currently, the container uses only `1.87MiB` memory
    and has a limit of `512MB`. The latter corresponds to what we have configured
    for this container. Now, let''s use `stress` to simulate four workers, which try
    to `malloc()` memory in blocks of `256MB`. Run this command inside the container
    to do so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`MEM USAGE`和`LIMIT`。当前，容器仅使用`1.87MiB`内存，并且内存限制为`512MB`。后者对应于我们为这个容器配置的值。现在，让我们使用`stress`模拟四个工作线程，这些线程尝试以`256MB`为单位的块分配内存。运行以下命令来实现：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the Terminal running Docker stats, observe how the value for `MEM USAGE`
    approaches but never exceeds `LIMIT`. This is exactly the behavior we expected
    from Docker. Docker uses Linux `cgroups` to enforce those limits.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端运行Docker stats时，观察`MEM USAGE`的值接近但永远不会超过`LIMIT`。这正是我们预期的Docker行为。Docker使用Linux的`cgroups`来强制执行这些限制。
- en: We could similarly limit the amount of CPU a container can consume with the
    `--cpu` switch.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们同样可以使用`--cpu`选项限制容器能够使用的CPU数量。
- en: With this operation, engineers can avoid the noisy neighbor problem on a busy
    Docker host, where a single container starves all of the others by consuming an
    excessive amount of resources.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这种操作，工程师们可以避免在繁忙的Docker主机上出现"噪音邻居"问题，即一个容器通过消耗过多资源使得其他所有容器都无法正常运行。
- en: Read-only filesystem
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 只读文件系统
- en: 'To protect your applications against malicious hacker attacks, it is often
    advised to define the filesystem of the container or part of it as read-only.
    This makes the most sense for stateless services. Assume that you have a billing
    service running in a container as part of your distributed, mission-critical application.
    You could run your billing service as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保护您的应用程序免受恶意黑客攻击，通常建议将容器的文件系统或其中一部分设置为只读。这对无状态服务最为适用。假设您有一个在容器中运行的计费服务，作为您分布式关键任务应用程序的一部分。您可以按以下方式运行您的计费服务：
- en: '[PRE20]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `--read-only` flag mounts the container''s filesystem as read-only. If
    a hacker succeeds in entering your billing container and tries to change an application
    maliciously by, say, replacing one of the binaries with a compromised one, then
    this operation would fail. We can easily demonstrate that with the following commands:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`--read-only`标志将容器的文件系统挂载为只读。如果黑客成功进入您的计费容器，并试图通过例如用一个被篡改的二进制文件替换其中的一个程序来恶意修改应用程序，那么这个操作将会失败。我们可以通过以下命令轻松演示这一点：'
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The first command runs a container with a read-only filesystem and the second
    command tries to execute another process in this container, which is supposed
    to write something to the filesystem—in this case, a simple text file. This fails,
    as we can see in the preceding output, with the error message `Read-only file
    system`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令运行一个只读文件系统的容器，第二个命令尝试在该容器中执行另一个进程，目的是将某些内容写入文件系统——在此案例中，是一个简单的文本文件。正如我们在前面的输出中看到的那样，这个操作失败了，错误信息为`只读文件系统`。
- en: Another means to tighten the security of your applications running in containers
    is to avoid running them as `root`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 加强容器中运行的应用程序安全性的另一种方法是避免以`root`身份运行它们。
- en: Avoid running a containerized app as root
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免以root身份运行容器化应用程序
- en: Most applications or application services that run inside a container do not
    need root access. To tighten security, it is helpful in those scenarios to run
    these processes with minimal necessary privileges. These applications should not
    be run as `root` nor assume that they have `root`-level privileges.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在容器中运行的应用程序或应用服务并不需要root权限。为了加强安全性，在这些情况下，尽可能用最小的必要权限运行这些进程是有益的。这些应用程序不应以`root`身份运行，也不应假设它们拥有`root`级别的权限。
- en: 'Once again, let''s illustrate what we mean with an example. Assume we have
    a file with top-secret content. We want to secure this file on our Unix-based
    system using the `chmod` tool so that only users with root permission can access
    it. Let''s assume I am logged in as `gabriel` on the `dev` host and hence my prompt
    is `gabriel@dev $`. I can use `sudo su` to impersonate a superuser. I have to
    enter the superuser password though:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 再次让我们通过一个例子来说明我们所说的。假设我们有一个包含顶级机密内容的文件。我们希望使用`chmod`工具在基于Unix的系统上保护这个文件，确保只有拥有root权限的用户可以访问它。假设我以`gabriel`身份登录到`dev`主机，因此我的提示符是`gabriel@dev
    $`。我可以使用`sudo su`来模拟超级用户身份。但我必须输入超级用户密码：
- en: '[PRE22]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, as the `root` user, I can create this file called `top-secret.txt` and
    secure it:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为`root`用户，我可以创建一个名为`top-secret.txt`的文件并将其加密：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If I try to access the file as `gabriel`, the following happens:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我尝试以`gabriel`身份访问该文件，以下情况会发生：
- en: '[PRE24]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'I get `Permission denied`, which is what we wanted. No other user except `root`
    can access this file. Now, let''s build a Docker image that contains this secured
    file and when a container is created from it, tries to output its content. The
    `Dockerfile` could look like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我得到`权限被拒绝`，这正是我们想要的。除`root`外，没有其他用户可以访问该文件。现在，让我们构建一个包含此加密文件的Docker镜像，当从该镜像创建容器时，尝试输出其内容。`Dockerfile`可能如下所示：
- en: '[PRE25]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can build an image from that Dockerfile (as `root`!) with the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令从那个Dockerfile（以`root`身份！）构建一个镜像：
- en: '[PRE26]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, when running a container from that image we get:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当我们从该镜像运行容器时，我们得到：
- en: '[PRE27]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OK, so although I am impersonating the `gabriel` user on the host and running
    the container under this user account, the application running inside the container
    automatically runs as `root`, and hence has full access to protected resources.
    That''s bad, so let''s fix it! Instead of running with the default, we define
    an explicit user inside the container. The modified `Dockerfile` looks like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，尽管我在主机上以`gabriel`用户身份模拟，并且在此用户账户下运行容器，但容器内运行的应用程序会自动以`root`身份运行，因此拥有对受保护资源的完全访问权限。这不好，所以让我们修复它！我们不再使用默认设置，而是在容器内定义一个明确的用户。修改后的`Dockerfile`如下所示：
- en: '[PRE28]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use the `groupadd` tool to define a new group, `demo-group`, with the ID
    `3000`. Then, we use the `useradd` tool to add a new user, `demo-user`, to this
    group. The user has the ID `4000` inside the container. Finally, with the `USER
    demo-user` statement, we declare that all subsequent operations should be executed
    as `demo-user`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`groupadd`工具定义一个新组`demo-group`，ID为`3000`。然后，我们使用`useradd`工具将一个新用户`demo-user`添加到此组。该用户在容器内的ID是`4000`。最后，通过`USER
    demo-user`语句，我们声明所有后续操作应以`demo-user`身份执行。
- en: 'Rebuild the image—again as `root`—and then try to run a container from it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以`root`身份重新构建镜像，然后尝试从中运行容器：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And as you can see on the last line, the application running inside the container
    runs with restricted permissions and cannot access resources that need root-level
    access. By the way, what do you think would happen if I ran the container as `root`?
    Try it out!
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在最后一行所看到的，运行在容器内的应用程序具有受限权限，无法访问需要根权限的资源。顺便问一下，如果我以`root`身份运行容器，你认为会发生什么？试试看吧！
- en: These have been a few tips and tricks for pros that are useful in the day-to-day
    usage of containers. There are many more. Google them. It is worth it.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些专业人士在日常容器使用中非常有用的提示和技巧。还有很多更多的技巧，去Google一下吧，值得一试。
- en: Running your Terminal in a remote container and accessing it via HTTPS
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在远程容器中运行终端并通过HTTPS访问它
- en: There are situations where you need to access a remote server and only have
    the option to use a browser for that. Your laptop may be locked down by your employer
    so that you are not allowed to, for example, `ssh` into a server outside of the
    company's domain.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你需要访问远程服务器，而唯一的选择是使用浏览器。你的笔记本电脑可能被你的雇主锁定，不允许你，例如，通过`ssh`连接到公司域外的服务器。
- en: 'To test this scenario proceed as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个场景，请按以下步骤操作：
- en: Create a free account on Microsoft Azure, GCP, or AWS. Then, create a VM, preferably
    with Ubuntu 18.04 or higher as the operating system, to follow along more easily.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Microsoft Azure、GCP或AWS上创建一个免费账户。然后，创建一个虚拟机，最好选择Ubuntu 18.04或更高版本的操作系统，以便更轻松地跟进。
- en: 'Once your VM is ready, SSH into it. The command to do so should look similar
    to this:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你的虚拟机准备好，使用SSH连接到它。执行此操作的命令应该类似于以下内容：
- en: '[PRE30]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To get access, you may need to open port `22` for ingress first for the VM.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要获得访问权限，您可能需要先为虚拟机开放端口`22`以允许外部访问。
- en: The user I have defined during the provisioning of the VM is `gnschenker` and
    the public IP address of my VM is `40.115.4.249`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我在配置虚拟机时定义的用户是`gnschenker`，而我的虚拟机的公网IP地址是`40.115.4.249`。
- en: Install Docker on this VM using the description found here: [https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/).
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此处提供的说明，在虚拟机上安装Docker：[https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/)。
- en: 'On a special note, do not forget to add your user (`gnschenker`, in my case)
    to the `docker` group on the VM with the following command:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 特别注意，不要忘记使用以下命令将你的用户（在我的例子中是`gnschenker`）添加到虚拟机的`docker`组中：
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With this, you avoid having to constantly use `sudo` for all Docker commands.
    You need to log out from and log in to the VM to make this change work.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你就避免了在所有Docker命令中都必须使用`sudo`。你需要退出并重新登录虚拟机以使此更改生效。
- en: 'Now, we are ready to run **Shell in a Box** ([https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox))
    in a container on the VM. There are quite a few people who have containerized
    Shell in a Box. We are using the Docker image, `sspreitzer/shellinabox`. At the
    time of writing, it is the most popular version by far on Docker Hub. With the
    following command, we are running the application with a user, `gnschenker`; password, `top-secret`;
    `sudo` for the user enabled; and with self-signed certificates:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备在虚拟机上的容器中运行**Shell in a Box** ([https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox))。有很多人已经将Shell
    in a Box容器化。我们正在使用Docker镜像`sspreitzer/shellinabox`。在写这篇文章时，它是Docker Hub上最受欢迎的版本。通过以下命令，我们正在以用户`gnschenker`运行该应用程序；密码为`top-secret`；该用户启用了`sudo`；并且使用自签名证书：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that initially, we recommend running the container in interactive mode
    so that you can follow what's happening. Once you are more familiar with the service,
    consider running it in the background with the `-d` flag. Also, note that we are
    mounting the `~/dev` folder from the host to the `/usr/src/dev` folder inside
    the container. This is useful if we want to remotely edit code that we have, for
    example, cloned from GitHub into the `~/dev` folder.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，最初我们建议以交互模式运行容器，以便你可以观察到发生了什么。一旦你更熟悉该服务，可以考虑使用`-d`标志在后台运行它。同时，请注意，我们将主机的`~/dev`文件夹挂载到容器内的`/usr/src/dev`文件夹。这对于远程编辑我们在`~/dev`文件夹中从GitHub克隆的代码非常有用。
- en: Also, notice that we are mapping port `4200` of Shell in a Box to host port
    `4200`. This is the port over which we will be able to access the shell using
    a browser and HTTPS. Hence, you need to open port `4200` for ingress on your VM.
    As a protocol, select TCP.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，我们将Shell in a Box的`4200`端口映射到主机的`4200`端口。我们将通过这个端口使用浏览器和HTTPS访问Shell。因此，你需要在虚拟机上为流量打开`4200`端口。请选择TCP协议。
- en: 'Once the container is running and you have opened port `4200` for ingress,
    open a new browser window and navigate to `https://<public-IP>:4200`, where `<public-IP>`
    is the public IP address of your VM. Since we''re using a self-signed certificate,
    you will be greeted with a warning,here shown when using Firefox:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦容器启动，并且你已为流量打开了`4200`端口，打开一个新的浏览器窗口，访问`https://<public-IP>:4200`，其中`<public-IP>`是你的虚拟机的公共IP地址。由于我们使用的是自签名证书，你将看到一个警告，下面是使用Firefox时的显示：
- en: '![](img/110c91ea-409e-47e7-b670-c5ab08fda9ba.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/110c91ea-409e-47e7-b670-c5ab08fda9ba.png)'
- en: Browser warning due to the use of self-signed certificates
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 由于使用了自签名证书，浏览器会显示警告
- en: 'In our case, this is not a problem; we know the cause—it''s the self-signed
    certificate. Hence, click the **Advanced...** button and then Accept Risk and
    Continue. Now, you will be redirected to the login screen. Log in with your username
    and password:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的情况下，这不是问题；我们知道原因——它是自签名证书。因此，点击**高级...**按钮，然后选择接受风险并继续。现在，你将被重定向到登录页面。使用你的用户名和密码登录：
- en: '![](img/6758f0cc-3405-4ede-b37e-8a0f2930a147.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6758f0cc-3405-4ede-b37e-8a0f2930a147.png)'
- en: Log in to the remote VM from your browser using HTTPS
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 使用HTTPS通过浏览器登录远程虚拟机
- en: We are logged in to the **Shell in a Box** application running on our remote
    VM, using the HTTPS protocol.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已通过HTTPS协议登录到在远程虚拟机上运行的**Shell in a Box**应用程序。
- en: 'Now, we have full access to, for example, the files and folder mapped from
    the host VM to `/usr/src/dev`. We can, for example, use the `vi` text editor to
    create and edit files, although we have to first install vi with this:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们完全可以访问，例如，从主机虚拟机映射到`/usr/src/dev`的文件和文件夹。我们可以使用`vi`文本编辑器来创建和编辑文件，尽管我们需要先通过以下命令安装vi：
- en: '[PRE33]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The possibilities are nearly endless. Please experiment with this setup.For
    example, run the Shell in a Box container with the Docker socket mounted, install
    Docker inside the container, and then try to use the Docker CLI from within the
    container. It is really cool because you can do all of this from within your browser!
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能性几乎是无穷无尽的。请尝试使用这个设置。例如，可以运行带有Docker套接字挂载的Shell in a Box容器，在容器内安装Docker，然后尝试从容器内使用Docker
    CLI。这真的很酷，因为你可以通过浏览器完成所有这些操作！
- en: If you intend to use this Shell in a Box container often and need some additional
    software installed, do not hesitate to create your own custom Docker image inheriting
    from `sspreitzer/shellinabox`.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你打算经常使用这个Shell in a Box容器，并且需要安装一些额外的软件，别犹豫，创建一个继承自`sspreitzer/shellinabox`的自定义Docker镜像吧。
- en: Next, we will see how to run your development environment inside a container.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在容器内运行你的开发环境。
- en: Running your development environment inside a container
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内运行你的开发环境
- en: Imagine that you only have access to a workstation with Docker for Desktop installed,
    but no possibility to add or change anything else on this workstation. Now you
    want to do some proof of concepts and code some sample application using Python.
    Unfortunately, Python is not installed on your computer. What can you do? What
    if you could run a whole development environment inside a container, including
    code editor and debugger? What if, at the same time, you could still have your
    code files on your host machine?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只有一台安装了Docker for Desktop的工作站，但无法对这台工作站进行任何其他修改或安装软件。现在，你想做一些概念验证，并使用Python编写一个示例应用程序。不幸的是，你的电脑上没有安装Python。你该怎么办？如果你可以在一个容器内运行完整的开发环境，包括代码编辑器和调试器呢？而且，同时你还能将代码文件保存在主机上呢？
- en: Containers are awesome and genius engineers have come up with solutions for
    exactly this kind of problem.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是非常强大的，聪明的工程师们为这种问题设计了完美的解决方案。
- en: 'Let''s try this for a Python application:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试这个 Python 应用：
- en: 'We will be using Visual Studio Code, our favorite code editor, to show how
    to run a complete Python development environment inside a container. But first,
    we need to install the necessary Visual Studio Code extension. Open Visual StudioCode
    and install the extension called Remote Development:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 Visual Studio Code——我们最喜欢的代码编辑器——来展示如何在容器内运行完整的 Python 开发环境。不过，首先我们需要安装必要的
    Visual Studio Code 扩展。打开 Visual Studio Code 并安装名为 Remote Development 的扩展：
- en: '![](img/9cd9233c-6976-4204-b2ed-9a00693a4547.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9cd9233c-6976-4204-b2ed-9a00693a4547.png)'
- en: Remote Development extension for Visual Studio Code
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 的远程开发扩展
- en: 'Then, click the green quick actions status bar item in the lower-left of the
    Visual Studio Code window. In the popup, select **Remote-Containers: Open Folder
    in Container...**:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，点击 Visual Studio Code 窗口左下角绿色的快速操作状态栏项。在弹出的菜单中，选择 **Remote-Containers: Open
    Folder in Container...**：'
- en: '![](img/32c52f7a-da9f-4d2f-b82c-14343336162d.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/32c52f7a-da9f-4d2f-b82c-14343336162d.png)'
- en: Opening a project in a remote container
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程容器中打开项目
- en: 'Select the project folder you want to work with in the container. In our case,
    we selected the `~/fod/ch08/remote-app` folder. Visual StudioCode will start preparing
    the environment, which, the very first time, can take a couple of minutes or so.
    You will see a message like this while this is happening:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中选择你想要工作的项目文件夹。在我们的例子中，我们选择了 `~/fod/ch08/remote-app` 文件夹。Visual Studio Code
    将开始准备环境，而第一次准备时可能需要几分钟时间。你会看到类似如下的消息：
- en: '![](img/00fddd11-d359-4cae-8003-bf8206513e2c.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00fddd11-d359-4cae-8003-bf8206513e2c.png)'
- en: Visual Studio Code preparing the development container
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio Code 准备开发容器
- en: 'By default, this development container runs as a non-root user—called `python`
    in our case. We learned, in a prior section, that this is a highly recommended
    best practice. You can change though, and run as `root` by commenting out the
    line with `"runArgs": [ "-u", "python" ],` in the `.devcontainer/devcontainer.json` file.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '默认情况下，这个开发容器以非 root 用户身份运行——在我们的例子中是 `python` 用户。我们在前一部分学到，这是一种强烈推荐的最佳实践。不过，你也可以修改配置，以
    `root` 用户身份运行，方法是注释掉 `.devcontainer/devcontainer.json` 文件中的这一行：`"runArgs": [ "-u",
    "python" ],`。'
- en: 'Open a Terminal inside Visual Studio Code with *Shift* + *Ctrl* + *` *and run
    the Flask app with the `env FLASK_APP=main.py flask run` command. You should see
    output like this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio Code 中，按 *Shift* + *Ctrl* + *`* 打开终端，并使用 `env FLASK_APP=main.py
    flask run` 命令运行 Flask 应用。你应该会看到类似如下的输出：
- en: '![](img/d410a8ba-00c4-4722-a958-fba0fff9fcda.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d410a8ba-00c4-4722-a958-fba0fff9fcda.png)'
- en: Starting a Python Flask app from Visual Studio Code running inside a container
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行 Visual Studio Code 中的 Python Flask 应用
- en: The `python@df86dceaed3d:/workspaces/remote-app$` prompt indicates that we are
    **not** running directly on our Docker host but from within a development container
    that Visual Studio Code spun up for us. The remote part of Visual Studio Code
    itself also runs inside that container. Only the client part of Visual Studio
    Code—the UI—continues to run on our host.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`python@df86dceaed3d:/workspaces/remote-app$` 提示符表示我们**并没有**直接在 Docker 主机上运行，而是从
    Visual Studio Code 为我们启动的开发容器内运行。Visual Studio Code 的远程部分本身也运行在该容器内，只有 Visual
    Studio Code 的客户端部分——即用户界面——继续在主机上运行。'
- en: 'Open another Terminal window inside Visual Studio Code by pressing *Shift+Ctrl+`*.
    Then, use `curl` to test the application:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Shift+Ctrl+`* 打开另一个终端窗口，然后使用 `curl` 测试应用：
- en: '![](img/6fb04349-0556-43fa-a13b-bc21d70cfe9f.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6fb04349-0556-43fa-a13b-bc21d70cfe9f.png)'
- en: Testing the remote Flask app
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 测试远程 Flask 应用
- en: Press *Ctrl* + *C* to stop the Flask application.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *C* 停止 Flask 应用。
- en: We can also debug the application like we're used when working directly on the
    host. Open the `.vscode/launch.json` file to understand how the Flask app is started
    and how the debugger is attached.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以像在主机上工作时一样调试应用。打开 `.vscode/launch.json` 文件，了解 Flask 应用是如何启动的以及调试器是如何附加的。
- en: Open the `main.py` file and set a breakpoint on the `return` statement of the
    `home()` function.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `main.py` 文件，并在 `home()` 函数的 `return` 语句处设置断点。
- en: 'Then, switch to the Debug view of Visual Studio Code and make sure the launch
    task, `Python: Flask`, is selected in the drop-down menu.'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '然后，切换到 Visual Studio Code 的调试视图，并确保下拉菜单中选择了启动任务 `Python: Flask`。'
- en: 'Next, press the green start arrow to start debugging. The output in the Terminal
    should look like this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按绿色的启动箭头开始调试。终端中的输出应该像这样：
- en: '![](img/63424e41-5a80-476c-8a90-0415284ac839.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63424e41-5a80-476c-8a90-0415284ac839.png)'
- en: Start debugging a remote app running in a container
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 开始调试在容器中运行的远程应用程序
- en: 'Open another Terminal with *Shift* + *Ctrl* + *`* and test the application
    by running the `curl localhost:9000/` command. The debugger should hit the breakpoint
    and you can start analyzing:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开另一个终端，按 *Shift* + *Ctrl* + *`* 并通过运行 `curl localhost:9000/` 命令来测试应用程序。调试器应该会命中断点，你可以开始分析：
- en: '![](img/8d6e30fd-ec53-4dce-ae48-d9ec94e1d718.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d6e30fd-ec53-4dce-ae48-d9ec94e1d718.png)'
- en: Line-by-line debugging in Visual Studio Code running inside a container
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行的 Visual Studio Code 中逐行调试
- en: I cannot say strongly enough how cool that is. The backend (non-UI part) of
    Visual Studio Code is running inside a container, as is Python, the Python debugger,
    and the Python Flask application itself. At the same time, the source code is
    mounted from the host into the container and the UI part of Visual Studio Code
    also runs on the host. This opens up unlimited possibilities for developers even
    on the most restricted workstations. You can do the same for all popular languages
    and frameworks, such as .NET, C#, Java, Go, Node.js, and Ruby. If one language
    is not supported out of the box, you can craft your own development container
    that will then work the same way as what we have shown with Python.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我不能过于强调这有多酷。Visual Studio Code 的后台（非 UI 部分）在容器内运行，Python、Python 调试器和 Python
    Flask 应用程序本身也是如此。同时，源代码从主机挂载到容器中，Visual Studio Code 的 UI 部分也运行在主机上。这为开发人员在最受限的工作站上打开了无限的可能性。你可以对所有流行的编程语言和框架做同样的操作，例如
    .NET、C#、Java、Go、Node.js 和 Ruby。如果某种语言默认不支持，你可以自己创建一个开发容器，这样就能像我们展示的 Python 一样工作。
- en: What if you are working on a workstation that does not have Docker for Desktop
    installed and is locked down even further? What are your options there?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用没有安装 Docker Desktop 的工作站，并且该工作站的权限更加严格，你有哪些选择？
- en: Running your code editor in a remote container and accessing it via HTTPS
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在远程容器中运行代码编辑器并通过 HTTPS 访问
- en: 'In this section, we will show how you can use Visual Studio Code to enable
    remote development inside a container. This is interesting when you are limited
    in what you can run on your workstation. Let''s follow these steps:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将展示如何使用 Visual Studio Code 在容器内启用远程开发。当你在工作站上有限制时，这会非常有用。让我们按照以下步骤操作：
- en: 'Download and extract the latest version of `code-server`. You can find out
    the URL by navigating to [https://github.com/cdr/code-server/releases/latest](https://github.com/cdr/code-server/releases/latest).
    At the time of writing, it is `1.1156-vsc1.33.1`:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载并解压最新版本的 `code-server`。你可以通过访问 [https://github.com/cdr/code-server/releases/latest](https://github.com/cdr/code-server/releases/latest)
    来查找 URL。写本文时，版本是 `1.1156-vsc1.33.1`：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Make sure to replace `<version>` with your specific version.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将`<version>`替换为你特定的版本。
- en: 'Navigate to the folder with the extracted binary, make it executable, and start
    it:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到解压后的二进制文件所在文件夹，使其可执行，并启动它：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The output should look similar to this:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该类似于以下内容：
- en: '![](img/ea928591-0b62-4b04-9281-7d2ac4e551b7.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea928591-0b62-4b04-9281-7d2ac4e551b7.png)'
- en: Starting Visual Studio Code remote-server on a remote VM
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在远程虚拟机上启动 Visual Studio Code 远程服务器
- en: Code Server is using self-signed certificates to secure communication, so we
    can access it over HTTPS. Please make sure you note down the `Password` output
    on the screen since you need it when accessing Code Server from within your browser.
    Also note that we are using port `4200` to expose Code Server on the host, the
    reason being that we already opened that port for ingress on our VM. You can,
    of course, select any port you want—just make sure you open it for ingress.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: Code Server 使用自签名证书来确保通信安全，因此我们可以通过 HTTPS 访问它。请确保记下屏幕上的 `Password` 输出，因为你在通过浏览器访问
    Code Server 时需要它。还要注意，我们使用端口 `4200` 来在主机上公开 Code Server，原因是我们已经为虚拟机打开了该端口。你当然可以选择任何端口，只需确保为该端口开放入口流量。
- en: 'Open a new browser page and navigate to `https://<public IP>:4200` ,where `<public
    IP>` is the public IP address of your VM. Since we are using self-signed certificates
    once again, the browser will greet you with a warning similar to what happened
    when we were using Shell in a Box earlier in this chapter. Accept the warning
    and you will be redirected to the login page of Code Server:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开一个新的浏览器页面，访问 `https://<public IP>:4200`，其中 `<public IP>` 是你虚拟机的公共 IP 地址。由于我们再次使用了自签名证书，浏览器会显示类似于本章前面使用
    Shell in a Box 时的警告。接受该警告后，你将被重定向到 Code Server 的登录页面：
- en: '![](img/d465a2e6-484a-44ef-98e5-f2a793ed4f9e.png)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d465a2e6-484a-44ef-98e5-f2a793ed4f9e.png)'
- en: Login page of Code Server
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: Code Server 的登录页面
- en: 'Enter the password that you noted down before and click ENTER IDE. Now you
    will be able to use Visual Studio Code remotely via your browser over a secure
    HTTPS connection:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入你之前记下的密码并点击 ENTER IDE。现在你可以通过浏览器远程使用 Visual Studio Code，连接是安全的 HTTPS 连接：
- en: '![](img/119fd2f9-696d-40d1-a25c-8292f546b98e.png)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![](img/119fd2f9-696d-40d1-a25c-8292f546b98e.png)'
- en: Visual Studio Code running in the browser over HTTPS
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中通过 HTTPS 运行的 Visual Studio Code
- en: Now you can do your development from, for example, a Chrome Book or a locked-down
    workstation, without restrictions. But wait a minute, you may say now! What does
    this have to do with containers? You're right—so far, there are no containers
    involved. I could say, though, that if your remote VM has Docker installed, you
    can use Code Server to do any container-specific development, and I would have
    saved the day. But that would be a cheap answer.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以从任何地方进行开发，例如使用 Chromebook 或受限的工作站，毫无任何限制。但等一下，你现在可能会问！这和容器有什么关系？你说得对——到目前为止，确实没有涉及容器。不过，我可以说，如果你的远程虚拟机已安装
    Docker，那么你可以使用 Code Server 进行任何与容器相关的开发，那样我就能解决问题了。但那样回答会太简单了。
- en: 'Let''s run Code Server itself in a container. That should be easy, shouldn''t
    it? Try using this command, which maps the internal port `8080` to the host port
    `4200` and mounts host folders containing Code Server settings and possibly your
    projects into the container:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在容器中运行 Code Server。这个应该不难吧？尝试使用这个命令，将内部端口`8080`映射到主机端口`4200`，并将包含 Code Server
    设置和可能的项目的主机文件夹挂载到容器中：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note, the preceding command runs Code Server in insecure mode as indicated
    in the output:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令在输出中显示 Code Server 以不安全模式运行：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'You can now access Visual Studio Code in your browser at `http://<public IP>:4200`.
    Please note the `HTTP` in the URL instead of `HTTPS`! Similarly to when running
    Code Server natively on the remote VM, you can now use Visual Studio Code from
    within your browser:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以通过浏览器访问 Visual Studio Code，网址为`http://<public IP>:4200`。请注意网址中的`HTTP`，而不是`HTTPS`！类似于在远程虚拟机上本地运行
    Code Server，你现在可以直接在浏览器中使用 Visual Studio Code：
- en: '![](img/c7e66138-3253-4388-a724-f50fe7f064fc.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c7e66138-3253-4388-a724-f50fe7f064fc.png)'
- en: Developing within your browser
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中进行开发
- en: With this, I hope you have got a feel for the near-unlimited possibilities that
    the use of containers offers to you.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个，希望你已经感受到容器的使用为你提供的几乎无限的可能性。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have shown a few tips and tricks for the advanced Docker
    user that can make your life much more productive. We have also shown how you
    can leverage containers to serve whole development environments that run on remote
    servers and can be accessed from within a browser over a secure HTTPS connection.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了一些高级 Docker 用户的技巧和窍门，可以让你的工作更加高效。我们还展示了如何利用容器提供整套开发环境，这些环境运行在远程服务器上，并且可以通过安全的
    HTTPS 连接从浏览器中访问。
- en: In the next chapter, we will introduce the concept of a distributed application
    architecture and discuss the various patterns and best practices that are required
    to run a distributed application successfully. In addition to that, we will list
    some of the concerns that need to be fulfilled to run such an application in production
    or a production-like environment.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍分布式应用架构的概念，并讨论成功运行分布式应用所需的各种模式和最佳实践。此外，我们还将列出在生产环境或类似生产环境中运行此类应用所需满足的一些关切。
- en: Questions
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name the reasons why you would want to run a complete development environment
    inside a container.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出你希望将完整的开发环境运行在容器中的原因。
- en: Why should you avoid to run applications inside a container as `root`?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你应该避免以 `root` 用户身份在容器内运行应用程序？
- en: Why would you ever bind-mount the Docker socket into a container?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会将 Docker 套接字绑定挂载到容器中？
- en: When pruning your Docker resources to make space, why do you need to handle
    volumes with special care?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你清理 Docker 资源以释放空间时，为什么需要特别小心地处理卷？
- en: Further reading
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: Using Docker in Docker at [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 中的 Docker，参考[http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
- en: Shell in a Box at [https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Shell in a Box，参考[https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox)
- en: Remote development using SSH at [https://code.visualstudio.com/docs/remote/ssh](https://code.visualstudio.com/docs/remote/ssh)
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SSH 进行远程开发，详情请见[https://code.visualstudio.com/docs/remote/ssh](https://code.visualstudio.com/docs/remote/ssh)
- en: Developing inside a container at [https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内进行开发，详情请见[https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)
