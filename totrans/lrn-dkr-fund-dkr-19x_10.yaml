- en: Advanced Docker Usage Scenarios
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last chapter, we showed you how you can use tools to perform administrative
    tasks without having to install those tools on the host computer. We also illustrated
    the use of containers that host and run test scripts or code used to test and
    validate application services running in containers. Finally, we guided you through
    the task of building a simple Docker-based CI/CD pipeline using Jenkins as the
    automation server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce advanced tips, tricks, and concepts that
    are useful when containerizing complex distributed applications, or when using
    Docker to automate sophisticated tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a quick overview of all of the subjects we are going to touch on in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: All of the tips and tricks of a Docker pro
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your Terminal in a remote container and accessing it via HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your development environment inside a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your code editor in a remote container and accessing it via HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After finishing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Successfully restore your Docker environment after it has been messed up completely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a remote Terminal in a container and access it with your browser via HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit code remotely with Visual Studio Code with your browser via HTTPS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, if you want to follow along with the code, you need Docker
    for Desktop on your Mac or Windows machine and the Visual Studio Code editor.
    The example will also work on a Linux machine with Docker and Visual Studio Code
    installed. Docker Toolbox is not supported in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: All of the tips and tricks of a Docker pro
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I will present a few very useful tips and tricks that make
    the lives of advanced Docker users so much easier. We will start with some guidance
    on how to keep your Docker environment clean.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your Docker environment clean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we want to learn how we can delete dangling images. According to Docker,
    dangling images are layers that have no relationship to any tagged images. Such
    image layers are certainly useless to us and can quickly fill up our disk—it''s
    better to remove them from time to time. Here is the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Please note that I have added the `-f` parameter to the `prune` command. This
    is to prevent the CLI from asking for a confirmation that we really want to delete
    those superfluous layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stopped containers can waste precious resources too. If you''re sure that you
    don''t need these containers anymore, then you should remove them, either individually
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, you can remove them as a batch with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is worth mentioning once again that, instead of `<container-id>`, we can
    also use `<container-name>` to identify a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unused Docker volumes too can quickly fill up disk space. It is a good practice
    to tender your volumes, specifically in a development or CI environment where
    you create a lot of mostly temporary volumes. But I have to warn you, Docker volumes
    are meant to store data. Often, this data must live longer than the life cycle
    of a container. This is specifically true in a production or production-like environment
    where the data is often mission-critical. Hence, be 100% sure of what you''re
    doing when using the following command to prune volumes on your Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: I recommend using this command without the `-f` (or `--force`) flag. It is a
    dangerous and terminal operation and it's better to give yourself a second chance
    to reconsider your action. Without the flag, the CLI outputs the warning you see
    in the preceding. You have to explicitly confirm by typing `y` and pressing the
    *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'On production or production-like systems, you should abstain from the preceding
    command and rather delete unwanted volumes one at a time by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: I should also mention that there is a command to prune Docker networks. But
    since we have not yet officially introduced networks, I will defer this to [chapter
    10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *Single-Host Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to show how we can automate Docker from within
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, we may want to run a container hosting an application that automates
    certain Docker tasks. How can we do that? The Docker Engine and the Docker CLI
    are installed on the host, yet the application runs inside the container. Well,
    from early on, Docker has provided a means to bind-mount Linux sockets from the
    host into the container. On Linux, sockets are used as very efficient data communications
    endpoints between processes that run on the same host. The Docker CLI uses a socket
    to communicate with the Docker Engine; it is often called the Docker socket. If
    we can give access to the Docker socket to an application running inside a container
    then we can just install the Docker CLI inside this container, and we will then
    be able to run an application in the same container that uses this locally installed
    Docker CLI to automate container-specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that here we are not talking about running the Docker
    Engine inside the container but rather only the Docker CLI and bind-mount the
    Docker socket from the host into the container so that the CLI can communicate
    with the Docker Engine running on the host computer. This is an important distinction.
    Running the Docker Engine inside a container, although possible, is not recommended.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we have the following script, called `pipeline.sh`, automating
    the building, testing, and pushing of a Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we're using four environment variables: `$HUB_USER` and `$HUB_PWD`
    being the credentials for Docker Hub and `$REPOSITORY` and `$TAG` being the name
    and tag of the Docker image we want to build. Eventually, we will have to pass
    values for those environment variables in the `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to run that script inside a builder container. Since the script uses
    the Docker CLI, our builder container must have the Docker CLI installed, and
    to access the Docker Engine, the builder container must have the Docker socket
    bind-mounted. Let''s start creating a Docker image for such a builder container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `builder` folder and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside this folder, create a `Dockerfile` that looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now create a `pipeline.sh` file in the `builder` folder and add as content the
    pipeline script we have presented in the preceding file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Save and make the file an executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Building an image is straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now ready to try `builder` out with a real Node.js application, for
    example, the sample app we defined in the `ch08/sample-app` folder. Make sure
    you replace `<user>` and `<password>` with your own credentials for Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how, in the preceding command, we mounted the Docker socket into the
    container with `-v /var/run/docker.sock:/var/run/docker.sock`. If everything goes
    well, you should have a container image built for the sample application, the
    test should have been run, and the image should have been pushed to Docker Hub.
    This is only one of the many use cases where it is very useful to be able to bind-mount
    the Docker socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special notice to all those of you who want to try Windows containers. On
    Docker for Windows, you can create a similar environment by bind-mounting Docker''s **named
    pipe** instead of a socket. A named pipe on Windows is roughly the same as a socket
    on a Unix-based system. Assuming you''re using a PowerShell Terminal, the command
    to bind-mount a named pipe when running a Windows container hosting Jenkins looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '``**PS>** **docker container run `** **--name jenkins `** **-p 8080:8080 `**
    **-v \\.\pipe\docker_engine:\\.\pipe\docker_engine ` friism/jenkins**``'
  prefs: []
  type: TYPE_NORMAL
- en: Note the special syntax, `\\.\pipe\docker_engine`, to access Docker's named
    pipe.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting the output of common Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Have you at times wished that your Terminal window was infinitely wide since
    the output of a Docker command such as `docker container ps` is scrambled across
    several lines per item? Worry not, as you can customize the output to your liking.
    Almost all commands that produce an output have a `--format` argument, which accepts
    a so-called Go template as a parameter. If you wonder why a Go template, it''s
    because most of Docker is written in this popular low-level language. Let''s look
    at an example. Assume we want to only show the name of the container, the name
    of the image, and the state of the container, separated by tabs, output by the
    `docker container ps` command. The format would then look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Please be aware that the `format` string is case sensitive. Also, note the
    addition of the `-a` parameter to include stopped containers in the output. A
    sample output could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is definitely nicer to display even on a narrow Terminal window than the
    unformatted one scattering wildly over multiple lines.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering the output of common Docker commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to what we have done in the previous section by pretty-printing the
    output of Docker commands, we can also filter what is output. There are quite
    a few filters that are supported. Please find the full list for each command in
    the Docker online documentation. The format of filters is straightforward and
    of the type `--filter <key>=<value>`. If we need to combine more than one filter,
    we can just combine multiple of these statements. Let''s do an example with the
    `docker image ls` command as I have a lot of images on my workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding filter only outputs images that are not dangling, that is, real
    images whose fully qualified name is of the form `<registry>/<user|org><repository>:<tag>`,
    and the tag is equal to `latest`. The output on my machine looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Having shown how to pretty print and filter output generated by the Docker CLI,
    it is now time to talk once more about building Docker images and how to optimize
    this process.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Many Docker beginners make the following mistake when crafting their first
    `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Can you spot the weak point in this typical `Dockerfile` for a Node.js application?
    In [Chapter 4](527543ae-a569-47dc-975d-65c96d0f6ff0.xhtml), *Creating and Managing
    Container Images*, we have learned that an image consists of a series of layers.
    Each (logical) line in a `Dockerfile` creates a layer, except the lines with the
    `CMD` and/or `ENTRYPOINT` keyword. We have also learned that the Docker builder
    tries to do its best by caching layers and reusing them if they have not changed
    between subsequent builds. But the caching only uses cached layers that occur
    before the first changed layer. All subsequent layers need to be rebuilt. That
    said, the preceding structure of the `Dockerfile` busts the image layer cache!
  prefs: []
  type: TYPE_NORMAL
- en: 'Why? Well, from experience, you certainly know that `npm install` can be a
    pretty expensive operation in a typical Node.js application with many external
    dependencies. The execution of this command can take from seconds to many minutes.
    That said, each time one of the source files changes, and we know that happens
    frequently during development, line 3 in the `Dockerfile` causes the corresponding
    image layer to change. Hence, the Docker builder cannot reuse this layer from
    cache, nor can it reuse the subsequent layer created by `RUN npm install`. Any
    minor change in code causes a complete rerun of `npm install`. That can be avoided.
    The `package.json` file containing the list of external dependencies rarely changes.
    With all of that information, let''s fix the `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This time, on line 3, we only copy the `package.json` file into the container,
    which rarely changes. Hence, the subsequent `npm install` command has to be executed
    equally rarely. The `COPY` command on line 5 then is a very fast operation and
    hence rebuilding an image after some code has changed only needs to rebuild this
    last layer. Build times reduce to merely a fraction of a second.
  prefs: []
  type: TYPE_NORMAL
- en: The very same principle applies to most languages or frameworks, such as Python,
    .NET, or Java. Avoid busting your image layer cache!
  prefs: []
  type: TYPE_NORMAL
- en: Limiting resources consumed by a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great features of a container, apart from encapsulating application
    processes, is the possibility of limiting the resources a single container can
    consume at. This includes CPU and memory consumption. Let''s have a look at how
    limiting the amount of memory (RAM) works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the container, install the `stress` tool, which we will use to
    simulate memory pressure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another Terminal window and execute the `docker stats` command. You should
    see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a674500-7732-44f7-98fd-a13d1aa38450.png)'
  prefs: []
  type: TYPE_IMG
- en: docker stats showing a resource-limited container
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at  `MEM USAGE` and `LIMIT`. Currently, the container uses only `1.87MiB` memory
    and has a limit of `512MB`. The latter corresponds to what we have configured
    for this container. Now, let''s use `stress` to simulate four workers, which try
    to `malloc()` memory in blocks of `256MB`. Run this command inside the container
    to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In the Terminal running Docker stats, observe how the value for `MEM USAGE`
    approaches but never exceeds `LIMIT`. This is exactly the behavior we expected
    from Docker. Docker uses Linux `cgroups` to enforce those limits.
  prefs: []
  type: TYPE_NORMAL
- en: We could similarly limit the amount of CPU a container can consume with the
    `--cpu` switch.
  prefs: []
  type: TYPE_NORMAL
- en: With this operation, engineers can avoid the noisy neighbor problem on a busy
    Docker host, where a single container starves all of the others by consuming an
    excessive amount of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Read-only filesystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To protect your applications against malicious hacker attacks, it is often
    advised to define the filesystem of the container or part of it as read-only.
    This makes the most sense for stateless services. Assume that you have a billing
    service running in a container as part of your distributed, mission-critical application.
    You could run your billing service as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--read-only` flag mounts the container''s filesystem as read-only. If
    a hacker succeeds in entering your billing container and tries to change an application
    maliciously by, say, replacing one of the binaries with a compromised one, then
    this operation would fail. We can easily demonstrate that with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The first command runs a container with a read-only filesystem and the second
    command tries to execute another process in this container, which is supposed
    to write something to the filesystem—in this case, a simple text file. This fails,
    as we can see in the preceding output, with the error message `Read-only file
    system`.
  prefs: []
  type: TYPE_NORMAL
- en: Another means to tighten the security of your applications running in containers
    is to avoid running them as `root`.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid running a containerized app as root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications or application services that run inside a container do not
    need root access. To tighten security, it is helpful in those scenarios to run
    these processes with minimal necessary privileges. These applications should not
    be run as `root` nor assume that they have `root`-level privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, let''s illustrate what we mean with an example. Assume we have
    a file with top-secret content. We want to secure this file on our Unix-based
    system using the `chmod` tool so that only users with root permission can access
    it. Let''s assume I am logged in as `gabriel` on the `dev` host and hence my prompt
    is `gabriel@dev $`. I can use `sudo su` to impersonate a superuser. I have to
    enter the superuser password though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as the `root` user, I can create this file called `top-secret.txt` and
    secure it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If I try to access the file as `gabriel`, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'I get `Permission denied`, which is what we wanted. No other user except `root`
    can access this file. Now, let''s build a Docker image that contains this secured
    file and when a container is created from it, tries to output its content. The
    `Dockerfile` could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build an image from that Dockerfile (as `root`!) with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, when running a container from that image we get:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so although I am impersonating the `gabriel` user on the host and running
    the container under this user account, the application running inside the container
    automatically runs as `root`, and hence has full access to protected resources.
    That''s bad, so let''s fix it! Instead of running with the default, we define
    an explicit user inside the container. The modified `Dockerfile` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use the `groupadd` tool to define a new group, `demo-group`, with the ID
    `3000`. Then, we use the `useradd` tool to add a new user, `demo-user`, to this
    group. The user has the ID `4000` inside the container. Finally, with the `USER
    demo-user` statement, we declare that all subsequent operations should be executed
    as `demo-user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild the image—again as `root`—and then try to run a container from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And as you can see on the last line, the application running inside the container
    runs with restricted permissions and cannot access resources that need root-level
    access. By the way, what do you think would happen if I ran the container as `root`?
    Try it out!
  prefs: []
  type: TYPE_NORMAL
- en: These have been a few tips and tricks for pros that are useful in the day-to-day
    usage of containers. There are many more. Google them. It is worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Running your Terminal in a remote container and accessing it via HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are situations where you need to access a remote server and only have
    the option to use a browser for that. Your laptop may be locked down by your employer
    so that you are not allowed to, for example, `ssh` into a server outside of the
    company's domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this scenario proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a free account on Microsoft Azure, GCP, or AWS. Then, create a VM, preferably
    with Ubuntu 18.04 or higher as the operating system, to follow along more easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once your VM is ready, SSH into it. The command to do so should look similar
    to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: To get access, you may need to open port `22` for ingress first for the VM.
  prefs: []
  type: TYPE_NORMAL
- en: The user I have defined during the provisioning of the VM is `gnschenker` and
    the public IP address of my VM is `40.115.4.249`.
  prefs: []
  type: TYPE_NORMAL
- en: Install Docker on this VM using the description found here: [https://docs.docker.com/install/linux/docker-ce/ubuntu/](https://docs.docker.com/install/linux/docker-ce/ubuntu/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On a special note, do not forget to add your user (`gnschenker`, in my case)
    to the `docker` group on the VM with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: With this, you avoid having to constantly use `sudo` for all Docker commands.
    You need to log out from and log in to the VM to make this change work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to run **Shell in a Box** ([https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox))
    in a container on the VM. There are quite a few people who have containerized
    Shell in a Box. We are using the Docker image, `sspreitzer/shellinabox`. At the
    time of writing, it is the most popular version by far on Docker Hub. With the
    following command, we are running the application with a user, `gnschenker`; password, `top-secret`;
    `sudo` for the user enabled; and with self-signed certificates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that initially, we recommend running the container in interactive mode
    so that you can follow what's happening. Once you are more familiar with the service,
    consider running it in the background with the `-d` flag. Also, note that we are
    mounting the `~/dev` folder from the host to the `/usr/src/dev` folder inside
    the container. This is useful if we want to remotely edit code that we have, for
    example, cloned from GitHub into the `~/dev` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Also, notice that we are mapping port `4200` of Shell in a Box to host port
    `4200`. This is the port over which we will be able to access the shell using
    a browser and HTTPS. Hence, you need to open port `4200` for ingress on your VM.
    As a protocol, select TCP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the container is running and you have opened port `4200` for ingress,
    open a new browser window and navigate to `https://<public-IP>:4200`, where `<public-IP>`
    is the public IP address of your VM. Since we''re using a self-signed certificate,
    you will be greeted with a warning,here shown when using Firefox:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/110c91ea-409e-47e7-b670-c5ab08fda9ba.png)'
  prefs: []
  type: TYPE_IMG
- en: Browser warning due to the use of self-signed certificates
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, this is not a problem; we know the cause—it''s the self-signed
    certificate. Hence, click the **Advanced...** button and then Accept Risk and
    Continue. Now, you will be redirected to the login screen. Log in with your username
    and password:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6758f0cc-3405-4ede-b37e-8a0f2930a147.png)'
  prefs: []
  type: TYPE_IMG
- en: Log in to the remote VM from your browser using HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: We are logged in to the **Shell in a Box** application running on our remote
    VM, using the HTTPS protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have full access to, for example, the files and folder mapped from
    the host VM to `/usr/src/dev`. We can, for example, use the `vi` text editor to
    create and edit files, although we have to first install vi with this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The possibilities are nearly endless. Please experiment with this setup.For
    example, run the Shell in a Box container with the Docker socket mounted, install
    Docker inside the container, and then try to use the Docker CLI from within the
    container. It is really cool because you can do all of this from within your browser!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you intend to use this Shell in a Box container often and need some additional
    software installed, do not hesitate to create your own custom Docker image inheriting
    from `sspreitzer/shellinabox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we will see how to run your development environment inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: Running your development environment inside a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you only have access to a workstation with Docker for Desktop installed,
    but no possibility to add or change anything else on this workstation. Now you
    want to do some proof of concepts and code some sample application using Python.
    Unfortunately, Python is not installed on your computer. What can you do? What
    if you could run a whole development environment inside a container, including
    code editor and debugger? What if, at the same time, you could still have your
    code files on your host machine?
  prefs: []
  type: TYPE_NORMAL
- en: Containers are awesome and genius engineers have come up with solutions for
    exactly this kind of problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try this for a Python application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using Visual Studio Code, our favorite code editor, to show how
    to run a complete Python development environment inside a container. But first,
    we need to install the necessary Visual Studio Code extension. Open Visual StudioCode
    and install the extension called Remote Development:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9cd9233c-6976-4204-b2ed-9a00693a4547.png)'
  prefs: []
  type: TYPE_IMG
- en: Remote Development extension for Visual Studio Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click the green quick actions status bar item in the lower-left of the
    Visual Studio Code window. In the popup, select **Remote-Containers: Open Folder
    in Container...**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/32c52f7a-da9f-4d2f-b82c-14343336162d.png)'
  prefs: []
  type: TYPE_IMG
- en: Opening a project in a remote container
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the project folder you want to work with in the container. In our case,
    we selected the `~/fod/ch08/remote-app` folder. Visual StudioCode will start preparing
    the environment, which, the very first time, can take a couple of minutes or so.
    You will see a message like this while this is happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00fddd11-d359-4cae-8003-bf8206513e2c.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio Code preparing the development container
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, this development container runs as a non-root user—called `python`
    in our case. We learned, in a prior section, that this is a highly recommended
    best practice. You can change though, and run as `root` by commenting out the
    line with `"runArgs": [ "-u", "python" ],` in the `.devcontainer/devcontainer.json` file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal inside Visual Studio Code with *Shift* + *Ctrl* + *` *and run
    the Flask app with the `env FLASK_APP=main.py flask run` command. You should see
    output like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d410a8ba-00c4-4722-a958-fba0fff9fcda.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting a Python Flask app from Visual Studio Code running inside a container
  prefs: []
  type: TYPE_NORMAL
- en: The `python@df86dceaed3d:/workspaces/remote-app$` prompt indicates that we are
    **not** running directly on our Docker host but from within a development container
    that Visual Studio Code spun up for us. The remote part of Visual Studio Code
    itself also runs inside that container. Only the client part of Visual Studio
    Code—the UI—continues to run on our host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another Terminal window inside Visual Studio Code by pressing *Shift+Ctrl+`*.
    Then, use `curl` to test the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6fb04349-0556-43fa-a13b-bc21d70cfe9f.png)'
  prefs: []
  type: TYPE_IMG
- en: Testing the remote Flask app
  prefs: []
  type: TYPE_NORMAL
- en: Press *Ctrl* + *C* to stop the Flask application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can also debug the application like we're used when working directly on the
    host. Open the `.vscode/launch.json` file to understand how the Flask app is started
    and how the debugger is attached.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `main.py` file and set a breakpoint on the `return` statement of the
    `home()` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, switch to the Debug view of Visual Studio Code and make sure the launch
    task, `Python: Flask`, is selected in the drop-down menu.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, press the green start arrow to start debugging. The output in the Terminal
    should look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/63424e41-5a80-476c-8a90-0415284ac839.png)'
  prefs: []
  type: TYPE_IMG
- en: Start debugging a remote app running in a container
  prefs: []
  type: TYPE_NORMAL
- en: 'Open another Terminal with *Shift* + *Ctrl* + *`* and test the application
    by running the `curl localhost:9000/` command. The debugger should hit the breakpoint
    and you can start analyzing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8d6e30fd-ec53-4dce-ae48-d9ec94e1d718.png)'
  prefs: []
  type: TYPE_IMG
- en: Line-by-line debugging in Visual Studio Code running inside a container
  prefs: []
  type: TYPE_NORMAL
- en: I cannot say strongly enough how cool that is. The backend (non-UI part) of
    Visual Studio Code is running inside a container, as is Python, the Python debugger,
    and the Python Flask application itself. At the same time, the source code is
    mounted from the host into the container and the UI part of Visual Studio Code
    also runs on the host. This opens up unlimited possibilities for developers even
    on the most restricted workstations. You can do the same for all popular languages
    and frameworks, such as .NET, C#, Java, Go, Node.js, and Ruby. If one language
    is not supported out of the box, you can craft your own development container
    that will then work the same way as what we have shown with Python.
  prefs: []
  type: TYPE_NORMAL
- en: What if you are working on a workstation that does not have Docker for Desktop
    installed and is locked down even further? What are your options there?
  prefs: []
  type: TYPE_NORMAL
- en: Running your code editor in a remote container and accessing it via HTTPS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will show how you can use Visual Studio Code to enable
    remote development inside a container. This is interesting when you are limited
    in what you can run on your workstation. Let''s follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download and extract the latest version of `code-server`. You can find out
    the URL by navigating to [https://github.com/cdr/code-server/releases/latest](https://github.com/cdr/code-server/releases/latest).
    At the time of writing, it is `1.1156-vsc1.33.1`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Make sure to replace `<version>` with your specific version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the folder with the extracted binary, make it executable, and start
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ea928591-0b62-4b04-9281-7d2ac4e551b7.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting Visual Studio Code remote-server on a remote VM
  prefs: []
  type: TYPE_NORMAL
- en: Code Server is using self-signed certificates to secure communication, so we
    can access it over HTTPS. Please make sure you note down the `Password` output
    on the screen since you need it when accessing Code Server from within your browser.
    Also note that we are using port `4200` to expose Code Server on the host, the
    reason being that we already opened that port for ingress on our VM. You can,
    of course, select any port you want—just make sure you open it for ingress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new browser page and navigate to `https://<public IP>:4200` ,where `<public
    IP>` is the public IP address of your VM. Since we are using self-signed certificates
    once again, the browser will greet you with a warning similar to what happened
    when we were using Shell in a Box earlier in this chapter. Accept the warning
    and you will be redirected to the login page of Code Server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d465a2e6-484a-44ef-98e5-f2a793ed4f9e.png)'
  prefs: []
  type: TYPE_IMG
- en: Login page of Code Server
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the password that you noted down before and click ENTER IDE. Now you
    will be able to use Visual Studio Code remotely via your browser over a secure
    HTTPS connection:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/119fd2f9-696d-40d1-a25c-8292f546b98e.png)'
  prefs: []
  type: TYPE_IMG
- en: Visual Studio Code running in the browser over HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: Now you can do your development from, for example, a Chrome Book or a locked-down
    workstation, without restrictions. But wait a minute, you may say now! What does
    this have to do with containers? You're right—so far, there are no containers
    involved. I could say, though, that if your remote VM has Docker installed, you
    can use Code Server to do any container-specific development, and I would have
    saved the day. But that would be a cheap answer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s run Code Server itself in a container. That should be easy, shouldn''t
    it? Try using this command, which maps the internal port `8080` to the host port
    `4200` and mounts host folders containing Code Server settings and possibly your
    projects into the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note, the preceding command runs Code Server in insecure mode as indicated
    in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now access Visual Studio Code in your browser at `http://<public IP>:4200`.
    Please note the `HTTP` in the URL instead of `HTTPS`! Similarly to when running
    Code Server natively on the remote VM, you can now use Visual Studio Code from
    within your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c7e66138-3253-4388-a724-f50fe7f064fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Developing within your browser
  prefs: []
  type: TYPE_NORMAL
- en: With this, I hope you have got a feel for the near-unlimited possibilities that
    the use of containers offers to you.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have shown a few tips and tricks for the advanced Docker
    user that can make your life much more productive. We have also shown how you
    can leverage containers to serve whole development environments that run on remote
    servers and can be accessed from within a browser over a secure HTTPS connection.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concept of a distributed application
    architecture and discuss the various patterns and best practices that are required
    to run a distributed application successfully. In addition to that, we will list
    some of the concerns that need to be fulfilled to run such an application in production
    or a production-like environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name the reasons why you would want to run a complete development environment
    inside a container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid to run applications inside a container as `root`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you ever bind-mount the Docker socket into a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When pruning your Docker resources to make space, why do you need to handle
    volumes with special care?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Docker in Docker at [http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/](http://jpetazzo.github.io/2015/09/03/do-not-use-docker-in-docker-for-ci/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell in a Box at [https://github.com/shellinabox/shellinabox](https://github.com/shellinabox/shellinabox)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote development using SSH at [https://code.visualstudio.com/docs/remote/ssh](https://code.visualstudio.com/docs/remote/ssh)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing inside a container at [https://code.visualstudio.com/docs/remote/containers](https://code.visualstudio.com/docs/remote/containers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
