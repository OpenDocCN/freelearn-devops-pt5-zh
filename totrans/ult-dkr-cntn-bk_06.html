<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-133"><a id="_idTextAnchor130"/>6</h1>
<h1 id="_idParaDest-134"><a id="_idTextAnchor131"/>Debugging Code Running in Containers</h1>
<p>In the previous chapter, we learned how to work with stateful containers – that is, containers that consume and produce data. We also learned how to configure our containers at runtime and at image build time using environment variables and config files.</p>
<p>In this chapter, we’re going to introduce techniques commonly used to allow a developer to evolve, modify, debug, and test their code while it’s running in a container. With these techniques at hand, you will enjoy a frictionless development process for applications running in a container, similar to what you experience when developing applications that run natively.</p>
<p>Here is a list of the topics we’re going to discuss:</p>
<ul>
<li>Evolving and testing code running in a container</li>
<li>Auto-restarting code upon changes</li>
<li>Line-by-line code debugging inside a container</li>
<li>Instrumenting your code to produce meaningful logging information</li>
<li>Using Jaeger to monitor and troubleshoot</li>
</ul>
<p>After finishing this chapter, you will be able to do the following:</p>
<ul>
<li>Mount source code residing on the host in a running container</li>
<li>Configure an application running in a container to auto-restart after a code change</li>
<li>Configure <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>) to debug applications written in Java, Node.js, Python, or .NET running inside a container line by line</li>
<li>Log important events from your application code</li>
<li>Configure your multi-component application for distributed tracing using the OpenTracing standard and a tool such as Jaeger</li>
</ul>
<h1 id="_idParaDest-135"><a id="_idTextAnchor132"/>Technical requirements</h1>
<p>In this chapter, if you want to follow along with the code, you will need Docker Desktop on macOS or Windows and a code editor – preferably VS Code. The samples will also work on a Linux machine with Docker and VS Code installed.</p>
<p>To prepare your environment for the coming hands-on labs, follow these steps:</p>
<ol>
<li>Please navigate to the folder where you have cloned the sample repository to. Normally, this should be <code>~/The-Ultimate-Docker-Container-Book</code>, so do the following:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book</pre></li> <li>Create a new subfolder called <code>ch06</code> and navigate to it:<pre class="source-code">
$ mkdir ch06 &amp;&amp; cd ch06</pre></li> </ol>
<p>A complete set of sample solutions for all the examples discussed in this chapter can be found in the <code>sample-solutions/ch06</code> folder or directly on GitHub: <a href="https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06">https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch06</a>.</p>
<h1 id="_idParaDest-136"><a id="_idTextAnchor133"/>Evolving and testing code running in a container</h1>
<p>Make sure you<a id="_idIndexMarker399"/> have Node.js and <code>npm</code> installed on your computer before <a id="_idIndexMarker400"/>you continue. On Mac, use this command:</p>
<pre class="source-code">
$ brew install node</pre> <p>On Windows, use the following command:</p>
<pre class="source-code">
$ choco install -y nodejs</pre> <p>When developing code that will eventually be running in a container, the best approach is often to run the code in the container from the very beginning, to make sure there will be no surprises. But we have to do this in the right way so that we don’t introduce any unnecessary friction to our development process. First, let’s look at a naïve way we could run and test code in<a id="_idIndexMarker401"/> a container. We can do this using a basic Node.js <a id="_idIndexMarker402"/>sample application:</p>
<ol>
<li>Create a new project folder and navigate to it:<pre class="source-code">
$ mkdir node-sample &amp;&amp; cd node-sample</pre></li> <li>Let’s use <code>npm</code> to create a new Node.js project:<pre class="source-code">
$ npm init</pre></li> <li>Accept all the defaults. Notice that a <code>package.json</code> file is created with the following content:</li>
</ol>
<div><div><img alt="Figure 6.1 – Content of the package.json file of the sample Node.js application" height="551" src="img/B19199_06_01.jpg" width="878"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Content of the package.json file of the sample Node.js application</p>
<ol>
<li value="4">We want to use the <code>Express.js</code> library in our Node application; thus, use <code>npm</code> to install it:<pre class="source-code">
$ npm install express –save</pre></li> </ol>
<p>This will <a id="_idIndexMarker403"/>install the newest version of <code>Express.js</code> on<a id="_idIndexMarker404"/> our machine and, because of the <code>–save</code> parameter, add a reference to our <code>package.json</code> file that looks similar to this:</p>
<pre class="source-code">
"dependencies": {    "express": "^4.18.2"
}</pre>
<p>Note that in your case, the version number of <code>express</code> may be different.</p>
<ol>
<li value="5">Start VS Code from within this folder:<pre class="source-code">
$ code .</pre></li> <li>In VS Code, create a new file called <code>index.js</code> and add this code snippet to it. Do not forget to save:</li>
</ol>
<div><div><img alt="Figure 6.2 – Content of the index.js file of the sample Node.js application" height="425" src="img/B19199_06_02.jpg" width="877"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Content of the index.js file of the sample Node.js application</p>
<ol>
<li value="7">From within <a id="_idIndexMarker405"/>your terminal window, start the application:<pre class="source-code">
$ node index.js</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">On Windows and Mac, when you execute the preceding command for the first time, a window will pop up, asking you to approve it on the firewall.</p>
<p>You should<a id="_idIndexMarker406"/> see this as the output:</p>
<pre class="source-code">
Application listening at 0.0.0.0:3000</pre> <p>This means that the application is running and ready to listen at the <code>0.0.0.0:3000</code> endpoint.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You might be wondering what the meaning of the host address, <code>0.0.0.0</code>, is and why we have chosen it. We will come back to this later when we run the application inside a container. For the moment, just know that <code>0.0.0.0</code> is a reserved IP address with a special meaning, similar to the loopback address, <code>127.0.0.1</code>. The <code>0.0.0.0</code> address simply means all IPv4 addresses on the local machine. If a host has two IP addresses, say <code>52.11.32.13</code> and <code>10.11.0.1</code>, and a server running on the host listens on <code>0.0.0.0</code>, it will be reachable at both of those IPs.</p>
<ol>
<li value="8">Now, open a new tab in your favorite browser and navigate to <code>http://localhost:3000</code>. You should see this:</li>
</ol>
<div><div><img alt="Figure 6.3 – Sample Node.js application running in a browser" height="197" src="img/B19199_06_03.jpg" width="539"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Sample Node.js application running in a browser</p>
<p>Great – our<a id="_idIndexMarker407"/> Node.js application is running on our developer <a id="_idIndexMarker408"/>machine. Stop the application by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal.</p>
<ol>
<li value="9">Now, we want to test the application we have developed so far by running it inside a container. To do this, we must create a Dockerfile so that we can build a container image, from which we can then run a container. Let’s use VS Code again to add a file called <code>Dockerfile</code> to our project folder and give it the following content:</li>
</ol>
<div><div><img alt="Figure 6.4 – Dockerfile for the sample Node.js application" height="290" src="img/B19199_06_04.jpg" width="361"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – Dockerfile for the sample Node.js application</p>
<ol>
<li value="10">We can<a id="_idIndexMarker409"/> then use this Dockerfile to build an image called <code>sample-app</code>, as follows:<pre class="source-code">
$ docker image build -t sample-app .</pre></li> </ol>
<p>It will take a<a id="_idIndexMarker410"/> few seconds for the base image to be downloaded and your custom image to be built on top of it.</p>
<ol>
<li value="11">After building, run the application in the container with this command:<pre class="source-code">
$ docker container run --rm -it \    --name my-sample-app \    -p 3000:3000 \    sample-app</pre></li> </ol>
<p>The output will be as follows:</p>
<pre class="source-code">
Application listening at 0.0.0.0:3000</pre> <p class="callout-heading">Note</p>
<p class="callout">The preceding command runs a container called <code>my-sample-app</code> from the <code>sample-app</code> container image and maps the container’s port, <code>3000</code>, to the equivalent host port. This port mapping is necessary; otherwise, we won’t be able to access the application running inside the container from outside the container. We will learn more about port mapping in <a href="B19199_10.xhtml#_idTextAnchor218"><em class="italic">Chapter 10</em></a>, <em class="italic">Using </em><em class="italic">Single-Host Networking</em>. It is similar to when we ran the application directly on our host.</p>
<ol>
<li value="12">Refresh your<a id="_idIndexMarker411"/> previous browser tab (or open a new browser<a id="_idIndexMarker412"/> tab and navigate to <code>localhost:3000</code>, if you closed it). You should see that the application still runs and produces the same output as when running natively. This is good. We have just shown that our application not only runs on our host but also inside a container.</li>
<li>Stop and remove the container by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal.</li>
<li>Now, let’s modify our code and add some additional functionality. We will define another <code>HTTP GET</code> endpoint at <code>/hobbies</code>. Please add the following code snippet at the end of your <code>index.js</code> file:<pre class="source-code">
const hobbies = [    'Swimming', 'Diving', 'Jogging', 'Cooking', 'Singing'];app.get('/hobbies', (req,res)=&gt;{    res.send(hobbies);})</pre></li> <li>We can test the new functionality on our host by running the app with the following command:<pre class="source-code">
$ node index.js</pre></li> </ol>
<p>Then, we can navigate to <code>http://localhost:3000/hobbies</code> in our browser. We <a id="_idIndexMarker413"/>should see the expected output – a JSON array with the list of hobbies – in the browser window. Don’t forget to stop the application with <em class="italic">Ctrl</em> + <em class="italic">C</em> when you’ve finished testing.</p>
<ol>
<li value="16">Next, we <a id="_idIndexMarker414"/>need to test the code when it runs inside the container. So, first, we must create a new version of the container image:<pre class="source-code">
$ docker image build -t sample-app .</pre></li> </ol>
<p>This time, the build should be quicker than the first time we did this since the base image is already in our local cache.</p>
<ol>
<li value="17">Next, we must run a container from this new image:<pre class="source-code">
$ docker container run --rm -it \    --name my-sample-app \    -p 3000:3000 \    sample-app</pre></li> <li>Now, we can navigate to <code>http://localhost:3000/hobbies</code> in our browser and confirm that the application works as expected inside the container too.</li>
<li>Once again, don’t forget to stop the container when you’re done by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>.</li>
</ol>
<p>We can repeat this sequence of tasks over and over again for each feature we add or any existing features we improve. It turns out that this is a lot of added friction compared to times when all the applications we developed always ran directly on the host.</p>
<p>However, we can do better. In the next section, we will look at a technique that allows us to remove most of this friction.</p>
<h2 id="_idParaDest-137"><a id="_idTextAnchor134"/>Mounting evolving code into the running container</h2>
<p>What if, after a <a id="_idIndexMarker415"/>code change, we do not have to rebuild the container image and rerun a container? Wouldn’t it be great if the changes would immediately, as we save them in an editor such as VS Code, be available inside the container too? Well, that is possible with volume mapping. In the previous chapter, we learned how to map an arbitrary host folder to an arbitrary location inside a container. We want to leverage that in this section. In <a href="B19199_05.xhtml#_idTextAnchor109"><em class="italic">Chapter 5</em></a>, <em class="italic">Data Volumes and Configuration</em>, we learned how to map host folders as volumes in a container. For example, if we want to mount a host folder, <code>/projects/sample-app</code>, into a container at <code>/app</code>, the syntax for this will look as follows:</p>
<pre class="source-code">
$ docker container run --rm -it \    --volume /projects/sample-app:/app \
    alpine /bin/sh</pre>
<p>Notice the <code>--volume &lt;host-folder&gt;:&lt;container-folder&gt;</code> line. The path to the host folder needs to be an absolute path, which in this example is <code>/projects/sample-app</code>.</p>
<p>Now, if we want to run a container from our <code>sample-app</code> container image and we do that from the project folder, we can map the current folder to the <code>/app</code> folder of the container, as follows:</p>
<pre class="source-code">
$ docker container run --rm -it \    --volume $(pwd):/app \
    -p 3000:3000 \
    sample-app</pre>
<p class="callout-heading">Note</p>
<p class="callout">Please note <code>$(pwd)</code> in place of the host folder path. <code>$(pwd)</code> equals the absolute path of the current folder, which comes in very handy.</p>
<p>Now, if we use the above volume mapping parameter, then whatever was in the <code>/app</code> folder of the <code>sample-app</code> container image will be overridden by the content of the mapped host folder, which in our case is the current folder. That’s exactly what we want – we want the <a id="_idIndexMarker416"/>current source to be mapped from the host into the container. Let’s test whether it works:</p>
<ol>
<li>Stop the container if you have started it by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>.</li>
<li>Then, add the following snippet to the end of the <code>index.js</code> file:<pre class="source-code">
app.get('/status', (req,res)=&gt;{    res.send('OK');})</pre></li> </ol>
<p>Do not forget to save.</p>
<ol>
<li value="3">Then, run the container again – this time, without rebuilding the image first – to see what happens:<pre class="source-code">
$ docker container run --rm -it \    --name my-sample-app \    --volume $(pwd):/app \    -p 3000:3000 \    sample-app</pre></li> <li>In your browser, navigate to <code>http://localhost:3000/status</code>. You will see the <code>OK</code> output in your browser window. Alternatively, instead of using your browser, you could use <code>curl</code> in another terminal window to probe the <code>/status</code> endpoint, as follows:<pre class="source-code">
$ curl localhost:3000/statusOK</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">For all those working on Windows and/or Docker Desktop for Windows, you can use the PowerShell <code>Invoke-WebRequest</code> command or <code>iwr</code> for short instead of <code>curl</code>. In this case, the equivalent to the preceding command would be <code>PS&gt; iwr -</code><code>Url http://localhost:3000/status</code>.</p>
<ol>
<li value="5">Leave the application in the container running for the moment and make yet another change. Instead of just returning <code>OK</code> when navigating to <code>/status</code>, we want a message stating <code>OK, all good</code> to be returned. Make your modification and save your changes.</li>
<li>Then, execute the <code>curl</code> command again or, if you did use your browser, refresh the page. What<a id="_idIndexMarker417"/> do you see? Right – nothing happened. The change we made is not reflected in the running application.</li>
<li>Well, let’s double-check whether the change has been propagated in the running container. To do this, let’s execute the following command:<pre class="source-code">
$ docker container exec my-sample-app cat index.js</pre></li> </ol>
<p>This executes the <code>cat index.js</code> command inside our already running container. We should see something like this – I have shortened the output for readability:</p>
<pre class="source-code">
...app.get('/hobbies', (req,res)=&gt;{
    res.send(hobbies);
})
app.get('/status', (req,res)=&gt;{
    res.send('OK, all good');
})
...</pre>
<p>As we can see, our changes have been propagated into the container as expected. Why, then, are the changes not reflected in the running application? Well, the answer is simple: for changes to be applied to the application, the Node.js sample application has to be restarted.</p>
<ol>
<li value="8">Let’s try that. Stop <a id="_idIndexMarker418"/>the container with the application running by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>. Then, re-execute the preceding <code>docker container run</code> command and use <code>curl</code> to probe the <code>http://localhost:3000/status</code> endpoint. This time, the following new message should b<a href="http://localhost:3000/status">e displayed:</a><pre class="source-code">
<a href="http://localhost:3000/status">$ curl http://l</a>ocalhost:3000/statusOK, all good</pre></li> </ol>
<p>With that, we have significantly reduced the friction in the development process by mapping the source code in the running container. We can now add new codeor modify existing code and test it without having to build the container image first. However, a bit of friction has been left in play. We have to manually restart the container every time we want to test some new or modified code. Can we automate this? The answer is yes! We will demonstrate exactly this in the next section.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor135"/>Auto-restarting code upon changes</h1>
<p>In the<a id="_idIndexMarker419"/> previous section, we showed you how we can massively reduce friction by volume mapping the source code folder in the container, thus avoiding having to rebuild the container image and rerun the container over and over again. Yet we still feel some remaining friction. The application running inside the container does not automatically restart when a code change is made. Thus, we have to manually stop and restart the container to pick up these new changes.</p>
<p>In this section, we will learn how we can containerize our applications written in various languages, such as Node.js, Java, Python, and .NET, and have them restart automatically whenever a code change is detected. Let’s start with Node.js.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor136"/>Auto-restarting for Node.js</h2>
<p>If you<a id="_idIndexMarker420"/> have been coding for a while, you <a id="_idIndexMarker421"/>will certainly have heard about helpful tools that can run your applications and restart them automatically whenever they discover a change in the code base. For Node.js applications, the most popular tool is <code>nodemon</code>. Let’s take a look:</p>
<ol>
<li>We can install <code>nodemon</code> globally on our system with the following command:<pre class="source-code">
$ npm install -g nodemon</pre></li> <li>Now that <code>nodemon</code> is available, instead of starting our application (for example, on the host) with <code>node index.js</code>, we can just execute <code>nodemon</code> and we should see the following:</li>
</ol>
<div><div><img alt="Figure 6.5 – Running our Node.js sample application with nodemon" height="212" src="img/B19199_06_05.jpg" width="622"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – Running our Node.js sample application with nodemon</p>
<p class="callout-heading">Note</p>
<p class="callout">As we can see, from parsing our <code>package.json</code> file, <code>nodemon</code> has recognized that it should use <code>node index.js</code> as the starting command.</p>
<ol>
<li value="3">Now, try to change some code. For this example, add the following code snippet to the end of <code>index.js</code> and then save the file:<pre class="source-code">
app.get('/colors', (req,res)=&gt;{    res.send(['red','green','blue']);})</pre></li> <li>Look at the terminal window. Did you see something happen? You should see this additional output:<pre class="source-code">
[nodemon] restarting due to changes...[nodemon] starting `node index.js`Application listening at 0.0.0.0:3000</pre></li> </ol>
<p>This indicates that <code>nodemon</code> has recognized some changes and automatically restarted the application.</p>
<ol>
<li value="5">Try this<a id="_idIndexMarker422"/> out on your browser<a id="_idIndexMarker423"/> by navigating to <code>localhost:3000/colors</code>. You should see the following expected output in your browser:<pre class="source-code">
["red", "green", "blue"]</pre></li> </ol>
<p>This is cool – you got this result without having to manually restart the application. This makes us yet another bit more productive. Now, can we do the same within the container?</p>
<p>Yes, we can. However, we won’t use the start command, <code>node index.js</code>, as defined in the last line of our Dockerfile:</p>
<pre class="source-code">
CMD node index.js</pre> <p>We will use <code>nodemon</code> instead.</p>
<p>Do we have to modify our Dockerfile? Or do we need two different Dockerfiles, one for development and one for production?</p>
<p>Our original Dockerfile creates an image that unfortunately does not contain <code>nodemon</code>. Thus, we need to create a new Dockerfile:</p>
<ol>
<li>Create a new file. Let’s call it <code>Dockerfile.dev</code>. Its content should look like this:</li>
</ol>
<div><div><img alt="Figure 6.6 – Dockerfile used for developing our Node.js application" height="317" src="img/B19199_06_06.jpg" width="438"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Dockerfile used for developing our Node.js application</p>
<p>Comparing<a id="_idIndexMarker424"/> this with our original <code>Dockerfile</code>, we have added line 2, where we install <code>nodemon</code>. We have also <a id="_idIndexMarker425"/>changed the last line and are now using <code>nodemon</code> as our start command.</p>
<ol>
<li value="2">Let’s build our development image, as follows:<pre class="source-code">
$ docker image build \    -f Dockerfile.dev \    -t node-demo-dev .</pre></li> </ol>
<p>Please note the <code>-f Dockerfile.dev</code> command-line parameter. We must use this since we are using a Dockerfile with a non-standard name.</p>
<ol>
<li value="3">Run a container, like this:<pre class="source-code">
$ docker container run --rm -it \    -v $(pwd):/app \    -p 3000:3000 \    node-demo-dev</pre></li> <li>Now, while <a id="_idIndexMarker426"/>the application is running in the container, change some code, save it, and notice that the application<a id="_idIndexMarker427"/> inside the container is automatically restarted. With this, we have achieved the same reduction in friction while running in a container as we did when running directly on the host.</li>
<li>Hit <em class="italic">Ctrl</em> + <em class="italic">C</em> when you’re done to exit your container.</li>
<li>Use the following command to clean up your system and remove all running or dangling containers:<pre class="source-code">
$ docker container rm -f $(docker container ls -aq)</pre></li> </ol>
<p>You might be wondering, does this only apply to Node.js? No – fortunately, many popular languages support similar concepts.</p>
<h2 id="_idParaDest-140"><a id="_idTextAnchor137"/>Auto-restarting for Java and Spring Boot</h2>
<p>Java <a id="_idIndexMarker428"/>and <a id="_idIndexMarker429"/>Spring Boot are still by far the most popular programming languages and libraries when <a id="_idIndexMarker430"/>developing <strong class="bold">line of business</strong> (<strong class="bold">LOB</strong>) type <a id="_idIndexMarker431"/>applications. Let’s learn how to work as friction-free as possible when developing such <a id="_idIndexMarker432"/>an application and containerizing it.</p>
<p>For this example to work, you have to have Java installed on your computer. At the time of writing, the recommended version is Java 17. Use your favorite package manager to do so, such as Homebrew on Mac or Chocolatey on Windows.</p>
<p>You may also want to make sure you have <em class="italic">Extension Pack for Java</em> by Microsoft installed for VS Code. You can find more details here: <a href="https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack">https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack</a>.</p>
<p>Once you <a id="_idIndexMarker433"/>have <a id="_idIndexMarker434"/>the Java 17 SDK installed and ready on your computer, proceed as follows:</p>
<ol>
<li>The easiest <a id="_idIndexMarker435"/>way to bootstrap a Spring Boot <a id="_idIndexMarker436"/>application is by using the <code>Spring Web</code>, and select it (<em class="italic">do not</em> select <strong class="bold">Spring </strong><strong class="bold">Reactive Web</strong>).</li></ol></li>
</ol>
<p>Your page should look like this:</p>
<div><div><img alt="Figure 6.7 – Bootstrapping a new Java project with Spring Initializr" height="661" src="img/B19199_06_07.jpg" width="1003"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – Bootstrapping a new Java project with Spring Initializr</p>
<ol>
<li value="2">Click <code>ch06/java-springboot-demo</code>.</li>
<li>Navigate <a id="_idIndexMarker439"/>to this folder:<pre class="source-code">
$ cd ch06/java-springboot-demo</pre></li> <li>Open<a id="_idIndexMarker440"/> VS Code from within this folder by using the following command:<pre class="source-code">
$ code .</pre></li> <li>Locate the main file of the project, which is called <code>DemoApplication.java</code>, and click on the <code>main</code> method on line 9, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 6.8 – Starting the Java Spring Boot application" height="573" src="img/B19199_06_08.jpg" width="1008"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – Starting the Java Spring Boot application</p>
<ol>
<li value="6">Observe <a id="_idIndexMarker441"/>that the application has been<a id="_idIndexMarker442"/> compiled and that<a id="_idIndexMarker443"/> a <a id="_idIndexMarker444"/>terminal window opens. Content similar to the following will be displayed:</li>
</ol>
<div><div><img alt="Figure 6.9 – Output generated by a running Spring Boot application" height="297" src="img/B19199_06_09.jpg" width="1096"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – Output generated by a running Spring Boot application</p>
<ol>
<li value="7">On the second to last line of the preceding output, we can see that the application uses the Tomcat web server and is listening at port <code>8080</code>.</li>
<li>Now, let’s add an endpoint that we can then try to access:<ol><li>Decorate the <code>DemoApplication</code> class with a <code>@</code><code>RestController</code> annotation.</li><li>Add a <code>getSpecies</code> method that returns a list of strings</li><li>Decorate the method with the following annotation:</li></ol></li>
</ol>
<p><code>@</code><code>GetMapping("/species")</code></p>
<p>Don’t <a id="_idIndexMarker445"/>forget<a id="_idIndexMarker446"/> to add<a id="_idIndexMarker447"/> the required <code>import</code> statements. The <a id="_idIndexMarker448"/>complete code will look like this:</p>
<div><div><img alt="Figure 6.10 – Complete demo code for the Spring Boot example" height="764" src="img/B19199_06_10.jpg" width="905"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – Complete demo code for the Spring Boot example</p>
<ol>
<li value="9">Use <code>curl</code> or the <code>/</code><code>species</code> endpoint:</li>
</ol>
<div><div><img alt="Figure 6.11 – Using the Thunder Client plugin to test the Java demo application" height="683" src="img/B19199_06_11.jpg" width="1090"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – Using the Thunder Client plugin to test the Java demo application</p>
<ol>
<li value="10">To add <a id="_idIndexMarker449"/>auto-restart support to our<a id="_idIndexMarker450"/> Java <a id="_idIndexMarker451"/>Spring Boot<a id="_idIndexMarker452"/> application, we need to add the so-called dev tools:<ol><li>Locate the <code>pom.xml</code> file in your Java project and open it in the editor.</li><li>Add the following snippet to the dependencies section of the file:</li></ol></li>
</ol>
<div><div><img alt="Figure 6.12 – Adding a reference to the Spring Boot dev tools" height="595" src="img/B19199_06_12.jpg" width="925"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – Adding a reference to the Spring Boot dev tools</p>
<p>Note that <a id="_idIndexMarker453"/>the version node in the <a id="_idIndexMarker454"/>dependency definition can <a id="_idIndexMarker455"/>be omitted as the project uses <code>spring-boot-starter-parent</code> as the parent.</p>
<ol>
<li value="11">Stop and rerun <a id="_idIndexMarker456"/>the application.</li>
<li>Modify line 20 of the <code>DemoApplication</code> class and add <code>Crocodile</code> as a fourth species to return to the caller.</li>
<li>Save your changes and observe that the application automatically rebuilds and restarts.</li>
<li>Use <code>curl</code> or Thunder Client again to access the <code>/species</code> endpoint. This time, a list of four species should be returned, including the just-added <code>Crocodile</code>.</li>
</ol>
<p>Great – we have a Java Spring Boot application that automatically re-compiles and restarts when we change any code in it. Now, we need to dockerize the whole thing, as we did with the <a id="_idIndexMarker457"/>Node.js example:</p>
<ol>
<li>Add a <code>Dockerfile</code> to the root of the project with the following content:</li>
</ol>
<div><div><img alt="Figure 6.13 – Dockerfile for the Java Spring Boot demo" height="359" src="img/B19199_06_13.jpg" width="676"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Dockerfile for the Java Spring Boot demo</p>
<p class="callout-heading">Note</p>
<p class="callout">We have used the <code>eclipse-temurin</code> image with the <code>17-jdk-focal</code> tag for this example since this image, at the time of writing, works on the M1 or M2 processor used by modern MacBooks.</p>
<ol>
<li value="2">Create <a id="_idIndexMarker458"/>an image using the preceding<a id="_idIndexMarker459"/> Dockerfile with <a id="_idIndexMarker460"/>this command:<pre class="source-code">
$ docker image build -t java-demo .</pre></li> <li>Create a container from this Docker image with the following command:<pre class="source-code">
$ docker container run --name java-demo --rm \    -p 8080:8080    -v $(pwd)/.:/app    java-demo</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">The first time you run the container, it will take a while to compile since all the Maven dependencies need to be downloaded.</p>
<ol>
<li value="4">Try<a id="_idIndexMarker461"/> to access the <code>/species</code> endpoint, as <a id="_idIndexMarker462"/>you did previously.</li>
<li>Now, change <a id="_idIndexMarker463"/>some code – for example, add<a id="_idIndexMarker464"/> a fifth species to be returned to the <code>getSpecies</code> method, such as <code>Penguin</code>, and then save your changes.</li>
<li>Observe how the application running inside the container is rebuilt. Verify that the change has been incorporated by accessing the <code>/species</code> endpoint once again and asserting that five species are returned, including <code>Penguin</code>.</li>
<li>When you’re done playing around, stop the container either via the dashboard of Docker Desktop or the Docker plugin in VS Code.</li>
</ol>
<p>Well, that was quite straightforward, wasn’t it? But let me tell you, setting up your development environment this way can make developing containerized applications much more enjoyable by eliminating much of the unnecessary friction.</p>
<p class="callout-heading">Challenge</p>
<p class="callout">Try to find out how you could map your local Maven cache into the container, to accelerate the first startup of the container even further.</p>
<p>Next, we are going to show you how easy it is to do the same exercise in Python. Stay tuned.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor138"/>Auto-restarting for Python</h2>
<p>Let’s look<a id="_idIndexMarker465"/> at how the same thing works for<a id="_idIndexMarker466"/> Python.</p>
<h3>Prerequisites</h3>
<p>For this <a id="_idIndexMarker467"/>example to work, you need to have Python 3.x installed on your computer. You can do this using your preferred package manager, such as Homebrew on Mac or Chocolatey on Windows.</p>
<p>On your Mac, use this command to install the latest Python version:</p>
<pre class="source-code">
$ brew install python</pre> <p>On your Windows computer, use this command to do the same:</p>
<pre class="source-code">
$ choco install python</pre> <p>Use this command to verify that the installation was successful:</p>
<pre class="source-code">
$ python3 --version</pre> <p>In the author’s case, the output looks like this:</p>
<pre class="source-code">
Python 3.10.8</pre> <p>Let’s begin:</p>
<ol>
<li>First, create a new project folder for our sample Python application and navigate to it:<pre class="source-code">
$ mkdir python-demo &amp;&amp; cd python-demo</pre></li> <li>Open VS Code from within this folder by using the following command:<pre class="source-code">
$ code .</pre></li> <li>We will create a sample Python application that uses the popular Flask library. Thus, add a file to this folder called <code>requirements.txt</code> that contains this content:<pre class="source-code">
flask</pre></li> <li>Next, add a <code>main.py</code> file and give it this content:</li>
</ol>
<div><div><img alt="Figure 6.14 – Content of the main.py file of our sample Python application" height="360" src="img/B19199_06_14.jpg" width="614"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Content of the main.py file of our sample Python application</p>
<p>This is a<a id="_idIndexMarker468"/> sim<a href="http://localhost:5000/">ple Hello World-type </a>app that implements a single RESTful endpoint at <code>http://localhost:5000/</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>host="0.0.0.0"</code> parameter in the <code>app.run</code> command is needed so that we can expose the port on which the Python app is listening (<code>5000</code>) to the host. We will need this later in this example.</p>
<p class="callout">Please also note that some people have reported that, when running on a Mac and using port <code>5000</code>, an error stating “Address already in use. Port <code>5000</code> is in use by another program...” is triggered. In this case, just try to use a different port, such as <code>5001</code>.</p>
<ol>
<li value="5">Before we can run and test this application, we need to install the necessary dependencies –  in our case, Flask. In the terminal, run the following command:<pre class="source-code">
$ pip3 install -r requirements.txt</pre></li> </ol>
<p>This should install Flask on your host. We are now ready to go.</p>
<ol>
<li value="6">When<a id="_idIndexMarker470"/> using Python, we can also use <code>nodemon</code> to have our application auto-restart when any changes are made to<a id="_idIndexMarker471"/> the code. For example, assume that your command to start the Python application is <code>python main.py</code>. In this case, you would just use <code>nodemon</code> like so:<pre class="source-code">
$ nodemon --exec python3 main.py</pre></li> </ol>
<p>You should see the following output:</p>
<div><div><img alt="Figure 6.15 – Using nodemon to auto-restart a Python 3 application" height="327" src="img/B19199_06_15.jpg" width="1125"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Using nodemon to auto-restart a Python 3 application</p>
<ol>
<li value="7">When using <code>nodemon</code> to start and monitor a Python application, we can test the application by using <code>curl</code>. Open another terminal window and enter this:<pre class="source-code">
$ curl localhost:5000</pre></li> </ol>
<p>You should see this in the output:</p>
<pre class="source-code">
Hello World!</pre> <ol>
<li value="8">Now, let’s modify the code by adding the following snippet to <code>main.py</code>, right after the definition of the <code>/</code> endpoint (that is, right after line 5), and save it:<pre class="source-code">
from flask import jsonify@app.route("/colors")def colors():    return jsonify(["red", "green", "blue"])</pre></li> </ol>
<p><code>nodemon</code> will <a id="_idIndexMarker472"/>discover the changes and restart the Python app, as we can see in the output produced in the terminal:</p>
<div><div><img alt="Figure 6.16 – nodemon discovering a change in the Python code" height="214" src="img/B19199_06_16.jpg" width="1129"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – nodemon discovering a change in the Python code</p>
<ol>
<li value="9">Once<a id="_idIndexMarker473"/> again, believing is good, but testing is better. Thus, let’s use our friend <code>curl</code> once again to probe the new endpoint and see what we get:<pre class="source-code">
$ curl localhost:5000/colors</pre></li> </ol>
<p>The output should look like this:</p>
<pre class="source-code">
["red", "green", "blue"]</pre> <p>Nice – it works! With that, we have covered Python.</p>
<ol>
<li value="10">Now, it’s time to containerize this application. Add a file called <code>Dockerfile</code> to the project with the following content:</li>
</ol>
<div><div><img alt="Figure 6.17 – Dockerfile for the sample Python application" height="324" src="img/B19199_06_17.jpg" width="755"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.17 – Dockerfile for the sample Python application</p>
<p>Note <a id="_idIndexMarker474"/>that on line 1, we are using a special<a id="_idIndexMarker475"/> base image that contains both Python and Node.js code. Then, on line 2, we install the <code>nodemon</code> tool before we copy the <code>requirements.txt</code> file into the container and execute the <code>pip install</code> command. Next, we copy all other files into the container and define the start command for whenever an instance of this image – that is, a container – is created.</p>
<ol>
<li value="11">Let’s build a Docker image with this command:<pre class="source-code">
$ docker image build -t python-sample .</pre></li> <li>Now, we can run a container from this image with the following code:<pre class="source-code">
$ docker container run --rm \    -p 5000:5000 \    -v $(pwd)/.:/app \    python-sample</pre></li> </ol>
<p>We should have an output similar to what was produced by the application running inside the container in <em class="italic">step 6</em>, where we ran the application natively:</p>
<div><div><img alt="Figure 6.18 – Running the containerized Python sample application" height="391" src="img/B19199_06_18.jpg" width="1122"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.18 – Running the containerized Python sample application</p>
<p>Note how <a id="_idIndexMarker476"/>we have mapped the container port, <code>5000</code>, to the equivalent host port so that we can access the application from outside. We have also mapped the content of the sample <a id="_idIndexMarker477"/>directory on the host to the <code>/app</code> folder inside the running container. This way, we can update the code and the containerized application will automatically restart.</p>
<ol>
<li value="13">Try to change the application code, and return a fourth color when the <code>/colors</code> endpoint is hit. Save the change and observe how the application running inside the container is restarted.</li>
<li>Use the <code>curl</code> command to verify that an array of four colors is returned.</li>
<li>When you’re done playing with this example, hit <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal window where you have the container running to stop the application and the container.</li>
</ol>
<p>With this, we have shown a fully working example for Python that helps you massively reduce the friction of working with containers during the development process.</p>
<p>.NET is another popular platform. Let’s see if we can do something like this when developing a C# application on .NET.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor139"/>Auto-restarting for .NET</h2>
<p>Our <a id="_idIndexMarker478"/>next candidate is a .NET application <a id="_idIndexMarker479"/>written in C#. Let’s look at how dynamic code updates and auto-restarts work in .NET.</p>
<h3>Prerequisites</h3>
<p>If you <a id="_idIndexMarker480"/>have not done so before, please install .NET on your laptop or workstation. You can use your favorite package manager, such as Homebrew on Mac or Chocolatey on Windows, to do so.</p>
<p>On Mac, use this command to install the .NET 7 SDK:</p>
<pre class="source-code">
$ brew install --cask dotnet-sdk</pre> <p>On a Windows machine, you can use this command:</p>
<pre class="source-code">
$ choco install -y dotnet-sdk</pre> <p>Finally, use this command to verify your installation:</p>
<pre class="source-code">
$ dotnet –version</pre> <p>On the author’s machine, the output is as follows:</p>
<pre class="source-code">
7.0.100</pre> <p>Let’s begin:</p>
<ol>
<li>In a new terminal window, navigate to this chapter’s folder:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch06</pre></li> <li>From within this folder, use the <code>dotnet</code> tool to create a new Web API and have it placed in the <code>dotnet</code> subfolder:<pre class="source-code">
$ dotnet new webapi -o csharp-sample</pre></li> <li>Navigate to this new project folder:<pre class="source-code">
$ cd csharp-sample</pre></li> <li>Open VS Code from within this folder:<pre class="source-code">
$ code .</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">If this is the first time you have opened a .NET project with VS Code, then the editor may display a popup asking you to add the missing dependencies for our <code>dotnet</code> project. Click the <strong class="bold">Yes</strong> button in this case:</p>
<div><div><img alt="Figure 6.19 – Request to load missing assets for the .NET sample application" height="177" src="img/B19199_06_19.jpg" width="910"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.19 – Request to load missing assets for the .NET sample application</p>
<ol>
<li value="5">In the <a id="_idIndexMarker481"/>Project Explorer of VS Code, you<a id="_idIndexMarker482"/> should see this:</li>
</ol>
<div><div><img alt="Figure 6.20 – The .NET sample application in the VS Code Project Explorer" height="506" src="img/B19199_06_20.jpg" width="548"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.20 – The .NET sample application in the VS Code Project Explorer</p>
<ol>
<li value="6">Please note the <code>Controllers</code> folder with the <code>WeatherForecastController.cs</code> file in it. Open this file and analyze its content. It contains the definition for the <code>WeatherForecastController</code> class, which<a id="_idIndexMarker483"/> implements a simple RESTful controller with a GET endpoint at <code>/WeatherForecast</code>.</li>
<li>From <a id="_idIndexMarker484"/>your terminal, run the application with <code>dotnet run</code>. You should see something like this:</li>
</ol>
<div><div><img alt="Figure 6.21 – Running the .NET sample Web API on the host" height="302" src="img/B19199_06_21.jpg" width="1309"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.21 – Running the .NET sample Web API on the host</p>
<p>Please note the fourth<a href="http://localhost:5080/"> line in the above </a>output, where .NET tells us that the application is listening at <code>http://localhost:5080</code>. In your case, the port may be a different one. Use the one reported for you for all subsequent steps.</p>
<ol>
<li value="8">We can use <code>curl</code> to test the application, like so:<pre class="source-code">
$ curl http://localhost:5080/WeatherForecast</pre></li> </ol>
<p>This will output an array of five JSON objects containing random weather data:</p>
<div><div><img alt="Figure 6.22 – Weather data produced by the .NET sample application" height="181" src="img/B19199_06_22.jpg" width="1077"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.22 – Weather data produced by the .NET sample application</p>
<ol>
<li value="9">We can now try to modify the code in <code>WeatherForecastController.cs</code> and return, say, 10 instead of the default 5 items. Change line 24 so that it looks like this:<pre class="source-code">
...    return Enumerable.Range(1, 10).Select(......</pre></li> <li>Save<a id="_idIndexMarker485"/> your changes and rerun the <code>curl</code> command. Notice how the result does not contain the newly added value. This is the <a id="_idIndexMarker486"/>same problem that we observed for Node.js and Python. To see the newly updated return value, we need to (manually) restart the application.</li>
<li>Thus, in your terminal, stop the application with <em class="italic">Ctrl</em> + <em class="italic">C</em> and restart it with <code>dotnet run</code>. Try the <code>curl</code> command again. The result should now reflect your changes.</li>
<li>Luckily for us, the <code>dotnet</code> tool has the <code>watch</code> command. Stop the application by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> and execute this slightly modified command:<pre class="source-code">
$ dotnet watch run</pre></li> </ol>
<p>You should see output resembling the following (shortened):</p>
<div><div><img alt="Figure 6.23 – Running the .NET sample application with the watch task" height="279" src="img/B19199_06_23.jpg" width="1312"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.23 – Running the .NET sample application with the watch task</p>
<p>Notice the first line in the preceding output, which states that the running application is now watched for changes.</p>
<ol>
<li value="13">Make another change in <code>WeatherForecastController.cs</code>; for example, make the <code>GET</code> endpoint method return 100 weather items and then save your changes. Observe the output in the terminal. It should look something like this:</li>
</ol>
<div><div><img alt="Figure 6.24 – Auto-restarting the running sample .NET Core application" height="59" src="img/B19199_06_24.jpg" width="1025"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.24 – Auto-restarting the running sample .NET Core application</p>
<ol>
<li value="14">By <a id="_idIndexMarker487"/>automatically restarting the application upon making changes to the code, the result is immediately available <a id="_idIndexMarker488"/>to us, and we can easily test it by running the following <code>curl</code> command:<pre class="source-code">
$ curl http://localhost:5080/WeatherForecast</pre></li> </ol>
<p>100 instead of 10 weather items should be output this time.</p>
<ol>
<li value="15">Now that we have auto-restart working on the host, we can author a <code>Dockerfile</code> that does the same for the application running inside a container. In VS Code, add a new file called <code>Dockerfile-dev</code> to the project and add the following content to it:</li>
</ol>
<div><div><img alt="Figure 6.25 – Dockerfile for the .NET sample application" height="278" src="img/B19199_06_25.jpg" width="771"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.25 – Dockerfile for the .NET sample application</p>
<p>Note the <code>--urls</code> command-line parameter on line 6. This explicitly tells the application to listen on port <code>5000</code> at all endpoints inside the container (denoted by the special <code>0.0.0.0</code> IP address). If we were to leave the default of <code>localhost</code>, then we wouldn’t be able to reach the application from outside the container.</p>
<p class="callout-heading">Port is already in use</p>
<p class="callout">Please note that some people have reported that when running on a Mac and using port <code>5000</code>, an error stating “Address already in use. Port <code>5000</code> is in use by another program...” is triggered. In this case, just try to use a different port, such as <code>5001</code>.</p>
<p>Now, we’re <a id="_idIndexMarker489"/>ready to build the container<a id="_idIndexMarker490"/> image:</p>
<ol>
<li>Use the following command to build a container image for the .NET sample:<pre class="source-code">
$ docker image build -f Dockerfile-dev \    -t csharp-sample .</pre></li> <li>Once the image has been built, we can run a container from it:<pre class="source-code">
$ docker container run --rm \    --name csharp-sample \    -p 5000:5000 \    -v $(pwd):/app \    csharp-sample</pre></li> </ol>
<p>We should see a similar output to what we saw when running natively.</p>
<ol>
<li value="3">Let’s test the application with our friend, <code>curl</code>:<pre class="source-code">
$ curl localhost:5000/weatherforecast</pre></li> </ol>
<p>We should get the array of weather forecast items. No surprises here – it works as expected.</p>
<ol>
<li value="4">Now, let’s make a code change in the controller and save it. Observe what’s happening in the terminal window. We should see an output like this:</li>
</ol>
<div><div><img alt="Figure 6.26 – Hot reloading the .NET sample application running inside a container" height="387" src="img/B19199_06_26.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.26 – Hot reloading the .NET sample application running inside a container</p>
<p>Well, that’s <a id="_idIndexMarker491"/>exactly what we expected. With this, we have removed most of the friction that we introduced by using containers when developing a .NET application.</p>
<ol>
<li value="5">When <a id="_idIndexMarker492"/>you’re done playing with the .NET sample application, open the dashboard of your Docker Desktop application. Locate the <code>csharp-sample</code> container and select it. Then, click the red <strong class="bold">Delete</strong> button to remove it from your system. This is the easiest way to do this since, unfortunately, just pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> in the terminal window where you ran the container does not work. Alternatively, you can open another terminal window and use this command to get rid of the container:<pre class="source-code">
$ docker container rm --force csharp-sample</pre></li> </ol>
<p>That’s it for now. In this section, we explored how we can reduce friction during development when working with containerized applications written in Node.js, Python, Spring Boot, Java, or .NET. Next, we are going to learn how we can debug an application running in a container line by line.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor140"/>Line-by-line code debugging inside a container</h1>
<p>Before we dive <a id="_idIndexMarker493"/>into this section about debugging code running inside a container line by line, let me make a disclaimer. What you will learn in this section should usually be your last resort if nothing else works. Ideally, when following a test-driven approach when developing your application, the code is mostly guaranteed to work since you have written unit and integration tests for it and run them<a id="_idIndexMarker494"/> against your code, which also runs in a container. Alternatively, if unit or integration tests don’t provide you with enough insight and you need to debug your code line by line, you can do so by running your code directly on your host, thus leveraging the support of development environments such as VS Code, Eclipse, or IntelliJ, to name just a few IDEs.</p>
<p>With all this preparation, you should rarely need to manually debug your code as it is running inside a container. That said, let’s see how you can do it anyways!</p>
<p>In this section, we are going to concentrate exclusively on how to debug when using VS Code. Other editors and IDEs may or may not offer similar capabilities.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor141"/>Debugging a Node.js application</h2>
<p>We’ll <a id="_idIndexMarker495"/>start with the easiest one – a Node.js application. We <a id="_idIndexMarker496"/>will use our sample application in the <code>~/The-Ultimate-Docker-Container-Book/ch06/node-sample</code> folder, which we worked with earlier in this chapter:</p>
<ol>
<li>Open a new terminal window and make sure that you navigate to this project folder:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch06/node-sample</pre></li> <li>Open VS Code from within this container:<pre class="source-code">
$ code .</pre></li> <li>In the terminal window, from within the project folder, run a container with our sample Node.js application:<pre class="source-code">
$ docker container run --rm -it \    --name node-sample \    -p 3000:3000 \    -p 9229:9229 \    -v $(pwd):/app \    node-demo-dev node --inspect=0.0.0.0 index.js</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">In the preceding command, we mapped port <code>9229</code> to the host. This port is used by the Node.js debugger, and VS Studio will communicate with our Node application via this port. Thus, it is important that you open this port – but only during a debugging session! Also, note that we overrode the standard start command that we defined in the Dockerfile (remember, it was just <code>node index.js</code>) with <code>node --inspect=0.0.0.0 index.js</code>. The <code>--inspect=0.0.0.0</code> command-line parameter tells Node to run in debug mode and listen on all IPv4 addresses in the container.</p>
<p>Now, we are<a id="_idIndexMarker497"/> ready<a id="_idIndexMarker498"/> to define a VS Code launch task for the scenario at hand – that is, our code running inside a container.</p>
<ol>
<li value="4">Add a folder called <code>.vscode</code> to your project (please note the leading period in the name of the folder). Within this folder, add a file called <code>launch.json</code> with the following content:</li>
</ol>
<div><div><img alt="Figure 6.27 – The launch configuration to debug a Node.js application" height="465" src="img/B19199_06_27.jpg" width="573"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.27 – The launch configuration to debug a Node.js application</p>
<ol>
<li value="5">To <a id="_idIndexMarker499"/>open the <code>launch.json</code> file, press <em class="italic">cmd</em> + <em class="italic">Shift</em> + <em class="italic">P</em> (or <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">P</em> on Windows) to open the<a id="_idIndexMarker500"/> command palette; look for <code>launch.json</code> file should open in the editor.</li>
<li>Open the <code>index.js</code> file and click on the left sidebar on line 25 to set a breakpoint:</li>
</ol>
<div><div><img alt="Figure 6.28 – Setting a breakpoint in our Node.js sample application" height="341" src="img/B19199_06_28.jpg" width="751"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.28 – Setting a breakpoint in our Node.js sample application</p>
<ol>
<li value="7">Open <a id="_idIndexMarker501"/>the Debug<a id="_idIndexMarker502"/> view in VS Code by pressing <em class="italic">cmd</em> + <em class="italic">Shift</em> + <em class="italic">D</em> (or <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">D</em> on Windows).</li>
<li>Make sure you select the correct launch task in the dropdown next to the green start button at the top of the view. Select <code>launch.json</code> file. It should look like this:</li>
</ol>
<div><div><img alt="Figure 6.29 – Selecting the correct launch task to debug our Node.js application" height="450" src="img/B19199_06_29.jpg" width="758"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.29 – Selecting the correct launch task to debug our Node.js application</p>
<ol>
<li value="9">Next, click <a id="_idIndexMarker503"/>on the<a id="_idIndexMarker504"/> green start button to attach VS Code to the Node.js application running in the container.</li>
<li>In another terminal window, use <code>curl</code> to navigate to the <code>/</code><code>colors</code> endpoint:<pre class="source-code">
$ curl localhost:3000/colors</pre></li> </ol>
<p>Observe that the code’s execution stops at the breakpoint:</p>
<div><div><img alt="Figure 6.30 – The code’s execution stops at the breakpoint" height="731" src="img/B19199_06_30.jpg" width="1022"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.30 – The code’s execution stops at the breakpoint</p>
<p>In the<a id="_idIndexMarker505"/> preceding <a id="_idIndexMarker506"/>screenshot, we can see a yellow bar, indicating that the code’s execution has stopped at the breakpoint. In the top-right corner, we have a toolbar that allows us to navigate through the code step by step. On the left-hand side, we can see the <strong class="bold">VARIABLES</strong>, <strong class="bold">WATCH</strong>, and <strong class="bold">CALL STACK</strong> windows, which we can use to observe the details of our running application. The fact that we are debugging the code running inside the container can be verified by the fact that, in the terminal windows where we started the container, we can see that the output debugger is attached, which was generated the moment we started debugging inside VS Code.</p>
<ol>
<li value="11">To stop the container, enter the following command in the terminal window:<pre class="source-code">
$ docker container rm --force node-sample</pre></li> <li>If we want to use <code>nodemon</code> for even more flexibility, then we have to change the <code>container run</code> command slightly:<pre class="source-code">
$ docker container run --rm \    --name node-sample \    -p 3000:3000 \    -p 9229:9229 \    -v $(pwd):/app \    node-sample-dev nodemon --inspect=0.0.0.0 index.js</pre></li> </ol>
<p>Note how <a id="_idIndexMarker507"/>we use <a id="_idIndexMarker508"/>the start command, <code>nodemon --inspect=0.0.0.0 index.js</code>. This will have the benefit that, upon any code changes, the application running inside the container will restart automatically, as we learned earlier in this chapter. You should see the following:</p>
<div><div><img alt="Figure 6.31 – Starting the Node.js application with nodemon and debugging turned on" height="505" src="img/B19199_06_31.jpg" width="1072"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.31 – Starting the Node.js application with nodemon and debugging turned on</p>
<ol>
<li value="13">Unfortunately, the consequence of an application restart is that the debugger loses its connection with VS Code. But don’t worry – we can mitigate this by adding <code>"restart": true</code> to our launch task in the <code>launch.json</code> file. Modify the task so that it looks like this:<pre class="source-code">
{    "type": "node",    "request": "attach",    "name": "Docker: Attach to Node",    "remoteRoot": "/app",    <strong class="bold">"restart": true</strong>},</pre></li> <li>After <a id="_idIndexMarker509"/>saving <a id="_idIndexMarker510"/>your changes, start the debugger in VS Code by clicking the green start button in the debug window. In the terminal, you should see that the debugger is attached, with a message as the output. In addition to that, VS Code will have an orange status bar at the bottom, indicating that the editor is in debug mode.</li>
<li>In a different terminal window, use <code>curl</code> and try to navigate to <code>localhost:3000/colors</code> to test that your line-by-line debugging still works. Make sure the code execution stops at any breakpoint you have set in the code.</li>
<li>Once you have verified that debugging still works, try to modify some code; for example, change the array of returned colors and add yet another color. Save your changes. Observe how <code>nodemon</code> restarts the application and that the debugger is automatically re-attached to the application running inside the container:</li>
</ol>
<div><div><img alt="Figure 6.32 – nodemon restarting the application and the debugger automatically re-attaching to the application" height="541" src="img/B19199_06_32.jpg" width="1075"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.32 – nodemon restarting the application and the debugger automatically re-attaching to the application</p>
<p>With that, we<a id="_idIndexMarker511"/> have everything assembled and can now work with code running inside a<a id="_idIndexMarker512"/> container as if the same code were running natively on the host. We have removed pretty much all of the friction that containers brought into the development process. We can now just enjoy the benefits of deploying our code in containers.</p>
<ol>
<li value="17">To clean up, stop the container by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em> within the terminal window from where you started it.</li>
</ol>
<p>Now that you’ve learned how to debug a Node.js application running in a container line by line, let’s learn how to do the same for a .NET application.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor142"/>Debugging a .NET application</h2>
<p>In this section, we <a id="_idIndexMarker513"/>want to give you a quick run-through <a id="_idIndexMarker514"/>of how to debug a .NET application line by line. We will use the sample .NET application that we created earlier in this chapter:</p>
<ol>
<li>Navigate to the project folder and open VS Code from within it:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch06/csharp-sample</pre></li> <li>Then, open VS Code with the following command:<pre class="source-code">
$ code .</pre></li> <li>To <a id="_idIndexMarker515"/>work with the debugger, we can fully rely on the help of VS Code commands. Hit <em class="italic">cmd</em> + <em class="italic">Shift</em> + <em class="italic">P</em> (<em class="italic">Shift</em> + <em class="italic">Ctrl</em> + <em class="italic">P</em> on Windows) to open the command palette.</li>
<li>Search for <code>Docker: Add Docker Files to Workspace</code> and select it:<ol><li>Select <code>5000</code>.</li></ol></li>
</ol>
<p>Once<a id="_idIndexMarker516"/> you have entered all the required information, a <code>Dockerfile</code> and a <code>.dockerignore</code> file will be added to the project. Take a moment to explore both. Notice that this <code>Dockerfile</code> is defined as a multistage build.</p>
<p>The previous command also added the <code>launch.json</code> and <code>tasks.json</code> files to a new <code>.vscode</code> folder in the project. These will be used by VS Code to help it define what to do when we ask it to debug our sample application.</p>
<ol>
<li value="5">Let’s put a breakpoint in the first <code>GET</code> request of the <code>WeatherForecastController.cs</code> file.</li>
<li>Locate the <code>.vscode/launch.json</code> file in the project and open it.</li>
<li>Locate the Docker .NET Core Launch debug configuration and add the snippet marked with the red rectangle to it:</li>
</ol>
<div><div><img alt="Figure 6.33 – Modifying the Docker Launch configuration" height="410" src="img/B19199_06_33.jpg" width="888"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.33 – Modifying the Docker Launch configuration</p>
<p>The <code>dockerServerReadyAction</code> property in the <code>launch.json</code> file of a .NET project in VS Code is used to specify an action that should be taken when a Docker<a id="_idIndexMarker517"/> container is ready to accept requests.</p>
<ol>
<li value="8">Switch to the<a id="_idIndexMarker518"/> debug window of VS Code (use <em class="italic">Command</em> + <em class="italic">Shift</em> + <em class="italic">D</em> or <em class="italic">Ctrl</em> + <em class="italic">Shift</em> + <em class="italic">D</em> on Linux or Windows to open it, respectively). Make sure you have selected the correct debug launch task – its name is Docker .NET Core Launch:</li>
</ol>
<div><div><img alt="Figure 6.34 – Selecting the correct debug launch task in VS Code" height="457" src="img/B19199_06_34.jpg" width="666"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.34 – Selecting the correct debug launch task in VS Code</p>
<ol>
<li value="9">Now, click the green start button to start the debugger. VS Code will build the Docker<a id="_idIndexMarker519"/> images, run a container of them, and configure the container for debugging. The output will be shown in the terminal window of VS Code. A browser window will open<a id="_idIndexMarker520"/> and navigate to <a href="http://localhost:5000/wetherforecast">http://localhost:5000/wetherforecast</a> since this is what we defined in the launch configuration (<em class="italic">step 6</em>). At the same time, the breakpoint in the application controller is hit, as shown here:</li>
</ol>
<div><div><img alt="Figure 6.35 – Debugging a .NET Core application running inside a container line by line" height="756" src="img/B19199_06_35.jpg" width="1025"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.35 – Debugging a .NET Core application running inside a container line by line</p>
<ol>
<li value="10">We <a id="_idIndexMarker521"/>can <a id="_idIndexMarker522"/>now step through the code, define watches, or analyze the call stack of the application, similar to what we did with the sample Node.js application. Hit the <strong class="bold">Continue</strong> button on the debug toolbar or press <em class="italic">F5</em> to continue executing the code.</li>
<li>To stop the application, click the red stop button in the debugging toolbar, which is visible in the top-right corner of the preceding screenshot.</li>
</ol>
<p>Now that we know how to debug code running in a container line by line, it is time to instrument our code so that it produces meaningful logging information.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor143"/>Instrumenting your code to produce meaningful logging information</h1>
<p>Once an<a id="_idIndexMarker523"/> application is running in production, it is impossible or strongly discouraged to interactively debug the application. Thus, we need to come up with other ways to find the root cause when the system is behaving unexpectedly or causing errors. The best way is to have the application generate detailed logging information that can then be used by the developers that need to track down any errors. Since logging is such a common task, all relevant programming languages or frameworks offer libraries that make the task of producing logging information inside an application straightforward.</p>
<p>It is common to categorize the information that’s output by an application as logs into so-called severity levels. Here is a list of those severity levels with a short description of each:</p>
<table class="No-Table-Style _idGenTablePara-1" id="table001-3">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p><strong class="bold">Log Level</strong></p>
</td>
<td class="No-Table-Style">
<p><strong class="bold">Description</strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>TRACE</p>
</td>
<td class="No-Table-Style">
<p>Very fine-grained information. At this level, you are looking at capturing every detail possible about your application’s behavior.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>DEBUG</p>
</td>
<td class="No-Table-Style">
<p>Relatively granular and mostly diagnostic information that helps you pin down potential problems if they occur.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>INFO</p>
</td>
<td class="No-Table-Style">
<p>Normal application behavior or milestones, such as startup or shutdown information.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>WARNING</p>
</td>
<td class="No-Table-Style">
<p>The application might have encountered a problem, or you detected an unusual situation.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>ERROR</p>
</td>
<td class="No-Table-Style">
<p>The application encountered a serious issue. This most probably represents the failure of an important application task.</p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style">
<p>FATAL</p>
</td>
<td class="No-Table-Style">
<p>The catastrophic failure of your application. The immediate shutdown of the application is advised.</p>
</td>
</tr>
</tbody>
</table>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 6.1 – A list of the severity levels used when generating logging information</p>
<p>Logging libraries usually allow a developer to define different log sinks – that is, destinations for the logging information. Popular sinks are file sinks or a stream to the console. When working with containerized applications, it is strongly recommended that you always <a id="_idIndexMarker524"/>direct logging output to the console or <code>STDOUT</code>. Docker will then make this information available to you via the <code>docker container logs</code> command. Other log collectors, such as Logstash, Fluentd, Loki, and others, can also be used to scrape this information.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor144"/>Instrumenting a Python application</h2>
<p>Let’s try<a id="_idIndexMarker525"/> to instrument our <a id="_idIndexMarker526"/>existing Python sample application:</p>
<ol>
<li>First, in your terminal, navigate to the project folder and open VS Code:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch06/python-demo</pre></li> <li>Open VS Code with the following command:<pre class="source-code">
$ code .</pre></li> <li>Open the <code>main.py</code> file and add the following code snippet to the top of it:</li>
</ol>
<div><div><img alt="Figure 6.36 – Defining a logger for our Python sample application" height="306" src="img/B19199_06_36.jpg" width="932"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.36 – Defining a logger for our Python sample application</p>
<p>On line 1, we import the standard logging library. We then define a logger for our sample application on line 3. On line 4, we define the filter for logging to be used. In this case, we set it to <code>WARN</code>. This means that all logging messages produced by the application with a severity equal to or higher than <code>WARN</code> will be output to the defined logging handlers or sinks, which is what we called them at the beginning of this section. In our case, only log messages with a log level of <code>WARN</code>, <code>ERROR</code>, or <code>FATAL</code> will be output.</p>
<p>On line 6, we <a id="_idIndexMarker527"/>create a logging sink or handler. In our case, it is <code>StreamHandler</code>, which outputs to <code>STDOUT</code>. Then, on line 8, we define how we want the logger to format <a id="_idIndexMarker528"/>the messages it outputs. Here, the format that we chose will output the time and date, the application (or logger) name, the log severity level, and finally, the actual message that we developers define in the code. On line 9, we add the formatter to the log handler, while on line 10, we add the handler to the logger.</p>
<p class="callout-heading">Note</p>
<p class="callout">We can define more than one handler per logger.</p>
<p>Now, we are ready to use the logger.</p>
<ol>
<li value="4">Let’s instrument the <code>hello</code> function, which is called when we navigate to the <code>/</code> endpoint:</li>
</ol>
<div><div><img alt="Figure 6.37 – Instrumenting a method with logging" height="214" src="img/B19199_06_37.jpg" width="660"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.37 – Instrumenting a method with logging</p>
<p>As shown<a id="_idIndexMarker529"/> in the preceding <a id="_idIndexMarker530"/>screenshot, we added line 3 to the preceding snippet, where we used the <code>logger</code> object to produce a logging message with the <code>INFO</code> log level. The message is <code>"Accessing </code><code>endpoint '/'"</code>.</p>
<ol>
<li value="5">Let’s instrument another function and output a message with the <code>WARN</code> log level:</li>
</ol>
<div><div><img alt="Figure 6.38 – Generating a warning" height="220" src="img/B19199_06_38.jpg" width="876"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.38 – Generating a warning</p>
<p>This time, we produced a message with the <code>WARN</code> log level on line 3 in the <code>colors</code> function. So far, so good – that wasn’t hard!</p>
<ol>
<li value="6">Now, let’s run the application and see what output we get:<pre class="source-code">
$ python3 main.py</pre></li> <li>Then, in your browser, navigate to <code>localhost:5000/</code> first and then to <code>localhost:5000/colors</code>. You should see an output like this:</li>
</ol>
<div><div><img alt="Figure 6.39 – Running the instrumented sample Python application" height="321" src="img/B19199_06_39.jpg" width="1097"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.39 – Running the instrumented sample Python application</p>
<p>As you<a id="_idIndexMarker531"/> can see, only the<a id="_idIndexMarker532"/> warning is output to the console; the <code>INFO</code> message is not. This is due to the filter we set when defining the logger. Also, note how our logging message is formatted with the date and time at the beginning, then the name of the logger, the log level, and finally, the message that was defined on line 3 of the snippet shown in <em class="italic">Figure 6</em><em class="italic">.39</em>.</p>
<ol>
<li value="8">When you’re done, stop the application by pressing <em class="italic">Ctrl</em> + <em class="italic">C</em>.</li>
</ol>
<p>Now that we’ve learned how to instrument a Python application, let’s learn how to do the same for .NET.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor145"/>Instrumenting a .NET C# application</h2>
<p>Let’s <a id="_idIndexMarker533"/>instrument <a id="_idIndexMarker534"/>our sample C# application:</p>
<ol>
<li>First, navigate to the project folder, from where you’ll open VS Code:<pre class="source-code">
$ cd ~/The-Ultimate.Docker-Container-Book/ch06/csharp-sample</pre></li> <li>Open VS Code with the following command:<pre class="source-code">
$ code .</pre></li> <li>Next, we<a id="_idIndexMarker535"/> need to add a NuGet package containing the logging library to the project:<pre class="source-code">
$ dotnet add package Microsoft.Extensions.Logging</pre></li> </ol>
<p>This should add the following line to your <code>dotnet.csproj</code> project file:</p>
<pre class="source-code">
&lt;PackageReference Include="Microsoft.Extensions.Logging" Version="7.0.0" /&gt;</pre> <ol>
<li value="4">Open <a id="_idIndexMarker536"/>the <code>Program.cs</code> class and notice that we have the following statement on line 1:<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);</pre></li> </ol>
<p>This method call, by default, adds a few logging providers to the application, among which is the console logging provider. This comes in very handy and frees us from having to do any complicated configuration first. You can, of course, override the default setting at any time with your own settings.</p>
<ol>
<li value="5">Next, open the <code>WeatherForecastController.cs</code> file in the <code>Controllers</code> folder and add the following:<ol><li>Add an instance variable, <code>logger</code>, of the <code>ILogger</code> type.</li><li>Add a constructor that has a parameter of the <code>ILogger&lt; WeatherForecastController &gt;</code> type. Assign this parameter to the <code>logger</code> instance variable:</li></ol></li>
</ol>
<div><div><img alt="Figure 6.40 – Defining a logger for the Web API controller" height="298" src="img/B19199_06_40.jpg" width="921"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.40 – Defining a logger for the Web API controller</p>
<ol>
<li value="6">Now, we’re<a id="_idIndexMarker537"/> ready to use the logger<a id="_idIndexMarker538"/> in the controller methods. Let’s instrument the <code>Get</code> method with an <em class="italic">info</em> message (line 4 in the following code):</li>
</ol>
<div><div><img alt="Figure 6.41 – Logging an INFO message from the API controller" height="254" src="img/B19199_06_41.jpg" width="916"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.41 – Logging an INFO message from the API controller</p>
<ol>
<li value="7">Now, let’s add a method that implements a <code>/warning</code> endpoint right after the <code>Get</code> method and instrument it (line 4 here):</li>
</ol>
<div><div><img alt="Figure 6.42 – Logging messages with the WARN log level" height="281" src="img/B19199_06_42.jpg" width="869"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.42 – Logging messages with the WARN log level</p>
<ol>
<li value="8">Let’s run<a id="_idIndexMarker539"/> the <a id="_idIndexMarker540"/>application by using the following command:<pre class="source-code">
$ dotnet run</pre></li> <li>We should see the following output when in a new browser tab. To do so, we must navigate to <code>localhost:3000/weatherforecast</code> and then <code>localhost:3000/warning</code>:</li>
</ol>
<div><div><img alt="Figure 6.43 – The log output of our sample .NET application" height="348" src="img/B19199_06_43.jpg" width="1094"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.43 – The log output of our sample .NET application</p>
<p>We can see the output of our log message, which is of the <code>info</code> and <code>warn</code> types, marked by red arrows. All the other log items have been produced by the ASP.NET library. You can see that there is a lot of helpful information available if you need to debug the application.</p>
<ol>
<li value="10">When you’re <a id="_idIndexMarker541"/>done, end the application with <em class="italic">Ctrl</em> + <em class="italic">C</em>.</li>
</ol>
<p>Now that<a id="_idIndexMarker542"/> we have learned how to instrument code to simplify how we can find the root cause of an issue when running in production, next, we will look at how we can instrument a distributed application using the Open Tracing standard for distributed tracing and then use Jaeger as a tool.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor146"/>Using Jaeger to monitor and troubleshoot</h1>
<p>When <a id="_idIndexMarker543"/>we want to monitor and troubleshoot transactions in a complex distributed system, we need something a bit more powerful than <a id="_idIndexMarker544"/>what we have just learned. Of course, we can and should continue to instrument our code with meaningful logging messages, yet we need something more on top of that. This <em class="italic">more</em> is the capability to trace a single request or transaction end to end, as it flows through a system consisting of many application services. Ideally, we also want to capture other interesting metrics, such as the time spent on each component versus the total time that the request took.</p>
<p>Luckily, we do not have to reinvent the wheel. There is battle-tested open source software out there that helps us achieve the aforementioned goals. One example of such an infrastructure component or <a id="_idIndexMarker545"/>softwa<a href="http://www.jaegertracing.io/">re is Jaeger (https:/</a> www.jaegertracing.io/). When using Jaeger, you run a central Jaeger server component and each application component uses a Jaeger client that will forward debug and tracing information transparently to the Jaeger server component. There are Jaeger clients for all major programming languages and frameworks, such as Node.js, Python, Java, and .NET.</p>
<p>We will not go into all the intimate details of how to use Jaeger in this book, but we will provide a high-level overview of how it works conceptually:</p>
<ol>
<li>First, we must define a Jaeger tracer object. This object coordinates the whole process of tracing a request through our distributed application. We can use this tracer object and also create a logger object from it, which our application code can use to generate log items, similar to what we did in the previous Python and .NET examples.</li>
<li>Next, we <a id="_idIndexMarker546"/>must wrap each method in the code that we want to trace with what Jaeger calls a span. This span has a name and provides us with a scope object.</li>
<li>Let’s look at<a id="_idIndexMarker547"/> some C# pseudocode that illustrates this:</li>
</ol>
<div><div><img alt="Figure 6.44 – Defining a span in Jaeger – pseudocode" height="389" src="img/B19199_06_44.jpg" width="815"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.44 – Defining a span in Jaeger – pseudocode</p>
<p>As you can see, we’re instrumenting the <code>SayHello</code> method. With a <code>using</code> statement creating a span, we’re wrapping the whole application code of this method. We have called the span <code>sayhello</code>; this will be the ID with which we can identify the method in the trace log produced by Jaeger.</p>
<p>Note that the method calls another nested method, <code>FormatString</code>. This method will look quite similar to the code needed to instrument it.</p>
<p>The span that our tracer object builds in this method will be a child span of the calling method. This child span is called <code>format-string</code>. Also, note that we are using the logger object in the preceding method to explicitly generate a log item of the <code>INFO</code> log level:</p>
<div><div><img alt="Figure 6.45 – Creating a child span in Jaeger – pseudocode" height="338" src="img/B19199_06_45.jpg" width="910"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.45 – Creating a child span in Jaeger – pseudocode</p>
<p>In the code <a id="_idIndexMarker548"/>included with this chapter, you can find a complete sample<a id="_idIndexMarker549"/> application written in Java and Spring Boot consisting of a Jaeger server container and two application containers called <code>api</code> and <code>inventory</code> that use the Jaeger client library to instrument the code. Follow these steps to rebuild this solution:</p>
<ol>
<li>Navigate to <a id="_idIndexMarker550"/>the<a href="https://start.spring.io"> <code>api</code>, as follows:</li>
</ol>
<div><div><img alt="Figure 6.46 – Bootstrapping the API component of the Jaeger sample" height="621" src="img/B19199_06_46.jpg" width="999"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.46 – Bootstrapping the API component of the Jaeger sample</p>
<p>Note <a id="_idIndexMarker551"/>how we are using Spring Boot 2.7.7 for this example<a id="_idIndexMarker552"/> since, at the time of writing, the Jaeger and Open Tracing integration does not yet work with Spring Boot 3. Also, note how we have added the Spring Web reference to the project.</p>
<ol>
<li value="2">Click <code>api.zip</code> will be downloaded to your computer.</li>
<li>Repeat the same steps but this time change the <code>inventory</code>. Then, click <code>inventory.zip</code> containing the bootstrap code will be downloaded to your computer.</li>
<li>Navigate to the source folder for this chapter:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch06</pre></li> <li>Then, create a subfolder called <code>jaeger-demo</code> in it:<pre class="source-code">
$ mkdir jaeger-demo</pre></li> <li>Extract the two ZIP files into the <code>jaeger-demo</code> folder. Make sure the subfolders are called <code>api</code> and <code>inventory</code>, respectively.</li>
<li>Open VS Code<a id="_idIndexMarker553"/> from within this folder:<pre class="source-code">
$ code .</pre></li> <li>Next, create<a id="_idIndexMarker554"/> a <code>docker-compose.yml</code> file in the root with this content:</li>
</ol>
<div><div><img alt="Figure 6.47 – The Docker Compose file for the Jaeger demo" height="607" src="img/B19199_06_47.jpg" width="689"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.47 – The Docker Compose file for the Jaeger demo</p>
<p>We will explain what a <code>docker-compose</code> file is in detail in <a href="B19199_11.xhtml#_idTextAnchor237"><em class="italic">Chapter 11</em></a>, <em class="italic">Managing Containers with </em><em class="italic">Docker Compose.</em></p>
<ol>
<li value="9">Run Jaeger<a id="_idIndexMarker555"/> with this command:<pre class="source-code">
$ docker compose up -d</pre></li> <li>In a new<a id="_idIndexMarker556"/> browser t<a href="http://localhost:16686">ab, navigate to the Ja</a>eger UI at <code>http://localhost:16686</code>.</li>
<li>Locate the two <code>pom.xml</code> files for the <code>api</code> and <code>inventory</code> projects in your VS Code. Add the Jaeger integration component to each file by adding this snippet to their <code>dependencies</code> sections:</li>
</ol>
<div><div><img alt="Figure 6.48 – Adding integration with Jaeger to the Java project(s)" height="528" src="img/B19199_06_48.jpg" width="1092"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.48 – Adding integration with Jaeger to the Java project(s)</p>
<ol>
<li value="12">In the <code>inventory</code> project, locate the start class, <code>InventoryApplication</code>, and add a bean to it that generates an instance of <code>RestTemplate</code>. We will use this to access an external API to download some data. The code snippet should look like this:<pre class="source-code">
@BeanRestTemplate restTemplate() {    return new RestTemplate();}</pre></li> <li>Do the same for the start class of the <code>api</code> project, called <code>ApiApplication</code>.</li>
<li>Now, let’s go <a id="_idIndexMarker557"/>back to the <code>inventory</code> project. Add a <a id="_idIndexMarker558"/>new file called <code>Todo.java</code> as a sibling next to the start class. The file will have the following content:</li>
</ol>
<div><div><img alt="Figure 6.49 – The Todo class in the api project for the Jaeger demo" height="963" src="img/B19199_06_49.jpg" width="490"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.49 – The Todo class in the api project for the Jaeger demo</p>
<p>This is a really simple POJO class that we are using as a data container.</p>
<ol>
<li value="15">Do the same in the <code>api</code> project.</li>
<li>Go to <a id="_idIndexMarker559"/>the <code>inventory</code> project and add a new file called <code>TodosController.java</code> with the following content:</li>
</ol>
<div><div><img alt="Figure 6.50 – The TodosController class for the Jaeger demo" height="525" src="img/B19199_06_50.jpg" width="968"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.50 – The TodosController class for the Jaeger demo</p>
<p>Notice how, on<a id="_idIndexMarker560"/> line 19, we reach out to the public <strong class="bold">JSONPlaceholder API</strong> to download a list of todo items and return those items to the caller on line 20. There’s nothing fancy here.</p>
<ol>
<li value="17">For the <code>api</code> project, add a new file called <code>HelloController.java</code> with the following content:</li>
</ol>
<div><div><img alt="Figure 6.51 – The HelloController class for the Jaeger demo" height="805" src="img/B19199_06_51.jpg" width="952"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.51 – The HelloController class for the Jaeger demo</p>
<p>Notice <a id="_idIndexMarker561"/>how the first method, which is listening <a id="_idIndexMarker562"/>on the <code>/hello</code> endpoint, just returns a string. However, the second endpoint, which is listening on the <code>/todos</code> endpoint, reaches out to the <code>api</code> service and its endpoint, <code>/api/todos</code>. The <code>api</code> service will send back the list of todos that it downloaded from the JSON Placeholder API. This way, we have a real distributed application ready to demonstrate the power of Jaeger and Open Tracing.</p>
<ol>
<li value="18">We are not quite done yet. We need to configure both projects via their respective <code>applications.properties</code> files:</li>
<li>Locate the <code>application.properties</code> file in the <code>api</code> project and add the following line to it:<pre class="source-code">
spring.application.name=jaeger-demo:api</pre></li> </ol>
<p>The preceding code defines the name of the service and how Jaeger will report it.</p>
<ol>
<li value="20">Locate <a id="_idIndexMarker563"/>the same file in the <code>inventory</code> project and<a id="_idIndexMarker564"/> add the following two lines to it:<pre class="source-code">
server.port=8090spring.application.name=jaeger-demo:inventory</pre></li> <li>The first line makes sure the inventory service is listening at port <code>8090</code> and not at the default port of <code>8080</code> to avoid any conflict with the <code>api</code> service, which will run on the default port.</li>
</ol>
<p>The second line defines the name of the service and how Jaeger will report it.</p>
<ol>
<li value="22">Now, start the <code>inventory</code> and <code>api</code> projects from within VS Code by clicking the <code>main</code> methods of their respective start classes.</li>
<li>Use <code>curl</code> or Thunder Client to access the expo<a href="http://localhost:8090/api/todos">sed endpoint of the inventory s</a>ervice at <code>http://localhost:8090/api/todos</code>. You can also do the same in a new browser tab. You should receive a list of 100 random todo items.</li>
<li>Ne<a href="http://localhost:8080/api/todos">xt, try to access the <code>api</code> s</a>ervice at the <code>http://localhost:8080/todos</code> endpoint. The same list of todos should be returned, but this time, they should originate from the <code>api</code> service and not directly from the JSON Placeholder API.</li>
<li>Now, go back to the browser tab where you opened the Jaeger UI.</li>
<li>Make sure you are on the <strong class="bold">Search</strong> tab.</li>
<li>From the <strong class="bold">Services</strong> drop-down list, select <strong class="bold">jaeger-demo:api</strong>.</li>
<li>Click <strong class="bold">Find Traces</strong>. You <a id="_idIndexMarker565"/>should see something like this:</li>
</ol>
<div><div><img alt="Figure 6.52 – Jaeger trace for the api service" height="629" src="img/B19199_06_52.jpg" width="1038"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.52 – Jaeger trace for the api service</p>
<ol>
<li value="29">Click on the <a id="_idIndexMarker566"/>trace to expand it. You should see this:</li>
</ol>
<div><div><img alt="Figure 6.53 – Details of the Jaeger trace for the api service" height="421" src="img/B19199_06_53.jpg" width="1003"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.53 – Details of the Jaeger trace for the api service</p>
<p>Here, we can see <a id="_idIndexMarker567"/>how the call is reaching out from the <code>api</code> service to the <code>inventory</code> service. We can also see the time that’s been spent on each component.</p>
<ol>
<li value="30">To clean <a id="_idIndexMarker568"/>up, stop the Jaeger server container:<pre class="source-code">
$ docker compose down</pre></li> <li>Also, stop the API with <em class="italic">Ctrl</em> + <em class="italic">C</em>.</li>
</ol>
<p>In this demo, we saw that without any special code, by just adding a component that integrates our Spring Boot applications with Jaeger and Open Tracing, we have gained a lot of insight. However, we’re only just scratching the surface of what is possible.</p>
<p><code>api</code> and <code>inventory</code> services using a similar <code>Dockerfile</code> for each, as we did in the Java demo application earlier in this chapter. The respective <code>Dockerfile</code> should be in the root of the <code>api</code> and <code>inventory</code> projects.</p>
<p>Then, amend the <code>docker-compose.yml</code> file. When you’re done, run the whole application with this command:</p>
<pre class="source-code">
$ docker compose up -d</pre> <p>Don’t <a id="_idIndexMarker569"/>worry if you’re not familiar with Docker Compose yet. We will discuss<a id="_idIndexMarker570"/> this very useful tool in <a href="B19199_11.xhtml#_idTextAnchor237"><em class="italic">Chapter 11</em></a>,<em class="italic"> </em><em class="italic">Managing Containers with </em><em class="italic">Docker Compose</em>.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor147"/>Summary</h1>
<p>In this chapter, we learned how to run and debug Node.js, Python, Java, and .NET code running inside a container. We started by mounting the source code from the host into the container to avoid the container image being rebuilt each time the code changes. Then, we smoothed out the development process further by enabling automatic application restarts inside the container upon code changes. Next, we learned how to configure VS Code to enable full interactive code debugging when code is running inside a container.</p>
<p>Finally, we learned how we can instrument our applications so that they generate logging information that can help us do root cause analysis on failures of misbehaving applications or application services running in production. We started by instrumenting our code using a logging library. Then, we used the Open Tracing standard for distributed tracing and the Jaeger tool to instrument a Java and Spring Boot application and gain valuable insight into the application’s inner workings.</p>
<p>In the next chapter, we are going to show you how using Docker containers can supercharge your automation, from running a simple automation task in a container to using containers to build a CI/CD pipeline.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor148"/>Questions</h1>
<p>Try to answer the following questions to assess your learning progress:</p>
<ol>
<li>Name two methods that help reduce the friction in the development process that’s introduced by using containers.</li>
<li>How can you achieve live code inside a container?</li>
<li>When and why would you debug code line by line when running inside a container?</li>
<li>Why is instrumenting code with good debugging information paramount?</li>
</ol>
<h1 id="_idParaDest-152"><a id="_idTextAnchor149"/>Answers</h1>
<p>Here are the answers to this chapter’s questions:</p>
<ol>
<li>Possible answers:<ul><li>Volume-mount your source code in the container</li><li>Use a tool that automatically restarts the app running inside the container when code changes are detected</li><li>Configure your container for remote debugging</li></ul></li>
<li>You can mount the folder containing the source code on your host in the container.</li>
<li>If you cannot cover certain scenarios easily with unit or integration tests and if the observed behavior of the application cannot be reproduced when the application runs on the host. Another scenario is a situation where you cannot run the application on the host directly due to a lack of the necessary language or framework.</li>
<li>Once an application is running in production, we cannot easily gain access to it as developers. If the application shows unexpected behavior or even crashes, logs are often the only source of information we have to help us reproduce the situation and pinpoint the root cause of the bug.</li>
</ol>
</div>
</div></body></html>