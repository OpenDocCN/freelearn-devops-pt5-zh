<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Controlling Execution Flow – Conditionals</h1></div></div></div><p>Control structures refer to anything and everything that have an effect on a program's execution flow. Control structures are mainly of the following two types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Conditional</li><li class="listitem" style="list-style-type: disc">Iterative</li></ul></div><p>At times, we need to execute code conditionally based on a value of a variable, type of platform, or even a result of some other command. There are times when we also need to iterate multiple objects, such as list hashes or multilevel variables.</p><p>Most programming languages and tools use powerful but machine-friendly constructs, such as <code class="literal">if else</code>, <code class="literal">for</code>, <code class="literal">unless</code>, <code class="literal">do while</code>, and so on. However, Ansible stays true to its design tenet of being a human-friendly automation language and manages to achieve the same with the omnipotent <code class="literal">when</code> and <code class="literal">with_*</code> constructs, which are closer to the English language. Let's begin to explore how it does so.</p><p>In this chapter, we are going to cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using conditional controls with the <code class="literal">when</code> statements</li><li class="listitem" style="list-style-type: disc">Using variables and facts to skip subroutines</li><li class="listitem" style="list-style-type: disc">Applying roles selectively</li><li class="listitem" style="list-style-type: disc">The conditional control structures in Jinja2 templates</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>The conditional control structure</h1></div></div></div><p>Conditional control <a id="id160" class="indexterm"/>structures allow Ansible to follow an alternate path, skip a task, or select a specific file to import based on certain conditions. In a generic programming language, this is done with the help of <code class="literal">if-then</code>, <code class="literal">else if</code>, <code class="literal">else</code>, <code class="literal">case</code> statements. Ansible does this using the "<code class="literal">when</code>" statement. Some example conditions are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Whether a certain variable is defined</li><li class="listitem" style="list-style-type: disc">Whether an earlier command sequence is successful</li><li class="listitem" style="list-style-type: disc">Whether the task has run before</li><li class="listitem" style="list-style-type: disc">Whether a platform on a target node matches the supported platforms</li><li class="listitem" style="list-style-type: disc">Whether a certain file exists</li></ul></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec36"/>The when statements</h2></div></div></div><p>We have already <a id="id161" class="indexterm"/>used the <code class="literal">when</code> statement to extract the <a id="id162" class="indexterm"/>WordPress archive based on the result of another command, which is:</p><div><pre class="programlisting">- name: download wordpress
    register: wp_download
- name: extract wordpress
    when: wp_download.rc == 0</pre></div><p>This would be vaguely equivalent to writing a shell snippet, as follows:</p><div><pre class="programlisting">DOWNLOAD_WORDPRESS
var=`echo $?
if [$var -eq 0]
then
    EXTRACT_WORDPRESS()
fi</pre></div><p>In addition to checking the preceding code, we could simply write conditions based on the result of the task itself, as follows:</p><div><pre class="programlisting">- name: extract wordpress
    when: wp_download|success
- name: notify devops engineers
    when: wp_download|failed</pre></div><p>For the failed statement to work, we need to add the <code class="literal">ignore_errors: True</code> statement to the earlier task that <a id="id163" class="indexterm"/>registers the variable. The following <a id="id164" class="indexterm"/>flowchart depicts the same logic:</p><div><img src="img/B03800_05_01.jpg" alt="The when statements"/></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Fact-based selection</h3></div></div></div><p>Facts are a good <a id="id165" class="indexterm"/>source of information to detect platform-specific <a id="id166" class="indexterm"/>information and make a choice based on it, especially when you have hybrid environments. Based on this selection, we could:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Decide whether to execute a task</li><li class="listitem" style="list-style-type: disc">Decide whether to include a task file</li><li class="listitem" style="list-style-type: disc">Decide whether to import a file</li><li class="listitem" style="list-style-type: disc">Decide whether to apply a role on the target node</li></ul></div><p>We have already used fact-based selection while writing MySQL, where we used the fact <code class="literal">ansible_os_family</code> to:</p><div><ol class="orderedlist arabic"><li class="listitem">Import the <code class="literal">vars</code> file for non-Debian-based systems.</li><li class="listitem">Include <a id="id167" class="indexterm"/>platform-specific tasks for package installation.</li></ol></div><p>The following code <a id="id168" class="indexterm"/>snippet shows both the use cases:</p><div><img src="img/B03800_05_02.jpg" alt="Fact-based selection"/></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Refactoring the MySQL role</h1></div></div></div><p>Our existing <a id="id169" class="indexterm"/>MySQL role installs and configures only the server. More often than not, all we need to do is just install the MySQL client package and not the server. We don't have the ability to selectively do so.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>
<strong>The scenario:</strong>
</p><p>We have been tasked to refactor the MySQL role and make it conditionally install the MySQL server based on a variable value. By default, it should just install MySQL client packages.</p></div></div><p>Boolean variables could be useful to set up an an on/off switch. We will add a variable and set its default <a id="id170" class="indexterm"/>value to <code class="literal">false</code>. This time, we will create a multilevel variable or a nested hash.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Multilevel variable dictionaries</h2></div></div></div><p>So far, we have <a id="id171" class="indexterm"/>been naming variables as <code class="literal">mysql_bind</code>, <code class="literal">mysql_port</code>, and so on and using an underscore to categorize them. Variables can instead be better categorized and organized if you define them with multiple-level dictionaries, for example:</p><div><pre class="programlisting">mysql:
  config:
    bind: 127.0.0.1
    port: 3306</pre></div><p>Multilevel variables can then be accessed inside the code as <code class="literal">mysql['config]['bind']</code> or <code class="literal">mysql['config]['port']</code>. Let's now update the <code class="literal">roles/mysql/defaults/main.yml</code> file to use multilevel variables and also create a new Boolean variable <code class="literal">mysql.server</code>, which acts as a flag:</p><div><img src="img/B03800_05_03.jpg" alt="Multilevel variable dictionaries"/></div><p>Additionally, we would have to update files in the <code class="literal">vars</code> directory in the <code class="literal">mysql</code> role to define the variables with a new style, all tasks, handlers, and templates to reference them appropriately. This process is added as part of the text to avoid redundancy.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec11"/>Merging hashes</h3></div></div></div><p>Multilevel variables <a id="id172" class="indexterm"/>or, in essence, dictionaries defined from different locations may need to be merged. For example, if we define default configuration parameters in the role <code class="literal">default</code> and then override a few from the <code class="literal">vars</code> directory in the role, the resultant variable <code class="literal">hash</code> should contain items from the <strong>defaults</strong> plus overridden values from <strong>vars</strong>.</p><p>Let's take a look at the following screenshot:</p><div><img src="img/B03800_05_04.jpg" alt="Merging hashes"/></div><p>However, by default, Ansible will replace the dictionary, and in the preceding example, instead of getting a merged dictionary, we would lose the user and port <code class="literal">vars</code> as <code class="literal">vars</code> in the role has higher precedence. This can be avoided by setting the <code class="literal">hash_behavior</code> parameter to <code class="literal">merge</code> instead of <code class="literal">replace</code>, as follows:</p><div><pre class="programlisting"># /etc/ansible/ansible.cfg
    hash_behaviour=merge</pre></div><p>This should be set on the Ansible control host and does not require us to restart any service.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec38"/>Configuring the MySQL server selectively</h2></div></div></div><p>After <a id="id173" class="indexterm"/>refactoring the code and adding a flag controlled by a variable, we are ready to selectively configure the MySQL server. We have the <code class="literal">mysql.server</code> variable, which takes the Boolean value of <code class="literal">True</code>/<code class="literal">False</code>. This variable could be used to decide whether to skip server configurations, as follows:</p><div><pre class="programlisting">#file: roles/mysql/tasks/main.yml
- include: configure.yml
  when: mysql.server

- include: service.yml
  when: mysql.server</pre></div><p>Let's also add <a id="id174" class="indexterm"/>tasks to install the MySQL client package as well as the Python bindings required by Ansible's MySQL module:</p><div><pre class="programlisting">---
# filename: roles/mysql/tasks/install_Debian.yml
  - name: install mysql client
    apt:
      name: "{{ mysql['pkg']['client'] }}"
      update_cache: yes

  - name: install mysql server
    apt:
      name: "{{ mysql['pkg']['server'] }}"
      update_cache: yes
    when: mysql.server

  - name: install mysql python binding
    apt:
      name: "{{ mysql['pkg']['python'] }}"</pre></div><p>Here, the package names come from the following variable <code class="literal">hash</code>:</p><div><pre class="programlisting">mysql:
pkg:
    server: mysql-server
    client: mysql-client
    python: python-mysqldb</pre></div><p>By default, the <code class="literal">mysql.server</code> parameter has been set to <code class="literal">False</code>. How do we enable this only for the database servers? There are plenty of ways we can do so. We would choose playbook variables this time, since we have one dedicated to DB servers.</p><p>Let's take a look at the following screenshot:</p><div><img src="img/B03800_05_05.jpg" alt="Configuring the MySQL server selectively"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec42"/>Conditional control structure in Jinja2 templates</h1></div></div></div><p>Ansible uses <a id="id175" class="indexterm"/>Jinja2 as a template engine. Hence, it would be useful for us to understand Jinja2 control structures in addition to the ones supported by <a id="id176" class="indexterm"/>Ansible tasks. Jinja2's syntax encloses the control structures inside the <code class="literal">{%     %}</code> blocks. For conditional control, Jinja2 uses the familiar <code class="literal">if</code> statements, which have the following syntax:</p><div><pre class="programlisting">{% if condition %}
    do_some_thing
{% elif condition2 %}
    do_another_thing
{% else %}
    do_something_else
{% endif %}</pre></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec39"/>Updating the MySQL template</h2></div></div></div><p>The template that <a id="id177" class="indexterm"/>we created earlier to generate the <code class="literal">my.cnf</code> file <a id="id178" class="indexterm"/>assumes that all the variables referred in it are defined somewhere. There is a chance that this is not always the case, which could result in errors while running Ansible. Could we selectively include configuration parameters in the <code class="literal">my.cnf</code> file? The answer is yes. We could check whether a variable is defined and only then, we will add it to the file, as follows:</p><div><pre class="programlisting">#filename: roles/mysql/template/my.cnf.j2
[mysqld]
user = {{ mysql['config']['user'] | default("mysql") }}
{% if mysql.config.pid is defined %}
pid-file = {{ mysql['config']['pid'] }}
{% endif %}
{% if mysql.config.socket is defined %}
socket = {{ mysql['config']['socket'] }}
{% endif %}
{% if mysql.config.port is defined %}
port = {{ mysql['config']['port'] }}
{% endif %}
{% if mysql.config.datadir is defined %}
datadir = {{ mysql['config']['datadir'] }}
{% endif %}
{% if mysql.config.bind is defined %}
bind-address = {{ mysql['config']['bind'] }}
{% endif %}</pre></div><p>Let's analyze the <a id="id179" class="indexterm"/>preceding code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Since we are <a id="id180" class="indexterm"/>setting the default value for the <code class="literal">mysql['config']['user']</code> parameter, there is no need to check whether it's defined. It's already handled gracefully.</li><li class="listitem" style="list-style-type: disc">For all other parameters, we check whether the variable is defined using a condition, such as <code class="literal">if mysql.config.pid is defined</code>. This would skip the parameter if it's not defined rather than throwing an error.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Running a task only once</h1></div></div></div><p>At times, a <a id="id181" class="indexterm"/>specific task in a role may need to be executed only once during a playbook execution, even though the role is applied to many hosts. This could be achieved with the <code class="literal">run_once</code> conditional:</p><div><pre class="programlisting">name: initialize wordpress database
script: initialize_wp_database.sh 
run_once: true</pre></div><p>Since we are using the <a id="id182" class="indexterm"/><code class="literal">run_once</code> option, the preceding task would run on the first host in the inventory that the role is being applied to. All consequent hosts would skip this task.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Executing roles conditionally</h1></div></div></div><p>The Nginx role <a id="id183" class="indexterm"/>that we created earlier to set up web server supports only Debian-based systems. Running this logic on other systems could lead to failure. For example, the Nginx role uses the <code class="literal">apt</code> module to install packages, which would not work on RedHat-based systems, which depend on the <code class="literal">yum</code> package manager. This could be avoided by adding the <code class="literal">when</code> statement with a fact to selectively execute based on an OS family. The following is the snippet from the <code class="literal">www.yml</code> playbook:</p><div><pre class="programlisting">#filename: www.yml (snippet)
- hosts: www
  roles:
    - { role: nginx, when: ansible_os_family == 'Debian' }</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec45"/>Review questions</h1></div></div></div><p>Do you think you've understood the chapter well enough? Try answering the following questions to test your understanding:</p><div><ol class="orderedlist arabic"><li class="listitem">What is the replacement for the <code class="literal">if else</code> statements in Ansible?</li><li class="listitem">How can you selectively import platform-specific variables?</li><li class="listitem">Why do Jinja2 templates use <code class="literal">__</code> and <code class="literal">__</code> to delimit control structures?</li><li class="listitem">How would you skip running roles on incompatible platforms?</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, you learnt about how to control execution flow using the <code class="literal">when</code> statements, conditional imports, selective includes, and so on. You also learnt how to use variables and facts to selectively skip routines and execute platform-specific subroutines. We refactored the MySQL role to start using dictionaries of variables to conditionally configure the MySQL server and to use more intelligent templates with prechecks for defined variables.</p><p>In the next chapter, we will begin exploring the second type of control structures, that is. iterative control structures, where we will start looping arrays and hashes.</p></div></body></html>