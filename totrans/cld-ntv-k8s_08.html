<html><head></head><body>
		<div><h1 id="_idParaDest-140"><em class="italic"><a id="_idTextAnchor143"/>Chapter 6</em>: Kubernetes Application Configuration</h1>
			<p>This chapter describes the main configuration tools that Kubernetes provides. We'll start by discussing some best practices for injecting configuration into containerized applications. Next, we will discuss ConfigMaps, a Kubernetes resource aimed at providing applications with configuration data. Finally, we will cover Secrets, a secure way to store and provide sensitive data to applications running on Kubernetes. Altogether, this chapter should give you a great toolset for configuring your production applications on Kubernetes.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Configuring containerized applications using best practices</li>
				<li>Implementing ConfigMaps</li>
				<li>Using Secrets</li>
			</ul>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor144"/>Technical requirements</h1>
			<p>In order to run the commands detailed in this chapter, you will need a computer that supports the <code>kubectl</code> command-line tool, along with a working Kubernetes cluster. Review <a href="B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016"><em class="italic">Chapter 1</em></a>, <em class="italic">Communicating with Kubernetes</em>, to find several methods for getting up and running with Kubernetes quickly, and for instructions on how to install the <code>kubectl</code> tool.</p>
			<p>The code used in this chapter can be found in the book's GitHub repository at <a href="https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter6">https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter6</a>.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor145"/>Configuring containerized applications using best practices</h1>
			<p>By now, we<a id="_idIndexMarker293"/> know how to effectively deploy (as covered in <a href="B14790_04_Final_PG_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 4</em></a>, <em class="italic">Scaling and Deploying Your Application</em>) and expose (as covered in <a href="B14790_05_Final_PG_ePub.xhtml#_idTextAnchor127"><em class="italic">Chapter 5</em></a>, <em class="italic">Services and Ingress </em>– <em class="italic">Communicating with the outside world</em>) containerized applications on Kubernetes. This is enough to run non-trivial stateless containerized applications on Kubernetes. However, Kubernetes also provides additional tooling for application configuration and Secrets management.</p>
			<p>Since Kubernetes runs containers, you could always configure your application to use environment variables baked into your Dockerfile. But this sidesteps some of the real value of an orchestrator like Kubernetes. We want to be able to change our application container without rebuilding a Docker image. For this purpose, Kubernetes gives us two configuration-focused resources: ConfigMaps and Secrets. Let's first look at ConfigMaps.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor146"/>Understanding ConfigMaps</h2>
			<p>When running <a id="_idIndexMarker294"/>applications in production, developers want the ability to quickly and easily inject application configuration information. There are many patterns for doing this – from using a separate configuration server that is queried, to using environment variables or environment files. These strategies vary in the security and usability they offer.</p>
			<p>For containerized applications, environment variables are often the easiest way to go – but injecting these variables in a secure way can require additional tooling or scripts. In Kubernetes, the ConfigMap resource lets us do this in a flexible, easy way. ConfigMaps allow Kubernetes administrators to specify and inject configuration information as either files or environment variables.</p>
			<p>For highly sensitive information such as secret keys, Kubernetes gives us another, similar resource – Secrets.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor147"/>Understanding Secrets</h2>
			<p>Secrets <a id="_idIndexMarker295"/>refer to additional application configuration items that need to be stored in a slightly more secure way – for instance, master keys to restricted APIs, database passwords, and more. Kubernetes provides a resource called a Secret, which stores application configuration information in an encoded fashion. This does not inherently make the Secret more secure, but Kubernetes respects the concept of a secret by not automatically printing secret information in the <code>kubectl get</code> or <code>kubectl describe</code> commands. This prevents the Secret from being accidentally printed to a log. </p>
			<p>To ensure that<a id="_idIndexMarker296"/> Secrets are actually secret, encryption at rest must be enabled on your cluster for secret data – we'll review how to do this later in this chapter. Available from Kubernetes 1.13, this functionality lets Kubernetes administrators prevent Secrets from being stored unencrypted in <code>etcd</code>, and limits access to <code>etcd</code> admins.</p>
			<p>Before we do a deep dive into Secrets, let's start by discussing ConfigMaps, which are better for non-sensitive information.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor148"/>Implementing ConfigMaps</h1>
			<p>ConfigMaps provide<a id="_idIndexMarker297"/> an easy way to store and inject application configuration data for containers running on Kubernetes.</p>
			<p>Creating a ConfigMap is simple – and they enable two possibilities for actually injecting the application configuration data:</p>
			<ul>
				<li>Injecting as an environment variable</li>
				<li>Injecting as a file</li>
			</ul>
			<p>While the first option operates simply using container environment variables in memory, the latter option touches on some facets of volumes – a Kubernetes storage medium that will be covered in the next chapter. We will keep the review short for now and use it as an introduction to volumes, which will be expanded on in the following chapter, <a href="B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166"><em class="italic">Chapter 7</em></a>, <em class="italic">Storage on Kubernetes</em>.</p>
			<p>When working with ConfigMaps, it can be easier to create them using an imperative <code>Kubectl</code> command. There are a few possible ways to create ConfigMaps, which also result in differences in the way data is stored and accessed from the ConfigMap itself. The first way is to simply create it from a text value, as we will see next.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor149"/>From text values</h2>
			<p>Creating a ConfigMap<a id="_idIndexMarker298"/> from a text value in a command is<a id="_idIndexMarker299"/> done as follows:</p>
			<pre>kubectl create configmap myapp-config --from-literal=mycategory.mykey=myvalue </pre>
			<p>The previous command creates a <code>configmap</code> named <code>myapp-config</code> with a single key, called <code>mycategory.mykey</code>, that has a value of <code>myvalue</code>. You can also create a ConfigMap with multiple keys and values, as follows:</p>
			<pre>kubectl create configmap myapp-config2 --from-literal=mycategory.mykey=myvalue
--from-literal=mycategory.mykey2=myvalue2 </pre>
			<p>The preceding command results in a ConfigMap with two values in the <code>data</code> section.</p>
			<p>To see what your ConfigMap looks like, run the following command:</p>
			<pre>kubectl get configmap myapp-config2</pre>
			<p>You will see the following output:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">configmap-output.yaml</p>
			<pre>apiVersion: v1
kind: ConfigMap
metadata:
  name: myapp-config2
  namespace: default
data:
  mycategory.mykey: myvalue
  mycategory.mykey2: myvalue2</pre>
			<p>When your ConfigMap data is long, it does not make as much sense to create it directly from a text value. For longer configs, we can create our ConfigMap from a file.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor150"/>From files</h2>
			<p>In order to make it easier <a id="_idIndexMarker300"/>to create a ConfigMap with many different <a id="_idIndexMarker301"/>values, or reuse existing environment files you already have, you can create a ConfigMap from a file by following these steps:</p>
			<ol>
				<li>Let's start by creating our file, which we'll name <code>env.properties</code>:<pre><strong class="bold">myconfigid=1125</strong>
<strong class="bold">publicapikey=i38ahsjh2</strong></pre></li>
				<li>Then, we can create our ConfigMap by running the following command:<pre><strong class="bold">kubectl create configmap my-config-map --from-file=env.properties</strong></pre></li>
				<li>To check whether our <code>kubectl create</code> command correctly made our ConfigMap, let's describe it using <code>kubectl describe</code>:<pre><strong class="bold">kubectl describe configmaps my-config-map</strong></pre></li>
			</ol>
			<p>This should result in the following output:</p>
			<pre>Name:           my-config-map
Namespace:      default
Labels:         &lt;none&gt;
Annotations:    &lt;none&gt;
Data
====
env.properties:        39 bytes</pre>
			<p>As you can see, this ConfigMap contains our text file (and the number of bytes). Our file in this case could be any text file – but if you know that your file is formatted properly as an environment file, you can let Kubernetes know that, in order to make your ConfigMap a bit easier to read. Let's learn how to do this. </p>
			<h2 id="_idParaDest-148"><a id="_idTextAnchor151"/>From environment files</h2>
			<p>If we know that <a id="_idIndexMarker302"/>our file is formatted as a normal<a id="_idIndexMarker303"/> environment file with key pairs, we can use a slightly different method to create our ConfigMap – the environment file method. This method will make our data more obvious in the ConfigMap object, rather than being hidden inside the file.</p>
			<p>Let's use the exact same file as before with our environment-specific creation:</p>
			<pre>kubectl create configmap my-env-config-map --from-env-file=env.properties</pre>
			<p>Now, let's describe our ConfigMap using the following command:</p>
			<pre>&gt; kubectl describe configmaps my-env-config-map</pre>
			<p>We get the following output:</p>
			<pre>Name:         my-env-config-map
Namespace:    default
Labels:       &lt;none&gt;
Annotations:  &lt;none&gt;
Data
====
myconfigid:
----
1125
publicapikey:
----
i38ahsjh2
Events:  &lt;none&gt;</pre>
			<p>As you can see, by using the <code>-from-env-file</code> method, the data in the <code>env</code> file is easily viewable when you run <code>kubectl describe</code>. This also means we can mount our ConfigMap directly as environment variables – more on that shortly.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor152"/>Mounting a ConfigMap as a volume</h2>
			<p>To consume<a id="_idIndexMarker304"/> data from a ConfigMap in a Pod, you need to mount it <a id="_idIndexMarker305"/>to the Pod in the spec. This mirrors (for good reason, as we'll find out) the way to mount a volume in Kubernetes, which is a resource that provides storage. For now, however, don't worry about volumes.</p>
			<p>Let's take a look at our Pod spec, which mounts our <code>my-config-map</code> ConfigMap as a volume on our Pod:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">pod-mounting-cm.yaml</p>
			<pre>apiVersion: v1
kind: Pod
metadata:
  name: my-pod-mount-cm
spec:
  containers:
    - name: busybox
      image: busybox
      command:
      - sleep
      - "3600"
      volumeMounts:
      - name: my-config-volume
        mountPath: /app/config
  volumes:
    - name: my-config-volume
      configMap:
        name: my-config-map
  restartPolicy: Never</pre>
			<p>As you can see, our <code>my-config-map</code> ConfigMap is mounted as a volume (<code>my-config-volume</code>) on the <code>/app/config</code> path for our container to access. We'll get to know more about how this works in the next chapter on storage.</p>
			<p>In some cases, you may want to <a id="_idIndexMarker306"/>mount a ConfigMap as environment variables in your container – we will learn<a id="_idIndexMarker307"/> how to do this next.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor153"/>Mounting a ConfigMap as an environment variable</h2>
			<p>You can also mount <a id="_idIndexMarker308"/>a ConfigMap as an environment <a id="_idIndexMarker309"/>variable. This process is pretty similar to mounting a ConfigMap as a volume.</p>
			<p>Let's take a look at our Pod spec:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">pod-mounting-cm-as-env.yaml</p>
			<pre>apiVersion: v1
kind: Pod
metadata:
  name: my-pod-mount-env
spec:
  containers:
    - name: busybox
      image: busybox
      command:
      - sleep
      - "3600"
      env:
        - name: MY_ENV_VAR
          valueFrom:
            configMapKeyRef:
              name: my-env-config-map
              key: myconfigid
  restartPolicy: Never</pre>
			<p>As you can see, instead<a id="_idIndexMarker310"/> of mounting our ConfigMap as a volume, we are simply referencing it in a container environment variable – <code>MY_ENV_VAR</code>. To do this, we need to use <code>configMapRef</code> in our <code>valueFrom</code> key and <a id="_idIndexMarker311"/>reference the name of our ConfigMap as well as the key to look at inside the ConfigMap itself.</p>
			<p>As we mentioned at the beginning of the chapter in the <em class="italic">Configuring containerized applications using best practices</em> section, ConfigMaps are not secure by default, and their data is stored as plaintext. For an added layer of security, we can use Secrets instead of ConfigMaps.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor154"/>Using Secrets</h1>
			<p>Secrets work <a id="_idIndexMarker312"/>very similarly to ConfigMaps, except that they are stored as encoded text (specifically, Base64) instead of plaintext.</p>
			<p>Creating a Secret is therefore very similar to creating a ConfigMap, with a few key differences. For starters, creating a Secret imperatively will automatically Base64-encode the data in the Secret. First, let's look at creating a Secret imperatively from a pair of files.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor155"/>From files</h2>
			<p>First, let's try creating a Secret<a id="_idIndexMarker313"/> from a file (this also works with multiple files). We can <a id="_idIndexMarker314"/>do this using the <code>kubectl create</code> command:</p>
			<pre>&gt; echo -n 'mysecretpassword' &gt; ./pass.txt
&gt; kubectl create secret generic my-secret --from-file=./pass.txt</pre>
			<p>This should result in the following output:</p>
			<pre>secret "my-secret" created</pre>
			<p>Now, let's see what our Secret looks like using <code>kubectl describe</code>:</p>
			<pre>&gt; kubectl describe secrets/db-user-pass</pre>
			<p>This command should result in the following output:</p>
			<pre>Name:            my-secret
Namespace:       default
Labels:          &lt;none&gt;
Annotations:     &lt;none&gt;
Type:            Opaque
Data
====
pass.txt:    16 bytes</pre>
			<p>As you can see, the <code>describe</code> command shows the number of bytes contained in the Secret, and its type <code>Opaque</code>.</p>
			<p>Another way to<a id="_idIndexMarker315"/> create a Secret is to manually create it using a declarative<a id="_idIndexMarker316"/> approach. Let's look at how to do that next.</p>
			<h2 id="_idParaDest-153"><a id="_idTextAnchor156"/>Manual declarative approach</h2>
			<p>When creating a Secret<a id="_idIndexMarker317"/> declaratively from a YAML file, you'll need to pre-encode the data to be stored using an encoding utility, such as the <code>base64</code> pipe on Linux. </p>
			<p>Let's encode our password here using the Linux <code>base64</code> command:</p>
			<pre>&gt; echo -n 'myverybadpassword' | base64
bXl2ZXJ5YmFkcGFzc3dvcmQ=</pre>
			<p>Now, we can declaratively create our Secret using a Kubernetes YAML spec, which we can name <code>secret.yaml</code>:</p>
			<pre>apiVersion: v1
kind: Secret
metadata:
  name: my-secret
type: Opaque
data:
  dbpass: bXl2ZXJ5YmFkcGFzc3dvcmQ=</pre>
			<p>Our <code>secret.yaml</code> spec contains the Base64-encoded string that we created.</p>
			<p>To create the Secret, run the following command:</p>
			<pre>kubectl create -f secret.yaml</pre>
			<p>Now you know<a id="_idIndexMarker318"/> how to create Secrets. Next, let's learn how to mount a Secret for use by a Pod.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor157"/>Mounting a Secret as a volume</h2>
			<p>Mounting <a id="_idIndexMarker319"/>Secrets is very similar to mounting ConfigMaps. First, let's <a id="_idIndexMarker320"/>take a look at how to mount a Secret to a Pod as a volume (file).</p>
			<p>Let's take a look at our Pod spec. In this case, we are running an example application in order to test our Secret. Here is the YAML:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">pod-mounting-secret.yaml</p>
			<pre>apiVersion: v1
kind: Pod
metadata:
  name: my-pod-mount-cm
spec:
  containers:
    - name: busybox
      image: busybox
      command:
      - sleep
      - "3600"
      volumeMounts:
      - name: my-config-volume
        mountPath: /app/config
        readOnly: true
  volumes:
    - name: foo
      secret:
      secretName: my-secret
  restartPolicy: Never</pre>
			<p>The one difference from ConfigMap here is that we specify <code>readOnly</code> on the volume to prevent any changes to the Secret while the Pod is running. Everything else is the same as far as how we are mounting the Secret.</p>
			<p>Again, we will review<a id="_idIndexMarker321"/> volumes in <a id="_idIndexMarker322"/>depth in the next chapter, <a href="B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166"><em class="italic">Chapter 7</em></a>, <em class="italic">Storage on Kubernetes</em>, but for a simple explanation, volumes are a way to add storage to your Pods. In this example, we mounted our volume, which you can consider a filesystem, to our Pod. Our Secret is then created as a file in the filesystem.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor158"/>Mounting a Secret as an environment variable</h2>
			<p>Similar to file<a id="_idIndexMarker323"/> mounting, we can mount our Secret as an <a id="_idIndexMarker324"/>environment variable in much the same way that ConfigMap mounting works.</p>
			<p>Let's take a look at another Pod YAML. In this case, we will mount our Secret as an environment variable:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">pod-mounting-secret-env.yaml</p>
			<pre>apiVersion: v1
kind: Pod
metadata:
  name: my-pod-mount-env
spec:
  containers:
    - name: busybox
      image: busybox
      command:
      - sleep
      - "3600"
      env:
        - name: MY_PASSWORD_VARIABLE
          valueFrom:
            secretKeyRef:
              name: my-secret
              key: dbpass
  restartPolicy: Never</pre>
			<p>After creating the preceding Pod with <code>kubectl apply</code>, let's run a command to look into our Pod to see if the variable was properly initialized. This works exactly the same way as <code>docker exec</code>:</p>
			<pre>&gt; kubectl exec -it my-pod-mount-env -- /bin/bash
&gt; printenv MY_PASSWORD_VARIABLE
myverybadpassword</pre>
			<p>It works! You should now have a good understanding of how to create, mount, and use ConfigMaps and Secrets.</p>
			<p>As the final topic<a id="_idIndexMarker325"/> concerning Secrets, we will learn how to create secure, encrypted<a id="_idIndexMarker326"/> Secrets using the Kubernetes <code>EncryptionConfig</code>.</p>
			<h2 id="_idParaDest-156">Implementing <a id="_idTextAnchor159"/>encrypted Secrets</h2>
			<p>Several managed <a id="_idIndexMarker327"/>Kubernetes services (including Amazon's <code>etcd</code> data at rest – so you don't need to do anything in order to<a id="_idIndexMarker328"/> implement encrypted Secrets. Cluster provisioners such as Kops have a simple flag (such as <code>encryptionConfig: true</code>). But if you're creating your cluster <em class="italic">the hard way</em>, you'll need to start the Kubernetes API server with a flag, <code>--encryption-provider-config</code>, and an <code>EncryptionConfig</code> file.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Creating a cluster completely from scratch is outside the scope of this book (take a look at <em class="italic">Kubernetes The Hard Way</em> for a great guide on that, at <a href="https://github.com/kelseyhightower/kubernetes-the-hard-way">https://github.com/kelseyhightower/kubernetes-the-hard-way</a>).</p>
			<p>For a quick look at how encryption is handled, take a look at the following <code>EncryptionConfiguration</code> YAML, which is passed to <code>kube-apiserver</code> on start:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">encryption-config.yaml</p>
			<pre>apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - aesgcm:
        keys:
        - name: key1
          secret: c2VjcmV0IGlzIHNlY3VyZQ==
        - name: key2
          secret: dGhpcyBpcyBwYXNzd29yZA==</pre>
			<p>The <a id="_idIndexMarker329"/>preceding <code>EncryptionConfiguration</code> YAML takes a list of the resources that should be encrypted in <code>etcd</code>, and one or more providers that can be used to encrypt data. The following providers are allowed as of Kubernetes <code>1.17</code>:</p>
			<ul>
				<li><strong class="bold">Identity</strong>: No encryption.</li>
				<li><strong class="bold">Aescbc</strong>: The recommended encryption provider.</li>
				<li><strong class="bold">Secretbox</strong>: Faster than Aescbc, and newer.</li>
				<li><strong class="bold">Aesgcm</strong>: Note that you will need to implement key rotation yourself with Aesgcm.</li>
				<li><strong class="bold">Kms</strong>: Used with a third-party Secrets store, such as Vault or AWS KMS.</li>
			</ul>
			<p>To see the full list, see https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/#providers. When multiple providers are added to the list, Kubernetes will use the first configured provider to encrypt objects. When decrypting, Kubernetes will go down the list and attempt decryption with each provider – if none work, it will return an error.</p>
			<p>Once we have created a secret (look at any of our previous examples of how to do so), and our <code>EncryptionConfig</code> is active, we can check whether our Secrets are actually encrypted.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor160"/>Checking whether your Secrets are encrypted</h2>
			<p>The easiest way<a id="_idIndexMarker330"/> to check whether your secret is actually encrypted in <code>etcd</code> is to fetch the value directly from <code>etcd</code> and check the encryption prefix:</p>
			<ol>
				<li value="1">First, let's go ahead and make a secret key using <code>base64</code>:<pre><strong class="bold">&gt; echo -n 'secrettotest' | base64</strong>
<strong class="bold">c2VjcmV0dG90ZXN0</strong></pre></li>
				<li>Create a file called <code>secret_to_test.yaml</code> with the following content:<pre>apiVersion: v1
kind: Secret
metadata:
 name: secret-to-test
type: Opaque
data:
  myencsecret: c2VjcmV0dG90ZXN0</pre></li>
				<li>Create the Secret:<pre><strong class="bold">kubectl apply -f secret_to_test.yaml</strong></pre></li>
				<li>With our Secret created, let's check if it is encrypted in <code>etcd</code> by directly querying it. You shouldn't need to directly query <code>etcd</code> very often, but if you have access to the certificates used to bootstrap the cluster, it is an easy process:<pre><code>k8s:enc:kms:v1:azurekmsprovider</code>.</p></li>
				<li>Now, check to see if the Secret is correctly decrypted (it will still be encoded) via <code>kubectl</code>:<pre><strong class="bold">&gt; kubectl get secrets secret-to-test -o yaml</strong></pre></li>
			</ol>
			<p>The output should be <code>myencsecret: c2VjcmV0dG90ZXN0</code>, which is our unencrypted, encoded Secret value:</p>
			<pre>&gt; echo 'c2VjcmV0dG90ZXN0' | base64 --decode
&gt; secrettotest</pre>
			<p>Success!</p>
			<p>We now have encryption running on our cluster. Let's find out how to remove it.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor161"/>Disabling cluster encryption</h2>
			<p>We can also remove <a id="_idIndexMarker332"/>encryption from our Kubernetes resources fairly easily.</p>
			<p>First, we need to restart the Kubernetes API server with a blank encryption configuration YAML. If you self-provisioned your cluster, this should be easy, but on EKS or AKS, this isn't possible manually. You'll need to follow the cloud provider-specific documentation on how to disable encryption.</p>
			<p>If you've self-provisioned your cluster or used a tool such as Kops or Kubeadm, then you can restart your <code>kube-apiserver</code> process on all master nodes with the following <code>EncryptionConfiguration</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">encryption-reset.yaml</p>
			<pre>apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - identity: {}</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Note that the identity provider does not need to be the only provider listed, but it does need to be first, since as we mentioned previously, Kubernetes uses the first provider to encrypt new/updated objects in <code>etcd</code>.</p>
			<p>Now, we will <a id="_idIndexMarker333"/>manually recreate all our Secrets, upon which point they will automatically use the identity provider (unencrypted):</p>
			<pre>kubectl get secrets --all-namespaces -o json | kubectl replace -f -</pre>
			<p>At this point, all of our Secrets are unencrypted!</p>
			<h1 id="_idParaDest-159"><a id="_idTextAnchor162"/>Summary</h1>
			<p>In this chapter, we looked at the methods Kubernetes provides for injecting application configuration. First, we looked at some best practices for configuring containerized applications. Then, we reviewed the first method that Kubernetes gives us, ConfigMaps, along with several options for creating and mounting them to Pods. Finally, we looked at Secrets, which when encrypted are a more secure way to handle sensitive configurations. By now, you should have all the tools you need to provide secure and insecure configuration values to your application.</p>
			<p>In the next chapter, we'll delve into a topic we already touched on by mounting our Secrets and ConfigMaps – the Kubernetes volume resource and, more generally, storage on Kubernetes.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor163"/>Questions</h1>
			<ol>
				<li value="1">What are the differences between Secrets and ConfigMaps?</li>
				<li>How are Secrets encoded?</li>
				<li>What is the major difference between creating a ConfigMap from a regular file, and creating one from an environment file?</li>
				<li>How can you make Secrets secure on Kubernetes? Why aren'<a id="_idTextAnchor164"/>t they secure by default?</li>
			</ol>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor165"/>Further reading</h1>
			<ul>
				<li>Info on data encryption configuration for Kubernetes can be found in the official documentation at <a href="https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/">https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/</a>.</li>
			</ul>
		</div>
	</body></html>