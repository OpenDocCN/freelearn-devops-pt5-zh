<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Managing Environments</h1></div></div></div><p>Most organizations start with a single environment while building their infrastructures. However, as the complexity grows, it is imperative that we have a workflow that involves writing code and testing it in development environments, followed by an intensive QA cycle to make sure that the code is tested for stability in the staging, or preproduction, environment before we finally release it to production. In order to simulate a real-world behavior, these environments have to run identical stacks of applications, but most likely at different scales. For example, staging will be a small-scale replica of production with fewer servers, and most commonly, development environments would run on individual workstations in virtualized environments. Even though all these environments run an identical application stack, they have to be isolated from each other and must have environment-specific configurations, explained as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The applications in the <code class="literal">dev</code> group should not be pointing at databases in staging and vice versa</li><li class="listitem" style="list-style-type: disc">A production environment may have its own package repository</li><li class="listitem" style="list-style-type: disc">A staging environment may run a web server on port <code class="literal">8080</code>, whereas all other environments run it on port <code class="literal">80</code></li></ul></div><p>With roles, we could create a modular code to configure these environments identically for all environments. Another important property of Ansible is its ability to separate code from data. Using these two in combination, we could model the infrastructure in a way that we would be able to create environment-specific configurations without having to modify the roles. We would be able to create them just by providing the variables from different places. Let's take a look at the following screenshot:</p><div><img src="img/B03800_09_01.jpg" alt="Managing Environments"/></div><p>The preceding diagram portrays three different environments, which are dev, stage, and production, within the same organization. All three run the same application stack, which involves a load balancer, web servers, and database servers. However, the two things to note here are that:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Each environment has a different scale based on which host can be configured to run one or more roles (for example, <code class="literal">db</code> plus <code class="literal">www</code>).</li><li class="listitem" style="list-style-type: disc">Each environment is isolated from the other. A web server in a production environment will not connect to a database in staging, and vice versa.</li></ul></div><p>In this chapter, we are going to cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Managing multiple environments with Ansible</li><li class="listitem" style="list-style-type: disc">Separating inventory files per environment</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">group_vars</code> and <code class="literal">host_vars</code> groups to specify environment-specific configurations</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Approaches for managing environments</h1></div></div></div><p>You have already learned <a id="id266" class="indexterm"/>about the need to create different environments with identical roles, but with different data. At the time of writing this, more than one approach exists for managing such multiple environment scenarios with Ansible. We are going to discuss two approaches here, and you can use your best judgment to pick either of the two or create your own approach. There is no explicit way to create an environment, but the following are the built-in features of Ansible, which could come in handy:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The use of an inventory to group together hosts that belong to one environment and isolate them from the hosts in other environments</li><li class="listitem" style="list-style-type: disc">The use of inventory variables, such as the <code class="literal">group_vars</code> and <code class="literal">host_vars</code> groups, to provide environment-specific variables</li></ul></div><p>Before we proceed, it would be useful to review the inventory groups, variables, and precedence rules that are applicable to them.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec54"/>The inventory groups and variables</h2></div></div></div><p>You have already learned learned that the <a id="id267" class="indexterm"/>Ansible inventory follows an INI style configuration, where <a id="id268" class="indexterm"/>hosts are grouped together with group tags enclosed in square brackets, as shown in the following figure:</p><div><img src="img/B03800_09_02.jpg" alt="The inventory groups and variables"/></div><p>The inventory variables can then be specified so that they match these group names using <code class="literal">group_vars</code> or match specific hosts in the <code class="literal">host_vars</code> files. Apart from these group names, there is a provision to specify default variables for the <code class="literal">group_vars</code> and <code class="literal">host_vars</code> files using a <a id="id269" class="indexterm"/>file named "<code class="literal">all</code>", which gives rise to the following structure:</p><div><img src="img/B03800_09_03.jpg" alt="The inventory groups and variables"/></div><p>In such a case, if you specify <a id="id270" class="indexterm"/>the same variable in the <code class="literal">all</code> and <code class="literal">webserver</code> files, the one variable that is more specific will take precedence. What this means is, if you define a variable in '<code class="literal">all</code>' and define it again in the '<code class="literal">webserver</code>' group under <code class="literal">group_vars</code>, the value of the parameters will be set to the one defined in '<code class="literal">webserver</code>', which is more specific. This is the behavior that we exploit in the approaches, which are as follows.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec55"/>Approach 1 – using nested groups in an inventory</h2></div></div></div><p>In addition to being <a id="id271" class="indexterm"/>able to create groups using the INI style, Ansible supports nested groups, where a complete group can be part of another parent group. The first approach is based on this feature and is discussed step by step, as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an environment directory to store environment-specific inventory files. It's a good idea to name them after the environments. Add hosts that are specific to that environment and group them. A group can be of any criteria, such as a role, location, server racks, and so on. For example, create a '<code class="literal">webservers</code>' group to add all the Apache web servers, or a group called '<code class="literal">in</code>' to add all the hosts belonging to that location.</li><li class="listitem">Add a parent group named after the environment name, such as, production, development, staging, and so on, and include all other groups that belong to that environment as a child. Each of these in turn include a group of hosts, for example:<div><pre class="programlisting">[dev:children]
  webservers
  databases</pre></div></li><li class="listitem">Now, create the <a id="id272" class="indexterm"/>common/default group variables in the <code class="literal">group_vars/all</code> file. These variables then can be overridden from the environment-specific files.</li><li class="listitem">To specify the environment-specific variables, create the <code class="literal">group_vars/{{env}}</code> file, which is shown as follows:<div><pre class="programlisting">group_vars
  |_ all
  |_ dev
  |_ stage</pre></div></li></ol></div><p>This is also going to override the variables in the <code class="literal">all</code> group. The following diagram shows the file structure created with this approach:</p><div><img src="img/B03800_09_04.jpg" alt="Approach 1 – using nested groups in an inventory"/></div><p>Once this has been created, it's just a matter of calling the environment-specific inventory with the <code class="literal">ansible-playbook</code> command run.</p><p>For example, let's <a id="id273" class="indexterm"/>take a look at the following command:</p><div><pre class="programlisting">
<strong>$ ansible-playbook -i environments/dev site.yml</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec56"/>Approach 2 – using environment-specific inventory variables</h2></div></div></div><p>The second <a id="id274" class="indexterm"/>approach does not require nested groups and relies on the following two features of Ansible:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">-i</code> option of Ansible-playbook also accepts a directory that can contain one or more inventory files</li><li class="listitem" style="list-style-type: disc">The <code class="literal">host</code> and <code class="literal">group</code> variables can be relative to the inventory files in addition to the <code class="literal">group_vars</code> and <code class="literal">host_vars</code> groups in the root of the Ansible repository</li></ul></div><p>This approach will create completely isolated variable files for each environment. The file structure we created is portrayed in the following diagram:</p><div><img src="img/B03800_09_05.jpg" alt="Approach 2 – using environment-specific inventory variables"/></div><p>The following is <a id="id275" class="indexterm"/>the step-by-step method used for this approach:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an environment directory in the root of the Ansible repository. Under this, create one directory per environment.</li><li class="listitem">Each of the environment directories contain two things:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A host's inventory.</li><li class="listitem" style="list-style-type: disc">Inventory variables, for example, <code class="literal">group_vars</code> and <code class="literal">host_vars</code>. To make environment-specific changes, <code class="literal">group_vars</code> is relevant to us.</li></ul></div></li><li class="listitem">Each environment contains its own <code class="literal">group_vars</code> directory, which in turn can have one or more files, including the <code class="literal">all</code> file as default. No two environments share these variables with others.</li></ol></div><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>
<strong>Caution</strong>: In addition to the environment-specific <code class="literal">group_vars</code> group, it's possible to use the <code class="literal">group_vars</code> file residing on top of the Ansible-playbook repository. However, it's recommended that you don't use it with this approach, as environment-specific changes are overridden by the values in the playbook <code class="literal">group_vars</code> if they are same.</p></div></div><p>With this approach, the <a id="id276" class="indexterm"/>playbook can be launched specific to an environment as:</p><div><pre class="programlisting">
<strong>$ ansible-playbook -i environments/dev site.py</strong>
</pre></div><p>Here, <code class="literal">environments/dev</code> is a directory.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec67"/>Creating a development environment</h1></div></div></div><p>After learning about <a id="id277" class="indexterm"/>how to manage environments, let's try it out by refactoring our existing code and create a dev environment. To test it, let's create a variable called "<code class="literal">env_name</code>" and change the default page of Nginx to <a id="id278" class="indexterm"/>dynamically use this variable and print the environment name. We will then try to override this variable from the environment. Let's take a look at the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Let's begin by setting the default variable:<div><pre class="programlisting">#group_vars/all
env_name: default</pre></div></li><li class="listitem">Then, change the Nginx task to use a template instead of a static file, so make the following modification in the <code class="literal">roles/nginx/tasks/configure.yml</code> file:<div><pre class="programlisting"> - name: create home page for default site
    copy: src=index.html dest=/usr/share/nginx/html/index.html</pre></div><p>Modify it into the following code:</p><div><pre class="programlisting"> - name: create home page for default site
   template:
     src: index.html.j2
     dest: /usr/share/nginx/html/index.html</pre></div></li><li class="listitem">Let's now try running the playbook without creating the environment:<div><pre class="programlisting">
<strong>$ ansible-playbook -i customhosts www.yml</strong>
</pre></div></li><li class="listitem">After the <a id="id279" class="indexterm"/>run is complete, let's check the <a id="id280" class="indexterm"/>default web page:<div><img src="img/B03800_09_06.jpg" alt="Creating a development environment"/></div></li><li class="listitem">It prints the value of the variable that we set from the <code class="literal">group_vars/all</code> file, the default value.</li><li class="listitem">Let's now create a file that would allow us to manage a <code class="literal">dev</code> environment. Since we are going to use the same set of hosts, we could just convert our existing inventory to dev and add a parent group after the name of the environment:<div><pre class="programlisting">
<strong>$ mkdir environments/</strong>
<strong>$ mv customhosts environments/dev </strong>
<strong>  [ edit  environments/dev ]</strong>
</pre></div></li><li class="listitem">Add all the groups to the <code class="literal">dev</code> environment as:<div><pre class="programlisting">[dev:children]
db
www
lb</pre></div><p>The inventory file is shown as follows and we've to make the following changes:</p><div><ol class="orderedlist arabic"><li class="listitem">Now, let's create a <code class="literal">group_vars</code> file for the <code class="literal">dev</code> environment and override the environment name:<div><pre class="programlisting">  #file: environments/dev
env_name: dev</pre></div></li><li class="listitem">This <a id="id281" class="indexterm"/>time, we are going to <a id="id282" class="indexterm"/>run the playbook as:<div><pre class="programlisting">
<strong>$ ansible-playbook -i environments/dev www.yml</strong>
</pre></div></li></ol></div><p>We'll see the following screenshot as the output:</p><div><img src="img/B03800_09_08.jpg" alt="Creating a development environment"/></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec68"/>Review questions</h1></div></div></div><p>Do you think you've understood this chapter well enough? Try answering the following questions to test your understanding:</p><div><ol class="orderedlist arabic"><li class="listitem">How do you specify multiple host inventories for the same environment?</li><li class="listitem">If you define a variable in the <code class="literal">environments/dev/group_vars/all</code> file and the same in the <code class="literal">group_vars/all</code> file, which one will take precedence?</li><li class="listitem">How do you create a group of groups in a host inventory file?</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec69"/>Summary</h1></div></div></div><p>In this chapter, you learned how to create multiple environments that map to the software development workflow or the phases. We started with a brief overview of inventory groups and inventory variables, specifically, the <code class="literal">group_vars</code> file. This was followed by the two approaches used to manage environments. Finally, we refactored our code, went on to create the <code class="literal">dev</code> environment, and tested it by overriding one variable from the environment. In the next chapter, you are going to learn about infrastructure orchestration and how Ansible shines when it comes to orchestrating complex infrastructure workflows, zero downtime deployments, and so on.</p></div></body></html>