- en: Chapter 9.  Secure Your AWS Environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is unsurprisingly a very hot topic in *The Cloud Computing - should
    you be doing it? debate.*
  prefs: []
  type: TYPE_NORMAL
- en: On one side we have the *my-hardware-is-my-castle* group of people, who find
    it deeply unnatural to even think of delegating your compute environment to some
    abstract entity that assures you that you own the capacity of *X* number of machines
    at any given time, but which you cannot see or touch. Not to mention the question
    of your data.
  prefs: []
  type: TYPE_NORMAL
- en: On the other, we find the people who do not really mind the mystical concept
    of the cloud at all. Their main interest is in having instant access to somewhat
    unlimited amount of compute resources at a reasonable cost. Unfortunately, they
    might occasionally concentrate too much on getting a job done quickly, ignoring
    some valid, healthy concerns that the former group puts forward.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is the middle ground - those of us who recognize the sacrifices one
    has to accept when moving to the cloud as well as the various solutions to make
    up for those. That is to say, with well-designed applications plus carefully planned-out
    architecture, your environment can remain adequately secure regardless of the
    underlying type of hosting platform.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to examine a few of these solutions and practices in attempt to
    make our AWS environment more secure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing access using IAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VPC security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EC2 security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security auditing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us begin.
  prefs: []
  type: TYPE_NORMAL
- en: Managing access using IAM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*AWS Identity and Access Management (IAM) is a web service that helps you securely
    control access to AWS resources for your users. You use IAM to control who can
    use your AWS resources (authentication) and what resources they can use and in
    what ways (authorization).*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ref: [http://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html](http://docs.aws.amazon.com/IAM/latest/UserGuide/introduction.html)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: We will be using IAM for managing access (be it user or application) to services
    under our AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Securing the root account
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a new AWS account is opened, it comes with a single user (the account owner)
    also referred to as the **root login**. This almighty user has all the powers,
    including the option of terminating the AWS account. For this reason, it is often
    advised that the root login is only used for high-level account management purposes
    while any day-to-day operations are done via IAM user accounts.
  prefs: []
  type: TYPE_NORMAL
- en: We shall follow this recommendation, so the very first thing we do after registering
    an AWS account is to login as **root**, disable any unnecessary authentication
    mechanisms and create ourselves a lower-privileged IAM user account.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us browse to the AWS Console (ref: [https://console.aws.amazon.com/console/home](https://console.aws.amazon.com/console/home)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the root account](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Notice the small print underneath the **Sign In** button. This is the link
    we need to follow in order to access the root account, which takes us to a slightly
    different login page as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the root account](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here, use your main Amazon credentials; you should see the familiar Console
    page. click on the name in the top-right corner:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the root account](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choosing **Security Credentials** takes us to our root account security options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the root account](img/image_09_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enable **Multi-Factor Authentication (MFA);** there really isn't a good reason
    not to. You could purchase a hardware token device or simply use an app on your
    phone such as the **Google Authenticator**.
  prefs: []
  type: TYPE_NORMAL
- en: Delete the keys under **Access Keys**. These are used for API access, which
    you are very likely not going to need for account management tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, click on the **Account Settings** link on the left, to update the current
    password policy. With the various password management tools available today, choosing
    a complex password and changing it often is no longer an inconvenience, so go
    crazy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the root account](img/image_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the same page, we can disable any regions we are not going to be using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the root account](img/image_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now we proceed to create the IAM accounts for daily AWS usage. We will organize
    our users into groups. We start with a user in a group which has administrator
    privileges, which can then be used to manage almost all aspects of the AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: On the left, select **Groups** and create a new group, granting it administrator
    access. Then under **Users**, create an account for yourself and make it a member
    of that group.
  prefs: []
  type: TYPE_NORMAL
- en: 'During the user creation process you would have had the option to create API
    access keys (you could also do it at a later stage too), which are useful if you
    are planning to use the AWS CLI or programmatic access in general. Once created,
    select the user and switch to the **Security Credentials** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Securing the root account](img/image_09_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here you have the option to create an **Access Keys** pair, if you did not do
    so earlier, as well as set a password for using the AWS Console. As mentioned
    earlier, you should take the opportunity to enable **MFA** (to take this a step
    further, have a look at [http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_configure-api-require.html](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_mfa_configure-api-require.html)).
    Also if you are planning to use the CodeCommit service over SSH, this is where
    you upload your public key.
  prefs: []
  type: TYPE_NORMAL
- en: This is it, from now on you can login to the AWS Console using the username
    and password of the IAM account you just created, keeping the root for special
    occasions.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note for those who might already maintain a user database external
    to AWS, there are ways to integrate it using **Federation**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more details, see either of these links: [https://aws.amazon.com/iam/details/manage-federation](https://aws.amazon.com/iam/details/manage-federation)
    [http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers.html](http://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles_providers.html)'
  prefs: []
  type: TYPE_NORMAL
- en: VPC security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have deployed your resources in a VPC, you are already moving in the
    right direction. Here we are mostly going to concern ourselves with network security
    and the tools or features a VPC provides for enhancing it.
  prefs: []
  type: TYPE_NORMAL
- en: Security Groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These represent our first layer of defense as stated in the AWS documentation.
    **Security Groups** (**SG**) get assigned to EC2 instances (generally speaking)
    and provide a type of stateful firewall, which supports allow rules only.
  prefs: []
  type: TYPE_NORMAL
- en: They are very flexible and an EC instance can have multiple such groups assigned
    to it. The rules can be based on host IP addresses, CIDRs or even on other Security
    Groups, for example, allow inbound `HTTP:80` from group ID `sg-12345`.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, within a VPC we would create an SG per role, such as **web server**,
    **db**, **cache**. Instances of the same component would then be assigned the
    respective SG, thus regulating traffic between the different components of a platform.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is often tempting to allow traffic based on the VPC CIDR address, resting
    on the fact that the VPC is largely an isolated environment. Resist that as much
    as possible and limit access to components that actually need it.
  prefs: []
  type: TYPE_NORMAL
- en: The db SG should allow traffic from/to the web server SG, but possibly not from
    the cache one.
  prefs: []
  type: TYPE_NORMAL
- en: Network ACLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second layer comes in the form of Network ACLs.
  prefs: []
  type: TYPE_NORMAL
- en: The ACLs are stateless, they apply to the underlying subnet that an instance
    lives in and their rules are evaluated based on priority, just like an old fashioned
    firewall. As a bonus, you can also set deny policies.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Network ACLs sit at the edge of the VPC, hence are evaluated before traffic
    reaches any Security Groups. This feature plus the ability to set deny rules make
    them very suitable for reacting to potential DDOS threats.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, both types of traffic management have their place in our VPC security
    design. ACLs should store a set of broader, less frequently changing rules, complemented
    by flexible Security Groups for fine-grained control.
  prefs: []
  type: TYPE_NORMAL
- en: VPN gateway
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If it so happens that you are using a VPC as an extension to your on-premise
    infrastructure, it would make a lot of sense to have the two sides more tightly
    connected.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of restricting external access via Security Groups or ACLs, you could
    create a secure VPN channel, benefiting from the implied encryption.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can connect your VPC to your office network using either a hardware or
    a software VPN solution (ref: [http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpn-connections.html](http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/vpn-connections.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more demanding use-cases, one could even route their VPN traffic over a
    high-speed direct link to AWS using the AWS Direct Connect service (ref: [http://docs.aws.amazon.com/directconnect/latest/UserGuide/Welcome.html](http://docs.aws.amazon.com/directconnect/latest/UserGuide/Welcome.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: VPC peering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a similar situation, where instead of your office network you have another
    VPC which needs to communicate with your, let us call it primary one, you could
    use VPC peering:'
  prefs: []
  type: TYPE_NORMAL
- en: '*A VPC peering connection is a networking connection between two VPCs that
    enables you to route traffic between them using private IP addresses. Instances
    in either VPC can communicate with each other as if they are within the same network.
    You can create a VPC peering connection between your own VPCs, or with a VPC in
    another AWS account within a single region.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*AWS uses the existing infrastructure of a VPC to create a VPC peering connection;
    it is neither a gateway nor a VPN connection, and does not rely on a separate
    piece of physical hardware. There is no single point of failure for communication
    or a bandwidth bottleneck.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ref: [http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide/vpc-peering-overview.html](http://docs.aws.amazon.com/AmazonVPC/latest/PeeringGuide/vpc-peering-overview.html)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Your VPCs will be able to communicate directly (within the same region) so you
    will not need to expose any services that do not explicitly need to be exposed.
    In addition, you can conveniently keep using private addresses for communication.
  prefs: []
  type: TYPE_NORMAL
- en: EC2 security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving deeper into our VPC, we are now going to look at ways to enhance the
    security around our EC2 instances.
  prefs: []
  type: TYPE_NORMAL
- en: IAM Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**IAM EC2 Roles** are the recommended way to grant your application access
    to AWS services.'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, let us assume we had a web app running on our web server EC2
    instance and it needs to be able to upload assets to S3.
  prefs: []
  type: TYPE_NORMAL
- en: A quick way of satisfying that requirement would be to create a set of IAM access
    keys and hardcode those into the application or its configuration. This however
    means that from that moment on it might not be very easy to update those keys
    unless we perform an app/config deployment. Furthermore, we might for one reason
    or another end up re-using the same set of keys with other applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The security implications are evident: reusing keys increases our exposure
    if those get compromised and having them hardcoded greatly increases our reaction
    time (it takes more effort to rotate such keys).'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to the preceding method would be to use Roles. We would create
    an EC2 Role, grant it write access to the S3 bucket and assign it to the web server
    EC2 instance. Once the instance has booted, it is given temporary credentials
    which can be found in its metadata and which get changed at regular intervals.
    We can now instruct our web app to retrieve the current set of credentials from
    the instance metadata and use those to carry out the S3 operations. If we were
    to use the AWS CLI on that instance, we would notice that it fetches the said
    metadata credentials by default.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Roles can be associated with instances only at launch time, so it is a good
    habit to assign one to all your hosts even if they do not need it right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'Roles can be used to assume other roles, making it possible for your instances
    to temporarily escalate their privileges by assuming a different role within your
    account or even across AWS accounts (ref: [http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html](http://docs.aws.amazon.com/STS/latest/APIReference/API_AssumeRole.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: SSH access
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common way to interact with an EC2 instance would be over SSH. Here
    are a couple of ideas to make our SSH sessions even more secure.
  prefs: []
  type: TYPE_NORMAL
- en: Individual keys
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a vanilla EC2 instance is launched it usually has a set of PEM keys associated
    with it to allow initial SSH access. If you also work within a team, my recommendation
    would be not to share that same key pair with your colleagues.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, as soon as you, or ideally your configuration management tool, gain
    access to the instance, individual user accounts should be created and public
    keys uploaded for the team members (plus `sudo` access where needed). Then the
    default `ec2-user` account (on Amazon Linux) and PEM key can be removed.
  prefs: []
  type: TYPE_NORMAL
- en: Entrypoint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regardless of the purpose that an EC2 instance serves, it is rarely the case
    that you must have direct external SSH access to it.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning public IP addresses and opening ports on EC2 instances is often an
    unnecessary exposure in the name of convenience and somewhat contradicts the idea
    of using a VPC in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: SSH can unarguably be useful however. So, to maintain the balance between the
    forces, one could setup an SSH gateway host with a public address. You would then
    restrict access to it to your home and/or office network and permit SSH connections
    from that host towards the rest of the VPC estate.
  prefs: []
  type: TYPE_NORMAL
- en: The chosen node becomes the administrative entry point of the VPC.
  prefs: []
  type: TYPE_NORMAL
- en: ELBs everywhere
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Latency is of importance. You will find brilliant engineering articles online
    from expert AWS users who have put time and effort into benchmarking ELB performance
    and side-effects.
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps not surprisingly their findings show that there is a given latency penalty
    with using an ELB, as opposed to serving requests directly off of a backend web
    server farm. The other side to this however is the fact that such an additional
    layer, be it an ELB or a cluster of custom HAProxy instances, acts as a shield
    in front of those web servers.
  prefs: []
  type: TYPE_NORMAL
- en: With a balancer at the edge of the VPC, web server nodes can remain within the
    private subnet which is not a small advantage if you can afford the said latency
    trade-off.
  prefs: []
  type: TYPE_NORMAL
- en: HTTPS by default
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services like the **AWS Certificate Manager**, make using SSL/TLS encryption
    even easier and more affordable. You get the certificates plus automatic renewals
    for free (within AWS).
  prefs: []
  type: TYPE_NORMAL
- en: Whether traffic between an ELB and the backend instances within a VPC should
    be encrypted is another good question, but for now please do add a certificate
    to your ELBs and enforce HTTPS where possible.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypted storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logically, since we are concerned with encrypting our HTTP traffic, we should
    not ignore our data at rest.
  prefs: []
  type: TYPE_NORMAL
- en: The most common type of storage on AWS must be the EBS volume with S3 right
    behind it. Each of the two services supports a strong and effortless implementation
    of encryption.
  prefs: []
  type: TYPE_NORMAL
- en: EBS volumes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, it should be noted that not all EC2 instance types support encrypted
    volumes. Before going any further, please consult this table: [http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html#EBSEncryption_supported_instances)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, let us see what does get encrypted and how:'
  prefs: []
  type: TYPE_NORMAL
- en: '*When you create an encrypted EBS volume and attach it to a supported instance
    type, the following types of data are encrypted:*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*- Data at rest inside the volume*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*- All data moving between the volume and the instance*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*- All snapshots created from the volume*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*The encryption occurs on the servers that host EC2 instances, providing encryption
    of data-in-transit from EC2 instances to EBS storage.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: ''
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*ref: [http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html](http://docs.aws.amazon.com/AWSEC2/latest/UserGuide/EBSEncryption.html)*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Note that the data gets encrypted on the servers that host EC2 instances, that
    is to say the hypervisors.
  prefs: []
  type: TYPE_NORMAL
- en: Naturally, if you wanted to go the extra mile you could manage your own encryption
    on the instance itself. Otherwise, you can be reasonably at peace knowing that
    each volume gets encrypted with an individual key which is in turn encrypted by
    a master key associated with the given AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of key management, AWS recommends that you create a custom key to replace
    the one which gets generated for you by default. Let us create a key and put it
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the IAM dashboard, select **Encryption Keys** on the left:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EBS volumes](img/image_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Choose to **Create Key** and fill in the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EBS volumes](img/image_09_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Then you can define who can manage the key:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EBS volumes](img/image_09_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As well as who can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EBS volumes](img/image_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the result should be visible back on that dashboard among the list of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EBS volumes](img/image_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now if you were to switch to the EC2 Console and choose to create a new EBS
    volume, the custom encryption key should be available as an option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![EBS volumes](img/image_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can now proceed to attach the new encrypted volume to an EC2 instance as
    per the usual process.
  prefs: []
  type: TYPE_NORMAL
- en: S3 objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: S3 allows the encryption of all, or a selection of objects within a bucket with
    the same **AES-256** algorithm as EBS here.
  prefs: []
  type: TYPE_NORMAL
- en: 'A few methods of key management are available (ref: [http://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html](http://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html)):'
  prefs: []
  type: TYPE_NORMAL
- en: You can import your own, external set of keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the KMS service to generate custom keys within AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the S3 service default (unique) key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encrypting existing data can be done on the folder level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![S3 objects](img/image_09_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'or by selecting individual files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![S3 objects](img/image_09_015.jpg)'
  prefs: []
  type: TYPE_IMG
- en: New data is encrypted on demand by either specifying a header (`x-amz-server-side-encryption`)
    in the `PUT` request or by passing any of the `--sse` options if using the AWS
    S3 CLI.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to deny any upload attempts which do not specify encryption
    by using a bucket policy (ref: [http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html](http://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: OS updates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you follow any security bulletins, you would have noticed the frequency with
    which new security flaws are being published. So, it is probably not much of an
    exaggeration to state that OS packages become obsolete days if not hours after
    a fully up-to-date EC2 instance has been provisioned. And unless the latest vulnerability
    is affecting BASH or OpenSSL, we tend to take comfort in the fact that most of
    our hosts reside within an isolated environment (such as a VPC), postponing updates
    over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: I believe we all agree this is a scary practice, which likely exists due to
    the anxiety that accompanies the thought of updating live, production systems.
    There is also a legitimate degree of complication brought about by services such
    as **Auto Scaling**, but this can be turned to an advantage. Let us see how.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll separate a typical EC2 deployment into two groups of instances: *static(non-autoscaled)*
    and *autoscaled*. Our task is to deploy the latest OS updates to both.'
  prefs: []
  type: TYPE_NORMAL
- en: In the case of static instances, where scaling is not an option due to some
    application specific or other type of limitation, we will have to resort to the
    well-known approach of first testing the updates in a completely separate environment
    then updating our static production hosts (usually one at a time).
  prefs: []
  type: TYPE_NORMAL
- en: 'With Auto Scaling however, OS patching can be a much more pleasant experience.
    You will recall Packer and Serverspec from previous chapters, where we used these
    tools to produce and test AMIs. A similar Jenkins pipeline can also be used for
    performing OS updates:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch the source AMI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a package update.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run tests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package a new AMI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Proceed with a phased deployment in production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To be comfortable with this process, we certainly need to put a decent amount
    of effort into ensuring that tests, deployment and rollback procedures are as
    reliable as practically possible, but then the end justifies the means.
  prefs: []
  type: TYPE_NORMAL
- en: Security auditing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS offers some good tools to help you keep your security policies in shape.
    Those will provide you with detailed audit reports including advice on how to
    improve any potential risk areas. In addition, you can configure service logs,
    so you get a better understanding what goes on within your deployment or AWS account
    as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: VPC Flow Logs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This service lets you capture information about the network traffic flowing
    through a VPC. The generated logs (unfortunately not quite real-time yet) contain
    src/dst port, src/dst address, protocol and other related details (for a full
    list please see: [http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/flow-logs.html#flow-log-records](http://docs.aws.amazon.com/AmazonVPC/latest/UserGuide/flow-logs.html#flow-log-records)).
    Apart from making for some pretty cool graphs to help identify network bottlenecks,
    the data can also be used for spotting unusual behavior. You could, for example,
    devise an in-house IDS by parsing the **Flow Logs** and forwarding any suspicious
    entries to your monitoring solution.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the VPC Console, select a VPC and switch to the **Flow Logs** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![VPC Flow Logs](img/image_09_016.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on **Create Flow Log**: you will need to fill a few parameters such as
    the IAM Role to be used (click on **Set Up Permissions** to create one) and the
    desired name of the **Destination Log Group**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a few minutes, the said log group should appear under the **Logs** section
    in the **CloudWatch** dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![VPC Flow Logs](img/image_09_017.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Within that group, you will find a log stream per EC2 instance (per network
    interface to be more precise) containing the captured traffic details.
  prefs: []
  type: TYPE_NORMAL
- en: CloudTrail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **CloudTrail** service is used for recording API activity within an AWS
    account. This includes requests done via the AWS Console, the CLI, the SDK or
    other services which issue calls on your behalf. The trail can be helpful for
    both security auditing and troubleshooting. Collected data is stored in S3 as
    encrypted objects, along with signed hashes to help ensure no tampering has occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enable the service, we go to the **CloudTrail** dashboard looking for a
    **Get Started** or an **Add new trail** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CloudTrail](img/image_09_018.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have chosen to collect data from all regions, storing it in a new S3 bucket
    with validation turned on. It is also possible to receive notifications on each
    log delivery, which can be useful for any further processing jobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on the dashboard, we click on the new trail to review its settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CloudTrail](img/image_09_019.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We enable encryption, then enter a name for the new KMS key. After approximately
    15 minutes, we should see events appearing under the API activity history dashboard
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![CloudTrail](img/image_09_020.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanding any of these entries would provide additional information such as
    the `access_key` used for the given API call and source IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the S3 bucket we would find two subfolders: **CloudTrail** which holds the
    API logs and **CloudTrail-Digest** for the file hashes.'
  prefs: []
  type: TYPE_NORMAL
- en: Trusted Advisor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Advisor** is enabled by default and periodically reviews your AWS account
    in order to identify any risk or areas of improvement.
  prefs: []
  type: TYPE_NORMAL
- en: 'It provides insights about cost, performance, security and HA as seen on the
    dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trusted Advisor](img/image_09_021.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are mainly interested in the security tips at this time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trusted Advisor](img/image_09_022.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Things appear to be green, following the steps we took to secure the root account
    earlier in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this view, weekly e-mail reports can be configured under the
    **Preferences** tab.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With **Config** we can track, inspect, and alert on resource changes that have
    occurred within our deployment.
  prefs: []
  type: TYPE_NORMAL
- en: When first enabled, the service performs an inventory of the resources found
    within the region and starts recording any changes.
  prefs: []
  type: TYPE_NORMAL
- en: Once a resource change is detected, for example a new rule is added to a security
    group, Config allows us to view a timeline with details about the current and
    any previous changes to that resource.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful feature is change inspection. Within Config we can define a
    set of rules to be evaluated against each resource change and alerts generated
    where necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Let us try both use-cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on **Get Started** on the Config dashboard, then choose a **Bucket name**
    and a **Role name**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS Config](img/image_09_023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'One the next page we can choose a few rules to get us started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS Config](img/image_09_024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have chosen to monitor CloudTrail, EBS volumes and MFA settings. Finalize
    the setup and go back to the **Rules** tab in the dashboard where we can add some
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note that at the time of writing, there is a cost of $2 per active rule
    per month.
  prefs: []
  type: TYPE_NORMAL
- en: Click on **Add rule** and look for the **restricted-ssh** rule which will monitor
    security groups for open SSH access. With the new rule in place, we can make a
    few resource changes and see how Config reacts to these. As an example, disable
    CloudTrail and create a temporary security group which allows incoming SSH from
    anywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a short while we can see the effect on the **AWS Config** dashboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS Config](img/image_09_025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can click on the **restricted-ssh** entry for more details. Locate the noncompliant
    entry in the list and click the **AWS Config** timeline icon:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS Config](img/image_09_026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can see the two recorded states of the resource. Clicking on the **Change**
    shows us what has happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![AWS Config](img/image_09_027.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we see the reason why our security group resource has been flagged as **noncompliant**.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the AWS-provided Config rules, you could write your own in the
    form of Lambda functions (ref: [http://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html](http://docs.aws.amazon.com/config/latest/developerguide/evaluate-config_develop-rules.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: Self pen testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here we examine self pen testing as an inexpensive alternative or as a preparation
    step prior to you hiring a third party for the official test (considering that
    each penetration testing iteration is usually chargeable).
  prefs: []
  type: TYPE_NORMAL
- en: The goal is a system which allows for on-demand and/or regular vulnerability
    scanning against our VPC deployment both internally and externally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two community projects that can help us with this task are **OpenVAS** (ref:
    [http://www.openvas.org](http://www.openvas.org)) and **OpenSCAP** (ref: [https://www.open-scap.org](https://www.open-scap.org)).'
  prefs: []
  type: TYPE_NORMAL
- en: A relatively easy way of setting up such an automated scanner would be to use
    a prebaked AMI and some user data. In essence, you would install either or both
    of the preceding frameworks on a vanilla EC2 instance and create an AMI out of
    it. Then launch a new instance of that AMI (perhaps per schedule) and, using user
    data, you would start the scanner, pass it the destination URI to be scanned,
    then e-mail any scan reports or save to S3.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scheduling is achieved using an Auto Scale Group, which simply launches a node,
    then terminates it after N hours (however long it takes to perform the scan).
    Alternatively, you could use CloudWatch events together with some Lambda functions
    (ref: [https://aws.amazon.com/premiumsupport/knowledge-center/start-stop-lambda-cloudwatch](https://aws.amazon.com/premiumsupport/knowledge-center/start-stop-lambda-cloudwatch)).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please note that vulnerability scanning or similar activity needs to be approved
    by AWS Support first (ref: [https://aws.amazon.com/forms/penetration-testing-request](https://aws.amazon.com/forms/penetration-testing-request)).'
  prefs: []
  type: TYPE_NORMAL
- en: Following the advice throughout this  chapter is one step towards creating a
    more secure environment, but we can by no means consider the job done. It has
    been said that security is a process, not a product and as such it should perhaps
    be a daily task on one's list.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you subscribe to relevant security feeds or mailing lists.
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS maintains a few of its own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/blogs/security](https://aws.amazon.com/blogs/security)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://aws.amazon.com/security/security-bulletins/](https://aws.amazon.com/security/security-bulletins/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://alas.aws.amazon.com/](https://alas.aws.amazon.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we covered some ideas on how to improve the overall security
    of an AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at AWS services which can be used for auditing and alerting on suspicious
    activity plus open-source tools that can be useful for regular vulnerability scanning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we will look at a list of popular (and less so) AWS tips
    and tricks.
  prefs: []
  type: TYPE_NORMAL
