- en: '*Chapter 13*'
  prefs: []
  type: TYPE_NORMAL
- en: Running Kubernetes in Public Clouds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two chapters, we looked at the various ways that we can create,
    configure, and interact with Kubernetes clusters on our local machines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to take our Kubernetes journey into the cloud by looking at
    what is involved in launching, configuring, and using Kubernetes in the following
    public cloud providers using both the web portals from each provider and also
    their command-line tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Microsoft Azure Kubernetes Service** (**AKS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine** (**GKE**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Elastic Kubernetes Service** (**EKS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DigitalOcean Kubernetes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have access to one or all of the cloud providers
    that we will be covering. As such, please be aware that launching these services,
    depending on your account, will incur costs. You should also remember to remove
    any resources once you have finished with them or that you understand the costs
    if you choose to leave them running for any length of time.
  prefs: []
  type: TYPE_NORMAL
- en: As with the previous chapters, I will be using my preferred operating system,
    which is macOS. As such, some of the supporting commands, which will be few and
    far between, may only apply to macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/336J7dE](https://bit.ly/336J7dE)'
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure Kubernetes Service (AKS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Microsoft has long been a supporter of running container workloads in Microsoft
    Azure. Originally, Microsoft started by offering the Azure Container Service,
    which supported three different container orchestrators: Kubernetes, Mesosphere
    DC/OS, and Docker Swarm.'
  prefs: []
  type: TYPE_NORMAL
- en: However, in October 2017, Microsoft announced that they would be replacing Azure
    Container Service with the newly developed Azure Kubernetes Service—this, as you
    may already have guessed, dropped support for Mesosphere DC/OS and Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, the service, which is a CNCF-certified Kubernetes hosting platform,
    has come on leaps and bounds, with a recent development being the general availability
    of Windows container support.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than go into any more detail on this subject, let''s get on and launch
    an AKS cluster. We will be covering two ways of doing this: using the Azure web
    portal and setting it up from your local machine using the Azure command-line
    tools. Let''s start with the Azure web portal.'
  prefs: []
  type: TYPE_NORMAL
- en: Launching a cluster using the web portal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start with, you need to be logged into the Azure web portal, which can be
    found at [https://portal.azure.com/](https://portal.azure.com/). Once logged in,
    enter `AKS` in the top search bar and click on the **Kubernetes services** item
    in the **Services** section of the search results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the page has loaded, you will be presented with a screen that looks like
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1: Ready to create the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_001.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1: Ready to create the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of you will have already guessed what the next step in launching our AKS
    cluster is going to be. That''s right: click on the **+ Add** button and select
    **Add Kubernetes cluster**. There are seven sections that we are going to be working
    through to launch our cluster, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Basics**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node pools**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Networking**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrations**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tags**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Review + create**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the **Basics**. Here, you will be asked for several pieces
    of information, beginning with the **Project details**. Here, we need to define
    which **Subscription** and **Resource Group** should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Choose your required subscription and then click on the **Create new** link
    under **Resource Group**. Enter the name of the resource group you would like
    your cluster to be placed—I have called mine **mastering-docker-aks-rg**.
  prefs: []
  type: TYPE_NORMAL
- en: Once those two bits of information have been entered, we can move on to the
    `1.15.10` at the time of writing).
  prefs: []
  type: TYPE_NORMAL
- en: 'The last piece of basic information is for the **Primary node pool**. Here,
    we can define the **Node size** and the **Node count**. By default, these are
    set to **Standard DS2 v2** and **3**—for testing purposes, let''s leave these
    as their default settings. To progress to the next step, click on the **Next:
    Node pools >** button.'
  prefs: []
  type: TYPE_NORMAL
- en: On the **Node pools** screen, we can add more pools—for example, if you wanted
    to run a Windows host pool alongside the Linux one that we are launching, then
    you can click on the **+ Add node pool** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you will be asked the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node pool name**: Name the new node pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OS type**: The underlying operating system that you want the new node pool
    to use. You have the choice of Linux or Windows.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node size**: The virtual machine size that the nodes in the new node pool
    should be.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node count**: The number of nodes that you want in the pool.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we are launching a test cluster, we do not need any additional node pools,
    so let's move on to the next set of options.
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual nodes** allow you to use **Azure Container Instances**, which we
    looked at in [*Chapter 10*](B15659_10_Final_JM_ePub.xhtml#_idTextAnchor277), *Running
    Docker in Public Clouds*. Leave this setting as **Disabled**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting **VM scale sets** as **Enabled** will allow us to scale our cluster
    up and down, so let''s click on the **Next: Authentication >** button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Authentication** settings allow you to configure how the Kubernetes cluster
    will be able to interact with and even launch other Azure services. For our cluster,
    leave these at their defaults and click on the **Next: Networking >** button.'
  prefs: []
  type: TYPE_NORMAL
- en: The **Networking** page has two different sets of options, the first being the
    **Network****Configuration**. Here, we have the option of choosing an existing
    **Virtual network** or creating one—for ease of use, let's stick with the defaults,
    which are already prefilled in for us, and move on to the **Network Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can again stick with the defaults, meaning that the only piece of information
    we need to provide is the **DNS name prefix**—I used **mastering-docker-aks**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Next: Integrations >** will take you to the options, where you
    can connect your AKS cluster to an **Azure Container Registry**, which we discussed
    in [*Chapter 3*](B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109)*, Storing & Distributing
    Images*. But as we are not using a system-assigned managed identity, this option
    is not available. The other integration we can configure is **Azure Monitor**.
    Leave these settings at their defaults, as we want a **Log Analytics workspace**
    set up for us.'
  prefs: []
  type: TYPE_NORMAL
- en: As our cluster is only temporary, you can click on the **Review + Create** button
    rather than adding the **Tags**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing that happens is that your configuration is validated. If there
    are any problems, you will not be allowed to proceed until the problem is fixed.
    If everything goes as planned, then you should be presented with something that
    looks like the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2: A validated configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.2: A validated configuration'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once validated, click on the **Create** button. Now would be a good time to
    grab a drink as a cluster could take anywhere from 10 to 20 minutes to deploy.
    Once deployed, you will see the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.3: The deployment has completed'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_003.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: The deployment has completed'
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on `kubectl` instance.
  prefs: []
  type: TYPE_NORMAL
- en: As Microsoft provides a shell built into Azure portal with both the Azure command-line
    tools and kubectl preinstalled; because we launched the cluster through the portal,
    we will use that.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Cloud Shell icon, which is the first of the icons in the top right
    of the screen after the search bar (it has **>_** on it). If you have used Cloud
    Shell before, then you will be logged straight in. If not, then follow the on-screen
    prompts.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two different flavors of Cloud Shell: **Bash** and **PowerShell**.
    For our purposes, you need to make sure you are using **Bash**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you are at Command Prompt, enter the following command, making sure that
    you update the resource group and cluster name if you have used different values
    to the ones I used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have run the command, you can test the connectivity to the cluster
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return three nodes, each with the version of Kubernetes that we
    selected when we first went to configure our cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Connecting kubectl to our AKS cluster using Cloud Shell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: Connecting kubectl to our AKS cluster using Cloud Shell'
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our cluster up and running, you can skip the next part of this section
    where we launch the cluster using the Azure command-line tools and go straight
    to launching an application.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a cluster using the command-line tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An alternative to launching the cluster through the Azure web portal is to
    use the Azure command-line tool. If you don''t already have it installed, then
    you can use the following instructions, starting with macOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Windows users can open a PowerShell prompt as the Administrator user and run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux users using Debian-based machines can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Linux users running Red-Hat-based operating systems can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the Azure CLI package installed, the first command you should
    run is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will prompt you to log in to your Azure account.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Please make sure that the account you are logging in to has the subscription
    that you want to launch your resources in as the default subscription—if it doesn't,
    go to [https://docs.microsoft.com/en-us/cli/azure/manage-azure-subscriptions-azure-cli](https://docs.microsoft.com/en-us/cli/azure/manage-azure-subscriptions-azure-cli)
    for details on how to change the active subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the Azure command-line tools installed and configured, we can
    launch our cluster. For macOS and Linux users, we can set some environment variables
    for values that we will be using through the cluster creation.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Windows users should replace the variables in the commands used to launch the
    cluster with the corresponding values from the following four variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the same values that we used in the last section, where we launched
    our cluster using the Azure web portal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step in launching the cluster is to create the resource group. To
    do this, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return a JSON file where the provisioning state should be `Succeeded`.
    Once the resource group has been created, we can launch our cluster by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'While the cluster is launching, you will see a screen that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![ Figure 13.5: Launching the cluster using the Azure CLI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.5: Launching the cluster using the Azure CLI'
  prefs: []
  type: TYPE_NORMAL
- en: Just like when the cluster was launched using the Azure web portal, it will
    take between 10 and 20 minutes to complete, so don't worry too much if you see
    the preceding output for a while—it just takes a little time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once completed, the final step is the same as when we launched the cluster
    using the Azure web portal. We need to configure kubectl to point towards the
    new launching cluster. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the configuration has been merged, you can run the following commands
    to check the connectivity with the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.6: Checking the cluster connectivity using kubectl'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: Checking the cluster connectivity using kubectl'
  prefs: []
  type: TYPE_NORMAL
- en: We should now have an AKS cluster in the same state as if it were launched using
    the Azure web portal, which means that we can now launch an application.
  prefs: []
  type: TYPE_NORMAL
- en: Launching an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we are no longer using our local machine to run Kubernetes, we can launch
    an application that is a little more resource-intensive. For this, we are going
    to be using the microservices demo created and maintained by Weave.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the application, you simply need to run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will create a namespace called **sock-shop** and then the resource that
    is used to make up the application, which is an e-commerce site selling socks.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a minute or two, you can run the following command to view the status
    of the pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This should display something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: Checking the status of the pods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: Checking the status of the pods'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once all of the pods are running, you can check the status of the services
    by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: Checking the status of the services'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: Checking the status of the services'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the application has been deployed, we need to expose it so that we
    can access it. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Once exposed, you can run the following command to get information on the endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the output, you are after the `LoadBalancer Ingress` and `Port`. See the
    following screenshot for an example output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: Getting information on the exposed service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_009.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: Getting information on the exposed service'
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering the `LoadBalancer Ingress` IP and `Port`—which for me was [http://52.191.99.154:8079/](http://52.191.99.154:8079/)—into
    a browser should open the store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10 – The Sock Shop application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_010.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.10 – The Sock Shop application
  prefs: []
  type: TYPE_NORMAL
- en: Click around the application—stick some socks in your basket, refresh pages,
    and so on. We are now going to take a look at the cluster in the Azure web portal.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you log in to the Azure web portal at [https://portal.azure.com/](https://portal.azure.com/)
    and then search for the name of your cluster in the search bar at the top of the
    page, you should be greeted with a page that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11 – Viewing the cluster in the Azure web portal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.11 – Viewing the cluster in the Azure web portal
  prefs: []
  type: TYPE_NORMAL
- en: 'If you then click on the **Monitor container** button, you will be taken to
    a **Cluster** overview. Once there, click on **Containers**. Adding a filter for
    the **sock-shop** namespace will just select the containers that are running in
    the pods for our application. Selecting one and then clicking the **View live
    data (preview)** button will stream the logs from the container to the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12 – Viewing the logs from the frontend container in the Azure
    web portal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.12 – Viewing the logs from the frontend container in the Azure web
    portal
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend having a click around some of the other tabs and options to
    get an idea of what else you can do with AKS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have finished with your AKS cluster, I recommend removing all of the
    resources created either through the Azure web portal or Azure CLI by deleting
    the resource groups. To do this, enter `Resource Groups` in the top search box
    and select the resource group related to your cluster. For example, as I launched
    my cluster, I have three resource groups, which I have highlighted in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13 – Finding the resource groups to delete'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_013.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.13 – Finding the resource groups to delete
  prefs: []
  type: TYPE_NORMAL
- en: To remove them, click on the resource group name, double-check the resources
    in there and then if you are happy, they contain just the resources for your test
    cluster click on the **Delete resource group** button and follow the on-screen
    instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure Kubernetes Service summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I am sure you will agree, launching the cluster was quite a straightforward
    process using both the Azure web portal and Azure CLI. Once launched and kubectl
    configured to interact with the cluster, the commands that were used to launch
    the application were pretty much the same as the ones that we used in [*Chapter
    12*](B15659_12_Final_JM_ePub.xhtml#_idTextAnchor394), *Discovering other Kubernetes
    options*.
  prefs: []
  type: TYPE_NORMAL
- en: The cluster that we launched would have a running cost of around $215 per month,
    with the only cost being for the virtual machine resource. Microsoft does not
    charge for the resources required for cluster management; if we want to add an
    uptime SLA to the cluster, we would add a further $73.00 per month.
  prefs: []
  type: TYPE_NORMAL
- en: Being able to run multiple node pools with a mixture of Linux and Windows containers
    is a big plus point for the service, as is its integration with Azure Monitor
    and the Azure Container Registry service. Add to this services such as Azure DevOps
    and **Azure Sentinel for Security information and event management** (**SIEM**),
    and you have quite a powerful platform.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we are going to move from Microsoft Azure to Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Google Kubernetes Engine (GKE)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The GKE, as you may have already guessed, is very tightly integrated with Google's
    Cloud platform. Rather than going into more detail on how Kubernetes started off
    life at Google, let's dive straight in and launch a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Going ahead, I am assuming that you already have a Google Cloud account and
    a project with billing enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a cluster using the web portal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once you are logged into [https://console.cloud.google.com/](https://console.cloud.google.com/),
    enter Kubernetes into the search box at the top of the page and select **Kubernetes
    Engine**. If you don''t have the service enabled for your project, it will automatically
    be enabled, and after a few seconds, you will be presented with a page that looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14 – The Kubernetes page in the Google Cloud web portal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_014.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.14 – The Kubernetes page in the Google Cloud web portal
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, as you might have already guessed, the first step to launching the cluster
    is to click on the **Create cluster** button. You will then be presented with
    quite a few options; however, we are going to use the defaults, other than the
    **Name**, which I am going to change to **mastering-docker-gke**. Once the name
    has been changed, click on the **Create** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.15 – Entering the cluster details'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_015.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.15 – Entering the cluster details
  prefs: []
  type: TYPE_NORMAL
- en: 'Launching the cluster will take around 10 minutes. Once it is created, you
    should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.16 – The cluster is ready'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_016.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.16 – The cluster is ready
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Microsoft Azure, Google Cloud has a shell built into the web interface,
    and the shell has `kubectl` and the `gcloud` command-line tool installed and configured.
    Open the shell by clicking on the `kubectl` accesses your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Update the name and zone if you used anything other than what we set it to.
    Once configured, you should be able to run both of the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'To test the connectivity, if everything has gone as planned, you should see
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.17 – Connecting kubectl to our cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_017.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.17 – Connecting kubectl to our cluster
  prefs: []
  type: TYPE_NORMAL
- en: Launching a basic cluster using the Google Cloud web portal is a really simple
    process; however, using the `gcloud` CLI is just as easy.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a cluster using the command-line tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `gcloud` command is provided by the Google Cloud SDK package. To install
    this on macOS using Homebrew and Cask, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If you are running Windows, then you can download the installer from [https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe](https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe).
  prefs: []
  type: TYPE_NORMAL
- en: 'Linux users running a Debian-based operating system need to run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Linux users running Red-Hat-based operating systems need to run the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the repository file is in place, you can install the package using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Should you have any problems with any of the preceding commands, a link for
    the quick starts for each of them containing common troubleshooting tips can be
    found in the further reading section of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once installed, you need to log in and then let the command-line tool know
    which project to use. You can do this by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you may have guessed, the project I am using is called **masteringdocker4**;
    you should update this to reflect your own project name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have `gcloud` configured, we can launch our cluster. To do this,
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a three-node cluster in the US Central 1c zone. Once launched,
    your kubectl will automatically be configured to communicate with the cluster,
    meaning that all you need to do is test connectivity by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show you something similar to the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.18 – Testing the connection to the Google Kubernetes Engine cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.18 – Testing the connection to the Google Kubernetes Engine cluster
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a Google Kubernetes Engine cluster up and running, we can now
    launch our application.
  prefs: []
  type: TYPE_NORMAL
- en: Launching an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we covered the launching of the application in detail in the *Microsoft
    Azure Kubernetes Service* section of this chapter, we are not going to go into
    much detail here, other than to say that you need to run the following commands
    to launch the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check the status of the pods and services by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once everything looks as if it''s up and running, you can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will expose the application. Once you have entered this, you can enter
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned before, to get information on the exposed service you need the
    `LoadBalancer Ingress` and `Port`. Stick them both in a browser (for example,
    I used `http://104.154.45.136:8079/`) and you should see that the Sock Shop is
    up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Going back to the Google Cloud web portal and clicking on **Workloads** within
    your cluster will show you a list of the nonsystem workload. Clicking on the frontend
    deployment will show you something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.19 – Viewing the deployment details'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.19 – Viewing the deployment details
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Container logs**, which can be found at the bottom of the preceding
    screen, will take you to a page where you can view the logs being generated by
    the workload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.20 – Viewing the logs for the frontend deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.20 – Viewing the logs for the frontend deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, spend a little time having a click around some of the other tabs and
    options to get an idea of what else you can do with GKE. Once you have finished
    spending some time getting to know GKE, you should remove all of the resources
    that were launched. To do this, simply select your cluster from the **Clusters**
    page of the **Kubernetes****Engine** section of the portal and then click on **Delete**.
    You will be given a warning before the cluster is removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.21 – Are you sure you want to delete the cluster?'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.21 – Are you sure you want to delete the cluster?
  prefs: []
  type: TYPE_NORMAL
- en: If you are happy to proceed, then click on **DELETE** and give it about 10 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: Google Kubernetes Engine summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am sure that you agree that the Google Kubernetes Service is another simple
    service to configure, and as you must now be noticing, once the cluster is up
    and running, interacting with it is a consistent experience. Again, Google offers
    deep integration with other Google Cloud services, such as its monitoring, databases,
    and load-balancing services.
  prefs: []
  type: TYPE_NORMAL
- en: Running the cluster at the specifications that we set up would cost around $150
    per month; however, $73 of that cost is the GKE cluster management fee, to run
    the cluster at the same specifications as the Microsoft Azure Kubernetes Service
    will cost around $220 per month, with the GKE cluster management fee staying the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: Both Googles and Microsoft Kubernetes offerings have been established for quite
    a while, so let's take a look at the last of the big three cloud providers' Kubernetes
    offerings and move onto Amazon Web Services
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Elastic Kubernetes Service (EKS)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next Kubernetes service we are going to take a look at is the Amazon Elastic
    Container Service for Kubernetes, or Amazon EKS for short. This is the most recently
    launched service of the three services we have covered so far. In fact, you could
    say that Amazon was very late to the Kubernetes party.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, the command-line tools for Amazon are not as user friendly as
    the ones we used for Microsoft Azure and Google Cloud. Because of this, we are
    going to be using a tool called `eksctl`, which was written by Weave, the same
    people who created the demo store we have been using. It has been adopted by Amazon
    as the official command client of EKS, as opposed to the commands built into their
    own client.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we are going to bypass the web-based portal and concentrate
    on `eksctl,` which itself makes use of the AWS command-line tools.
  prefs: []
  type: TYPE_NORMAL
- en: Launching a cluster using the command-line tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we install `eksctl`, we need to install the AWS command-line tools.
    To do this on macOS using Homebrew, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If you are a Windows user, then you can download the installer from [https://awscli.amazonaws.com/AWSCLIV2.msi](https://awscli.amazonaws.com/AWSCLIV2.msi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, Linux users can run the following commands to download and install
    the command-line tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once installed, you will need to configure your credentials. Unlike the `az`
    and `gcloud` commands, you need to log in to the AWS web portal to do this. Details
    on the steps you need to take can be found at [https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html](https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the AWS command-line tools installed and configured, you can
    proceed with installing `eksctl`, again starting with macOS and Homebrew:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'It is recommended that Windows users use Chocolatey:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, Linux users can download the precompiled binary straight from GitHub
    using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, you will be able to run the following command to create and
    configure your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once launched, you should see something like the following, which, as you can
    see, is quite descriptive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.22  – Launching the EKS cluster using eksctl'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.22 – Launching the EKS cluster using eksctl
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of the launch, `eksctl` will have configured your local `kubectl` context,
    meaning that you can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the cluster up and running, we can launch the demo store, just
    like we did previously.
  prefs: []
  type: TYPE_NORMAL
- en: Launching an application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You should be getting quite good at deploying the Sock Shop application now,
    so here is a recap of all of the commands you need:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that the **LoadBalancer Ingres** is actually a fully qualified
    domain rather than an IP address:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.23 – Viewing details on the exposed service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.23 – Viewing details on the exposed service
  prefs: []
  type: TYPE_NORMAL
- en: You might need to give it a few minutes for the DNS for the load balancer to
    update, but you should be able to use the URL and port. For my cluster, I went
    to http://a5fecbaee10a04cfaa19846e116081f8-624222238.eu-west-1.elb.amazonaws.com:8079
    to access the Sock Shop.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster information
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If I am honest, this section is pretty redundant as there isn't much information
    on the cluster exposed in the AWS web portal by default outside of the basic information
    on the VMs that make up the node cluster. Sure, you can enable some features in
    CloudWatch to start monitoring your cluster, but this is not done by default at
    the moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command will immediately delete the cluster for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: However, I recommend double-checking for any resources left over in your AWS
    web portal, just to make sure you don't get any unexpected bills.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Elastic Kubernetes Service summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As already mentioned, the Amazon Elastic Kubernetes Service was the last of
    the big three public cloud providers' Kubernetes-as-a-service offerings to launch,
    and in my personal opinion, it is the weakest of the three offerings.
  prefs: []
  type: TYPE_NORMAL
- en: While it is a CNCF-certified hosting platform, it simply doesn't feel as integrated
    or intuitive as the offerings from Microsoft and Google—everything just feels
    tacked on to the normally good AWS services; the same can also be said of the
    Amazon Container Service.
  prefs: []
  type: TYPE_NORMAL
- en: Costwise, the instances are charged at standard EC2 rates, and there is a charge
    of $0.10 per hour per Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Before we finish the chapter, let's look at one more Kubernetes offering, this
    time from DigitalOcean.
  prefs: []
  type: TYPE_NORMAL
- en: DigitalOcean Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we are nearing the end of the chapter, we are going to very quickly take
    a look at the Kubernetes offering from DigitalOcean, as it represents good value
    for money and is simple to configure. To start with, log in to your DigitalOcean
    web portal and under the **Manage** section of the right-hand menu, click on **Kubernetes**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.24 – Details of the DigitalOcean Kubernetes offering'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.24 – Details of the DigitalOcean Kubernetes offering
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the **Create a Kubernetes** **Cluster** button will take you to the
    **Create a cluster** page, from there just choose a datacenter region and scroll
    to the bottom of the page; DigitalOcean has some great defaults so we can skim
    past them. Once at the bottom, click on the **Create Cluster** button and wait.
    After around five minutes, your cluster will be available:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.25 – Viewing the newly created DigitalOcean Kubernetes cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.25 – Viewing the newly created DigitalOcean Kubernetes cluster
  prefs: []
  type: TYPE_NORMAL
- en: Now that the cluster is up and running, you can click on the `kubectl` configuration
    for your cluster, or, if you have it installed (see the further reading section
    for a link), you can use the `doctl` command to download and configure your local
    `kubectl` to talk to your newly created cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to do this is as follows; please make sure that you update the
    name at the end to match that of your own cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Once configured, you know what to do: launch the Sock Shop application using
    the same commands that we have been using throughout the chapter—well sort of;
    if you want to steam ahead and try to launch the application you would receive
    several errors. Go ahead and try it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The errors, which look like the following screenshot, are there because of
    changes to the API in the later version of Kubernetes that DigitalOcean launches
    by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.26 – Errors with the Sock Shop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.26 – Errors with the Sock Shop
  prefs: []
  type: TYPE_NORMAL
- en: 'Never fear though—this is easily resolved. First, let''s remove the namespace
    with the partly deployed application in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Once these are removed, we need to clone the Sock Shop repository and recreate
    the namespace. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to change directory to the Kubernetes deployment folder, update
    the definition files, and then launch the application. For this, we need to run
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, you can check the pods and services, expose the frontend, and get
    information on the exposed service using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: It may take a minute or two for the services to be exposed as a DigitalOcean
    load balancer is launched.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we return to the DigitalOcean web portal, let''s enable the advanced
    cluster metrics. To do this, we need to deploy another application. You can do
    this by running the following two commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Once installed, it will take a minute or two for the metrics to appear in the
    portal. You can find them by selecting your cluster and then clicking on the **Insights**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.27 – Viewing details on the cluster in the DigitalOcean web portal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 13.27 – Viewing details on the cluster in the DigitalOcean web portal
  prefs: []
  type: TYPE_NORMAL
- en: I would recommend having a click around the DigitalOcean web portal before you
    remove the cluster, as I am sure you will agree that the service is quite well
    integrated and comes at a bargain price. The three-node cluster we launched would
    cost just $30 per month to run!
  prefs: []
  type: TYPE_NORMAL
- en: You can terminate the cluster through the web portal. Also, make sure that you
    also remove the load balancer as this will remain once the cluster has been terminated
    to avoid unexpected costs at the end of the month.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at launching Kubernetes clusters in various clouds
    and running the same demo application in all of them. I am sure that by the end
    of the chapter you were quite bored of launching the same application over and
    over again; however, that was the point.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at four very different and traditionally incompatible cloud providers
    and deployed the same application using the same tools and commands across all
    four of them. Admittedly, we had to make some allowances for the different versions
    of Kubernetes being used, but for the most part, we didn't have to make any provider-specific
    allowances once we started working with `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is one of the key reasons why Kubernetes has become so popular: it truly
    does allow you to define and distribute your applications in a platform-agnostic
    way—even just a few years ago, being able to deploy an application locally and
    then across four public cloud providers using the same set of commands and configurations
    seemed impossible without a lot of complexity, which I am sure you will agree
    there has been none of in the last few chapters.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to go back to Docker and learn how to best
    secure your containers.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once our cluster launches, what command did we need to run to create the namespace
    for the Sock Shop store?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you find out the full details of the Load Balancer?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the official Amazon Elastic Kubernetes Service CLI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The product pages for each of the Kubernetes services can be found at the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Service:** [https://azure.microsoft.com/en-gb/services/kubernetes-service/](https://azure.microsoft.com/en-gb/services/kubernetes-service/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine:** [https://cloud.google.com/kubernetes-engine/](https://cloud.google.com/kubernetes-engine/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Elastic Container Service for Kubernetes:** [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DigitalOcean Kubernetes:** [https://www.digitalocean.com/products/kubernetes/](https://www.digitalocean.com/products/kubernetes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Quick starts for the various command-line tools used in the chapter can be
    found at the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Azure CLI:** [https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest](https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Google Cloud SDK:** [https://cloud.google.com/sdk/](https://cloud.google.com/sdk/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Command-Line Interface:** [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**eksctl, the official CLI for Amazon EKS:** [https://eksctl.io/](https://eksctl.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**doctl:** [https://github.com/digitalocean/doctl/](https://github.com/digitalocean/doctl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, for more details on the demo store, go to the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sock Shop:** [https://microservices-demo.github.io/](https://microservices-demo.github.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Section 3**: Best Practices'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take the skills learned from the previous chapters
    and cover how they can be used in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section comprises the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B15659_14_Final_JM_ePub.xhtml#_idTextAnchor787), *Securing Your
    Docker Environment*'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B15659_15_Final_JM_ePub.xhtml#_idTextAnchor823), *Docker Workflows*'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 16*](B15659_16_Final_JM_ePub.xhtml#_idTextAnchor922), *Next Steps
    with Docker*'
  prefs: []
  type: TYPE_NORMAL
