- en: Adding Continuous Integration and Continuous Deployment
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加持续集成和持续部署
- en: In the previous chapters, we focused on improving the creation and management
    of infrastructure. The DevOps culture doesn't stop there, however. As you might
    recall from [Chapter 1](1e42d3ae-b9f3-420a-8b87-000810a339b6.xhtml), *The Cloud
    and the DevOps Revolution*, DevOps culture also includes having a very efficient
    process to test and deploy code. At the 2009 Velocity conference, John Allspaw
    and Paul Hammond made a very inspirational speech about how Flickr was carrying
    out over 10 deployments a day ([http://bit.ly/292ASlW](http://bit.ly/292ASlW)).
    This presentation is often mentioned as a pivotal moment that contributed to the
    creation of the DevOps movement. In their presentation, John and Paul talk about
    the conflicts between development and operations teams but also outline a number
    of best practices that allow Flickr to deploy new code to production multiple
    times a day.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们集中讨论了改善基础设施的创建和管理。然而，DevOps文化并不止于此。如你从[第1章](1e42d3ae-b9f3-420a-8b87-000810a339b6.xhtml)《云计算与DevOps革命》中所记得的，DevOps文化还包括拥有一个非常高效的代码测试和部署流程。在2009年Velocity大会上，John
    Allspaw和Paul Hammond做了一个非常鼓舞人心的演讲，介绍了Flickr是如何每天进行超过10次部署的([http://bit.ly/292ASlW](http://bit.ly/292ASlW))。这次演讲常被提及为DevOps运动诞生的关键时刻之一。在他们的演讲中，John和Paul谈到了开发和运维团队之间的冲突，同时也概述了一些最佳实践，使得Flickr能够每天多次将新代码部署到生产环境。
- en: With innovations such as virtualization, the public and private cloud, and automation,
    creating new start ups has never been so easy. Because of that, the biggest problem
    many companies are now facing is being able to stand apart from their competitors.
    Having the ability to iterate faster than most competitors can be a detrimental
    to a company's success.  An effective DevOps organization uses a number of tools
    and strategies to increase the velocity at which engineering organizations release
    new code to production. This is what we will focus on in this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着虚拟化、公共云和私有云以及自动化等创新的出现，创建新公司从未如此容易。因此，许多公司现在面临的最大问题是如何脱颖而出，区别于竞争对手。比大多数竞争者更快地迭代能力可能对公司的成功至关重要。一个高效的DevOps组织利用多种工具和策略，以提高工程团队将新代码发布到生产环境的速度。这正是我们将在本章中关注的内容。
- en: We will first look at creating a **Continuous Integration** (**CI**) pipeline.
    A CI pipeline will allow us to test proposed code changes automatically and continuously.
    This will free up the time of developers and QAs who no longer have to carry out
    as much manual testing. It also makes the integration of code changes much easier.
    To implement our pipeline, we will use GitHub and one of the most widely used
    integration tools—**Jenkins**.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先着手创建一个**持续集成**（**CI**）流水线。CI流水线将允许我们自动且持续地测试提议的代码更改。这将释放开发人员和质量保证人员的时间，他们将不再需要进行大量的手动测试。它还使得代码更改的集成变得更加容易。为了实现我们的流水线，我们将使用GitHub和一个最广泛使用的集成工具——**Jenkins**。
- en: We will then look at creating a **Continuous Deployment** (**CD**) pipeline.
    Once the code has gone through the CI pipeline, we will use this continuous deployment
    pipeline to automatically deploy the new code. We will rely on two AWS services
    to implement this pipeline—**AWS CodeDeploy** and **AWS CodePipeline**. CodeDeploy
    lets us define how the new code needs to be deployed on our EC2 instances while
    CodePipeline lets us orchestrate the full life cycle of our application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将探讨如何创建一个**持续部署**（**CD**）流水线。一旦代码通过了CI流水线，我们将使用这个持续部署流水线自动部署新代码。我们将依赖两个AWS服务来实现这个流水线——**AWS
    CodeDeploy**和**AWS CodePipeline**。CodeDeploy让我们定义如何在EC2实例上部署新代码，而CodePipeline则让我们可以协调应用程序的整个生命周期。
- en: 'In order to deploy our code to production, we will add an extra step that will
    allow the operator to deploy the latest build that is present in the staging to
    the production process at the press of a button. This ability to deploy code to
    production on-demand is called CD. Its main advantage is that it provides the
    ability for the deployment operator to validate a build in a staging environment
    before it gets deployed to production. At the end of the chapter, we will see
    a couple of techniques and strategies that effective engineering organizations
    use to convert their continuous delivery pipelines into continuous deployment
    pipelines so that the entire process of deploying code up to production can happen
    without any human intervention. We will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将我们的代码部署到生产环境，我们将增加一个额外的步骤，允许操作员通过按下一个按钮将最新的构建版本从预发布环境部署到生产环境。这种按需将代码部署到生产环境的能力被称为
    CD（持续部署）。它的主要优势在于，它允许部署操作员在将代码部署到生产环境之前，在预发布环境中验证构建。章节末尾，我们将介绍一些有效的工程组织使用的技术和策略，帮助将持续交付管道转变为持续部署管道，从而使整个代码部署过程无需人工干预即可完成。我们将讨论以下主题：
- en: Building a continuous integration pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建持续集成管道
- en: Building a continuous deployment pipeline
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建持续部署管道
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节的技术要求如下：
- en: GitHub
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GitHub
- en: Jenkins
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: Ansible
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: AWS CodeDeploy
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CodeDeploy
- en: AWS CodePipeline
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AWS CodePipeline
- en: 'The links are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相关链接如下：
- en: '**Jenkins package repository**: [https://pkg.jenkins.io/](https://pkg.jenkins.io/)'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins 包管理库**: [https://pkg.jenkins.io/](https://pkg.jenkins.io/)'
- en: '**Jenkins setup playbook**: [https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml](https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml)'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins 设置剧本**: [https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml](https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml)'
- en: '**Jenkinsfile**: [https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile)'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkinsfile**: [https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile)'
- en: '**Code deploy library**: [https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/ansible/library/aws_codedeploy](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/ansible/library/aws_codedeploy)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码部署库**: [https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/ansible/library/aws_codedeploy](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/ansible/library/aws_codedeploy)'
- en: Building a CI pipeline
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 CI 管道
- en: Initially, working in a CI environment meant that developers had to commit their
    code in a common branch as frequently as possible, as opposed to working off a
    separate branch or not committing changes for weeks. This allowed for improved
    visibility of the ongoing work and encouraged communication to avoid integration
    problems, a situation that is commonly known as **Integration Hell**. As the toolset
    related to source control and build and release management matured, so did the
    vision of how code integration should look in an ideal world.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，在 CI 环境中工作意味着开发人员必须尽可能频繁地将代码提交到一个公共分支，而不是在一个单独的分支上工作或几周不提交更改。这可以提高当前工作的可见性，并促进沟通，避免集成问题，这种情况通常被称为
    **集成地狱**。随着源代码管理、构建和发布管理相关工具集的成熟，理想世界中代码集成的愿景也逐渐明确。
- en: Nowadays, most effective engineering organizations will continue down the path
    of integrating early and often. They often use, however, a more modern development
    process, where developers are required to edit the code and, at the same time,
    add or edit the different relevant tests to validate the change. This drastically
    increases overall productivity; it is now easier to find new bugs as the amount
    of code that changes between merges is fairly small.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如今，大多数有效的工程组织将继续沿着早期频繁集成的道路前进。然而，他们通常使用一种更现代的开发过程，在这种过程中，开发人员需要在编辑代码的同时，添加或编辑相关的测试以验证更改。这大大提高了整体生产力；现在更容易发现新错误，因为每次合并时代码的变化量相对较小。
- en: 'To adopt such a workflow, using a source control tool such as Git for example,
    you can proceed as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 要采用这样的工作流程，例如使用 Git 这样的源代码管理工具，你可以按以下步骤进行：
- en: When as a developer, you want to make changes, start by creating a new Git branch
    that branches off the HEAD of the master branch.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为开发者，当你想做出更改时，首先创建一个新的Git分支，从主分支的HEAD分支出。
- en: Edit the code and, at the same time, add or edit the different relevant tests
    to validate the change.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑代码，并同时添加或编辑不同的相关测试以验证更改。
- en: Test the code locally.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地测试代码。
- en: When the code is ready, rebase the branch to integrate new eventual changes
    from other developers. If needed, resolve conflicts and test the code again.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当代码准备好时，将分支rebase以集成其他开发者的最新更改。如有需要，解决冲突并再次测试代码。
- en: If everything went well, the next step consists of creating a `pull request`.
    In this process, you tell other developers that your code is ready to be reviewed.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，下一步是创建一个`pull request`。在这个过程中，你需要告诉其他开发者你的代码已经准备好进行审查。
- en: Once the pull request is created, an automated testing system such as the one
    we will build in this chapter will pick up the change and run the entire test
    suite to make sure nothing fails.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦创建了pull request，一个自动化测试系统（如我们将在本章中构建的系统）将捕捉到更改并运行整个测试套件，以确保没有任何失败。
- en: In addition, other interested parties will review the code and the different
    tests that were added to the branch. If they are satisfied with the proposed change,
    they will approve it, giving the developers the green light to merge their changes.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，其他相关方将审查代码以及添加到分支中的不同测试。如果他们对所提议的更改满意，他们将批准它，允许开发者合并他们的更改。
- en: In the last step, the developers merge their pull requests, which will translate
    into merging their new code and testing the master branch. Other developers will
    now integrate this change when they rebase or create new branches.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，开发者合并他们的pull requests，这将意味着将他们的新代码合并并测试主分支。其他开发者现在将在重新base或创建新分支时集成这个更改。
- en: In the following section, we will create a CI server using Jenkins running on
    top of an EC2 instance and GitHub.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将创建一个使用Jenkins的CI服务器，运行在EC2实例和GitHub之上。
- en: As projects get bigger, the number of tests, the time it takes to run them.
    While certain advanced build systems such as Bazel ([https://bazel.build/](https://bazel.build/))
    have the ability to run only those tests relevant to a particular change, it is
    usually easier to start simply and create a CI system that runs all the tests
    available every time a new pull request is proposed. Having an external test infrastructure
    with the elasticity of AWS becomes a huge time saver for the developers who don't
    want to wait minutes or even hours for all the tests to be executed. In this book,
    we will focus on web application development. You may face a more challenging
    environment in which you need to build software for specific hardware and operating
    system. Having a dedicated CI system will allow you to run your tests on the hardware
    and software you are ultimately targeting.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 随着项目的扩大，测试的数量和运行测试所需的时间也会增加。虽然像Bazel ([https://bazel.build/](https://bazel.build/))
    这样的高级构建系统能够只运行与特定更改相关的测试，但通常更容易从简单开始，创建一个每次提交新pull request时都会运行所有可用测试的CI系统。拥有像AWS这样弹性的外部测试基础设施，对于那些不希望等待几分钟甚至几小时来执行所有测试的开发者来说，将节省大量时间。在本书中，我们将重点讨论Web应用开发。你可能会面临一个更加具有挑战性的环境，需要为特定的硬件和操作系统构建软件。拥有一个专门的CI系统，将允许你在最终目标的硬件和软件上运行测试。
- en: Creating a Jenkins server using Ansible and CloudFormation
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Ansible和CloudFormation创建Jenkins服务器
- en: As mentioned before, we are going to use Jenkins as our central system to run
    our CI pipeline. With over 10 years of development, Jenkins has been the leading
    open-source solution to practice continuous integration for a long time. Famous
    for its rich plugin ecosystem, Jenkins has gone through a major new release (Jenkins
    2.x), which has put the spotlight on a number of very DevOps-centric features,
    including the ability to create native delivery pipelines that can be checked
    in  and version-controlled. It also provides better integration with source control
    systems such as GitHub, which we are using in this book.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用Jenkins作为我们运行CI流水线的核心系统。Jenkins有超过10年的开发历史，长期以来一直是实践持续集成的领先开源解决方案。Jenkins以其丰富的插件生态系统而闻名，已经经历了一个重大的新版本发布（Jenkins
    2.x），这使得它更加聚焦于一些DevOps中心的功能，包括能够创建可以进行版本控制和检查的原生交付流水线。它还提供了与源代码管理系统（如我们在本书中使用的GitHub）的更好集成。
- en: We are going to continue using **Ansible** and **CloudFormation** in the same
    way as we did in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating
    Your Infrastructure as Code, *to manage our Jenkins server.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续像在[第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)中一样使用 **Ansible**
    和 **CloudFormation**，*将你的基础设施视为代码*，来管理我们的 Jenkins 服务器。
- en: Creating the Ansible playbook for Jenkins
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Jenkins 创建 Ansible playbook
- en: 'Start by navigating to our `ansible` roles directory:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导航到我们的 `ansible` 角色目录：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This directory should contain the `helloworld` and `nodejs` directories, with
    the configurations that we created previously in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*. We are now going to create our Jenkins
    role with the `ansible-galaxy` command:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 该目录应包含 `helloworld` 和 `nodejs` 目录，以及我们在[第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)中创建的配置，*将你的基础设施视为代码*。我们现在将使用
    `ansible-galaxy` 命令创建我们的 Jenkins 角色：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are now going to edit the task definition for this new role by editing the
    file: `jenkins/tasks/main.yml`. Open up the file with your favorite text editor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过编辑文件 `jenkins/tasks/main.yml` 来编辑该新角色的任务定义。用你喜欢的文本编辑器打开文件。
- en: 'The goal of our task is to install and start Jenkins. In order to do this,
    since we are on a Linux-based operating system (AWS Amazon Linux, in our case),
    we are going to install an RPM package through `yum`. Jenkins maintains a `yum`
    repository, so the first step will consist of importing this to our `yum` repository
    configuration, basically as an entry in `/etc/yum.repos.d`:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们任务的目标是安装并启动 Jenkins。为了实现这一目标，由于我们使用的是基于 Linux 的操作系统（在我们的例子中是 AWS Amazon Linux），我们将通过
    `yum` 安装一个 RPM 包。Jenkins 维护了一个 `yum` 仓库，所以第一步将是将其导入到我们的 `yum` 仓库配置中，基本上是作为 `/etc/yum.repos.d`
    中的一个条目：
- en: 'The following is the initial comment of the tasks file, add the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是任务文件的初始注释，请添加以下内容：
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step will consist of importing the GPG key of that repository. Ansible
    has a module to manage these kinds of keys:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将是导入该仓库的 GPG 密钥。Ansible 有一个模块来管理这些密钥：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We have now reached the point where we can use `yum` to install Jenkins. We
    will do that with the following call:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了可以使用 `yum` 安装 Jenkins 的步骤。我们将通过以下调用来完成：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Since the `jenkins` repository is disabled by default, we are enabling it through
    the `enablerepo` flag for the execution of this `yum` command.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `jenkins` 仓库默认被禁用，我们通过 `enablerepo` 标志在执行此 `yum` 命令时启用它。
- en: 'At this point, Jenkins will be installed. To conform with best practice guidelines,
    we will specify which version of Jenkins we want to install (in our case the version
    is 2.99). We also want to start the service and have it enabled at the `chkconfig`
    level so that if the EC2 instance where Jenkins is installed restarts, Jenkins
    will start automatically. We can do that using the service module. Add the following
    after the previous call:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，Jenkins 已经安装完成。为了遵循最佳实践指南，我们将指定要安装的 Jenkins 版本（在我们的例子中是 2.99）。我们还希望启动该服务并在
    `chkconfig` 级别启用它，这样如果安装了 Jenkins 的 EC2 实例重新启动，Jenkins 会自动启动。我们可以通过使用服务模块来做到这一点。请在前一个调用后添加以下内容：
- en: '[PRE5]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For a simple Jenkins role, that's all we need.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个简单的 Jenkins 角色，这就是我们所需要的。
- en: We should now have a `main.yml` file that looks as follows: [https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml](https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该有一个 `main.yml` 文件，如下所示：[https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml](https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml)。
- en: 'AWS Amazon Linux comes with Java 7 but Jenkins has pre-requisites to install
    Java 8 for Jenkins version 2.54 and above. So you will see two extra tasks in
    the preceding link, which will uninstall Java 7 and install Java 8:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: AWS Amazon Linux 配备了 Java 7，但 Jenkins 在版本 2.54 及以上要求安装 Java 8。因此，在上面的链接中你会看到两个额外的任务，这些任务将卸载
    Java 7 并安装 Java 8：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As you gain more experience with Jenkins and Ansible, explore the web or the
    Ansible galaxy, you will find more advanced roles allowing you to configure Jenkins
    in more detail, generate jobs, and select the plugins to install. It is an important
    step to go through that this book won't cover, but ideally, you want your entire
    system to be described by code. In addition, in this chapter, we are using Jenkins
    over HTTP. It is strongly encouraged to use it over an encrypted protocol such
    as HTTPS or, as we will see in Chapter 8, *Hardening the Security of Your AWS
    Environment,* in a private subnet with a VPN connection.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你对 Jenkins 和 Ansible 的经验积累，探索网络或 Ansible Galaxy，你会发现更多的高级角色，允许你更详细地配置 Jenkins、生成作业并选择要安装的插件。这是一个重要的步骤，本书不会涵盖，但理想情况下，你希望你的整个系统都能通过代码来描述。此外，在本章中，我们使用的是
    HTTP 协议上的 Jenkins。强烈建议使用加密协议（如 HTTPS），或者正如我们将在第 8 章《*强化 AWS 环境的安全性*》中看到的那样，使用
    VPN 连接的私有子网。
- en: We have now built a role that will allow us to install Jenkins. We want to create
    a new EC2 instance and install Jenkins on it with the end goal of testing our
    Node.js code on the instance. In order to be able to do that, the Jenkins host
    will need to also have the node and `npm` installed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经构建了一个角色，使我们能够安装 Jenkins。我们希望创建一个新的 EC2 实例并在其上安装 Jenkins，最终目标是在该实例上测试我们的
    Node.js 代码。为了实现这一点，Jenkins 主机还需要安装 Node 和 `npm`。
- en: 'We have two options. We can either add our `nodejs` role as a dependency of
    the Jenkins role, as we did for the `helloworld` role, or we can list the `nodejs`
    role in the list of roles for our playbook. Since ultimately Jenkins doesn''t
    really require a node to run, we will opt for the second approach. In the root
    directory of our `ansible` repository, create the `playbook` file. The filename
    is `jenkins.yml` and it should look as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种选择。我们可以像为 `helloworld` 角色做的那样，将我们的 `nodejs` 角色作为 Jenkins 角色的依赖项，或者我们可以将
    `nodejs` 角色列在我们的剧本角色列表中。由于最终 Jenkins 并不需要 Node 才能运行，我们将选择第二种方法。在我们 `ansible` 仓库的根目录中，创建
    `playbook` 文件。文件名为 `jenkins.yml`，并应如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Our role is now complete, so we can commit our new role and push it to GitHub.
    Following the best practices described previously, we will start by creating a
    new branch:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的角色已经完成，因此我们可以提交我们新的角色并将其推送到 GitHub。按照之前描述的最佳实践，我们将从创建一个新的分支开始：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add our files with the following command:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令添加我们的文件：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Commit and finally `push` the changes:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 提交并最终 `push` 更改：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'From there, submit a pull request inside GitHub and merge the branch back to
    the master:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，在 GitHub 内部提交一个拉取请求并将分支合并回主分支：
- en: '![](img/b70fa6ca-f937-49db-959d-505bffbc2ec9.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b70fa6ca-f937-49db-959d-505bffbc2ec9.png)'
- en: 'Once done, get back to the master branch with the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，使用以下命令返回到主分支：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In a real-life situation, you likely also want to periodically run the following:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际情况中，你可能还希望定期运行以下内容：
- en: '[PRE12]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will retrieve the changes made by other developers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索其他开发人员所做的更改。
- en: We can now create our CloudFormation template in order to call the role.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建我们的 CloudFormation 模板，以便调用该角色。
- en: Creating the CloudFormation template
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CloudFormation 模板
- en: 'In order to keep our code fairly similar to the code we looked at in [Chapter
    3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as Code,* we are going to start off with the `helloworld` Troposphere code that
    we created in that chapter. First, we are going to duplicate the Python script.
    Go to your `EffectiveDevOpsTemplates` directory, where you have your Troposphere
    templates, and then clone the `ansiblebase-cf-template.py` file as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的代码与我们在[第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)《*将基础设施视为代码*》中看到的代码尽可能相似，我们将从我们在该章中创建的
    `helloworld` Troposphere 代码开始。首先，我们将复制 Python 脚本。前往你的 `EffectiveDevOpsTemplates`
    目录，那里有你的 Troposphere 模板，然后按如下方式克隆 `ansiblebase-cf-template.py` 文件：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The Jenkins host will need to interact with AWS. To allow this, we will create
    an instance profile, which we will describe in more detail later, taking advantage
    of another library that is developed by the same authors as Troposphere. We will
    install it as follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 主机将需要与 AWS 进行交互。为此，我们将创建一个实例配置文件，稍后将详细描述它，利用由与 Troposphere 相同的作者开发的另一个库。我们将按如下方式安装它：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We are now going to edit the `jenkins-cf-template.py` file. The first two changes
    we will make are to the name and port of the application. Jenkins runs by default
    on `TCP/8080`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将编辑 `jenkins-cf-template.py` 文件。我们将进行的前两个更改是应用程序的名称和端口。Jenkins 默认运行在 `TCP/8080`
    上：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We will also set a number of constants around the GitHub information.  Replace
    the value of your `GithubAccount` with your GitHub username or organization name:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将设置一些与 GitHub 信息相关的常量。将 `GithubAccount` 的值替换为你的 GitHub 用户名或组织名：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We also want to add an instance IAM profile to better control how our EC2 instance
    can interact with AWS services such as EC2\. We previously used the IAM service
    in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First
    Web Application,* when we created our user. You may recall that in addition to
    creating the user, we also assigned it the administrator policy, which gives the
    user full access to all AWS services. On top of that, we generated an access key
    and a secret access key, which we are currently using to authenticate ourselves
    as that administrator user and interact with services such as CloudFormation and
    EC2.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想添加一个实例 IAM 配置文件，以更好地控制我们的 EC2 实例如何与 AWS 服务（如 EC2）进行交互。我们之前在 [第 2 章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中使用了
    IAM 服务，*部署您的第一个 Web 应用程序*，当时我们创建了我们的用户。你可能还记得，除了创建用户外，我们还为其分配了管理员策略，这使得用户可以完全访问所有
    AWS 服务。除此之外，我们还生成了访问密钥和秘密访问密钥，当前正使用它们来验证自己作为该管理员用户，并与 CloudFormation 和 EC2 等服务进行交互。
- en: When you are using EC2 instances, the **instance profile** feature provided
    lets you specify an IAM role to your instance. In other words, we can assign IAM
    permissions directly to EC2 instances without having to use access keys and secret
    access keys.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当你使用 EC2 实例时，提供的 **实例配置文件** 功能让你可以为实例指定一个 IAM 角色。换句话说，我们可以直接将 IAM 权限分配给 EC2
    实例，而无需使用访问密钥和秘密访问密钥。
- en: 'Having an instance profile will be very useful later on in this chapter, when
    we work on the CI pipeline and integrate our Jenkins instance with the AWS managed
    services. To do this, we will first import some extra libraries. The following
    is from Troposphere `import()` section, add the following:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个实例配置文件将在本章后续章节中非常有用，尤其是在我们进行 CI 管道工作并将 Jenkins 实例与 AWS 托管服务集成时。为此，我们首先需要导入一些额外的库。以下内容来自
    Troposphere `import()` 部分，请添加如下：
- en: '[PRE17]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Then, in between the instantiation of the variables `ud` and the creation of
    the instance, we are going to create and add our role resource to the template
    as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在变量 `ud` 实例化和实例创建之间，我们将创建并将角色资源添加到模板中，如下所示：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As we did previously for the role, we can now create our instance profile and
    reference the role. The following code is the creation of the role:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前为角色所做的那样，我们现在可以创建实例配置文件并引用该角色。以下代码是创建角色的过程：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we can reference our new instance profile by updating the declaration
    of our instance. We will add a period after `UserData=ud` and on the line after
    initializing the `IamInstanceProfile` as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过更新实例声明来引用我们的新实例配置文件。在 `UserData=ud` 后添加一个句点，并在初始化 `IamInstanceProfile`
    的行后添加，如下所示：
- en: '[PRE20]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The file should now look like this [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/jenkins-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/jenkins-cf-template.py).
    You can save the changes, commit the new script to GitHub, and generate the CloudFormation
    template:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，文件应该如下所示：[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/jenkins-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/jenkins-cf-template.py)。你可以保存更改，将新的脚本提交到
    GitHub，并生成 CloudFormation 模板：
- en: '[PRE21]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Launching the stack and configuring Jenkins
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动堆栈并配置 Jenkins
- en: 'In order to create our EC2 instance with Jenkins running on it, we will proceed
    as we did in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating
    Your Infrastructure as Code*, using either the web interface or the command-line
    interface as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在运行 Jenkins 的 EC2 实例上创建我们的 EC2 实例，我们将按照 [第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)中所做的那样，*将基础设施视为代码*，使用网页界面或命令行界面，如下所示：
- en: '[PRE22]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'As we did before, we can then wait until the execution is complete:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们可以等待执行完成：
- en: '[PRE23]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'After that, we can extract the host''s public IP:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以提取主机的公网 IP：
- en: '[PRE24]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Because we kept the **Ansible Jenkins** role fairly simple, we need to complete
    its configuration in order to complete the installation of Jenkins. Follow these
    steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将 **Ansible Jenkins** 角色保持得相对简单，我们需要完成它的配置，以便完成 Jenkins 的安装。请按照以下步骤操作：
- en: 'Open port `8080` of the instance public IP in your browser (that is, in my
    case, `http://18.208.183.35:8080)`. Wait for a while to get Jenkins configurations
    to get configured before you get the screen):'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开实例公有IP的`8080`端口（在我的情况下，即`http://18.208.183.35:8080`）。等待一段时间，直到Jenkins配置完成，然后你将看到屏幕：
- en: '![](img/dd5efa0e-175e-46fa-8640-8c59d3b03232.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dd5efa0e-175e-46fa-8640-8c59d3b03232.png)'
- en: 'Using the following `ssh` command (adapt the IP address) and its ability to
    run commands remotely, we can extract the admin password, and provide it to that
    first configuration screen with the following command:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下`ssh`命令（请根据需要调整IP地址）及其远程执行命令的功能，我们可以提取管理员密码，并通过以下命令将其提供给第一个配置屏幕：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: On the next screen, choose to install the suggested plugins.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，选择安装推荐的插件。
- en: Create your first admin user on the next screen and click on the Save and Finish
    button.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上创建你的第一个管理员用户，并点击“保存并完成”按钮。
- en: Finally, click on the Start using Jenkins button.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击“开始使用Jenkins”按钮。
- en: Our Jenkins instance is now ready to be used.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Jenkins实例现在已经准备好使用了。
- en: Preparing our CI environment
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备我们的CI环境
- en: We are going to use our Jenkins instance in conjunction with GitHub to recreate
    our `helloworld` application using a proper CI pipeline. To do this, we are going
    to go through a number of preliminary steps, starting with the creation of a new
    GitHub organization that has a new repository named `helloworld`.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的Jenkins实例与GitHub一起，使用一个合适的CI管道重新创建我们的`helloworld`应用程序。为此，我们将经过一些初步步骤，从创建一个新的GitHub组织开始，这个组织里有一个名为`helloworld`的新仓库。
- en: Creating a new GitHub organization and repository
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个新的GitHub组织和仓库
- en: 'We are now going to create a new organization having a new repository dedicated
    to hosting our `helloworld` node application. We will create the organization
    by going through the following steps and then will create a new repository inside
    the organization using the same steps as in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将创建一个新组织，并为其创建一个新的仓库，用于托管我们的`helloworld`节点应用程序。我们将通过以下步骤创建该组织，然后使用与[第3章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)《将基础设施视为代码》相同的步骤，在组织内部创建一个新仓库：
- en: Open [https://github.com/organizations/new](https://github.com/new) in your
    browser.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开[https://github.com/organizations/new](https://github.com/new)。
- en: Set the organization name, which will be a separate GitHub account inside your
    main GitHub account. I am creating mine with the name `yogeshrahejahelloworld`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置组织名称，这将是你主GitHub账户下的一个独立GitHub账户。我创建的组织名称是`yogeshrahejahelloworld`。
- en: Provide your email ID and select the free plan.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供你的电子邮件ID并选择免费计划。
- en: 'Click on the Create organization button and select the default settings for
    the next two steps:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建组织”按钮，并为接下来的两个步骤选择默认设置：
- en: '![](img/e0293a81-55ab-48bb-9d48-4922a28028fc.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e0293a81-55ab-48bb-9d48-4922a28028fc.png)'
- en: 'Create a new repository for the newly created organization:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为新创建的组织创建一个新仓库：
- en: '![](img/8e1a7d3c-12b7-4922-b78c-397adbe631e4.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e1a7d3c-12b7-4922-b78c-397adbe631e4.png)'
- en: Call your repository `helloworld`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的仓库命名为`helloworld`。
- en: Check the  Initialize this repository with a README checkbox.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选“初始化此仓库并附带README”复选框。
- en: 'Click on the Create Repository button:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“创建仓库”按钮：
- en: '![](img/22eba538-9e1f-44a8-b652-726d32ac3d7a.png)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22eba538-9e1f-44a8-b652-726d32ac3d7a.png)'
- en: This will create the repository, a master branch, and a `README.md` file.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个仓库、一个主分支，以及一个`README.md`文件。
- en: A proper CI pipeline works silently in the background. In order to achieve this,
    when the code is hosted on GitHub, Jenkins needs to get notifications from GitHub
    to indicate that the code has changed so that it can trigger a build automatically.
    This is something we can easily implement thanks to a plugin called `github-organization-plugin`.
    This plugin is one of those that were installed when we chose to install the suggested
    plugins in Jenkins. In order to use it, we first need to create a personal access
    token in GitHub.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一个合适的CI管道在后台静默运行。为了实现这一点，当代码托管在GitHub上时，Jenkins需要从GitHub获取通知，以表明代码已发生变化，从而触发自动构建。这是我们可以通过一个叫做`github-organization-plugin`的插件轻松实现的。这个插件是我们在选择安装推荐插件时，Jenkins中安装的插件之一。为了使用它，我们首先需要在GitHub中创建一个个人访问令牌。
- en: Creating a GitHub personal access token
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个GitHub个人访问令牌
- en: 'Creating a personal access token will give the plugins the ability to access
    the code pushed to GitHub and create the necessary hooks to get notifications
    when new commits and pull requests occur. In order to create the token, use the
    following steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 创建个人访问令牌将使插件能够访问推送到 GitHub 的代码，并创建必要的钩子，以便在发生新的提交和拉取请求时获取通知。为了创建令牌，请按照以下步骤操作：
- en: Open [https://github.com/settings/tokens](https://github.com/settings/tokens)
    in your browser.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 [https://github.com/settings/tokens](https://github.com/settings/tokens)。
- en: Click on the Generate new token button.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击生成新令牌按钮。
- en: Give it a descriptive name, such as `Effective DevOps with AWS Jenkins`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它起一个描述性的名称，例如 `Effective DevOps with AWS Jenkins`。
- en: Select the  repo, admin:repo_hook, and admin:org_hook scopes.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `repo`、`admin:repo_hook` 和 `admin:org_hook` 范围。
- en: Click on the Generate token button.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击生成令牌按钮。
- en: This brings you back to the main token page. Save the token that is generated.
    We will need it later.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带你回到主令牌页面。保存生成的令牌，我们稍后将需要它。
- en: Adding the access token to the credentials in Jenkins
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将访问令牌添加到 Jenkins 中的凭证
- en: 'We can now add the token to Jenkins as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以按照以下步骤将令牌添加到 Jenkins 中：
- en: Open Jenkins, in my case `http://18.208.183.35:8080`.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Jenkins，在我的案例中是 `http://18.208.183.35:8080`。
- en: Click on Credentials in the menu on the left, then click on System just after
    it it, and then Global credentials.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中点击凭证，然后点击系统，接着点击全局凭证。
- en: On the next screen, click on Add credentials.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，点击添加凭证。
- en: The credentials we are going to create are of the type Username with password.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要创建的凭证类型是用户名与密码。
- en: The scope should be global.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 范围应该是全局的。
- en: Use your GitHub organization as a username.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的 GitHub 组织作为用户名。
- en: Use the token generated in the previous section as your password.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用上一部分生成的令牌作为密码。
- en: 'The ID can be something like `GitHub` as shown in the following screenshot:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ID 可以是类似 `GitHub` 的名称，如下截图所示：
- en: '![](img/50c9d78c-1ef5-4c08-abc3-7c8ea5f234d9.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/50c9d78c-1ef5-4c08-abc3-7c8ea5f234d9.png)'
- en: You can also choose to give it a description. After that, click OK.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以选择为它提供一个描述。之后点击 OK。
- en: The last step of our initialization process consists of creating the Jenkins
    job.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们初始化过程的最后一步是创建 Jenkins 作业。
- en: Creating the Jenkins job to automatically run the builds
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Jenkins 作业以自动运行构建
- en: 'As mentioned previously, Jenkins has a plugin to help with the GitHub integration.
    We can easily take advantage of this by creating a GitHub organization job. To
    do this, go through the following steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Jenkins 有一个插件来帮助与 GitHub 集成。我们可以通过创建一个 GitHub 组织作业轻松利用这个插件。按照以下步骤操作：
- en: Open your Jenkins home page in your browser, enter  `http://18.208.183.35:8080/`
     and click on Create new jobs.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 Jenkins 首页，输入 `http://18.208.183.35:8080/` 并点击创建新作业。
- en: Enter an item name, provide your GitHub username or organization name, click
    on GitHub Organization, and then click on OK.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入项目名称，提供你的 GitHub 用户名或组织名称，点击 GitHub 组织，然后点击 OK。
- en: 'This will bring us to a new page, where we will be able to configure the project:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们到一个新页面，我们将在这里配置项目：
- en: In the Credentials drop-down menu, select your newly created credential.
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在凭证下拉菜单中，选择你新创建的凭证。
- en: Validate that the owner is your username or organization name or the name you
    provided while creating the job. This will be used by Jenkins to scan all your
    repositories.
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证所有者是你的用户名、组织名称，或创建作业时提供的名称。这将被 Jenkins 用来扫描你所有的代码库。
- en: Since we already know that we are only interested in the `helloworld` repository,
    click on the Add button at the bottom of the Behaviors section and select the
    first option, which should be Filter by Name (with regular expression).
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经知道我们只关心 `helloworld` 仓库，点击“行为”部分底部的“添加”按钮，然后选择第一个选项，即“按名称过滤（使用正则表达式）”。
- en: 'In the newly populated field, Regular expression, replace `.*` with `helloworld`. Select
    strategy as All branches from the Discover branches section and scroll down to
    select one minute from the Scan Organization Triggers section on the same page:'
  id: totrans-158
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新出现的字段中，常规表达式，将`.*`替换为`helloworld`。在“发现分支”部分选择策略为“所有分支”，然后向下滚动，在同一页面的“扫描组织触发器”部分选择一分钟：
- en: '![](img/04b09d75-9436-4b4d-b976-19e5036c0db8.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/04b09d75-9436-4b4d-b976-19e5036c0db8.png)'
- en: Click on Save.
  id: totrans-160
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击保存。
- en: '![](img/08e9deeb-4169-4321-93b7-a2adde97eea2.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/08e9deeb-4169-4321-93b7-a2adde97eea2.png)'
- en: 'The job will be created and will scan the project to find a branch. It will
    find the master branch with the `README` file in it, but because we don''t have
    any code yet we will not do anything. In the following section, we are going to
    remediate that lack of code and implement our `helloworld` application:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 该工作将被创建并扫描项目以找到一个分支。它会找到包含`README`文件的master分支，但因为我们还没有代码，所以我们不会做任何事情。在接下来的部分，我们将解决代码缺失的问题并实现我们的`helloworld`应用程序：
- en: '![](img/dbbb6d83-9963-408f-8e90-e6b23984b48f.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dbbb6d83-9963-408f-8e90-e6b23984b48f.png)'
- en: Implementing the helloworld application using our CI environment
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用我们的CI环境实现helloworld应用程序
- en: 'Here, we will once again use the simple `helloworld` web application that we
    created in [Chapter 2](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Deploying
    Your First Web Application*. The goal here is more to illustrate the use of our
    CI pipeline than to build a complex web application:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将再次使用我们在[第二章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)中创建的简单`helloworld`
    Web应用程序，*部署您的第一个Web应用程序*。这里的目标更多是为了说明我们CI管道的使用，而不是构建一个复杂的Web应用程序：
- en: Initializing the project
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初始化项目
- en: We are going to use the same AWS instance that we deployed and configured in
    the previous section for Jenkins, as a development environment. Therefore, we
    need to have `nodejs` and `npm` installed on our instance. If you haven't installed
    these yet, refer to the instructions in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application:*
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用在上一节中为Jenkins部署和配置的相同AWS实例作为开发环境。因此，我们需要在实例上安装`nodejs`和`npm`。如果您还没有安装它们，请参考[第二章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)中的说明，*部署您的第一个Web应用程序：*
- en: '[PRE26]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述命令的输出如下：
- en: '![](img/15de66b9-f970-4b78-b705-32e42125a52d.png)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![](img/15de66b9-f970-4b78-b705-32e42125a52d.png)'
- en: 'Our first step will be to clone the `helloworld` GitHub repository that we
    created in the preceding section:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一步将是克隆我们在上一节中创建的`helloworld` GitHub仓库：
- en: '[PRE27]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can now create a new branch:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个新的分支：
- en: '[PRE28]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Create an empty file called `helloworld.js`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个空文件，名为`helloworld.js`：
- en: '[PRE29]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: One of the best ways to write tests for these types of projects is to use a
    **Test Driven Development** (**TDD**) approach. In a TDD process, developers create
    the tests first, then run them to make sure they are failing, write the code,
    and then test again. At that point, the tests should pass. We can create a pull
    request and merge it once it has been reviewed and approved.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为这些类型的项目编写测试的最佳方法之一是使用**测试驱动开发**（**TDD**）方法。在TDD过程中，开发人员首先创建测试，然后运行它们以确保它们失败，编写代码，再次进行测试。此时，测试应通过。我们可以创建一个拉取请求并在审查和批准后进行合并。
- en: Creating a functional test using Mocha
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Mocha创建功能测试
- en: In order to illustrate the process of writing tests for our TDD approach, we
    will use a tool called **Mocha** ([https://mochajs.org/](https://mochajs.org/)).
    Mocha is a very common and easy-to-use JavaScript test framework to create a test.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明我们TDD方法中编写测试的过程，我们将使用一个名为**Mocha**的工具（[https://mochajs.org/](https://mochajs.org/)）。Mocha是一个非常常见且易于使用的JavaScript测试框架，用于创建测试。
- en: We will install it locally on our system using the following `npm`, the Node.js
    package manager command.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下`npm`，即Node.js包管理器命令，在本地安装它到我们的系统中。
- en: 'First, we will initialize `npm` with the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用以下命令初始化`npm`：
- en: '[PRE30]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述命令的输出如下：
- en: '![](img/745a176a-ac1b-4ad2-bf85-1cd70713d165.png)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![](img/745a176a-ac1b-4ad2-bf85-1cd70713d165.png)'
- en: 'This will create a new file called `package.json`. Next, we will install Mocha
    and add it to our list of development dependencies as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`package.json`的新文件。接下来，我们将安装Mocha并将其添加到我们的开发依赖列表中，如下所示：
- en: '[PRE31]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This will create a directory called `node_modules`. Mocha will be installed
    in that directory.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`node_modules`的目录，Mocha将被安装在该目录中。
- en: 'In addition to Mocha, we will use a headless browser testing module to render
    our `helloworld` application, called **Zombie**. We can install it with the same
    command as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Mocha，我们还将使用一个无头浏览器测试模块来渲染我们的`helloworld`应用程序，名为**Zombie**。我们可以通过以下相同命令安装它：
- en: '[PRE32]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In order to separate the tests from the rest of the project, we are now going
    to create a directory called `test` in the root location of our `helloworld` project.
    By default, Mocha will look for tests in that directory:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将测试与项目的其余部分分开，我们现在将在`helloworld`项目的根目录下创建一个名为`test`的目录。默认情况下，Mocha会在该目录中查找测试：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The last piece of boilerplate code we will use will configure `npm` to use
    Mocha to run our tests. With your editor, open the `package.json` file and replace
    the test scripts with the following command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用的最后一段样板代码将配置`npm`，使其使用Mocha来运行我们的测试。使用您的编辑器，打开`package.json`文件，并将测试脚本替换为以下命令：
- en: '[PRE34]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Inside the `test` directory, create and edit the file `helloworld_test.js`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`test`目录内，创建并编辑文件`helloworld_test.js`。
- en: 'The first step consists of loading two modules that we are going to use and
    need in our test. The first one is `zombie`, our headline browser, and the second
    one is the `assert` module, which is the standard module used to create unit testing
    in Node.js applications:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是加载我们将在测试中使用并需要的两个模块。第一个是`zombie`，我们的无头浏览器，第二个是`assert`模块，它是用于在Node.js应用程序中创建单元测试的标准模块：
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next, we need to load our application. This is done by calling the same `require()`
    function, but this time we will ask it to load the `helloworld.js` file that we
    will soon implement. For now, it''s an empty file:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要加载我们的应用程序。这可以通过调用相同的`require()`函数来完成，但这次我们将让它加载我们即将实现的`helloworld.js`文件。目前，它是一个空文件：
- en: '[PRE36]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'We can now start creating the test. The basic syntax of Mocha tries to mimic
    what it thinks specification document could require. The following are the three
    required statements, add the following:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始创建测试了。Mocha的基本语法试图模仿它认为规范文档可能需要的内容。以下是三个必需的语句，请添加以下内容：
- en: '[PRE37]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We now need to add hooks into that test to interact with our web application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要向测试中添加钩子，以便与我们的web应用程序进行交互。
- en: 'The first step will be to point the test to our application endpoint. As you
    might remember from the previous chapters, the application is running on `http://localhost:3000`.
    We will use the hook called `before()` to set up a precondition. Above the call
    to `it()`, add the following to point our headless browser to the proper server:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将测试指向我们的应用程序端点。如您可能记得，从前面的章节中，应用程序正在`http://localhost:3000`上运行。我们将使用名为`before()`的钩子来设置一个前提条件。在`it()`调用之上，添加以下内容，将我们的无头浏览器指向正确的服务器：
- en: '[PRE38]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'At this point, our headless browser will connect to our application, but it
    won''t request any page. Let''s add that in another `before()` hook, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们的无头浏览器将连接到我们的应用程序，但它不会请求任何页面。让我们在另一个`before()`钩子中添加这一点，如下所示：
- en: '[PRE39]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now that the home page has loaded, we need to implement the code in the `it()`
    function to validate our assertion. We will edit the line with the `it()` call
    to add a callback function, as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在首页已经加载，我们需要在`it()`函数中实现代码来验证我们的断言。我们将编辑包含`it()`调用的行，并添加一个回调函数，如下所示：
- en: '[PRE40]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our test is now ready. If everything went well, your code should look like
    the one shown at the following link: [https://raw.githubusercontent.com/yogeshraheja/helloworld/master/test/helloworld_test.js](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/test/helloworld_test.js).'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试现在已经准备好。如果一切顺利，您的代码应该与以下链接中所示的代码相似：[https://raw.githubusercontent.com/yogeshraheja/helloworld/master/test/helloworld_test.js](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/test/helloworld_test.js)。
- en: 'We can test it in Terminal by simply calling the Mocha command, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在终端中简单地调用Mocha命令来进行测试，如下所示：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As you can see, our test is failing. It can't connect to the web application.
    This is, of course, expected, since we haven't implemented the application code
    yet.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的测试失败了。它无法连接到web应用程序。这当然是预期的，因为我们还没有实现应用程序代码。
- en: Developing the remainder of the application
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发应用程序的其余部分
- en: 'We are now ready to develop our application. Since we already went through
    creating the exact code in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*, we are simply going to copy it or download
    it directly as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好开发我们的应用程序了。由于我们已经在[第2章](1abe175d-50df-434d-bc0a-097397a39cee.xhtml)《部署你的第一个Web应用程序》中完成了相同代码的创建，我们只需按如下方式复制或直接下载它：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can now test the code again using the `npm` command:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用`npm`命令重新测试代码：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前述命令的输出如下：
- en: '![](img/459801e2-d046-4807-8516-0dfdfa7fd057.png)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![](img/459801e2-d046-4807-8516-0dfdfa7fd057.png)'
- en: Our test is now passing.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的测试现在已经通过。
- en: We are almost there. We have satisfied one of our first goals, which was to
    have test coverage for our code. Of course, a real application with more complexity
    would have many more tests, but what we want to focus on now is automation. Now
    that we've learned how to test our code manually, we want to see how Jenkins can
    do this for us.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们快完成了。我们已经完成了第一个目标，即为我们的代码提供测试覆盖率。当然，一个更复杂的实际应用会有更多的测试，但现在我们要关注的是自动化。既然我们已经学会了如何手动测试代码，我们想看看
    Jenkins 如何为我们完成这一工作。
- en: Creating the CI pipeline in Jenkins
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jenkins 中创建 CI 管道
- en: As we saw earlier, Jenkins works by creating and executing jobs. Historically,
    one way to create the pipeline would be to open Jenkins in the browser, navigate
    to the job we previously created, and edit it to outline the different steps involved
    in testing our code. The problem with that solution is that there isn't a good
    review process involved and it's hard to track every change made over time. In
    addition, it's very hard for developers to make changes in a project that involves
    adding new build steps as the code of the project and the job building the project
    aren't synced together. Jenkins 2 made the concept of describing the build process
    into a local file a standard feature, which we're going to use in the following
    section.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前看到的，Jenkins 通过创建和执行作业来工作。历史上，创建管道的一种方式是打开浏览器中的 Jenkins，导航到我们之前创建的作业，并编辑它以概述测试代码的不同步骤。这个解决方案的问题在于，它没有一个好的审核过程，很难跟踪每次更改。此外，对于开发者来说，在一个涉及添加新构建步骤的项目中进行更改是非常困难的，因为项目的代码和构建该项目的作业没有同步在一起。Jenkins
    2 将描述构建过程为本地文件的概念作为标准功能，我们将在接下来的部分中使用它。
- en: We are going to create and edit a new file in the project called `Jenkinsfile`
    (capital `J`, no file extension). The file will be written in **Groovy** ([http://www.groovy-lang.org](http://www.groovy-lang.org)).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建并编辑项目中的新文件 `Jenkinsfile`（大写的 `J`，没有文件扩展名）。该文件将使用 **Groovy** 编写（[http://www.groovy-lang.org](http://www.groovy-lang.org)）。
- en: 'On the first line of the file, we are going to put the following:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的第一行，我们将放置以下内容：
- en: '[PRE44]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This is useful for the different IDEs and GitHub as it indicates the nature
    of the file. The first step of our script will consist of asking Jenkins to assign
    the job to a node as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于不同的 IDE 和 GitHub 来说是有用的，因为它标明了文件的性质。我们脚本的第一步将是要求 Jenkins 将任务分配给节点，如下所示：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our Jenkins installation is fairly simple. We only have one server and therefore
    only one node. If we had more nodes, we could add parameters to the call to target
    a node with a specific architecture, or even drive the parallel execution.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Jenkins 安装相当简单。我们只有一台服务器，因此只有一个节点。如果我们有更多的节点，我们可以向调用中添加参数，以便将任务指向具有特定架构的节点，甚至可以实现并行执行。
- en: 'Our CI testing can be logically broken up into a few steps:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 CI 测试可以逻辑上分为几个步骤：
- en: Get the code from GitHub.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 GitHub 获取代码。
- en: Install the different dependencies by calling the `npm install` command.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过调用 `npm install` 命令来安装不同的依赖项。
- en: Run our run with the command `mocha`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令 `mocha` 运行我们的测试。
- en: Clean up.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 清理。
- en: 'These steps have an equivalent concept in Jenkins called **stages**. We are
    going to add them inside the node routing. Here is what the first stage will look
    like:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤在 Jenkins 中有一个等价的概念，叫做 **stages（阶段）**。我们将把它们添加到节点路由中。以下是第一个阶段的样子：
- en: '[PRE46]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This tells Jenkins to get the code from the source control. When we created
    the job, we stated that it was a GitHub organization job, so Jenkins will know
    how to interpret that correctly.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉 Jenkins 从源代码管理获取代码。当我们创建作业时，我们声明它是一个 GitHub 组织作业，因此 Jenkins 会知道如何正确地解释这一点。
- en: 'Next, we need to call the `npm install` command. Groovy doesn''t understand
    native language specific features such as calling `npm`. To do this, therefore,
    we will use the `sh` command, which will allow us to spawn a shell and run a command.
    Here is what our second stage looks like:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要调用 `npm install` 命令。Groovy 无法理解诸如调用 `npm` 这样的特定语言功能。为此，我们将使用 `sh` 命令，它允许我们启动一个
    shell 并执行命令。我们的第二个阶段如下所示：
- en: '[PRE47]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In our next stage, we are going to run Mocha. The following is the `Setup`
    stage; add the following:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的阶段中，我们将运行 Mocha。以下是 `Setup` 阶段；请添加以下内容：
- en: '[PRE48]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Finally, we can proceed to clean up the repository with the following stage:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以继续清理代码库，使用以下阶段：
- en: '[PRE49]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The Jenkins file is now ready, it should look like this: [https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile).'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 文件现在已经准备好，它应如下所示：[https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile)。
- en: 'We can now commit our code and test it:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以提交我们的代码并进行测试：
- en: '[PRE50]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This will create a remote branch called `initial-branch`. As the branch gets
    created, Jenkins will get a notification from GitHub about the change and will
    run the CI pipeline. In a matter of seconds, our test will run on Jenkins, which
    in turn will send the result back to GitHub. We can observe this as follows:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个名为`initial-branch`的远程分支。当分支创建时，Jenkins 会收到来自 GitHub 的通知，并会运行 CI 流水线。在几秒钟内，我们的测试将在
    Jenkins 上运行，Jenkins 又会将结果返回给 GitHub。我们可以通过以下方式观察这一过程：
- en: Open GitHub in your browser and navigate to the `helloworld` project you created.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 GitHub，导航到你创建的`helloworld`项目。
- en: Click on Branch and select initial-branch.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Branch 并选择 initial-branch。
- en: From that screen, click on New pull request, provide a title and a good description
    of the change you are making. If possible, mention other developers so that they
    can thoroughly review the change you are proposing.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该页面上，点击 New pull request，提供一个标题并简要描述你正在进行的更改。如果可能，提到其他开发人员，以便他们可以彻底审查你提出的更改。
- en: 'Click on Create pull request and follow the steps to create a pull request.
    Once the pull request is created, you will be able to see how GitHub shows that
    the pull request has passed all checks:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Create pull request 并按照步骤创建拉取请求。一旦拉取请求创建完成，你将能够看到 GitHub 如何显示该拉取请求已通过所有检查：
- en: '![](img/f1cdb793-6c9b-4ab8-8ebc-31d6b4c5626d.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1cdb793-6c9b-4ab8-8ebc-31d6b4c5626d.png)'
- en: 'You can also go to your Jenkins browser and check the build history. You can
    even check the details from Jenkins by clicking the organization, followed by
    repository and branch. This will bring us back to the Jenkins job, where you can
    observe the execution of the job and its pipeline in more detail:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还可以进入 Jenkins 浏览器并查看构建历史。你甚至可以通过点击组织，接着是仓库和分支，查看 Jenkins 的详细信息。这将把我们带回 Jenkins
    作业页面，在那里你可以更详细地观察作业和流水线的执行：
- en: '![](img/f966e8c5-f53e-48e2-92f1-eb04a6fd4a28.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f966e8c5-f53e-48e2-92f1-eb04a6fd4a28.png)'
- en: At that point, if you mentioned other developers, they should get a notification
    so that they can look at the content of the pull request. Once it is reviewed
    and approved, the pull request can be merged. From that point on, when developers
    pull the master branch or rebase their branch, they will see your code.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此时，如果你提到其他开发人员，他们应该会收到通知，这样他们可以查看拉取请求的内容。一旦审核通过，拉取请求可以合并。从那时起，当开发人员拉取 master
    分支或进行 rebase 操作时，他们将能看到你的代码。
- en: Depending on the size of the team working on a repository, it is common to have
    to rebase a branch. The two most important times to do that are before creating
    the pull request (step 2) and before merging it (step 6).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 根据团队在仓库中的规模，通常需要对分支进行 rebase。最重要的两个时机是在创建拉取请求之前（步骤 2）和合并之前（步骤 6）。
- en: Productionizing the CI pipeline
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 CI 流水线投入生产
- en: We have now put in place a basic, yet functional, CI pipeline. While this is
    a good starting point, you are likely to want to perfect certain details of this
    system. As mentioned previously, our Ansible recipe for Jenkins can be improved
    to include the configuration of the jobs such as the `helloworld` job we manually
    created.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经建立了一个基本的、但功能完备的 CI 流水线。虽然这是一个不错的起点，但你可能还希望完善这个系统的某些细节。如前所述，我们为 Jenkins
    配置的 Ansible 配方可以改进，以包含诸如我们手动创建的`helloworld`作业的配置。
- en: We only created a single functional test to illustrate how to use a TDD approach
    and how to integrate a testing step in our pipeline. The success of a continuous
    integration pipeline depends strongly on the quality and quantity of the tests
    produced. Tests will typically be broken up into functional and non-functional
    tests. In order to best take advantage of your pipeline, you will want to catch
    possible errors as early as possible. This means focusing on the functional tests
    and in particular the **unit tests,** which are used to validate small units of
    code such as a method in a class.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只创建了一个功能性测试来演示如何使用 TDD 方法以及如何将测试步骤集成到我们的流水线中。持续集成流水线的成功在很大程度上依赖于所编写的测试的质量和数量。测试通常会分为功能性测试和非功能性测试。为了最好地利用你的流水线，你需要尽早捕捉到可能的错误。这意味着要集中精力做功能性测试，特别是**单元测试**，这些测试用于验证小单元的代码，例如类中的方法。
- en: 'After this, you can focus on **integration testing,** which covers a bit more
    ground and usually interacts with data stores and other functions in the code.
    Finally, you will want to add **acceptance testing** to verify that all the requirements
    for your stories are complete:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，你可以专注于**集成测试**，它涵盖的范围更广，通常涉及数据存储和代码中的其他功能。最后，你还需要添加**验收测试**，以验证你的故事需求是否完整：
- en: '![](img/4a791083-e83e-48b0-a39f-81c6ca5fa43a.png)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a791083-e83e-48b0-a39f-81c6ca5fa43a.png)'
- en: In terms of non-functional testing, you will usually want to look at **performance**,
    **security**, **usability,** and **compatibility** testing.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在非功能性测试方面，你通常会关注**性能**、**安全性**、**可用性**和**兼容性**测试。
- en: Finally, you can complement your own tests with code analyzer tools to get a
    sense of the code coverage (how many lines of code are executed by your automated
    tests).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以借助代码分析工具来补充自己的测试，以了解代码覆盖率（自动化测试执行了多少行代码）。
- en: As always with DevOps, it is important to collect metrics. In a CI pipeline,
    you will typically want to monitor the number of builds that go through the CI
    pipeline and the quality of the pull requests.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一如既往，DevOps 中收集指标非常重要。在持续集成（CI）流水线中，你通常需要监控通过 CI 流水线的构建数量以及拉取请求的质量。
- en: Like any other system, you will need to spend a bit of time setting up backups
    and monitoring. You may decide to back up the Jenkins home directory if you haven't
    moved to a model where your jobs and the Jenkins configuration are managed by
    your configuration management system (Ansible). In terms of metrics, keeping an
    eye on the system performance, its availability, and health are paramount. A breakage
    in the build pipeline should be considered a critical issue as it impacts the
    productivity of all the developers and operators.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 像任何其他系统一样，你需要花一些时间来设置备份和监控。如果你还没有迁移到由配置管理系统（如 Ansible）管理你的作业和 Jenkins 配置的模型，你可能会决定备份
    Jenkins 主目录。在指标方面，监控系统性能、可用性和健康状况是至关重要的。构建流水线出现故障应该被视为一个关键问题，因为它会影响所有开发人员和运维人员的生产力。
- en: Finally, you should expect to have to scale up your CI infrastructure over time.
    As code and tests get added, it will take longer and longer to run the tests.
    You may decide to add more Jenkins slaves, which will allow you to run tests in
    parallel and/or use bigger instances. In the current format, Jenkins will run
    the `helloworld` pipeline every time a change is pushed to a branch. You may also
    decide to only run the pipeline once the pull requests are created.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你应该预期随着时间推移，CI 基础设施需要扩展。随着代码和测试的增加，运行测试的时间会越来越长。你可能会决定增加更多的 Jenkins 从机，这样可以并行运行测试和/或使用更强大的实例。在当前格式下，每次有变更推送到分支时，Jenkins
    都会运行 `helloworld` 流水线。你还可以决定仅在创建拉取请求时才运行流水线。
- en: In the initial section of this chapter, we adopted a new workflow where developers
    commit code and tests to individual branches and send frequent pull requests to
    share the proposed changes with the rest of the engineering organization. In addition,
    we made sure that the new code is fully tested by creating a continuous integration
    pipeline. To do this, we created a Jenkins server and hooked it to GitHub. Thanks
    to that system, all the tests committed with the project get automatically executed
    and the results are sent back to GitHub. We are now in an ideal situation to take
    our workflow to the next level and automate deployment.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的初始部分，我们采用了一个新工作流，开发人员将代码和测试提交到各自的分支，并频繁发送拉取请求，与其他工程师共享提议的变更。此外，我们通过创建持续集成流水线确保新代码经过充分测试。为此，我们创建了一个
    Jenkins 服务器并将其与 GitHub 连接。通过该系统，所有与项目一起提交的测试会自动执行，测试结果会返回到 GitHub。现在，我们处于一个理想的状态，可以将工作流提升到下一个层次，并实现部署自动化。
- en: '**Are the QA teams no longer needed with DevOps?**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**DevOps 是否不再需要 QA 团队？**'
- en: Yes and no. In an effective DevOps organization, non-technical QA jobs are not
    usually needed. If everything is fully automated and the developers write sufficient
    tests to cover all aspects of the code, the organization doesn't need to task
    anyone to write and execute test plans. Instead of that, DevOps-focused organizations
    will have engineers, sometimes called QA engineers, who focus on quality but with
    an emphasis on automation. This involves working on tooling and processes to improve
    the ability to automatically test code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，也不是。在一个高效的 DevOps 组织中，通常不需要非技术性的 QA 工作。如果一切都已完全自动化，并且开发人员编写了足够的测试覆盖所有代码的方面，那么组织不需要安排人来编写和执行测试计划。相反，专注于
    DevOps 的组织将有工程师，有时被称为 QA 工程师，他们专注于质量，但重点是自动化。这涉及到开发工具和流程，以提高自动化测试代码的能力。
- en: Building a continuous deployment pipeline
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建持续部署流水线
- en: By creating a CI pipeline, we have taken the first step toward being an effective
    **engineering** organization. Because our workflow now involves working in individual
    branches and merging them back to the master branch after going through automated
    testing and human reviews, we can assume that the code present in the master branch
    is of high quality and is safe to deploy. We can now focus on the next challenge,
    which is to release code automatically as new code gets merged into the master
    branch.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建 CI 流水线，我们迈出了成为高效**工程**组织的第一步。因为我们的工作流现在包括在各个分支上进行工作，并在经过自动化测试和人工审核后将其合并回主分支，我们可以假设主分支中的代码质量较高，并且可以安全部署。现在我们可以专注于下一个挑战，那就是在新代码合并到主分支后，自动发布代码。
- en: By continuously releasing new code, you drastically accelerate the feedback
    loop process that DevOps provides. Releasing new code to production at high speed
    lets you collect real customer metrics, which often leads to exposing new and
    often unexpected issues. For many companies, deploying new code to production
    is a challenge. It can be quite worrying, especially if it involves thousands
    of new commits all going out to production at the same time in a process that
    occurs only a few times a year. Companies that do this often schedule their maintenance
    late at night and during weekends. Adopting a more modern approach, such as the
    one we will go through in the remainder of the chapters, will have a significant
    positive impact on the work-life balance of the engineering team.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 通过持续发布新代码，你大幅加快了 DevOps 提供的反馈循环过程。以高速将新代码发布到生产环境，能够收集真实的客户数据，这通常会暴露出新的且往往是意想不到的问题。对于许多公司来说，将新代码部署到生产环境是一项挑战。特别是当涉及到成千上万的新的提交同时发布到生产环境时，这种过程一年只有几次，可能会让人感到焦虑。做这件事的公司通常会安排在深夜或周末进行维护。采用更现代化的方法，像我们将在后续章节中介绍的，将对工程团队的工作与生活平衡产生显著的积极影响。
- en: Most well-known tech companies such as Google or Facebook don't deploy code
    on Fridays. The goal is to avoid pushing bugs out just before the weekend, which could otherwise
    lead to unexpected pages on Saturdays or Sundays. Because they aren't scared of
    deploying code, a lot of those changes will go out to production at peak hours
    so that they can quickly catch any issues related to load.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 像 Google 或 Facebook 这样的知名科技公司通常不在周五部署代码。目的是避免在周末前发布存在漏洞的代码，这可能导致周六或周日出现意外问题。因为他们不害怕部署代码，许多变更会在高峰时段发布到生产环境，以便能够快速捕捉到与负载相关的问题。
- en: 'In order to implement our continuous deployment pipeline, we are going to look
    at two new AWS services—**CodePipeline** and **CodeDeploy**:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现我们的持续部署流水线，我们将重点介绍两个新的 AWS 服务——**CodePipeline** 和 **CodeDeploy**：
- en: CodePipeline let us create our deployment pipeline. We will tell it to take
    our code from GitHub, like we did before, and send it to Jenkins to run CI testing
    on it. Instead of simply returning the result to GitHub, however, we will then
    take the code and deploy it to our EC2 instance with the help of AWS CodeDeploy.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodePipeline 让我们可以创建部署流水线。我们将告诉它从 GitHub 获取代码，像之前一样，将其发送到 Jenkins 进行 CI 测试。然而，与其仅仅将结果返回到
    GitHub，我们接着会通过 AWS CodeDeploy 将代码部署到我们的 EC2 实例上。
- en: CodeDeploy is a service that lets us properly deploy code to our EC2 instances.
    By adding a certain number of configuration files and scripts, we can use CodeDeploy
    to deploy and test our code reliably. Thanks to CodeDeploy, we don't have to worry
    about any kind of complicated logic when it comes to sequencing our deployment.
    It is tightly integrated with EC2 and knows how to perform rolling updates across
    multiple instances and, if needed, perform a rollback.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeDeploy 是一项服务，允许我们将代码正确地部署到 EC2 实例上。通过添加一定数量的配置文件和脚本，我们可以使用 CodeDeploy 来可靠地部署和测试我们的代码。得益于
    CodeDeploy，我们不必担心部署顺序的复杂逻辑。它与 EC2 紧密集成，知道如何在多个实例之间执行滚动更新，并在需要时执行回滚。
- en: In [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as Code*, we looked at how to configure servers and deploy the `helloworld` application
    using Ansible. While this solution allowed us to illustrate how to use configuration
    management, this solution is not good enough for a more critical service. There
    isn't any notion of sequencing, there are no good feedback mechanisms to tell
    us how the deploy went, and we didn't implement any validation steps.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)《将基础设施视为代码》中，我们查看了如何使用 Ansible
    配置服务器并部署`helloworld`应用程序。虽然这个解决方案允许我们演示如何使用配置管理，但它对于更关键的服务来说并不够好。没有顺序概念，也没有良好的反馈机制来告诉我们部署是否成功，此外我们也没有实现任何验证步骤。
- en: Having a dedicated service geared towards carrying out deployments in AWS will
    make deploying applications a lot better, as we will see in the following section. In
    order to demonstrate these services, we will first build a new generic Node.js
    web server using Ansible.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个专门针对 AWS 部署的服务，将使得部署应用程序变得更加高效，正如我们将在接下来的部分中看到的那样。为了演示这些服务，我们将首先使用 Ansible
    构建一个新的通用 Node.js web 服务器。
- en: Creating new web servers for continuous deployment
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为持续部署创建新的 web 服务器
- en: In order to use CodeDeploy, the EC2 instances need to be running the CodeDeploy
    agent. This is normally done by downloading an executable from an S3 bucket, which
    varies depending on the region your instances are running in. Conveniently, AWS
    has also released a custom Ansible library, which can automate these steps. Because
    that library isn't a part of the standard Ansible library, we first need to add
    it to our Ansible repository.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 CodeDeploy，EC2 实例需要运行 CodeDeploy 代理。通常通过从 S3 存储桶中下载一个可执行文件来完成此操作，具体取决于你的实例所在的区域。方便的是，AWS
    还发布了一个自定义 Ansible 库，可以自动化这些步骤。由于该库不是标准的 Ansible 库的一部分，我们首先需要将其添加到我们的 Ansible 仓库中。
- en: Importing a custom library to Ansible for AWS CodeDeploy
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将自定义库导入 Ansible 以用于 AWS CodeDeploy
- en: By default, Ansible expects to find the custom libraries in the `/usr/share/my_modules/`
    directory. Previously, when we looked at the inventory script in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*, we changed this default behavior by editing
    the `ansible.cfg` file. We will make the necessary changes so that the library
    is being downloaded onto the host with the rest of the Ansible files. The simplest
    way to accomplish this is to create a new directory at the root of our `ansible`
    repository and put the library in it.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ansible 期望在`/usr/share/my_modules/`目录中找到自定义库。之前，我们在[第 3 章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)《将基础设施视为代码》中查看了清单脚本，*将基础设施视为代码*，并通过编辑`ansible.cfg`文件更改了这个默认行为。我们将进行必要的更改，使得库文件与其他
    Ansible 文件一起下载到主机上。完成此操作的最简单方法是在`ansible`仓库的根目录创建一个新目录，并将库放在其中。
- en: 'On your computer, open a Terminal and go to your `ansible` directory:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的电脑上，打开终端并进入你的`ansible`目录：
- en: 'In the root directory of our `ansible` repository, where the `ansible.cfg`
    file is located, we are going to add the new directory library to store the AWS
    CodeDeploy `ansible` library:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们`ansible`仓库的根目录中，`ansible.cfg`文件所在的位置，我们将添加一个新的目录库，用于存放 AWS CodeDeploy `ansible`库：
- en: '[PRE51]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Once the folder is created, we can download the `ansible` library in it:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 文件夹创建完成后，我们可以将`ansible`库下载到其中：
- en: '[PRE52]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Lastly, we are going to edit the `ansible.cfg` file that is present in the
    root directory of the `ansible` repository to specify the location of the library
    folder as follows:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将编辑位于`ansible`仓库根目录中的`ansible.cfg`文件，以指定库文件夹的位置，如下所示：
- en: '[PRE53]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We are now ready to start using the library. CodeDeploy is a service that we
    are likely to reuse over time as new services get added to our system. In order
    to ensure that our Ansible repository code conforms to the **Don't Repeat Yourself**
    (**DRY**) principle, we are going to create an Ansible role that is dedicated
    to CodeDeploy.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备开始使用这个库。CodeDeploy是一个我们可能会随着新服务加入系统而不断重用的服务。为了确保我们的Ansible仓库代码符合**不要重复自己**（**DRY**）原则，我们将创建一个专门用于CodeDeploy的Ansible角色。
- en: Creating a CodeDeploy Ansible role
  id: totrans-290
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个CodeDeploy Ansible角色
- en: 'We are first going to go into the role directory that is present at the root
    location of our `ansible` repository:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先进入位于`ansible`仓库根目录的角色目录：
- en: '[PRE54]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'As before, we will rely on `ansible-galaxy` to put in place the scaffolding
    that is needed to create our role:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将依赖`ansible-galaxy`来设置创建角色所需的框架：
- en: '[PRE55]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Our role will be very simple. We are going to edit the `codedeploy/tasks/main.yml` file
    and make a call to the new module that the `aws_codedeploy` library provides,
    as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的角色将非常简单。我们将编辑`codedeploy/tasks/main.yml`文件，并调用`aws_codedeploy`库提供的新模块，如下所示：
- en: '[PRE56]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'At this point, we can create our new playbook for generic `nodejs` web servers.
    First, go back in the root directory of the `ansible` repository:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，我们可以为通用`nodejs` Web服务器创建新的剧本。首先，返回到`ansible`仓库的根目录：
- en: '[PRE57]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Create a new file called `nodeserver.yml`:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`nodeserver.yml`的新文件：
- en: '[PRE58]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We will take the same approach we did previously with our other playbooks.
    The goal of our servers will be to run Node.js applications and run the CodeDeploy
    daemon. Edit the `nodeserver.yml` file and add the following to it:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用与之前其他剧本相同的方法。我们的服务器目标是运行Node.js应用程序并启动CodeDeploy守护进程。编辑`nodeserver.yml`文件，并添加如下内容：
- en: '[PRE59]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: When using CodeDeploy in a config management system such as Ansible or CloudFormation, it
    is important to always install all the dependencies for your application prior
    to starting it. This allows you to avoid a race condition.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用CodeDeploy与配置管理系统（如Ansible或CloudFormation）时，重要的是始终在启动应用程序之前安装所有依赖项。这可以帮助您避免竞态条件。
- en: 'We can now commit our changes to `git`. First, create a new branch and then
    add new files and directories that we created:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以将更改提交到`git`。首先，创建一个新分支，然后添加我们创建的新文件和目录：
- en: '[PRE60]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Finally, `commit` and `push` the changes:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`commit`并`push`更改：
- en: '[PRE61]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'As before, you can now create a pull request. Once the pull request has been
    reviewed and approved, merge it back to the master. After you have followed these
    steps, your Ansible repository should look as follows: [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter05/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter05/ansible).'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，您现在可以创建一个拉取请求。一旦拉取请求被审查和批准，将其合并回主分支。按照这些步骤操作后，您的Ansible仓库应该如下所示：[https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter05/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter05/ansible)。
- en: Creating the web server CloudFormation template
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Web服务器CloudFormation模板
- en: 'As we now have our Ansible playbook ready, we can create our CloudFormation
    template using Troposphere. Start by duplicating the Troposphere script that we
    created for Jenkins earlier in the chapter:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了Ansible剧本，可以使用Troposphere创建CloudFormation模板。首先，复制我们之前为Jenkins创建的Troposphere脚本：
- en: '[PRE62]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Edit the `nodeserver-cf-template.py` file to make the following changes. First,
    change the application name and port by updating the variables as follows:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑`nodeserver-cf-template.py`文件，进行如下更改。首先，通过更新变量来更改应用程序名称和端口：
- en: '[PRE63]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'In addition, our instances will need to download files from S3\. To allow this
    to happen, replace the policy that allowed CodePipeline on our Jenkins instance
    with a policy to allow S3\. Edit the policy called `AllowCodePipeline` and update
    its name and action. Above the instantiation of our instance, add a new IAM policy
    resource as follows:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们的实例需要从S3下载文件。为了实现这一点，替换允许Jenkins实例上CodePipeline的策略，使用允许S3的策略。编辑名为`AllowCodePipeline`的策略，更新其名称和操作。在实例化我们的实例上方，添加一个新的IAM策略资源，如下所示：
- en: '[PRE64]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The new script should look as follows: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/nodeserver-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/nodeserver-cf-template.py).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 新的脚本应该如下所示：[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/nodeserver-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/nodeserver-cf-template.py)。
- en: 'As the new script is now ready, we can save it and generate the CloudFormation
    template as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 由于新脚本已经准备好，我们可以保存它并按以下方式生成 CloudFormation 模板：
- en: '[PRE65]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Launching our web server
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动我们的 Web 服务器
- en: 'As before, we are going to launch our instance using CloudFormation. Note that
    we are calling this first stack `helloworld-staging`. We will first look at CodeDeploy
    as a way to deploy our code to a staging environment. We will use this name in
    CodeDeploy so that we can target the deployments to that specific stack:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 和以前一样，我们将使用 CloudFormation 启动我们的实例。请注意，我们将第一个堆栈命名为 `helloworld-staging`。我们将首先将
    CodeDeploy 用作将代码部署到暂存环境的一种方式。我们将在 CodeDeploy 中使用这个名称，以便将部署目标定位到该特定堆栈：
- en: '[PRE66]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: In a few minutes, our instance will be ready.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，我们的实例将准备好。
- en: We are now at an important point in our DevOps transformation. We have now created
    generic `nodejs` web servers that allow you to deploy code on them easily. We
    are really close to a realistic environment that effective companies traditionally
    use to deploy and run their services. The fact that we are able to create these
    environments simply and on demand is our key to success.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正处于 DevOps 转型的一个重要节点。我们已经创建了通用的 `nodejs` Web 服务器，允许你轻松地在其上部署代码。我们距离一个现实的环境非常接近，企业通常用来部署和运行其服务。我们能够轻松、按需创建这些环境，正是我们成功的关键。
- en: When architecting services, always make sure that the infrastructure can easily
    be recreated. Being able to troubleshoot an issue is great, but being able to
    quickly rebuild a service host and stop the impact on the user is often even more
    desirable.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在架构服务时，始终确保基础设施可以轻松重建。能够排查问题是很好的，但能够快速重建服务主机并停止对用户的影响，通常是更为理想的。
- en: Integrating our helloworld application with CodeDeploy
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的 helloworld 应用程序与 CodeDeploy 集成
- en: Now that our servers are initiated and the CodeDeploy agent is running, we can
    start using them. First, we need to create an IAM service role for CodeDeploy.
    We then need to add an entry in the CodeDeploy service to define our application.
    Finally, we need to add our application specification file and a few scripts to
    help with deploying and running our service to the `helloworld` application.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的服务器已经初始化，CodeDeploy 代理正在运行，我们可以开始使用它们了。首先，我们需要为 CodeDeploy 创建一个 IAM 服务角色。接着，我们需要在
    CodeDeploy 服务中添加一个条目来定义我们的应用程序。最后，我们需要添加我们的应用程序规范文件以及一些脚本，帮助部署和运行我们的服务到 `helloworld`
    应用程序。
- en: Creating the IAM service role for CodeDeploy
  id: totrans-327
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CodeDeploy 的 IAM 服务角色
- en: 'CodeDeploy permissions work with IAM at the level of the individual application.
    In order to provide sufficient permissions, we will create a new IAM service role
    with the following policy:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy 权限在 IAM 中是以单个应用程序为单位工作的。为了提供足够的权限，我们将创建一个新的 IAM 服务角色，并附加以下策略：
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'We will create a new role that will be called `CodeDeployServiceRole` using
    the following command in the command-line interface:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下命令在命令行界面中创建一个名为 `CodeDeployServiceRole` 的新角色：
- en: '[PRE68]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We now need to attach the role policy to provide the proper permissions to
    the service role:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要附加角色策略，以为服务角色提供适当的权限：
- en: '[PRE69]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Our IAM service role is now ready. We can finally start interacting with the
    CodeDeploy web interface.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 IAM 服务角色现在已经准备好。我们终于可以开始与 CodeDeploy Web 界面交互了。
- en: Creating the CodeDeploy application
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 CodeDeploy 应用程序
- en: 'Now that we have launched EC2 instances with the CodeDeploy service running
    on them and defined our IAM service role, we have all the requirements to create
    a CodeDeploy application. As always, there are many ways to use AWS services,
    but we will demonstrate the basic uses with the web interface in this section:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经启动了 EC2 实例，并在其上运行 CodeDeploy 服务，定义了我们的 IAM 服务角色，我们具备了创建 CodeDeploy 应用程序所需的所有条件。像往常一样，AWS
    服务有许多使用方式，但在这一部分，我们将通过 Web 界面演示其基本用法：
- en: Open [https://console.aws.amazon.com/codedeploy](https://console.aws.amazon.com/codedeploy)
    in your browser.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 [https://console.aws.amazon.com/codedeploy](https://console.aws.amazon.com/codedeploy)。
- en: If prompted, click on Get Started Now.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有提示，点击立即开始。
- en: This leads us to a welcome screen with two options, Sample Deployment and Custom
    Deployment. Choose Custom Deployment and click on Skip Walkthrough**.** This brings
    us to a form called Create Application.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们进入一个欢迎页面，提供两个选项，Sample Deployment 和 Custom Deployment。选择 Custom Deployment
    并点击跳过操作指南。接着，我们将进入一个名为创建应用程序的表单。
- en: In that form, under Application Name, give our application the name `helloworld`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单中，在应用程序名称下，给我们的应用程序命名为 `helloworld`。
- en: The deployment groups can be viewed as the environment in which the application
    will live. We will first create a staging environment. Under Deployment Group
    Name, provide the name `staging`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署组可以被视为应用程序将要运行的环境。我们将首先创建一个暂存环境。在“Deployment Group Name”字段中，提供名称`staging`。
- en: 'We now need to add instances to our application. Our goal is to target the
    EC2 instance that we previously created with CloudFormation. As you might recall,
    we called our stack `helloworld-staging`. In the section Environment configuration,
    select Amazon EC2 instances, and select `aws:cloudformation:stack-name` in the
    Key field and `helloworld- staging` in the Value field. This will make sure that
    CodeDeploy only selects the instance that we intend to use for our application.
    AWS CodeDeploy should confirm that it matched one instance:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要向我们的应用程序添加实例。我们的目标是针对之前使用CloudFormation创建的EC2实例。如你所记，我们把我们的堆栈命名为`helloworld-staging`。在“环境配置”部分，选择Amazon
    EC2实例，在“Key”字段选择`aws:cloudformation:stack-name`，在“Value”字段选择`helloworld-staging`。这将确保CodeDeploy只选择我们打算用于应用程序的实例。AWS
    CodeDeploy应该确认它匹配到了一个实例：
- en: '![](img/b2b61b09-cff2-43b7-9d2a-8fe58e409a65.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2b61b09-cff2-43b7-9d2a-8fe58e409a65.png)'
- en: The next section is called **Deployment configuration**. One of the strengths
    of CodeDeploy is its ability to understand how to deploy code to a cluster of
    servers. This features makes it easy to avoid outages during deployment. By default,
    the service comes with three deployment options—one at a time, all at once, and
    half at a time. It is possible to create custom deployment configurations, but
    in our case, since we have only one instance, we can leave the default option
    `CodeDeployDefault.OneAtATime`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的部分叫做**部署配置**。CodeDeploy的一个优势是它能够理解如何将代码部署到服务器集群。这一功能使得在部署过程中能够轻松避免停机。默认情况下，服务提供三种部署选项——一次一个、一次全部、和一半一个。虽然可以创建自定义的部署配置，但在我们的案例中，由于我们只有一个实例，可以保留默认选项`CodeDeployDefault.OneAtATime`。
- en: The next two sections are called triggers and alarms. We aren't going to cover
    these in detail in this book, but basically triggers are useful when it comes
    to collecting metrics around deployment and monitoring. By creating triggers to
    push notifications in SNS and creating CloudWatch metrics, you can easily collect
    metrics around deployments. This helps you answer questions such as how many deployments
    are happening, how many fail, how many deploys lead to rollback, and so on.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两个部分被称为触发器和警报。在本书中我们不会详细讲解这些内容，但基本上，触发器在收集部署和监控相关的指标时非常有用。通过创建触发器，将通知推送到SNS并创建CloudWatch指标，你可以轻松收集与部署相关的指标。这有助于你回答诸如发生了多少次部署、多少次失败、多少次部署导致回滚等问题。
- en: Our application is somewhat stateless, therefore enabling rollback upon failure
    is a good idea. Select the Roll back when a deployment fails option.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们的应用程序是无状态的，因此在失败时启用回滚是个好主意。选择“部署失败时回滚”选项。
- en: Lastly, we need to select the service role that we created in the previous steps.
    Under Service Role ARN, select the role that ends with CodeDeployServiceRole.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要选择在之前步骤中创建的服务角色。在“Service Role ARN”字段中，选择以CodeDeployServiceRole结尾的角色。
- en: Finally, click on Create Application.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击“创建应用程序”。
- en: This brings us back to the CodeDeploy application page for our newly created
    `helloworld` application.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 这将带我们回到CodeDeploy应用页面，展示我们新创建的`helloworld`应用。
- en: Creating the application in CodeDeploy allows us to define where our newly created
    application will be deployed. We will now look at how to deploy our code.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 在CodeDeploy中创建应用程序使我们能够定义我们新创建的应用程序将被部署到哪里。现在我们来看看如何部署我们的代码。
- en: Adding the CodeDeploy configuration and scripts to our repository
  id: totrans-351
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将CodeDeploy配置和脚本添加到我们的仓库
- en: When we worked on creating a Jenkins pipeline earlier in this chapter, we created
    a Jenkinsfile file inside the `helloworld` GitHub repository. The reason for this
    was that we could change the code and the way the code is tested in the same change
    set. For the same reason, it is a good idea to put the logic about how to deploy
    our code with the code itself.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在本章早些时候创建Jenkins流水线时，我们在`helloworld` GitHub仓库中创建了一个Jenkinsfile文件。这样做的原因是我们可以在同一更改集中同时更改代码和代码的测试方式。出于同样的原因，将如何部署代码的逻辑与代码本身放在一起是个好主意。
- en: Our `helloworld` repository currently contains the application that we created
    inside a new GitHub organization (`yogeshrahejahelloworld` in my case). It also
    contains the applications tests and a repository with name `helloworld` . We are
    now going to add the information that CodeDeploy needs in order to execute the
    deployment of our service.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`helloworld`仓库目前包含我们在一个新的GitHub组织（在我的情况下是`yogeshrahejahelloworld`）中创建的应用程序。它还包含应用程序的测试和一个名为`helloworld`的仓库。我们现在将添加CodeDeploy所需的信息，以便执行我们的服务部署。
- en: 'CodeDeploy relies on an application specification file called `appspec.yml`
    to manage deployment. We first need to create this file. Go to the directory where
    the `helloworld` GitHub project is cloned and create a new branch off the master:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy依赖于名为`appspec.yml`的应用程序规范文件来管理部署。我们首先需要创建这个文件。进入克隆了`helloworld` GitHub项目的目录并从master分支创建一个新分支：
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We are now going to create and edit the file `appspec.yml`:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建并编辑文件`appspec.yml`：
- en: '[PRE71]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'On the first line of the file, we are going to define which version of the
    AppSpec file we want to use. Currently, the only version that is supported is
    `0.0`:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的第一行，我们将定义想要使用的AppSpec文件版本。目前，唯一支持的版本是`0.0`：
- en: '[PRE72]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'On the next line, we are going to specify the operating system on which we
    wish to deploy our service. In our case, this is Linux:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行，我们将指定我们希望部署服务的操作系统。在我们的案例中，这是Linux：
- en: '[PRE73]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We are now going to describe which file goes where. To do this, we are going
    to create a section called `files` and put each file that we want to deploy using
    a format source destination. Note that the file is written in YAML and therefore
    the spacing and alignment are important:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将描述每个文件应该放在哪里。为此，我们将创建一个名为`files`的部分，并使用格式`source destination`将我们要部署的每个文件放入其中。请注意，文件是用YAML编写的，因此空格和对齐非常重要：
- en: '[PRE74]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Thanks to this section, CodeDeploy now knows to copy the `helloworld.js` in
    the target destination, `/usr/local/helloworld`. Our `helloworld` directory will
    be automatically created by CodeDeploy. In order to start the application, we
    will also need our upstart script, which isn't currently in the repository.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一部分，CodeDeploy现在知道将`helloworld.js`复制到目标位置`/usr/local/helloworld`。我们的`helloworld`目录将由CodeDeploy自动创建。为了启动应用程序，我们还需要我们的upstart脚本，而它目前不在仓库中。
- en: 'Back in the Terminal of  the root directory of the `helloworld` project, we
    are going to create a subdirectory called `scripts` and add the upstart script
    to it:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 回到`helloworld`项目的根目录的终端，我们将创建一个名为`scripts`的子目录，并将upstart脚本添加到其中：
- en: '[PRE75]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'We can now add the `helloworld.conf` file that new file to our `appspsec.yml`
    by adding another block with the source and destination of the upstart script
    as follows:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以将新的`helloworld.conf`文件添加到我们的`appspec.yml`中，通过添加另一个块来指定upstart脚本的源和目标位置，如下所示：
- en: '[PRE76]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'The two files that we need in order to run our application as a service will
    now be present in the appropriate locations. In order to deploy our application,
    we need more files. We need CodeDeploy to start and stop the service. Previously,
    we started the application using Ansible, but this time around we aren''t using
    Ansible to manage our service. CodeDeploy has a much more elegant solution: when
    a deployment starts, the CodeDeploy agent running on the EC2 instance will go
    through the following sequence of events:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的应用程序作为服务所需的两个文件现在已经放置在适当的位置。为了部署我们的应用程序，我们还需要更多的文件。我们需要CodeDeploy来启动和停止服务。之前，我们使用Ansible来启动应用程序，但这次我们不再使用Ansible来管理服务。CodeDeploy提供了一个更优雅的解决方案：当部署开始时，运行在EC2实例上的CodeDeploy代理将按照以下事件序列进行操作：
- en: '![](img/90cf2590-75a6-4078-93da-0405583c3e9a.jpg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90cf2590-75a6-4078-93da-0405583c3e9a.jpg)'
- en: The archive containing our application will be downloaded on the system during
    the **DownloadBundle** event. The install section will be used to copy the files
    defined in our template to their destinations.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 包含我们应用程序的档案将在**DownloadBundle**事件期间下载到系统中。安装部分将用于将我们模板中定义的文件复制到它们的目标位置。
- en: 'CodeDeploy uses the concept of hooks. In the `appspec.yml` file we can create
    a number of hooks to execute custom scripts during each of the stages described
    previously. We are going to create three scripts: a script to start our application,
    a script to stop it, and finally a script to check if the deployment was successful.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: CodeDeploy使用钩子（hooks）的概念。在`appspec.yml`文件中，我们可以创建多个钩子，在之前描述的每个阶段执行自定义脚本。我们将创建三个脚本：一个脚本用来启动应用程序，一个脚本用来停止它，最后一个脚本用来检查部署是否成功。
- en: 'We will put these three scripts in the `scripts` directory that we created
    previously. Let''s create the first file `start.sh` and start editing it:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这三个脚本放在之前创建的`scripts`目录中。让我们创建第一个文件`start.sh`并开始编辑它：
- en: '[PRE77]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The script is very straightforward. We are simply going to call upstart to
    start the service:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本非常简单。我们只是简单地调用upstart来启动服务：
- en: '[PRE78]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'This is all we need. We are now going to create our stop script file:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们所需要的一切。现在我们要创建我们的停止脚本文件：
- en: '[PRE79]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'As we did before, edit it as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以前所做的那样，按以下方式编辑它：
- en: '[PRE80]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'The stop script is slightly more complicated than the start script because
    it will be executed during the `BeforeInstall` step. The basic logic is the same:
    we are making a call to stop the `helloworld` application. We have some extra
    calls before this because we need to handle the case of the first deployment where
    the application hasn''t been installed and started before.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 停止脚本比启动脚本稍微复杂，因为它将在`BeforeInstall`步骤期间执行。基本逻辑相同：我们正在调用停止`helloworld`应用程序。在此之前我们有一些额外的调用，因为我们需要处理第一次部署的情况，即应用程序在安装和启动之前尚未安装。
- en: 'The last script we will create is called `validate.sh`:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建的最后一个脚本称为`validate.sh`：
- en: '[PRE81]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Once again the code is very simple:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，代码非常简单：
- en: '[PRE82]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: For the purposes of this book, we are carrying out the most basic validation
    possible. This consists of a HEAD request on the only route that our application
    has. In a more realistic application, we would test more routes and anything that
    could potentially go wrong when new code is pushed out.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本书的目的，我们正在进行尽可能基本的验证。这包括对我们的应用程序唯一路由的HEAD请求。在更真实的应用程序中，我们将测试更多的路由和在推送新代码时可能出错的任何内容。
- en: 'Our scripts need to be executable to avoid any unnecessary warnings in CodeDeploy:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的脚本需要是可执行的，以避免CodeDeploy中的任何不必要的警告：
- en: '[PRE83]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'We can now add our hooks in our `appspec.yml` file. Open the file again and create
    a `hooks` section below the `files` section:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在我们的`appspec.yml`文件中添加我们的钩子。重新打开文件并在`files`部分下创建一个`hooks`部分：
- en: '[PRE84]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We will first declare the stop script that we want to run at the `BeforeInstall`
    stage. In the hooks section, add the following:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先声明我们希望在`BeforeInstall`阶段运行的停止脚本。在hooks部分中，添加以下内容：
- en: '[PRE85]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'We are allowing `30` seconds for the execution of the stop command to complete. We
    are going to repeat a similar operation to add our start and validate scripts
    as follows:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 我们允许`30`秒来完成停止命令的执行。我们将重复类似的操作以添加我们的启动和验证脚本如下：
- en: '[PRE86]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'When our deploy pipeline runs, it will try to do the following:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的部署管道运行时，它将尝试执行以下操作：
- en: Download our application package and decompress it in a temporary directory
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载我们的应用程序包并在临时目录中解压缩它
- en: Run the stop script
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行停止脚本
- en: Copy the application and upstart script
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制应用程序和upstart脚本
- en: Run the start script
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行启动脚本
- en: Run the validate script to make sure everything is working as expected
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行验证脚本以确保一切正常运行
- en: 'We can add all our new files to `git`, commit and push the changes, and send
    a pull request as follows:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将所有新文件添加到`git`中，提交并推送更改，并按以下方式发送拉取请求：
- en: '[PRE87]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: The branch will go through Jenkins and be tested. A peer can then review the
    code change; once it is approved, you can merge your pull request.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 分支将通过Jenkins进行测试。同行可以审查代码更改；一旦批准，您可以合并您的拉取请求。
- en: In order to perform deployment, we essentially need to answer three questions—*what
    are we trying to deploy?* *Where are we trying to deploy it?* *How can we deploy
    it?* We answered the second question when we created the job in CodeDeploy and
    the third question with our appspec file and its helper scripts. We now need to
    look into the first question—*what are we trying to deploy?* This is where we
    are going to use AWS CodePipeline.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进行部署，我们基本上需要回答三个问题—*我们试图部署什么？* *我们试图将其部署到哪里？* *我们如何部署它？* 在我们创建了CodeDeploy作业时，我们已经回答了第二个问题，并且在我们的appspec文件及其辅助脚本中回答了第三个问题。现在我们需要研究第一个问题—*我们试图部署什么？*
    这就是我们将使用AWS CodePipeline的地方。
- en: Building our deployment pipeline with AWS CodePipeline
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用AWS CodePipeline构建我们的部署管道
- en: AWS CodePipeline is a service dedicated to creating delivery pipelines. You
    can think of it as similar to the Jenkins pipelines feature with an AWS twist.
    The service is very well integrated with the rest of the AWS ecosystem, which
    means that it has a number of great features and useful advantages over Jenkins.
    Because it's a fully managed service, you don't have to worry about its uptime
    the way we do with a single Jenkins instance. It integrates out of the box with
    CodeDeploy, which is very handy for our case. While we won't go into too much
    detail here, the service is fully integrated with the IAM service, which means
    that you have a very granular level of control over who can do what. The service
    can, for example, prevent unauthorized users from performing deployments. Thanks
    to its API, a number of services can be integrated into your pipelines, including
    Jenkins and GitHub.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodePipeline 是一项专门用于创建交付流水线的服务。你可以把它看作是类似于 Jenkins 流水线功能的 AWS 版本。这项服务与 AWS
    生态系统的其他部分高度集成，这意味着它相较于 Jenkins 具有许多优秀的功能和优势。由于它是完全托管的服务，你不必像使用单个 Jenkins 实例时那样担心其正常运行时间。它与
    CodeDeploy 即开即用集成，这对于我们的情况非常方便。虽然我们在这里不详细讨论，但该服务完全与 IAM 服务集成，这意味着你可以非常精细地控制谁可以做什么。例如，该服务可以阻止未经授权的用户执行部署。凭借其
    API，多个服务可以集成到你的流水线中，包括 Jenkins 和 GitHub。
- en: We will first look into creating a basic pipeline in two stages. In the first
    stage, we will get the code from GitHub, package it, and store the package on
    S3\. In the second stage, we will take that package and deploy it to our staging
    instance using CodeDeploy.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何创建一个包含两个阶段的基本流水线。在第一阶段，我们将从 GitHub 获取代码，将其打包，并将包存储在 S3 中。在第二阶段，我们将使用
    CodeDeploy 将该包部署到我们的暂存实例中。
- en: After that, we will go through a more advanced scenario. We will see how we
    can use our Jenkins instance to run our tests before deploying our code to staging.
    We will also create a production environment and add an on-demand production deployment
    process, called a continuous delivery pipeline. Finally, we will look at a couple
    of strategies that will allow us to build confidence in the code that we push
    through our pipeline so that we will be able to remove the on-demand production
    deployment step and turn it into a fully automated pipeline.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过一个更高级的场景。我们将看看如何利用我们的 Jenkins 实例在将代码部署到暂存环境之前运行测试。我们还将创建一个生产环境，并添加一个按需的生产部署过程，称为持续交付流水线。最后，我们将探讨几种策略，帮助我们建立对通过流水线推送代码的信心，以便最终能够移除按需生产部署步骤，将其转变为完全自动化的流水线。
- en: Creating a continuous deployment pipeline for staging
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为暂存环境创建持续部署流水线
- en: 'To create our first deployment pipeline with `CodePipeline`, we are going to
    use the AWS console, which offers a very intuitive web interface:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的第一个部署流水线，使用 `CodePipeline`，我们将利用 AWS 控制台，这提供了一个非常直观的 Web 界面：
- en: Open the following link in your browser: [h](https://console.aws.amazon.com/codepipeline)[t](https://console.aws.amazon.com/codepipeline)[t](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[://c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[l](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[w](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[m](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[z](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[m](https://console.aws.amazon.com/codepipeline)[/c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[d](https://console.aws.amazon.com/codepipeline)
    [e](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[i](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline)[l](https://console.aws.amazon.com/codepipeline)[i](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline).
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开以下链接： [h](https://console.aws.amazon.com/codepipeline)[t](https://console.aws.amazon.com/codepipeline)[t](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[://c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[l](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[w](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[m](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[z](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[m](https://console.aws.amazon.com/codepipeline)[/c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[d](https://console.aws.amazon.com/codepipeline)
    [e](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[i](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline)[l](https://console.aws.amazon.com/codepipeline)[i](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline)。
- en: If prompted, click on Get started.
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果提示，点击“开始使用”。
- en: On the next screen, give your pipeline the name `helloworld` and click on Next
    Step.
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个页面，给你的管道命名为`helloworld`，然后点击“下一步”。
- en: For the source location, select GitHub as a Source provider and click on Connect
    to Github. If requested, sign into your GitHub account.
  id: totrans-414
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于源位置，选择 GitHub 作为源提供商，并点击“连接到 Github”。如果要求，登录你的 GitHub 账户。
- en: This will bring you back to the AWS CodePipeline screen. We can now select a
    Repository and branch. We will select the `helloworld` project and the master
    branch. Click on Next step**.**
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带你回到 AWS CodePipeline 页面。现在我们可以选择一个仓库和分支。我们将选择`helloworld`项目和主分支。点击“下一步”**。
- en: If you don't see the organization name/repository name (that is, `yogeshrahejahelloworld/helloworld`)
    then, as a workaround, clone/copy the organization name/repository name to your
    global Github repository (that is, `yogeshrahejahelloworld/helloworld`  to `yogeshraheja/hellworld`
    in my case).
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有看到组织名/仓库名（即`yogeshrahejahelloworld/helloworld`），那么作为变通方法，可以将组织名/仓库名克隆/复制到你的全球
    GitHub 仓库（即，将`yogeshrahejahelloworld/helloworld`改为`yogeshraheja/hellworld`，这是我的情况）。
- en: This brings us to stage three of our pipeline where we can select our Build
    provider. Our application is being written in Node.js so we don't need to build
    anything. Select No build and click on Next step.
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们进入管道的第三阶段，在这里我们可以选择我们的构建提供商。我们的应用程序是用 Node.js 编写的，所以我们不需要构建任何东西。选择“不构建”并点击“下一步”。
- en: The next step is called **Beta.** This is essentially our staging deployment
    step. Under Deployment provider, select AWS CodeDeploy. Under Application name,
    select `helloworld`. Finally, select staging for the Deployment group. Click on
    Next step.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个步骤叫做 **Beta**。这实际上是我们的暂存部署步骤。在部署提供者下，选择 AWS CodeDeploy。在应用程序名称下，选择 `helloworld`。最后，选择暂存环境作为部署组。点击下一步。
- en: This brings us to a step in which we have to choose our Role Name. Conveniently,
    AWS have also added a Create Role button. Click on this.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将带我们进入一个步骤，在这里我们需要选择角色名称。方便的是，AWS 还添加了一个创建角色按钮。点击这个按钮。
- en: On the next screen, select Create a new IAM Role and give it the name `AWS-
    CodePipeline-Service`. Use the policy proposed and click on Allow.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏幕上，选择创建一个新的 IAM 角色，并将其命名为 `AWS- CodePipeline-Service`。使用推荐的策略并点击允许。
- en: Go back to the CodePipeline step and make sure that role name says `AWS- CodePipeline-Service`.
    Click on Next step.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 CodePipeline 步骤，确保角色名称显示为 `AWS- CodePipeline-Service`。点击下一步。
- en: On the review screen, make sure everything is correct. Finally, click on Create
    Pipeline.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在审核屏幕上，确保一切正确。最后，点击创建流水线。
- en: Because we are using the web interface, Amazon automatically creates an S3 bucket
    on your behalf to store the artifacts that are produced when the pipeline runs.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用的是 Web 界面，Amazon 会自动为您创建一个 S3 存储桶，以便存储流水线运行时生成的工件。
- en: '![](img/c34cd2eb-4c88-42d4-8fb2-217080aa3223.png)'
  id: totrans-424
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c34cd2eb-4c88-42d4-8fb2-217080aa3223.png)'
- en: The pipeline will be created in a matter of seconds and run for the first time.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线将在几秒钟内创建并首次运行。
- en: To illustrate the basic functions of CodeDeploy and CodePipeline, we have used
    the web and command line interface. This process is very manual and doesn't go
    through any kind of review process. CloudFormation supports these two services.
    For a real production system, instead of making changes by hand, it is best to
    use something like Troposphere to generate the templates programmatically to manage
    the services.
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示 CodeDeploy 和 CodePipeline 的基本功能，我们使用了 Web 和命令行界面。这个过程非常手动，并没有经过任何形式的审查过程。CloudFormation
    支持这两项服务。对于实际的生产系统来说，最好使用类似 Troposphere 的工具来编程生成模板，从而管理这些服务，而不是手动进行更改。
- en: 'Once both steps have run, you can verify that the code has been deployed by
    opening in your browser `http://**<instanceip>**:3000`. The instance IP can be
    found in the CloudFormation template or the EC2 console. You can even verify the
    success with the following one-liner:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦两个步骤都执行完成，您可以通过在浏览器中打开 `http://**<instanceip>**:3000` 来验证代码是否已经部署。实例的 IP 地址可以在
    CloudFormation 模板或 EC2 控制台中找到。您甚至可以使用以下命令行验证成功：
- en: '[PRE88]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We have finished our basic pipeline. By taking advantage of CodePipeline, CodeDeploy,
    GitHub, and S3, we have built a very elegant solution to handle the deployment
    our web application. Every time a pull request is merged to the master, our pipeline
    will pick up the change, automatically create a new package with the new code,
    store it on S3, and then deploy it to staging. Thanks to CodeDeploy we can have
    a basic test in place to verify that the version is working. If needed, we can
    also roll back to any revisions that were built previously.
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了基础流水线的创建。通过利用 CodePipeline、CodeDeploy、GitHub 和 S3，我们构建了一个非常优雅的解决方案来处理我们
    web 应用程序的部署。每当一个拉取请求被合并到主分支时，我们的流水线会自动获取变更，创建一个包含新代码的新包，将其存储在 S3 上，然后部署到暂存环境。感谢
    CodeDeploy，我们可以进行基本的测试以验证版本是否正常工作。如有需要，我们还可以回滚到之前构建的任何版本。
- en: Our pipeline doesn't have to be limited to staging; we can actually do a lot
    more. As we mentioned previously, CodePipeline can integrate with Jenkins. We
    can use CodePipeline to build artifacts, but also to run some extra series of
    tests. Let's add it to our pipeline before deploying to staging.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流水线不必仅限于暂存环境；我们实际上可以做更多的事情。正如我们之前提到的，CodePipeline 可以与 Jenkins 集成。我们可以使用 CodePipeline
    来构建工件，也可以执行一些额外的测试序列。让我们在部署到暂存环境之前将其添加到我们的流水线中。
- en: Integrating Jenkins to our CodePipeline pipeline
  id: totrans-431
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Jenkins 集成到我们的 CodePipeline 流水线中
- en: One of the features that makes Jenkins so popular is its plugin capability.
    AWS released a number of plugins to integrate different services with Jenkins.
    We are going to use the one that has been created for CodePipeline. First, this
    will require us to change the IAM profile role of the instance so that it can
    interact with CodePipeline. We will then install the CodePipeline plugin in Jenkins
    and create a job to run our test. Finally, we will edit our pipeline to integrate
    the new stage.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins受欢迎的一个特点是其插件功能。AWS发布了多个插件，以将不同的服务与Jenkins集成。我们将使用为CodePipeline创建的插件。首先，这需要我们更改实例的IAM配置文件角色，以便它可以与CodePipeline交互。然后，我们将在Jenkins中安装CodePipeline插件，并创建一个作业来运行我们的测试。最后，我们将编辑管道以集成新的阶段。
- en: Updating the IAM profile through CloudFormation
  id: totrans-433
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过CloudFormation更新IAM配置文件
- en: In order to add the new privileges to the instance profile, we are going to
    edit the `jenkins-cf-template.py` template that we created earlier in the chapter.
    We are going to add a policy to grant permissions to allow the Jenkins instance
    to communicate with CodePipeline. This step is very similar to the change we made
    to grant S3 access to our web server previously.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将新权限添加到实例配置文件中，我们将编辑在本章早些时候创建的`jenkins-cf-template.py`模板。我们将添加一个策略，以授予Jenkins实例与CodePipeline通信的权限。这一步非常类似于我们之前为Web服务器授予S3访问权限的更改。
- en: 'Above the instance variable instantiation, add the following:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 在实例变量实例化的上方，添加以下内容：
- en: '[PRE89]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, save the changes and regenerate the template. The new template should
    look as follows:[ https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/EffectiveDevOpsTemplates/jenkins-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/EffectiveDevOpsTemplates/jenkins-cf-template.py):'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，保存更改并重新生成模板。新模板应如下所示：[https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/EffectiveDevOpsTemplates/jenkins-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/EffectiveDevOpsTemplates/jenkins-cf-template.py)：
- en: '[PRE90]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Using the web interface, update the stack:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Web界面更新堆栈：
- en: Open [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
  id: totrans-440
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开[https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation)。
- en: Check the checkbox next to the Jenkins stack and in the Actions menu, select
    Update Stack.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 勾选Jenkins堆栈旁边的复选框，然后在操作菜单中选择更新堆栈。
- en: 'Browse to the newly generated `jenkins-cf.template` and click on Next until
    you get to the review screen:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 浏览到新生成的`jenkins-cf.template`并点击下一步，直到您进入审阅页面：
- en: '![](img/38e0c4c5-cf02-4276-99dd-c6940556b57f.png)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![](img/38e0c4c5-cf02-4276-99dd-c6940556b57f.png)'
- en: As shown in the preceding screenshot, only the IAM policy is being added because
    we created our instance with an instance profile. Our EC2 instance will stay untouched,
    making this change safe. Click on Update to confirm the change.
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所示，只有IAM策略被添加，因为我们是通过实例配置文件创建实例的。我们的EC2实例将保持不变，这使得此更改是安全的。点击更新以确认更改。
- en: The instance policy will get updated, giving Jenkins enough permissions to interact
    with CodePipeline. We can now install the Jenkins plugin for CodePipeline.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 实例策略将被更新，赋予Jenkins足够的权限与CodePipeline交互。现在我们可以安装CodePipeline的Jenkins插件了。
- en: Installing and using the CodePipeline Jenkins plugin
  id: totrans-446
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装并使用CodePipeline Jenkins插件
- en: 'Installing a plugin in Jenkins is very simple:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins中安装插件非常简单：
- en: Open your Jenkins instance in your browser (in my case `http://1 8.208.183.35:8080`).
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开您的Jenkins实例（在我的例子中是`http://18.208.183.35:8080`）。
- en: If necessary, log in and click on Manage Jenkins.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，登录并点击管理Jenkins。
- en: on the Manage Jenkins page, select Manage Plugins.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管理Jenkins页面，选择管理插件。
- en: Search for the plugin called AWS CodePipeline Plugin, select it, and install
    it. We can now start using the plugin.
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 搜索名为AWS CodePipeline Plugin的插件，选择它并安装。我们现在可以开始使用这个插件了。
- en: Go back to the homepage of your Jenkins server.
  id: totrans-452
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到Jenkins服务器的主页。
- en: Click on New Item in the menu on the left.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击左侧菜单中的新建项。
- en: Give the new item the name `HelloworldTest`, select Freestyle project**,** and
    click on the OK button at the bottom of the page.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给新项命名为`HelloworldTest`，选择Freestyle项目**，然后点击页面底部的OK按钮。
- en: On the next screen, under Source Code Management, select AWS CodePipeline. Because
    we configured the permissions at the instance profile level, the only options
    we need to configure are the AWS Region and Category, which are in our case `US_EAST_1`
    and `Test`respectively.
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个屏幕上，在 Source Code Management 部分选择 AWS CodePipeline。因为我们在实例配置文件级别配置了权限，所以我们需要配置的唯一选项是
    AWS Region 和 Category，在我们的案例中分别是 `US_EAST_1` 和 `Test`。
- en: Under Build Triggers, select Poll SCM and then type `* * * * *` to tell Jenkins
    to check with CodePipeline every minute for possible code test requests.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Build Triggers 下，选择 Poll SCM，然后输入 `* * * * *`，以告知 Jenkins 每分钟检查一次 CodePipeline，看看是否有可能的代码测试请求。
- en: Under the Build section, click on Add build step and then Execute shell.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Build 部分，点击 Add build step 然后选择 Execute shell。
- en: 'Once again, we are going to run the tests that we created at the beginning
    of the chapter. In the Command section, type the following:'
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将再次运行在本章开始时创建的测试。在 Command 部分，输入以下内容：
- en: '[PRE91]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Add a post-build action and select the action called AWS CodePipline Publisher.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个构建后操作，并选择名为 AWS CodePipline Publisher 的操作。
- en: In the newly generated AWS CodePipeline Publisher, click on Add, and leave the
    Location blank.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新生成的 AWS CodePipeline Publisher 中，点击 Add，并将 Location 保留为空。
- en: You can configure the rest of the job according to your preferences and then
    click on Save to create the new job.
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以根据自己的偏好配置其余的作业，然后点击 Save 来创建新作业。
- en: Our test job in Jenkins is ready to be used and we can now update our pipeline.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 Jenkins 中的测试作业已经准备好使用，现在我们可以更新我们的流水线。
- en: Adding a test stage to our pipeline
  id: totrans-464
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的流水线添加一个测试阶段。
- en: 'We are going to use the web interface to make this change:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Web 界面来进行这个更改：
- en: Open [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)
    in your browser.
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)。
- en: Select the `helloworld` pipeline we previously created.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们之前创建的 `helloworld` 流水线。
- en: On the `helloworld` pipeline page, click on the Edit button at the top of the
    pipeline.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `helloworld` 流水线页面上，点击流水线顶部的 Edit 按钮。
- en: Add a stage by clicking on the + Stage button located between the Source and
    Beta stages.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Source 和 Beta 阶段之间的 + Stage 按钮来添加一个阶段。
- en: Call that stage `Test` and click on Action.
  id: totrans-470
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该阶段命名为 `Test`，然后点击 Action。
- en: In the menu on the right, under Action category, choose the action called `Test`.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧菜单的 Action category 下，选择名为 `Test` 的操作。
- en: Call your action Jenkins and, for the Test provider, select Add Jenkins.
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的操作命名为 Jenkins，并且对于 Test provider，选择 Add Jenkins。
- en: In the Add Jenkins menu, leave the Provider Name set to `Jenkins`. Provide your
    Jenkins URL, which in my case is `http://18.203.183.35:8080`. The project name
    needs to match the name of the job on Jenkins. This should be `HelloworldTest`.
    Once set, click on Add action.
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Add Jenkins 菜单中，将 Provider Name 设置为 `Jenkins`。提供你的 Jenkins URL，我这里是 `http://18.203.183.35:8080`。项目名称需要与
    Jenkins 上作业的名称匹配。这个名称应该是 `HelloworldTest`。设置完成后，点击 Add action。
- en: Apply your change by clicking on Save pipeline changes at the top of the pipeline.
  id: totrans-474
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击流水线顶部的 Save pipeline changes 来应用你的更改。
- en: Run the pipeline again by clicking on Release change. After a few minutes, you
    should be able to see the Jenkins step being executed. If everything goes well
    it should turn green.
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次点击 Release change 运行流水线。几分钟后，你应该能看到 Jenkins 步骤正在执行。如果一切顺利，它应该会变成绿色。
- en: Our pipeline is now starting to look very interesting. Here, we have demonstrated
    the Jenkins integration in its most rudimentary form, but you can easily imagine
    more realistic scenarios where you would add a step after deploying your code
    to staging to carry out better validation with better integration, load, and even
    penetration testing.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流水线现在开始变得非常有趣。在这里，我们展示了 Jenkins 集成的最基础形式，但你可以轻松想象出更现实的场景，比如在将代码部署到暂存环境后，添加一个步骤来进行更好的验证，包括更完善的集成、负载测试，甚至是渗透测试。
- en: The goal of AWS CodePipeline is to help you take your services from source control
    all the way up to production. As you first start working on a service, you might
    not have the test coverage needed to continuously deploy it to production so you
    might opt for  one-click production deployment instead. We are going to take advantage
    of the automation we have built so far in this chapter and build a continuous
    delivery pipeline for production.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: AWS CodePipeline 的目标是帮助你将服务从源控制一直推进到生产环境。刚开始处理一个服务时，你可能没有足够的测试覆盖来持续部署到生产环境，因此你可能会选择一键生产部署。我们将利用本章中迄今为止构建的自动化，构建一个用于生产的持续交付流水线。
- en: Building a continuous delivery pipeline for production
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产环境构建持续交付管道
- en: In order to build our continuous delivery pipeline, we are first going to create
    a CloudFormation stack for a production environment. We will then add a new deployment
    group in CodeDeploy, which will provide us with the ability to deploy code to
    the new CloudFormation stack. Finally, we will upgrade the pipeline to include
    an approval process to deploy our code to production and the production deployment
    stage itself.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建我们的持续交付管道，我们将首先为生产环境创建一个CloudFormation堆栈。然后，我们将在CodeDeploy中添加一个新的部署组，这将使我们能够将代码部署到新的CloudFormation堆栈。最后，我们将升级管道，加入一个批准流程，以便将代码部署到生产环境，并加入生产环境的部署阶段。
- en: Creating the new CloudFormation stack for production
  id: totrans-480
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为生产环境创建新的CloudFormation堆栈
- en: 'Here, we are going to reuse the exact same template as we used for staging.
    In your Terminal, go to the location you used to generate the node server template
    and then run the same command as before, but this time with the stack name `helloworld-production`:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将重新使用与之前用于预发布环境相同的模板。在你的终端中，进入你用于生成节点服务器模板的位置，然后运行与之前相同的命令，但这次使用堆栈名称`helloworld-production`：
- en: '[PRE92]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We can then run the following command to wait for the stack to be ready:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以运行以下命令，等待堆栈准备就绪：
- en: '[PRE93]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: You might realize the weakness of our production stack with only one EC2 instance
    in it. We will address that concern in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure,* when we talk about scaling strategies.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会意识到，我们的生产堆栈中只有一个EC2实例的弱点。我们将在[第六章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)《*扩展你的基础设施*》中讨论这一问题，届时我们将讨论扩展策略。
- en: Creating a CodeDeploy group to deploy to production
  id: totrans-486
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个CodeDeploy组以便部署到生产环境
- en: Previously, we created a CodeDeploy application and a first deployment group
    that allowed us to deploy our code to staging. Using the command-line interface,
    we are now going to add a new deployment group to deploy our code to our newly
    created production environment.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们创建了一个CodeDeploy应用程序和第一个部署组，允许我们将代码部署到预发布环境。现在，我们将使用命令行界面，添加一个新的部署组，将代码部署到新创建的生产环境。
- en: 'One of the parameters needed to add new deployment groups is the `arn` of the
    policy we created initially. We can easily extract this from the staging deployment
    group that we created previously. We will store the result in a variable called
    `arn`:'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新部署组所需的参数之一是我们最初创建的策略的`arn`。我们可以轻松地从之前创建的预发布部署组中提取这一信息。我们将把结果存储在一个名为`arn`的变量中：
- en: '[PRE94]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'We can now run the following command to create the new deployment group:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以运行以下命令来创建新的部署组：
- en: '[PRE95]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'If everything went well, the new deployment group should be created. We can
    verify this by browsing to the application in the AWS CodeDeploy web page or using
    the command-line with the following command:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，新的部署组应该已经创建。我们可以通过浏览AWS CodeDeploy网页上的应用程序，或使用以下命令行命令来验证这一点：
- en: '[PRE96]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Adding a continuous delivery step to our pipeline
  id: totrans-494
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向我们的管道添加持续交付步骤
- en: 'As we saw earlier in this chapter, pipelines are composed of stages. In CodePipeline,
    stages are characterized by their categories. We have explored three categories
    so far: source, deploy, and test. In order to add a confirmation step to deploy
    our service to production, we will use a new category called **approval**.'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章前面看到的，管道由多个阶段组成。在CodePipeline中，阶段由其类别来定义。到目前为止，我们已经探索了三种类别：源、部署和测试。为了向管道中添加一个确认步骤，以便将我们的服务部署到生产环境中，我们将使用一个新的类别，叫做**批准**。
- en: Approval actions offer a number of configuration options to send notifications
    when a job is pending approval. To demonstrate this feature, we are going to create
    a new SNS topic and subscribe to it. As you might remember from [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*, SNS is the simple notification service
    that we used to monitor our infrastructure.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 批准操作提供了多个配置选项，用于在任务等待批准时发送通知。为了演示此功能，我们将创建一个新的SNS主题并订阅它。正如你在[第三章](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml)《*将基础设施视为代码*》中记得的那样，SNS是我们用来监控基础设施的简单通知服务。
- en: 'We are going to use the command-line to create a new topic and subscribe to
    it:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用命令行创建一个新的主题并订阅它：
- en: '[PRE97]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Here, we will use an email subscription. SNS also supports a number of other
    protocols such as SMS, HTTP, and SQS. In order to subscribe, you need to know
    the Topic ARN, which is in the output of the previous command:'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将使用电子邮件订阅。SNS 还支持其他多种协议，如 SMS、HTTP 和 SQS。为了订阅，你需要知道主题 ARN，它在前一个命令的输出中：
- en: '[PRE98]'
  id: totrans-500
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: Go to your inbox to confirm the subscription.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 去你的收件箱确认订阅。
- en: 'We can now add our new stages, starting with the approval stage:'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以添加新的阶段，从批准阶段开始：
- en: Open [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)
    in your browser.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中打开 [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)。
- en: Select the `helloworld` application.
  id: totrans-504
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `helloworld` 应用程序。
- en: Click on `Edit` at the top of the pipeline.
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击流水线顶部的 `编辑`。
- en: Click on the `+ Stage` button at the bottom of the pipeline below the Beta stage.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击流水线底部 Beta 阶段下方的 `+ 阶段` 按钮。
- en: Give it the name `Approval`.
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给它命名为 `Approval`。
- en: Click on + Action**.**
  id: totrans-508
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 + 操作**。**
- en: Select Approval in the Action Category menu.
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在操作类别菜单中选择 Approval。
- en: Call the action Approval.
  id: totrans-510
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此操作命名为 Approval。
- en: Select the approval type Manual approval**.**
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择批准类型手动批准**。**
- en: Pick the SNS topic we just created. Typing `production deploy` should allow
    you to find the topic easily thanks to the autocomplete feature of the form.
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们刚创建的 SNS 主题。输入 `production deploy` 应该能让你轻松找到该主题，因为表单的自动完成功能。
- en: Finally, click on Add action. We are now going to add the deployment to production
    steps below this approval.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，点击添加操作。现在，我们将添加生产部署步骤到此批准下方。
- en: Click on the + Stage button below the newly created stage Approval.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击新创建的阶段 Approval 下方的 + 阶段 按钮。
- en: Call this new stage Production.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将这个新阶段命名为 Production。
- en: Click on + Action.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 + 操作。
- en: Select the Deploy category.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择部署类别。
- en: Call the action Production.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此操作命名为 Production。
- en: Select the CodeDeploy provider.
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 CodeDeploy 提供程序。
- en: Pick `helloworld` as our application name.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `helloworld` 作为我们的应用名称。
- en: Select the deployment group production.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择部署组 production。
- en: Select the artifact `MyApp`.
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择工件 `MyApp`。
- en: Click on Add action.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击添加操作。
- en: Complete the creation of our new stages by clicking on Save pipeline changes
    at the top of the pipeline.
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击流水线顶部的保存流水线更改，完成创建我们的新阶段。
- en: We can once again click on Release change to test our updated pipeline.
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以再次点击发布变更来测试更新后的流水线。
- en: 'The pipeline will go through the first three stages and then block at the approval
    stage. If you check your email inbox, you will find a link where you can review
    the change. Alternatively, you can simply use the web interface and click on the
    review button in the approval stage:'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 流水线将通过前三个阶段，然后在批准阶段暂停。如果你查看电子邮件收件箱，会发现一个链接，点击链接可以审查变更。或者，你也可以使用 Web 界面，在批准阶段点击审查按钮：
- en: '![](img/cbd25f05-1091-4872-b355-3e1e56661f49.png)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cbd25f05-1091-4872-b355-3e1e56661f49.png)'
- en: After carefully reviewing the changes, you can either approve or reject the
    change. If it is approved, the deployment will continue to the last step of the
    pipeline and deploy the code to production.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 在仔细审查变更后，你可以批准或拒绝该变更。如果被批准，部署将继续进行到流水线的最后一步，将代码部署到生产环境。
- en: We have now automated our entire release process. Our `helloworld` application
    may not reflect what a real application might look like, but the pipeline we built
    around it does. What we built can be used as a blueprint for deploying more complex
    applications from environment to environment safely.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经自动化了整个发布过程。我们的 `helloworld` 应用程序可能无法完全代表一个真实的应用程序，但我们围绕它构建的流水线确实可以。我们所构建的可以作为从一个环境到另一个环境安全部署更复杂应用程序的蓝图。
- en: There is no question that the ability to move fast and release your new features
    and services to customers allows you to prevent disruptions. The last step of
    building a continuous deployment pipeline is to remove the manual approval process
    to release code to production, thereby taking out the last step involving humans
    in the release process. Over the years, different companies have come up with
    a couple of strategies to make production deployments a safe process. In the next
    section, we will look at some solutions that you can implement.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 毫无疑问，快速移动并将新的功能和服务发布给客户的能力，可以帮助你避免中断。构建持续部署流水线的最后一步是去除手动批准流程，以便将代码发布到生产环境，从而去掉发布过程中涉及的最后一步人工操作。多年来，不同的公司提出了几种策略，使生产部署成为一个安全的过程。在接下来的部分，我们将看看一些你可以实施的解决方案。
- en: Strategies to practice continuous deployments in production
  id: totrans-531
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在生产中实践持续部署的策略
- en: As always, your first line of defense is to have enough test coverage and sophisticated
    validation scripts that cover most of the sensitive routes and features in your
    product. There are some well-known strategies and techniques to make a continuous
    deployment pipeline safe for production. We will explore three common ones in
    this section.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你的第一道防线是拥有足够的测试覆盖率和复杂的验证脚本，涵盖产品中大多数敏感的路由和功能。有一些广为人知的策略和技术可以使持续部署流水线在生产环境中更为安全。我们将在本节中探索三种常见的策略。
- en: Fail fast
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 快速失败
- en: The pipeline that we built is fairly fast and robust. Depending on the nature
    of your service, you may choose to trust the quality of the code produced by your
    team and always deploy the code straight to production. With sufficient monitoring
    around your logs and application metrics, you will be able to catch issues minutes
    after the code is deployed. You can then rely on CodeDeploy and its ability to
    deploy older releases fast to recover from that situation.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 我们构建的流水线相当快速且健壮。根据服务的性质，你可以选择相信你团队编写的代码质量，并始终将代码直接部署到生产环境。通过充分监控日志和应用程序指标，你将能够在代码部署后的几分钟内捕捉到问题。然后，你可以依赖
    CodeDeploy 及其快速部署旧版本的能力来从这种情况中恢复。
- en: If you take this approach and a problem is detected, simply roll back to a previous
    version. You may know exactly what's wrong and know that it's easy to fix, but
    the pressure caused by knowing that there is an ongoing issue impacting users
    can cause you to make more mistakes, making the situation worse.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你采取这种方式并检测到问题，直接回滚到之前的版本即可。你可能完全知道问题所在，并且知道修复起来很容易，但由于知道问题正在影响用户，所产生的压力可能会导致你犯更多错误，使得情况变得更糟。
- en: Canary deployment
  id: totrans-536
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 金丝雀发布
- en: Similarly, you could try to deploy your code straight to production, but only
    expose part of the traffic to the new code for some time. You can build a system
    where only a small percentage of the traffic hits the new servers that are running
    the new code and compare the error rate and performance originating from each
    release for a short period of time. Usually, 10% of the traffic for 10 minutes
    is sufficient to collect enough information about the quality of the new build.
    If, after that time, everything looks good, you can then move 100% of the traffic
    to the new version of the service.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，你也可以尝试将代码直接部署到生产环境，但只将一部分流量暴露给新代码一段时间。你可以构建一个系统，让只有一小部分流量访问运行新代码的新服务器，并在短时间内对比每个版本的错误率和性能。通常，10%
    的流量在 10 分钟内就足以收集到有关新构建质量的信息。如果过了这段时间后，一切看起来正常，那么你就可以将 100% 的流量切换到新版本的服务。
- en: 'Bugs such as memory leaks are usually slower to manifest themselves; once the
    deployment is complete, continue closely monitoring your different systems and
    key metrics to make sure that no mistakes have been made:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 内存泄漏等 Bugs 通常表现较慢；一旦部署完成，继续密切监控不同的系统和关键指标，确保没有出现任何错误：
- en: '![](img/f553ebcc-786a-4381-8c80-4fc8b2baa3c3.png)'
  id: totrans-539
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f553ebcc-786a-4381-8c80-4fc8b2baa3c3.png)'
- en: Feature flags
  id: totrans-540
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 特性开关
- en: Also known as a dark launch, this last strategy is the hardest one to implement
    but also the most valuable. It is used by most well-known tech companies. The
    idea is to have multiple smart switches on each of your features. When you first
    deploy the code for a new feature, you do so with those switches turned off. You
    then progressively turn them on for different subsets of users. You might start
    by only allowing employees of the company to experience the feature. You might
    then decide to increase the number of people exposed to that feature by adding
    a set of trusted users. You might then turn the feature on for 20% of your users,
    then 50%, and so on. As well as allowing you to do a soft launch, this type of
    features can be used at the product level to carry out A/B testing, maintenance,
    where you want to turn off a specific feature, or even load testing.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略也被称为“暗发布”，是最难实现但也是最有价值的策略。大多数知名科技公司都在使用这种策略。其核心思路是，在每个功能上都设置多个智能开关。当你首次部署新功能的代码时，开关是关闭的。接着，你逐步为不同的用户子集打开这些开关。你可以首先仅允许公司员工体验这个功能。接下来，你可能会通过添加一组信任的用户，增加体验该功能的人数。然后，你可能会为
    20% 的用户开启该功能，再到 50%，依此类推。除了允许你进行软发布外，这种功能还可以在产品层面进行 A/B 测试、维护操作（比如关闭特定功能），甚至进行负载测试。
- en: One of the best uses of a dark launch was summarized in a blog post by Facebook.
    In 2008, Facebook launched their chat functionality. It was a very challenging
    feature as it was the first service Facebook developed in Erlang. In order to
    make sure the service would be able to handle the scale at which Facebook operates,
    they relied on a dark launch strategy. During the months leading up to the official
    launch, they simulated what the real traffic could look like by releasing the
    service without the UI. Real users browsers would establish connections to the
    chat servers and invisibly send and receive messages to simulate the load. When
    it was time to launch, Facebook didn't push out new code, but simply turned the
    switch on to make the chat window visible in the UI. More information about this
    launch can be found at: [https://www.facebook.com/notes/facebook-engineering/facebook-cha](https://www.facebook.com/notes/facebook-engineering/facebook-chat/14218138919/)
    [t/14218138919/](https://www.facebook.com/notes/facebook-engineering/facebook-chat/14218138919/).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-543
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been through one of the most important aspects of the
    DevOps philosophy—how to change the way in which code is released.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: Our first objective was to improve developers' productivity. To that effect,
    we built a continuous integration pipeline. Taking advantage of Jenkins and GitHub,
    we created a new workflow where developers commit their code in individual branches
    and submit pull requests. The branches are automatically tested with Jenkins and
    a final peer review ensures that the code committed is of high quality.
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this change, we can guarantee that the code present in the master
    branch of our project is always good and worth being pushed to staging. To do
    this, we built a continuous deployment pipeline. Thanks to AWS CodeDeploy and
    CodePipeline, we were able to easily build a fully functional pipeline. The pipeline
    has all the desired features an operator could wish for. It automatically picks
    up changes from developers merging their pull requests, creates a package of the
    new version of the application, stores the package on S3, and then deploys it
    to staging. As the new code gets deployed, validation steps ensure that the application
    isn't misbehaving and, if needed, the application can easily be rolled back.
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
- en: Once we finished building our continuous deployment pipeline, we extended it
    to build a continuous delivery capability so that we could carry out production
    deployment on demand. We also added an extra stage to integrate testing through
    Jenkins within the pipeline itself. Finally, we discussed different techniques
    and strategies to have a continuous deployment pipeline for production that will
    allow us to perform dozens of production deployments a day for any given service.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
- en: Since we started to take a more DevOps approach towards managing our architecture
    and  services, we haven't looked at the notions of high availability or load balancing.
    Even in this chapter, we only created one EC2 instance for our production environment.
    We will address this in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure.* We will look at tools and services to scale our
    infrastructure and handle massive amounts of traffic.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们开始采取更偏向DevOps的方式来管理我们的架构和服务后，我们就没有关注过高可用性或负载均衡的概念。即使在本章中，我们也只为生产环境创建了一个EC2实例。我们将在[第六章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)，*扩展你的基础设施*中讨论这一问题。我们将探讨扩展基础设施的工具和服务，并处理海量流量。
- en: Questions
  id: totrans-549
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is Continuous Integration, Continuous Deployment and Continuous Delivery?
  id: totrans-550
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是持续集成、持续部署和持续交付？
- en: What is Jenkins, and how does it help in the SDLC cycle?
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是Jenkins，它如何在SDLC周期中提供帮助？
- en: Describe how to build your first continuous deployment pipeline.
  id: totrans-552
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 描述如何构建你的第一个持续部署流水线。
- en: Further reading
  id: totrans-553
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Please read the following articles for more information:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 请阅读以下文章以获取更多信息：
- en: '**Jenkins Reference**: [https://jenkins.io/](https://jenkins.io/)'
  id: totrans-555
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins参考**: [https://jenkins.io/](https://jenkins.io/)'
- en: '**Mocha Reference**: [https://mochajs.org/](https://mochajs.org/)'
  id: totrans-556
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha参考**: [https://mochajs.org/](https://mochajs.org/)'
- en: '**AWS CodeDeploy Reference**: [https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html](https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html)'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeDeploy参考**: [https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html](https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html)'
- en: '**AWS CodePipeline Reference**: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodePipeline参考**: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)'
- en: '**Jenkins Reference**: [https://jenkins.io/](https://jenkins.io/)'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Jenkins参考**: [https://jenkins.io/](https://jenkins.io/)'
- en: '**Mocha Reference**: [https://mochajs.org/](https://mochajs.org/)'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Mocha参考**: [https://mochajs.org/](https://mochajs.org/)'
- en: '**AWS CodeDeploy Reference**: [https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html](https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html)'
  id: totrans-561
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodeDeploy参考**: [https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html](https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html)'
- en: '**AWS CodePipeline Reference**: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AWS CodePipeline参考**: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)'
