- en: Adding Continuous Integration and Continuous Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we focused on improving the creation and management
    of infrastructure. The DevOps culture doesn't stop there, however. As you might
    recall from [Chapter 1](1e42d3ae-b9f3-420a-8b87-000810a339b6.xhtml), *The Cloud
    and the DevOps Revolution*, DevOps culture also includes having a very efficient
    process to test and deploy code. At the 2009 Velocity conference, John Allspaw
    and Paul Hammond made a very inspirational speech about how Flickr was carrying
    out over 10 deployments a day ([http://bit.ly/292ASlW](http://bit.ly/292ASlW)).
    This presentation is often mentioned as a pivotal moment that contributed to the
    creation of the DevOps movement. In their presentation, John and Paul talk about
    the conflicts between development and operations teams but also outline a number
    of best practices that allow Flickr to deploy new code to production multiple
    times a day.
  prefs: []
  type: TYPE_NORMAL
- en: With innovations such as virtualization, the public and private cloud, and automation,
    creating new start ups has never been so easy. Because of that, the biggest problem
    many companies are now facing is being able to stand apart from their competitors.
    Having the ability to iterate faster than most competitors can be a detrimental
    to a company's success.  An effective DevOps organization uses a number of tools
    and strategies to increase the velocity at which engineering organizations release
    new code to production. This is what we will focus on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will first look at creating a **Continuous Integration** (**CI**) pipeline.
    A CI pipeline will allow us to test proposed code changes automatically and continuously.
    This will free up the time of developers and QAs who no longer have to carry out
    as much manual testing. It also makes the integration of code changes much easier.
    To implement our pipeline, we will use GitHub and one of the most widely used
    integration tools—**Jenkins**.
  prefs: []
  type: TYPE_NORMAL
- en: We will then look at creating a **Continuous Deployment** (**CD**) pipeline.
    Once the code has gone through the CI pipeline, we will use this continuous deployment
    pipeline to automatically deploy the new code. We will rely on two AWS services
    to implement this pipeline—**AWS CodeDeploy** and **AWS CodePipeline**. CodeDeploy
    lets us define how the new code needs to be deployed on our EC2 instances while
    CodePipeline lets us orchestrate the full life cycle of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to deploy our code to production, we will add an extra step that will
    allow the operator to deploy the latest build that is present in the staging to
    the production process at the press of a button. This ability to deploy code to
    production on-demand is called CD. Its main advantage is that it provides the
    ability for the deployment operator to validate a build in a staging environment
    before it gets deployed to production. At the end of the chapter, we will see
    a couple of techniques and strategies that effective engineering organizations
    use to convert their continuous delivery pipelines into continuous deployment
    pipelines so that the entire process of deploying code up to production can happen
    without any human intervention. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Building a continuous integration pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a continuous deployment pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The technical requirements for this chapter as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CodeDeploy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS CodePipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The links are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jenkins package repository**: [https://pkg.jenkins.io/](https://pkg.jenkins.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins setup playbook**: [https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml](https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkinsfile**: [https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code deploy library**: [https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/ansible/library/aws_codedeploy](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/ansible/library/aws_codedeploy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a CI pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Initially, working in a CI environment meant that developers had to commit their
    code in a common branch as frequently as possible, as opposed to working off a
    separate branch or not committing changes for weeks. This allowed for improved
    visibility of the ongoing work and encouraged communication to avoid integration
    problems, a situation that is commonly known as **Integration Hell**. As the toolset
    related to source control and build and release management matured, so did the
    vision of how code integration should look in an ideal world.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, most effective engineering organizations will continue down the path
    of integrating early and often. They often use, however, a more modern development
    process, where developers are required to edit the code and, at the same time,
    add or edit the different relevant tests to validate the change. This drastically
    increases overall productivity; it is now easier to find new bugs as the amount
    of code that changes between merges is fairly small.
  prefs: []
  type: TYPE_NORMAL
- en: 'To adopt such a workflow, using a source control tool such as Git for example,
    you can proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: When as a developer, you want to make changes, start by creating a new Git branch
    that branches off the HEAD of the master branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the code and, at the same time, add or edit the different relevant tests
    to validate the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the code locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the code is ready, rebase the branch to integrate new eventual changes
    from other developers. If needed, resolve conflicts and test the code again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If everything went well, the next step consists of creating a `pull request`.
    In this process, you tell other developers that your code is ready to be reviewed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the pull request is created, an automated testing system such as the one
    we will build in this chapter will pick up the change and run the entire test
    suite to make sure nothing fails.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, other interested parties will review the code and the different
    tests that were added to the branch. If they are satisfied with the proposed change,
    they will approve it, giving the developers the green light to merge their changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last step, the developers merge their pull requests, which will translate
    into merging their new code and testing the master branch. Other developers will
    now integrate this change when they rebase or create new branches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the following section, we will create a CI server using Jenkins running on
    top of an EC2 instance and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: As projects get bigger, the number of tests, the time it takes to run them.
    While certain advanced build systems such as Bazel ([https://bazel.build/](https://bazel.build/))
    have the ability to run only those tests relevant to a particular change, it is
    usually easier to start simply and create a CI system that runs all the tests
    available every time a new pull request is proposed. Having an external test infrastructure
    with the elasticity of AWS becomes a huge time saver for the developers who don't
    want to wait minutes or even hours for all the tests to be executed. In this book,
    we will focus on web application development. You may face a more challenging
    environment in which you need to build software for specific hardware and operating
    system. Having a dedicated CI system will allow you to run your tests on the hardware
    and software you are ultimately targeting.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Jenkins server using Ansible and CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned before, we are going to use Jenkins as our central system to run
    our CI pipeline. With over 10 years of development, Jenkins has been the leading
    open-source solution to practice continuous integration for a long time. Famous
    for its rich plugin ecosystem, Jenkins has gone through a major new release (Jenkins
    2.x), which has put the spotlight on a number of very DevOps-centric features,
    including the ability to create native delivery pipelines that can be checked
    in  and version-controlled. It also provides better integration with source control
    systems such as GitHub, which we are using in this book.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to continue using **Ansible** and **CloudFormation** in the same
    way as we did in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating
    Your Infrastructure as Code, *to manage our Jenkins server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Ansible playbook for Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Start by navigating to our `ansible` roles directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This directory should contain the `helloworld` and `nodejs` directories, with
    the configurations that we created previously in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*. We are now going to create our Jenkins
    role with the `ansible-galaxy` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We are now going to edit the task definition for this new role by editing the
    file: `jenkins/tasks/main.yml`. Open up the file with your favorite text editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'The goal of our task is to install and start Jenkins. In order to do this,
    since we are on a Linux-based operating system (AWS Amazon Linux, in our case),
    we are going to install an RPM package through `yum`. Jenkins maintains a `yum`
    repository, so the first step will consist of importing this to our `yum` repository
    configuration, basically as an entry in `/etc/yum.repos.d`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the initial comment of the tasks file, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step will consist of importing the GPG key of that repository. Ansible
    has a module to manage these kinds of keys:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We have now reached the point where we can use `yum` to install Jenkins. We
    will do that with the following call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Since the `jenkins` repository is disabled by default, we are enabling it through
    the `enablerepo` flag for the execution of this `yum` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, Jenkins will be installed. To conform with best practice guidelines,
    we will specify which version of Jenkins we want to install (in our case the version
    is 2.99). We also want to start the service and have it enabled at the `chkconfig`
    level so that if the EC2 instance where Jenkins is installed restarts, Jenkins
    will start automatically. We can do that using the service module. Add the following
    after the previous call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: For a simple Jenkins role, that's all we need.
  prefs: []
  type: TYPE_NORMAL
- en: We should now have a `main.yml` file that looks as follows: [https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml](https://raw.githubusercontent.com/yogeshraheja/ansible/master/roles/jenkins/tasks/main.yml).
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS Amazon Linux comes with Java 7 but Jenkins has pre-requisites to install
    Java 8 for Jenkins version 2.54 and above. So you will see two extra tasks in
    the preceding link, which will uninstall Java 7 and install Java 8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you gain more experience with Jenkins and Ansible, explore the web or the
    Ansible galaxy, you will find more advanced roles allowing you to configure Jenkins
    in more detail, generate jobs, and select the plugins to install. It is an important
    step to go through that this book won't cover, but ideally, you want your entire
    system to be described by code. In addition, in this chapter, we are using Jenkins
    over HTTP. It is strongly encouraged to use it over an encrypted protocol such
    as HTTPS or, as we will see in Chapter 8, *Hardening the Security of Your AWS
    Environment,* in a private subnet with a VPN connection.
  prefs: []
  type: TYPE_NORMAL
- en: We have now built a role that will allow us to install Jenkins. We want to create
    a new EC2 instance and install Jenkins on it with the end goal of testing our
    Node.js code on the instance. In order to be able to do that, the Jenkins host
    will need to also have the node and `npm` installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have two options. We can either add our `nodejs` role as a dependency of
    the Jenkins role, as we did for the `helloworld` role, or we can list the `nodejs`
    role in the list of roles for our playbook. Since ultimately Jenkins doesn''t
    really require a node to run, we will opt for the second approach. In the root
    directory of our `ansible` repository, create the `playbook` file. The filename
    is `jenkins.yml` and it should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Our role is now complete, so we can commit our new role and push it to GitHub.
    Following the best practices described previously, we will start by creating a
    new branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Add our files with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Commit and finally `push` the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From there, submit a pull request inside GitHub and merge the branch back to
    the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b70fa6ca-f937-49db-959d-505bffbc2ec9.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once done, get back to the master branch with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In a real-life situation, you likely also want to periodically run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will retrieve the changes made by other developers.
  prefs: []
  type: TYPE_NORMAL
- en: We can now create our CloudFormation template in order to call the role.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CloudFormation template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to keep our code fairly similar to the code we looked at in [Chapter
    3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as Code,* we are going to start off with the `helloworld` Troposphere code that
    we created in that chapter. First, we are going to duplicate the Python script.
    Go to your `EffectiveDevOpsTemplates` directory, where you have your Troposphere
    templates, and then clone the `ansiblebase-cf-template.py` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The Jenkins host will need to interact with AWS. To allow this, we will create
    an instance profile, which we will describe in more detail later, taking advantage
    of another library that is developed by the same authors as Troposphere. We will
    install it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to edit the `jenkins-cf-template.py` file. The first two changes
    we will make are to the name and port of the application. Jenkins runs by default
    on `TCP/8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We will also set a number of constants around the GitHub information.  Replace
    the value of your `GithubAccount` with your GitHub username or organization name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We also want to add an instance IAM profile to better control how our EC2 instance
    can interact with AWS services such as EC2\. We previously used the IAM service
    in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml), *Deploying Your First
    Web Application,* when we created our user. You may recall that in addition to
    creating the user, we also assigned it the administrator policy, which gives the
    user full access to all AWS services. On top of that, we generated an access key
    and a secret access key, which we are currently using to authenticate ourselves
    as that administrator user and interact with services such as CloudFormation and
    EC2.
  prefs: []
  type: TYPE_NORMAL
- en: When you are using EC2 instances, the **instance profile** feature provided
    lets you specify an IAM role to your instance. In other words, we can assign IAM
    permissions directly to EC2 instances without having to use access keys and secret
    access keys.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having an instance profile will be very useful later on in this chapter, when
    we work on the CI pipeline and integrate our Jenkins instance with the AWS managed
    services. To do this, we will first import some extra libraries. The following
    is from Troposphere `import()` section, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in between the instantiation of the variables `ud` and the creation of
    the instance, we are going to create and add our role resource to the template
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did previously for the role, we can now create our instance profile and
    reference the role. The following code is the creation of the role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can reference our new instance profile by updating the declaration
    of our instance. We will add a period after `UserData=ud` and on the line after
    initializing the `IamInstanceProfile` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The file should now look like this [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/jenkins-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/jenkins-cf-template.py).
    You can save the changes, commit the new script to GitHub, and generate the CloudFormation
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Launching the stack and configuring Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to create our EC2 instance with Jenkins running on it, we will proceed
    as we did in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating
    Your Infrastructure as Code*, using either the web interface or the command-line
    interface as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did before, we can then wait until the execution is complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, we can extract the host''s public IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we kept the **Ansible Jenkins** role fairly simple, we need to complete
    its configuration in order to complete the installation of Jenkins. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open port `8080` of the instance public IP in your browser (that is, in my
    case, `http://18.208.183.35:8080)`. Wait for a while to get Jenkins configurations
    to get configured before you get the screen):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dd5efa0e-175e-46fa-8640-8c59d3b03232.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the following `ssh` command (adapt the IP address) and its ability to
    run commands remotely, we can extract the admin password, and provide it to that
    first configuration screen with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: On the next screen, choose to install the suggested plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create your first admin user on the next screen and click on the Save and Finish
    button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on the Start using Jenkins button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our Jenkins instance is now ready to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing our CI environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use our Jenkins instance in conjunction with GitHub to recreate
    our `helloworld` application using a proper CI pipeline. To do this, we are going
    to go through a number of preliminary steps, starting with the creation of a new
    GitHub organization that has a new repository named `helloworld`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new GitHub organization and repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now going to create a new organization having a new repository dedicated
    to hosting our `helloworld` node application. We will create the organization
    by going through the following steps and then will create a new repository inside
    the organization using the same steps as in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://github.com/organizations/new](https://github.com/new) in your
    browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the organization name, which will be a separate GitHub account inside your
    main GitHub account. I am creating mine with the name `yogeshrahejahelloworld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide your email ID and select the free plan.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Create organization button and select the default settings for
    the next two steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/e0293a81-55ab-48bb-9d48-4922a28028fc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Create a new repository for the newly created organization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8e1a7d3c-12b7-4922-b78c-397adbe631e4.png)'
  prefs: []
  type: TYPE_IMG
- en: Call your repository `helloworld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the  Initialize this repository with a README checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Create Repository button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/22eba538-9e1f-44a8-b652-726d32ac3d7a.png)'
  prefs: []
  type: TYPE_IMG
- en: This will create the repository, a master branch, and a `README.md` file.
  prefs: []
  type: TYPE_NORMAL
- en: A proper CI pipeline works silently in the background. In order to achieve this,
    when the code is hosted on GitHub, Jenkins needs to get notifications from GitHub
    to indicate that the code has changed so that it can trigger a build automatically.
    This is something we can easily implement thanks to a plugin called `github-organization-plugin`.
    This plugin is one of those that were installed when we chose to install the suggested
    plugins in Jenkins. In order to use it, we first need to create a personal access
    token in GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub personal access token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a personal access token will give the plugins the ability to access
    the code pushed to GitHub and create the necessary hooks to get notifications
    when new commits and pull requests occur. In order to create the token, use the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://github.com/settings/tokens](https://github.com/settings/tokens)
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Generate new token button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give it a descriptive name, such as `Effective DevOps with AWS Jenkins`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the  repo, admin:repo_hook, and admin:org_hook scopes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the Generate token button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This brings you back to the main token page. Save the token that is generated.
    We will need it later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adding the access token to the credentials in Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now add the token to Jenkins as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Jenkins, in my case `http://18.208.183.35:8080`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Credentials in the menu on the left, then click on System just after
    it it, and then Global credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, click on Add credentials.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The credentials we are going to create are of the type Username with password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scope should be global.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use your GitHub organization as a username.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the token generated in the previous section as your password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The ID can be something like `GitHub` as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/50c9d78c-1ef5-4c08-abc3-7c8ea5f234d9.png)'
  prefs: []
  type: TYPE_IMG
- en: You can also choose to give it a description. After that, click OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The last step of our initialization process consists of creating the Jenkins
    job.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Jenkins job to automatically run the builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned previously, Jenkins has a plugin to help with the GitHub integration.
    We can easily take advantage of this by creating a GitHub organization job. To
    do this, go through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your Jenkins home page in your browser, enter  `http://18.208.183.35:8080/`
     and click on Create new jobs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter an item name, provide your GitHub username or organization name, click
    on GitHub Organization, and then click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This will bring us to a new page, where we will be able to configure the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Credentials drop-down menu, select your newly created credential.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate that the owner is your username or organization name or the name you
    provided while creating the job. This will be used by Jenkins to scan all your
    repositories.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we already know that we are only interested in the `helloworld` repository,
    click on the Add button at the bottom of the Behaviors section and select the
    first option, which should be Filter by Name (with regular expression).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the newly populated field, Regular expression, replace `.*` with `helloworld`. Select
    strategy as All branches from the Discover branches section and scroll down to
    select one minute from the Scan Organization Triggers section on the same page:'
  prefs:
  - PREF_OL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/04b09d75-9436-4b4d-b976-19e5036c0db8.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Save.
  prefs:
  - PREF_UL
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/08e9deeb-4169-4321-93b7-a2adde97eea2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The job will be created and will scan the project to find a branch. It will
    find the master branch with the `README` file in it, but because we don''t have
    any code yet we will not do anything. In the following section, we are going to
    remediate that lack of code and implement our `helloworld` application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dbbb6d83-9963-408f-8e90-e6b23984b48f.png)'
  prefs: []
  type: TYPE_IMG
- en: Implementing the helloworld application using our CI environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we will once again use the simple `helloworld` web application that we
    created in [Chapter 2](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Deploying
    Your First Web Application*. The goal here is more to illustrate the use of our
    CI pipeline than to build a complex web application:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to use the same AWS instance that we deployed and configured in
    the previous section for Jenkins, as a development environment. Therefore, we
    need to have `nodejs` and `npm` installed on our instance. If you haven't installed
    these yet, refer to the instructions in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/15de66b9-f970-4b78-b705-32e42125a52d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our first step will be to clone the `helloworld` GitHub repository that we
    created in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a new branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Create an empty file called `helloworld.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: One of the best ways to write tests for these types of projects is to use a
    **Test Driven Development** (**TDD**) approach. In a TDD process, developers create
    the tests first, then run them to make sure they are failing, write the code,
    and then test again. At that point, the tests should pass. We can create a pull
    request and merge it once it has been reviewed and approved.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a functional test using Mocha
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to illustrate the process of writing tests for our TDD approach, we
    will use a tool called **Mocha** ([https://mochajs.org/](https://mochajs.org/)).
    Mocha is a very common and easy-to-use JavaScript test framework to create a test.
  prefs: []
  type: TYPE_NORMAL
- en: We will install it locally on our system using the following `npm`, the Node.js
    package manager command.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will initialize `npm` with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/745a176a-ac1b-4ad2-bf85-1cd70713d165.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will create a new file called `package.json`. Next, we will install Mocha
    and add it to our list of development dependencies as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This will create a directory called `node_modules`. Mocha will be installed
    in that directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to Mocha, we will use a headless browser testing module to render
    our `helloworld` application, called **Zombie**. We can install it with the same
    command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to separate the tests from the rest of the project, we are now going
    to create a directory called `test` in the root location of our `helloworld` project.
    By default, Mocha will look for tests in that directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The last piece of boilerplate code we will use will configure `npm` to use
    Mocha to run our tests. With your editor, open the `package.json` file and replace
    the test scripts with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `test` directory, create and edit the file `helloworld_test.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step consists of loading two modules that we are going to use and
    need in our test. The first one is `zombie`, our headline browser, and the second
    one is the `assert` module, which is the standard module used to create unit testing
    in Node.js applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to load our application. This is done by calling the same `require()`
    function, but this time we will ask it to load the `helloworld.js` file that we
    will soon implement. For now, it''s an empty file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now start creating the test. The basic syntax of Mocha tries to mimic
    what it thinks specification document could require. The following are the three
    required statements, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We now need to add hooks into that test to interact with our web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step will be to point the test to our application endpoint. As you
    might remember from the previous chapters, the application is running on `http://localhost:3000`.
    We will use the hook called `before()` to set up a precondition. Above the call
    to `it()`, add the following to point our headless browser to the proper server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, our headless browser will connect to our application, but it
    won''t request any page. Let''s add that in another `before()` hook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that the home page has loaded, we need to implement the code in the `it()`
    function to validate our assertion. We will edit the line with the `it()` call
    to add a callback function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Our test is now ready. If everything went well, your code should look like
    the one shown at the following link: [https://raw.githubusercontent.com/yogeshraheja/helloworld/master/test/helloworld_test.js](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/test/helloworld_test.js).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can test it in Terminal by simply calling the Mocha command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our test is failing. It can't connect to the web application.
    This is, of course, expected, since we haven't implemented the application code
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Developing the remainder of the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are now ready to develop our application. Since we already went through
    creating the exact code in [Chapter 2](1abe175d-50df-434d-bc0a-097397a39cee.xhtml),
    *Deploying Your First Web Application*, we are simply going to copy it or download
    it directly as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now test the code again using the `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running the preceding command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/459801e2-d046-4807-8516-0dfdfa7fd057.png)'
  prefs: []
  type: TYPE_IMG
- en: Our test is now passing.
  prefs: []
  type: TYPE_NORMAL
- en: We are almost there. We have satisfied one of our first goals, which was to
    have test coverage for our code. Of course, a real application with more complexity
    would have many more tests, but what we want to focus on now is automation. Now
    that we've learned how to test our code manually, we want to see how Jenkins can
    do this for us.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CI pipeline in Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw earlier, Jenkins works by creating and executing jobs. Historically,
    one way to create the pipeline would be to open Jenkins in the browser, navigate
    to the job we previously created, and edit it to outline the different steps involved
    in testing our code. The problem with that solution is that there isn't a good
    review process involved and it's hard to track every change made over time. In
    addition, it's very hard for developers to make changes in a project that involves
    adding new build steps as the code of the project and the job building the project
    aren't synced together. Jenkins 2 made the concept of describing the build process
    into a local file a standard feature, which we're going to use in the following
    section.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create and edit a new file in the project called `Jenkinsfile`
    (capital `J`, no file extension). The file will be written in **Groovy** ([http://www.groovy-lang.org](http://www.groovy-lang.org)).
  prefs: []
  type: TYPE_NORMAL
- en: 'On the first line of the file, we are going to put the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This is useful for the different IDEs and GitHub as it indicates the nature
    of the file. The first step of our script will consist of asking Jenkins to assign
    the job to a node as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our Jenkins installation is fairly simple. We only have one server and therefore
    only one node. If we had more nodes, we could add parameters to the call to target
    a node with a specific architecture, or even drive the parallel execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our CI testing can be logically broken up into a few steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the code from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the different dependencies by calling the `npm install` command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run our run with the command `mocha`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Clean up.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'These steps have an equivalent concept in Jenkins called **stages**. We are
    going to add them inside the node routing. Here is what the first stage will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: This tells Jenkins to get the code from the source control. When we created
    the job, we stated that it was a GitHub organization job, so Jenkins will know
    how to interpret that correctly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to call the `npm install` command. Groovy doesn''t understand
    native language specific features such as calling `npm`. To do this, therefore,
    we will use the `sh` command, which will allow us to spawn a shell and run a command.
    Here is what our second stage looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'In our next stage, we are going to run Mocha. The following is the `Setup`
    stage; add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can proceed to clean up the repository with the following stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The Jenkins file is now ready, it should look like this: [https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile](https://raw.githubusercontent.com/yogeshraheja/helloworld/master/Jenkinsfile).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now commit our code and test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a remote branch called `initial-branch`. As the branch gets
    created, Jenkins will get a notification from GitHub about the change and will
    run the CI pipeline. In a matter of seconds, our test will run on Jenkins, which
    in turn will send the result back to GitHub. We can observe this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Open GitHub in your browser and navigate to the `helloworld` project you created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Branch and select initial-branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From that screen, click on New pull request, provide a title and a good description
    of the change you are making. If possible, mention other developers so that they
    can thoroughly review the change you are proposing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Create pull request and follow the steps to create a pull request.
    Once the pull request is created, you will be able to see how GitHub shows that
    the pull request has passed all checks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f1cdb793-6c9b-4ab8-8ebc-31d6b4c5626d.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also go to your Jenkins browser and check the build history. You can
    even check the details from Jenkins by clicking the organization, followed by
    repository and branch. This will bring us back to the Jenkins job, where you can
    observe the execution of the job and its pipeline in more detail:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f966e8c5-f53e-48e2-92f1-eb04a6fd4a28.png)'
  prefs: []
  type: TYPE_IMG
- en: At that point, if you mentioned other developers, they should get a notification
    so that they can look at the content of the pull request. Once it is reviewed
    and approved, the pull request can be merged. From that point on, when developers
    pull the master branch or rebase their branch, they will see your code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on the size of the team working on a repository, it is common to have
    to rebase a branch. The two most important times to do that are before creating
    the pull request (step 2) and before merging it (step 6).
  prefs: []
  type: TYPE_NORMAL
- en: Productionizing the CI pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now put in place a basic, yet functional, CI pipeline. While this is
    a good starting point, you are likely to want to perfect certain details of this
    system. As mentioned previously, our Ansible recipe for Jenkins can be improved
    to include the configuration of the jobs such as the `helloworld` job we manually
    created.
  prefs: []
  type: TYPE_NORMAL
- en: We only created a single functional test to illustrate how to use a TDD approach
    and how to integrate a testing step in our pipeline. The success of a continuous
    integration pipeline depends strongly on the quality and quantity of the tests
    produced. Tests will typically be broken up into functional and non-functional
    tests. In order to best take advantage of your pipeline, you will want to catch
    possible errors as early as possible. This means focusing on the functional tests
    and in particular the **unit tests,** which are used to validate small units of
    code such as a method in a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, you can focus on **integration testing,** which covers a bit more
    ground and usually interacts with data stores and other functions in the code.
    Finally, you will want to add **acceptance testing** to verify that all the requirements
    for your stories are complete:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a791083-e83e-48b0-a39f-81c6ca5fa43a.png)'
  prefs: []
  type: TYPE_IMG
- en: In terms of non-functional testing, you will usually want to look at **performance**,
    **security**, **usability,** and **compatibility** testing.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can complement your own tests with code analyzer tools to get a
    sense of the code coverage (how many lines of code are executed by your automated
    tests).
  prefs: []
  type: TYPE_NORMAL
- en: As always with DevOps, it is important to collect metrics. In a CI pipeline,
    you will typically want to monitor the number of builds that go through the CI
    pipeline and the quality of the pull requests.
  prefs: []
  type: TYPE_NORMAL
- en: Like any other system, you will need to spend a bit of time setting up backups
    and monitoring. You may decide to back up the Jenkins home directory if you haven't
    moved to a model where your jobs and the Jenkins configuration are managed by
    your configuration management system (Ansible). In terms of metrics, keeping an
    eye on the system performance, its availability, and health are paramount. A breakage
    in the build pipeline should be considered a critical issue as it impacts the
    productivity of all the developers and operators.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you should expect to have to scale up your CI infrastructure over time.
    As code and tests get added, it will take longer and longer to run the tests.
    You may decide to add more Jenkins slaves, which will allow you to run tests in
    parallel and/or use bigger instances. In the current format, Jenkins will run
    the `helloworld` pipeline every time a change is pushed to a branch. You may also
    decide to only run the pipeline once the pull requests are created.
  prefs: []
  type: TYPE_NORMAL
- en: In the initial section of this chapter, we adopted a new workflow where developers
    commit code and tests to individual branches and send frequent pull requests to
    share the proposed changes with the rest of the engineering organization. In addition,
    we made sure that the new code is fully tested by creating a continuous integration
    pipeline. To do this, we created a Jenkins server and hooked it to GitHub. Thanks
    to that system, all the tests committed with the project get automatically executed
    and the results are sent back to GitHub. We are now in an ideal situation to take
    our workflow to the next level and automate deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Are the QA teams no longer needed with DevOps?**'
  prefs: []
  type: TYPE_NORMAL
- en: Yes and no. In an effective DevOps organization, non-technical QA jobs are not
    usually needed. If everything is fully automated and the developers write sufficient
    tests to cover all aspects of the code, the organization doesn't need to task
    anyone to write and execute test plans. Instead of that, DevOps-focused organizations
    will have engineers, sometimes called QA engineers, who focus on quality but with
    an emphasis on automation. This involves working on tooling and processes to improve
    the ability to automatically test code.
  prefs: []
  type: TYPE_NORMAL
- en: Building a continuous deployment pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By creating a CI pipeline, we have taken the first step toward being an effective
    **engineering** organization. Because our workflow now involves working in individual
    branches and merging them back to the master branch after going through automated
    testing and human reviews, we can assume that the code present in the master branch
    is of high quality and is safe to deploy. We can now focus on the next challenge,
    which is to release code automatically as new code gets merged into the master
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: By continuously releasing new code, you drastically accelerate the feedback
    loop process that DevOps provides. Releasing new code to production at high speed
    lets you collect real customer metrics, which often leads to exposing new and
    often unexpected issues. For many companies, deploying new code to production
    is a challenge. It can be quite worrying, especially if it involves thousands
    of new commits all going out to production at the same time in a process that
    occurs only a few times a year. Companies that do this often schedule their maintenance
    late at night and during weekends. Adopting a more modern approach, such as the
    one we will go through in the remainder of the chapters, will have a significant
    positive impact on the work-life balance of the engineering team.
  prefs: []
  type: TYPE_NORMAL
- en: Most well-known tech companies such as Google or Facebook don't deploy code
    on Fridays. The goal is to avoid pushing bugs out just before the weekend, which could otherwise
    lead to unexpected pages on Saturdays or Sundays. Because they aren't scared of
    deploying code, a lot of those changes will go out to production at peak hours
    so that they can quickly catch any issues related to load.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to implement our continuous deployment pipeline, we are going to look
    at two new AWS services—**CodePipeline** and **CodeDeploy**:'
  prefs: []
  type: TYPE_NORMAL
- en: CodePipeline let us create our deployment pipeline. We will tell it to take
    our code from GitHub, like we did before, and send it to Jenkins to run CI testing
    on it. Instead of simply returning the result to GitHub, however, we will then
    take the code and deploy it to our EC2 instance with the help of AWS CodeDeploy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CodeDeploy is a service that lets us properly deploy code to our EC2 instances.
    By adding a certain number of configuration files and scripts, we can use CodeDeploy
    to deploy and test our code reliably. Thanks to CodeDeploy, we don't have to worry
    about any kind of complicated logic when it comes to sequencing our deployment.
    It is tightly integrated with EC2 and knows how to perform rolling updates across
    multiple instances and, if needed, perform a rollback.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    as Code*, we looked at how to configure servers and deploy the `helloworld` application
    using Ansible. While this solution allowed us to illustrate how to use configuration
    management, this solution is not good enough for a more critical service. There
    isn't any notion of sequencing, there are no good feedback mechanisms to tell
    us how the deploy went, and we didn't implement any validation steps.
  prefs: []
  type: TYPE_NORMAL
- en: Having a dedicated service geared towards carrying out deployments in AWS will
    make deploying applications a lot better, as we will see in the following section. In
    order to demonstrate these services, we will first build a new generic Node.js
    web server using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new web servers for continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to use CodeDeploy, the EC2 instances need to be running the CodeDeploy
    agent. This is normally done by downloading an executable from an S3 bucket, which
    varies depending on the region your instances are running in. Conveniently, AWS
    has also released a custom Ansible library, which can automate these steps. Because
    that library isn't a part of the standard Ansible library, we first need to add
    it to our Ansible repository.
  prefs: []
  type: TYPE_NORMAL
- en: Importing a custom library to Ansible for AWS CodeDeploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Ansible expects to find the custom libraries in the `/usr/share/my_modules/`
    directory. Previously, when we looked at the inventory script in [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*, we changed this default behavior by editing
    the `ansible.cfg` file. We will make the necessary changes so that the library
    is being downloaded onto the host with the rest of the Ansible files. The simplest
    way to accomplish this is to create a new directory at the root of our `ansible`
    repository and put the library in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your computer, open a Terminal and go to your `ansible` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the root directory of our `ansible` repository, where the `ansible.cfg`
    file is located, we are going to add the new directory library to store the AWS
    CodeDeploy `ansible` library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the folder is created, we can download the `ansible` library in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we are going to edit the `ansible.cfg` file that is present in the
    root directory of the `ansible` repository to specify the location of the library
    folder as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: We are now ready to start using the library. CodeDeploy is a service that we
    are likely to reuse over time as new services get added to our system. In order
    to ensure that our Ansible repository code conforms to the **Don't Repeat Yourself**
    (**DRY**) principle, we are going to create an Ansible role that is dedicated
    to CodeDeploy.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CodeDeploy Ansible role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are first going to go into the role directory that is present at the root
    location of our `ansible` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, we will rely on `ansible-galaxy` to put in place the scaffolding
    that is needed to create our role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Our role will be very simple. We are going to edit the `codedeploy/tasks/main.yml` file
    and make a call to the new module that the `aws_codedeploy` library provides,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can create our new playbook for generic `nodejs` web servers.
    First, go back in the root directory of the `ansible` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new file called `nodeserver.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We will take the same approach we did previously with our other playbooks.
    The goal of our servers will be to run Node.js applications and run the CodeDeploy
    daemon. Edit the `nodeserver.yml` file and add the following to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: When using CodeDeploy in a config management system such as Ansible or CloudFormation, it
    is important to always install all the dependencies for your application prior
    to starting it. This allows you to avoid a race condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now commit our changes to `git`. First, create a new branch and then
    add new files and directories that we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `commit` and `push` the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, you can now create a pull request. Once the pull request has been
    reviewed and approved, merge it back to the master. After you have followed these
    steps, your Ansible repository should look as follows: [https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter05/ansible](https://github.com/yogeshraheja/Effective-DevOps-with-AWS/tree/master/Chapter05/ansible).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the web server CloudFormation template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we now have our Ansible playbook ready, we can create our CloudFormation
    template using Troposphere. Start by duplicating the Troposphere script that we
    created for Jenkins earlier in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `nodeserver-cf-template.py` file to make the following changes. First,
    change the application name and port by updating the variables as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, our instances will need to download files from S3\. To allow this
    to happen, replace the policy that allowed CodePipeline on our Jenkins instance
    with a policy to allow S3\. Edit the policy called `AllowCodePipeline` and update
    its name and action. Above the instantiation of our instance, add a new IAM policy
    resource as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The new script should look as follows: [https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/nodeserver-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/nodeserver-cf-template.py).
  prefs: []
  type: TYPE_NORMAL
- en: 'As the new script is now ready, we can save it and generate the CloudFormation
    template as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Launching our web server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As before, we are going to launch our instance using CloudFormation. Note that
    we are calling this first stack `helloworld-staging`. We will first look at CodeDeploy
    as a way to deploy our code to a staging environment. We will use this name in
    CodeDeploy so that we can target the deployments to that specific stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: In a few minutes, our instance will be ready.
  prefs: []
  type: TYPE_NORMAL
- en: We are now at an important point in our DevOps transformation. We have now created
    generic `nodejs` web servers that allow you to deploy code on them easily. We
    are really close to a realistic environment that effective companies traditionally
    use to deploy and run their services. The fact that we are able to create these
    environments simply and on demand is our key to success.
  prefs: []
  type: TYPE_NORMAL
- en: When architecting services, always make sure that the infrastructure can easily
    be recreated. Being able to troubleshoot an issue is great, but being able to
    quickly rebuild a service host and stop the impact on the user is often even more
    desirable.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating our helloworld application with CodeDeploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our servers are initiated and the CodeDeploy agent is running, we can
    start using them. First, we need to create an IAM service role for CodeDeploy.
    We then need to add an entry in the CodeDeploy service to define our application.
    Finally, we need to add our application specification file and a few scripts to
    help with deploying and running our service to the `helloworld` application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the IAM service role for CodeDeploy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'CodeDeploy permissions work with IAM at the level of the individual application.
    In order to provide sufficient permissions, we will create a new IAM service role
    with the following policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create a new role that will be called `CodeDeployServiceRole` using
    the following command in the command-line interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We now need to attach the role policy to provide the proper permissions to
    the service role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Our IAM service role is now ready. We can finally start interacting with the
    CodeDeploy web interface.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CodeDeploy application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have launched EC2 instances with the CodeDeploy service running
    on them and defined our IAM service role, we have all the requirements to create
    a CodeDeploy application. As always, there are many ways to use AWS services,
    but we will demonstrate the basic uses with the web interface in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://console.aws.amazon.com/codedeploy](https://console.aws.amazon.com/codedeploy)
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If prompted, click on Get Started Now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This leads us to a welcome screen with two options, Sample Deployment and Custom
    Deployment. Choose Custom Deployment and click on Skip Walkthrough**.** This brings
    us to a form called Create Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In that form, under Application Name, give our application the name `helloworld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The deployment groups can be viewed as the environment in which the application
    will live. We will first create a staging environment. Under Deployment Group
    Name, provide the name `staging`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to add instances to our application. Our goal is to target the
    EC2 instance that we previously created with CloudFormation. As you might recall,
    we called our stack `helloworld-staging`. In the section Environment configuration,
    select Amazon EC2 instances, and select `aws:cloudformation:stack-name` in the
    Key field and `helloworld- staging` in the Value field. This will make sure that
    CodeDeploy only selects the instance that we intend to use for our application.
    AWS CodeDeploy should confirm that it matched one instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b2b61b09-cff2-43b7-9d2a-8fe58e409a65.png)'
  prefs: []
  type: TYPE_IMG
- en: The next section is called **Deployment configuration**. One of the strengths
    of CodeDeploy is its ability to understand how to deploy code to a cluster of
    servers. This features makes it easy to avoid outages during deployment. By default,
    the service comes with three deployment options—one at a time, all at once, and
    half at a time. It is possible to create custom deployment configurations, but
    in our case, since we have only one instance, we can leave the default option
    `CodeDeployDefault.OneAtATime`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next two sections are called triggers and alarms. We aren't going to cover
    these in detail in this book, but basically triggers are useful when it comes
    to collecting metrics around deployment and monitoring. By creating triggers to
    push notifications in SNS and creating CloudWatch metrics, you can easily collect
    metrics around deployments. This helps you answer questions such as how many deployments
    are happening, how many fail, how many deploys lead to rollback, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our application is somewhat stateless, therefore enabling rollback upon failure
    is a good idea. Select the Roll back when a deployment fails option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we need to select the service role that we created in the previous steps.
    Under Service Role ARN, select the role that ends with CodeDeployServiceRole.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on Create Application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This brings us back to the CodeDeploy application page for our newly created
    `helloworld` application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application in CodeDeploy allows us to define where our newly created
    application will be deployed. We will now look at how to deploy our code.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CodeDeploy configuration and scripts to our repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we worked on creating a Jenkins pipeline earlier in this chapter, we created
    a Jenkinsfile file inside the `helloworld` GitHub repository. The reason for this
    was that we could change the code and the way the code is tested in the same change
    set. For the same reason, it is a good idea to put the logic about how to deploy
    our code with the code itself.
  prefs: []
  type: TYPE_NORMAL
- en: Our `helloworld` repository currently contains the application that we created
    inside a new GitHub organization (`yogeshrahejahelloworld` in my case). It also
    contains the applications tests and a repository with name `helloworld` . We are
    now going to add the information that CodeDeploy needs in order to execute the
    deployment of our service.
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeDeploy relies on an application specification file called `appspec.yml`
    to manage deployment. We first need to create this file. Go to the directory where
    the `helloworld` GitHub project is cloned and create a new branch off the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to create and edit the file `appspec.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first line of the file, we are going to define which version of the
    AppSpec file we want to use. Currently, the only version that is supported is
    `0.0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'On the next line, we are going to specify the operating system on which we
    wish to deploy our service. In our case, this is Linux:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to describe which file goes where. To do this, we are going
    to create a section called `files` and put each file that we want to deploy using
    a format source destination. Note that the file is written in YAML and therefore
    the spacing and alignment are important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to this section, CodeDeploy now knows to copy the `helloworld.js` in
    the target destination, `/usr/local/helloworld`. Our `helloworld` directory will
    be automatically created by CodeDeploy. In order to start the application, we
    will also need our upstart script, which isn't currently in the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in the Terminal of  the root directory of the `helloworld` project, we
    are going to create a subdirectory called `scripts` and add the upstart script
    to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add the `helloworld.conf` file that new file to our `appspsec.yml`
    by adding another block with the source and destination of the upstart script
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The two files that we need in order to run our application as a service will
    now be present in the appropriate locations. In order to deploy our application,
    we need more files. We need CodeDeploy to start and stop the service. Previously,
    we started the application using Ansible, but this time around we aren''t using
    Ansible to manage our service. CodeDeploy has a much more elegant solution: when
    a deployment starts, the CodeDeploy agent running on the EC2 instance will go
    through the following sequence of events:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/90cf2590-75a6-4078-93da-0405583c3e9a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The archive containing our application will be downloaded on the system during
    the **DownloadBundle** event. The install section will be used to copy the files
    defined in our template to their destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'CodeDeploy uses the concept of hooks. In the `appspec.yml` file we can create
    a number of hooks to execute custom scripts during each of the stages described
    previously. We are going to create three scripts: a script to start our application,
    a script to stop it, and finally a script to check if the deployment was successful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will put these three scripts in the `scripts` directory that we created
    previously. Let''s create the first file `start.sh` and start editing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'The script is very straightforward. We are simply going to call upstart to
    start the service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'This is all we need. We are now going to create our stop script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: 'As we did before, edit it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'The stop script is slightly more complicated than the start script because
    it will be executed during the `BeforeInstall` step. The basic logic is the same:
    we are making a call to stop the `helloworld` application. We have some extra
    calls before this because we need to handle the case of the first deployment where
    the application hasn''t been installed and started before.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last script we will create is called `validate.sh`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again the code is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: For the purposes of this book, we are carrying out the most basic validation
    possible. This consists of a HEAD request on the only route that our application
    has. In a more realistic application, we would test more routes and anything that
    could potentially go wrong when new code is pushed out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our scripts need to be executable to avoid any unnecessary warnings in CodeDeploy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add our hooks in our `appspec.yml` file. Open the file again and create
    a `hooks` section below the `files` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: 'We will first declare the stop script that we want to run at the `BeforeInstall`
    stage. In the hooks section, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'We are allowing `30` seconds for the execution of the stop command to complete. We
    are going to repeat a similar operation to add our start and validate scripts
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'When our deploy pipeline runs, it will try to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Download our application package and decompress it in a temporary directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the stop script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the application and upstart script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the start script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the validate script to make sure everything is working as expected
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can add all our new files to `git`, commit and push the changes, and send
    a pull request as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The branch will go through Jenkins and be tested. A peer can then review the
    code change; once it is approved, you can merge your pull request.
  prefs: []
  type: TYPE_NORMAL
- en: In order to perform deployment, we essentially need to answer three questions—*what
    are we trying to deploy?* *Where are we trying to deploy it?* *How can we deploy
    it?* We answered the second question when we created the job in CodeDeploy and
    the third question with our appspec file and its helper scripts. We now need to
    look into the first question—*what are we trying to deploy?* This is where we
    are going to use AWS CodePipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Building our deployment pipeline with AWS CodePipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodePipeline is a service dedicated to creating delivery pipelines. You
    can think of it as similar to the Jenkins pipelines feature with an AWS twist.
    The service is very well integrated with the rest of the AWS ecosystem, which
    means that it has a number of great features and useful advantages over Jenkins.
    Because it's a fully managed service, you don't have to worry about its uptime
    the way we do with a single Jenkins instance. It integrates out of the box with
    CodeDeploy, which is very handy for our case. While we won't go into too much
    detail here, the service is fully integrated with the IAM service, which means
    that you have a very granular level of control over who can do what. The service
    can, for example, prevent unauthorized users from performing deployments. Thanks
    to its API, a number of services can be integrated into your pipelines, including
    Jenkins and GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: We will first look into creating a basic pipeline in two stages. In the first
    stage, we will get the code from GitHub, package it, and store the package on
    S3\. In the second stage, we will take that package and deploy it to our staging
    instance using CodeDeploy.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will go through a more advanced scenario. We will see how we
    can use our Jenkins instance to run our tests before deploying our code to staging.
    We will also create a production environment and add an on-demand production deployment
    process, called a continuous delivery pipeline. Finally, we will look at a couple
    of strategies that will allow us to build confidence in the code that we push
    through our pipeline so that we will be able to remove the on-demand production
    deployment step and turn it into a fully automated pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a continuous deployment pipeline for staging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our first deployment pipeline with `CodePipeline`, we are going to
    use the AWS console, which offers a very intuitive web interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the following link in your browser: [h](https://console.aws.amazon.com/codepipeline)[t](https://console.aws.amazon.com/codepipeline)[t](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[://c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[l](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[w](https://console.aws.amazon.com/codepipeline)[s](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[m](https://console.aws.amazon.com/codepipeline)[a](https://console.aws.amazon.com/codepipeline)[z](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[.](https://console.aws.amazon.com/codepipeline)[c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[m](https://console.aws.amazon.com/codepipeline)[/c](https://console.aws.amazon.com/codepipeline)[o](https://console.aws.amazon.com/codepipeline)[d](https://console.aws.amazon.com/codepipeline)
    [e](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[i](https://console.aws.amazon.com/codepipeline)[p](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline)[l](https://console.aws.amazon.com/codepipeline)[i](https://console.aws.amazon.com/codepipeline)[n](https://console.aws.amazon.com/codepipeline)[e](https://console.aws.amazon.com/codepipeline).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If prompted, click on Get started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, give your pipeline the name `helloworld` and click on Next
    Step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the source location, select GitHub as a Source provider and click on Connect
    to Github. If requested, sign into your GitHub account.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will bring you back to the AWS CodePipeline screen. We can now select a
    Repository and branch. We will select the `helloworld` project and the master
    branch. Click on Next step**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't see the organization name/repository name (that is, `yogeshrahejahelloworld/helloworld`)
    then, as a workaround, clone/copy the organization name/repository name to your
    global Github repository (that is, `yogeshrahejahelloworld/helloworld`  to `yogeshraheja/hellworld`
    in my case).
  prefs: []
  type: TYPE_NORMAL
- en: This brings us to stage three of our pipeline where we can select our Build
    provider. Our application is being written in Node.js so we don't need to build
    anything. Select No build and click on Next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next step is called **Beta.** This is essentially our staging deployment
    step. Under Deployment provider, select AWS CodeDeploy. Under Application name,
    select `helloworld`. Finally, select staging for the Deployment group. Click on
    Next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This brings us to a step in which we have to choose our Role Name. Conveniently,
    AWS have also added a Create Role button. Click on this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, select Create a new IAM Role and give it the name `AWS-
    CodePipeline-Service`. Use the policy proposed and click on Allow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the CodePipeline step and make sure that role name says `AWS- CodePipeline-Service`.
    Click on Next step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the review screen, make sure everything is correct. Finally, click on Create
    Pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Because we are using the web interface, Amazon automatically creates an S3 bucket
    on your behalf to store the artifacts that are produced when the pipeline runs.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c34cd2eb-4c88-42d4-8fb2-217080aa3223.png)'
  prefs: []
  type: TYPE_IMG
- en: The pipeline will be created in a matter of seconds and run for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the basic functions of CodeDeploy and CodePipeline, we have used
    the web and command line interface. This process is very manual and doesn't go
    through any kind of review process. CloudFormation supports these two services.
    For a real production system, instead of making changes by hand, it is best to
    use something like Troposphere to generate the templates programmatically to manage
    the services.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once both steps have run, you can verify that the code has been deployed by
    opening in your browser `http://**<instanceip>**:3000`. The instance IP can be
    found in the CloudFormation template or the EC2 console. You can even verify the
    success with the following one-liner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: We have finished our basic pipeline. By taking advantage of CodePipeline, CodeDeploy,
    GitHub, and S3, we have built a very elegant solution to handle the deployment
    our web application. Every time a pull request is merged to the master, our pipeline
    will pick up the change, automatically create a new package with the new code,
    store it on S3, and then deploy it to staging. Thanks to CodeDeploy we can have
    a basic test in place to verify that the version is working. If needed, we can
    also roll back to any revisions that were built previously.
  prefs: []
  type: TYPE_NORMAL
- en: Our pipeline doesn't have to be limited to staging; we can actually do a lot
    more. As we mentioned previously, CodePipeline can integrate with Jenkins. We
    can use CodePipeline to build artifacts, but also to run some extra series of
    tests. Let's add it to our pipeline before deploying to staging.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Jenkins to our CodePipeline pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features that makes Jenkins so popular is its plugin capability.
    AWS released a number of plugins to integrate different services with Jenkins.
    We are going to use the one that has been created for CodePipeline. First, this
    will require us to change the IAM profile role of the instance so that it can
    interact with CodePipeline. We will then install the CodePipeline plugin in Jenkins
    and create a job to run our test. Finally, we will edit our pipeline to integrate
    the new stage.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the IAM profile through CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to add the new privileges to the instance profile, we are going to
    edit the `jenkins-cf-template.py` template that we created earlier in the chapter.
    We are going to add a policy to grant permissions to allow the Jenkins instance
    to communicate with CodePipeline. This step is very similar to the change we made
    to grant S3 access to our web server previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Above the instance variable instantiation, add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, save the changes and regenerate the template. The new template should
    look as follows:[ https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/EffectiveDevOpsTemplates/jenkins-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/Effective-DevOps-with-AWS/master/Chapter05/EffectiveDevOpsTemplates/jenkins-cf-template.py):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the web interface, update the stack:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://console.aws.amazon.com/cloudformation](https://console.aws.amazon.com/cloudformation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the checkbox next to the Jenkins stack and in the Actions menu, select
    Update Stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Browse to the newly generated `jenkins-cf.template` and click on Next until
    you get to the review screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/38e0c4c5-cf02-4276-99dd-c6940556b57f.png)'
  prefs: []
  type: TYPE_IMG
- en: As shown in the preceding screenshot, only the IAM policy is being added because
    we created our instance with an instance profile. Our EC2 instance will stay untouched,
    making this change safe. Click on Update to confirm the change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The instance policy will get updated, giving Jenkins enough permissions to interact
    with CodePipeline. We can now install the Jenkins plugin for CodePipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using the CodePipeline Jenkins plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing a plugin in Jenkins is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Open your Jenkins instance in your browser (in my case `http://1 8.208.183.35:8080`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If necessary, log in and click on Manage Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: on the Manage Jenkins page, select Manage Plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for the plugin called AWS CodePipeline Plugin, select it, and install
    it. We can now start using the plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to the homepage of your Jenkins server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on New Item in the menu on the left.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give the new item the name `HelloworldTest`, select Freestyle project**,** and
    click on the OK button at the bottom of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the next screen, under Source Code Management, select AWS CodePipeline. Because
    we configured the permissions at the instance profile level, the only options
    we need to configure are the AWS Region and Category, which are in our case `US_EAST_1`
    and `Test`respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under Build Triggers, select Poll SCM and then type `* * * * *` to tell Jenkins
    to check with CodePipeline every minute for possible code test requests.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under the Build section, click on Add build step and then Execute shell.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once again, we are going to run the tests that we created at the beginning
    of the chapter. In the Command section, type the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: Add a post-build action and select the action called AWS CodePipline Publisher.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the newly generated AWS CodePipeline Publisher, click on Add, and leave the
    Location blank.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can configure the rest of the job according to your preferences and then
    click on Save to create the new job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our test job in Jenkins is ready to be used and we can now update our pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test stage to our pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are going to use the web interface to make this change:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `helloworld` pipeline we previously created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the `helloworld` pipeline page, click on the Edit button at the top of the
    pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a stage by clicking on the + Stage button located between the Source and
    Beta stages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call that stage `Test` and click on Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the menu on the right, under Action category, choose the action called `Test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call your action Jenkins and, for the Test provider, select Add Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Add Jenkins menu, leave the Provider Name set to `Jenkins`. Provide your
    Jenkins URL, which in my case is `http://18.203.183.35:8080`. The project name
    needs to match the name of the job on Jenkins. This should be `HelloworldTest`.
    Once set, click on Add action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply your change by clicking on Save pipeline changes at the top of the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the pipeline again by clicking on Release change. After a few minutes, you
    should be able to see the Jenkins step being executed. If everything goes well
    it should turn green.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our pipeline is now starting to look very interesting. Here, we have demonstrated
    the Jenkins integration in its most rudimentary form, but you can easily imagine
    more realistic scenarios where you would add a step after deploying your code
    to staging to carry out better validation with better integration, load, and even
    penetration testing.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of AWS CodePipeline is to help you take your services from source control
    all the way up to production. As you first start working on a service, you might
    not have the test coverage needed to continuously deploy it to production so you
    might opt for  one-click production deployment instead. We are going to take advantage
    of the automation we have built so far in this chapter and build a continuous
    delivery pipeline for production.
  prefs: []
  type: TYPE_NORMAL
- en: Building a continuous delivery pipeline for production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to build our continuous delivery pipeline, we are first going to create
    a CloudFormation stack for a production environment. We will then add a new deployment
    group in CodeDeploy, which will provide us with the ability to deploy code to
    the new CloudFormation stack. Finally, we will upgrade the pipeline to include
    an approval process to deploy our code to production and the production deployment
    stage itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the new CloudFormation stack for production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, we are going to reuse the exact same template as we used for staging.
    In your Terminal, go to the location you used to generate the node server template
    and then run the same command as before, but this time with the stack name `helloworld-production`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then run the following command to wait for the stack to be ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: You might realize the weakness of our production stack with only one EC2 instance
    in it. We will address that concern in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure,* when we talk about scaling strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CodeDeploy group to deploy to production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we created a CodeDeploy application and a first deployment group
    that allowed us to deploy our code to staging. Using the command-line interface,
    we are now going to add a new deployment group to deploy our code to our newly
    created production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the parameters needed to add new deployment groups is the `arn` of the
    policy we created initially. We can easily extract this from the staging deployment
    group that we created previously. We will store the result in a variable called
    `arn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now run the following command to create the new deployment group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went well, the new deployment group should be created. We can
    verify this by browsing to the application in the AWS CodeDeploy web page or using
    the command-line with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: Adding a continuous delivery step to our pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we saw earlier in this chapter, pipelines are composed of stages. In CodePipeline,
    stages are characterized by their categories. We have explored three categories
    so far: source, deploy, and test. In order to add a confirmation step to deploy
    our service to production, we will use a new category called **approval**.'
  prefs: []
  type: TYPE_NORMAL
- en: Approval actions offer a number of configuration options to send notifications
    when a job is pending approval. To demonstrate this feature, we are going to create
    a new SNS topic and subscribe to it. As you might remember from [Chapter 3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml),
    *Treating Your Infrastructure as Code*, SNS is the simple notification service
    that we used to monitor our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the command-line to create a new topic and subscribe to
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will use an email subscription. SNS also supports a number of other
    protocols such as SMS, HTTP, and SQS. In order to subscribe, you need to know
    the Topic ARN, which is in the output of the previous command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Go to your inbox to confirm the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now add our new stages, starting with the approval stage:'
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)
    in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `helloworld` application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on `Edit` at the top of the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `+ Stage` button at the bottom of the pipeline below the Beta stage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Give it the name `Approval`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on + Action**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Approval in the Action Category menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the action Approval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the approval type Manual approval**.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick the SNS topic we just created. Typing `production deploy` should allow
    you to find the topic easily thanks to the autocomplete feature of the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, click on Add action. We are now going to add the deployment to production
    steps below this approval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the + Stage button below the newly created stage Approval.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call this new stage Production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on + Action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Deploy category.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the action Production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the CodeDeploy provider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pick `helloworld` as our application name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the deployment group production.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the artifact `MyApp`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Add action.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Complete the creation of our new stages by clicking on Save pipeline changes
    at the top of the pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can once again click on Release change to test our updated pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline will go through the first three stages and then block at the approval
    stage. If you check your email inbox, you will find a link where you can review
    the change. Alternatively, you can simply use the web interface and click on the
    review button in the approval stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cbd25f05-1091-4872-b355-3e1e56661f49.png)'
  prefs: []
  type: TYPE_IMG
- en: After carefully reviewing the changes, you can either approve or reject the
    change. If it is approved, the deployment will continue to the last step of the
    pipeline and deploy the code to production.
  prefs: []
  type: TYPE_NORMAL
- en: We have now automated our entire release process. Our `helloworld` application
    may not reflect what a real application might look like, but the pipeline we built
    around it does. What we built can be used as a blueprint for deploying more complex
    applications from environment to environment safely.
  prefs: []
  type: TYPE_NORMAL
- en: There is no question that the ability to move fast and release your new features
    and services to customers allows you to prevent disruptions. The last step of
    building a continuous deployment pipeline is to remove the manual approval process
    to release code to production, thereby taking out the last step involving humans
    in the release process. Over the years, different companies have come up with
    a couple of strategies to make production deployments a safe process. In the next
    section, we will look at some solutions that you can implement.
  prefs: []
  type: TYPE_NORMAL
- en: Strategies to practice continuous deployments in production
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As always, your first line of defense is to have enough test coverage and sophisticated
    validation scripts that cover most of the sensitive routes and features in your
    product. There are some well-known strategies and techniques to make a continuous
    deployment pipeline safe for production. We will explore three common ones in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Fail fast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The pipeline that we built is fairly fast and robust. Depending on the nature
    of your service, you may choose to trust the quality of the code produced by your
    team and always deploy the code straight to production. With sufficient monitoring
    around your logs and application metrics, you will be able to catch issues minutes
    after the code is deployed. You can then rely on CodeDeploy and its ability to
    deploy older releases fast to recover from that situation.
  prefs: []
  type: TYPE_NORMAL
- en: If you take this approach and a problem is detected, simply roll back to a previous
    version. You may know exactly what's wrong and know that it's easy to fix, but
    the pressure caused by knowing that there is an ongoing issue impacting users
    can cause you to make more mistakes, making the situation worse.
  prefs: []
  type: TYPE_NORMAL
- en: Canary deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similarly, you could try to deploy your code straight to production, but only
    expose part of the traffic to the new code for some time. You can build a system
    where only a small percentage of the traffic hits the new servers that are running
    the new code and compare the error rate and performance originating from each
    release for a short period of time. Usually, 10% of the traffic for 10 minutes
    is sufficient to collect enough information about the quality of the new build.
    If, after that time, everything looks good, you can then move 100% of the traffic
    to the new version of the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bugs such as memory leaks are usually slower to manifest themselves; once the
    deployment is complete, continue closely monitoring your different systems and
    key metrics to make sure that no mistakes have been made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f553ebcc-786a-4381-8c80-4fc8b2baa3c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Feature flags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Also known as a dark launch, this last strategy is the hardest one to implement
    but also the most valuable. It is used by most well-known tech companies. The
    idea is to have multiple smart switches on each of your features. When you first
    deploy the code for a new feature, you do so with those switches turned off. You
    then progressively turn them on for different subsets of users. You might start
    by only allowing employees of the company to experience the feature. You might
    then decide to increase the number of people exposed to that feature by adding
    a set of trusted users. You might then turn the feature on for 20% of your users,
    then 50%, and so on. As well as allowing you to do a soft launch, this type of
    features can be used at the product level to carry out A/B testing, maintenance,
    where you want to turn off a specific feature, or even load testing.
  prefs: []
  type: TYPE_NORMAL
- en: One of the best uses of a dark launch was summarized in a blog post by Facebook.
    In 2008, Facebook launched their chat functionality. It was a very challenging
    feature as it was the first service Facebook developed in Erlang. In order to
    make sure the service would be able to handle the scale at which Facebook operates,
    they relied on a dark launch strategy. During the months leading up to the official
    launch, they simulated what the real traffic could look like by releasing the
    service without the UI. Real users browsers would establish connections to the
    chat servers and invisibly send and receive messages to simulate the load. When
    it was time to launch, Facebook didn't push out new code, but simply turned the
    switch on to make the chat window visible in the UI. More information about this
    launch can be found at: [https://www.facebook.com/notes/facebook-engineering/facebook-cha](https://www.facebook.com/notes/facebook-engineering/facebook-chat/14218138919/)
    [t/14218138919/](https://www.facebook.com/notes/facebook-engineering/facebook-chat/14218138919/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have been through one of the most important aspects of the
    DevOps philosophy—how to change the way in which code is released.
  prefs: []
  type: TYPE_NORMAL
- en: Our first objective was to improve developers' productivity. To that effect,
    we built a continuous integration pipeline. Taking advantage of Jenkins and GitHub,
    we created a new workflow where developers commit their code in individual branches
    and submit pull requests. The branches are automatically tested with Jenkins and
    a final peer review ensures that the code committed is of high quality.
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to this change, we can guarantee that the code present in the master
    branch of our project is always good and worth being pushed to staging. To do
    this, we built a continuous deployment pipeline. Thanks to AWS CodeDeploy and
    CodePipeline, we were able to easily build a fully functional pipeline. The pipeline
    has all the desired features an operator could wish for. It automatically picks
    up changes from developers merging their pull requests, creates a package of the
    new version of the application, stores the package on S3, and then deploys it
    to staging. As the new code gets deployed, validation steps ensure that the application
    isn't misbehaving and, if needed, the application can easily be rolled back.
  prefs: []
  type: TYPE_NORMAL
- en: Once we finished building our continuous deployment pipeline, we extended it
    to build a continuous delivery capability so that we could carry out production
    deployment on demand. We also added an extra stage to integrate testing through
    Jenkins within the pipeline itself. Finally, we discussed different techniques
    and strategies to have a continuous deployment pipeline for production that will
    allow us to perform dozens of production deployments a day for any given service.
  prefs: []
  type: TYPE_NORMAL
- en: Since we started to take a more DevOps approach towards managing our architecture
    and  services, we haven't looked at the notions of high availability or load balancing.
    Even in this chapter, we only created one EC2 instance for our production environment.
    We will address this in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure.* We will look at tools and services to scale our
    infrastructure and handle massive amounts of traffic.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Continuous Integration, Continuous Deployment and Continuous Delivery?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is Jenkins, and how does it help in the SDLC cycle?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Describe how to build your first continuous deployment pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please read the following articles for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jenkins Reference**: [https://jenkins.io/](https://jenkins.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocha Reference**: [https://mochajs.org/](https://mochajs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeDeploy Reference**: [https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html](https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodePipeline Reference**: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jenkins Reference**: [https://jenkins.io/](https://jenkins.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocha Reference**: [https://mochajs.org/](https://mochajs.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeDeploy Reference**: [https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html](https://docs.aws.amazon.com/codedeploy/latest/userguide/welcome.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodePipeline Reference**: [https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html](https://docs.aws.amazon.com/codepipeline/latest/userguide/welcome.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
