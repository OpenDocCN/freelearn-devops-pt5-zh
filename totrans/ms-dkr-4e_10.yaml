- en: '*Chapter 10*'
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker in Public Clouds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been using Digital Ocean to launch containers on a cloud-based
    infrastructure. In this chapter, we will look at the container solutions offered
    by **Amazon Web Services** (**AWS**), Microsoft Azure, and Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Before we talk about these container services, we will also go into a little
    bit of the history behind each one of the cloud providers and cover the installation
    of any of the command-line tools required to launch the container services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microsoft Azure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Cloud Run
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using AWS, Microsoft Azure, and Google Cloud, so
    if you are following along, you will need active accounts with one or all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget that if you are following along, there may be charges for the services
    you launch in public cloud providers – please ensure that you terminate resources
    when you have finished with them to avoid any unexpected costs.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon Web Services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first of the public cloud providers we are going to be looking at in this
    chapter is AWS. It was first launched in July 2002 as an internal service used
    within Amazon to provide a few disparate services to support the Amazon retail
    site. A year or so later, an internal presentation at Amazon laid the groundwork
    for what AWS was to become: a standardized and completely automated compute infrastructure
    to support Amazon''s vision of a web-based retail platform.'
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the presentation, it was mentioned that Amazon could possibly
    sell access to some of the services AWS had to offer to help fund the infrastructure
    investment required to get the platform off the ground. In late 2004, the first
    of these public services was launched – **Amazon Simple Queue Service** (**Amazon
    SQS**), a distributed message queuing service. Around this time, Amazon started
    work on services that it could consume for the retail site and services it could
    sell to the public.
  prefs: []
  type: TYPE_NORMAL
- en: In 2006, AWS was relaunched, and Amazon SQS was joined by **Amazon Simple Storage
    Service** (**Amazon S3**) and **Amazon Elastic Compute Cloud** (**Amazon EC2**),
    and from there, AWS's popularity grew. At the time of writing, AWS has an annual
    revenue of over $25 billion and the number of services offered as part of the
    platform has grown from the original 3 to over 210.
  prefs: []
  type: TYPE_NORMAL
- en: These services include **Amazon Elastic Container Registry** (**Amazon ECR**),
    which we looked at in [*Chapter 3*](B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109),
    *Storing and Distributing Images*, **Amazon Elastic Container Service** (**Amazon
    ECS**), and **AWS Fargate**. While these last two services are actually designed
    to work together, let's take a quick look at what options were available for using
    Amazon ECS before Amazon introduced AWS Fargate.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon ECS – EC2-backed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Amazon ECS is described by Amazon as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"A highly scalable, fast, container management service that makes it easy to
    run, stop, and manage Docker containers on a cluster."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In essence, it allows you to manage the placement and availability of Docker
    containers on a cluster of compute resources before you launch your first ECS
    cluster. Let''s quickly have a look at some of the terminology involved and get
    an idea of how it is going to hang together. When we launch our Amazon ECS-hosted
    application, we will need to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clusters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram will give you an idea of how the preceding elements are
    going to be utilized within our cluster; you can clearly see the containers, tasks,
    and the service, which in this diagram, is the box that spans the three instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Amazon ECS container instances'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.01_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Amazon ECS container instances
  prefs: []
  type: TYPE_NORMAL
- en: 'The important difference between the preceding diagram and if we were going
    to be using AWS Fargate is the fact that we are running container instances. To
    launch a cluster of EC2 instances, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the AWS console at [https://console.aws.amazon.com/](https://console.aws.amazon.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sign in.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **ECS** in the **Services** menu in the top-left corner of the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once you have the Amazon ECS page open, select your preferred region in the
    region switcher in the top-right corner – as I am based in the UK, I have chosen
    **London**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Clusters**, which is the first entry in the left-hand menu:![Figure
    10.2 – Creating Amazon ECS Clusters
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.02_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.2 – Creating Amazon ECS Clusters
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Click the **Create Cluster** button and you will be presented with three options:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Networking only**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**EC2 Linux + Networking**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**EC2 Windows + Networking**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we are going to be launching an AWS Fargate cluster next and our test application
    is Linux-based, select **EC2 Linux + Networking** and then on the **Next Step**
    button at the bottom of the options, and you should find yourself on the **Configure
    cluster** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to name our cluster. A cluster name is a unique name; I have called
    mine `RussTestECSCluster`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave the `1` to `3`; when using spot instances, it is important that you have
    more than 1 instance to maintain a basic level of availability.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**EC2 Ami Id**: This option can''t be changed.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**EBS storage (GiB)**: I left this at the default, **22GB**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Key pair**: I left this as **None - Unable to SSH**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For **Networking**, **Container instance IAM role**, **Spot Fleet IAM role**,
    and **Tags**, I left everything at their defaults before finally reaching the
    very last option, **CloudWatch Container Insights**, I ticked the box for **Enable
    Container Insights**. Once everything's filled in, click on the **Create** button.
    Once clicked, your cluster will be launched, and you can track the progress as
    resources are configured and launched:![Figure 10.3 – Launcing the ECS cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.03_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.3 – Launcing the ECS cluster
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once it's launched, you can click on the **View cluster** button, which will
    take you the following screen:![Figure. 10.4 – Looking at the ECS cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.04_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.4 – Looking at the ECS cluster
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now that we have a cluster, we need to create a task definition. To do this,
    click on **Task Definitions** in the left-hand menu and then click on the **Create
    new Task Definition** button. The first option we are presented with asks which
    launch type we want to use. We have just created an EC2-based cluster, so select
    **EC2**:![Figure 10.5 – Select which type of task we need
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.05_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.5 – Select which type of task we need
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once selected, click on the `cluster-task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`1gb`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1 vcpu`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This brings us down to the container definitions. As a task definition is a
    collection of containers, you can enter multiple containers here. In this example,
    we are going to add a single container. To start, click on `cluster-container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`russmckendrick/cluster:latest`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`128`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`80` for the `tcp`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Leave the remainder of the form at the default settings and then click on **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The final part of the task definition we need to define is `cluster-task`, leave
    **Volume type** as **Bind month** and **Source path** empty, and then click on
    the **Add** button. Now, click on **Create** and then return to the cluster via
    the left-hand **Clusters** menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have our cluster, and our task definition, we can create a service.
    To do this within the `cluster-service`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Service Type**: Leave this as **REPLICA**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Number of tasks**: Enter 2.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Minimum healthy percent**: Leave at **100**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Maximum percent**: Leave at **200**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Leave the **Deployments** and **Task Placement** options at the defaults and
    click on the **Next step** button at the bottom of the page, which will take you
    to the **Configure network** page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Load balancer type**: Select **None**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Enable service discovery integration**: Untick this option.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on **Next step** and leave **Service Auto Scaling** on the default **Do
    not adjust the service's desired count** option, and then click on **Next Step**.
    After reviewing the options, click on the **Create Service** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we open our running container, we need to open the firewall rules. To
    do this, select `30000-60000`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0.0.0.0/0`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Container ports`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on the **Save Rules** button. This should leave you with something
    like the following:![Figure 10.6 – Updating the security group rules
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.06_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.6 – Updating the security group rules
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have set the rule, return to your ECS cluster, click on the **Tasks**
    tab, then select one of the two running tasks. Once the task overview place loads,
    scroll down to the container and extend the container listed in the table, and
    then click on the external link. This will take you straight to the running container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Our working application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.07_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Our working application
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have seen the running container, let's remove the cluster. To do
    this, go to the cluster overview page and click on the **Delete Cluster** button
    in the top-right corner – from there, follow the on-screen instructions.
  prefs: []
  type: TYPE_NORMAL
- en: Now that was the old way of launching containers sort-of nativity in AWS; I
    say sort of because we are still starting EC2 instances to power our cluster,
    and even though we used spot instances, we had a lot of unused resources that
    we would have been paying for – what if we could just launch containers and not
    have worry about managing a bunch of EC2 resources?
  prefs: []
  type: TYPE_NORMAL
- en: Amazon ECS – AWS Fargate backed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In November 2017, Amazon announced that they had been working on AWS Fargate
    – this is a service that is Amazon ECS-compatible and removes the need to launch
    and manage EC2 instances. Instead, your containers are launched on Amazon's backplane,
    and you get per-second billing, meaning you only pay for the vCPU and memory that
    your containerised application requests during its life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to cheat slightly and work through the Amazon ECS first-run process.
    You can access this by going to the following URL: https://console.aws.amazon.com/ecs/home?#/firstRun.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take us through the four steps we need to take to launch a container
    within a Fargate cluster. The first step in launching our AWS Fargate-hosted container
    is to configure the container and task definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: For our example, there are three predefined options and a custom option. Click
    on the `cluster-container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`russmckendrick/cluster:latest`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`80` and leave `tcp` selected.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, click on the `cluster-task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`awsvpc`; you can''t change this option.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`ecsTaskExecutionRole`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`FARGATE` and you should not be able to edit it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Task memory and Task CPU**: Leave both at their default options.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once everything's updated, click on the **Save** button. Now, you can click
    on the **Next** button at the bottom of the page. This will take us to the second
    step, which is where the service is defined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we discussed in the previous section, the service runs tasks, which in turn
    have a container associated with them. The default services are fine, so click
    on the **Next** button to proceed to the third step of the launch process. The
    first step is where the cluster is created. Again, the default values are fine,
    so click on the **Next** button to be taken to the review page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is your last chance to double-check the task, service, and cluster definitions
    before any services are launched. If you are happy with everything, click on the
    **Create** button. From here, you will be taken to a page where you can view the
    status of the various AWS services that make our AWS Fargate cluster:![Figure
    10.8 – Launching our Fargate cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.08_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.8 – Launching our Fargate cluster
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once everything has changed from **pending** to **complete**, you will be able
    to click on the **View service** button to be taken to the **Service** overview
    page:![Figure 10.9 – Looking at our Fargate cluster
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.09_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.9 – Looking at our Fargate cluster
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we need to know the public IP address of our container. To find this,
    click on the **Task** tab, and then select the unique ID of the running task.
    In the **Network** section of the page, you should be able to find both the private
    and public IP addresses of the tasks. Entering the public IP in your browser should
    bring up the now-familiar cluster application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.10 – Our working application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – Our working application
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the container name that''s displayed is the hostname of
    the container, and includes the internal IP address. You can also view the logs
    from the container by click on the **Logs** tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11 – Viewing the container logs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – Viewing the container logs
  prefs: []
  type: TYPE_NORMAL
- en: So, how much is this costing? To be able to run the container for an entire
    month would cost around $14, which works out at about $0.019 per hour.
  prefs: []
  type: TYPE_NORMAL
- en: This costing means that if you are going to be running a number of tasks 24/7,
    then Fargate may not be the most cost-effective way of running your containers.
    Instead, you may want to take the Amazon ECS EC2 option, where you can pack more
    containers onto your resource, or the Amazon EKS service, which we will look at
    later in this chapter. However, for quickly bringing up a container and then terminating
    it, Fargate is excellent—there is a low barrier to launching the containers and
    the number of supporting resources is small.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished with your Fargate container, you should delete the cluster.
    This will remove all of the services associated with the cluster. Once the cluster
    has been removed, go into the **Task Definitions** page and deregister them if
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section of the chapter, we have only touched on how Amazon ECS works;
    what we haven't covered is some of the close integration that an Amazon ECS-managed
    container has with other AWS services, such as **Elastic Load Balancing**, **Amazon
    Cloud Map**, and **AWS App Mesh**. Also, using the Amazon ECS command-line tool,
    you can launch your Docker Compose files into an Amazon ECS-managed cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our AWS basics in place, let's move on to one of its major
    competitors, Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft Azure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Microsoft Azure**, or Windows Azure as it started life as, is Microsoft''s
    entry into the public cloud. It offers a mixture of the **software as a service**
    (**SaaS**), **platform as a service** (**PaaS**), and **infrastructure as a service**
    (**IaaS**) services. It began life as an internal Microsoft project with the codename
    of *Project Red Dog* around 2005\. Project Red Dog was a continuation of the *Red
    Dog OS*, which was a fork of the Windows operating system, which was focused on
    delivering data center services using core Windows components.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The service that was publicly announced at the Microsoft Developer conference
    in 2008 was made up of five core services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows Azure: Allows users to spin up and manage compute instances, storage,
    and various networking services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft SQL Data Services**: A cloud version of the Microsoft SQL database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft .NET services**: Services that would allow you to deploy your .NET
    instance to the cloud without having to worry about instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft SharePoint and** **Microsoft Dynamics services**: These would be
    SaaS offerings of Microsoft''s intranet and CRM software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It launched in early 2010 to mixed reviews as some people thought it was limited
    compared to AWS, which by this time had been available for 4 years and was much
    more mature. However, Microsoft persevered, and over the last 10 years has added
    numerous services that have moved it way beyond its Windows roots. This promoted
    the name change from Windows Azure to Microsoft Azure in 2014.
  prefs: []
  type: TYPE_NORMAL
- en: Since then, Microsoft's cloud has quickly caught up feature-wise with AWS, and
    depending on which news source you read, is chosen by enterprises to run their
    cloud workloads thanks to its tight integration with other Microsoft services,
    such as **Microsoft Office** and **Microsoft 365**.
  prefs: []
  type: TYPE_NORMAL
- en: Azure web app for containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Microsoft Azure App Service is a fully managed platform that allows you to deploy
    your application and let Azure worry about managing the platform they are running
    on. There are several options available when launching an app service. You can
    run applications written in **.NET**, **.NET Core**, **Ruby**, **Node.js**, **PHP**,
    and **Python**, or you can launch an image directly from a container image registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this quick walkthrough, we are going to be launching the cluster image from
    the Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: Log in to the Azure portal at [https://portal.azure.com/](https://portal.azure.com/).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **App Services** from the left-hand menu, which can be accessed via the
    burger icon on the top left-hand corner of the screen:![Figure 10.12 – Preparing
    to launch an app service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.12 – Preparing to launch an app service
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: On the page that loads, click on the `Docker Container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Operating System**: Leave as **Linux**.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Region**: Select your preferred region.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**App Service plan**: By default, a more expensive production-ready plan is
    selected, so clicking **Change size** in the **Sku and size** section will give
    you options on changing the pricing tier. For our needs, the **Dev/Test** plan
    will be fine.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have selected and filled out the preceding options, click on the `Single
    container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Docker Hub` from the dropdown list. This will open up the Docker Hub options
    below the form.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`public`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`russmckendrick/cluster:latest`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Startup command**: Leave blank.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once that's all completed, click through the **Monitoring** and **Tag** tabs,
    and then click on the **Create** button after reviewing the information. After
    a minute or two, you should be presented with a screen that looks like the following:![Figure
    10.13 – Deploying the app service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.13_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.13 – Deploying the app service
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Clicking on the **Go to resource** button will take you to the newly launched
    application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.14 – Viewing our running app service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.14_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.14 – Viewing our running app service
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our application has launched, you should be able to access the service
    via the URL provided by Azure – for example, mine was [https://masteringdocker4thedition.azurewebsites.net](https://masteringdocker4thedition.azurewebsites.net).
    Opening this, your browser will display the cluster application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15 – Displaying the cluster application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.15_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.15 – Displaying the cluster application
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this time, we have the container ID, rather than a full hostname
    as we got when launching the container on AWS Fargate. The container at this spec
    will cost us around $10 per month.
  prefs: []
  type: TYPE_NORMAL
- en: There are some other really useful advantages to launching your container as
    an application, rather than just a plain old container – for example, you may
    have noticed that our container URL has an **SSL certificate** enabled. While
    it is currently one that covers [azurewebsites.net](http://azurewebsites.net),
    you can add your own custom domain and provide your own SSL certificate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another handy feature is that you can configure your single container to automatically
    update itself via a trigger from a webhook. For example, when your new container
    image has successfully been built, you can find this option on the **Container
    settings** page for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16 – Launching multiple containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.16_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.16 – Launching multiple containers
  prefs: []
  type: TYPE_NORMAL
- en: Also, as touched on when we first configured the application, you can use a
    Docker Compose file to launch multiple containers in your Microsoft Azure web
    app.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished with the web app, delete it and the resource group, assuming
    it doesn't contain any other resources you need.
  prefs: []
  type: TYPE_NORMAL
- en: Azure container instances
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have learned how to launch Docker containers in Azure using Azure
    web apps, let's now look at the Azure Container Instance service. Think of this
    as being similar in concept to the AWS Fargate service in that it allows you to
    launch containers directly on, in this case, Microsoft's shared backplane.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s configure a container instance:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter `Container instances` into the search bar at the top of the screen and
    then click on the link for the **Container Instances** service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the page loads, click on the `Public`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`russmckendrick/cluster:latest`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Linux`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`1GB`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have filled in the information, click on the `Yes`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`80` and **TCP** configured.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**DNS name label**: Enter a DNS name for your container.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Skip past the **Advance** and **Tags** sections and go straight to **Review
    + create**. Once the validation has passed, click on the **Create** button:![Figure
    10.17 – Launching our Azure container instance
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.17_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.17 – Launching our Azure container instance
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'As before, click on the **Go to resource** button and you will be taken to
    the newly created Azure container instance, as you can see in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.18 – An overview of our Azure container instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.18_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.18 – An overview of our Azure container instance
  prefs: []
  type: TYPE_NORMAL
- en: 'There are fewer options than we had in the web application, and that is because
    Azure container instances are designed to do just one thing: run containers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to click on `/bin/sh` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.19 – Opening a session to our Azure container instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.19_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.19 – Opening a session to our Azure container instance
  prefs: []
  type: TYPE_NORMAL
- en: 'Entering the URL given in the overview page into a browser, which in my case
    was [http://masteringdocker4thedition-aci.uksouth.azurecontainer.io/](http://masteringdocker4thedition-aci.uksouth.azurecontainer.io/),
    will show you your container app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.20 – Our running application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.20_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.20 – Our running application
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this time we have the container ID, which in my case was wk-caas-ca0c275b8f3e4ce2848c5802ee406a13-4e02f5281687aa1e58d98f.
    You might notice that there is no HTTPS this time, just plain old HTTP on port
    80\.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished with your Azure container instance, click on **Delete**,
    and also remove the resource group if required.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up Microsoft Azure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While on the face of it the two services we have looked at in this section appear
    to quite similar, they are in fact really very different. Microsoft web apps are
    a managed service offered by Microsoft that is powered by containers. Typically,
    the container that is launched is for the code that the end user launches. However,
    when running containers, they end up running Docker in Docker. Azure container
    instances are just that, your running container – no wrappers or helpers, only
    vanilla containers.
  prefs: []
  type: TYPE_NORMAL
- en: We know have a foundation in Microsoft Azure. With Amazon and Microsoft established
    in the game, it's no surprise that Google launched its own competitor product.
    Let's take a look at it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of the three major public clouds, **Google Cloud** is the newest. It started
    life as Google App Engine in 2008\. App Engine was Google's PaaS offering, which
    supported Java, PHP, Node.js, Python, C#, .Net, Ruby, and Go applications. Unlike
    AWS and Microsoft Azure, Google remained a PaaS service for over 4 years until
    it introduced Google Compute Engine.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to be learning a lot more about Google's journey into the cloud
    in the next chapter when we start to talk about Kubernetes, so I am not going
    to go into much more detail here. So, let's jump right in.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Run
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Google Cloud Run works slightly differently than the other container services
    we have looked at in this chapter. The first thing we need is to have an image
    hosted in Google Container Registry to use the service:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s grab a copy of our cluster image from Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to use the Google Cloud command-line tool to log in to our Google
    Cloud account. To do this, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once logged in, we can configure Docker to use Google Container Registry by
    running the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that Docker is configured to interact with Google Container Registry, we
    can run the following commands to create a tag and push our image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in the search bar at the top of the page, enter `Cloud Run` and follow
    the link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the Cloud Run page loads, click on the **Create Service** button at the
    top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first thing you need to do is choose which image to use. Click on **Select**
    and highlight the cluster image and then the version of the image you want to
    use:![Figure 10.22 – Selecting the Google Container Registry image
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/Figure_10.22_B15659.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 10.22 – Selecting the Google Container Registry image
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once selected, click on **CONTINUE**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the deployment platform, we are going to be using **Cloud Run (fully managed)**.
    Choose the closest region to you from the drop-down box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next up, we need to name the server – I called mine `masteringdocker4cluster`
    – and then tick the **Allow unauthenticated invocations** radio box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As our container listens on port `80`, we need to update the revision settings
    as the default is port `8080`. Clicking on `8080` to `80`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once everything is filled in, scroll to the bottom of the page and click on
    the **Create** button. After a short while, you should see something like the
    following screen:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.23 – Viewing our Cloud Run application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.23_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.23 – Viewing our Cloud Run application
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have information on our running container, including a URL,
    which in this case was [https://cluster-5iidnzldtq-ez.a.run.app](https://cluster-5iidnzldtq-ez.a.run.app)
    – opening the URL in a browser shows the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.24 – Our running application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.24_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.24 – Our running application
  prefs: []
  type: TYPE_NORMAL
- en: This is what we would have expected to have seen; however, there is a difference
    between how Google Cloud Run and the other services we covered in the AWS and
    Azure section of this chapter work. With the other service, our container was
    running all of the time, but with Google Cloud Run, it only runs when it is needed.
    Google Cloud Run is built on top of **Knative**, which is an open source serverless
    platform designed to run on top of a Kubernetes, and we have been running our
    containers on Google's own Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up Google Cloud
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you may have guessed, Google is more geared to running Kubernetes-based services,
    as we have already seen with Google Cloud Run. So, we will revisit Google Cloud
    in a later chapter once we have covered Kubernetes in a little more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at how we can deploy our Docker containers into
    services offered by the three leading public cloud providers using their container-only
    services. The services we looked at all approach both the deployment and management
    of containers in very different ways, from the fully managed Docker-based web
    app in Azure app services to AWS' own clustering service Amazon ECS.
  prefs: []
  type: TYPE_NORMAL
- en: The differences between all of these services are quite important as it means
    that if you want to use them, then you are tied to just the one cloud provider.
    While in most cases, that shouldn't be too much of a problem, it could in the
    long term end up limiting you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter (and in subsequent chapters), we will explore one of the
    most exciting services to arrive on the scene since Docker: Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of application do we need to launch in Azure?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Amazon service don't you have to manage if you're using Amazon Fargate
    directly?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Azure Container Instances comes with HTTPS support out of the
    box.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the open source service that Google Cloud Run is built on top of.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the services that we looked at support Docker Compose?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For details on each of the services we have used in this chapter, refer to
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'AWS: [http://aws.amazon.com/](http://aws.amazon.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon ECS: [https://aws.amazon.com/ecs/](https://aws.amazon.com/ecs/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'AWS Fargate: [https://aws.amazon.com/fargate/](https://aws.amazon.com/fargate/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Microsoft Azure: [https://azure.microsoft.com/](https://azure.microsoft.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure App Service: [https://azure.microsoft.com/en-gb/services/app-service/](https://azure.microsoft.com/en-gb/services/app-service/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure Container Instances: [https://azure.microsoft.com/en-gb/services/container-instances/](https://azure.microsoft.com/en-gb/services/container-instances/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Cloud: [https://cloud.google.com](https://cloud.google.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Google Cloud Run: [https://cloud.google.com/run](https://cloud.google.com/run)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Knative: [http://knative.dev](http://knative.dev)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
