- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The correct answers are **D** and **E**.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A Docker container is to IT what a shipping container is to the transportation
    industry. It defines a standard on how to package goods. In this case, goods are the
    application(s) developers write. The suppliers (in this case, the developers) are
    responsible for packaging the goods into the container and making sure everything
    fits as expected. Once the goods are packaged into a container, it can be shipped.
    Since it is a standard container, the shippers can standardize their means of
    transportation, such as lorries, trains, or ships. The shipper doesn't really care
    what's in a container. Also, the loading and unloading process from one transportation
    means to another (for example, train to ship) can be highly standardized. This
    massively increases the efficiency of transportation. Analogous to this is an
    operations engineer in IT, who can take a software container built by a developer
    and ship it to a production system and run it there in a highly standardized way,
    without worrying about what's in the container. It will just work.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Some of the reasons why containers are game changers are as follows:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Containers are self-contained and thus if they run on one system, they run anywhere
    that a container can run.
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers run on premises and in the cloud, as well as in hybrid environments.
    This is important for today's typical enterprises since it allows a smooth transition
    from on premises to the cloud.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Container images are built or packaged by the people who know best – the developers.
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Container images are immutable, which is important for good release management.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are enablers of a secure software supply chain based on encapsulation
    (using Linux namespaces and cgroups), secrets, content trust, and image vulnerability
    scanning.
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Any given container runs anywhere where containers can run for the following
    reasons:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Containers are self-contained black boxes. They encapsulate not only an application
    but all its dependencies, such as libraries and frameworks, configuration data,
    certificates, and so on.
  id: totrans-12
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are based on widely accepted standards such as OCI.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The answer is **B**. Containers are useful for modern applications as well as
    to containerize traditional applications. The benefits for an enterprise when
    doing the latter are huge. Cost savings in the maintenance of legacy apps of 50%
    or more have been reported. The time between new releases of such legacy applications
    could be reduced by up to 90%. These numbers have been publicly reported by real enterprise
    customers.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 50% or more.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Containers are based on Linux namespaces (network, process, user, and so on) and
    cgroups (control groups).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-machine` can be used for the following scenarios:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To create a VM on various providers such as VirtualBox, Hyper-V, AWS, MS Azure,
    or Google Compute Engine that will serve as a Docker Host.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To start, stop, or kill a previously generated VM.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To SSH into a local or remote Docker Host VM created with this tool.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To re-generate certificates for the secure use of a Docker Host VM.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: A. True. Yes, with Docker for Windows, you can develop and run Linux containers.
    It is also possible, but not discussed in this book, to develop and run native
    Windows containers with this edition of Docker for Desktop. With the macOS edition,
    you can only develop and run Linux containers.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scripts are used to automate processes and hence avoid human errors. Building,
    testing, sharing, and running Docker containers are tasks that should always be
    automated to increase their reliability and repeatability.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following Linux distros are certified to run Docker: RedHat Linux (RHEL),
    CentOS, Oracle Linux, Ubuntu, and more.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following Windows OS are certified to run Docker: Windows 10 Pro, Windows
    Server 2016, and Windows Server 2019'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'The possible states of a Docker container are as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`created`: A container that has been created but not started'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restarting`: A container that is in the process of being restarted'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`running`: A currently running container'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paused`: A container whose processes have been paused'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exited`: A container that ran and completed'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dead`: A container that the Docker engine tried and failed to stop'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We can use `docker container ls` (or the old, shorter version, `docker ps`)
    to list all containers that are currently running on our Docker host. Note that
    this will NOT list the stopped containers, for which you need the extra parameter`--all` (or `-a`).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To list all IDs of containers, running or stopped, we can use `docker container
    ls -a -q`, where `-q` stands for output ID only.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Dockerfile` could look like this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that in Ubuntu, the `ping` tool is part of the `iputils-ping` package.
    Build the image called `pinger`—for example— with `docker image build -t my-pinger`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '2\. The `Dockerfile` could look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build the image with `docker image build -t my-alpine:1.0`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '3\. The `Dockerfile` for a Go application could look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find the full solution in the `~/fod/ch04/answer03` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '4\. A Docker image has the following characteristics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: 1\. It is immutable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 2\. It consists of one-to-many layers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 3\. It contains the files and folders needed for the packaged application to
    run.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 5\. **C.** First, you need to log in to Docker Hub; then, tag your image correctly
    with the username; and finally, push the image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 5
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to play with volumes is to use the Docker Toolbox because when
    directly using Docker for Desktop, the volumes are stored inside a (somewhat hidden)
    Linux VM that Docker for Desktop uses transparently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, we suggest the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now that you''re inside a Linux VM called `volume-test`, you can do the following
    exercise:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a named volume, run the following command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the path on the host for the volume, use this command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This (if you''re using `docker-machine` and VirtualBox) should result in this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now execute the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In another terminal, execute this command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Execute a command such as this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Exit both containers and then, back on the host, execute this command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The answer is B. Each container is a sandbox and thus has its very own environment.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Collect all environment variables and their respective values in a configuration
    file, which you then provide to the container with the `--env-file` command-line
    parameter in the `docker run` command, like so:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Chapter 6
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Possible answers: a) Volume mount your source code in the container; b) use
    a tool that automatically restarts the app running inside the container when code
    changes are detected; c) configure your container for remote debugging.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can mount the folder containing the source code on your host in the container.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you cannot cover certain scenarios easily with unit or integration tests
    and if the observed behavior of the application cannot be reproduced when the
    application runs on the host. Another scenario is a situation where you cannot
    run the application on the host directly due to the lack of the necessary language
    or framework.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the application is running in production, we cannot easily gain access
    to it as developers. If the application shows unexpected behavior or even crashes,
    logs are often the only source of information we have to help us reproduce the
    situation and pinpoint the root cause of the bug.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: 'Pros and cons:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pro: We don''t need to have the particular shell, tool, or language required
    by the task installed on our host.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: We can run on any Docker host, from Raspberry Pi to a mainframe computer;
    the only requirement is that the host can run containers.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pro: After a successful run, the tool is removed without leaving any traces
    from the host when the container is removed.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Con: We need to have Docker installed on the host.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Con: The user needs to have a basic understanding of Docker containers.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Con: Use of the tool is a bit more indirect than when using it natively.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Running tests in a container has the following advantages:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They run equally well on a developer machine than on a test or CI system.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easier to start each test run with the same initial conditions.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: All developers working with the code use the same setup, for example, versions
    of libraries and frameworks.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有开发人员使用相同的环境设置，例如库和框架的版本。
- en: Here, we expect a diagram that shows a developer writing code and checking it
    in, for example, GitHub. We then want to see an automation server such as Jenkins
    or TeamCity in the picture that is either periodically polling GitHub for changes
    or the GitHub triggers the automation server (with an HTTP callback) to create
    a new build. The diagram should also show that the automation server then runs
    all tests against the built artifacts and, if they all succeed, deploys the application
    or service to an integration system where it is again tested, for example, with
    a few smoke tests. Once again, if those tests succeed, the automation server should
    either ask a human for approval to deploy to production (this equals to continuous
    delivery) or the automation server should automatically deploy to production (continuous
    deployment).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们期望看到一个图示，展示一个开发人员写代码并提交代码，例如到 GitHub。然后我们希望看到一个自动化服务器，如 Jenkins 或 TeamCity，图中显示它定期轮询
    GitHub 是否有更新，或者是 GitHub 触发自动化服务器（通过 HTTP 回调）创建新的构建。图中还应显示自动化服务器运行所有测试，以验证构建的产物，如果所有测试通过，自动将应用程序或服务部署到集成系统中，在那里再次进行测试，例如进行一些冒烟测试。再次，如果这些测试通过，自动化服务器应该要求人工批准是否将其部署到生产环境中（这等同于持续交付），或者自动化服务器应自动将其部署到生产环境中（持续部署）。
- en: Chapter 8
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章提出问题的一些示例答案：
- en: You could be working on a workstation with limited resources or capabilities,
    or your workstation could be locked down by your company so that you are not allowed
    to install any software that is not officially approved. Sometimes, you might
    need to do proof of concepts or experiments using languages or frameworks that
    are not yet approved by your company (but might be in the future if the proof
    of concept is successful).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能在一个资源或功能有限的工作站上工作，或者你的工作站可能被公司锁定，禁止安装任何未获官方批准的软件。有时，你可能需要使用公司尚未批准的语言或框架进行概念验证或实验（但如果概念验证成功，未来可能会被批准）。
- en: Bind-mounting a Docker socket into a container is the recommended method when
    a containerized application needs to automate some container-related tasks. This
    can be an application such as an automation server such as Jenkins that you are
    using to build, test, and deploy Docker images.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器化应用程序需要自动化某些与容器相关的任务时，将 Docker 套接字绑定到容器中是推荐的方式。这可以是像 Jenkins 这样的自动化服务器应用程序，通常用于构建、测试和部署
    Docker 镜像。
- en: Most business applications do not need root-level authorizations to do their
    job. From a security perspective, it is hence strongly recommended to run such
    applications with the least necessary access rights to their job. Any unnecessary
    elevated privileges could possibly be exploited by hackers in a malicious attack.
    By running the application as a non-root user, you make it more difficult for
    potential hackers to compromise your system.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数商业应用程序在执行任务时不需要根级别的授权。从安全角度来看，因此强烈建议以最小权限运行此类应用程序，确保它们仅拥有完成任务所需的最低权限。任何不必要的提升权限可能会被黑客在恶意攻击中利用。通过以非
    root 用户身份运行应用程序，你可以使潜在的黑客更难以入侵系统。
- en: Volumes contain data and the lifespan of data most often needs to go far beyond
    the life cycle of a container or an application, for that matter. Data is often
    mission-critical and needs to be stored safely for days, months, even years. When
    you delete a volume, you irreversibly delete the data associated with it. Hence,
    make sure you know what you're doing when deleting a volume.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卷包含数据，而数据的生命周期通常需要远远超过容器或应用程序的生命周期。数据通常是任务关键的，需要安全存储数天、数月，甚至数年。当你删除一个卷时，你会不可逆地删除与其相关的数据。因此，删除卷时一定要确认你知道自己在做什么。
- en: Chapter 9
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章提出问题的一些示例答案：
- en: In a distributed application architecture, every piece of the software and infrastructure
    needs to be redundant in a production environment, where the continuous uptime
    of the application is mission-critical. A highly distributed application consists
    of many parts and the likelihood of one of the pieces failing or misbehaving increases
    with the number of parts. It is guaranteed that, given enough time, every part
    will eventually fail. To avoid outages of the application, we need redundancy
    in every part, be it a server, a network switch, or a service running on a cluster
    node in a container.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分布式应用架构中，软件和基础设施的每一部分都需要在生产环境中具有冗余，以确保应用程序的持续运行时间是至关重要的。高度分布式的应用由多个部分组成，随着部分数量的增加，某个部分发生故障或异常行为的可能性也在增加。可以保证，给定足够的时间，每个部分最终都会失败。为了避免应用程序的停机，我们需要对每个部分进行冗余，无论是服务器、网络交换机，还是在容器中集群节点上运行的服务。
- en: In highly distributed, scalable, and fault-tolerant systems, individual services
    of the application can move around due to scaling needs or due to component failures.
    Thus, we cannot hardwire different services with each other. Service A, which
    needs access to Service B, should not have to know details such as the IP address
    of Service B. It should rely on an external provider of this information. DNS
    is such a provider of location information. Service A just tells it that it wants
    to talk to Service B and the DNS service will figure out the details.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在高度分布式、可扩展和容错的系统中，应用程序的单个服务可能会由于扩展需求或组件故障而发生变化。因此，我们不能将不同的服务硬编码在一起。服务A需要访问服务B时，不应该知道服务B的IP地址等细节。它应该依赖于外部提供者来获取这些信息。DNS就是这种位置服务提供者。服务A只需要告诉它要与服务B通信，DNS服务将会处理具体的细节。
- en: A circuit breaker is a means to avoid cascading failures if a component in a
    distributed application is failing or misbehaving. Similar to a circuit breaker
    in electric wiring, a software-driven circuit breaker cuts the communication between
    a client and a failed service. The circuit breaker will directly report an error
    back to the client component if the failed service is called. This gives the system
    the opportunity to recover or heal from failure.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 熔断器是一种避免级联故障的机制，适用于分布式应用中出现故障或异常行为的组件。类似于电路中的熔断器，软件驱动的熔断器切断客户端与故障服务之间的通信。如果调用的服务发生故障，熔断器将直接将错误报告给客户端组件。这为系统提供了从故障中恢复或修复的机会。
- en: A monolithic application is easier to manage that a multi-service application
    since it consists of a single deployment package. On the other hand, a monolith
    is harder to scale to account for increased demand. In a distributed application,
    each service can be scaled individually and each service can run on optimized
    infrastructure, while a monolith needs to run on infrastructure that is OK for
    all or most of the features implemented in it. Maintaining and updating a monolith
    is much harder than a multi-service application, where each service can be updated
    and deployed independently. The monolith is often a big, complex, and tightly
    coupled pile of code. Minor modifications can have unexpected side effects. (Micro-)
    Services, on the other hand, are self-contained, simple components that behave
    like black boxes. Dependent services know nothing about the inner workings of
    the service and thus do not depend on it.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用比多服务应用更容易管理，因为它由一个单一的部署包组成。另一方面，单体应用更难以扩展以应对需求的增加。在分布式应用中，每个服务可以单独扩展，并且每个服务可以运行在优化的基础设施上，而单体应用则需要在能够支持所有或大部分功能的基础设施上运行。维护和更新单体应用比多服务应用困难得多，后者每个服务都可以独立更新和部署。单体应用通常是一个庞大、复杂且紧密耦合的代码堆栈。即使是小的修改也可能会带来意想不到的副作用。而（微）服务则是自包含、简单的组件，像黑盒一样工作。依赖的服务对服务的内部工作一无所知，因此也不依赖于它。
- en: A blue-green deployment is a form of software deployment that allows for zero
    downtime deployments of new versions of an application or an application service.
    If, say, Service A needs to be updated with a new version, then we call the currently
    running version blue. The new version of the service is deployed into production,
    but not yet wired up with the rest of the application. This new version is called
    green. Once the deployment succeeds and smoke tests have shown it's ready to go,
    the router that funnels traffic to blue is reconfigured to switch to green. The
    behavior of green is observed for a while and if everything is OK, blue is decommissioned.
    On the other hand, if green causes difficulties, the router can simply be switched
    back to blue and green can be fixed and later redeployed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝绿部署是一种软件部署方式，允许在零停机时间的情况下部署应用或应用服务的新版本。例如，如果服务A需要更新到新版本，那么当前运行的版本被称为蓝色。新版本的服务被部署到生产环境中，但尚未与其余应用连接。这个新版本被称为绿色。一旦部署成功并且冒烟测试表明它准备就绪，路由器会被重新配置，将流量从蓝色切换到绿色。观察绿色的表现一段时间，如果一切正常，蓝色将被停用。另一方面，如果绿色出现问题，路由器可以简单地切换回蓝色，绿色可以修复并重新部署。
- en: Chapter 10
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的部分示例答案：
- en: The three core elements are **sandbox**, **endpoint**, and **network**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个核心元素是**沙盒**、**端点**和**网络**。
- en: 'Execute this command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run this command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Test that both NGINX instances are up and running:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试两个NGINX实例是否都在运行：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should be seeing the welcome page of NGINX in both cases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都应该看到NGINX的欢迎页面。
- en: 'To get the IPs of all attached containers, run this command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取所有附加容器的IP地址，请运行此命令：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see something similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的内容：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To get the subnet used by the network, use the following (for example):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取网络使用的子网，请使用以下命令（例如）：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should receive something along the lines of the following (obtained from
    the previous example):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到类似以下的内容（来自前面的示例）：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `host` network allows us to run a container in the networking namespace
    of the host.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`host`网络允许我们在主机的网络命名空间中运行容器。'
- en: Only use this network for debugging purposes or when building a system-level tool.
    Never use the `host` network for an application container running a production
    environment!
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在调试目的或构建系统级工具时使用此网络。切勿将`host`网络用于运行生产环境的应用容器！
- en: The `none` network is basically saying that the container is not attached to
    any network. It should be used for containers that do not need to communicate
    with other containers and do not need to be accessed from outside.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`none`网络基本上是指容器未连接到任何网络。它应仅用于不需要与其他容器通信且不需要从外部访问的容器。'
- en: The `none` network could, for example, be used for a batch process running in
    a container that only needs access to local resources such as files that could
    be accessed via a host mounted volume.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，`none`网络可用于运行批处理进程的容器，这些进程仅需要访问本地资源，例如通过主机挂载卷访问的文件。
- en: Traefik can be used to provide Layer 7 or application-level routing. This is
    especially useful if you want to break out functionality from a monolith with
    a well-defined API. In this case, you have a need to reroute certain HTTP calls
    to the new container/service. This is just one of the possible usage scenarios,
    but it's also the most important one. Another one could be to use Traefik as a
    load balancer.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Traefik可用于提供第7层或应用层路由。如果你想将某个功能从单体应用中拆分并且有明确的API定义，这将特别有用。在这种情况下，你需要将某些HTTP调用重新路由到新容器/服务。这只是可能的使用场景之一，但也是最重要的一个。另一个场景是将Traefik用作负载均衡器。
- en: Chapter 11
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的部分示例答案：
- en: 'The following code can be used to run the application in detached or daemon
    mode:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码可用于以分离模式或守护进程模式运行应用：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Execute the following command to display the details of the running service:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以显示运行中的服务的详细信息：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should result in the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生如下输出：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following command can be used to scale up the web service:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令可用于扩展Web服务：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Chapter 12
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的部分示例答案：
- en: A mission-critical, highly available application that is implemented as a highly
    distributed system of interconnected application services that are just too complex
    to manually monitor, operate, and manage. Container orchestrators help in this
    regard. They automate most of the typical tasks, such as reconciling a desired
    state, or collecting and aggregating key metrics of the system. Humans cannot
    react quick enough to make such an application elastic or self-healing. Software
    support is needed for this in the form of the mentioned container orchestrators.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A container orchestrator frees us from mundane and cumbersome tasks such as
    the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scaling services up and down
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing requests
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing requests to the desired target
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the health of service instances
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing a distributed application
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The winner in this space is Kubernetes, which is open sourced and owned by the
    CNCF. It was originally developed by Google. We also have Docker Swarm, which
    is proprietary and has been developed by Docker. AWS offers a container service
    called ECS, which is also proprietary and tightly integrated into the AWS ecosystem.
    Finally, Microsoft offers AKS, which has the same pros and cons as AWS ECS.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct answer is as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `--advertise-addr` is optional and is only needed if you the host have more than
    one IP address.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'On the worker node that you want to remove, execute the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On one of the master nodes, execute the command `$ docker node rm -f<node ID>`,
    where <`node ID>` is the ID of the worker node to remove.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'The correct answer is as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The correct answer is as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The correct answer is as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Chapter 14
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: Zero-downtime deployment means that a new version of a service in a distributed
    application is updated to a new version without the application needing to stop
    working. Usually, with Docker SwarmKit or Kubernetes (as we will see), this is
    done in a rolling fashion. A service consists of multiple instances and those
    are updated in batches so that the majority of the instances are up and running
    at all times.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, Docker SwarmKit uses a rolling updated strategy to achieve zero-downtime
    deployments.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Containers are self-contained units of deployment. If a new version of a service
    is deployed and does not work as expected, we (or the system) need to only roll
    back to the previous version. The previous version of the service is also deployed
    in the form of self-contained containers. Conceptually, there is no difference
    in rolling forward (update) or backward (rollback). One version of a container
    is replaced by another one. The host itself is not affected by such changes in
    any way.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker secrets are encrypted at rest. They are only transferred to the services
    and containers that use the secrets. Secrets are transferred encrypted due to
    the fact that the communication between swarm nodes uses mutual TLS. Secrets are
    never physically stored on a worker node.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The command to achieve this is as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '6\. First, we need to remove the old secret from the service, and then we need
    to add the new version to it (directly updating a secret is not possible):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Chapter 15
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes master is responsible for managing the cluster. All requests
    to create objects, reschedule pods, manage ReplicaSets, and more happen on the
    master. The master does not run the application workload in a production or production-like
    cluster.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On each worker node, we have the kubelet, the proxy, and container runtime.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The answer is A. **Yes**. You cannot run standalone containers on a Kubernetes
    cluster. Pods are the atomic units of deployment in such a cluster.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All containers running inside a pod share the same Linux kernel network namespace.
    Thus, all processes running inside those containers can communicate with each
    other through `localhost` in a similar way to how processes or applications directly
    running on the host can communicate with each other through `localhost`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `pause` container's sole role is to reserve the namespaces of the pod for
    containers that run in it.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is a bad idea since all containers of a pod are co-located, which means
    they run on the same cluster node. Also, if multiple containers run in the same
    pod, they can only be scaled up or down all at once. However, the different components
    of the application (that is, `web`, `inventory`, and `db`) usually have very different
    requirements with regard to scalability or resource consumption. The `web` component
    might need to be scaled up and down depending on the traffic and the `db` component,
    in turn, has special requirements regarding storage that the others don't have.
    If we do run every component in its own pod, we are much more flexible in this
    regard.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a mechanism in order to run multiple instances of a pod in a cluster
    and make sure that the actual number of pods running always corresponds to the
    desired number, even when individual pods crash or disappear due to network partition or
    cluster node failures. The ReplicaSet is the mechanism that provides scalability
    and self-healing to any application service.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need deployment objects whenever we want to update an application service in
    a Kubernetes cluster without causing downtime to the service. Deployment objects
    add rolling updates and rollback capabilities to ReplicaSets.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kubernetes service objects are used to make application services participate
    in service discovery. They provide a stable endpoint to a set of pods (normally
    governed by a ReplicaSet or a deployment). Kube services are abstractions that define
    a logical set of pods and a policy regarding how to access them. There are four types
    of Kube service:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**ClusterIP**: Exposes the service on an IP address that''s only accessible
    from inside the cluster; this is a virtual IP (VIP).'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NodePort**: Publishes a port in the range 30,000–32,767 on every cluster node.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LoadBalancer**: This type exposes the application service externally using
    a cloud provider''s load balancer, such as ELB on AWS.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ExternalName**: Used when you need to define a proxy for a cluster''s external
    service such as a database.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter 16
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming we have a Docker image in a registry for the two application services, the
    web API and Mongo DB, we then need to do the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Define a deployment for Mongo DB using a StatefulSet; let's call this deployment `db-deployment`.
    The StatefulSet should have one replica (replicating Mongo DB is a bit more involved
    and is outside the scope of this book).
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a Kubernetes service called `db` of the `ClusterIP` type for `db-deployment`.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a deployment for the web API; let's call it `web-deployment`. Let's scale
    this service to three instances.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Define a Kubernetes service called `api` of the `NodePort` type for `web-deployment`.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If we use secrets, then define those secrets directly in the cluster using kubectl.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the application using kubectl.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: To implement layer 7 routing for an application, we ideally use an IngressController.
    The IngressController is a reverse proxy such as Nginx that has a sidecar listening
    on the Kubernetes Server API for relevant changes and updating the reverse proxy's
    configuration and restarting it if such a change has been detected. Then, we need
    to define Ingress resources in the cluster that define the routing, for example,
    from a context-based route such as `https://example.com/pets to <a service name>/<port>` or
    a pair such as `api/32001`. The moment Kubernetes creates or changes this Ingress
    object, the IngressController's sidecar picks it up and updates the proxy's routing configuration.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Assuming this is a cluster internal inventory service, then we do the following:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When deploying version 1.0, we define a deployment called `inventory-deployment-blue` and
    label the pods with a label of `color: blue`.'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We deploy the Kubernetes service of the `ClusterIP` type called inventory for
    the preceding deployment with the selector containing `color: blue`.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we''re ready to deploy the new version of the payments service, we define
    a deployment for version 2.0 of the service and call it `inventory-deployment-green`.
    We add a label of `color: green` to the pods.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can now smoke test the "green" service and when everything is OK, we can
    update the inventory service so that the selector contains `color: green`.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Some forms of information that are confidential and thus should be provided
    to services through Kubernetes secrets include passwords, certificates, API key
    IDs, API key secrets, and tokens.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sources for secret values can be files or base64-encoded values.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 17
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: We cannot do any live debugging on a production system for performance and security
    reasons. This includes interactive or remote debugging. Yet application services
    can show unexpected behavior to code defects or other infrastructure-related issues
    such as network glitches or external services that are not available. To quickly
    pinpoint the reason for the misbehavior or failure of a service, we need as much
    logging information as possible. This information should give us a clue about,
    and guide us to, the root cause of the error. When we instrument a service, we
    do exactly this — we produce as much information as reasonable in the form of
    log entries and published metrics.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prometheus is a service that is used to collect functional or non-functional
    metrics that are provided by other infrastructure services and most importantly
    by application services. Since Prometheus itself is pulling those metrics periodically
    from all configured services, the services themselves do not have to worry about
    sending data. Prometheus also defines the format in which the metrics are to be
    presented by the producers.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To instrument a Node.js-based application service we need to do the following
    four steps:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Prometheus adapter to the project. The maintainers of Prometheus recommend
    the library called `siimon/prom-client`.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the Prometheus client during startup of the application. This includes
    the definition of a metrics registry.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose an HTTP GET endpoint/metrics where we return the collection of metrics
    defined in the metrics registry.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we define custom metrics of the `counter`, `gauge`, or `histogram` type,
    and use them in our code; for example, we increase a metric of the `counter` type
    each time a certain endpoint is called.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Normally in production, a Kubernetes cluster node only contains a minimal OS
    to keep its attack surface as limited as possible and to not waste precious resources.
    Thus we cannot assume that the tools typically used to troubleshoot applications
    or processes are available on the respective host. A powerful and recommended
    way to troubleshoot is to run a special tools or troubleshoot container as part
    of an ad hoc pod. This container can then be used as a bastion from which we can
    investigate network and other issues with the troubled service. A container that
    has been successfully used by many Docker field engineers at their customers site is `netshoot`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 18
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: 'To install UCP in AWS, we do the following:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a VPC with subnets and an SG.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, provision a cluster of Linux VMs, possibly as part of an ASG. Many Linux
    distributions are supported, such as CentOS, RHEL, and Ubuntu.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, install Docker on each VM.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, select one VM on which to install UCP using the `docker/ucp` image.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Once UCP is installed, join the other VMs to the cluster either as worker nodes
    or manager nodes.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are a few reasons to consider a hosted Kubernetes offering:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You do not want to, or do not have the resources to, install and manage a Kubernetes
    cluster.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You want to concentrate on what brings value to your business, which in most
    cases is the applications that are supposed to run on Kubernetes and not Kubernetes
    itself.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You prefer a cost model where you pay only for what you need.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The nodes of your Kubernetes cluster are automatically patched and updated.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrading the version of Kubernetes with zero downtime is easy and straightforward.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two main reasons to host container images on the cloud provider''s container
    registry (such as ACR on Microsoft Azure) are these:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The images are geographically close to your Kubernetes cluster and thus the
    latency and transfer network costs are minimal.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Production or production-like clusters are ideally sealed from the internet,
    and thus the Kubernetes cluster nodes cannot access Docker Hub directly.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
