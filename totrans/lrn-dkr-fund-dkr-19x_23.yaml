- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第一章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的一些示例答案：
- en: The correct answers are **D** and **E**.
  id: totrans-3
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案是**D**和**E**。
- en: A Docker container is to IT what a shipping container is to the transportation
    industry. It defines a standard on how to package goods. In this case, goods are the
    application(s) developers write. The suppliers (in this case, the developers) are
    responsible for packaging the goods into the container and making sure everything
    fits as expected. Once the goods are packaged into a container, it can be shipped.
    Since it is a standard container, the shippers can standardize their means of
    transportation, such as lorries, trains, or ships. The shipper doesn't really care
    what's in a container. Also, the loading and unloading process from one transportation
    means to another (for example, train to ship) can be highly standardized. This
    massively increases the efficiency of transportation. Analogous to this is an
    operations engineer in IT, who can take a software container built by a developer
    and ship it to a production system and run it there in a highly standardized way,
    without worrying about what's in the container. It will just work.
  id: totrans-4
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker容器对IT的意义就像运输行业中的集装箱对运输业的意义一样。它定义了如何打包货物的标准。在这里，货物就是开发人员编写的应用程序。供应商（在这种情况下是开发人员）负责将货物打包进容器并确保一切按预期装配好。一旦货物被打包进容器，它就可以被运输。由于这是标准集装箱，运输商可以标准化他们的运输方式，如卡车、火车或船只。运输商并不关心容器里装的是什么。此外，从一种运输方式到另一种运输方式（例如从火车到船）的装卸过程可以高度标准化。这极大提高了运输效率。与此类似，IT中的运维工程师可以将开发人员构建的软件容器运送到生产系统并在那儿以高度标准化的方式运行，而无需担心容器中装的是什么。它将按预期工作。
- en: 'Some of the reasons why containers are game changers are as follows:'
  id: totrans-5
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器之所以能改变游戏规则的原因如下：
- en: Containers are self-contained and thus if they run on one system, they run anywhere
    that a container can run.
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是自包含的，因此如果它们在一个系统上运行，它们就能在任何能运行容器的地方运行。
- en: Containers run on premises and in the cloud, as well as in hybrid environments.
    This is important for today's typical enterprises since it allows a smooth transition
    from on premises to the cloud.
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器可以在本地和云端运行，也可以在混合环境中运行。这对今天的典型企业非常重要，因为它允许从本地环境到云端的平滑过渡。
- en: Container images are built or packaged by the people who know best – the developers.
  id: totrans-8
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像由最了解的人——开发人员来构建或打包。
- en: Container images are immutable, which is important for good release management.
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器镜像是不可变的，这对于良好的发布管理非常重要。
- en: Containers are enablers of a secure software supply chain based on encapsulation
    (using Linux namespaces and cgroups), secrets, content trust, and image vulnerability
    scanning.
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是基于封装（使用Linux命名空间和cgroups）、机密、内容信任和镜像漏洞扫描的安全软件供应链的推动者。
- en: 'Any given container runs anywhere where containers can run for the following
    reasons:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任何给定的容器可以在任何容器可以运行的地方运行，原因如下：
- en: Containers are self-contained black boxes. They encapsulate not only an application
    but all its dependencies, such as libraries and frameworks, configuration data,
    certificates, and so on.
  id: totrans-12
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器是自包含的黑盒子。它们不仅封装了一个应用程序，还封装了它的所有依赖项，如库、框架、配置数据、证书等。
- en: Containers are based on widely accepted standards such as OCI.
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器基于广泛接受的标准，如OCI。
- en: The answer is **B**. Containers are useful for modern applications as well as
    to containerize traditional applications. The benefits for an enterprise when
    doing the latter are huge. Cost savings in the maintenance of legacy apps of 50%
    or more have been reported. The time between new releases of such legacy applications
    could be reduced by up to 90%. These numbers have been publicly reported by real enterprise
    customers.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是**B**。容器对现代应用程序以及将传统应用程序容器化都非常有用。企业在进行后者时能获得巨大的收益。据报道，维护传统应用程序的成本可以节省50%以上。此类传统应用程序的新版本发布之间的时间可减少多达90%。这些数据已由实际企业客户公开报告。
- en: 50% or more.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 50%以上。
- en: Containers are based on Linux namespaces (network, process, user, and so on) and
    cgroups (control groups).
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器基于Linux命名空间（网络、进程、用户等）和cgroups（控制组）。
- en: Chapter 2
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的一些示例答案：
- en: '`docker-machine` can be used for the following scenarios:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker-machine`可以用于以下场景：'
- en: To create a VM on various providers such as VirtualBox, Hyper-V, AWS, MS Azure,
    or Google Compute Engine that will serve as a Docker Host.
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多个提供商（如 VirtualBox、Hyper-V、AWS、MS Azure 或 Google Compute Engine）上创建一个虚拟机，该虚拟机将作为
    Docker 主机。
- en: To start, stop, or kill a previously generated VM.
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动、停止或终止先前生成的虚拟机。
- en: To SSH into a local or remote Docker Host VM created with this tool.
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用这个工具创建的本地或远程 Docker 主机虚拟机中使用 SSH。
- en: To re-generate certificates for the secure use of a Docker Host VM.
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新生成用于安全使用 Docker 主机虚拟机的证书。
- en: A. True. Yes, with Docker for Windows, you can develop and run Linux containers.
    It is also possible, but not discussed in this book, to develop and run native
    Windows containers with this edition of Docker for Desktop. With the macOS edition,
    you can only develop and run Linux containers.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: A. 正确。是的，使用 Docker for Windows，您可以开发并运行 Linux 容器。使用本书未讨论的此版本的 Docker for Desktop，您也可以开发并运行原生
    Windows 容器。对于 macOS 版本，您只能开发和运行 Linux 容器。
- en: Scripts are used to automate processes and hence avoid human errors. Building,
    testing, sharing, and running Docker containers are tasks that should always be
    automated to increase their reliability and repeatability.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本用于自动化过程，从而避免人为错误。构建、测试、共享和运行 Docker 容器是应该始终自动化的任务，以提高其可靠性和可重复性。
- en: 'The following Linux distros are certified to run Docker: RedHat Linux (RHEL),
    CentOS, Oracle Linux, Ubuntu, and more.'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 Linux 发行版已通过认证，可以运行 Docker：RedHat Linux (RHEL)、CentOS、Oracle Linux、Ubuntu
    等。
- en: 'The following Windows OS are certified to run Docker: Windows 10 Pro, Windows
    Server 2016, and Windows Server 2019'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下 Windows 操作系统已通过认证，可以运行 Docker：Windows 10 专业版、Windows Server 2016 和 Windows
    Server 2019。
- en: Chapter 3
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出问题的一些示例答案：
- en: 'The possible states of a Docker container are as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 容器的可能状态如下：
- en: '`created`: A container that has been created but not started'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`created`：一个已创建但未启动的容器'
- en: '`restarting`: A container that is in the process of being restarted'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restarting`：一个正在重启过程中的容器'
- en: '`running`: A currently running container'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`running`：一个当前正在运行的容器'
- en: '`paused`: A container whose processes have been paused'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`paused`：一个其进程已被暂停的容器'
- en: '`exited`: A container that ran and completed'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exited`：一个已运行并完成的容器'
- en: '`dead`: A container that the Docker engine tried and failed to stop'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dead`：一个 Docker 引擎尝试但未能停止的容器'
- en: We can use `docker container ls` (or the old, shorter version, `docker ps`)
    to list all containers that are currently running on our Docker host. Note that
    this will NOT list the stopped containers, for which you need the extra parameter`--all` (or `-a`).
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker container ls`（或者旧的、简短的版本 `docker ps`）列出当前在 Docker 主机上运行的所有容器。请注意，这不会列出已停止的容器，若要查看这些容器需要使用额外的参数
    `--all`（或 `-a`）。
- en: To list all IDs of containers, running or stopped, we can use `docker container
    ls -a -q`, where `-q` stands for output ID only.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要列出所有容器的 ID，无论是运行中的还是已停止的，我们可以使用 `docker container ls -a -q`，其中 `-q` 表示仅输出容器
    ID。
- en: Chapter 4
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出问题的一些示例答案：
- en: 'The `Dockerfile` could look like this:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Dockerfile` 可能如下所示：'
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note that in Ubuntu, the `ping` tool is part of the `iputils-ping` package.
    Build the image called `pinger`—for example— with `docker image build -t my-pinger`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在 Ubuntu 中，`ping` 工具是 `iputils-ping` 包的一部分。使用 `docker image build -t my-pinger`
    构建名为 `pinger` 的镜像——例如。
- en: '2\. The `Dockerfile` could look like this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 2. `Dockerfile` 可能如下所示：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Build the image with `docker image build -t my-alpine:1.0`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `docker image build -t my-alpine:1.0` 构建镜像。
- en: '3\. The `Dockerfile` for a Go application could look like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 一个 Go 应用的 `Dockerfile` 可能如下所示：
- en: '[PRE2]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You can find the full solution in the `~/fod/ch04/answer03` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 `~/fod/ch04/answer03` 文件夹中找到完整的解决方案。
- en: '4\. A Docker image has the following characteristics:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 一个 Docker 镜像具有以下特点：
- en: 1\. It is immutable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 1. 它是不可变的。
- en: 2\. It consists of one-to-many layers.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 2. 它由一到多个层组成。
- en: 3\. It contains the files and folders needed for the packaged application to
    run.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 3. 它包含了运行打包应用所需的文件和文件夹。
- en: 5\. **C.** First, you need to log in to Docker Hub; then, tag your image correctly
    with the username; and finally, push the image.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 5. **C.** 首先，您需要登录 Docker Hub；然后，使用用户名正确标记您的镜像；最后，推送镜像。
- en: Chapter 5
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第五章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出问题的一些示例答案：
- en: The easiest way to play with volumes is to use the Docker Toolbox because when
    directly using Docker for Desktop, the volumes are stored inside a (somewhat hidden)
    Linux VM that Docker for Desktop uses transparently.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 玩转卷的最简单方法是使用 Docker Toolbox，因为在直接使用 Docker for Desktop 时，卷被存储在 Docker for Desktop
    透明使用的（稍微隐蔽的）Linux 虚拟机中。
- en: 'Thus, we suggest the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们建议执行以下操作：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And now that you''re inside a Linux VM called `volume-test`, you can do the following
    exercise:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经进入名为 `volume-test` 的 Linux 虚拟机，你可以进行以下练习：
- en: 'To create a named volume, run the following command:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个命名卷，请执行以下命令：
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Execute the following command:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE5]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To get the path on the host for the volume, use this command:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取主机上卷的路径，请使用以下命令：
- en: '[PRE6]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This (if you''re using `docker-machine` and VirtualBox) should result in this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这（如果你使用的是 `docker-machine` 和 VirtualBox）应当产生如下结果：
- en: '[PRE7]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now execute the following command:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在执行以下命令：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Execute the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In another terminal, execute this command:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中，执行此命令：
- en: '[PRE10]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Execute a command such as this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行如下命令：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Exit both containers and then, back on the host, execute this command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 退出两个容器，然后返回主机，执行此命令：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The answer is B. Each container is a sandbox and thus has its very own environment.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是 B。每个容器都是一个沙箱，因此拥有自己独立的环境。
- en: 'Collect all environment variables and their respective values in a configuration
    file, which you then provide to the container with the `--env-file` command-line
    parameter in the `docker run` command, like so:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 收集所有环境变量及其对应的值到一个配置文件中，然后通过 `--env-file` 命令行参数将其提供给容器，在 `docker run` 命令中使用，示例如下：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Chapter 6
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第六章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的示例答案：
- en: 'Possible answers: a) Volume mount your source code in the container; b) use
    a tool that automatically restarts the app running inside the container when code
    changes are detected; c) configure your container for remote debugging.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可能的答案：a) 将源代码挂载到容器中；b) 使用工具，在检测到代码更改时自动重新启动容器中的应用；c) 配置容器进行远程调试。
- en: You can mount the folder containing the source code on your host in the container.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以将包含源代码的文件夹从主机挂载到容器中。
- en: If you cannot cover certain scenarios easily with unit or integration tests
    and if the observed behavior of the application cannot be reproduced when the
    application runs on the host. Another scenario is a situation where you cannot
    run the application on the host directly due to the lack of the necessary language
    or framework.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你不能轻松通过单元测试或集成测试覆盖某些场景，并且如果在主机上运行应用程序时无法重现观察到的行为，或者无法直接在主机上运行应用程序（由于缺乏必要的语言或框架），那么容器化的测试可以帮助解决这些问题。
- en: Once the application is running in production, we cannot easily gain access
    to it as developers. If the application shows unexpected behavior or even crashes,
    logs are often the only source of information we have to help us reproduce the
    situation and pinpoint the root cause of the bug.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦应用程序在生产环境中运行，作为开发人员，我们就不能轻易访问它。如果应用程序表现出异常行为或甚至崩溃，日志通常是我们唯一可以用来帮助我们重现情况并找出根本原因的来源。
- en: Chapter 7
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第七章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的示例答案：
- en: 'Pros and cons:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优缺点：
- en: 'Pro: We don''t need to have the particular shell, tool, or language required
    by the task installed on our host.'
  id: totrans-91
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：我们不需要在主机上安装任务所需的特定 Shell、工具或语言。
- en: 'Pro: We can run on any Docker host, from Raspberry Pi to a mainframe computer;
    the only requirement is that the host can run containers.'
  id: totrans-92
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：我们可以在任何 Docker 主机上运行，从树莓派到大型主机，唯一的要求是主机能运行容器。
- en: 'Pro: After a successful run, the tool is removed without leaving any traces
    from the host when the container is removed.'
  id: totrans-93
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优点：成功运行后，工具会在容器被移除时从主机上被清除，不会留下任何痕迹。
- en: 'Con: We need to have Docker installed on the host.'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：我们需要在主机上安装 Docker。
- en: Con: The user needs to have a basic understanding of Docker containers.
  id: totrans-95
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：用户需要具备基本的 Docker 容器知识。
- en: Con: Use of the tool is a bit more indirect than when using it natively.
  id: totrans-96
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺点：与本地使用工具相比，使用该工具的方式稍显间接。
- en: 'Running tests in a container has the following advantages:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中运行测试具有以下优点：
- en: They run equally well on a developer machine than on a test or CI system.
  id: totrans-98
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在开发者机器上运行和在测试或 CI 系统中运行一样顺畅。
- en: It is easier to start each test run with the same initial conditions.
  id: totrans-99
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次测试运行时，保持相同的初始条件会更容易。
- en: All developers working with the code use the same setup, for example, versions
    of libraries and frameworks.
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有开发人员使用相同的环境设置，例如库和框架的版本。
- en: Here, we expect a diagram that shows a developer writing code and checking it
    in, for example, GitHub. We then want to see an automation server such as Jenkins
    or TeamCity in the picture that is either periodically polling GitHub for changes
    or the GitHub triggers the automation server (with an HTTP callback) to create
    a new build. The diagram should also show that the automation server then runs
    all tests against the built artifacts and, if they all succeed, deploys the application
    or service to an integration system where it is again tested, for example, with
    a few smoke tests. Once again, if those tests succeed, the automation server should
    either ask a human for approval to deploy to production (this equals to continuous
    delivery) or the automation server should automatically deploy to production (continuous
    deployment).
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们期望看到一个图示，展示一个开发人员写代码并提交代码，例如到 GitHub。然后我们希望看到一个自动化服务器，如 Jenkins 或 TeamCity，图中显示它定期轮询
    GitHub 是否有更新，或者是 GitHub 触发自动化服务器（通过 HTTP 回调）创建新的构建。图中还应显示自动化服务器运行所有测试，以验证构建的产物，如果所有测试通过，自动将应用程序或服务部署到集成系统中，在那里再次进行测试，例如进行一些冒烟测试。再次，如果这些测试通过，自动化服务器应该要求人工批准是否将其部署到生产环境中（这等同于持续交付），或者自动化服务器应自动将其部署到生产环境中（持续部署）。
- en: Chapter 8
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章提出问题的一些示例答案：
- en: You could be working on a workstation with limited resources or capabilities,
    or your workstation could be locked down by your company so that you are not allowed
    to install any software that is not officially approved. Sometimes, you might
    need to do proof of concepts or experiments using languages or frameworks that
    are not yet approved by your company (but might be in the future if the proof
    of concept is successful).
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能在一个资源或功能有限的工作站上工作，或者你的工作站可能被公司锁定，禁止安装任何未获官方批准的软件。有时，你可能需要使用公司尚未批准的语言或框架进行概念验证或实验（但如果概念验证成功，未来可能会被批准）。
- en: Bind-mounting a Docker socket into a container is the recommended method when
    a containerized application needs to automate some container-related tasks. This
    can be an application such as an automation server such as Jenkins that you are
    using to build, test, and deploy Docker images.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当容器化应用程序需要自动化某些与容器相关的任务时，将 Docker 套接字绑定到容器中是推荐的方式。这可以是像 Jenkins 这样的自动化服务器应用程序，通常用于构建、测试和部署
    Docker 镜像。
- en: Most business applications do not need root-level authorizations to do their
    job. From a security perspective, it is hence strongly recommended to run such
    applications with the least necessary access rights to their job. Any unnecessary
    elevated privileges could possibly be exploited by hackers in a malicious attack.
    By running the application as a non-root user, you make it more difficult for
    potential hackers to compromise your system.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数商业应用程序在执行任务时不需要根级别的授权。从安全角度来看，因此强烈建议以最小权限运行此类应用程序，确保它们仅拥有完成任务所需的最低权限。任何不必要的提升权限可能会被黑客在恶意攻击中利用。通过以非
    root 用户身份运行应用程序，你可以使潜在的黑客更难以入侵系统。
- en: Volumes contain data and the lifespan of data most often needs to go far beyond
    the life cycle of a container or an application, for that matter. Data is often
    mission-critical and needs to be stored safely for days, months, even years. When
    you delete a volume, you irreversibly delete the data associated with it. Hence,
    make sure you know what you're doing when deleting a volume.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卷包含数据，而数据的生命周期通常需要远远超过容器或应用程序的生命周期。数据通常是任务关键的，需要安全存储数天、数月，甚至数年。当你删除一个卷时，你会不可逆地删除与其相关的数据。因此，删除卷时一定要确认你知道自己在做什么。
- en: Chapter 9
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章提出问题的一些示例答案：
- en: In a distributed application architecture, every piece of the software and infrastructure
    needs to be redundant in a production environment, where the continuous uptime
    of the application is mission-critical. A highly distributed application consists
    of many parts and the likelihood of one of the pieces failing or misbehaving increases
    with the number of parts. It is guaranteed that, given enough time, every part
    will eventually fail. To avoid outages of the application, we need redundancy
    in every part, be it a server, a network switch, or a service running on a cluster
    node in a container.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在分布式应用架构中，软件和基础设施的每一部分都需要在生产环境中具有冗余，以确保应用程序的持续运行时间是至关重要的。高度分布式的应用由多个部分组成，随着部分数量的增加，某个部分发生故障或异常行为的可能性也在增加。可以保证，给定足够的时间，每个部分最终都会失败。为了避免应用程序的停机，我们需要对每个部分进行冗余，无论是服务器、网络交换机，还是在容器中集群节点上运行的服务。
- en: In highly distributed, scalable, and fault-tolerant systems, individual services
    of the application can move around due to scaling needs or due to component failures.
    Thus, we cannot hardwire different services with each other. Service A, which
    needs access to Service B, should not have to know details such as the IP address
    of Service B. It should rely on an external provider of this information. DNS
    is such a provider of location information. Service A just tells it that it wants
    to talk to Service B and the DNS service will figure out the details.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在高度分布式、可扩展和容错的系统中，应用程序的单个服务可能会由于扩展需求或组件故障而发生变化。因此，我们不能将不同的服务硬编码在一起。服务A需要访问服务B时，不应该知道服务B的IP地址等细节。它应该依赖于外部提供者来获取这些信息。DNS就是这种位置服务提供者。服务A只需要告诉它要与服务B通信，DNS服务将会处理具体的细节。
- en: A circuit breaker is a means to avoid cascading failures if a component in a
    distributed application is failing or misbehaving. Similar to a circuit breaker
    in electric wiring, a software-driven circuit breaker cuts the communication between
    a client and a failed service. The circuit breaker will directly report an error
    back to the client component if the failed service is called. This gives the system
    the opportunity to recover or heal from failure.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 熔断器是一种避免级联故障的机制，适用于分布式应用中出现故障或异常行为的组件。类似于电路中的熔断器，软件驱动的熔断器切断客户端与故障服务之间的通信。如果调用的服务发生故障，熔断器将直接将错误报告给客户端组件。这为系统提供了从故障中恢复或修复的机会。
- en: A monolithic application is easier to manage that a multi-service application
    since it consists of a single deployment package. On the other hand, a monolith
    is harder to scale to account for increased demand. In a distributed application,
    each service can be scaled individually and each service can run on optimized
    infrastructure, while a monolith needs to run on infrastructure that is OK for
    all or most of the features implemented in it. Maintaining and updating a monolith
    is much harder than a multi-service application, where each service can be updated
    and deployed independently. The monolith is often a big, complex, and tightly
    coupled pile of code. Minor modifications can have unexpected side effects. (Micro-)
    Services, on the other hand, are self-contained, simple components that behave
    like black boxes. Dependent services know nothing about the inner workings of
    the service and thus do not depend on it.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单体应用比多服务应用更容易管理，因为它由一个单一的部署包组成。另一方面，单体应用更难以扩展以应对需求的增加。在分布式应用中，每个服务可以单独扩展，并且每个服务可以运行在优化的基础设施上，而单体应用则需要在能够支持所有或大部分功能的基础设施上运行。维护和更新单体应用比多服务应用困难得多，后者每个服务都可以独立更新和部署。单体应用通常是一个庞大、复杂且紧密耦合的代码堆栈。即使是小的修改也可能会带来意想不到的副作用。而（微）服务则是自包含、简单的组件，像黑盒一样工作。依赖的服务对服务的内部工作一无所知，因此也不依赖于它。
- en: A blue-green deployment is a form of software deployment that allows for zero
    downtime deployments of new versions of an application or an application service.
    If, say, Service A needs to be updated with a new version, then we call the currently
    running version blue. The new version of the service is deployed into production,
    but not yet wired up with the rest of the application. This new version is called
    green. Once the deployment succeeds and smoke tests have shown it's ready to go,
    the router that funnels traffic to blue is reconfigured to switch to green. The
    behavior of green is observed for a while and if everything is OK, blue is decommissioned.
    On the other hand, if green causes difficulties, the router can simply be switched
    back to blue and green can be fixed and later redeployed.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 蓝绿部署是一种软件部署方式，允许在零停机时间的情况下部署应用或应用服务的新版本。例如，如果服务A需要更新到新版本，那么当前运行的版本被称为蓝色。新版本的服务被部署到生产环境中，但尚未与其余应用连接。这个新版本被称为绿色。一旦部署成功并且冒烟测试表明它准备就绪，路由器会被重新配置，将流量从蓝色切换到绿色。观察绿色的表现一段时间，如果一切正常，蓝色将被停用。另一方面，如果绿色出现问题，路由器可以简单地切换回蓝色，绿色可以修复并重新部署。
- en: Chapter 10
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的部分示例答案：
- en: The three core elements are **sandbox**, **endpoint**, and **network**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 三个核心元素是**沙盒**、**端点**和**网络**。
- en: 'Execute this command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Run this command:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行此命令：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Test that both NGINX instances are up and running:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 测试两个NGINX实例是否都在运行：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You should be seeing the welcome page of NGINX in both cases.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都应该看到NGINX的欢迎页面。
- en: 'To get the IPs of all attached containers, run this command:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取所有附加容器的IP地址，请运行此命令：
- en: '[PRE17]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'You should see something similar to the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的内容：
- en: '[PRE18]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To get the subnet used by the network, use the following (for example):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取网络使用的子网，请使用以下命令（例如）：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You should receive something along the lines of the following (obtained from
    the previous example):'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该收到类似以下的内容（来自前面的示例）：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `host` network allows us to run a container in the networking namespace
    of the host.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`host`网络允许我们在主机的网络命名空间中运行容器。'
- en: Only use this network for debugging purposes or when building a system-level tool.
    Never use the `host` network for an application container running a production
    environment!
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅在调试目的或构建系统级工具时使用此网络。切勿将`host`网络用于运行生产环境的应用容器！
- en: The `none` network is basically saying that the container is not attached to
    any network. It should be used for containers that do not need to communicate
    with other containers and do not need to be accessed from outside.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`none`网络基本上是指容器未连接到任何网络。它应仅用于不需要与其他容器通信且不需要从外部访问的容器。'
- en: The `none` network could, for example, be used for a batch process running in
    a container that only needs access to local resources such as files that could
    be accessed via a host mounted volume.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 例如，`none`网络可用于运行批处理进程的容器，这些进程仅需要访问本地资源，例如通过主机挂载卷访问的文件。
- en: Traefik can be used to provide Layer 7 or application-level routing. This is
    especially useful if you want to break out functionality from a monolith with
    a well-defined API. In this case, you have a need to reroute certain HTTP calls
    to the new container/service. This is just one of the possible usage scenarios,
    but it's also the most important one. Another one could be to use Traefik as a
    load balancer.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Traefik可用于提供第7层或应用层路由。如果你想将某个功能从单体应用中拆分并且有明确的API定义，这将特别有用。在这种情况下，你需要将某些HTTP调用重新路由到新容器/服务。这只是可能的使用场景之一，但也是最重要的一个。另一个场景是将Traefik用作负载均衡器。
- en: Chapter 11
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的部分示例答案：
- en: 'The following code can be used to run the application in detached or daemon
    mode:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码可用于以分离模式或守护进程模式运行应用：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Execute the following command to display the details of the running service:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行以下命令以显示运行中的服务的详细信息：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This should result in the following output:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会产生如下输出：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The following command can be used to scale up the web service:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下命令可用于扩展Web服务：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Chapter 12
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出问题的部分示例答案：
- en: A mission-critical, highly available application that is implemented as a highly
    distributed system of interconnected application services that are just too complex
    to manually monitor, operate, and manage. Container orchestrators help in this
    regard. They automate most of the typical tasks, such as reconciling a desired
    state, or collecting and aggregating key metrics of the system. Humans cannot
    react quick enough to make such an application elastic or self-healing. Software
    support is needed for this in the form of the mentioned container orchestrators.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个关键任务的、高可用的应用程序，它实现为一个高度分布的互联应用服务系统，过于复杂，无法手动监控、操作和管理。容器编排工具在这方面提供帮助。它们自动化大多数典型任务，比如协调期望状态，或收集和聚合系统的关键指标。人类无法快速反应使得这样的应用程序具备弹性或自愈能力。需要以容器编排工具形式的
    软件支持。
- en: 'A container orchestrator frees us from mundane and cumbersome tasks such as
    the following:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器编排工具将我们从以下繁琐的日常任务中解放出来：
- en: Scaling services up and down
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展服务的规模
- en: Load balancing requests
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载均衡请求
- en: Routing requests to the desired target
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求路由到目标
- en: Monitoring the health of service instances
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控服务实例的健康状况
- en: Securing a distributed application
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护分布式应用程序
- en: The winner in this space is Kubernetes, which is open sourced and owned by the
    CNCF. It was originally developed by Google. We also have Docker Swarm, which
    is proprietary and has been developed by Docker. AWS offers a container service
    called ECS, which is also proprietary and tightly integrated into the AWS ecosystem.
    Finally, Microsoft offers AKS, which has the same pros and cons as AWS ECS.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个领域的赢家是 Kubernetes，它是开源的，属于 CNCF。最初由 Google 开发。我们还有 Docker Swarm，它是专有的，由 Docker
    开发。AWS 提供了一种名为 ECS 的容器服务，也是专有的，并且与 AWS 生态系统紧密集成。最后，微软提供了 AKS，它与 AWS ECS 有相同的优缺点。
- en: Chapter 13
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章提出问题的一些示例答案：
- en: 'The correct answer is as follows:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE25]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `--advertise-addr` is optional and is only needed if you the host have more than
    one IP address.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`--advertise-addr` 是可选的，只有当主机有多个 IP 地址时才需要。'
- en: 'On the worker node that you want to remove, execute the following command:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你要移除的工作节点上，执行以下命令：
- en: '[PRE26]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: On one of the master nodes, execute the command `$ docker node rm -f<node ID>`,
    where <`node ID>` is the ID of the worker node to remove.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个主节点上，执行命令 `$ docker node rm -f <node ID>`，其中 `<node ID>` 是要移除的工作节点的 ID。
- en: 'The correct answer is as follows:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The correct answer is as follows:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE28]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The correct answer is as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正确答案如下：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Chapter 14
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本章提出问题的一些示例答案：
- en: Zero-downtime deployment means that a new version of a service in a distributed
    application is updated to a new version without the application needing to stop
    working. Usually, with Docker SwarmKit or Kubernetes (as we will see), this is
    done in a rolling fashion. A service consists of multiple instances and those
    are updated in batches so that the majority of the instances are up and running
    at all times.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 零停机部署意味着分布式应用程序中服务的新版本可以更新为新版本，而不需要应用程序停止工作。通常，使用 Docker SwarmKit 或 Kubernetes（如我们将看到的），这是以滚动方式进行的。一个服务由多个实例组成，且这些实例是分批更新的，这样大部分实例始终在运行。
- en: By default, Docker SwarmKit uses a rolling updated strategy to achieve zero-downtime
    deployments.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 默认情况下，Docker SwarmKit 使用滚动更新策略来实现零停机部署。
- en: Containers are self-contained units of deployment. If a new version of a service
    is deployed and does not work as expected, we (or the system) need to only roll
    back to the previous version. The previous version of the service is also deployed
    in the form of self-contained containers. Conceptually, there is no difference
    in rolling forward (update) or backward (rollback). One version of a container
    is replaced by another one. The host itself is not affected by such changes in
    any way.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器是自包含的部署单元。如果部署的新版本服务无法正常工作，我们（或系统）只需要回滚到之前的版本。服务的前一个版本也是以自包含的容器形式部署的。从概念上讲，前进（更新）或后退（回滚）没有区别。一个版本的容器被另一个版本替代。主机本身不受这些更改的影响。
- en: Docker secrets are encrypted at rest. They are only transferred to the services
    and containers that use the secrets. Secrets are transferred encrypted due to
    the fact that the communication between swarm nodes uses mutual TLS. Secrets are
    never physically stored on a worker node.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Docker 密钥在静态存储时是加密的。它们只会传输给使用这些密钥的服务和容器。由于群集节点之间的通信使用相互 TLS，因此密钥是加密传输的。密钥永远不会物理存储在工作节点上。
- en: 'The command to achieve this is as follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现此操作的命令如下：
- en: '[PRE30]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '6\. First, we need to remove the old secret from the service, and then we need
    to add the new version to it (directly updating a secret is not possible):'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 首先，我们需要将旧的密钥从服务中删除，然后需要将新版本的密钥添加进去（无法直接更新密钥）：
- en: '[PRE31]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Chapter 15
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第十五章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章提出的问题的一些示例答案：
- en: The Kubernetes master is responsible for managing the cluster. All requests
    to create objects, reschedule pods, manage ReplicaSets, and more happen on the
    master. The master does not run the application workload in a production or production-like
    cluster.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 主节点负责管理集群。所有创建对象、重新调度 Pod、管理 ReplicaSets 等的请求都发生在主节点上。主节点不在生产或类生产集群中运行应用程序工作负载。
- en: On each worker node, we have the kubelet, the proxy, and container runtime.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在每个工作节点上，我们有 kubelet、代理和容器运行时。
- en: The answer is A. **Yes**. You cannot run standalone containers on a Kubernetes
    cluster. Pods are the atomic units of deployment in such a cluster.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 答案是 A. **是的**。你无法在 Kubernetes 集群上运行独立容器。Pod 是该集群中部署的原子单元。
- en: All containers running inside a pod share the same Linux kernel network namespace.
    Thus, all processes running inside those containers can communicate with each
    other through `localhost` in a similar way to how processes or applications directly
    running on the host can communicate with each other through `localhost`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个 Pod 内运行的所有容器共享相同的 Linux 内核网络命名空间。因此，所有在这些容器中运行的进程可以通过 `localhost` 相互通信，这与直接在主机上运行的进程或应用程序通过
    `localhost` 互相通信的方式类似。
- en: The `pause` container's sole role is to reserve the namespaces of the pod for
    containers that run in it.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`pause` 容器的唯一作用是为在其中运行的容器保留 Pod 的命名空间。'
- en: This is a bad idea since all containers of a pod are co-located, which means
    they run on the same cluster node. Also, if multiple containers run in the same
    pod, they can only be scaled up or down all at once. However, the different components
    of the application (that is, `web`, `inventory`, and `db`) usually have very different
    requirements with regard to scalability or resource consumption. The `web` component
    might need to be scaled up and down depending on the traffic and the `db` component,
    in turn, has special requirements regarding storage that the others don't have.
    If we do run every component in its own pod, we are much more flexible in this
    regard.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个糟糕的主意，因为一个 Pod 的所有容器是共同定位的，这意味着它们都运行在同一个集群节点上。此外，如果多个容器运行在同一个 Pod 中，它们只能一起扩展或缩减。然而，应用程序的不同组件（即
    `web`、`inventory` 和 `db`）通常在可扩展性或资源消耗方面有非常不同的要求。`web` 组件可能需要根据流量进行扩展或缩减，而 `db`
    组件则在存储方面有特殊要求，而其他组件没有。如果我们将每个组件都运行在自己的 Pod 中，那么在这方面我们就更具灵活性。
- en: We need a mechanism in order to run multiple instances of a pod in a cluster
    and make sure that the actual number of pods running always corresponds to the
    desired number, even when individual pods crash or disappear due to network partition or
    cluster node failures. The ReplicaSet is the mechanism that provides scalability
    and self-healing to any application service.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个机制来确保在集群中运行多个实例的 Pod，并确保实际运行的 Pod 数量始终与期望数量相符，即使个别 Pod 因网络分区或集群节点故障而崩溃或消失。ReplicaSet
    是为任何应用程序服务提供可扩展性和自我修复的机制。
- en: We need deployment objects whenever we want to update an application service in
    a Kubernetes cluster without causing downtime to the service. Deployment objects
    add rolling updates and rollback capabilities to ReplicaSets.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每当我们想在 Kubernetes 集群中更新应用程序服务时，而不造成服务的停机，就需要部署对象。部署对象为 ReplicaSets 添加了滚动更新和回滚功能。
- en: 'Kubernetes service objects are used to make application services participate
    in service discovery. They provide a stable endpoint to a set of pods (normally
    governed by a ReplicaSet or a deployment). Kube services are abstractions that define
    a logical set of pods and a policy regarding how to access them. There are four types
    of Kube service:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 服务对象用于使应用服务参与服务发现。它们为一组 pod 提供稳定的端点（通常由 ReplicaSet 或部署管理）。Kube 服务是定义逻辑集的抽象，并规定如何访问它们的策略。Kube
    服务有四种类型：
- en: '**ClusterIP**: Exposes the service on an IP address that''s only accessible
    from inside the cluster; this is a virtual IP (VIP).'
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterIP**：在仅能从集群内部访问的 IP 地址上暴露服务；这是一个虚拟 IP（VIP）。'
- en: '**NodePort**: Publishes a port in the range 30,000–32,767 on every cluster node.'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NodePort**：在每个集群节点上发布一个 30,000 到 32,767 范围内的端口。'
- en: '**LoadBalancer**: This type exposes the application service externally using
    a cloud provider''s load balancer, such as ELB on AWS.'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadBalancer**：这种类型使用云提供商的负载均衡器（例如 AWS 上的 ELB）将应用服务暴露给外部。'
- en: '**ExternalName**: Used when you need to define a proxy for a cluster''s external
    service such as a database.'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ExternalName**：当你需要为集群外部服务（例如数据库）定义代理时使用。'
- en: Chapter 16
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第16章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章中提出问题的一些示例答案：
- en: 'Assuming we have a Docker image in a registry for the two application services, the
    web API and Mongo DB, we then need to do the following:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们在注册表中有一个 Docker 镜像用于两个应用服务：Web API 和 Mongo DB，接下来我们需要做以下操作：
- en: Define a deployment for Mongo DB using a StatefulSet; let's call this deployment `db-deployment`.
    The StatefulSet should have one replica (replicating Mongo DB is a bit more involved
    and is outside the scope of this book).
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 StatefulSet 为 Mongo DB 定义一个部署，我们称之为`db-deployment`。StatefulSet 应该有一个副本（复制
    Mongo DB 更为复杂，超出了本书的范围）。
- en: Define a Kubernetes service called `db` of the `ClusterIP` type for `db-deployment`.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为`db`的 Kubernetes 服务，类型为`ClusterIP`，用于`db-deployment`。
- en: Define a deployment for the web API; let's call it `web-deployment`. Let's scale
    this service to three instances.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个用于 Web API 的部署，我们称之为`web-deployment`。我们将这个服务扩展为三个实例。
- en: Define a Kubernetes service called `api` of the `NodePort` type for `web-deployment`.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个名为`api`的 Kubernetes 服务，类型为`NodePort`，用于`web-deployment`。
- en: If we use secrets, then define those secrets directly in the cluster using kubectl.
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们使用机密（secrets），则需要通过 kubectl 直接在集群中定义这些机密。
- en: Deploy the application using kubectl.
  id: totrans-205
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 kubectl 部署应用程序。
- en: To implement layer 7 routing for an application, we ideally use an IngressController.
    The IngressController is a reverse proxy such as Nginx that has a sidecar listening
    on the Kubernetes Server API for relevant changes and updating the reverse proxy's
    configuration and restarting it if such a change has been detected. Then, we need
    to define Ingress resources in the cluster that define the routing, for example,
    from a context-based route such as `https://example.com/pets to <a service name>/<port>` or
    a pair such as `api/32001`. The moment Kubernetes creates or changes this Ingress
    object, the IngressController's sidecar picks it up and updates the proxy's routing configuration.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为应用实现第7层路由，理想情况下我们使用 IngressController。IngressController 是一个反向代理，例如 Nginx，它有一个
    sidecar 监听 Kubernetes 服务器 API 的相关更改，并在检测到此类更改时更新反向代理的配置并重启它。然后，我们需要在集群中定义 Ingress
    资源，定义路由规则，例如基于上下文的路由，如`https://example.com/pets to <service name>/<port>`，或者像`api/32001`这样的配对。一旦
    Kubernetes 创建或更改了这个 Ingress 对象，IngressController 的 sidecar 就会捕捉到并更新代理的路由配置。
- en: 'Assuming this is a cluster internal inventory service, then we do the following:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设这是一个集群内部的库存服务，那么我们接下来做以下操作：
- en: 'When deploying version 1.0, we define a deployment called `inventory-deployment-blue` and
    label the pods with a label of `color: blue`.'
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '在部署版本 1.0 时，我们定义一个名为`inventory-deployment-blue`的部署，并为 pod 添加标签`color: blue`。'
- en: 'We deploy the Kubernetes service of the `ClusterIP` type called inventory for
    the preceding deployment with the selector containing `color: blue`.'
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们为前面的部署部署一个类型为`ClusterIP`的 Kubernetes 服务，命名为 inventory，选择器包含`color: blue`。'
- en: 'When we''re ready to deploy the new version of the payments service, we define
    a deployment for version 2.0 of the service and call it `inventory-deployment-green`.
    We add a label of `color: green` to the pods.'
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '当我们准备好部署支付服务的新版本时，我们为服务的 2.0 版本定义一个部署，并将其命名为`inventory-deployment-green`。我们为
    pod 添加一个标签`color: green`。'
- en: 'We can now smoke test the "green" service and when everything is OK, we can
    update the inventory service so that the selector contains `color: green`.'
  id: totrans-211
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '我们现在可以对 "green" 服务进行冒烟测试，当一切正常时，我们可以更新库存服务，使得选择器包含 `color: green`。'
- en: Some forms of information that are confidential and thus should be provided
    to services through Kubernetes secrets include passwords, certificates, API key
    IDs, API key secrets, and tokens.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一些机密信息，应该通过 Kubernetes secrets 提供给服务，包括密码、证书、API 密钥 ID、API 密钥密文和令牌。
- en: Sources for secret values can be files or base64-encoded values.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 秘密值的来源可以是文件或 base64 编码的值。
- en: Chapter 17
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第17章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的一些示例答案：
- en: We cannot do any live debugging on a production system for performance and security
    reasons. This includes interactive or remote debugging. Yet application services
    can show unexpected behavior to code defects or other infrastructure-related issues
    such as network glitches or external services that are not available. To quickly
    pinpoint the reason for the misbehavior or failure of a service, we need as much
    logging information as possible. This information should give us a clue about,
    and guide us to, the root cause of the error. When we instrument a service, we
    do exactly this — we produce as much information as reasonable in the form of
    log entries and published metrics.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 出于性能和安全原因，我们不能在生产系统上进行实时调试。这包括交互式调试或远程调试。然而，应用服务可能由于代码缺陷或其他与基础设施相关的问题（如网络故障或不可用的外部服务）而表现出意外行为。为了快速确定服务行为异常或失败的原因，我们需要尽可能多的日志信息。这些信息应该为我们提供线索，并引导我们找到错误的根本原因。当我们对服务进行监控时，正是为了做到这一点——我们以合理的方式生成尽可能多的信息，形式是日志条目和发布的度量。
- en: Prometheus is a service that is used to collect functional or non-functional
    metrics that are provided by other infrastructure services and most importantly
    by application services. Since Prometheus itself is pulling those metrics periodically
    from all configured services, the services themselves do not have to worry about
    sending data. Prometheus also defines the format in which the metrics are to be
    presented by the producers.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Prometheus 是一个用于收集由其他基础设施服务，最重要的是应用服务提供的功能性或非功能性度量的服务。由于 Prometheus 本身周期性地从所有配置的服务中拉取这些度量，服务本身无需担心发送数据。Prometheus
    还定义了生产者应呈现度量数据的格式。
- en: 'To instrument a Node.js-based application service we need to do the following
    four steps:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要为基于 Node.js 的应用服务进行监控，我们需要执行以下四个步骤：
- en: Add a Prometheus adapter to the project. The maintainers of Prometheus recommend
    the library called `siimon/prom-client`.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加 Prometheus 适配器。Prometheus 的维护者推荐使用名为 `siimon/prom-client` 的库。
- en: Configure the Prometheus client during startup of the application. This includes
    the definition of a metrics registry.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用启动时配置 Prometheus 客户端。这包括定义度量注册表。
- en: Expose an HTTP GET endpoint/metrics where we return the collection of metrics
    defined in the metrics registry.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暴露一个 HTTP GET 端点/度量，在该端点我们返回度量注册表中定义的度量集合。
- en: Finally, we define custom metrics of the `counter`, `gauge`, or `histogram` type,
    and use them in our code; for example, we increase a metric of the `counter` type
    each time a certain endpoint is called.
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们定义 `counter`、`gauge` 或 `histogram` 类型的自定义度量，并在我们的代码中使用它们；例如，我们每次调用某个端点时，就增加一个
    `counter` 类型的度量。
- en: Normally in production, a Kubernetes cluster node only contains a minimal OS
    to keep its attack surface as limited as possible and to not waste precious resources.
    Thus we cannot assume that the tools typically used to troubleshoot applications
    or processes are available on the respective host. A powerful and recommended
    way to troubleshoot is to run a special tools or troubleshoot container as part
    of an ad hoc pod. This container can then be used as a bastion from which we can
    investigate network and other issues with the troubled service. A container that
    has been successfully used by many Docker field engineers at their customers site is `netshoot`.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产环境中，Kubernetes 集群节点通常只包含一个最小化的操作系统，以尽可能减少攻击面并避免浪费宝贵的资源。因此，我们不能假设通常用于排查应用或进程问题的工具在各个主机上都可用。一个强大且推荐的排查方式是运行一个特殊的工具或排查容器，作为一个临时
    pod 的一部分。这个容器可以作为堡垒，从中我们可以调查与有问题服务相关的网络或其他问题。一个已经成功被许多 Docker 工程师在客户现场使用的容器是 `netshoot`。
- en: Chapter 18
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第18章
- en: 'Here are some sample answers to the questions presented in this chapter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的一些示例答案：
- en: 'To install UCP in AWS, we do the following:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在 AWS 上安装 UCP，我们按以下步骤操作：
- en: Create a VPC with subnets and an SG.
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个包含子网和安全组（SG）的虚拟私有云（VPC）。
- en: Then, provision a cluster of Linux VMs, possibly as part of an ASG. Many Linux
    distributions are supported, such as CentOS, RHEL, and Ubuntu.
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，提供一组 Linux 虚拟机，可能作为自动伸缩组（ASG）的一部分。许多 Linux 发行版是支持的，如 CentOS、RHEL 和 Ubuntu。
- en: Next, install Docker on each VM.
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，在每个虚拟机上安装 Docker。
- en: Finally, select one VM on which to install UCP using the `docker/ucp` image.
  id: totrans-230
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，选择一台虚拟机并使用 `docker/ucp` 镜像来安装 UCP。
- en: Once UCP is installed, join the other VMs to the cluster either as worker nodes
    or manager nodes.
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦 UCP 安装完成，将其他虚拟机加入集群，作为工作节点或管理节点。
- en: 'Here are a few reasons to consider a hosted Kubernetes offering:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下是考虑使用托管 Kubernetes 服务的一些原因：
- en: You do not want to, or do not have the resources to, install and manage a Kubernetes
    cluster.
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可能不想安装和管理一个 Kubernetes 集群，或者没有足够的资源来完成这一任务。
- en: You want to concentrate on what brings value to your business, which in most
    cases is the applications that are supposed to run on Kubernetes and not Kubernetes
    itself.
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你希望专注于为你的业务带来价值的部分，在大多数情况下，这就是应该运行在 Kubernetes 上的应用，而不是 Kubernetes 本身。
- en: You prefer a cost model where you pay only for what you need.
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你偏向于一种按需付费的成本模型，只为你需要的部分付费。
- en: The nodes of your Kubernetes cluster are automatically patched and updated.
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的 Kubernetes 集群节点会自动进行补丁更新。
- en: Upgrading the version of Kubernetes with zero downtime is easy and straightforward.
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级 Kubernetes 版本且零停机时间的操作简单直接。
- en: 'The two main reasons to host container images on the cloud provider''s container
    registry (such as ACR on Microsoft Azure) are these:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将容器镜像托管在云服务提供商的容器注册表（例如微软 Azure 上的 ACR）上的两个主要原因是：
- en: The images are geographically close to your Kubernetes cluster and thus the
    latency and transfer network costs are minimal.
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像地理位置靠近你的 Kubernetes 集群，因此延迟和传输网络成本极低。
- en: Production or production-like clusters are ideally sealed from the internet,
    and thus the Kubernetes cluster nodes cannot access Docker Hub directly.
  id: totrans-240
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产环境或类似生产环境的集群最好与互联网隔离，因此 Kubernetes 集群节点无法直接访问 Docker Hub。
