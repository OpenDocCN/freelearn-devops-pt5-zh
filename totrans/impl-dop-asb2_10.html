<html><head></head><body>
        

                            
                    <h1 class="header-title">Ansible and Docker</h1>
                
            
            
                
<p>Ansible's realm of DevOps integrations is not limited to CI solutions or Configuration Management provisioning implementations. In addition to these, its integration with cloud infrastructure and virtualization-oriented solutions is considered second to none by industry experts. Virtualization solutions such as Docker and Vagrant have taken the cloud computing industry by storm. As such, the integration between Configuration Management tools (including Ansible) has become increasingly robust.</p>
<p>In this chapter, we will take a deep dive into the relationship that can be forged between Docker and Ansible. We will discover how Ansible can be used to create, maintain, and deploy Docker images. We will take a look at how Ansible's module solution for Docker can help automate the delivery of software applications. We will discover commonly popular ways to integrate Ansible with this modern virtualization solution and learn how experts in the industry are combining these two tools to create horizontally scalable and powerful infrastructure delivery solutions.</p>
<p>Upon completing this chapter, we will have a better understanding of how to integrate Ansible with Docker. We will have a solid grasp of the technical requirements required to create a scalable Docker environment, and you will learn how to better automate continuous integration and continuous delivery pipelines.</p>
<p>More specifically, in this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding Docker's Architecture</li>
<li>Managing Docker Containers with Ansible</li>
<li>Using Ansible to Create Docker Images</li>
<li>Managing Docker Images with Ansible</li>
<li>Gathering Facts About Docker Containers using Ansible</li>
</ul>
<p>Let's get started!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Docker's Architecture</h1>
                
            
            
                
<p>Initially, combining Docker and Ansible may seem contrary to good configuration management tactics. However, after some research, we quickly learn that these two seemingly different technologies are actually quite robust and scalable when combined. This chapter will focus on integrating Ansible and Docker.</p>
<p>Docker is easily the frontrunner of virtualization solutions. It provides a huge benefit above virtually every other virtualization solution on the market. As such, Dockers popularity has grown significantly in organizations looking to deliver high-quality, robust implementations to customers.</p>
<p>Before we can dive into the integration points, let's talk about Dockers' architecture. This is important to understand as it is what sets Docker aside from the competition. The following diagram shows Docker's unique architecture in detail:</p>
<div><img height="398" width="649" class="image-border" src="img/957222cd-e575-4ccb-987e-aab376565fd2.png"/></div>
<p>As we can see from the preceding diagram, Dockers architecture provides us with a <strong>shared kernel</strong> that sits on top of the <strong>Host operating system</strong>. In addition to the shared kernel, we also have <strong>Shared libraries</strong> and a set of shared resources.</p>
<p>This is important to understand because in the case of the <strong>Host operating system</strong>, the flavor of Linux is irrelevant. This support structure allows Docker to sit on top of any flavor of Linux and yet still serve up a filesystem from another flavor of Linux. For example, the <strong>Host operating system</strong> could be Ubuntu Linux and yet the containers might have a Fedora flavor.</p>
<p>Let's look at how this works via the following diagram:</p>
<div><img height="446" width="587" class="image-border" src="img/2aa93f36-363f-4bc3-a7b6-187b40762677.png"/></div>
<p>From the preceding diagram, we can see exactly how the various Linux distributions can be used via a Docker container. In our illustration, we have three highly unique flavors of Linux and web applications that reside within different Linux flavors. Neat, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Docker containers as environments</h1>
                
            
            
                
<p>Docker's implementation makes it highly effective for spinning up environments. Environments in this context represent application hosts, database tiers, and APIs that can be combined to provide a working instance of a software solution. In the case of larger organizations, these environments might be multiple instances (development, QA, stage, and production).</p>
<p>In the following diagram, we can see the architecture of a full-scale environment implementation using Docker:</p>
<div><img height="447" width="681" class="image-border" src="img/bc15d2ed-78c0-4d82-a39a-16f69ce2ab89.png"/></div>
<p>In the preceding diagram, we have multiple containers serving up multiple environments. Ansible's integration and orchestration solution can help pave and maintain these environments. In the next section, we will see exactly how.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing Docker Containers with Ansible</h1>
                
            
            
                
<p>Ansible provides a unique set of modules that allow Ansible playbook developers to integrate Ansible with Docker directly. The <em>Docker module</em> provides the Ansible playbook developer with the ability to <kbd>create</kbd>, <kbd>start</kbd>, <kbd>restart</kbd>, <kbd>modify</kbd>, and <kbd>remove</kbd>.</p>
<p>In this section, we will take a look at basic operational techniques that can be applied to managing Docker containers using Ansible. Specifically, we will cover:</p>
<ul>
<li>How to create Docker containers using Ansible</li>
<li>How to update Docker containers using Ansible</li>
<li>How to delete Docker containers using Ansible</li>
<li>How to launch a Docker container using Ansible</li>
</ul>
<p>Initially, performing these tasks may seem a bit daunting. But once we pull back the veil on this solution, we will see that the implementation of such tasks within a playbook is fairly straightforward. Let's take a look at how these playbook modules can help us manage Docker containers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating Docker containers</h1>
                
            
            
                
<p>Creating Docker containers may seem like a difficult task through Ansible; however, it's actually quite simple. In this section, you will learn how to do exactly that. Let's get started:</p>
<pre>
- name: Create a data container<br/>  docker_container:<br/>    name: mydata<br/>    image: busybox<br/>    volumes:<br/>      - /data<br/>
</pre>
<p>The preceding Ansible task creates a Docker data container using the <kbd>busybox</kbd> image with a simple volume of <kbd>/data</kbd>. While it's easy to create simple containers, we will obviously need more substance to create more useful containers. Let's take a look at how to do this.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Removing Docker containers</h1>
                
            
            
                
<p>Removing Docker containers can be achieved with a simple Ansible state for the container provided within the task itself. The following is an example of how to remove a Docker container from the local Docker registry:</p>
<pre>
- name: Remove MYSQL container
  docker_container:
    name: mysql
    state: absent
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Launching and stopping Docker containers</h1>
                
            
            
                
<p>Launching Docker containers using Ansible can be achieved via the Ansible Docker task. In the following example, we launch a Docker container for <kbd>mysql</kbd>. Let's take a look:</p>
<pre class="mce-root">
# The following task launches a mysql docker container<br/>- name: MySQL Database Container Launch<br/>   docker:<br/>   name: database<br/>   image: mysql:1.0<br/>   state: started
</pre>
<p>From the preceding example, we can see the task launches a MySQL Docker container (version 1.0). The primary parameters we used in this task are <kbd>image</kbd> and <kbd>name</kbd>. These parameters define the image and tag for the task to use and what we want to title the container we are managing.</p>
<p class="mce-root">The key to launching the container is the <kbd>started</kbd> state. State in this context provides the following switches:</p>
<ul>
<li class="mce-root"><kbd>absent</kbd></li>
<li class="mce-root"><kbd>present</kbd></li>
<li class="mce-root"><kbd>stopped</kbd></li>
<li class="mce-root"><kbd>started</kbd></li>
</ul>
<p>So, in order to expand on this, let's take a look at an example of the same Ansible task, which instead of launching the container will stop it:</p>
<pre>
# The following task stops a mysql docker container<br/>- name: MySQL Database Container Stop<br/>   docker:<br/>   name: database<br/>   image: mysql:1.0<br/>   state: stopped
</pre>
<p>For teams who update their containers frequently, it is probably a good idea to add the following flags to the Docker container launch operation:</p>
<pre>
   pull: always
</pre>
<p>These operational parameters will force Docker to pull a fresh container every time it's executed <em>and</em> to reload the container as part of the task.</p>
<p>For a complete documentation of the Ansible Docker container module, go to <a href="https://docs.ansible.com/ansible/docker_container_module.html">https://docs.ansible.com/ansible/docker_container_module.html</a>.</p>
<p>In addition to launching and stopping a Docker container using the <kbd>started</kbd> and <kbd>stopped</kbd> switches, we can also launch a container and execute a command. Let's take a look at how to do this:</p>
<pre>
- name: Starting a container and executing a command<br/> docker_container:<br/> name: sleepy<br/> image: ubuntu:14.04<br/> command: ["sleep", "infinity"]
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing network access Docker containers</h1>
                
            
            
                
<p>What good is an isolated Docker container with no network access? In this section, we are going to take a look at how to add a container to a network and conversely also remove it from the network.</p>
<p>To manage network connectivity within a Docker container, the Ansible task implementation has provided a set of network switches to the main Docker container task. Let's take a look at an example of these switches in action and see how to leverage Ansible in this form.</p>
<p>Adding a container to a network can be done using the following code:</p>
<pre>
- name: Add container to CoprLAN and GuestLan networks<br/>  docker_container:<br/>  name: sleepy<br/>  networks:<br/><br/>- name: CorpLan<br/>  ipv4_address: 172.1.10.1<br/>  links:<br/>   - sleeper<br/>   - name: GuestLan<br/>  ipv4_address: 172.1.10.2
</pre>
<p>Removing a container from the network can be done using the following code:</p>
<pre>
- name: Remove container from the CorpLan network<br/>  docker_container:<br/>  name: MySQL<br/>  networks:<br/>    - name: CorpLan<br/>  purge_networks: yes
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Ansible to Create Docker Images</h1>
                
            
            
                
<p>Docker provides an out-of-box solution to build Docker images using a Docker domain-specific language. Docker files are created in order to provide spin-up instructions that Docker can execute in order to build an image. After learning to create Docker files, one may ask why we would advocate for leveraging Ansible to create Docker containers in conjunction with a Dockerfile. The answer is quite simpleâ€”idempotency. An idempotent operation is one where the operation, once executed, can be executed repeatedly without any change. This is precisely what Ansible does.</p>
<p>Once Ansible has effected a change in a given system, it will automatically skip that change if the change is already present. So for example, if an Ansible playbook runs against a target system and makes, say, four changes to that system, it will automatically skip trying to make that change again <em>if</em> the change is found already present or if the system is already in the desired state.</p>
<p>In terms of creating Docker images using Ansible, it is a good idea to leverage Ansible because the domain language is a bit easier to read, the operations are idempotent, and the changes can be applied to one container or a hundred simultaneously. This provides a large amount of flexibility and scalability within this space. In this section, we are going to look at how to leverage Ansible to create Docker images. Let's get started.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Dockerfiles to launch Ansible playbooks</h1>
                
            
            
                
<p>By leveraging Docker files to call Ansible playbooks once launched, we can make our implementation of Docker containers fairly robust. This type of implementation has a number of benefits. The most notable are as follows:</p>
<ul>
<li>If there is existing infrastructure that is already leveraging Ansible, keeping the automation control consistent is a no-brainer</li>
<li>Ansible's module system provides integration with a number of third-party tools and technologies</li>
<li>Ansible's implementation of easy-to-read syntax and idempotent architecture provides a significant set of capabilities for developers onboarding into Ansible.</li>
</ul>
<p>In this section, we will take a look at how to best leverage a Dockerfile to execute an Ansible playbook. Let's get started by taking a look at an example Dockerfile:</p>
<pre class="mce-root">
# This DOCKERFILE creates a docker image with Ubuntu 14.04 and Ansible installed<br/># It also executes a playbook upon startup<br/>FROM ansible/ubuntu14.04-ansible:stable<br/><br/># This Defines the location for Ansible playbooks as /srv/example<br/>ADD ansible /srv/example<br/>WORKDIR /srv/example<br/><br/># Execute Ansible with the playbook's primary entry point as myplaybook.yml<br/>RUN ansible-playbook myplaybook.yml -c local<br/>CMD ["--help"] 
</pre>
<p>The preceding example should be fairly self-documented. However, it basically creates a Docker image based on Ubuntu 14.04, defines a working directory for Ansible, and then runs Ansible locally using <kbd>myplaybook.yml</kbd> as its source. Easy, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing Docker Images with Ansible</h1>
                
            
            
                
<p class="mce-root CDPAlignLeft CDPAlign">Docker images are slightly different from containers. That is, the image is the stored copy of the container. Docker images are stored in what is commonly referred to as a <strong>registry.</strong> In the context of Docker, the registry acts similar to a source control solution in many ways. That source control solution is mirrored in many ways to Git. Docker registries parallel Git in many ways; the most obvious is the ability to have a distributed set of registries. Confused yet? Let's take a look at the following diagram:</p>
<div><img height="328" width="402" class="image-border" src="img/cebd8ec3-2cd1-4367-8467-a9ed47fa9f8b.png"/></div>
<p>From the preceding illustration, we can see that the <strong>Docker registry</strong> is a remote location that stores Docker images. Docker images then reside in a local registry (local to the developer) where they can manipulate and store changes made to the various containers stored within the <strong>Docker registry</strong>. When a set of changes has been deemed complete, the developer has the option to <strong>push</strong> the image(s) to the remote registry and communicate their changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pulling, pushing, and tagging images</h1>
                
            
            
                
<p>One of the fundamental Docker development requirements is the ability of the developer to pull, push, and tag Docker images from the remote registry. Ansible can be useful in this <em>if</em> you have a build system that orchestrates changes to the infrastructure and stores the baked images for future deployment. Within this type of scenario, the workflow might go something like this:</p>
<ol>
<li>The developer checks out the source code for a set of Ansible playbooks that define the organization's infrastructure.</li>
<li>The developer makes a change to a playbook that is associated with the DB tier of the environment and commits their code change to Git.</li>
<li>Jenkins offers an automated CI solution, which sees the commit, and pulls down the playbook repo for validation.</li>
<li>Jenkins executes Ansible to run the playbook, which automatically creates a newer version of the Docker image.</li>
<li>The updated Docker image is then pushed to the remote registry for deployment into a development or QA environment.</li>
</ol>
<p>This type of workflow is pretty simple. It ensures that the development organization is not manually making changes to the containers; it ensures that Ansible is the tool used to develop, automate, and deploy the software solution; and it ensures that the images spun up are tested before deployment to production.</p>
<p>Automating this type of workflow in Ansible takes the ability to pull a Docker image, push a Docker image, and tag a Docker image. Let's look at the playbook tasks that could make this happen.</p>
<p>To pull a Docker image, use the following code:</p>
<pre class="mce-root">
- name: Pull a Docker Image<br/>  docker_image:<br/>  name: pacur/centos-7
</pre>
<p>To tag an image and push it, use the following code:</p>
<pre class="mce-root">
- name: Tag a Docker Image and Push to docker hub<br/>  docker_image:<br/>  name: pacur/centos-7<br/>  repository: myorg/myimage<br/>  tag: 1.1<br/>  push: yes
</pre>
<p class="mce-root">As we can see, the implementation of these tasks is actually <em>very</em> straightforward. But what about tagging and pushing to a local registry? I'm glad you asked. Let's look at how to do that:</p>
<pre>
- name: Tag a Docker Image and push to the local registry<br/>  docker_image:<br/>  name: MyCentOS<br/>  repository: localhost:5000/mycentos<br/>  tag: 1.0<br/>  push: yes
</pre>
<p>Easy, right? Finally, let's look at how to build and image from a Dockerfile and push it to a private registry. This should be simple, easy right?</p>
<p>The following example shows how an image is built from a Dockerfile:</p>
<pre>
- name: Build a Docker Image from a Dockerfile and push it to a private registry<br/>  docker_image:<br/>  path: ./test<br/>  name: registry.myorg.com/foo/test<br/>  tag: v1<br/>  push: yes
</pre>
<p class="mce-root">This task assumes you have a Dockerfile located at <kbd>./test</kbd>, and it definitely isn't rocket science.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building and archiving Docker images</h1>
                
            
            
                
<p>Building Docker images from a Dockerfile is a topic we briefly touched on in the previous section, but it deserves a bit more depth. In building a Docker image from a Dockerfile, we can leverage it later. But first, we would need a Dockerfile to make this happen. Let's look at an example of a Dockerfile and then look at how to build it using Ansible:</p>
<pre>
# This DOCKERFILE creates a docker image with Ubuntu 14.04 and Ansible installed<br/># It also executes a playbook upon startup<br/>FROM ansible/ubuntu14.04-ansible:stable<br/><br/># This Defines the location for Ansible playbooks as /srv/example<br/>ADD ansible /srv/example<br/>WORKDIR /srv/example<br/><br/># Execute Ansible with the playbook's primary entry point as myplaybook.yml<br/>RUN ansible-playbook myplaybook.yml -c local<br/>CMD ["--help"] 
</pre>
<p>This Dockerfile should look <em>very</em> familiar. In fact, it is! It's the source code we leveraged earlier to have it run an Ansible playbook at launch. Can you see where we are going with this example? Save this Dockerfile to the <kbd>/opt/test</kbd> directory and then create a playbook with the following contents:</p>
<pre class="mce-root">
---<br/>- hosts: all<br/>  remote_user: root<br/>  tasks:<br/>    - name: Build Docker Image<br/>      docker_image:<br/>      path: /opt/test<br/>      name: myimage
</pre>
<p>Now create a simple playbook in <kbd>/srv/example/myplaybook.yml</kbd> with the following content:</p>
<pre class="mce-root">
---<br/>- hosts: all<br/>  tasks:<br/>   - name: Installs nginx web server on a Docker Image<br/>     apt: pkg=nginx state=installed update_cache=true<br/>     notify:<br/>       - start nginx<br/><br/>handlers:<br/> - name: start nginx<br/>   service: name=nginx state=started
</pre>
<p>Nice. Now run the <kbd>/opt/test</kbd> Ansible playbook and see the solution build a Docker container with nginx already installed and sitting happily in the local Docker registry.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Saving and loading archived Docker images</h1>
                
            
            
                
<p>Docker provides a unique ability to share containers using tarballs. This allows developers to pass around a tarball copy of the infrastructure for inspection and manipulation. Generally, there are two distinct operations involved in archiving a Docker container (exporting/archiving and loading an archive); a Docker image is also a really straightforward task. Let's look at an example code on how to archive a Docker image:</p>
<pre>
Archiving an Image:<br/>- name: Archive A Docker Image as a TAR file<br/> docker_image:<br/> name: registry.ansible.com/foo/sinatra<br/> tag: v1<br/> archive_path: sinatra.tar
</pre>
<p>Loading an archived image can be done using the following code:</p>
<pre>
- name: Load a Docker Image from a TAR archive and push to a private registry<br/> docker_image:<br/> name: localhost:5000/foo/sinatra<br/> tag: v1<br/> push: yes<br/> load_path: sinatra.tar
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Gathering Facts About Docker Containers</h1>
                
            
            
                
<p>Facts are the bread and butter of how Ansible works and manages information about its controlled/automated systems. Facts represent data about the device and the current state. Ansible provides a set of playbook tasks that can be readily leveraged to gather facts about Docker images. Let's take a look at a couple of examples of how to accomplish this.</p>
<p>This is example 1:</p>
<pre class="mce-root">
- name: Inspect a single Docker image<br/> docker_image_facts:<br/> name: foo/centos-7
</pre>
<p>This is example 2:</p>
<pre class="mce-root">
- name: Inspect multiple Docker images<br/> docker_image_facts:<br/> name:<br/> - foo/centos-7<br/> - sinatra
</pre>
<p class="mce-root">The preceding playbook tasks inspect a single or multiple Docker image setup and report the facts. The fact data itself is stored in the return value. An example of the output is provided as follows:</p>
<pre>
[{'Container': 'e83a452b8fb8ff43oj094j4050131ca5c863629a47639530d9ad2008d610', 'Name': 'registry:2', 'Author': '', 'GraphDriver': {'Data': None, 'Name': 'aufs'}, 'Architecture': 'amd64', 'VirtualSize': 165808884, 'ContainerConfig': {'Cmd': ['/bin/sh', '-c', '#(nop) CMD ["/etc/docker/registry/config.yml"]'], 'Env': ['PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'], 'StdinOnce': False, 'Hostname': 'e5c68db50333', 'WorkingDir': '', 'Entrypoint': ['/bin/registry'], 'Volumes': {'/var/lib/registry': {}}, 'OnBuild': [], 'OpenStdin': False, 'Tty': False, 'Domainname': '', 'Image': 'c72dce2618dc8groeirgjeori444c2b1e64e0205ead5befc294f8111da23bd6a2c799', 'Labels': {}, 'ExposedPorts': {'5000/tcp': {}}, 'User': '', 'AttachStdin': False, 'AttachStderr': False, 'AttachStdout': False}, 'Os': 'linux', 'RepoTags': ['registry:2'], 'Comment': '', 'DockerVersion': '1.9.1', 'Parent': 'f0b1f729f784b755e7bf9c8c2e65d8a0a35a533769c2588f02895f6781ac0805', 'Config': {'Cmd': ['/etc/docker/registry/config.yml'], 'Env': ['PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin'], 'StdinOnce': False, 'Hostname': 'e5c68db50333', 'WorkingDir': '', 'Entrypoint': ['/bin/registry'], 'Volumes': {'/var/lib/registry': {}}, 'OnBuild': [], 'OpenStdin': False, 'Tty': False, 'Domainname': '', 'Image': 'c72dce2618dc409834095834jt4ggf5ead5befc294f8111da23bd6a2c799', 'Labels': {}, 'ExposedPorts': {'5000/tcp': {}}, 'User': '', 'AttachStdin': False, 'AttachStderr': False, 'AttachStdout': False}, 'Created': '2016-03-08T21:08:15.399680378Z', 'RepoDigests': [], 'Id': '53773d8552f07b7340958340fj32094jfd67b344141d965463a950a66e08', 'Size': 0}]<br/>
</pre>
<p>The output of the command provides a nice hash data set. This data could then be further dissected and used within playbook's.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discovered some interesting and unique ways to integrate the Ansible automation system with Docker. We learned that these two seemingly redundant technologies can be combined to provide a robust automation implementation that scales very well.</p>
<p>We also talked about how to inversely leverage Ansible playbook tasks to create, update, delete, and manage containers. Then, we covered how to attach and remove networking from these containers. You learned that even though these implementations might have looked difficult at first, they proved to be quite easy actually.</p>
<p>In the next chapter, we will take a look at how to extend Ansible and create custom modules. We will educate you on how to use Python to extend Ansible and create custom modules that integrate with unique specific technology stacks. This will be done by providing a set of tutorials that teach you how to write and release custom Ansible modules. This chapter will teach you how to read input, manage facts, perform automated tasks, interact with REST APIs, and generate documentation.</p>


            

            
        
    </body></html>