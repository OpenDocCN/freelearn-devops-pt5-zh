- en: Exploring Docker Remote API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Docker 远程 API
- en: You can mass-produce hardware; you cannot mass-produce software - you cannot
    mass-produce the human mind.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以大规模生产硬件；你不能大规模生产软件——你不能大规模生产人类的思维。
- en: –Michio Kaku
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —— Michio Kaku
- en: Up until now, we used Docker through its client. Whenever we needed something,
    the only thing we had to do is execute a `docker` command (example: `docker service
    create`). In most cases, that is enough when we are limiting ourselves to operating
    our cluster from a command line.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 直到现在，我们一直通过 Docker 客户端来使用 Docker。每当我们需要某个功能时，唯一需要做的就是执行一个`docker`命令（例如：`docker
    service create`）。在大多数情况下，当我们仅限于从命令行操作集群时，这已经足够了。
- en: What happens if we want to accomplish a functionality beyond what the client
    offers? What if we'd like to operate Docker from inside our applications? Can
    we get statistics from all the containers running on the whole cluster?
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想实现一些客户端提供的功能之外的操作会发生什么呢？如果我们希望从我们的应用程序内部操作 Docker 呢？我们能从整个集群中获取所有正在运行的容器的统计信息吗？
- en: One possible answer to those and quite a few other questions lies in the adoption
    of tools beyond those offered by Docker Inc. We'll explore quite a few of those
    in the chapters that follow.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 对这些问题以及其他许多问题的一个可能答案在于采用 Docker 公司之外的工具。我们将在接下来的章节中探讨这些工具。
- en: Another approach would be to use Docker Remote API. After all, if we choose
    one of the products of the Docker ecosystem, chances are they will use the API.
    Docker Compose uses it to issue commands to Docker engines. Even the client uses
    it to communicate with the remote engine. You might find it useful as well.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用 Docker 远程 API。毕竟，如果我们选择了 Docker 生态系统中的某个产品，它很可能会使用 API。Docker Compose
    使用它向 Docker 引擎发送命令。即使是客户端，也使用它与远程引擎进行通信。你也许会发现它很有用。
- en: By default, Docker daemon listens on `unix:///var/run/docker.sock` and the client
    must have root access to interact with the daemon. If a group named `docker` exists
    on your system, Docker applies ownership of the socket to the group. That does
    not mean that the socket is the only way to access the API. There are indeed quite
    a few others, and I encourage you to experiment with different combinations. For
    the purpose of this chapter, we'll stick with the socket since it is the easiest
    way to send API requests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 守护进程监听 `unix:///var/run/docker.sock`，并且客户端必须拥有 root 权限才能与守护进程交互。如果你的系统上存在名为
    `docker` 的组，Docker 会将套接字的所有权赋给该组。这并不意味着套接字是访问 API 的唯一方式。事实上，还有很多其他方式，我鼓励你尝试不同的组合。为了本章的目的，我们将坚持使用套接字，因为它是发送
    API 请求最简单的方式。
- en: Setting up the environment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境设置
- en: As in the previous chapters, we'll start with the creation of a cluster we'll
    use to experiment.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 就像前几章一样，我们将从创建一个我们将用来实验的集群开始。
- en: All the commands from this chapter are available in the `07-api.sh` ([https://gist.github.com/vfarcic/bab7f89f1cbd14f9895a9e0dc7293102](https://gist.github.com/vfarcic/bab7f89f1cbd14f9895a9e0dc7293102))
    Gist.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有命令都可以在 `07-api.sh` 中找到（[https://gist.github.com/vfarcic/bab7f89f1cbd14f9895a9e0dc7293102](https://gist.github.com/vfarcic/bab7f89f1cbd14f9895a9e0dc7293102)）Gist。
- en: 'Please enter the `cloud-provisioning` directory where we pulled the repository.
    Since I might have updated it since the last time you used it, we''ll issue a
    pull. Finally, we''ll run the already familiar        `script/ dm-swarm.sh` that
    will create a new Swarm cluster:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请进入我们拉取仓库的 `cloud-provisioning` 目录。由于我可能自上次你使用它之后更新过它，我们将执行一个 pull。最后，我们将运行已经熟悉的
    `script/ dm-swarm.sh`，它将创建一个新的 Swarm 集群：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The cluster is up and running.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 集群已经启动并运行。
- en: VMs created with *Docker Machine* are based on *Boot2Docker*. It is a lightweight
    Linux distribution made specifically to run Docker containers. It runs entirely
    from RAM, is a small 38 MB download, and boots in ~5s. It is based on *Tiny Core
    Linux* ([http://tinycorelinux.net/](http://tinycorelinux.net/)). What distinguishes
    it from more popular Linux distributions is its size. It is stripped down to a
    bare minimum. This approach serves us well. If we adopt containers, there is no
    real need for most of the kernel modules usually seen in distributions like Ubuntu
    and RedHat.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *Docker Machine* 创建的虚拟机基于 *Boot2Docker*。它是一个专门为运行 Docker 容器而设计的轻量级 Linux
    发行版。它完全运行在 RAM 中，下载大小仅为 38 MB，并且大约 5 秒内即可启动。它基于 *Tiny Core Linux*（[http://tinycorelinux.net/](http://tinycorelinux.net/)）。与更流行的
    Linux 发行版相比，它的区别在于体积。它被精简到最基本的程度。这种做法对我们来说非常适用。如果我们采用容器，大多数通常在像 Ubuntu 和 RedHat
    这样的发行版中看到的内核模块其实并没有必要。
- en: This is in line with the minimalistic approach we strive for when working with
    containers. I already discussed the reasons for using `Alpine` as the base image
    we use for our containers. The main one is its size (only a few MB). After all,
    why would we ship our containers with things we don't need? The same can be said
    for the hosts OS. Less is better, as long as all our needs are fulfilled.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在使用容器时追求的简约方法一致。我之前讨论了使用 `Alpine` 作为容器基础镜像的原因。最主要的原因是它的体积（仅几个 MB）。毕竟，为什么我们要将不需要的东西打包到容器中呢？主机操作系统也可以这样说。少即是多，只要满足我们的所有需求即可。
- en: There is a caveat. *Boot2Docker* is currently designed and tuned for development.
    Using it for any kind of production workloads at this time is highly discouraged.
    That does not diminish its value, but makes a clear distinction what it's good
    for, and what it's not.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个警告。*Boot2Docker* 当前设计和优化用于开发环境。在此时，强烈不建议将其用于任何生产负载。这并不削弱其价值，但明确区分了它适合做什么，不适合做什么。
- en: The reason behind this short introduction to *Boot2Docker* and Tiny Core Linux
    lies in the next steps. We're about to install a few programs, and we need to
    know the package management tool for the distribution we're using. Tiny Core Linux
    uses `tce-load`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *Boot2Docker* 和 Tiny Core Linux 的简短介绍是为了后续步骤做准备。我们即将安装一些程序，而我们需要了解所使用的发行版的包管理工具。Tiny
    Core Linux 使用 `tce-load`。
- en: In the previous chapters, we executed most of the commands from your OS (MacOS,
    Linux, or Windows). This time, we'll run them inside one of the Docker Machine
    VMs. The reason lies in `jq` ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/))
    we'll use to format JSON output we'll be receiving from the API. It is available
    on most platforms, but I thought it would be better to avoid possible problems
    by putting you inside the VM. The second and more important reason lies in the
    choice to send requests to the API through the Docker socket that is available
    on the machines.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在前几章中，我们从操作系统（MacOS、Linux 或 Windows）执行了大多数命令。这一次，我们将在 Docker Machine 虚拟机中执行这些命令。原因在于我们将使用
    `jq` ([https://stedolan.github.io/jq/](https://stedolan.github.io/jq/)) 来格式化从
    API 接收到的 JSON 输出。它在大多数平台上都可用，但我认为最好将你放入虚拟机中，以避免可能出现的问题。第二个更重要的原因是，我们选择通过机器上的 Docker
    套接字向 API 发送请求。
- en: 'Without further ado, we''ll proceed with installations of `curl` and `jq`:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 不再多说，我们将开始安装 `curl` 和 `jq`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We entered the `swarm-1` machine and used `tce-load` to install `curl` and `wget`.
    Since `jq` is not available through `tce-load`, we used `wget` to download the
    binary. Finally, we moved `jq` to the bin directory and added execute permissions.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入了 `swarm-1` 机器，并使用 `tce-load` 安装了 `curl` 和 `wget`。由于 `jq` 无法通过 `tce-load`
    获取，我们使用 `wget` 下载了二进制文件。最后，我们将 `jq` 移动到 bin 目录，并添加了执行权限。
- en: Now we're ready to start exploring Docker Remote API.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好开始探索 Docker 远程 API 了。
- en: Operating Docker Swarm through the Docker Remote API
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 Docker 远程 API 操作 Docker Swarm
- en: We won't go through the whole API. The official *documentation* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/))
    is well written and provides enough details. Instead, we'll go through some basic
    examples focused around Docker Swarm. We'll see how we can use the API by repeating
    some of the client commands we practiced earlier. The goal of this chapter is
    to get just enough knowledge to be able to use the API in your applications as
    well as a glue between different services we'll explore in the next chapters.
    Later on, we'll try to leverage this knowledge to create a monitoring system that
    stores the information about the cluster in a database and performs some actions.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细讲解整个 API。官方的 *文档* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/))
    编写得非常清晰，并提供了足够的细节。相反，我们将通过一些围绕 Docker Swarm 的基本示例来学习。我们将通过重复之前练习过的一些客户端命令来查看如何使用
    API。本章的目标是获取足够的知识，以便在应用程序中使用 API，并将其作为连接不同服务的粘合剂，我们将在后续章节中探索这些服务。之后，我们将尝试利用这些知识创建一个监控系统，将有关集群的信息存储在数据库中，并执行一些操作。
- en: Let's discuss a very simple example of a possible use case for the API.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一个非常简单的示例，展示 API 的可能使用场景。
- en: If a node fails, Swarm will make sure that the containers that were running
    inside it are rescheduled. However, that does not mean that is enough. We might
    want to send an email stating that a node failed. Upon receiving such an email,
    someone would perform an investigation of the cause of the failed node and probably
    take some corrective actions. Those tasks are not urgent since Swarm mitigated
    the problem. However, something not being urgent does not mean that it should
    not be done.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个节点出现故障，Swarm 会确保该节点内部运行的容器被重新调度。然而，这并不意味着这样就足够了。我们可能想要发送一封邮件，通知某个节点故障。收到这样的邮件后，有人将调查故障节点的原因，并可能采取一些纠正措施。这些任务并不紧急，因为
    Swarm 已经缓解了问题。然而，事情不紧急并不意味着它不应当被完成。
- en: The chapters that follow will try to make our cluster more robust, and the API
    will play a crucial role in that. For now, let's have a brief overview.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的章节将尝试让我们的集群更加强大，而 API 在其中将发挥关键作用。现在，让我们先做一个简要的概述。
- en: 'We''ll start with a simple example. Let''s see which nodes form our cluster:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的示例开始。让我们看看哪些节点构成了我们的集群：
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The output displays three nodes with detailed information for each. Showing
    all the information of all the nodes is too much for the book so let''s limit
    the output to one of the nodes. All we have to do is append the name of the node
    to the previous command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了三节点的详细信息。展示所有节点的所有信息对本书来说太多了，所以我们限制输出为一个节点。我们只需要将节点的名称附加到之前的命令后面：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The output, above, is truncated and only includes the "Leader" node. Your output
    will contain three sets of nodes that start with `ID`. We won't go into details
    of what each of the fields means. You should already be familiar with most of
    them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的输出被截断，仅包括“Leader”节点。你的输出将包含以 `ID` 开头的三个节点集合。我们不会详细讨论每个字段的含义，你应该已经熟悉大部分字段。
- en: 'Please consult *Docker Remote API v1.24: Nodes* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/nodes](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/nodes))
    for more information.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '更多信息，请参考 *Docker Remote API v1.24: 节点* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/nodes](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/nodes))。'
- en: 'The API is not limited only to queries. We can use it to perform any of the
    operations available through the Docker client (and a few more). For example,
    we can create a new service:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: API 不仅限于查询操作。我们还可以利用它执行 Docker 客户端提供的任何操作（还有一些其他操作）。例如，我们可以创建一个新服务：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We sent a `POST` request to create a service named `go-demo-db`. The image
    of the service is `mongo:3.2.10`. As a result, the API responded with the service
    `ID`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送了一个 `POST` 请求来创建一个名为 `go-demo-db` 的服务。该服务的镜像是 `mongo:3.2.10`。结果，API 返回了该服务的
    `ID`：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Please consult *Docker Remote API v1.24: Create a service* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#create-a-service](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#create-a-service))
    for more information.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '更多信息，请参考 *Docker Remote API v1.24: 创建服务* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#create-a-service](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#create-a-service))。'
- en: 'We can confirm that the operation was indeed successful by listing all the
    services:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过列出所有服务来确认操作确实成功：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output is as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We got a list of services (at the moment only one) with some of their properties.
    We can see when was the service created, the number of replicas, and so on. Please
    consult *Docker Remote API v1.24: List services *([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/list-services](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/list-services))
    for more information.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '我们获得了一个服务列表（目前只有一个），其中包含一些服务的属性。我们可以看到该服务的创建时间、副本数等信息。更多信息，请参考 *Docker Remote
    API v1.24: 列出服务* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/list-services](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#/list-services))。'
- en: 'Similarly, we can retrieve the information of a single instance:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们可以检索单个实例的信息：
- en: '[PRE9]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The output is almost the same as when we listed all services. The only significant
    difference is that, this time, we got a single result, while the list of services
    returned an array enclosed in `[ and ]`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 输出几乎与我们列出所有服务时相同。唯一的显著区别是，这次我们得到了一个单一的结果，而列出服务时返回的是一个用`[和]`括起来的数组：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Please consult *Docker Remote API v1.24: Inspect one or more services* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#inspect-one-or-more-services](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#inspect-one-or-more-services))
    for more information.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '请查阅*Docker远程API v1.24: 检查一个或多个服务*（[https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#inspect-one-or-more-services](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#inspect-one-or-more-services)）以获取更多信息。'
- en: Let's spice it up a bit and scale to three replicas. We can accomplish that
    by updating the service. However, before we send an update request, we need the
    version and ID of the service. That information is available in the output of
    the service request we sent a moment ago. However, since we are trying to do things
    in a way that is easy to automate, we might be better off putting those values
    in environment variables.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微增加点挑战，将副本数扩展到三个。我们可以通过更新服务来实现这一点。然而，在发送更新请求之前，我们需要知道服务的版本和ID。这些信息可以从我们之前发送的服务请求的输出中获得。不过，由于我们希望以便于自动化的方式执行操作，可能更好将这些值放入环境变量中。
- en: We can use `jq` to filter the output and return a particular value.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`jq`来过滤输出并返回特定的值。
- en: 'The command that returns the version of the service is as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 返回服务版本的命令如下：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the variable `$VERSION` is as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`$VERSION`变量的输出如下：'
- en: '[PRE12]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Similarly, we should retrieve the service `ID` as well:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们还应该获取服务的`ID`：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now we have all the information we need to update the service. We''ll change
    the number of replicas to three:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有更新服务所需的所有信息。我们将副本数更改为三个：
- en: '[PRE15]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Please consult *Docker Remote API v1.24: Update a service* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#update-a-service](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#update-a-service))
    for more information.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '请查阅*Docker远程API v1.24: 更新服务*（[https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#update-a-service](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#update-a-service)）以获取更多信息。'
- en: 'Next, we can list the `tasks` and confirm whether the service was indeed scaled
    to three instances:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以列出`tasks`并确认服务是否真的扩展到三个实例：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The output is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE17]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you can see, three tasks were returned, each representing one replica of
    the `go-demo-db` service.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，返回了三个任务，每个任务代表`go-demo-db`服务的一个副本。
- en: 'Please consult *Docker Remote API v1.24: List tasks *([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#list-tasks](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#list-tasks))
    for more information.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '请查阅*Docker远程API v1.24: 列出任务*（[https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#list-tasks](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#list-tasks)）以获取更多信息。'
- en: All the API requests we made so far were related to nodes and services. In some
    cases, we might need to go lower and use the API on a container level. For example,
    we might want to get statistics related to a single container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所做的所有API请求都与节点和服务有关。在某些情况下，我们可能需要更深入地使用容器级别的API。例如，我们可能想获取与单个容器相关的统计信息。
- en: Before we proceed, please make sure that the state of all the tasks is running.
    Feel free to repeat the `http:/tasks` request to confirm the state. If it's not
    running, please wait for a while and check it again.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保所有任务的状态都是“正在运行”。可以随时重复`http:/tasks`请求来确认状态。如果它没有运行，请稍等片刻再检查。
- en: 'To get stats of a container, first we need to find out on which node it is
    running:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取容器的统计信息，首先我们需要找出它运行在哪个节点上：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We exited the `swarm-1` machine and used eval to create environment variables
    that instructed the Docker client running on our host to use the engine running
    on `swarm-1`. Please note that those environment variables are telling the client
    to use the same API we've been exploring throughout this chapter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们退出了`swarm-1`机器，并使用eval命令创建了环境变量，指示主机上运行的Docker客户端使用在`swarm-1`上运行的引擎。请注意，这些环境变量告诉客户端使用我们在本章中探讨的相同API。
- en: Further on, we retrieved the node where one of the containers forming the `go-demo-db`
    service is running. We already used a similar command a couple of times, so there's
    no need explaining it in more detail.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步地，我们检索了一个容器所在的节点，这个容器是`go-demo-db`服务的一部分。我们已经使用过类似的命令几次，所以无需再详细解释。
- en: 'The output of the `$NODE` variable is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`$NODE`变量的输出如下：'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: On my laptop, the container we're looking for is running inside the `swarm-2`
    node. In your case, it might be a different one.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的笔记本电脑上，我们正在寻找的容器运行在 `swarm-2` 节点内。在你的情况下，它可能是另一个节点。
- en: 'Now we can enter the node and get the `ID` of the container:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以进入节点并获取容器的 `ID`：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The output of the `ID` variable is as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ID` 变量的输出如下：'
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Finally, we are ready to get the statistics. The command is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备获取统计信息。命令如下：
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As soon as the request is sent, you will see a constant stream of statistics.
    Please press *CTRL* + *C* to stop the stream when you get tired looking at it.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦请求发送，你将看到不断流动的统计信息。当你看腻了时，请按 *CTRL* + *C* 停止流式传输。
- en: Streaming stats might be a very useful feature if we would like to implement
    our own monitoring solution. In many other cases, we might want to disable streaming
    and retrieve only a single recordset. We can accomplish that by setting the `stream`
    parameter to `false`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想实现自己的监控解决方案，流式统计可能是一个非常有用的功能。在许多其他情况下，我们可能希望禁用流式传输，只检索单个记录集。我们可以通过将 `stream`
    参数设置为 `false` 来实现这一点。
- en: 'The command that returns a single stats recordset is as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 返回单个统计记录集的命令如下：
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The output is still too big to be presented in the book, so you have to inspect
    it from your screen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 输出仍然太大，无法在书中展示，因此你需要从自己的屏幕上查看。
- en: We won't go into details of what each field from stats means. You'll have to
    wait until we reach the monitoring chapter for deeper exploration. For now, the
    important thing to note is that you can retrieve them for each container inside
    your cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细探讨每个统计字段的含义。你需要等到我们进入监控章节时才能深入探讨。目前，重要的是要注意，你可以为集群中的每个容器检索这些统计信息。
- en: As an exercise, create a script that retrieves all the containers running on
    the node. Iterate through each to get stats of all the containers running inside
    that VM.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，创建一个脚本，检索节点上运行的所有容器。遍历每个容器以获取该虚拟机内所有容器的统计信息。
- en: 'Please consult *Docker Remote API v1.24: Get container stats based on resource
    usage* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#get-container-stats-based-on-resource-usage](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#get-container-stats-based-on-resource-usage))
    for more information.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '请参阅 *Docker Remote API v1.24: 根据资源使用情况获取容器统计信息* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#get-container-stats-based-on-resource-usage](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#get-container-stats-based-on-resource-usage))
    了解更多信息。'
- en: 'We are almost finished with the exploration of basic API requests related to
    Swarm services so let''s remove the service we created:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经快完成与 Swarm 服务相关的基本 API 请求的探索了，现在让我们删除我们创建的服务：
- en: '[PRE24]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We sent the `DELETE` request to remove the `go-demo-db` service followed with
    the request to retrieve all services. The output of the later is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发送了 `DELETE` 请求以删除 `go-demo-db` 服务，随后发送了请求以检索所有服务。后者的输出如下：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Our service is no more. We removed it from the cluster and, since that was the
    only one we created, the request to retrieve the list of services returned an
    empty array `[]`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的服务已经不存在了。我们将其从集群中删除，且由于这是我们创建的唯一服务，请求返回了一个空的数组 `[]`。
- en: 'Please consult *Docker Remote API v1.24: Remove a service* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#remove-a-service](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#remove-a-service))
    for more information.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '请参阅 *Docker Remote API v1.24: 删除服务* ([https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#remove-a-service](https://docs.docker.com/engine/reference/api/docker_remote_api_v1.24/#remove-a-service))
    了解更多信息。'
- en: 'Finally, let''s get out of the machine:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们退出机器：
- en: '[PRE26]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now that you have a basic understanding of the API, we can explore one possible
    use case.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你对 API 有了基本了解，我们可以探索一个可能的用例。
- en: Using Docker Remote API to automate proxy configuration
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker Remote API 自动化代理配置
- en: Up until now, we were sending reconfigure and remove requests to our proxy.
    That greatly simplified the configuration. Instead of changing HAProxy config
    ourselves, we let the service reconfigure itself. We used Consul to persist the
    state of the proxy. Can we improve the existing design by leveraging Docker Remote
    API? I think we can.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直向代理发送重新配置和删除请求。这大大简化了配置。我们不再自己修改 HAProxy 配置，而是让服务自行重新配置。我们使用 Consul
    来持久化代理的状态。我们能否通过利用 Docker Remote API 改进现有设计？我认为我们可以。
- en: Instead of sending reconfigure and remove requests, we can have a service that
    would monitor the cluster state through the API. Such a tool could detect new
    and removed services and send the same request to the `proxy` like the one we
    would send manually.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 不再发送重新配置和删除请求，我们可以有一个服务来通过API监视集群状态。这样的工具可以检测新创建和删除的服务，并向`proxy`发送与我们手动发送的相同请求。
- en: We can go even further. Since the API allows us to retrieve any information
    related to the cluster, we don't need to store it in Consul anymore. Whenever
    a new instance of the service is created, it can retrieve all the information
    it needs from the API.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以走得更远。由于API允许我们检索与集群相关的任何信息，我们不再需要将其存储在Consul中。每当创建服务的新实例时，它可以从API中检索所需的所有信息。
- en: All in all, we can use the API to fully automate changes to the `proxy` configuration
    as well as its state. We can create a new service that will monitor the cluster
    state. We can also modify the `proxy` to consult that service during its initialization.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，我们可以利用API完全自动化对`proxy`配置及其状态的更改。我们可以创建一个新的服务来监视集群状态。我们还可以修改`proxy`以在其初始化过程中查询该服务。
- en: I thought to save you some time by taking the liberty to create such a service.
    The project behind it is called *Docker Flow Swarm Listener *([https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener)).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我考虑节省您的一些时间，因此擅自创建了这样一个服务。它背后的项目称为*Docker Flow Swarm Listener* ([https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener))。
- en: Let's see it in action.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它的工作情况。
- en: Combining the Swarm listener with the proxy
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Swarm监听器与代理结合使用
- en: The *Docker Flow Swarm Listener* ([https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener))
    project leverages Docker Remote API. It has many usages but, for now, we'll limit
    ourselves to the features that can help make our proxy configuration fully hands-free.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Flow Swarm Listener* ([https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener))
    项目利用了Docker Remote API。它有很多用途，但现在我们将限制在可以帮助我们完全无需手动操作来配置代理的功能上。'
- en: 'We''ll start by creating two networks:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建两个网络：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We created those two networks so many times that there is no reason to go over
    their usefulness. The only difference is that this time, we'll have one more service
    to attach to the `proxy` network.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了这两个网络很多次了，没有理由再去讨论它们的有用性。唯一的区别是，这次我们将有一个更多的服务附加到`proxy`网络。
- en: Next, we'll create the `swarm-listener` ([https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener))
    service. It will act as a companion to the Docker Flow Proxy. Its purpose is to
    monitor Swarm services and send requests to the proxy whenever a service is created
    or destroyed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建`swarm-listener` ([https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener))
    服务。它将作为Docker Flow Proxy的伴侣。其目的是监视Swarm服务并在创建或销毁服务时向代理发送请求。
- en: '**A note to Windows users**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows用户请注意**'
- en: 'Git Bash has a habit of altering file system paths. To stop this, execute the
    following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: Git Bash有改变文件系统路径的习惯。要停止这个行为，请执行以下操作：
- en: '`export MSYS_NO_PATHCONV=1`'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`export MSYS_NO_PATHCONV=1`'
- en: 'Let''s create the `swarm-listener` service:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建`swarm-listener`服务：
- en: '[PRE28]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The service is attached to the `proxy` network, mounts the Docker socket, and
    declares the environment variables `DF_NOTIF_CREATE_SERVICE_URL` and `DF_NOTIF_REMOVE_SERVICE_URL`.
    We'll see the purpose of those variables soon. The service is constrained to the
    manager nodes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务附加到`proxy`网络，挂载Docker套接字，并声明环境变量`DF_NOTIF_CREATE_SERVICE_URL`和`DF_NOTIF_REMOVE_SERVICE_URL`。我们很快将看到这些变量的用途。该服务受限于管理节点。
- en: 'The next step is to create the `proxy` service:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建`proxy`服务：
- en: '[PRE29]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: We opened ports `*80*` and `*443*`. External requests will be routed through
    them towards destination services. Please note that this time, we did not open
    port `8080`. Since the `proxy` will be receiving notifications from the `swarm-listener`,
    there is no need for having `8080` available for manual notifications.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们打开了`*80*`和`*443*`端口。外部请求将通过它们路由到目标服务。请注意，这次我们没有打开`8080`端口。由于`proxy`将从`swarm-listener`接收通知，因此无需为手动通知保留`8080`端口。
- en: The `proxy` is attached to the `proxy` network and has the mode set to swarm.
    The `proxy` must belong to the same network as the listener. They will exchange
    information whenever a service is created or removed as well as when a new instance
    of the `proxy` is created.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`proxy`连接到`proxy`网络，并将模式设置为swarm。`proxy`必须与监听器属于同一网络。它们将在每次创建或删除服务时以及每次创建新的`proxy`实例时交换信息。'
- en: Automatically reconfiguring the proxy
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动重新配置代理
- en: 'Let''s create the already familiar demo services:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建已经熟悉的示例服务：
- en: '[PRE30]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Please note the labels. We did not have them in the previous chapters. Things
    changed and now they are a crucial part of the service definition. The `com.df.notify=true`
    tells the `swarm-listener`  service whether to send notifications whenever a service
    is created or removed. Since we don't want to add the `go-demo-db` service to
    the `proxy`, the label is defined only for the `go-demo` service. The rest of
    the labels match the query arguments we would use if we'd reconfigure the proxy
    manually. The only difference is that the labels are prefixed with `com.df`. For
    the list of the query arguments, please see the *Reconfigure* ([https://github.com/vfarcic/docker-flow-proxy#reconfigure](https://github.com/vfarcic/docker-flow-proxy#reconfigure))
    section of the project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意标签。在前面的章节中我们没有使用它们。情况发生了变化，现在它们已成为服务定义中的关键部分。`com.df.notify=true`告诉`swarm-listener`服务是否在服务被创建或删除时发送通知。由于我们不想将`go-demo-db`服务添加到`proxy`中，因此该标签仅定义在`go-demo`服务上。其余的标签与我们手动重新配置代理时使用的查询参数相匹配。唯一的区别是，这些标签前缀为`com.df`。有关查询参数的列表，请参阅项目中的*重新配置* ([https://github.com/vfarcic/docker-flow-proxy#reconfigure](https://github.com/vfarcic/docker-flow-proxy#reconfigure))部分。
- en: 'Now we should wait until all the services are running. You can see their status
    by executing the command that follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该等待所有服务都在运行。您可以通过执行以下命令来查看它们的状态：
- en: '[PRE31]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once all the replicas are set to `1/1`, we can see the effect of the `com.df`
    labels by sending a request to the `go-demo` service through the `proxy`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有副本都设置为`1/1`，我们可以通过向`proxy`发送请求来看到`com.df`标签的效果，该请求会通过`proxy`访问`go-demo`服务：
- en: '[PRE32]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The output is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We sent a request to the `proxy` (the only service listening to the port `80`)
    and got back the response from the `go-demo` service. The `proxy` was configured
    automatically as soon as the `go-demo` service was created.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向`proxy`发送了一个请求（唯一监听端口`80`的服务），并收到了来自`go-demo`服务的响应。`proxy`在`go-demo`服务创建时自动进行了配置。
- en: 'The way the process works is as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程的工作方式如下：
- en: '*Docker Flow Swarm Listener* is running inside one of the Swarm manager nodes
    and queries Docker API in search of newly created services. Once it finds a new
    service, it looks for its labels. If the service contains the label `com.df.notify`
    (it can hold any value), the rest of the labels with keys starting with `com.df`.
    are retrieved. All those labels are used to form request parameters. Those parameters
    are appended to the address specified as the `DF_NOTIF_CREATE_SERVICE_URL` environment
    variable defined in the `swarm-listener` service. Finally, a request is sent.
    In this particular case, the request was made to reconfigure the `proxy` with
    the service `go-demo` (the name of the service), using `/demo` as the path, and
    running on the port `808`0\. The distribute label is not necessary in this example
    since we''re running only a single instance of the `proxy`. However, in production,
    we should run at least two `proxy` instances (for fault tolerance) and the distribute
    argument means that reconfiguration should be applied to all.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Flow Swarm Listener*运行在一个Swarm管理节点内，并查询Docker API以寻找新创建的服务。一旦找到新服务，它会查找其标签。如果服务包含`com.df.notify`标签（它可以包含任何值），则会获取所有其他以`com.df`开头的标签。这些标签将用于形成请求参数。这些参数会附加到作为`DF_NOTIF_CREATE_SERVICE_URL`环境变量定义在`swarm-listener`服务中的地址上。最后，发送请求。在这个特定的例子中，请求是为了使用`go-demo`（服务名称）重新配置`proxy`，路径为`/demo`，并且运行在端口`8080`上。分发标签在这个例子中不是必须的，因为我们只运行了一个`proxy`实例。然而，在生产环境中，我们应该至少运行两个`proxy`实例（以实现容错），而分发参数意味着该重新配置应应用于所有实例。'
- en: Please see the *Reconfigure* ([https://github.com/vfarcic/docker-flow-proxy#reconfigure](https://github.com/vfarcic/docker-flow-proxy#reconfigure))
    section for the list of all the arguments that can be used with the proxy.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请参见*重新配置* ([https://github.com/vfarcic/docker-flow-proxy#reconfigure](https://github.com/vfarcic/docker-flow-proxy#reconfigure))部分，查看可以与代理一起使用的所有参数列表。
- en: Removing a service from the proxy
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从代理中移除服务
- en: 'Since `swarm-listener` is monitoring `docker` services, if a service is removed,
    related entries in the `proxy` configuration will be removed as well:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`swarm-listener`正在监控`docker`服务，如果删除了一个服务，相关的`proxy`配置条目也将被删除：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'If you were to check the Swarm Listener logs in the same way you would check
    logs for any other container service, you''d see an entry similar to the one that
    follows:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您像检查任何其他容器服务的日志一样检查Swarm Listener的日志，您将看到类似以下条目的一个条目：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'A moment later, a new entry would appear in the `proxy` logs:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 不久之后，`proxy`日志中会出现一个新条目：
- en: '[PRE36]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: From this moment on, the service `go-demo` is not available through the proxy.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，服务`go-demo`将无法通过代理访问。
- en: Swarm Listener detected that the service was removed, sent a notification to
    the `proxy` which, in turn, changed its configuration and reloaded the underlying
    HAProxy.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Swarm Listener检测到服务已被移除，向`proxy`发送了一个通知，`proxy`进而改变其配置并重新加载底层的HAProxy。
- en: What now?
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在怎么办？
- en: Apart from the potential utility of having a proxy that is configured automatically
    whenever a service is created or removed, `swarm-listener` shows how useful it
    is to leverage the Docker Remote API. If you have your own needs that are not
    fully covered with Docker or one of the tools in its ecosystem, it is relatively
    easy to write your own service on top of the API. The truth is that, at the time
    this chapter was written, the Swarm Mode is only a couple of months old, and there
    aren’t many third party tools that can be used to fine tune or extend its behavior.
    Even if you find all the tools that do more or less what you need, it’s still
    a good idea to write a bit of code yourself and switch from more or less to exactly
    what you need.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在每次创建或删除服务时自动配置代理的潜在实用性之外，`swarm-listener`显示了利用Docker远程API的有用性。如果您有自己的需求，而Docker或其生态系统中的工具尚未完全满足您的需求，编写自己的服务并不是很困难。事实上，在撰写本章时，Swarm模式只有几个月的历史，并且没有太多第三方工具可以用来微调或扩展其行为。即使您找到了几乎满足您需求的所有工具，编写一些自定义代码以确切地满足您的需求仍然是个好主意。
- en: I encourage you to fire up your favorite editor and write a service in your
    programming language of choice. You can monitor services and send yourself an
    email whenever a member of your team creates or removes one. Or you can integrate
    statistics with your favorite monitoring tool.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我鼓励您启动您最喜欢的编辑器，并用您选择的编程语言编写一个服务。您可以监控服务，并在您的团队成员创建或删除服务时发送电子邮件给自己。或者您可以将统计数据集成到您最喜欢的监控工具中。
- en: If you are out of ideas for your own service and you're not afraid of *Go *([https://golang.org/](https://golang.org/)),
    you might try extending *Docker Flow Swarm Listener *([https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener)).
    Fork it, add a new feature, and make a pull request.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对自己的服务已经没有了新的想法，并且你不怕*Go*（[https://golang.org/](https://golang.org/)），那么你可以尝试扩展*Docker
    Flow Swarm Listener*（[https://github.com/vfarcic/docker-flow-swarm-listener](https://github.com/vfarcic/docker-flow-swarm-listener)）。分叉它，添加一个新功能，并提交一个拉取请求。
- en: Remember, learning is golden. If the only outcome is that you learned something,
    that's already pretty good. If it turns up to be useful, even better.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，学习是金贵的。如果您学到了一些东西，那已经非常不错了。如果证明是有用的，那就更好了。
- en: We reached the end of the chapter, and you already know the drill. We'll destroy
    the machines we created and start anew.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到了本章的结尾，您已经了解了程序。我们将销毁我们创建的机器并重新开始。
- en: '[PRE37]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
