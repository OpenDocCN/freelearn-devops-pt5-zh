- en: '*Chapter 6*: Clustering with Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, in this book, we have covered the fundamental aspects of the acceptance
    testing process. In this chapter, we will see how to change the Docker environment
    from a single Docker host into a cluster of machines and how to change an independent
    application into a system composed of multiple applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Server clustering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes installation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application dependencies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative cluster management systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the instructions in this chapter, you''ll need the following
    hardware/software requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: At least 4 GB of RAM
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At least 1 GB of free disk space
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java JDK 8+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the examples and solutions to the exercises in this chapter can be found
    in this book's GitHub repository at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter06).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3rcffcz](https://bit.ly/3rcffcz).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: Server clustering
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have interacted with each of the machines individually. What we did
    was connect to the `localhost` Docker daemon server. We could have used the `-H`
    option in the `docker run` command to specify the address of the remote Docker,
    but that would still mean deploying our application to a single Docker host machine.
    In real life, however, if servers share the same physical location, we are not
    interested in which particular machine the service is deployed in. All we need
    is to have it accessible and replicated in many instances to support high availability.
    *How can we configure a set of machines to work that way?* This is the role of
    clustering.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: In the following subsections, you will be introduced to the concept of server
    clustering and the Kubernetes environment, which is an example of cluster management
    software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Introducing server clustering
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A server cluster is a set of connected computers that work together in such
    a way that they can be used similarly to a single system. Servers are usually
    connected through the local network by a connection that''s fast enough to ensure
    that the services that are being run are distributed. A simple server cluster
    is presented in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Server clustering'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_06_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.1 – Server clustering
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: A user accesses the cluster through a master host, which exposes the cluster
    API. There are multiple nodes that act as computing resources, which means that
    they are responsible for running applications. The master, on the other hand,
    is responsible for all other activities, such as the orchestration process, service
    discovery, load balancing, and node failure detection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Kubernetes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is an open source cluster management system that was originally designed
    by Google. Looking at the popularity charts, it is a clear winner among other
    competitors, such as Docker Swarm and Apache Mesos. Its popularity has grown so
    fast that most cloud platforms provide Kubernetes out of the box. It's not Docker-native,
    but there are a lot of additional tools and integrations to make it work smoothly
    with the whole Docker ecosystem; for example, **kompose** can translate Docker
    Compose files into Kubernetes configurations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个开源的集群管理系统，最初由 Google 设计。从流行度的图表来看，它在其他竞争者（如 Docker Swarm 和 Apache
    Mesos）中遥遥领先。它的流行度增长非常迅速，以至于大多数云平台都直接提供 Kubernetes。它不是 Docker 原生的，但有许多附加工具和集成可以使其与整个
    Docker 生态系统顺畅配合；例如，**kompose** 可以将 Docker Compose 文件转换为 Kubernetes 配置。
- en: Information
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In the first edition of this book, I recommended Docker Compose and Docker Swarm
    for application dependency resolution and server clustering. While they're both
    good tools, Kubernetes' popularity has grown so high recently that I decided to
    use Kubernetes as the recommended approach and keep Docker-native tooling as an
    alternative.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，我推荐使用 Docker Compose 和 Docker Swarm 来解决应用依赖关系和服务器集群问题。虽然这两个工具都很好，但
    Kubernetes 最近的流行度如此之高，以至于我决定将 Kubernetes 作为推荐的方法，并将 Docker 原生工具作为替代方案。
- en: 'Let''s take a look at the simplified architecture of Kubernetes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看简化版的 Kubernetes 架构：
- en: '![Figure 6.2 – Simplified Kubernetes architecture'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 简化版 Kubernetes 架构'
- en: '](img/B18223_06_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_02.jpg)'
- en: Figure 6.2 – Simplified Kubernetes architecture
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 简化版 Kubernetes 架构
- en: The Kubernetes `8080`) and the control plane is responsible for making it happen.
    A Kubernetes Node, on the other hand, is a worker. You may see it just as a (Docker)
    container host with a special Kubernetes process (called `kubelet`) installed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes `8080`) 和控制平面负责实现这一目标。另一方面，Kubernetes 节点是一个工作节点。你可以把它看作是一个（Docker）容器主机，安装了一个特殊的
    Kubernetes 进程（称为 `kubelet`）。
- en: From the user's perspective, you provide a declarative deployment configuration
    in the form of a YAML file and pass it to the Kubernetes control plane through
    its API. Then, the control plane reads the configuration and installs the deployment.
    Kubernetes introduces the concept of a **Pod**, which represents a single deployment
    unit. The Pod contains Docker **containers**, which are scheduled together. While
    you can put multiple containers into a single Pod, in real-life scenarios, you
    will see that most Pods contain just a single Docker container. Pods are dynamically
    built and removed depending on the requirement changes that are expressed in the
    YAML configuration updates.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，你提供一个声明式的部署配置，形式为 YAML 文件，并通过其 API 将该文件传递给 Kubernetes 控制平面。然后，控制平面读取配置并安装部署。Kubernetes
    引入了 **Pod** 的概念，表示一个单独的部署单元。Pod 包含 Docker **容器**，这些容器一起调度。虽然你可以将多个容器放入一个 Pod，但在实际场景中，大多数
    Pod 通常只包含一个 Docker 容器。Pods 会根据 YAML 配置文件更新中表达的需求变化动态创建和删除。
- en: You will gain more practical knowledge about Kubernetes in later sections of
    this chapter, but first, let's name the features that make Kubernetes such a great
    environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后续部分，你将获得更多关于 Kubernetes 的实际知识，但首先，让我们列举出使 Kubernetes 成为如此出色的环境的一些特性。
- en: Kubernetes features overview
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 特性概述
- en: 'Kubernetes provides a number of interesting features. Let''s walk through the
    most important ones:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了许多有趣的特性。让我们来看看其中最重要的一些：
- en: '**Container balancing**: Kubernetes takes care of the load balancing of Pods
    on nodes; you specify the number of replicas of your application and Kubernetes
    takes care of the rest.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器负载均衡**：Kubernetes 负责 Pods 在节点上的负载均衡；你指定应用副本的数量，Kubernetes 会处理其余部分。'
- en: '**Traffic load balancing**: When you have multiple replicas of your application,
    the Kubernetes service can load balance the traffic. In other words, you create
    a service with a single IP (or DNS) and Kubernetes takes care of load balancing
    the traffic to your application replicas.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量负载均衡**：当你有多个应用副本时，Kubernetes 服务可以进行流量负载均衡。换句话说，你创建一个具有单一 IP（或 DNS）的服务，Kubernetes
    会处理将流量负载均衡到你的应用副本。'
- en: '**Dynamic horizontal scaling**: Each deployment can be dynamically scaled up
    or down; you specify the number of application instances (or the rules for autoscaling)
    and Kubernetes starts/stops Pod replicas.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态水平扩展**：每个部署可以动态地进行扩展或缩减；你指定应用实例的数量（或自动扩展的规则），Kubernetes 会启动/停止 Pod 副本。'
- en: '**Failure recovery**: Pods (and nodes) are constantly monitored and if any
    of them fail, new Pods are started so that the declared number of replicas is
    constant.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障恢复**：Pods（和节点）会持续被监控，如果其中任何一个失败，新的 Pods 会被启动，以确保声明的副本数保持不变。'
- en: '**Rolling updates**: An update to the configuration can be applied incrementally;
    for example, if we have 10 replicas and we would like to make a change, we can
    define a delay between the deployment to each replica. In such a case, when anything
    goes wrong, we never end up with a scenario where a replica isn''t working correctly.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动更新**：配置的更新可以逐步应用；例如，如果我们有 10 个副本并希望进行更改，可以在每个副本的部署之间定义一个延迟。在这种情况下，当出现问题时，我们永远不会遇到副本无法正常工作的情况。'
- en: '**Storage orchestration**: Kubernetes can mount a storage system of your choice
    to your applications. Pods are stateless in nature and, therefore, Kubernetes
    integrates with a number of storage providers, such as Amazon **Elastic Block
    Storage** (**EBS**), **Google Compute Engine** (**GCE**) Persistent Disk, and
    Azure Data Storage.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储编排**：Kubernetes 可以将你选择的存储系统挂载到你的应用程序上。Pod 是无状态的，因此 Kubernetes 与多个存储提供商集成，例如
    Amazon **Elastic Block Storage** (**EBS**)、**Google Compute Engine** (**GCE**)
    持久磁盘和 Azure 数据存储。'
- en: '**Service discovery**: Kubernetes Pods are ephemeral in nature and their IPs
    are dynamically assigned, but Kubernetes provides DNS-based service discovery
    for this.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：Kubernetes Pods 本质上是短暂的，它们的 IP 动态分配，但 Kubernetes 提供了基于 DNS 的服务发现机制。'
- en: '**Run everywhere**: Kubernetes is an open source tool, and you have a lot of
    options of how to run it: on-premises, cloud infrastructure, or hybrid.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随处运行**：Kubernetes 是一个开源工具，你可以选择多种方式来运行它：本地部署、云基础设施或混合部署。'
- en: Now that we have some background about Kubernetes, let's see what it all looks
    like in practice, starting with the installation process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对 Kubernetes 有了一些背景了解，接下来让我们看看它在实践中的表现，从安装过程开始。
- en: Kubernetes installation
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 安装
- en: 'Kubernetes, just like Docker, consists of two parts: the client and the server.
    The client is a command-line tool named `kubectl` and it connects to the server
    part using the Kubernetes API. The server is much more complex and is as we described
    in the previous section. Obviously, to do anything with Kubernetes, you need both
    parts, so let''s describe them one by one, starting with the client.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 就像 Docker 一样，由两部分组成：客户端和服务器端。客户端是一个名为`kubectl`的命令行工具，它通过 Kubernetes
    API 连接到服务器端。服务器端要复杂得多，正如我们在上一节所描述的那样。显然，要使用 Kubernetes 执行任何操作，你需要这两部分，因此我们将逐一描述它们，从客户端开始。
- en: Kubernetes client
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 客户端
- en: 'The Kubernetes client, `kubectl`, is a command-line application that allows
    you to perform operations on the Kubernetes cluster. The installation process
    depends on your operating system. You can check out the details on the official
    Kubernetes website: [https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 客户端 `kubectl` 是一个命令行应用程序，允许你对 Kubernetes 集群执行操作。安装过程取决于你的操作系统。你可以在
    Kubernetes 官方网站上查看详细信息：[https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)。
- en: 'After you have successfully installed `kubectl`, you should be able to execute
    the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功安装了 `kubectl` 之后，你应该能够执行以下命令：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that you have the Kubernetes client configured, we can move on to the server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了 Kubernetes 客户端，我们可以继续设置服务器部分。
- en: Kubernetes server
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 服务器
- en: There are multiple ways to set up a Kubernetes server. Which one you should
    use depends on your needs, but if you are completely new to Kubernetes, then I
    recommend starting from a local environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Kubernetes 服务器有多种方式。你应该使用哪种方式取决于你的需求，但如果你完全是 Kubernetes 的新手，我建议从本地环境开始。
- en: Local environment
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地环境
- en: Even though Kubernetes itself is a complex clustering system, there are a few
    tools that can simplify your local development setup. Let's walk through the options
    you have, which include Docker Desktop, kind, and minikube.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Kubernetes 本身是一个复杂的集群系统，但有一些工具可以简化你的本地开发环境。让我们逐一了解你可以使用的选项，包括 Docker Desktop、kind
    和 minikube。
- en: Docker Desktop
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Docker Desktop is an application that is used to set up a local Docker environment
    on macOS or Windows. As you may remember from the previous chapters, the Docker
    daemon can only run natively on Linux, so for other operating systems, you need
    to get it running on a VM. Docker Desktop provides a super-intuitive way to do
    this, and luckily, it also supports the creation of Kubernetes clusters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop是一个应用程序，用于在macOS或Windows上设置本地Docker环境。如你从前面的章节中可能记得，Docker守护进程只能在Linux上本地运行，因此在其他操作系统上，你需要在虚拟机上运行它。Docker
    Desktop提供了一种超级直观的方式来实现这一点，幸运的是，它还支持创建Kubernetes集群。
- en: 'If you have Docker Desktop installed, then all you need to do is check the
    `kubectl` will be configured:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已安装Docker Desktop，那么你需要做的就是检查`kubectl`是否已配置：
- en: '![Figure 6.3 – Kubernetes in Docker Desktop'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 在Docker Desktop中使用Kubernetes'
- en: '](img/B18223_06_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_03.jpg)'
- en: Figure 6.3 – Kubernetes in Docker Desktop
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 在Docker Desktop中使用Kubernetes
- en: Starting from this point, you are ready to use the Kubernetes cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你已经准备好使用Kubernetes集群了。
- en: kind
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: kind
- en: If you use the Linux operating system and can't, or just don't want to, use
    Docker Desktop, then your second simplest option is **kind** (short for **Kubernetes
    in Docker**). It's a tool for which the only requirement is to have Docker installed
    and configured.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Linux操作系统，并且不能或不想使用Docker Desktop，那么你第二简单的选择是**kind**（即**Kubernetes in
    Docker**的缩写）。它是一个工具，唯一的要求是安装并配置Docker。
- en: 'After installing kind, you can start and configure your local Kubernetes cluster
    with this one command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完kind后，你可以通过以下一条命令启动并配置本地Kubernetes集群：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Information
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can check the kind installation steps at [https://kind.sigs.k8s.io/docs/user/quick-start/](https://kind.sigs.k8s.io/docs/user/quick-start/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看kind的安装步骤，网址是[https://kind.sigs.k8s.io/docs/user/quick-start/](https://kind.sigs.k8s.io/docs/user/quick-start/)。
- en: minikube
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: minikube
- en: minikube is a command-line tool that starts a fully functional Kubernetes environment
    inside a VM. It is backed up by a VM hypervisor, so you need to have VirtualBox,
    Hyper-V, VMware, or a similar tool installed. The instructions to install minikube
    depend on your operating system, and you can find instructions for each at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: minikube是一个命令行工具，可以在虚拟机内启动一个功能完备的Kubernetes环境。它由虚拟机监控程序支持，因此你需要安装VirtualBox、Hyper-V、VMware或类似的工具。安装minikube的说明取决于你的操作系统，你可以在[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)找到每个操作系统的安装指南。
- en: Information
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: minikube is an open source tool that you can find on GitHub at [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: minikube是一个开源工具，你可以在GitHub上找到它，网址是[https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)。
- en: 'After you have successfully installed minikube, you can start your Kubernetes
    cluster with the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功安装minikube后，你可以通过以下命令启动Kubernetes集群：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: minikube starts a Kubernetes cluster and automatically configures your Kubernetes
    client with the cluster URL and credentials, so you can move directly to the *Verifying
    the Kubernetes setup* section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: minikube启动一个Kubernetes集群，并自动配置你的Kubernetes客户端，包含集群URL和凭证，这样你就可以直接进入*验证Kubernetes配置*部分。
- en: Cloud platforms
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云平台
- en: Kubernetes has become so popular that most cloud computing platforms provide
    it as a service. The leader here is **Google Cloud Platform** (**GCP**), which
    allows you to create a Kubernetes cluster within a few minutes. Other cloud platforms,
    such as Microsoft Azure, **Amazon Web Services** (**AWS**), and IBM Cloud, also
    have Kubernetes in their portfolios. Let's take a closer look at the three most
    popular solutions—**GCP**, **Azure**, and **AWS**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes已经变得非常流行，几乎所有的云计算平台都将其作为一项服务提供。这里的领导者是**Google Cloud Platform**（**GCP**），它允许你在几分钟内创建一个Kubernetes集群。其他云平台，如Microsoft
    Azure、**Amazon Web Services**（**AWS**）和IBM Cloud，也将Kubernetes纳入其产品组合。让我们仔细看看三大最受欢迎的解决方案——**GCP**、**Azure**和**AWS**。
- en: Google Cloud Platform
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Google Cloud Platform
- en: You can access GCP at [https://cloud.google.com/](https://cloud.google.com/).
    After creating an account, you should be able to open their web console ([https://console.cloud.google.com](https://console.cloud.google.com)).
    One of the services in their portfolio is called **Google Kubernetes Engine**
    (**GKE**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问GCP，网址是[https://cloud.google.com/](https://cloud.google.com/)。创建账户后，你应该能够打开他们的Web控制台（[https://console.cloud.google.com](https://console.cloud.google.com)）。他们的产品组合中有一个服务叫做**Google
    Kubernetes Engine**（**GKE**）。
- en: You can create a Kubernetes cluster by clicking in the user interface or by
    using the GCP command-line tool, called `gcloud`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击用户界面或使用 GCP 命令行工具`gcloud`来创建 Kubernetes 集群。
- en: Information
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'You can read how to install `gcloud` on your operating system at the official
    GCP website: [https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方 GCP 网站上查看如何在你的操作系统上安装 `gcloud`：[https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install)。
- en: 'To create a Kubernetes cluster using the command-line tool, it''s enough to
    execute the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行工具创建 Kubernetes 集群，只需执行以下命令：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Apart from creating a Kubernetes cluster, it automatically configures `kubectl`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建 Kubernetes 集群外，它还会自动配置`kubectl`。
- en: Microsoft Azure
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 微软 Azure
- en: Microsoft Azure also offers a very quick Kubernetes setup thanks to **Azure
    Kubernetes Service** (**AKS**). Like GCP, you can use either a web interface or
    a command-line tool to create a cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Azure 还通过**Azure Kubernetes 服务**（**AKS**）提供了一个非常快速的 Kubernetes 设置。像 GCP 一样，你可以使用
    web 界面或命令行工具来创建集群。
- en: Information
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can access the Azure web console at [https://portal.azure.com/](https://portal.azure.com/).
    To install the Azure command-line tool, check the installation guide on their
    official page at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问 Azure Web 控制台：[https://portal.azure.com/](https://portal.azure.com/)。要安装
    Azure 命令行工具，请查看其官方网站的安装指南：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)。
- en: 'To create a Kubernetes cluster using the Azure command-line tool, assuming
    you already have an Azure resource group created, it''s enough to run the following
    command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Azure 命令行工具创建 Kubernetes 集群，假设你已经创建了一个 Azure 资源组，只需运行以下命令：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After a few seconds, your Kubernetes cluster should be ready. To configure
    `kubectl`, run the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你的 Kubernetes 集群应该准备就绪。要配置 `kubectl`，运行以下命令：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By doing this, you will have successfully set up a Kubernetes cluster and configured
    `kubectl`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你将成功设置一个 Kubernetes 集群并配置好 `kubectl`。
- en: Amazon Web Services
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 亚马逊网络服务
- en: AWS provides a managed Kubernetes service called Amazon **Elastic Kubernetes
    Service** (**EKS**). You can start using it by accessing the AWS web console at
    [https://console.aws.amazon.com/eks](https://console.aws.amazon.com/eks) or using
    the AWS command-line tool.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 提供了一种托管的 Kubernetes 服务，称为 Amazon **弹性 Kubernetes 服务**（**EKS**）。你可以通过访问 AWS
    Web 控制台：[https://console.aws.amazon.com/eks](https://console.aws.amazon.com/eks)
    或使用 AWS 命令行工具开始使用它。
- en: Information
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'You can check all the information (and the installation guide) for the AWS
    command-line tool at its official website: [https://docs.aws.amazon.com/cli/](https://docs.aws.amazon.com/cli/).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 AWS 命令行工具的官方网站查看所有信息（包括安装指南）：[https://docs.aws.amazon.com/cli/](https://docs.aws.amazon.com/cli/)。
- en: As you can see, using Kubernetes in the cloud is a relatively simple option.
    Sometimes, however, you may need to install an on-premises Kubernetes environment
    from scratch on your own server machines. Let's discuss this in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用云中的 Kubernetes 是一个相对简单的选择。然而，有时你可能需要从头开始在自己的服务器上安装本地 Kubernetes 环境。我们将在下一节讨论这个问题。
- en: On-premises
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地部署
- en: Installing Kubernetes from scratch on your own servers makes sense if you don't
    want to depend on cloud platforms or if your corporate security policies don't
    allow it. The installation process is relatively complex and out of the scope
    of this book, but you can find all the details in the official documentation at
    [https://kubernetes.io/docs/setup/production-environment/](https://kubernetes.io/docs/setup/production-environment/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想依赖云平台，或者你的公司安全政策不允许使用云平台，那么从头开始在自己的服务器上安装 Kubernetes 是有意义的。安装过程相对复杂，超出了本书的范围，但你可以在官方文档中找到所有细节：[https://kubernetes.io/docs/setup/production-environment/](https://kubernetes.io/docs/setup/production-environment/)。
- en: Now that we have the Kubernetes environment configured, we can check that `kubectl`
    is connected to the cluster correctly and that we are ready to start deploying
    our applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了 Kubernetes 环境，可以检查 `kubectl` 是否已正确连接到集群，并准备好开始部署应用程序。
- en: Verifying the Kubernetes setup
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 Kubernetes 配置
- en: 'No matter which Kubernetes server installation you choose, you should already
    have everything configured and the Kubernetes client should be filled with the
    cluster''s URL and credentials. You can check this with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种Kubernetes服务器安装方式，你应该已经完成所有配置，并且Kubernetes客户端应该已经填充了集群的URL和凭证。你可以通过以下命令来检查：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the output for the Docker Desktop scenario and is why you can see `localhost`.
    Your output may be slightly different and may include more entries. If you see
    no errors, then everything is correct, and we can start using Kubernetes to run
    applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Docker Desktop场景下的输出，正因如此你能看到`localhost`。你的输出可能略有不同，且可能包含更多条目。如果没有看到错误信息，那么一切都是正确的，我们可以开始使用Kubernetes来运行应用程序。
- en: Using Kubernetes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes
- en: We have the whole Kubernetes environment ready and `kubectl` configured. This
    means that it's high time to finally present the power of Kubernetes and deploy
    our first application. Let's use the `leszko/calculator` Docker image that we
    built in the previous chapters and start it in multiple replicas on Kubernetes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了整个Kubernetes环境，并配置了`kubectl`。这意味着是时候展示Kubernetes的强大功能，部署我们的第一个应用程序了。我们将使用前几章中构建的`leszko/calculator`
    Docker镜像，并在Kubernetes上启动多个副本。
- en: Deploying an application
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: 'In order to start a Docker container on Kubernetes, we need to prepare a deployment
    configuration as a YAML file. Let''s name it `deployment.yaml`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Kubernetes上启动Docker容器，我们需要准备一个部署配置文件，格式为YAML。我们将其命名为`deployment.yaml`：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this YAML configuration, we have to ensure the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个YAML配置中，我们需要确保以下几点：
- en: We have defined a Kubernetes resource of the `Deployment` type from the `apps/v1`
    Kubernetes API version.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了一个类型为`Deployment`的Kubernetes资源，使用的是`apps/v1` Kubernetes API版本。
- en: The unique deployment name is `calculator-deployment`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的部署名称是`calculator-deployment`。
- en: We have defined that there should be exactly `3` of the same Pods created.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了应该创建正好`3`个相同的Pod。
- en: '`selector` defines how `Deployment` finds Pods to manage, in this case, just
    by the label.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selector`定义了`Deployment`如何找到需要管理的Pod，在这个例子中，仅通过标签来进行查找。'
- en: '`template` defines the specification for each created Pod.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`template`定义了每个创建的Pod的规格。'
- en: 'Each Pod is labeled with `app: calculator`.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '每个Pod都被标记为`app: calculator`。'
- en: Each Pod contains a Docker container named `calculator`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个Pod都包含一个名为`calculator`的Docker容器。
- en: A Docker container was created from the image called `leszko/calculator`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从名为`leszko/calculator`的镜像创建了一个Docker容器。
- en: The Pod exposes container port `8080`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该Pod暴露了容器端口`8080`。
- en: 'To install the deployment, run the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装部署，请运行以下命令：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can check that the three Pods, each containing one Docker container, have
    been created:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查是否已经创建了包含一个Docker容器的三个Pod：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Each Pod runs a Docker container. We can check its logs by using the following
    command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod都运行一个Docker容器。我们可以使用以下命令来检查它的日志：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should see the familiar Spring logo and the logs of our Calculator web service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到熟悉的Spring logo和我们Calculator web服务的日志。
- en: Information
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'To look at an overview of `kubectl` commands, please check out the official
    guide: [https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`kubectl`命令的概述，请查看官方指南：[https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/)。
- en: We have just performed our first deployment to Kubernetes, and with just a few
    lines of code, we have three replicas of our Calculator web service application.
    Now, let's see how we can use the application we deployed. For this, we'll need
    to understand the concept of a Kubernetes Service.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了第一次Kubernetes部署，通过几行代码，我们创建了三个副本的Calculator web服务应用程序。现在，让我们看看如何使用我们部署的应用程序。为此，我们需要了解Kubernetes
    Service的概念。
- en: Deploying a Kubernetes Service
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Kubernetes Service
- en: Each Pod has an IP address in the internal Kubernetes network, which means that
    you can already access each Calculator instance from another Pod running in the
    same Kubernetes cluster. But *how do we access our application from the outside?*
    That is the role of a Kubernetes Service.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod在Kubernetes内部网络中都有一个IP地址，这意味着你已经可以从同一Kubernetes集群中运行的其他Pod访问每个Calculator实例。但是，*我们如何从外部访问我们的应用程序呢？*
    这正是Kubernetes Service的作用。
- en: 'The idea of Pods and Services is that Pods are mortal—they get terminated,
    and then they get restarted. The Kubernetes orchestrator only cares about the
    right number of Pod replicas, not about the Pod''s identity. That''s why, even
    though each Pod has an (internal) IP address, we should not stick to it or use
    it. Services, on the other hand, act as a frontend for Pods. They have IP addresses
    (and DNS names) that can be used. Let''s look at the following diagram, which
    presents the idea of a Pod and Service:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 和 Service 的概念是，Pod 是有生命的——它们会被终止，然后重新启动。Kubernetes 调度器只关心正确数量的 Pod 副本，而不是
    Pod 的身份。这就是为什么，即使每个 Pod 都有一个（内部）IP 地址，我们也不应该依赖它或使用它。而 Service 则充当 Pod 的前端。它们有可供使用的
    IP 地址（和 DNS 名称）。让我们看一下以下图示，展示了 Pod 和 Service 的概念：
- en: '![Figure 6.4 – Kubernetes Pod and Service'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – Kubernetes Pod 和 Service'
- en: '](img/B18223_06_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_04.jpg)'
- en: Figure 6.4 – Kubernetes Pod and Service
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – Kubernetes Pod 和 Service
- en: Pods are physically placed on different nodes, but you don't have to worry about
    this since Kubernetes takes care of the right orchestration and introduces the
    abstraction of a Pod and Service. The user accesses the Service, which load balances
    the traffic between the Pod replicas. Let's look at an example of how to create
    a service for our Calculator application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 实际上分布在不同的节点上，但您不需要担心这一点，因为 Kubernetes 会处理正确的调度，并引入 Pod 和 Service 的抽象。用户访问
    Service，Service 会在 Pod 副本之间进行流量负载均衡。让我们看一个如何为我们的计算器应用创建服务的示例。
- en: 'Just like we did for the Deployment, we start from a YAML configuration file.
    Let''s name it `service.yaml`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为部署所做的一样，我们从一个 YAML 配置文件开始。我们将其命名为 `service.yaml`：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a configuration for a simple service that load balances the traffic
    to all the Pods that meet the criteria we mentioned in `selector`. To install
    the service, run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的服务配置，它将流量负载均衡到所有符合我们在 `selector` 中提到的条件的 Pod。要安装该服务，请运行以下命令：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can then check that the service was correctly deployed by running the following
    command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过运行以下命令来检查服务是否已正确部署：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To check that the service points to the three Pod replicas we created in the
    previous section, run the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查该服务是否指向我们在上一节中创建的三个 Pod 副本，请运行以下命令：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the last two commands we ran, we can see that the service is available
    under the IP address of `10.19.248.154` and that it load balances the traffic
    to three Pods with the IPs of `10.16.1.5`, `10.16.2.6`, and `10.16.2.7`. All of
    these IP addresses, for both the Service and Pod, are internal to the Kubernetes
    cluster network.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们运行的最后两条命令中，我们可以看到该服务在 `10.19.248.154` 的 IP 地址下可用，并将流量负载均衡到三个 IP 地址分别为 `10.16.1.5`、`10.16.2.6`
    和 `10.16.2.7` 的 Pod。所有这些 IP 地址，无论是服务还是 Pod，都是 Kubernetes 集群网络内部的。
- en: Information
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: To read more about Kubernetes Services, please visit the official Kubernetes
    website at [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Kubernetes 服务的信息，请访问 Kubernetes 官方网站：[https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)。
- en: In the next section, we'll take a look at how to access a service from outside
    the Kubernetes cluster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何从 Kubernetes 集群外部访问服务。
- en: Exposing an application
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 曝露应用
- en: 'To understand how your application can be accessed from the outside, we need
    to start with the types of Kubernetes Services. You can use four different service
    types, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解您的应用如何从外部访问，我们需要从 Kubernetes 服务类型开始。您可以使用四种不同的服务类型，如下所示：
- en: '**ClusterIP (default)**: The service has an internal IP only.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterIP（默认）**：该服务仅具有内部 IP 地址。'
- en: '`<NODE-IP>:<NODE-PORT>`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<NODE-IP>:<NODE-PORT>`。'
- en: '**LoadBalancer**: Creates an external load balancer and assigns a separate
    external IP for the service. Your Kubernetes cluster must support external load
    balancers, which works fine in the case of cloud platforms, but may not work if
    you use minikube.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadBalancer**：创建一个外部负载均衡器，并为该服务分配一个单独的外部 IP 地址。您的 Kubernetes 集群必须支持外部负载均衡器，在云平台中通常没有问题，但如果您使用
    minikube，可能无法正常工作。'
- en: '`externalName` in the spec).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalName` 在规格说明中）。'
- en: If you use a Kubernetes instance that's been deployed on a cloud platform (for
    example, GKE), then the simplest way to expose your service is to use `kubectl
    get service` command. If we had used it in our configuration, then you could have
    accessed the Calculator service at `http://<EXTERNAL-IP>:8080`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是部署在云平台上的 Kubernetes 实例（例如，GKE），那么暴露服务的最简单方法是使用 `kubectl get service`
    命令。如果我们在配置中使用了它，那么你就可以通过 `http://<EXTERNAL-IP>:8080` 访问 Calculator 服务。
- en: 'While LoadBalancer seems to be the simplest solution, it has two drawbacks:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 LoadBalancer 似乎是最简单的解决方案，但它有两个缺点：
- en: First, it's not always available, for example, if you deployed on-premises Kubernetes
    or used minikube.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它并不总是可用的，例如，如果你在本地部署了 Kubernetes 或使用了 minikube。
- en: Second, external public IPs are usually expensive. A different solution is to
    use a `NodePort` service, as we did in the previous section.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，外部公共 IP 通常比较昂贵。另一种解决方案是使用 `NodePort` 服务，正如我们在前面一节中所做的那样。
- en: Now, let's see how we can access our service.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何访问我们的服务。
- en: 'We can repeat the same command we ran already:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复我们已经执行过的相同命令：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that port `32259` was selected as a node port. This means that we
    can access our Calculator service using that port and the IP of any of the Kubernetes
    nodes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到端口 `32259` 被选作节点端口。这意味着我们可以通过该端口和任何 Kubernetes 节点的 IP 来访问我们的 Calculator
    服务。
- en: 'The IP address of your Kubernetes node depends on your installation. If you
    used Docker Desktop, then your node IP is `localhost`. In the case of minikube,
    you can check it with the `minikube ip` command. In the case of cloud platforms
    or the on-premises installation, you can check the IP addresses with the following
    command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Kubernetes 节点的 IP 地址取决于你的安装方式。如果你使用的是 Docker Desktop，那么你的节点 IP 是 `localhost`。如果是
    minikube，你可以通过 `minikube ip` 命令来查看它。在云平台或本地安装的情况下，你可以使用以下命令查看 IP 地址：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To check that you can access Calculator from the outside, run the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你是否能从外部访问 Calculator，请运行以下命令：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We made an HTTP request to one of our Calculator container instances and it
    returned the right response, which means that we successfully deployed the application
    on Kubernetes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向其中一个 Calculator 容器实例发出了 HTTP 请求，它返回了正确的响应，这意味着我们已经成功地在 Kubernetes 上部署了应用程序。
- en: Tip
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 小提示
- en: 'The `kubectl` command offers a shortcut to create a service without using YAML.
    Instead of the configuration we used, you could just execute the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 命令提供了一种快捷方式，可以在不使用 YAML 的情况下创建服务。你可以执行以下命令，而不是使用我们之前的配置：'
- en: '`$ kubectl expose deployment calculator-deployment --type=NodePort --name=calculator-service`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl expose deployment calculator-deployment --type=NodePort --name=calculator-service`。'
- en: What we've just learned gives us the necessary basics about Kubernetes. We can
    now use it for the staging and production environments and, therefore, include
    it in the continuous delivery process. Before we do so, however, let's look at
    a few more Kubernetes features that make it a great and useful tool.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学到的内容为我们提供了 Kubernetes 的必要基础。现在我们可以将其用于暂存和生产环境，从而将其纳入持续交付过程。然而，在我们这么做之前，让我们再看看一些使
    Kubernetes 成为一个伟大且有用工具的其他功能。
- en: Advanced Kubernetes
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Kubernetes
- en: Kubernetes provides a way to dynamically modify your deployment during runtime.
    This is especially important if your application is already running in production
    and you need to support zero-downtime deployments. First, let's look at how to
    scale up an application and then present the general approach Kubernetes takes
    on any deployment changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一种在运行时动态修改部署的方法。这一点尤其重要，如果你的应用程序已经在生产环境中运行，并且你需要支持零停机时间的部署。首先，让我们看看如何扩展应用程序，然后介绍
    Kubernetes 在任何部署更改中的通用方法。
- en: Scaling an application
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Let's imagine that our Calculator application is getting popular. People have
    started using it and the traffic is so high that the three Pod replicas are overloaded.
    *What can we do now?*
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的 Calculator 应用程序开始流行起来。人们开始使用它，流量大到三个 Pod 副本都超载了。*我们现在该怎么办？*
- en: 'Luckily, `kubectl` provides a simple way to scale up and down deployments using
    the `scale` keyword. Let''s scale our Calculator deployment to `5` instances:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`kubectl` 提供了一种简单的方法来使用 `scale` 关键字扩展和缩减部署。让我们将我们的 Calculator 部署扩展到 `5`
    个实例：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That''s it, our application is now scaled up:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的应用程序现在已经扩展：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that, from now on, the service we created load balances the traffic to
    all `5` Calculator Pods. Also, note that you don't even need to wonder about which
    physical machine each Pod runs on, since this is covered by the Kubernetes orchestrator.
    All you have to think about is your desired number of application instances.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes also provides a way to autoscale your Pods, depending on its metrics.
    This feature is called the **HorizontalPodAutoscaler**, and you can read more
    about it at [https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: We have just seen how we can scale applications. Now, let's take a more generic
    look at how to update any part of a Kubernetes deployment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Updating an application
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes takes care of updating your deployments. Let''s make a change to
    `deployment.yaml` and add a new label to the Pod template:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we repeat this and apply the same deployment, we can observe what happens
    with the Pods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see that Kubernetes terminated all the old Pods and started the new ones.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: In our example, we modified the deployment of the YAML configuration, not the
    application itself. However, modifying the application is actually the same. If
    we make any change to the source code of the application, we need to build a new
    Docker image with the new version and then update this version in `deployment.yaml`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Every time you change something and run `kubectl apply`, Kubernetes checks whether
    there is any change between the existing state and the YAML configuration, and
    then, if needed, it performs the update operation we described previously.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: This is all well and good, but if Kubernetes suddenly terminates all Pods, we
    may end up in a situation where all the old Pods are already killed and none of
    the new Pods are ready yet. This would make our application unavailable for a
    moment. *How do we ensure zero-downtime deployments?* That's the role of rolling
    updates.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Rolling updates
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A rolling update entails incrementally terminating old instances and starting
    new ones. In other words, the workflow is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Terminate one of the old Pods.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new Pod.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait until the new Pod is ready.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat *step 1* until all old instances are replaced.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Information
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The concept of a rolling update works correctly only if the new application
    version is backward compatible with the old application version. Otherwise, we
    risk having two different incompatible versions at the same time.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To configure it, we need to add the `RollingUpdate` strategy to our deployment
    and specify `readinessProbe`, which makes Kubernetes aware when the Pod is ready.
    Let''s modify `deployment.yaml`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s explain the parameters we used in our configuration:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '`maxUnavailable`: The maximum number of Pods that can be unavailable during
    the update process; in our case, Kubernetes won''t terminate at the same time
    when there''s more than one Pod (*75%* ** 5* desired replicas).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`maxSurge`: The maximum number of Pods that can be created over the desired
    number of Pods; in our case, Kubernetes won''t create any new Pods before terminating
    an old one.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`path` and `port`: The endpoint of the container to check for readiness; an
    HTTP `GET` request is sent to `<POD-IP>:8080/sum?a=1&b=2` and when it finally
    returns `200` as the HTTP status code, the Pod is marked as *ready*.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By modifying the `maxUnavailable` and `maxSurge` parameters, we can decide whether
    Kubernetes first starts new Pods and later terminates old ones or, as we did in
    our case, first terminates old Pods and later starts new ones.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now apply the deployment and observe that the Pods are updated one by
    one:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That's it, we have just configured a rolling update for our Calculator deployment,
    which means that we can provide zero-downtime releases.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes also provides a different way of running applications. You can use
    `StatefulSet` instead of `Deployment`, and then the rolling update is always enabled
    (even without specifying any additional strategy).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: Rolling updates are especially important in the context of continuous delivery,
    because if we deploy very often, then we definitely can't afford any downtime.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'After playing with Kubernetes, it''s good to perform the cleanup to remove
    all the resources we created. In our case, we can execute the following commands
    to remove the service and deployment we created:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '`$ kubectl delete -f service.yaml`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: '`$ kubectl delete -f deployment.yaml`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We've already presented all the Kubernetes features that are needed for the
    continuous delivery process. Let's look at a short summary and add a few words
    about other useful features.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes objects and workloads
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The execution unit in Kubernetes is always a Pod, which contains one or more
    (Docker) containers. There are multiple different resource types to orchestrate
    Pods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployment**: This is the most common workload, which manages the life cycle
    of the desired number of replicated Pods.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**StatefulSet**: This is a specialized Pod controller that guarantees the ordering
    and uniqueness of Pods. It is usually associated with data-oriented applications
    (in which it''s not enough to say, *my desired number of replicas is 3*, as in
    the case of a Deployment, but rather, *I want exactly 3 replicas, with always
    the same predictable Pod names, and always started in the same order*).'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DaemonSet**: This is a specialized Pod controller that runs a copy of a Pod
    on each Kubernetes node.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Job/CronJob**: This is a workflow that''s dedicated to task-based operations
    in which containers are expected to exist successfully.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You may also find a Kubernetes resource called **ReplicationController**, which
    is deprecated and has been replaced by Deployment.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Apart from Pod management, there are other Kubernetes objects. The most useful
    ones that you may often encounter are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
- en: '**Service**: A component that acts as an internal load balancer for Pods.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ConfigMap**: This decouples configuration from the image content; it can
    be any data that''s defined separately from the image and then mounted onto the
    container''s filesystem.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secret**: This allows you to store sensitive information, such as passwords.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PersistentVolume/PersistentVolumeClaim**: These allow you to mount a persistent
    volume into a (stateless) container''s filesystem.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually, there are many more objects available, and you can even create your
    own resource definitions. However, the ones we've mentioned here are the most
    frequently used in practice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: We already have a good understanding of clustering in Kubernetes, but Kubernetes
    isn't just about workloads and scaling. It can also help with resolving dependencies
    between applications. In the next section, we will approach this topic and describe
    application dependencies in the context of Kubernetes and the continuous delivery
    process.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Application dependencies
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Life is easy without dependencies. In real life, however, almost every application
    links to a database, cache, messaging system, or another application. In the case
    of (micro) service architecture, each service needs a bunch of other services
    to do its work. The monolithic architecture does not eliminate the issue—an application
    usually has some dependencies, at least to the database.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a newcomer joining your development team; *how much time does it take
    to set up the entire development environment and run the application with all
    its dependencies?*
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to automated acceptance testing, the dependencies issue is no
    longer only a matter of convenience—it becomes a necessity. While, during unit
    testing, we could mock the dependencies, the acceptance testing suite requires
    a complete environment. *How do we set it up quickly and in a repeatable manner?*
    Luckily, Kubernetes can help thanks to its built-in DNS resolution for Services
    and Pods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes DNS resolution
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s present the Kubernetes DNS resolution with a real-life scenario. Let''s
    say we would like to deploy a caching service as a separate application and make
    it available for other services. One of the best in-memory caching solutions is
    Hazelcast, so let''s use it here. In the case of the Calculator application, we
    need `Deployment` and `Service`. Let''s define them both in one file, `hazelcast.yaml`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similar to what we did previously for the Calculator application, we will now
    define the Hazelcast configuration. Let''s start it in the same way:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After a few seconds, the Hazelcast caching application should start. You can
    check its Pod logs with the `kubectl logs` command. We also created a service
    of a default type (`ClusterIP`, which is only exposed inside the same Kubernetes
    cluster).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: So far, so good—we did nothing different from what we've already seen in the
    case of the Calculator application. Now comes the most interesting part. Kubernetes
    provides a way of resolving a service IP using the service name. What's even more
    interesting is that we know the `Service` name upfront—in our case, it's always
    `hazelcast`. So, if we use this as the cache address in our application, the dependency
    will be automatically resolved.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Actually, Kubernetes DNS resolution is even more powerful, and it can resolve
    Services in a different Kubernetes namespace. Read more at [https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: Before we show you how to implement caching inside the Calculator application,
    let's take a moment to overview the system we will build.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Multiapplication system overview
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We already have the Hazelcast server deployed on Kubernetes. Before we modify
    our Calculator application so that we can use it as a caching provider, let''s
    take a look at a diagram of the complete system we want to build:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Sample multiapplication deployment'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_06_05.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.5 – Sample multiapplication deployment
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: The user uses the `hazelcast`). The **Hazelcast Service** redirects to the **Hazelcast
    Pod**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: If you look at the diagram, you can see that we have just deployed the Hazelcast
    part (**Hazelcast Service** and **Hazelcast Pod**). We also deployed the Calculator
    part (**Calculator Service** and **Calculator Pod**) in the previous section.
    The final missing part is the Calculator code to use Hazelcast. Let's implement
    it now.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Multiapplication system implementation
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement caching with Hazelcast in our Calculator application, we need
    to do the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Add the Hazelcast client library to Gradle.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the Hazelcast cache configuration.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add Spring Boot caching.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build a Docker image.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's proceed step by step.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Hazelcast client library to Gradle
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `build.gradle` file, add the following configuration to the `dependencies`
    section:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This adds the Java libraries that take care of communication with the Hazelcast
    server.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Hazelcast cache configuration
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Add the following parts to the `src/main/java/com/leszko/calculator/CalculatorApplication.java`
    file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a standard Spring cache configuration. Note that for the Hazelcast server
    address, we use `hazelcast`, which is automatically available thanks to the Kubernetes
    DNS resolution.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: In real life, if you use Hazelcast, you don't even need to specify the service
    name, since Hazelcast provides an autodiscovery plugin dedicated to the Kubernetes
    environment. Read more at [https://docs.hazelcast.com/hazelcast/latest/deploy/deploying-in-kubernetes.html](https://docs.hazelcast.com/hazelcast/latest/deploy/deploying-in-kubernetes.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: We also need to remove the Spring context test automatically created by Spring
    Initializr, `src/test/java/com/leszko/calculator/CalculatorApplicationTests.java`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add caching to the Spring Boot service.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Adding Spring Boot caching
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that the cache is configured, we can finally add caching to our web service.
    In order to do this, we need to change the `src/main/java/com/leszko/calculator/Calculator.java`
    file so that it looks as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We added the `@Cacheable` annotation to make Spring automatically cache every
    call of the `sum()` method. We also added sleeping for 3 seconds, just for the
    purpose of testing, so that we could see that the cache works correctly.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: From now on, the sum calculations are cached in Hazelcast, and when we call
    the `/sum` endpoint of the Calculator web service, it will first try to retrieve
    the result from the cache. Now, let's build our application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Building a Docker image
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the next step, we need to remove the Spring default context test, `src/test/java/com/leszko/calculator/CalculatorApplicationTests.java`
    (to avoid failing because of the missing Hazelcast dependency).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can rebuild the Calculator application and the Docker image with a
    new tag. Then, we will push it to Docker Hub once more:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Obviously, you should change `leszko` to your Docker Hub account.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The application is ready, so let's test it all together on Kubernetes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Multiapplication system testing
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We should already have the Hazelcast caching server deployed on Kubernetes.
    Now, let''s change the deployment for the Calculator application to use the `leszko/calculator:caching`
    Docker image. You need to modify `image` in the `deployment.yaml` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, apply the Calculator deployment and service:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s repeat the `curl` operation we did before:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first time you execute it, it should reply in 3 seconds, but all subsequent
    calls should be instant, which means that caching works correctly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re interested, you can also check the logs of the Calculator Pod. You
    should see some logs there that confirm that the application is connected to the
    Hazelcast server:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '`Members [1] {`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '`Member [10.16.2.15]:5701 - 3fca574b-bbdb-4c14-ac9d-73c45f56b300`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: You can probably already see how we could perform acceptance testing on a multicontainer
    system. All we need is an acceptance test specification for the whole system.
    Then, we could deploy the complete system into the Kubernetes staging environment
    and run a suite of acceptance tests against it. We'll talk about this in more
    detail in [*Chapter 8*](B18223_08_ePub.xhtml#_idTextAnchor218), *Continuous Delivery
    Pipeline*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: In our example, the dependent service was related to caching, which doesn't
    really change the functional acceptance tests we created in [*Chapter 5*](B18223_05_ePub.xhtml#_idTextAnchor133),
    *Automated Acceptance Testing*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: That's all we need to know about how to approach dependent applications that
    are deployed on the Kubernetes cluster in the context of continuous delivery.
    Nevertheless, before we close this chapter, let's write a few words about Kubernetes'
    competitors, that is, other popular cluster management systems.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: Alternative cluster management systems
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes is not the only system that can be used to cluster Docker containers.
    Even though it's currently the most popular one, there may be some valid reasons
    to use different software. Let's walk through the alternatives.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Swarm is a native clustering system for Docker that turns a set of Docker
    hosts into one consistent cluster, called a **swarm**. Each host connected to
    the swarm plays the role of a manager or a worker (there must be at least one
    manager in a cluster). Technically, the physical location of the machines does
    not matter; however, it's reasonable to have all Docker hosts inside one local
    network; otherwise, managing operations (or reaching a consensus between multiple
    managers) can take a significant amount of time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: Since Docker 1.12, Docker Swarm is natively integrated into Docker Engine in
    swarm mode. In older versions, it was necessary to run the swarm container on
    each of the hosts to provide the clustering functionality.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram, which presents the terminology and the
    Docker Swarm clustering process:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – Docker Swarm'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_06_06.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.6 – Docker Swarm
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: In Docker Swarm mode, a running image is called a **Service**, as opposed to
    a **container**, which is run on a single Docker host. One service runs a specified
    number of **tasks**. A task is an atomic scheduling unit of the swarm that holds
    the information about the container and the command that should be run inside
    the container. A **replica** is each container that is run on the node. The number
    of replicas is the expected number of all containers for the given service.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: We start by specifying a service, the Docker image, and the number of replicas.
    The manager automatically assigns tasks to worker nodes. Obviously, each replicated
    container is run from the same Docker image. In the context of the presented flow,
    Docker Swarm can be viewed as a layer on top of the Docker Engine mechanism that
    is responsible for container orchestration.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Information
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: In the first edition of this book, Docker Swarm was used for all the examples
    that were provided. So, if Docker Swarm is your clustering system of choice, you
    may want to read the first edition.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Another alternative to Kubernetes is Apache Mesos. Let's talk about it now.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Apache Mesos
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apache Mesos is an open source scheduling and clustering system that was started
    at the University of California, Berkeley, in 2009, long before Docker emerged.
    It provides an abstraction layer over CPU, disk space, and RAM. One of the great
    advantages of Mesos is that it supports any Linux application, but not necessarily
    (Docker) containers. This is why it's possible to create a cluster out of thousands
    of machines and use it for both Docker containers and other programs, for example,
    Hadoop-based calculations.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the following diagram, which presents the Mesos architecture:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.7 – Apache Mesos'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_06_07.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
- en: Figure 6.7 – Apache Mesos
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: 'Apache Mesos, similar to other clustering systems, has the master-slave architecture.
    It uses node agents that have been installed on every node for communication,
    and it provides two types of schedulers:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '**Chronos**: For cron-style repeating tasks'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marathon**: To provide a REST API to orchestrate services and containers'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache Mesos is very mature compared to other clustering systems, and it has
    been adopted in a large number of organizations, such as Twitter, Uber, and CERN.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Comparing features
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Kubernetes, Docker Swarm, and Mesos are all good choices for the cluster management
    system. All of them are free and open source, and all of them provide important
    cluster management features, such as load balancing, service discovery, distributed
    storage, failure recovery, monitoring, secret management, and rolling updates.
    All of them can also be used in the continuous delivery process without huge differences.
    This is because, in the Dockerized infrastructure, they all address the same issue—the
    clustering of Docker containers. Nevertheless, the systems are not exactly the
    same. Let''s take a look at the following table, which presents the differences:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18223_06_Table_1.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
- en: Obviously, apart from Kubernetes, Docker Swarm, and Apache Mesos, there are
    other clustering systems available on the market. Especially in the era of cloud
    platforms, there are very popular platform-specific systems, for example, Amazon
    **Elastic Container Service** (**ECS**). The good news is that if you understand
    the idea of clustering Docker containers, then using another system won't be difficult
    for you.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we took a look at the clustering methods for Docker environments
    that allow you to set up complete staging and production environments. Let''s
    go over some of the key takeaways from this chapter:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: Clustering is a method of configuring a set of machines in a way that, in many
    respects, can be viewed as a single system.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes is the most popular clustering system for Docker.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes consists of the Kubernetes server and the Kubernetes client (`kubectl`).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes server can be installed locally (through minikube or Docker Desktop),
    on the cloud platform (AKS, GKE, or EKS), or manually on a group of servers. Kubernetes
    uses YAML configurations to deploy applications.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes provides features such as scaling and rolling updates out of the
    box.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes provides DNS resolution, which can help when you're deploying systems
    that consist of multiple dependent applications.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The most popular clustering systems that support Docker are Kubernetes, Docker
    Swarm, and Apache Mesos.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will describe the configuration management part of the
    continuous delivery pipeline.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have covered Kubernetes and the clustering process in detail.
    In order to enhance this knowledge, we recommend the following exercises:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a `hello world` application on the Kubernetes cluster:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `hello world` application can look exactly the same as the one we described
    in the exercises for [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034), *Introducing
    Docker*.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the application with three replicas.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Expose the application with the `NodePort` service.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a request (using `curl`) to the application.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement a new feature, *Goodbye World!*, and deploy it using a rolling update:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This feature can be added as a new endpoint, `/bye`, which always returns *Goodbye
    World!*.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Rebuild a Docker image with a new version tag.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `RollingUpdate` strategy and `readinessProbe`.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the rolling update procedure.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Make a request (using `curl`) to the application.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Questions
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To verify your knowledge from this chapter, please answer the following questions:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: What is a server cluster?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a Kubernetes control plane and Kubernetes Node?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least three cloud platforms that provide a Kubernetes environment out
    of the box.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between a Kubernetes deployment and service?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the Kubernetes command for scaling deployments?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least two cluster management systems other than Kubernetes.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To find out more about Kubernetes, please refer to the following resources:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes official documentation**: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nigel Poulton: The Kubernetes Book** ([https://leanpub.com/thekubernetesbook](https://leanpub.com/thekubernetesbook))'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
