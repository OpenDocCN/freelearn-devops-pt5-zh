- en: '*Chapter 6*: Clustering with Kubernetes'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第6章*: 使用Kubernetes进行集群管理'
- en: So far, in this book, we have covered the fundamental aspects of the acceptance
    testing process. In this chapter, we will see how to change the Docker environment
    from a single Docker host into a cluster of machines and how to change an independent
    application into a system composed of multiple applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，本书已涵盖了验收测试过程的基础知识。本章中，我们将看到如何将Docker环境从单一Docker主机转换为一组机器的集群，以及如何将独立的应用程序变为由多个应用程序组成的系统。
- en: 'This chapter covers the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Server clustering
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器集群
- en: Introducing Kubernetes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Kubernetes
- en: Kubernetes installation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes安装
- en: Using Kubernetes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kubernetes
- en: Advanced Kubernetes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级Kubernetes
- en: Application dependencies
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序依赖关系
- en: Alternative cluster management systems
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代的集群管理系统
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the instructions in this chapter, you''ll need the following
    hardware/software requirements:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，您需要满足以下硬件/软件要求才能跟随本章中的说明进行操作：
- en: At least 4 GB of RAM
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少4 GB的RAM
- en: At least 1 GB of free disk space
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少1 GB的可用磁盘空间
- en: Java JDK 8+
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Java JDK 8+
- en: All the examples and solutions to the exercises in this chapter can be found
    in this book's GitHub repository at [https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter06).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有示例和练习的解决方案可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter06](https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter06)。
- en: Code in Action videos for this chapter can be viewed at [https://bit.ly/3rcffcz](https://bit.ly/3rcffcz).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码实战视频可以在[https://bit.ly/3rcffcz](https://bit.ly/3rcffcz)观看。
- en: Server clustering
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器集群
- en: So far, we have interacted with each of the machines individually. What we did
    was connect to the `localhost` Docker daemon server. We could have used the `-H`
    option in the `docker run` command to specify the address of the remote Docker,
    but that would still mean deploying our application to a single Docker host machine.
    In real life, however, if servers share the same physical location, we are not
    interested in which particular machine the service is deployed in. All we need
    is to have it accessible and replicated in many instances to support high availability.
    *How can we configure a set of machines to work that way?* This is the role of
    clustering.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分别与每台机器进行过交互。我们所做的是连接到`localhost` Docker守护进程服务器。我们本可以在`docker run`命令中使用`-H`选项来指定远程Docker的地址，但那仍然意味着将应用程序部署到单一的Docker主机上。然而，在实际生活中，如果服务器共享相同的物理位置，我们并不关心服务部署在哪一台具体的机器上。我们需要做的是让它可访问，并在多个实例中进行复制，以支持高可用性。*我们如何配置一组机器让它们以这种方式工作？*
    这就是集群的作用。
- en: In the following subsections, you will be introduced to the concept of server
    clustering and the Kubernetes environment, which is an example of cluster management
    software.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的子章节中，您将了解服务器集群的概念，以及Kubernetes环境，这是一个集群管理软件的示例。
- en: Introducing server clustering
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍服务器集群
- en: 'A server cluster is a set of connected computers that work together in such
    a way that they can be used similarly to a single system. Servers are usually
    connected through the local network by a connection that''s fast enough to ensure
    that the services that are being run are distributed. A simple server cluster
    is presented in the following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器集群是一组连接在一起的计算机，它们协同工作，可以像单一系统一样使用。服务器通常通过局域网连接，连接速度足够快，以确保运行的服务可以分布式处理。下图展示了一个简单的服务器集群：
- en: '![Figure 6.1 – Server clustering'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.1 – 服务器集群'
- en: '](img/B18223_06_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_01.jpg)'
- en: Figure 6.1 – Server clustering
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 服务器集群
- en: A user accesses the cluster through a master host, which exposes the cluster
    API. There are multiple nodes that act as computing resources, which means that
    they are responsible for running applications. The master, on the other hand,
    is responsible for all other activities, such as the orchestration process, service
    discovery, load balancing, and node failure detection.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用户通过主机访问集群，主机暴露集群API。集群中有多个节点作为计算资源，负责运行应用程序。而主机则负责其他所有活动，例如编排过程、服务发现、负载均衡和节点故障检测。
- en: Introducing Kubernetes
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Kubernetes
- en: Kubernetes is an open source cluster management system that was originally designed
    by Google. Looking at the popularity charts, it is a clear winner among other
    competitors, such as Docker Swarm and Apache Mesos. Its popularity has grown so
    fast that most cloud platforms provide Kubernetes out of the box. It's not Docker-native,
    but there are a lot of additional tools and integrations to make it work smoothly
    with the whole Docker ecosystem; for example, **kompose** can translate Docker
    Compose files into Kubernetes configurations.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是一个开源的集群管理系统，最初由 Google 设计。从流行度的图表来看，它在其他竞争者（如 Docker Swarm 和 Apache
    Mesos）中遥遥领先。它的流行度增长非常迅速，以至于大多数云平台都直接提供 Kubernetes。它不是 Docker 原生的，但有许多附加工具和集成可以使其与整个
    Docker 生态系统顺畅配合；例如，**kompose** 可以将 Docker Compose 文件转换为 Kubernetes 配置。
- en: Information
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In the first edition of this book, I recommended Docker Compose and Docker Swarm
    for application dependency resolution and server clustering. While they're both
    good tools, Kubernetes' popularity has grown so high recently that I decided to
    use Kubernetes as the recommended approach and keep Docker-native tooling as an
    alternative.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，我推荐使用 Docker Compose 和 Docker Swarm 来解决应用依赖关系和服务器集群问题。虽然这两个工具都很好，但
    Kubernetes 最近的流行度如此之高，以至于我决定将 Kubernetes 作为推荐的方法，并将 Docker 原生工具作为替代方案。
- en: 'Let''s take a look at the simplified architecture of Kubernetes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看简化版的 Kubernetes 架构：
- en: '![Figure 6.2 – Simplified Kubernetes architecture'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 简化版 Kubernetes 架构'
- en: '](img/B18223_06_02.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_02.jpg)'
- en: Figure 6.2 – Simplified Kubernetes architecture
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 简化版 Kubernetes 架构
- en: The Kubernetes `8080`) and the control plane is responsible for making it happen.
    A Kubernetes Node, on the other hand, is a worker. You may see it just as a (Docker)
    container host with a special Kubernetes process (called `kubelet`) installed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes `8080`) 和控制平面负责实现这一目标。另一方面，Kubernetes 节点是一个工作节点。你可以把它看作是一个（Docker）容器主机，安装了一个特殊的
    Kubernetes 进程（称为 `kubelet`）。
- en: From the user's perspective, you provide a declarative deployment configuration
    in the form of a YAML file and pass it to the Kubernetes control plane through
    its API. Then, the control plane reads the configuration and installs the deployment.
    Kubernetes introduces the concept of a **Pod**, which represents a single deployment
    unit. The Pod contains Docker **containers**, which are scheduled together. While
    you can put multiple containers into a single Pod, in real-life scenarios, you
    will see that most Pods contain just a single Docker container. Pods are dynamically
    built and removed depending on the requirement changes that are expressed in the
    YAML configuration updates.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 从用户的角度来看，你提供一个声明式的部署配置，形式为 YAML 文件，并通过其 API 将该文件传递给 Kubernetes 控制平面。然后，控制平面读取配置并安装部署。Kubernetes
    引入了 **Pod** 的概念，表示一个单独的部署单元。Pod 包含 Docker **容器**，这些容器一起调度。虽然你可以将多个容器放入一个 Pod，但在实际场景中，大多数
    Pod 通常只包含一个 Docker 容器。Pods 会根据 YAML 配置文件更新中表达的需求变化动态创建和删除。
- en: You will gain more practical knowledge about Kubernetes in later sections of
    this chapter, but first, let's name the features that make Kubernetes such a great
    environment.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章后续部分，你将获得更多关于 Kubernetes 的实际知识，但首先，让我们列举出使 Kubernetes 成为如此出色的环境的一些特性。
- en: Kubernetes features overview
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 特性概述
- en: 'Kubernetes provides a number of interesting features. Let''s walk through the
    most important ones:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了许多有趣的特性。让我们来看看其中最重要的一些：
- en: '**Container balancing**: Kubernetes takes care of the load balancing of Pods
    on nodes; you specify the number of replicas of your application and Kubernetes
    takes care of the rest.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**容器负载均衡**：Kubernetes 负责 Pods 在节点上的负载均衡；你指定应用副本的数量，Kubernetes 会处理其余部分。'
- en: '**Traffic load balancing**: When you have multiple replicas of your application,
    the Kubernetes service can load balance the traffic. In other words, you create
    a service with a single IP (or DNS) and Kubernetes takes care of load balancing
    the traffic to your application replicas.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流量负载均衡**：当你有多个应用副本时，Kubernetes 服务可以进行流量负载均衡。换句话说，你创建一个具有单一 IP（或 DNS）的服务，Kubernetes
    会处理将流量负载均衡到你的应用副本。'
- en: '**Dynamic horizontal scaling**: Each deployment can be dynamically scaled up
    or down; you specify the number of application instances (or the rules for autoscaling)
    and Kubernetes starts/stops Pod replicas.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态水平扩展**：每个部署可以动态地进行扩展或缩减；你指定应用实例的数量（或自动扩展的规则），Kubernetes 会启动/停止 Pod 副本。'
- en: '**Failure recovery**: Pods (and nodes) are constantly monitored and if any
    of them fail, new Pods are started so that the declared number of replicas is
    constant.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**故障恢复**：Pods（和节点）会持续被监控，如果其中任何一个失败，新的 Pods 会被启动，以确保声明的副本数保持不变。'
- en: '**Rolling updates**: An update to the configuration can be applied incrementally;
    for example, if we have 10 replicas and we would like to make a change, we can
    define a delay between the deployment to each replica. In such a case, when anything
    goes wrong, we never end up with a scenario where a replica isn''t working correctly.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**滚动更新**：配置的更新可以逐步应用；例如，如果我们有 10 个副本并希望进行更改，可以在每个副本的部署之间定义一个延迟。在这种情况下，当出现问题时，我们永远不会遇到副本无法正常工作的情况。'
- en: '**Storage orchestration**: Kubernetes can mount a storage system of your choice
    to your applications. Pods are stateless in nature and, therefore, Kubernetes
    integrates with a number of storage providers, such as Amazon **Elastic Block
    Storage** (**EBS**), **Google Compute Engine** (**GCE**) Persistent Disk, and
    Azure Data Storage.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储编排**：Kubernetes 可以将你选择的存储系统挂载到你的应用程序上。Pod 是无状态的，因此 Kubernetes 与多个存储提供商集成，例如
    Amazon **Elastic Block Storage** (**EBS**)、**Google Compute Engine** (**GCE**)
    持久磁盘和 Azure 数据存储。'
- en: '**Service discovery**: Kubernetes Pods are ephemeral in nature and their IPs
    are dynamically assigned, but Kubernetes provides DNS-based service discovery
    for this.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务发现**：Kubernetes Pods 本质上是短暂的，它们的 IP 动态分配，但 Kubernetes 提供了基于 DNS 的服务发现机制。'
- en: '**Run everywhere**: Kubernetes is an open source tool, and you have a lot of
    options of how to run it: on-premises, cloud infrastructure, or hybrid.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随处运行**：Kubernetes 是一个开源工具，你可以选择多种方式来运行它：本地部署、云基础设施或混合部署。'
- en: Now that we have some background about Kubernetes, let's see what it all looks
    like in practice, starting with the installation process.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对 Kubernetes 有了一些背景了解，接下来让我们看看它在实践中的表现，从安装过程开始。
- en: Kubernetes installation
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kubernetes 安装
- en: 'Kubernetes, just like Docker, consists of two parts: the client and the server.
    The client is a command-line tool named `kubectl` and it connects to the server
    part using the Kubernetes API. The server is much more complex and is as we described
    in the previous section. Obviously, to do anything with Kubernetes, you need both
    parts, so let''s describe them one by one, starting with the client.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 就像 Docker 一样，由两部分组成：客户端和服务器端。客户端是一个名为`kubectl`的命令行工具，它通过 Kubernetes
    API 连接到服务器端。服务器端要复杂得多，正如我们在上一节所描述的那样。显然，要使用 Kubernetes 执行任何操作，你需要这两部分，因此我们将逐一描述它们，从客户端开始。
- en: Kubernetes client
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 客户端
- en: 'The Kubernetes client, `kubectl`, is a command-line application that allows
    you to perform operations on the Kubernetes cluster. The installation process
    depends on your operating system. You can check out the details on the official
    Kubernetes website: [https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 客户端 `kubectl` 是一个命令行应用程序，允许你对 Kubernetes 集群执行操作。安装过程取决于你的操作系统。你可以在
    Kubernetes 官方网站上查看详细信息：[https://kubernetes.io/docs/tasks/tools/](https://kubernetes.io/docs/tasks/tools/)。
- en: 'After you have successfully installed `kubectl`, you should be able to execute
    the following command:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功安装了 `kubectl` 之后，你应该能够执行以下命令：
- en: '[PRE0]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now that you have the Kubernetes client configured, we can move on to the server.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经配置了 Kubernetes 客户端，我们可以继续设置服务器部分。
- en: Kubernetes server
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 服务器
- en: There are multiple ways to set up a Kubernetes server. Which one you should
    use depends on your needs, but if you are completely new to Kubernetes, then I
    recommend starting from a local environment.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Kubernetes 服务器有多种方式。你应该使用哪种方式取决于你的需求，但如果你完全是 Kubernetes 的新手，我建议从本地环境开始。
- en: Local environment
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地环境
- en: Even though Kubernetes itself is a complex clustering system, there are a few
    tools that can simplify your local development setup. Let's walk through the options
    you have, which include Docker Desktop, kind, and minikube.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 Kubernetes 本身是一个复杂的集群系统，但有一些工具可以简化你的本地开发环境。让我们逐一了解你可以使用的选项，包括 Docker Desktop、kind
    和 minikube。
- en: Docker Desktop
  id: totrans-59
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Docker Desktop
- en: Docker Desktop is an application that is used to set up a local Docker environment
    on macOS or Windows. As you may remember from the previous chapters, the Docker
    daemon can only run natively on Linux, so for other operating systems, you need
    to get it running on a VM. Docker Desktop provides a super-intuitive way to do
    this, and luckily, it also supports the creation of Kubernetes clusters.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Desktop是一个应用程序，用于在macOS或Windows上设置本地Docker环境。如你从前面的章节中可能记得，Docker守护进程只能在Linux上本地运行，因此在其他操作系统上，你需要在虚拟机上运行它。Docker
    Desktop提供了一种超级直观的方式来实现这一点，幸运的是，它还支持创建Kubernetes集群。
- en: 'If you have Docker Desktop installed, then all you need to do is check the
    `kubectl` will be configured:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已安装Docker Desktop，那么你需要做的就是检查`kubectl`是否已配置：
- en: '![Figure 6.3 – Kubernetes in Docker Desktop'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.3 – 在Docker Desktop中使用Kubernetes'
- en: '](img/B18223_06_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_03.jpg)'
- en: Figure 6.3 – Kubernetes in Docker Desktop
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 在Docker Desktop中使用Kubernetes
- en: Starting from this point, you are ready to use the Kubernetes cluster.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从这一点开始，你已经准备好使用Kubernetes集群了。
- en: kind
  id: totrans-66
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: kind
- en: If you use the Linux operating system and can't, or just don't want to, use
    Docker Desktop, then your second simplest option is **kind** (short for **Kubernetes
    in Docker**). It's a tool for which the only requirement is to have Docker installed
    and configured.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Linux操作系统，并且不能或不想使用Docker Desktop，那么你第二简单的选择是**kind**（即**Kubernetes in
    Docker**的缩写）。它是一个工具，唯一的要求是安装并配置Docker。
- en: 'After installing kind, you can start and configure your local Kubernetes cluster
    with this one command:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完kind后，你可以通过以下一条命令启动并配置本地Kubernetes集群：
- en: '[PRE1]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Information
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can check the kind installation steps at [https://kind.sigs.k8s.io/docs/user/quick-start/](https://kind.sigs.k8s.io/docs/user/quick-start/).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看kind的安装步骤，网址是[https://kind.sigs.k8s.io/docs/user/quick-start/](https://kind.sigs.k8s.io/docs/user/quick-start/)。
- en: minikube
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: minikube
- en: minikube is a command-line tool that starts a fully functional Kubernetes environment
    inside a VM. It is backed up by a VM hypervisor, so you need to have VirtualBox,
    Hyper-V, VMware, or a similar tool installed. The instructions to install minikube
    depend on your operating system, and you can find instructions for each at [https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: minikube是一个命令行工具，可以在虚拟机内启动一个功能完备的Kubernetes环境。它由虚拟机监控程序支持，因此你需要安装VirtualBox、Hyper-V、VMware或类似的工具。安装minikube的说明取决于你的操作系统，你可以在[https://minikube.sigs.k8s.io/docs/start/](https://minikube.sigs.k8s.io/docs/start/)找到每个操作系统的安装指南。
- en: Information
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: minikube is an open source tool that you can find on GitHub at [https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: minikube是一个开源工具，你可以在GitHub上找到它，网址是[https://github.com/kubernetes/minikube](https://github.com/kubernetes/minikube)。
- en: 'After you have successfully installed minikube, you can start your Kubernetes
    cluster with the following command:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你成功安装minikube后，你可以通过以下命令启动Kubernetes集群：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: minikube starts a Kubernetes cluster and automatically configures your Kubernetes
    client with the cluster URL and credentials, so you can move directly to the *Verifying
    the Kubernetes setup* section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: minikube启动一个Kubernetes集群，并自动配置你的Kubernetes客户端，包含集群URL和凭证，这样你就可以直接进入*验证Kubernetes配置*部分。
- en: Cloud platforms
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 云平台
- en: Kubernetes has become so popular that most cloud computing platforms provide
    it as a service. The leader here is **Google Cloud Platform** (**GCP**), which
    allows you to create a Kubernetes cluster within a few minutes. Other cloud platforms,
    such as Microsoft Azure, **Amazon Web Services** (**AWS**), and IBM Cloud, also
    have Kubernetes in their portfolios. Let's take a closer look at the three most
    popular solutions—**GCP**, **Azure**, and **AWS**.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes已经变得非常流行，几乎所有的云计算平台都将其作为一项服务提供。这里的领导者是**Google Cloud Platform**（**GCP**），它允许你在几分钟内创建一个Kubernetes集群。其他云平台，如Microsoft
    Azure、**Amazon Web Services**（**AWS**）和IBM Cloud，也将Kubernetes纳入其产品组合。让我们仔细看看三大最受欢迎的解决方案——**GCP**、**Azure**和**AWS**。
- en: Google Cloud Platform
  id: totrans-81
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: Google Cloud Platform
- en: You can access GCP at [https://cloud.google.com/](https://cloud.google.com/).
    After creating an account, you should be able to open their web console ([https://console.cloud.google.com](https://console.cloud.google.com)).
    One of the services in their portfolio is called **Google Kubernetes Engine**
    (**GKE**).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问GCP，网址是[https://cloud.google.com/](https://cloud.google.com/)。创建账户后，你应该能够打开他们的Web控制台（[https://console.cloud.google.com](https://console.cloud.google.com)）。他们的产品组合中有一个服务叫做**Google
    Kubernetes Engine**（**GKE**）。
- en: You can create a Kubernetes cluster by clicking in the user interface or by
    using the GCP command-line tool, called `gcloud`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过点击用户界面或使用 GCP 命令行工具`gcloud`来创建 Kubernetes 集群。
- en: Information
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'You can read how to install `gcloud` on your operating system at the official
    GCP website: [https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install).'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方 GCP 网站上查看如何在你的操作系统上安装 `gcloud`：[https://cloud.google.com/sdk/docs/install](https://cloud.google.com/sdk/docs/install)。
- en: 'To create a Kubernetes cluster using the command-line tool, it''s enough to
    execute the following command:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用命令行工具创建 Kubernetes 集群，只需执行以下命令：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Apart from creating a Kubernetes cluster, it automatically configures `kubectl`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 除了创建 Kubernetes 集群外，它还会自动配置`kubectl`。
- en: Microsoft Azure
  id: totrans-89
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 微软 Azure
- en: Microsoft Azure also offers a very quick Kubernetes setup thanks to **Azure
    Kubernetes Service** (**AKS**). Like GCP, you can use either a web interface or
    a command-line tool to create a cluster.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 微软 Azure 还通过**Azure Kubernetes 服务**（**AKS**）提供了一个非常快速的 Kubernetes 设置。像 GCP 一样，你可以使用
    web 界面或命令行工具来创建集群。
- en: Information
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can access the Azure web console at [https://portal.azure.com/](https://portal.azure.com/).
    To install the Azure command-line tool, check the installation guide on their
    official page at [https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以访问 Azure Web 控制台：[https://portal.azure.com/](https://portal.azure.com/)。要安装
    Azure 命令行工具，请查看其官方网站的安装指南：[https://docs.microsoft.com/en-us/cli/azure/install-azure-cli](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli)。
- en: 'To create a Kubernetes cluster using the Azure command-line tool, assuming
    you already have an Azure resource group created, it''s enough to run the following
    command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 Azure 命令行工具创建 Kubernetes 集群，假设你已经创建了一个 Azure 资源组，只需运行以下命令：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'After a few seconds, your Kubernetes cluster should be ready. To configure
    `kubectl`, run the following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，你的 Kubernetes 集群应该准备就绪。要配置 `kubectl`，运行以下命令：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: By doing this, you will have successfully set up a Kubernetes cluster and configured
    `kubectl`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，你将成功设置一个 Kubernetes 集群并配置好 `kubectl`。
- en: Amazon Web Services
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 亚马逊网络服务
- en: AWS provides a managed Kubernetes service called Amazon **Elastic Kubernetes
    Service** (**EKS**). You can start using it by accessing the AWS web console at
    [https://console.aws.amazon.com/eks](https://console.aws.amazon.com/eks) or using
    the AWS command-line tool.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 提供了一种托管的 Kubernetes 服务，称为 Amazon **弹性 Kubernetes 服务**（**EKS**）。你可以通过访问 AWS
    Web 控制台：[https://console.aws.amazon.com/eks](https://console.aws.amazon.com/eks)
    或使用 AWS 命令行工具开始使用它。
- en: Information
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'You can check all the information (and the installation guide) for the AWS
    command-line tool at its official website: [https://docs.aws.amazon.com/cli/](https://docs.aws.amazon.com/cli/).'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 AWS 命令行工具的官方网站查看所有信息（包括安装指南）：[https://docs.aws.amazon.com/cli/](https://docs.aws.amazon.com/cli/)。
- en: As you can see, using Kubernetes in the cloud is a relatively simple option.
    Sometimes, however, you may need to install an on-premises Kubernetes environment
    from scratch on your own server machines. Let's discuss this in the next section.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，使用云中的 Kubernetes 是一个相对简单的选择。然而，有时你可能需要从头开始在自己的服务器上安装本地 Kubernetes 环境。我们将在下一节讨论这个问题。
- en: On-premises
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地部署
- en: Installing Kubernetes from scratch on your own servers makes sense if you don't
    want to depend on cloud platforms or if your corporate security policies don't
    allow it. The installation process is relatively complex and out of the scope
    of this book, but you can find all the details in the official documentation at
    [https://kubernetes.io/docs/setup/production-environment/](https://kubernetes.io/docs/setup/production-environment/).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想依赖云平台，或者你的公司安全政策不允许使用云平台，那么从头开始在自己的服务器上安装 Kubernetes 是有意义的。安装过程相对复杂，超出了本书的范围，但你可以在官方文档中找到所有细节：[https://kubernetes.io/docs/setup/production-environment/](https://kubernetes.io/docs/setup/production-environment/)。
- en: Now that we have the Kubernetes environment configured, we can check that `kubectl`
    is connected to the cluster correctly and that we are ready to start deploying
    our applications.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置好了 Kubernetes 环境，可以检查 `kubectl` 是否已正确连接到集群，并准备好开始部署应用程序。
- en: Verifying the Kubernetes setup
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 验证 Kubernetes 配置
- en: 'No matter which Kubernetes server installation you choose, you should already
    have everything configured and the Kubernetes client should be filled with the
    cluster''s URL and credentials. You can check this with the following command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你选择哪种Kubernetes服务器安装方式，你应该已经完成所有配置，并且Kubernetes客户端应该已经填充了集群的URL和凭证。你可以通过以下命令来检查：
- en: '[PRE6]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is the output for the Docker Desktop scenario and is why you can see `localhost`.
    Your output may be slightly different and may include more entries. If you see
    no errors, then everything is correct, and we can start using Kubernetes to run
    applications.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Docker Desktop场景下的输出，正因如此你能看到`localhost`。你的输出可能略有不同，且可能包含更多条目。如果没有看到错误信息，那么一切都是正确的，我们可以开始使用Kubernetes来运行应用程序。
- en: Using Kubernetes
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Kubernetes
- en: We have the whole Kubernetes environment ready and `kubectl` configured. This
    means that it's high time to finally present the power of Kubernetes and deploy
    our first application. Let's use the `leszko/calculator` Docker image that we
    built in the previous chapters and start it in multiple replicas on Kubernetes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了整个Kubernetes环境，并配置了`kubectl`。这意味着是时候展示Kubernetes的强大功能，部署我们的第一个应用程序了。我们将使用前几章中构建的`leszko/calculator`
    Docker镜像，并在Kubernetes上启动多个副本。
- en: Deploying an application
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: 'In order to start a Docker container on Kubernetes, we need to prepare a deployment
    configuration as a YAML file. Let''s name it `deployment.yaml`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Kubernetes上启动Docker容器，我们需要准备一个部署配置文件，格式为YAML。我们将其命名为`deployment.yaml`：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In this YAML configuration, we have to ensure the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个YAML配置中，我们需要确保以下几点：
- en: We have defined a Kubernetes resource of the `Deployment` type from the `apps/v1`
    Kubernetes API version.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了一个类型为`Deployment`的Kubernetes资源，使用的是`apps/v1` Kubernetes API版本。
- en: The unique deployment name is `calculator-deployment`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 唯一的部署名称是`calculator-deployment`。
- en: We have defined that there should be exactly `3` of the same Pods created.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经定义了应该创建正好`3`个相同的Pod。
- en: '`selector` defines how `Deployment` finds Pods to manage, in this case, just
    by the label.'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`selector`定义了`Deployment`如何找到需要管理的Pod，在这个例子中，仅通过标签来进行查找。'
- en: '`template` defines the specification for each created Pod.'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`template`定义了每个创建的Pod的规格。'
- en: 'Each Pod is labeled with `app: calculator`.'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '每个Pod都被标记为`app: calculator`。'
- en: Each Pod contains a Docker container named `calculator`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个Pod都包含一个名为`calculator`的Docker容器。
- en: A Docker container was created from the image called `leszko/calculator`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从名为`leszko/calculator`的镜像创建了一个Docker容器。
- en: The Pod exposes container port `8080`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该Pod暴露了容器端口`8080`。
- en: 'To install the deployment, run the following command:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装部署，请运行以下命令：
- en: '[PRE8]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can check that the three Pods, each containing one Docker container, have
    been created:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以检查是否已经创建了包含一个Docker容器的三个Pod：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Each Pod runs a Docker container. We can check its logs by using the following
    command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod都运行一个Docker容器。我们可以使用以下命令来检查它的日志：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You should see the familiar Spring logo and the logs of our Calculator web service.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该能看到熟悉的Spring logo和我们Calculator web服务的日志。
- en: Information
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'To look at an overview of `kubectl` commands, please check out the official
    guide: [https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/).'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看`kubectl`命令的概述，请查看官方指南：[https://kubernetes.io/docs/reference/kubectl/overview/](https://kubernetes.io/docs/reference/kubectl/overview/)。
- en: We have just performed our first deployment to Kubernetes, and with just a few
    lines of code, we have three replicas of our Calculator web service application.
    Now, let's see how we can use the application we deployed. For this, we'll need
    to understand the concept of a Kubernetes Service.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了第一次Kubernetes部署，通过几行代码，我们创建了三个副本的Calculator web服务应用程序。现在，让我们看看如何使用我们部署的应用程序。为此，我们需要了解Kubernetes
    Service的概念。
- en: Deploying a Kubernetes Service
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署Kubernetes Service
- en: Each Pod has an IP address in the internal Kubernetes network, which means that
    you can already access each Calculator instance from another Pod running in the
    same Kubernetes cluster. But *how do we access our application from the outside?*
    That is the role of a Kubernetes Service.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Pod在Kubernetes内部网络中都有一个IP地址，这意味着你已经可以从同一Kubernetes集群中运行的其他Pod访问每个Calculator实例。但是，*我们如何从外部访问我们的应用程序呢？*
    这正是Kubernetes Service的作用。
- en: 'The idea of Pods and Services is that Pods are mortal—they get terminated,
    and then they get restarted. The Kubernetes orchestrator only cares about the
    right number of Pod replicas, not about the Pod''s identity. That''s why, even
    though each Pod has an (internal) IP address, we should not stick to it or use
    it. Services, on the other hand, act as a frontend for Pods. They have IP addresses
    (and DNS names) that can be used. Let''s look at the following diagram, which
    presents the idea of a Pod and Service:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 和 Service 的概念是，Pod 是有生命的——它们会被终止，然后重新启动。Kubernetes 调度器只关心正确数量的 Pod 副本，而不是
    Pod 的身份。这就是为什么，即使每个 Pod 都有一个（内部）IP 地址，我们也不应该依赖它或使用它。而 Service 则充当 Pod 的前端。它们有可供使用的
    IP 地址（和 DNS 名称）。让我们看一下以下图示，展示了 Pod 和 Service 的概念：
- en: '![Figure 6.4 – Kubernetes Pod and Service'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.4 – Kubernetes Pod 和 Service'
- en: '](img/B18223_06_04.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_04.jpg)'
- en: Figure 6.4 – Kubernetes Pod and Service
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – Kubernetes Pod 和 Service
- en: Pods are physically placed on different nodes, but you don't have to worry about
    this since Kubernetes takes care of the right orchestration and introduces the
    abstraction of a Pod and Service. The user accesses the Service, which load balances
    the traffic between the Pod replicas. Let's look at an example of how to create
    a service for our Calculator application.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 实际上分布在不同的节点上，但您不需要担心这一点，因为 Kubernetes 会处理正确的调度，并引入 Pod 和 Service 的抽象。用户访问
    Service，Service 会在 Pod 副本之间进行流量负载均衡。让我们看一个如何为我们的计算器应用创建服务的示例。
- en: 'Just like we did for the Deployment, we start from a YAML configuration file.
    Let''s name it `service.yaml`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们为部署所做的一样，我们从一个 YAML 配置文件开始。我们将其命名为 `service.yaml`：
- en: '[PRE11]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is a configuration for a simple service that load balances the traffic
    to all the Pods that meet the criteria we mentioned in `selector`. To install
    the service, run the following command:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的服务配置，它将流量负载均衡到所有符合我们在 `selector` 中提到的条件的 Pod。要安装该服务，请运行以下命令：
- en: '[PRE12]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can then check that the service was correctly deployed by running the following
    command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过运行以下命令来检查服务是否已正确部署：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'To check that the service points to the three Pod replicas we created in the
    previous section, run the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查该服务是否指向我们在上一节中创建的三个 Pod 副本，请运行以下命令：
- en: '[PRE14]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: From the last two commands we ran, we can see that the service is available
    under the IP address of `10.19.248.154` and that it load balances the traffic
    to three Pods with the IPs of `10.16.1.5`, `10.16.2.6`, and `10.16.2.7`. All of
    these IP addresses, for both the Service and Pod, are internal to the Kubernetes
    cluster network.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们运行的最后两条命令中，我们可以看到该服务在 `10.19.248.154` 的 IP 地址下可用，并将流量负载均衡到三个 IP 地址分别为 `10.16.1.5`、`10.16.2.6`
    和 `10.16.2.7` 的 Pod。所有这些 IP 地址，无论是服务还是 Pod，都是 Kubernetes 集群网络内部的。
- en: Information
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: To read more about Kubernetes Services, please visit the official Kubernetes
    website at [https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Kubernetes 服务的信息，请访问 Kubernetes 官方网站：[https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/)。
- en: In the next section, we'll take a look at how to access a service from outside
    the Kubernetes cluster.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何从 Kubernetes 集群外部访问服务。
- en: Exposing an application
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 曝露应用
- en: 'To understand how your application can be accessed from the outside, we need
    to start with the types of Kubernetes Services. You can use four different service
    types, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解您的应用如何从外部访问，我们需要从 Kubernetes 服务类型开始。您可以使用四种不同的服务类型，如下所示：
- en: '**ClusterIP (default)**: The service has an internal IP only.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ClusterIP（默认）**：该服务仅具有内部 IP 地址。'
- en: '`<NODE-IP>:<NODE-PORT>`.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<NODE-IP>:<NODE-PORT>`。'
- en: '**LoadBalancer**: Creates an external load balancer and assigns a separate
    external IP for the service. Your Kubernetes cluster must support external load
    balancers, which works fine in the case of cloud platforms, but may not work if
    you use minikube.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**LoadBalancer**：创建一个外部负载均衡器，并为该服务分配一个单独的外部 IP 地址。您的 Kubernetes 集群必须支持外部负载均衡器，在云平台中通常没有问题，但如果您使用
    minikube，可能无法正常工作。'
- en: '`externalName` in the spec).'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`externalName` 在规格说明中）。'
- en: If you use a Kubernetes instance that's been deployed on a cloud platform (for
    example, GKE), then the simplest way to expose your service is to use `kubectl
    get service` command. If we had used it in our configuration, then you could have
    accessed the Calculator service at `http://<EXTERNAL-IP>:8080`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是部署在云平台上的 Kubernetes 实例（例如，GKE），那么暴露服务的最简单方法是使用 `kubectl get service`
    命令。如果我们在配置中使用了它，那么你就可以通过 `http://<EXTERNAL-IP>:8080` 访问 Calculator 服务。
- en: 'While LoadBalancer seems to be the simplest solution, it has two drawbacks:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 LoadBalancer 似乎是最简单的解决方案，但它有两个缺点：
- en: First, it's not always available, for example, if you deployed on-premises Kubernetes
    or used minikube.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它并不总是可用的，例如，如果你在本地部署了 Kubernetes 或使用了 minikube。
- en: Second, external public IPs are usually expensive. A different solution is to
    use a `NodePort` service, as we did in the previous section.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，外部公共 IP 通常比较昂贵。另一种解决方案是使用 `NodePort` 服务，正如我们在前面一节中所做的那样。
- en: Now, let's see how we can access our service.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下如何访问我们的服务。
- en: 'We can repeat the same command we ran already:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重复我们已经执行过的相同命令：
- en: '[PRE15]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that port `32259` was selected as a node port. This means that we
    can access our Calculator service using that port and the IP of any of the Kubernetes
    nodes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到端口 `32259` 被选作节点端口。这意味着我们可以通过该端口和任何 Kubernetes 节点的 IP 来访问我们的 Calculator
    服务。
- en: 'The IP address of your Kubernetes node depends on your installation. If you
    used Docker Desktop, then your node IP is `localhost`. In the case of minikube,
    you can check it with the `minikube ip` command. In the case of cloud platforms
    or the on-premises installation, you can check the IP addresses with the following
    command:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 Kubernetes 节点的 IP 地址取决于你的安装方式。如果你使用的是 Docker Desktop，那么你的节点 IP 是 `localhost`。如果是
    minikube，你可以通过 `minikube ip` 命令来查看它。在云平台或本地安装的情况下，你可以使用以下命令查看 IP 地址：
- en: '[PRE16]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To check that you can access Calculator from the outside, run the following
    command:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查你是否能从外部访问 Calculator，请运行以下命令：
- en: '[PRE17]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We made an HTTP request to one of our Calculator container instances and it
    returned the right response, which means that we successfully deployed the application
    on Kubernetes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们向其中一个 Calculator 容器实例发出了 HTTP 请求，它返回了正确的响应，这意味着我们已经成功地在 Kubernetes 上部署了应用程序。
- en: Tip
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 小提示
- en: 'The `kubectl` command offers a shortcut to create a service without using YAML.
    Instead of the configuration we used, you could just execute the following command:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`kubectl` 命令提供了一种快捷方式，可以在不使用 YAML 的情况下创建服务。你可以执行以下命令，而不是使用我们之前的配置：'
- en: '`$ kubectl expose deployment calculator-deployment --type=NodePort --name=calculator-service`.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl expose deployment calculator-deployment --type=NodePort --name=calculator-service`。'
- en: What we've just learned gives us the necessary basics about Kubernetes. We can
    now use it for the staging and production environments and, therefore, include
    it in the continuous delivery process. Before we do so, however, let's look at
    a few more Kubernetes features that make it a great and useful tool.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚学到的内容为我们提供了 Kubernetes 的必要基础。现在我们可以将其用于暂存和生产环境，从而将其纳入持续交付过程。然而，在我们这么做之前，让我们再看看一些使
    Kubernetes 成为一个伟大且有用工具的其他功能。
- en: Advanced Kubernetes
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 Kubernetes
- en: Kubernetes provides a way to dynamically modify your deployment during runtime.
    This is especially important if your application is already running in production
    and you need to support zero-downtime deployments. First, let's look at how to
    scale up an application and then present the general approach Kubernetes takes
    on any deployment changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一种在运行时动态修改部署的方法。这一点尤其重要，如果你的应用程序已经在生产环境中运行，并且你需要支持零停机时间的部署。首先，让我们看看如何扩展应用程序，然后介绍
    Kubernetes 在任何部署更改中的通用方法。
- en: Scaling an application
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展应用程序
- en: Let's imagine that our Calculator application is getting popular. People have
    started using it and the traffic is so high that the three Pod replicas are overloaded.
    *What can we do now?*
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们的 Calculator 应用程序开始流行起来。人们开始使用它，流量大到三个 Pod 副本都超载了。*我们现在该怎么办？*
- en: 'Luckily, `kubectl` provides a simple way to scale up and down deployments using
    the `scale` keyword. Let''s scale our Calculator deployment to `5` instances:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，`kubectl` 提供了一种简单的方法来使用 `scale` 关键字扩展和缩减部署。让我们将我们的 Calculator 部署扩展到 `5`
    个实例：
- en: '[PRE18]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'That''s it, our application is now scaled up:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的应用程序现在已经扩展：
- en: '[PRE19]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that, from now on, the service we created load balances the traffic to
    all `5` Calculator Pods. Also, note that you don't even need to wonder about which
    physical machine each Pod runs on, since this is covered by the Kubernetes orchestrator.
    All you have to think about is your desired number of application instances.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从现在开始，我们创建的服务会将流量负载均衡到所有 `5` 个 Calculator Pod 上。还要注意，你甚至不需要担心每个 Pod 运行在哪台物理机器上，因为
    Kubernetes 编排器已经涵盖了这一点。你只需要考虑应用实例的目标数量。
- en: Information
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Kubernetes also provides a way to autoscale your Pods, depending on its metrics.
    This feature is called the **HorizontalPodAutoscaler**, and you can read more
    about it at [https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还提供了一种根据其指标自动扩展 Pod 的方法。这个功能叫做 **HorizontalPodAutoscaler**，你可以在[https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/](https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/)了解更多信息。
- en: We have just seen how we can scale applications. Now, let's take a more generic
    look at how to update any part of a Kubernetes deployment.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到如何扩展应用程序。现在，让我们更广泛地了解如何更新 Kubernetes 部署的任何部分。
- en: Updating an application
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新应用程序
- en: 'Kubernetes takes care of updating your deployments. Let''s make a change to
    `deployment.yaml` and add a new label to the Pod template:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 会处理部署更新。让我们修改 `deployment.yaml` 文件，并向 Pod 模板中添加一个新标签：
- en: '[PRE20]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we repeat this and apply the same deployment, we can observe what happens
    with the Pods:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们重复这个操作并应用相同的部署，我们可以观察到 Pod 会发生什么：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We can see that Kubernetes terminated all the old Pods and started the new ones.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，Kubernetes 终止了所有旧的 Pod 并启动了新的 Pod。
- en: Information
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In our example, we modified the deployment of the YAML configuration, not the
    application itself. However, modifying the application is actually the same. If
    we make any change to the source code of the application, we need to build a new
    Docker image with the new version and then update this version in `deployment.yaml`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们修改的是 YAML 配置中的部署，而不是应用程序本身。然而，修改应用程序实际上是一样的。如果我们对应用程序的源代码进行任何更改，我们需要构建一个新的
    Docker 镜像并更新 `deployment.yaml` 中的版本。
- en: Every time you change something and run `kubectl apply`, Kubernetes checks whether
    there is any change between the existing state and the YAML configuration, and
    then, if needed, it performs the update operation we described previously.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你更改某些内容并运行 `kubectl apply` 时，Kubernetes 会检查现有状态与 YAML 配置之间是否存在变化，然后如果需要，它会执行我们之前描述的更新操作。
- en: This is all well and good, but if Kubernetes suddenly terminates all Pods, we
    may end up in a situation where all the old Pods are already killed and none of
    the new Pods are ready yet. This would make our application unavailable for a
    moment. *How do we ensure zero-downtime deployments?* That's the role of rolling
    updates.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，但如果 Kubernetes 突然终止所有 Pod，我们可能会陷入一种情况：所有旧的 Pod 都已经被杀死，但新的 Pod 还没有准备好。这将导致我们的应用程序暂时不可用。*如何确保零停机时间的部署？*
    这就是滚动更新的作用。
- en: Rolling updates
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滚动更新
- en: 'A rolling update entails incrementally terminating old instances and starting
    new ones. In other words, the workflow is as follows:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新意味着逐步终止旧的实例并启动新的实例。换句话说，工作流程如下：
- en: Terminate one of the old Pods.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 终止一个旧的 Pod。
- en: Start a new Pod.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个新的 Pod。
- en: Wait until the new Pod is ready.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 等待直到新的 Pod 准备好。
- en: Repeat *step 1* until all old instances are replaced.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复 *第 1 步*，直到所有旧实例被替换。
- en: Information
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: The concept of a rolling update works correctly only if the new application
    version is backward compatible with the old application version. Otherwise, we
    risk having two different incompatible versions at the same time.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 滚动更新的概念只有在新版本的应用程序与旧版本的应用程序向后兼容时才有效。否则，我们可能会面临两个不兼容的版本同时存在的风险。
- en: 'To configure it, we need to add the `RollingUpdate` strategy to our deployment
    and specify `readinessProbe`, which makes Kubernetes aware when the Pod is ready.
    Let''s modify `deployment.yaml`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置它，我们需要在部署中添加 `RollingUpdate` 策略，并指定 `readinessProbe`，这让 Kubernetes 知道 Pod
    何时准备就绪。让我们修改 `deployment.yaml`：
- en: '[PRE22]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let''s explain the parameters we used in our configuration:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下我们在配置中使用的参数：
- en: '`maxUnavailable`: The maximum number of Pods that can be unavailable during
    the update process; in our case, Kubernetes won''t terminate at the same time
    when there''s more than one Pod (*75%* ** 5* desired replicas).'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxUnavailable`：在更新过程中可以不可用的最大 Pods 数量；在我们的例子中，Kubernetes 在 Pod 数量大于一个时，不会同时终止多个
    Pods（*75%* ** 5* 所需副本）。'
- en: '`maxSurge`: The maximum number of Pods that can be created over the desired
    number of Pods; in our case, Kubernetes won''t create any new Pods before terminating
    an old one.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`maxSurge`：可以创建的 Pods 数量，超过所需 Pods 的数量；在我们的例子中，Kubernetes 在终止旧 Pods 之前不会创建新的
    Pods。'
- en: '`path` and `port`: The endpoint of the container to check for readiness; an
    HTTP `GET` request is sent to `<POD-IP>:8080/sum?a=1&b=2` and when it finally
    returns `200` as the HTTP status code, the Pod is marked as *ready*.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`path` 和 `port`：检查容器是否准备就绪的端点；一个 HTTP `GET` 请求会被发送到 `<POD-IP>:8080/sum?a=1&b=2`，当它最终返回
    `200` HTTP 状态码时，Pod 将被标记为 *就绪*。'
- en: Tip
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 提示
- en: By modifying the `maxUnavailable` and `maxSurge` parameters, we can decide whether
    Kubernetes first starts new Pods and later terminates old ones or, as we did in
    our case, first terminates old Pods and later starts new ones.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过修改 `maxUnavailable` 和 `maxSurge` 参数，我们可以决定是 Kubernetes 首先启动新的 Pods 然后终止旧的
    Pods，还是像我们做的那样，先终止旧的 Pods 然后再启动新的 Pods。
- en: 'We can now apply the deployment and observe that the Pods are updated one by
    one:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以应用部署并观察 Pods 一一更新：
- en: '[PRE23]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: That's it, we have just configured a rolling update for our Calculator deployment,
    which means that we can provide zero-downtime releases.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样，我们已经为我们的计算器部署配置了滚动更新，这意味着我们可以提供零停机时间的发布。
- en: Information
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Kubernetes also provides a different way of running applications. You can use
    `StatefulSet` instead of `Deployment`, and then the rolling update is always enabled
    (even without specifying any additional strategy).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 还提供了一种不同的应用程序运行方式。你可以使用 `StatefulSet` 代替 `Deployment`，这样滚动更新将始终启用（即使没有指定任何额外的策略）。
- en: Rolling updates are especially important in the context of continuous delivery,
    because if we deploy very often, then we definitely can't afford any downtime.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动更新在持续交付的背景下尤其重要，因为如果我们频繁部署，就绝对不能承受任何停机时间。
- en: Tip
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'After playing with Kubernetes, it''s good to perform the cleanup to remove
    all the resources we created. In our case, we can execute the following commands
    to remove the service and deployment we created:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在玩 Kubernetes 后，进行清理以删除我们创建的所有资源是很好的做法。在我们的例子中，我们可以执行以下命令来删除我们创建的服务和部署：
- en: '`$ kubectl delete -f service.yaml`'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete -f service.yaml`'
- en: '`$ kubectl delete -f deployment.yaml`'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ kubectl delete -f deployment.yaml`'
- en: We've already presented all the Kubernetes features that are needed for the
    continuous delivery process. Let's look at a short summary and add a few words
    about other useful features.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经展示了所有 Kubernetes 中用于持续交付过程的功能。让我们做一个简短的总结，并简要介绍其他有用的功能。
- en: Kubernetes objects and workloads
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes 对象和工作负载
- en: 'The execution unit in Kubernetes is always a Pod, which contains one or more
    (Docker) containers. There are multiple different resource types to orchestrate
    Pods:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 中的执行单元始终是 Pod，它包含一个或多个（Docker）容器。有多种不同的资源类型来编排 Pods：
- en: '**Deployment**: This is the most common workload, which manages the life cycle
    of the desired number of replicated Pods.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Deployment**：这是最常见的工作负载，它管理所需副本 Pods 的生命周期。'
- en: '**StatefulSet**: This is a specialized Pod controller that guarantees the ordering
    and uniqueness of Pods. It is usually associated with data-oriented applications
    (in which it''s not enough to say, *my desired number of replicas is 3*, as in
    the case of a Deployment, but rather, *I want exactly 3 replicas, with always
    the same predictable Pod names, and always started in the same order*).'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**StatefulSet**：这是一个专门的 Pod 控制器，它保证 Pods 的顺序和唯一性。它通常与面向数据的应用程序关联（在这种情况下，仅仅说
    *我需要 3 个副本* 并不够，就像 Deployment 中的情况，而是 *我想要 3 个副本，始终保持相同的可预测 Pod 名称，并且总是按相同顺序启动*）。'
- en: '**DaemonSet**: This is a specialized Pod controller that runs a copy of a Pod
    on each Kubernetes node.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DaemonSet**：这是一个专门的 Pod 控制器，它在每个 Kubernetes 节点上运行一个 Pod 的副本。'
- en: '**Job/CronJob**: This is a workflow that''s dedicated to task-based operations
    in which containers are expected to exist successfully.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Job/CronJob**：这是一个专门针对任务操作的工作流，其中容器预计能够成功存在。'
- en: Information
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 信息
- en: You may also find a Kubernetes resource called **ReplicationController**, which
    is deprecated and has been replaced by Deployment.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可能还会看到一个 Kubernetes 资源叫做 **ReplicationController**，它已经被弃用，并由 Deployment 取代。
- en: 'Apart from Pod management, there are other Kubernetes objects. The most useful
    ones that you may often encounter are as follows:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Pod 管理，Kubernetes 还有其他对象。以下是你可能经常遇到的最有用的对象：
- en: '**Service**: A component that acts as an internal load balancer for Pods.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务**：充当 Pod 内部负载均衡器的组件。'
- en: '**ConfigMap**: This decouples configuration from the image content; it can
    be any data that''s defined separately from the image and then mounted onto the
    container''s filesystem.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ConfigMap**：这将配置与镜像内容解耦；它可以是任何与镜像分开定义的数据，然后挂载到容器的文件系统中。'
- en: '**Secret**: This allows you to store sensitive information, such as passwords.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Secret**：这允许你存储敏感信息，如密码。'
- en: '**PersistentVolume/PersistentVolumeClaim**: These allow you to mount a persistent
    volume into a (stateless) container''s filesystem.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PersistentVolume/PersistentVolumeClaim**：这些允许你将持久卷挂载到（无状态的）容器文件系统中。'
- en: Actually, there are many more objects available, and you can even create your
    own resource definitions. However, the ones we've mentioned here are the most
    frequently used in practice.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，还有更多的对象可用，甚至可以创建自己的资源定义。然而，我们在这里提到的这些是实践中最常用的。
- en: We already have a good understanding of clustering in Kubernetes, but Kubernetes
    isn't just about workloads and scaling. It can also help with resolving dependencies
    between applications. In the next section, we will approach this topic and describe
    application dependencies in the context of Kubernetes and the continuous delivery
    process.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经对 Kubernetes 中的集群有了很好的理解，但 Kubernetes 不仅仅是关于工作负载和扩展。它还可以帮助解决应用程序之间的依赖关系。在接下来的部分，我们将探讨这个话题，并描述在
    Kubernetes 和持续交付过程中应用程序的依赖关系。
- en: Application dependencies
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序依赖项
- en: Life is easy without dependencies. In real life, however, almost every application
    links to a database, cache, messaging system, or another application. In the case
    of (micro) service architecture, each service needs a bunch of other services
    to do its work. The monolithic architecture does not eliminate the issue—an application
    usually has some dependencies, at least to the database.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 没有依赖的生活很轻松。然而，在现实生活中，几乎每个应用程序都会连接到数据库、缓存、消息系统或其他应用程序。在（微）服务架构中，每个服务都需要一堆其他服务来完成工作。单体架构并没有消除这个问题——一个应用程序通常至少会有一些依赖项，至少是数据库。
- en: Imagine a newcomer joining your development team; *how much time does it take
    to set up the entire development environment and run the application with all
    its dependencies?*
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下一个新人加入你的开发团队；*设置整个开发环境并运行所有依赖项的应用程序需要多少时间？*
- en: When it comes to automated acceptance testing, the dependencies issue is no
    longer only a matter of convenience—it becomes a necessity. While, during unit
    testing, we could mock the dependencies, the acceptance testing suite requires
    a complete environment. *How do we set it up quickly and in a repeatable manner?*
    Luckily, Kubernetes can help thanks to its built-in DNS resolution for Services
    and Pods.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 当谈到自动化验收测试时，依赖问题不再仅仅是一个便利问题——它变成了一个必要条件。在单元测试中，我们可以模拟依赖项，但验收测试套件需要一个完整的环境。*我们如何快速并可重复地设置它？*
    幸运的是，Kubernetes 可以通过其内建的 DNS 解析功能帮助我们解决这个问题，适用于服务和 Pod。
- en: The Kubernetes DNS resolution
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes DNS 解析
- en: 'Let''s present the Kubernetes DNS resolution with a real-life scenario. Let''s
    say we would like to deploy a caching service as a separate application and make
    it available for other services. One of the best in-memory caching solutions is
    Hazelcast, so let''s use it here. In the case of the Calculator application, we
    need `Deployment` and `Service`. Let''s define them both in one file, `hazelcast.yaml`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个现实场景来展示 Kubernetes DNS 解析。假设我们想将一个缓存服务作为一个独立的应用程序部署，并让它对其他服务可用。最好的内存缓存解决方案之一是
    Hazelcast，因此我们在这里使用它。对于计算器应用程序，我们需要 `Deployment` 和 `Service`。让我们将它们都定义在一个文件中，`hazelcast.yaml`：
- en: '[PRE24]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Similar to what we did previously for the Calculator application, we will now
    define the Hazelcast configuration. Let''s start it in the same way:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们之前为计算器应用程序所做的，我们现在将定义 Hazelcast 配置。我们以相同的方式开始：
- en: '[PRE25]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After a few seconds, the Hazelcast caching application should start. You can
    check its Pod logs with the `kubectl logs` command. We also created a service
    of a default type (`ClusterIP`, which is only exposed inside the same Kubernetes
    cluster).
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，Hazelcast 缓存应用程序应该启动。你可以通过 `kubectl logs` 命令查看其 Pod 日志。我们还创建了一个默认类型的服务（`ClusterIP`，仅在同一
    Kubernetes 集群内暴露）。
- en: So far, so good—we did nothing different from what we've already seen in the
    case of the Calculator application. Now comes the most interesting part. Kubernetes
    provides a way of resolving a service IP using the service name. What's even more
    interesting is that we know the `Service` name upfront—in our case, it's always
    `hazelcast`. So, if we use this as the cache address in our application, the dependency
    will be automatically resolved.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利——我们与计算器应用程序中的操作没有什么不同。现在进入最有趣的部分。Kubernetes 提供了一种使用服务名称解析服务 IP 的方式。更有意思的是，我们事先就知道了
    `Service` 的名称——在我们的案例中，它始终是 `hazelcast`。所以，如果我们在应用程序中使用它作为缓存地址，依赖关系将被自动解析。
- en: Information
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Actually, Kubernetes DNS resolution is even more powerful, and it can resolve
    Services in a different Kubernetes namespace. Read more at [https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Kubernetes 的 DNS 解析功能更强大，它甚至可以解析不同 Kubernetes 命名空间中的服务。详情请阅读 [https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/](https://kubernetes.io/docs/concepts/services-networking/dns-pod-service/)。
- en: Before we show you how to implement caching inside the Calculator application,
    let's take a moment to overview the system we will build.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在向你展示如何在计算器应用程序中实现缓存之前，让我们先概览一下我们将构建的系统。
- en: Multiapplication system overview
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多应用系统概览
- en: 'We already have the Hazelcast server deployed on Kubernetes. Before we modify
    our Calculator application so that we can use it as a caching provider, let''s
    take a look at a diagram of the complete system we want to build:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 Kubernetes 上部署了 Hazelcast 服务器。在修改我们的计算器应用程序之前，以便能够将其用作缓存提供者，让我们先来看一下我们要构建的完整系统的示意图：
- en: '![Figure 6.5 – Sample multiapplication deployment'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.5 – 示例多应用部署'
- en: '](img/B18223_06_05.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_05.jpg)'
- en: Figure 6.5 – Sample multiapplication deployment
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.5 – 示例多应用部署
- en: The user uses the `hazelcast`). The **Hazelcast Service** redirects to the **Hazelcast
    Pod**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 用户使用 `hazelcast`）。**Hazelcast 服务** 将重定向到 **Hazelcast Pod**。
- en: If you look at the diagram, you can see that we have just deployed the Hazelcast
    part (**Hazelcast Service** and **Hazelcast Pod**). We also deployed the Calculator
    part (**Calculator Service** and **Calculator Pod**) in the previous section.
    The final missing part is the Calculator code to use Hazelcast. Let's implement
    it now.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看图示，可以看到我们刚刚部署了 Hazelcast 部分（**Hazelcast 服务** 和 **Hazelcast Pod**）。我们也在上一节中部署了计算器部分（**Calculator
    服务** 和 **Calculator Pod**）。最后缺失的部分是计算器代码，来使用 Hazelcast。现在让我们来实现它。
- en: Multiapplication system implementation
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多应用系统实现
- en: 'To implement caching with Hazelcast in our Calculator application, we need
    to do the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的计算器应用程序中实现缓存功能，我们需要执行以下操作：
- en: Add the Hazelcast client library to Gradle.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Hazelcast 客户端库添加到 Gradle。
- en: Add the Hazelcast cache configuration.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Hazelcast 缓存配置。
- en: Add Spring Boot caching.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 Spring Boot 缓存。
- en: Build a Docker image.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建 Docker 镜像。
- en: Let's proceed step by step.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步来。
- en: Adding the Hazelcast client library to Gradle
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将 Hazelcast 客户端库添加到 Gradle
- en: 'In the `build.gradle` file, add the following configuration to the `dependencies`
    section:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `build.gradle` 文件中，将以下配置添加到 `dependencies` 部分：
- en: '[PRE26]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This adds the Java libraries that take care of communication with the Hazelcast
    server.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这将添加负责与 Hazelcast 服务器通信的 Java 库。
- en: Adding the Hazelcast cache configuration
  id: totrans-273
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加 Hazelcast 缓存配置
- en: 'Add the following parts to the `src/main/java/com/leszko/calculator/CalculatorApplication.java`
    file:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下部分添加到 `src/main/java/com/leszko/calculator/CalculatorApplication.java` 文件中：
- en: '[PRE27]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is a standard Spring cache configuration. Note that for the Hazelcast server
    address, we use `hazelcast`, which is automatically available thanks to the Kubernetes
    DNS resolution.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个标准的 Spring 缓存配置。请注意，对于 Hazelcast 服务器地址，我们使用 `hazelcast`，它由于 Kubernetes DNS
    解析功能而自动可用。
- en: Tip
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: In real life, if you use Hazelcast, you don't even need to specify the service
    name, since Hazelcast provides an autodiscovery plugin dedicated to the Kubernetes
    environment. Read more at [https://docs.hazelcast.com/hazelcast/latest/deploy/deploying-in-kubernetes.html](https://docs.hazelcast.com/hazelcast/latest/deploy/deploying-in-kubernetes.html).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，如果你使用 Hazelcast，甚至不需要指定服务名称，因为 Hazelcast 提供了一个专门针对 Kubernetes 环境的自动发现插件。详情请阅读
    [https://docs.hazelcast.com/hazelcast/latest/deploy/deploying-in-kubernetes.html](https://docs.hazelcast.com/hazelcast/latest/deploy/deploying-in-kubernetes.html)。
- en: We also need to remove the Spring context test automatically created by Spring
    Initializr, `src/test/java/com/leszko/calculator/CalculatorApplicationTests.java`.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要删除Spring Initializr自动创建的Spring上下文测试，`src/test/java/com/leszko/calculator/CalculatorApplicationTests.java`。
- en: Next, let's add caching to the Spring Boot service.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们为Spring Boot服务添加缓存。
- en: Adding Spring Boot caching
  id: totrans-281
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加Spring Boot缓存
- en: 'Now that the cache is configured, we can finally add caching to our web service.
    In order to do this, we need to change the `src/main/java/com/leszko/calculator/Calculator.java`
    file so that it looks as follows:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 现在缓存已经配置好，我们终于可以将缓存添加到我们的Web服务中了。为此，我们需要修改`src/main/java/com/leszko/calculator/Calculator.java`文件，使其如下所示：
- en: '[PRE28]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We added the `@Cacheable` annotation to make Spring automatically cache every
    call of the `sum()` method. We also added sleeping for 3 seconds, just for the
    purpose of testing, so that we could see that the cache works correctly.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了`@Cacheable`注解，使Spring自动缓存每次调用`sum()`方法。我们还添加了3秒钟的睡眠，仅用于测试，以便我们能够看到缓存是否正确工作。
- en: From now on, the sum calculations are cached in Hazelcast, and when we call
    the `/sum` endpoint of the Calculator web service, it will first try to retrieve
    the result from the cache. Now, let's build our application.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，求和计算会被缓存到Hazelcast中，当我们调用Calculator Web服务的`/sum`端点时，它会首先尝试从缓存中检索结果。现在，让我们构建我们的应用程序。
- en: Building a Docker image
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建Docker镜像
- en: As the next step, we need to remove the Spring default context test, `src/test/java/com/leszko/calculator/CalculatorApplicationTests.java`
    (to avoid failing because of the missing Hazelcast dependency).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步，我们需要删除Spring默认的上下文测试，`src/test/java/com/leszko/calculator/CalculatorApplicationTests.java`（以避免因缺少Hazelcast依赖项而导致失败）。
- en: 'Now, we can rebuild the Calculator application and the Docker image with a
    new tag. Then, we will push it to Docker Hub once more:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以重新构建Calculator应用程序及其Docker镜像，并使用新标签。然后，我们会将它再次推送到Docker Hub：
- en: '[PRE29]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Obviously, you should change `leszko` to your Docker Hub account.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，你应该将`leszko`更改为你的Docker Hub账户。
- en: The application is ready, so let's test it all together on Kubernetes.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序已经准备好，所以让我们一起在Kubernetes上进行测试。
- en: Multiapplication system testing
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多应用系统测试
- en: 'We should already have the Hazelcast caching server deployed on Kubernetes.
    Now, let''s change the deployment for the Calculator application to use the `leszko/calculator:caching`
    Docker image. You need to modify `image` in the `deployment.yaml` file:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该已经在Kubernetes上部署了Hazelcast缓存服务器。现在，让我们修改Calculator应用程序的部署，使用`leszko/calculator:caching`
    Docker镜像。你需要在`deployment.yaml`文件中修改`image`：
- en: '[PRE30]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, apply the Calculator deployment and service:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，应用Calculator的部署和服务：
- en: '[PRE31]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Let''s repeat the `curl` operation we did before:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重复之前的`curl`操作：
- en: '[PRE32]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first time you execute it, it should reply in 3 seconds, but all subsequent
    calls should be instant, which means that caching works correctly.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次执行时，它应该在3秒钟内响应，但所有后续调用应该是即时的，这意味着缓存工作正常。
- en: Tip
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If you''re interested, you can also check the logs of the Calculator Pod. You
    should see some logs there that confirm that the application is connected to the
    Hazelcast server:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有兴趣，你还可以查看Calculator Pod的日志。你应该能看到一些日志，确认应用程序已连接到Hazelcast服务器：
- en: '`Members [1] {`'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '`Members [1] {`'
- en: '`Member [10.16.2.15]:5701 - 3fca574b-bbdb-4c14-ac9d-73c45f56b300`'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`Member [10.16.2.15]:5701 - 3fca574b-bbdb-4c14-ac9d-73c45f56b300`'
- en: '`}`'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: You can probably already see how we could perform acceptance testing on a multicontainer
    system. All we need is an acceptance test specification for the whole system.
    Then, we could deploy the complete system into the Kubernetes staging environment
    and run a suite of acceptance tests against it. We'll talk about this in more
    detail in [*Chapter 8*](B18223_08_ePub.xhtml#_idTextAnchor218), *Continuous Delivery
    Pipeline*.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经能看到我们如何在一个多容器系统上执行验收测试了。我们所需要的只是整个系统的验收测试规范。然后，我们可以将完整的系统部署到Kubernetes的暂存环境中，并对其运行一系列的验收测试。我们将在[*第8章*](B18223_08_ePub.xhtml#_idTextAnchor218)，*持续交付管道*中详细讨论这个问题。
- en: Information
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In our example, the dependent service was related to caching, which doesn't
    really change the functional acceptance tests we created in [*Chapter 5*](B18223_05_ePub.xhtml#_idTextAnchor133),
    *Automated Acceptance Testing*.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，依赖服务与缓存相关，这实际上并没有改变我们在[*第5章*](B18223_05_ePub.xhtml#_idTextAnchor133)，*自动化验收测试*中创建的功能验收测试。
- en: That's all we need to know about how to approach dependent applications that
    are deployed on the Kubernetes cluster in the context of continuous delivery.
    Nevertheless, before we close this chapter, let's write a few words about Kubernetes'
    competitors, that is, other popular cluster management systems.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们在持续交付的背景下，如何处理部署在 Kubernetes 集群上的依赖应用程序所需要了解的全部内容。然而，在我们结束这一章节之前，让我们简单谈一谈
    Kubernetes 的竞争者，也就是其他流行的集群管理系统。
- en: Alternative cluster management systems
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替代的集群管理系统
- en: Kubernetes is not the only system that can be used to cluster Docker containers.
    Even though it's currently the most popular one, there may be some valid reasons
    to use different software. Let's walk through the alternatives.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 不是唯一可以用来集群 Docker 容器的系统。尽管它目前是最受欢迎的选择，但可能会有一些合理的原因去使用不同的软件。让我们一起来了解一下其他的替代方案。
- en: Docker Swarm
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Swarm is a native clustering system for Docker that turns a set of Docker
    hosts into one consistent cluster, called a **swarm**. Each host connected to
    the swarm plays the role of a manager or a worker (there must be at least one
    manager in a cluster). Technically, the physical location of the machines does
    not matter; however, it's reasonable to have all Docker hosts inside one local
    network; otherwise, managing operations (or reaching a consensus between multiple
    managers) can take a significant amount of time.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 是一个原生的 Docker 集群系统，它将一组 Docker 主机转化为一个一致的集群，称为 **swarm**。每个连接到
    swarm 的主机都扮演着管理者或工作者的角色（集群中必须至少有一个管理者）。从技术上讲，机器的物理位置并不重要；然而，将所有 Docker 主机放在同一个本地网络中是合理的，否则管理操作（或在多个管理者之间达成共识）可能会花费大量时间。
- en: Information
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Since Docker 1.12, Docker Swarm is natively integrated into Docker Engine in
    swarm mode. In older versions, it was necessary to run the swarm container on
    each of the hosts to provide the clustering functionality.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Docker 1.12 开始，Docker Swarm 原生集成进了 Docker 引擎的 swarm 模式。在旧版本中，需要在每个主机上运行 swarm
    容器来提供集群功能。
- en: 'Let''s look at the following diagram, which presents the terminology and the
    Docker Swarm clustering process:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的图表，它展示了 Docker Swarm 的术语和集群过程：
- en: '![Figure 6.6 – Docker Swarm'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.6 – Docker Swarm'
- en: '](img/B18223_06_06.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_06.jpg)'
- en: Figure 6.6 – Docker Swarm
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.6 – Docker Swarm
- en: In Docker Swarm mode, a running image is called a **Service**, as opposed to
    a **container**, which is run on a single Docker host. One service runs a specified
    number of **tasks**. A task is an atomic scheduling unit of the swarm that holds
    the information about the container and the command that should be run inside
    the container. A **replica** is each container that is run on the node. The number
    of replicas is the expected number of all containers for the given service.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker Swarm 模式下，一个运行中的镜像被称为 **Service**，而与之相对的 **container** 则是在单个 Docker
    主机上运行的。一个服务会运行指定数量的 **tasks**。任务是 swarm 的一个原子调度单元，它包含关于容器及其内部应该运行的命令的信息。**Replica**
    是在节点上运行的每个容器。副本数量是指给定服务的所有容器的期望数量。
- en: We start by specifying a service, the Docker image, and the number of replicas.
    The manager automatically assigns tasks to worker nodes. Obviously, each replicated
    container is run from the same Docker image. In the context of the presented flow,
    Docker Swarm can be viewed as a layer on top of the Docker Engine mechanism that
    is responsible for container orchestration.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过指定服务、Docker 镜像和副本数量开始。管理器会自动将任务分配给工作节点。显然，每个复制的容器都是从相同的 Docker 镜像运行的。在所展示的流程中，Docker
    Swarm 可以被看作是 Docker 引擎机制之上的一层，负责容器编排。
- en: Information
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In the first edition of this book, Docker Swarm was used for all the examples
    that were provided. So, if Docker Swarm is your clustering system of choice, you
    may want to read the first edition.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的第一版中，所有提供的示例都使用了 Docker Swarm。因此，如果 Docker Swarm 是你选择的集群系统，你可能想阅读第一版。
- en: Another alternative to Kubernetes is Apache Mesos. Let's talk about it now.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 的另一个替代方案是 Apache Mesos。现在让我们来谈谈它。
- en: Apache Mesos
  id: totrans-324
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Apache Mesos
- en: Apache Mesos is an open source scheduling and clustering system that was started
    at the University of California, Berkeley, in 2009, long before Docker emerged.
    It provides an abstraction layer over CPU, disk space, and RAM. One of the great
    advantages of Mesos is that it supports any Linux application, but not necessarily
    (Docker) containers. This is why it's possible to create a cluster out of thousands
    of machines and use it for both Docker containers and other programs, for example,
    Hadoop-based calculations.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Mesos 是一个开源调度和集群系统，始于 2009 年在加利福尼亚大学伯克利分校，它比 Docker 更早诞生。它在 CPU、磁盘空间和内存上提供了一个抽象层。Mesos
    的一个大优点是它支持任何 Linux 应用程序，但不一定是（Docker）容器。这就是为什么它可以将成千上万台机器组成一个集群，并用于 Docker 容器和其他程序，比如基于
    Hadoop 的计算。
- en: 'Let''s look at the following diagram, which presents the Mesos architecture:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看下面的图示，展示了 Mesos 的架构：
- en: '![Figure 6.7 – Apache Mesos'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.7 – Apache Mesos'
- en: '](img/B18223_06_07.jpg)'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_06_07.jpg)'
- en: Figure 6.7 – Apache Mesos
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.7 – Apache Mesos
- en: 'Apache Mesos, similar to other clustering systems, has the master-slave architecture.
    It uses node agents that have been installed on every node for communication,
    and it provides two types of schedulers:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: Apache Mesos 与其他集群系统类似，采用主从架构。它使用已在每个节点上安装的节点代理进行通信，并提供两种类型的调度器：
- en: '**Chronos**: For cron-style repeating tasks'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chronos**：用于定时任务风格的重复任务'
- en: '**Marathon**: To provide a REST API to orchestrate services and containers'
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Marathon**：提供一个 REST API 来编排服务和容器'
- en: Apache Mesos is very mature compared to other clustering systems, and it has
    been adopted in a large number of organizations, such as Twitter, Uber, and CERN.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 相较于其他集群系统，Apache Mesos 已经非常成熟，并且已被大量组织采纳，如 Twitter、Uber 和 CERN。
- en: Comparing features
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较特性
- en: 'Kubernetes, Docker Swarm, and Mesos are all good choices for the cluster management
    system. All of them are free and open source, and all of them provide important
    cluster management features, such as load balancing, service discovery, distributed
    storage, failure recovery, monitoring, secret management, and rolling updates.
    All of them can also be used in the continuous delivery process without huge differences.
    This is because, in the Dockerized infrastructure, they all address the same issue—the
    clustering of Docker containers. Nevertheless, the systems are not exactly the
    same. Let''s take a look at the following table, which presents the differences:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes、Docker Swarm 和 Mesos 都是集群管理系统的不错选择。它们都是免费的开源软件，并且提供了重要的集群管理功能，如负载均衡、服务发现、分布式存储、故障恢复、监控、秘密管理和滚动更新。它们也都可以在持续交付过程中使用，且没有太大差异。这是因为，在
    Docker 化的基础设施中，它们都解决了同一个问题——Docker 容器的集群化。然而，这些系统并不完全相同。让我们看一下以下的表格，展示了它们之间的差异：
- en: '![](img/B18223_06_Table_1.jpg)'
  id: totrans-336
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B18223_06_Table_1.jpg)'
- en: Obviously, apart from Kubernetes, Docker Swarm, and Apache Mesos, there are
    other clustering systems available on the market. Especially in the era of cloud
    platforms, there are very popular platform-specific systems, for example, Amazon
    **Elastic Container Service** (**ECS**). The good news is that if you understand
    the idea of clustering Docker containers, then using another system won't be difficult
    for you.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，除了 Kubernetes、Docker Swarm 和 Apache Mesos，市场上还有其他集群系统。特别是在云平台时代，存在许多流行的特定平台系统，例如
    Amazon **弹性容器服务**（**ECS**）。好消息是，如果你理解了 Docker 容器集群化的思路，那么使用其他系统对你来说也不会太难。
- en: Summary
  id: totrans-338
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we took a look at the clustering methods for Docker environments
    that allow you to set up complete staging and production environments. Let''s
    go over some of the key takeaways from this chapter:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Docker 环境的集群方法，允许你设置完整的预生产和生产环境。让我们回顾一下本章的一些关键要点：
- en: Clustering is a method of configuring a set of machines in a way that, in many
    respects, can be viewed as a single system.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集群化是一种将一组机器配置成某种方式的方法，在许多方面可以视作一个单一的系统。
- en: Kubernetes is the most popular clustering system for Docker.
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 是最受欢迎的 Docker 集群系统。
- en: Kubernetes consists of the Kubernetes server and the Kubernetes client (`kubectl`).
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 由 Kubernetes 服务器和 Kubernetes 客户端（`kubectl`）组成。
- en: The Kubernetes server can be installed locally (through minikube or Docker Desktop),
    on the cloud platform (AKS, GKE, or EKS), or manually on a group of servers. Kubernetes
    uses YAML configurations to deploy applications.
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 服务器可以本地安装（通过 minikube 或 Docker Desktop）、在云平台上安装（AKS、GKE 或 EKS），或者手动安装在一组服务器上。Kubernetes
    使用 YAML 配置来部署应用程序。
- en: Kubernetes provides features such as scaling and rolling updates out of the
    box.
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 提供了开箱即用的功能，如自动扩展和滚动更新。
- en: Kubernetes provides DNS resolution, which can help when you're deploying systems
    that consist of multiple dependent applications.
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kubernetes 提供 DNS 解析，这在部署由多个依赖应用程序组成的系统时非常有用。
- en: The most popular clustering systems that support Docker are Kubernetes, Docker
    Swarm, and Apache Mesos.
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持 Docker 的最流行集群系统有 Kubernetes、Docker Swarm 和 Apache Mesos。
- en: In the next chapter, we will describe the configuration management part of the
    continuous delivery pipeline.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将描述持续交付管道中的配置管理部分。
- en: Exercises
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'In this chapter, we have covered Kubernetes and the clustering process in detail.
    In order to enhance this knowledge, we recommend the following exercises:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们详细讲解了 Kubernetes 和集群过程。为了增强这部分知识，我们推荐以下练习：
- en: 'Run a `hello world` application on the Kubernetes cluster:'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Kubernetes 集群上运行一个 `hello world` 应用程序：
- en: The `hello world` application can look exactly the same as the one we described
    in the exercises for [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034), *Introducing
    Docker*.
  id: totrans-351
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`hello world` 应用程序可以与我们在[*第二章*](B18223_02_ePub.xhtml#_idTextAnchor034)中描述的完全相同，*介绍
    Docker*。'
- en: Deploy the application with three replicas.
  id: totrans-352
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用三个副本部署应用程序。
- en: Expose the application with the `NodePort` service.
  id: totrans-353
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `NodePort` 服务暴露应用程序。
- en: Make a request (using `curl`) to the application.
  id: totrans-354
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序发出请求（使用`curl`）。
- en: 'Implement a new feature, *Goodbye World!*, and deploy it using a rolling update:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个新特性，*Goodbye World!*，并使用滚动更新进行部署：
- en: This feature can be added as a new endpoint, `/bye`, which always returns *Goodbye
    World!*.
  id: totrans-356
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个特性可以作为一个新的端点 `/bye` 添加，始终返回 *Goodbye World!*。
- en: Rebuild a Docker image with a new version tag.
  id: totrans-357
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新版本标签重建一个 Docker 镜像。
- en: Use the `RollingUpdate` strategy and `readinessProbe`.
  id: totrans-358
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `RollingUpdate` 策略和 `readinessProbe`。
- en: Observe the rolling update procedure.
  id: totrans-359
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察滚动更新过程。
- en: Make a request (using `curl`) to the application.
  id: totrans-360
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向应用程序发出请求（使用`curl`）。
- en: Questions
  id: totrans-361
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To verify your knowledge from this chapter, please answer the following questions:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证你在本章中的知识，请回答以下问题：
- en: What is a server cluster?
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是服务器集群？
- en: What is the difference between a Kubernetes control plane and Kubernetes Node?
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 控制平面和 Kubernetes 节点有什么区别？
- en: Name at least three cloud platforms that provide a Kubernetes environment out
    of the box.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举至少三个提供 Kubernetes 环境的云平台。
- en: What is the difference between a Kubernetes deployment and service?
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 部署和服务有什么区别？
- en: What is the Kubernetes command for scaling deployments?
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kubernetes 用于扩展部署的命令是什么？
- en: Name at least two cluster management systems other than Kubernetes.
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举至少两个除了 Kubernetes 之外的集群管理系统。
- en: Further reading
  id: totrans-369
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To find out more about Kubernetes, please refer to the following resources:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 Kubernetes 的信息，请参考以下资源：
- en: '**Kubernetes official documentation**: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes 官方文档**：[https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
- en: '**Nigel Poulton: The Kubernetes Book** ([https://leanpub.com/thekubernetesbook](https://leanpub.com/thekubernetesbook))'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Nigel Poulton: The Kubernetes Book** ([https://leanpub.com/thekubernetesbook](https://leanpub.com/thekubernetesbook))'
