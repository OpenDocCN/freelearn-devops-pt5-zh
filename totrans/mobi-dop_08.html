<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Deploying Applications on AWS</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover how to deploy applications to the cloud and look at the prerequisites to do so. Before going forward, we need to understand why we want to deploy applications to the cloud. We have gone through the differences of Cloud versus on-premises systems in <a href="69772d4d-8571-421f-83a8-a23b0411e8aa.xhtml" target="_blank">Chapter 1</a>, <em>Introduction</em>. </p>
<p>So far, we have gone through various DevOps mechanisms, which are where you will start writing your code and pushing it to a code repository (GitHub), as the commands are pretty straightforward (such as <kbd>git add</kbd>, <kbd>git commit</kbd>, and <kbd>git push</kbd>).</p>
<p>Once the new version of the code is available in GitHub, it will be pulled as a new change to the <strong>Continuous Integration</strong> and <strong>Continuous Deployment</strong> (<span><strong>CI</strong>/<strong>CD</strong>)</span> pipeline. We have demonstrated two examples in our book of how to deploy a CI/CD pipeline (Teamcity and VSTS). CI will start the process of building different parts of the software, including the code/software, database, and other dependent components of the pipeline. The software scripts will then be deployed to the environment. </p>
<p>Before we deploy the code, we need to set up the environment, and the environment here includes a set of machines running on AWS. <span>The virtual machines in AWS are called <strong>Elastic Compute Cloud</strong> (<strong>EC2</strong>)</span>. As the software is running on multiple machines, we have to make sure the requests go to all the machines. For that, we will create an <strong>Elastic Load Balancer</strong> (<span><strong>ELB</strong>)</span>. An ELB distributes user requests to multiple EC2 nodes and gives a single DNS host entry to point end user requests. In this chapter, we will also use <strong>Auto Scaling Groups</strong> (<span><strong>ASGs</strong>)</span>, used to scale in and out EC2 instances on the basis of various metrics, such as workload, CPU, memory consumption, and so on. You can configure an ASG to meet your application requirements.</p>
<p>In this chapter, we will cover application deployment on AWS:</p>
<ul>
<li>Creation of an instance:
<ul>
<li>Lightsail</li>
<li>EC2 CLI</li>
</ul>
</li>
<li>Terraform</li>
<li>Creating an Elastic Load Balancer, launch configuration, and Auto Scaling Groups</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creation of an instance</h1>
                </header>
            
            <article>
                
<p>Now, let's continue with creating an EC2 instance. There are various methods to create EC2 instances in AWS. We will be going through the following:</p>
<ul>
<li>Lightsail</li>
<li>EC2 CLI</li>
<li>Teraform</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Lightsail</h1>
                </header>
            
            <article>
                
<p>Lightsail is a one-click easy service to create instances, and it is very important for testing applications and development environments where you don't want to spend time on spinning and maintaining nodes. Lightsail also supports creating instances with predefined templates for <span>MEAN,</span> <span>LAMP, Node.js, and LEMP (Nginx). Let's see how we can create instances with Lightsail.</span></p>
<p>The following are the required steps to create instances in Lightsail:</p>
<ol>
<li>Log in to the AWS console.</li>
<li>Click on <span class="packt_screen">Lightsail</span> under the <span class="packt_screen">Compute</span> section:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e6922c2d-f0bf-4b9b-bd65-f44faf1bc143.png" style=""/></div>
<ol start="3">
<li><span>The first screen of Lightsail is pretty straightforward; just click on <span class="packt_screen">Create instance</span>:</span></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c5652dfe-97fd-4557-b1f3-395ffbd32805.png" style=""/></div>
<ol start="4">
<li>Now, you will be asked a bunch of basic questions:
<ol>
<li>Select your instance location:</li>
</ol>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e39f7cdd-24e0-4d45-8625-dec00865b207.png" style=""/></div>
<ol>
<li style="list-style-type: none">
<ol start="2">
<li>Pick your instance image and select a blueprint:</li>
</ol>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1252a228-14a4-4a6b-a68a-82be3157457b.png" style=""/></div>
<ol>
<li style="list-style-type: none">
<ol start="3">
<li class="mce-root">Click <span class="packt_screen">Create New</span> and create a key pair for your instance:</li>
</ol>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2f4be806-5f33-45f7-88cf-32b7ee77cefa.png"/></div>
<ol>
<li style="list-style-type: none">
<ol start="4">
<li>Provide a name to the key and click on <span class="packt_screen">Generate key pair</span>:</li>
</ol>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5b1751af-564f-4ce9-b190-cf06d364109e.png" style=""/></div>
<ol start="5">
<li style="list-style-type: none">
<ol start="5">
<li>Choose your instance plan:</li>
</ol>
</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5aedc6a1-b969-4354-af1d-110fe2cf90ee.png" style=""/></div>
<ol start="5">
<li>Name the instance. You can create multiple instances as per your requirements. Instances will look as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/14ca0e8a-d3f6-4044-aadd-b5cca78e9b91.png" style=""/></div>
<ol start="6">
<li>You can connect to the instance  by clicking on the three dots at the top-right corner of the instance icon and clicking on <span class="packt_screen">Connect</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c77af472-ccc7-4e5d-abfe-2165dbf7c2af.png" style=""/></div>
<ol start="7">
<li>A connection screen will be shown as follows:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f0484c1e-52dd-413a-bd9b-bfd145bddc83.png"/></div>
<p>Now, the instance has been created. We will now create instances using Terraform.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terraform</h1>
                </header>
            
            <article>
                
<p>Terraform provides simple Infrastructure as a Service for multiple cloud providers and existing house systems. Using Terraform, we can manage very low-level tasks, such as creating an instance, adding EBS volume to the instance, and registering the instance to Route 53. We will be using Terraform as self-service code; for example, for when we have developed the code and we want to deploy it somewhere, do the integration testing, and then destroy the machines/cluster. The setup can be very useful for software showcase/trial, multiple cloud setup, and replaceable infrastructure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Installation</h1>
                </header>
            
            <article>
                
<p>Terraform installation can be done through downloading a single binary package. Download the binary package from <a href="https://www.terraform.io/downloads.html">https://www.terraform.io/downloads.html</a> according to your OS.</p>
<p>Once the installation is done, verify it by running the following command:</p>
<pre><strong>$ terraform --version</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuration files</h1>
                </header>
            
            <article>
                
<p>Now we will see how to create EC2 instances using Terraform.</p>
<p>Create a directory for your configuration file. Terraform will load all the files (<kbd>*.tf</kbd>) inside the directory called <kbd>workspace</kbd>, so make sure to keep the necessary files inside the directory:</p>
<pre><strong>$ mkdir terraform</strong><br/><strong>$ cd terraform</strong><br/><strong>$ terraform workspace new MyTestMachine</strong><br/><strong>$ terraform workspace select MyTestMachine</strong></pre>
<p><span>Terraform uses the <kbd>*.tf</kbd> format, known as Terraform configuration.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating instances</h1>
                </header>
            
            <article>
                
<ol>
<li>T<span>o pass the variable for the AWS instance type, use the following code:</span></li>
</ol>
<pre class="highlight hcl" style="padding-left: 60px"><span class="n">variable</span> <span class="s2">"instance_type"</span> <span class="p">{</span>
  <span class="n">description</span> <span class="o">=</span> <span class="s2">"the AWS instance type to use"</span>
<span class="p">}</span></pre>
<p style="padding-left: 60px">You can also define <kbd>secret</kbd> variables in a file called <kbd>terraform.tfvars</kbd> or <kbd>*.auto.tfvars</kbd>.</p>
<ol start="2">
<li><span>Define the AMI b</span>efore you create an instance; <kbd>ami-id</kbd> will be different for all the regions. Please use the proper image ID as per your region. You can use tools such as Packer to create your own golden AMI. I've also attached Ansible code that you can use to create custom AMIs:</li>
</ol>
<pre style="padding-left: 60px">resource "aws_instance" "testapp" {<br/>  ami = "ami-12345t67"<br/>  instance_type = "${var.instance_type}"<br/>}</pre>
<ol start="3">
<li>Use providers, such as <kbd>"aws"</kbd>, to create instances in AWS. You can also set multiple providers in the configuration file to create instances in multiple providers in one go:</li>
</ol>
<pre class="highlight hcl" style="padding-left: 60px"><span class="n">Provider</span> <span class="s2">"aws"</span> <span class="p">{</span>
  <span class="n">access_key</span> <span class="o">=</span> <span class="s2">"ENTER_ACCESS_KEY"</span>
  <span class="n">secret_key</span> <span class="o">=</span> <span class="s2">"ENTER_SECRET_KEY"</span>
  <span class="n">region</span>     <span class="o">=</span> <span class="s2">"us-west-2" // you can select any region</span>
<span class="p">}</span></pre>
<div class="packt_infobox">Don't pass the <kbd>access_key</kbd> and <kbd>secret_key</kbd> variables if you want to use IAM roles. We will create IAM roles in a later section.<br/>
<br/>
Also, <span><kbd>access_key</kbd> and <kbd>secret_key</kbd> can be saved in <kbd>~/.aws/credentials</kbd> using the <kbd>profile</kbd> option:<br/>
<br/>
<kbd><strong># aws configure --profile user1</strong></kbd><br/>
<br/>
<kbd><strong>AWS Access Key ID [None]: ABCDEFGHIJKLMNOPQ</strong></kbd><br/>
<kbd><strong>AWS Secret Access Key [None]: wjVDFVdfdfklfF/G6vFGFGr/fsjfERDFFDGgFGDFGDF</strong></kbd><br/>
<kbd><strong>Default region name [None]: us-west-2</strong></kbd><br/>
<kbd><strong>Default output format [None]: json</strong></kbd><br/>
<br/></span></div>
<p class="mce-root" style="padding-left: 60px">Region details are given as follows:</p>
<table>
<tbody>
<tr>
<td>
<p><strong>Region</strong></p>
</td>
<td>
<p><strong>Region Name</strong></p>
</td>
</tr>
<tr>
<td>
<p>US East (Ohio)</p>
</td>
<td>
<p><kbd>us-east-2</kbd></p>
</td>
</tr>
<tr>
<td>
<p>US East (N. Virginia)</p>
</td>
<td>
<p><kbd>us-east-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>US West (N. California)</p>
</td>
<td>
<p><kbd>us-west-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>US West (Oregon)</p>
</td>
<td>
<p><kbd>us-west-2</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Asia Pacific (Tokyo)</p>
</td>
<td>
<p><kbd>ap-northeast-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Asia Pacific (Seoul)</p>
</td>
<td>
<p><kbd>ap-northeast-2</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Asia Pacific (Osaka-Local)</p>
</td>
<td>
<p><kbd>ap-northeast-3</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Asia Pacific (Mumbai)</p>
</td>
<td>
<p><kbd>ap-south-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Asia Pacific (Singapore)</p>
</td>
<td>
<p><kbd>ap-southeast-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Asia Pacific (Sydney)</p>
</td>
<td>
<p><kbd>ap-southeast-2</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Canada (Central)</p>
</td>
<td>
<p><kbd>ca-central-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>China (Beijing)</p>
</td>
<td>
<p><kbd>cn-north-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>China (Ningxia)</p>
</td>
<td>
<p><kbd>cn-northwest-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>EU (Frankfurt)</p>
</td>
<td>
<p><kbd>eu-central-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>EU (Ireland)</p>
</td>
<td>
<p><kbd>eu-west-1</kbd></p>
</td>
</tr>
<tr>
<td>
<p>EU (London)</p>
</td>
<td>
<p><kbd>eu-west-2</kbd></p>
</td>
</tr>
<tr>
<td>
<p>EU (Paris)</p>
</td>
<td>
<p><kbd>eu-west-3</kbd></p>
</td>
</tr>
<tr>
<td>
<p>South America (SÃ£o Paulo)</p>
</td>
<td>
<p><kbd>sa-east-1</kbd></p>
</td>
</tr>
</tbody>
</table>
<ol start="4">
<li>Initialize the configuration file by running the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform init</strong><br/><strong>$ terraform plan -var 'instance_type=t2.micro'</strong></pre>
<p style="padding-left: 60px">Once the configuration is done, the AWS plugin is set in a separate directory for further use.</p>
<ol start="5">
<li>Run the configuration in the same directory where your <kbd>main.tf</kbd> exists. You can also pass multiple variables in the command line:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform apply -var 'instance_type=t2.micro'</strong></pre>
<ol start="6">
<li>The output is pretty human-readable and equivalent to Git output. The output contains the implementation steps in detail. If the implementation starts with <kbd>+</kbd> (a plus sign), that means Terraform is creating resources.</li>
</ol>
<ol start="7">
<li>Before starting the creation of instances, Terraform will ask for confirmation. You can review the plan and click <kbd>yes</kbd>. If you are running Terraform as part of your automation, add <kbd>auto-approve</kbd> to automatically approve all the configurations:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraform apply -auto-approve -var 'instance_type=t2.micro'</strong></pre>
<p style="padding-left: 60px">The instance creation can take some time and once the instances are available, you can look for them in the console.</p>
<ol start="8">
<li>To get the current status of Terraform, enter the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>terraform show</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Modifying instances</h1>
                </header>
            
            <article>
                
<ol>
<li>To modify the instances, you need to make changes in <kbd>main.tf</kbd>. For example, I'm updating the elastic IP of the instance. The <kbd>aws_eip</kbd> module is used for allocation of elastic IPs:</li>
</ol>
<pre style="padding-left: 60px">resource "aws_eip" "ip" {<br/>  instance = "${aws_instance.testapp.id}"<br/>}</pre>
<ol start="2">
<li>Save the file and run the following commands again to make the changes in the instance:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform apply</strong><br/><br/><strong>+ aws_eip.ip</strong><br/><strong>    allocation_id: "&lt;computed&gt;"</strong><br/><strong>    association_id: "&lt;computed&gt;"</strong><br/><strong>    domain: "&lt;computed&gt;"</strong><br/><strong>    instance: "${aws_instance.example.id}"</strong><br/><strong>    network_interface: "&lt;computed&gt;"</strong><br/><strong>    private_ip: "&lt;computed&gt;"</strong><br/><strong>    public_ip: "&lt;computed&gt;"</strong></pre>
<p style="padding-left: 60px">Type <kbd>yes</kbd> to accept the changes and see the changes using the AWS console, or run the <kbd>terraform show</kbd> command.</p>
<ol start="3">
<li>Get the output by creating another <kbd>output.tf</kbd> file in the same directory. Add the following configuration details in the file:</li>
</ol>
<pre style="padding-left: 60px">output "ip" {<br/>  value = "${aws_eip.ip.public_ip}"<br/>}</pre>
<ol start="4">
<li>You can query separately to the IP output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform output ip</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Terminating instances</h1>
                </header>
            
            <article>
                
<p>Instances can be terminated with single commands. Make sure to run the commands from the same directory where your <kbd>main.tf</kbd> exists:</p>
<pre><strong>terraform destroy</strong><br/><strong># ...</strong><br/><br/><strong>- aws_instance.testap</strong></pre>
<div class="packt_infobox">If you want to forcefully destroy the instance, use the <kbd>"-force"</kbd> flag with the command.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Example of instance creation using Terraform</h1>
                </header>
            
            <article>
                
<ol>
<li>We have a sample configuration file to create an instance and set up a Route 53 DNS using that instance. Save the file as <kbd>main.tf</kbd>:</li>
</ol>
<pre style="padding-left: 60px">$ vi main.tf<br/><br/>variable "stack_name" { default = "MyTestMachine"}<br/>variable "aws_region" { default = "us-east-1" }<br/>variable "instance_type" { default = "t2.micro" }<br/>variable "instance_count" { default = "1" }<br/>variable "route53_zone_id"<br/>variable "security_group_id"<br/>provider "aws" {<br/>  region = "${var.aws_region}"<br/>}<br/>module "MyTestMachine" {<br/>  source = "./ec2_nodes"<br/>  instance_type = "${var.instance_type}"<br/>  stack_name = "${var.stack_name}"<br/>  role = "MyTestMachine"<br/>  count = "1"<br/>  security_group_id = "${var.security_group_id}"<br/>}<br/>resource "aws_route53_record" "MyTestMachine" {<br/>  zone_id = "${var.route53_zone_id}"<br/>  name = "${var.stack_name}-domainname.com"<br/>  type = "A"<br/>  ttl = "300"<br/>  records = ["${module.MyTestMachine.firstip}"]<br/>}</pre>
<ol start="2">
<li>I've put the source details in another file, so a single configuration file can be used to create multiple machines. Create an <kbd>ec2_nodes</kbd> folder and create <kbd>main.tf</kbd> inside the directory:</li>
</ol>
<pre style="padding-left: 60px">$ mkdir ec2_nodes<br/>$ cd ec2_nodes<br/>$ vi main.tf<br/><br/>variable "stack_name" {}<br/>variable "count" {}<br/>variable "role" {}<br/>variable "instance_type" {}<br/>variable "security_group_id" {}<br/>variable "route53_zone_id" {}<br/>resource "aws_instance" "MyTestMachine" {<br/>  ami = "ami-97785bed" # you can select any AMI instance<br/>  instance_type = "${var.instance_type}"<br/>  count = "${var.count}"<br/>  vpc_security_group_ids = [<br/>    "${var.security_group_id}" <br/>  ]<br/>  associate_public_ip_address = false<br/>  iam_instance_profile = "MyTestRole"<br/>  subnet_id = "subnet-12345678"<br/>  key_name = "aws-key-1234"<br/>    user_data = &lt;&lt;EOF<br/># yum update<br/>sudo yum update -y<br/>EOF<br/>  tags {<br/>    Name = "${var.stack_name}"<br/>    Role = "${var.role}"<br/>  }<br/>}<br/>resource "aws_route53_record" "nodecname" {<br/>  zone_id = "${var.route53_zone_id}"<br/>  count = "${var.count}"<br/>  name = "${var.stack_name}-${var.role}-${count.index}.domainname.com"<br/>  type = "A"<br/>  ttl = "300"<br/>  records = ["${element(aws_instance.MyTestMachine.*.private_ip, count.index)}"]<br/>}</pre>
<ol start="3">
<li>Now, we will create another output file inside the same directory, <kbd>ec2_nodes</kbd>:</li>
</ol>
<pre style="padding-left: 60px">output "first_ip" {<br/>  value = "${aws_instance.MyTestMachine.0.private_ip}"<br/>}</pre>
<ol start="4">
<li>Run the Terraform installation using the following commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ terraform workspace new MyTestMachine</strong><br/><strong>$ terraform workspace select MyTestMachine</strong><br/><br/><strong>$ terraform plan \</strong><br/><strong>  -var "stack_name=MyTestMachine" \</strong><br/><strong>    -var "instance_type=t2.micro" \</strong><br/><strong>    -var "route53_zone_id=123456789" \ </strong><br/><strong>    -var "security_group_id=sg-12345678"</strong><br/><br/><strong>$ terraform apply -auto-approve \</strong><br/><strong>  -var "stack_name=MyTestMachine" \</strong><br/><strong>    -var "instance_type=t2.micro" \</strong><br/><strong>    -var "route53_zone_id=123456789" \ </strong><br/><strong>    -var "security_group_id=sg-12345678"</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">EC2 CLI</h1>
                </header>
            
            <article>
                
<p><span>AWS CLI contains multiple modules to manage AWS resources. </span>EC2 CLI is a very straightforward way of creating and managing instances.</p>
<div class="packt_infobox">Install AWS CLI (commands): <br/>
<br/>
<kbd><strong>$ curl -O https://bootstrap.pypa.io/get-pip.py                   // Download pip</strong></kbd><br/>
<br/>
<kbd><strong>$ python get-pip.py --user                                                         // Install pip for the user</strong></kbd><br/>
<br/>
<kbd><strong>$pip install awscli --upgrade --user                                     // Install AWS CLI (remove --user if you want to install for all users)</strong></kbd></div>
<p>Format:</p>
<pre><strong>$ aws ec2 run-instances &lt;Pass parameters&gt;</strong></pre>
<p>Example:</p>
<pre><strong>$ aws ec2 run-instances --count 1 --security-groups launch-wizard-1 --subnet-id subnet-1234rt78 --instance-type t2.micro --key-name myTestKey --image-id ami-abc123dec --associate-public-ip-address --iam-instance-profile Name=MyTestIAM-Role</strong></pre>
<p>The output will contain all the details of the instance, including the instance ID as follows:</p>
<pre><strong>{</strong><br/><strong>    "Instances": [</strong><br/><strong>        {</strong><br/><strong>            "Monitoring": {</strong><br/><strong>                "State": "disabled"</strong><br/><strong>            },</strong><br/><strong>            "PublicDnsName": "",</strong><br/><strong>            "StateReason": {</strong><br/><strong>                "Message": "pending",</strong><br/><strong>                "Code": "pending"</strong><br/><strong>            },</strong><br/><strong>            "State": {</strong><br/><strong>                "Code": 0,</strong><br/><strong>                "Name": "pending"</strong><br/><strong>            },</strong><br/><strong>            "EbsOptimized": false,</strong><br/><strong>            "LaunchTime": "2018-03-10T07:55:32.000Z",</strong><br/><strong>            "PrivateIpAddress": "10.10.81.24",</strong><br/><strong>            "ProductCodes": [],</strong><br/><strong>            "VpcId": "vpc-123456b",</strong><br/><strong>            "StateTransitionReason": "",</strong><br/><strong>            "InstanceId": "i-1234d5r6t7y8g9aws",</strong><br/><strong>            "ImageId": "ami-12345678",</strong><br/><strong>            "PrivateDnsName": "ip-10-10-81-24.ap-southeast-1.compute.internal",</strong><br/><strong>            "KeyName": "MyTestKey",</strong><br/><strong>            "SecurityGroups": [</strong><br/><strong>                {</strong><br/><strong>                    "GroupName": "launch-wizard-1",</strong><br/><strong>                    "GroupId": "sg-12345678"</strong><br/><strong>                }</strong><br/><strong>            ],</strong><br/><strong>            "ClientToken": "",</strong><br/><strong>            "SubnetId": "subnet-1234rt78",</strong><br/><strong>            "InstanceType": "t2.micro",</strong><br/><strong>            "NetworkInterfaces": [</strong><br/><strong>                {</strong><br/><strong>                    "Status": "in-use",</strong><br/><strong>                    "MacAddress": "02:d4:43:07:9c:a4",</strong><br/><strong>                    "SourceDestCheck": true,</strong><br/><strong>                    "VpcId": "vpc-12345678",</strong><br/><strong>                    "Description": "",</strong><br/><strong>                    "NetworkInterfaceId": "eni-12345678",</strong><br/><strong>                    "PrivateIpAddresses": [</strong><br/><strong>                        {</strong><br/><strong>                            "Primary": true,</strong><br/><strong>                            "PrivateIpAddress": "10.10.81.24"</strong><br/><strong>                        }</strong><br/><strong>                    ],</strong><br/><strong>                    "SubnetId": "subnet-1234rt78",</strong><br/><strong>                    "Attachment": {</strong><br/><strong>                        "Status": "attaching",</strong><br/><strong>                        "DeviceIndex": 0,</strong><br/><strong>                        "DeleteOnTermination": true,</strong><br/><strong>                        "AttachmentId": "eni-attach-c5d3e72e",</strong><br/><strong>                        "AttachTime": "2018-03-12T07:55:32.000Z"</strong><br/><strong>                    },</strong><br/><strong>                    "Groups": [</strong><br/><strong>                        {</strong><br/><strong>                            "GroupName": "launch-wizard-1",</strong><br/><strong>                            "GroupId": "sg-12345678"</strong><br/><strong>                        }</strong><br/><strong>                    ],</strong><br/><strong>                    "Ipv6Addresses": [],</strong><br/><strong>                    "OwnerId": "1234567891011",</strong><br/><strong>                    "PrivateIpAddress": "10.10.81.24"</strong><br/><strong>                }</strong><br/><strong>            ],</strong><br/><strong>            "SourceDestCheck": true,</strong><br/><strong>            "Placement": {</strong><br/><strong>                "Tenancy": "default",</strong><br/><strong>                "GroupName": "",</strong><br/><strong>                "AvailabilityZone": "us-east-1a"</strong><br/><strong>            },</strong><br/><strong>            "Hypervisor": "xen",</strong><br/><strong>            "BlockDeviceMappings": [],</strong><br/><strong>            "Architecture": "x86_64",</strong><br/><strong>            "RootDeviceType": "ebs",</strong><br/><strong>            "IamInstanceProfile": {</strong><br/><strong>                "Id": "A1B2C3D4E5S6F7G8I9J1K0",</strong><br/><strong>                "Arn": "arn:aws:iam::1234567891011:instance-profile/MyTestIAM-Role"</strong><br/><strong>            },</strong><br/><strong>            "RootDeviceName": "/dev/xvda",</strong><br/><strong>            "VirtualizationType": "hvm",</strong><br/><strong>            "AmiLaunchIndex": 0</strong><br/><strong>        }</strong><br/><strong>    ],</strong><br/><strong>    "ReservationId": "r-123456789101112",</strong><br/><strong>    "Groups": [],</strong><br/><strong>    "OwnerId": "1234567891011"</strong><br/><strong>}</strong></pre>
<p>You can get the details of the instance ID:</p>
<pre><strong>$ aws ec2 describe-instances --instance-id &lt;id-awsinstanceid&gt;</strong></pre>
<p>To terminate an instance, use the following command:</p>
<pre><strong>$ aws ec2 terminate-instances --instance-ids "i-1234d5r6t7y8g9aws"</strong><br/><strong>{</strong><br/><strong>    "TerminatingInstances": [</strong><br/><strong>        {</strong><br/><strong>            "InstanceId": "i-1234d5r6t7y8g9aws",</strong><br/><strong>            "CurrentState": {</strong><br/><strong>                "Code": 32,</strong><br/><strong>                "Name": "shutting-down"</strong><br/><strong>            },</strong><br/><strong>            "PreviousState": {</strong><br/><strong>                "Code": 16,</strong><br/><strong>                "Name": "running"</strong><br/><strong>            }</strong><br/><strong>        }</strong><br/><strong>    ]</strong><br/><strong>}</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an Elastic Load Balancer, launch configuration, and Auto Scaling Groups</h1>
                </header>
            
            <article>
                
<p>In this section, we will see how to create ELB and ASG using AWS CLI.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Elastic Load Balancer</h1>
                </header>
            
            <article>
                
<p>An ELB automatically distributes a load/traffic across multiple instances in a part of different <strong>availability zones</strong> (<strong>AZs</strong>). The member instances can be part of single AZ or multiple AZs. An ELB becomes the single point of contact for the DNS and the end users. An ELB also monitors the instance via a health check; if the instance is healthy, then only the requests will be routed to the instance.</p>
<p>As we have already created instances, we will create an ELB using CLI. The command to do so is as follows:</p>
<pre><strong>$ aws elb create-load-balancer --load-balancer-name my-test-elb --listeners "Protocol=HTTP,LoadBalancerPort=80,InstanceProtocol=HTTP,InstancePort=80" --availability-zones us-west-2a us-west-2b</strong></pre>
<p>Add the newly created instance to the ELB:</p>
<pre><strong>$ aws elb register-instances-with-load-balancer --load-balancer-name my-test-elb --instances i-awsinstance12fd</strong></pre>
<div class="packt_infobox">An ELB can be monitored using CloudWatch, access logs, and AWS CloudTrail. An ELB can be internal or internet facing. Internet-facing ELBs can be associated with domain names.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Auto Scaling Groups</h1>
                </header>
            
            <article>
                
<p>Let's understand basic infrastructure scaling: </p>
<ul>
<li><strong>Scale out</strong>: Achieving scalability by increasing the number of EC2 instances</li>
<li><strong>Scale up</strong>: Achieving scalability by resizing the capacity (compute, memory, and EBS) of existing EC2 instances</li>
<li><strong>Scale down</strong>: Decreasing the number of EC2 instances of the configuration for existing EC2</li>
</ul>
<p>Auto Scaling takes care of scale out and scale down. Auto Scaling components are managed into groups so that they can be treated as separate logical units for management and scaling purposes. Auto Scaling Groups use <strong>launch configuration</strong> as a template to  create EC2 instances</p>
<pre><strong>$ aws autoscaling create-launch-configuration --launch-configuration-name my-test-launch --key-name my-key-pair --image-id ami-c1wjdlakf6 --instance-type m1.small --security-groups sg-lkjl3kmm --instance-type m1.small</strong> </pre>
<p>Scaling plans will define the threshold and conditions for triggering the ASG:</p>
<pre><strong>$ aws autoscaling create-auto-scaling-group --auto-scaling-group-name my-test-asg-group --launch-configuration-name test-launch --load-balancer-names my-test-elb --health-check-type ELB --health-check-grace-period 120 --min-size 1 --max-size 3 --desired-capacity 2 --default-cooldown 600--termination-policies "OldestInstance"<br/></strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">IAM roles</h1>
                </header>
            
            <article>
                
<p>AWS IAM role gives an extra layer of security by managing and rotating the keys themselves. Keys are encrypted credentials known as access key and secret key.</p>
<p>Access key example is as follows:</p>
<pre><strong>aws iam create-role --role-name myTestKey --assume-role-policy-document file://myTestKeyPolicy.json --description "Role for testing access from EC2 to S3 and Route 53"</strong></pre>
<p class="mce-root">A policy is JSON document consist of permission delegated from one AWS service to another AWS service. The default permission of an IAM role is all deny (by default blocks all the requests to any service until specified explicitly). Sample policy is for creating and managing an EC2 instance, S3 bucket, and Route 53.</p>
<p class="mce-root">Sample policy (save the following text as <kbd>myTestKeyPolicy.json</kbd>):</p>
<pre>{<br/>  "Version": "2012-10-17",<br/>  "Statement": [<br/>    {<br/>      "Action": "ec2:*",<br/>      "Effect": "Allow",<br/>      "Resource": "*"<br/>    },<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": "elasticloadbalancing:*",<br/>      "Resource": "*"<br/>    },<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": "cloudwatch:*",<br/>      "Resource": "*"<br/>    },<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": "autoscaling:*",<br/>      "Resource": "*"<br/>    },<br/>    {<br/>      "Effect": "Allow",<br/>      "Action": "iam:CreateServiceLinkedRole",<br/>      "Resource": "*",<br/>      "Condition": {<br/>        "StringEquals": {<br/>          "iam:AWSServiceName": [<br/>            "autoscaling.amazonaws.com",<br/>            "ec2scheduled.amazonaws.com",<br/>            "elasticloadbalancing.amazonaws.com",<br/>            "spot.amazonaws.com",<br/>            "spotfleet.amazonaws.com"<br/>          ]<br/>        }<br/>      }</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at various methods of creating EC2 instances for our software deployment. Once an instance has been created, push the software jars into your instances. Use the private instance IP, username (<kbd>ec2-user</kbd>), and private key (<kbd>test.pem</kbd>) to connect to your machine. Once the testing is completed, make sure you terminate the test instances so you don't pay for them.</p>
<div class="packt_tip"><strong>T2.micro</strong> <span>EC2 instance type</span> is free for use for one year for new AWS accounts.</div>
<p>Later on in the chapter, we went through the creation of ELBs and ASGs using AWS CLI.</p>
<div class="packt_tip">You can register your ELB DNS name with your domain service provider (for example, Route 53, GoDaddy, and BigRock) to resolve your application.</div>
<p>You can also try putting some workload into your application and see whether Auto Scaling is increasing the number of instances, and then remove the workload to test the termination policy.</p>
<div class="packt_tip">You can also use distributed filesystems, such as EFS, NFS, and GlusterFS, to share the workspaces among all nodes.</div>
<p>In the next chapter, we will cover the optimization and monitoring of applications using Test Cloud and Android monitoring tools. Test cloud is a mobile testing tool powered by Xamarin that it tests the applications of over 2000 devices. Android Monitor provides a GUI to debug and optimize applications.</p>


            </article>

            
        </section>
    </body></html>