- en: '13'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scanning Your Ansible Playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you will learn how to scan your Ansible playbooks using two
    third-party tools: Checkov and KICS. Both are open source and can help you identify
    and fix common configuration issues within your Ansible code, such as syntax errors,
    misconfigurations, hardcoded secrets, and deployment problems, which could lead
    to potential breaches.'
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this chapter, you will have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installed and run Checkov and KICS scans on our Ansible playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewed the results and reports generated during the scans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fixed any issues detected during the scans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why scan your playbooks?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker overview and installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring Checkov
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring KICS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rather than installing the tools locally, we will use Docker to execute the
    scans; there will be a little detail on how to install Docker later in the chapter.
    Additionally, we will be scanning a variation of the playbook we wrote in [*Chapter
    11*](B21620_11.xhtml#_idTextAnchor501), *Highly Available Cloud Deployments*;
    this can be found in the repository at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter13](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter13).
  prefs: []
  type: TYPE_NORMAL
- en: Why scan your playbooks?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we have been taking a sensible approach to deploying our cloud resources
    in previous chapters, many of the guardrails we have put in place have all been
    ones I have learned through experience and by applying a little common sense.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when launching a virtual machine resource in either Microsoft Azure
    or Amazon Web Services, we have been locking down the SSH or RDP service to the
    host’s public IP address, which is running Ansible; up until now, this has been
    your local machine rather than just opening SSH or RDP to the world by using `0.0.0.0/0`
    as the source address, which is the CIDR notation for *“**allow all.”*
  prefs: []
  type: TYPE_NORMAL
- en: This is not a problem for the workloads we have been working on; having a virtual
    machine exposed directly to the internet with its management port open for everyone
    to access is not considered best practice, as it will expose you to brute-force
    attacks, which, if they are successful, will not only lead to that machine being
    compromised; it could also act as a gateway to the rest of your network and other
    associated resources such as databases and storage.
  prefs: []
  type: TYPE_NORMAL
- en: I would class the preceding example as common sense, but as we launch more and
    more cloud services using our playbooks, how can we ensure that we are following
    best practices for services that maybe we haven’t had much experience with outside
    of getting something up and running? How can we put some guardrails in place to
    stop us from doing something before resources are deployed?
  prefs: []
  type: TYPE_NORMAL
- en: This is where the two tools we will look at in this chapter come in; they are
    designed to scan your playbooks, look at the configuration, and compare them to
    their best practice policies. Eventually, in [*Chapter 15*](B21620_15.xhtml#_idTextAnchor641),
    *Using Ansible with GitHub Actions and Azure DevOps*, we will build one of the
    two tools into our deployment pipelines, but for now, we are going to look at
    the tools and run them locally using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker overview and installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker, the platform that made containers popular, is both an open source and
    commercial solution that enables you to package all of the elements of your application,
    including libraries and other dependencies, alongside your own code in a single,
    easy-to-distribute package; this means that we won’t need to download and install
    all of the prerequisites for the tools that we will be running in this chapter
    or need to compile the tools from source to get working executables for our system.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the example in this chapter, you must install **Docker Desktop** on
    your host.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker Desktop on macOS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Docker Desktop on macOS, follow these three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Choose the appropriate installer for your Mac’s architecture:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For ARM64 (Apple Silicon), use [https://desktop.docker.com/mac/main/arm64/Docker.dmg](https://desktop.docker.com/mac/main/arm64/Docker.dmg).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: For AMD64 (Intel Macs), use [https://desktop.docker.com/mac/main/amd64/Docker.dmg](https://desktop.docker.com/mac/main/amd64/Docker.dmg).
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: After downloading, open the `Docker.dmg` file by double-clicking it. In the
    opened window, drag the Docker icon to your Applications folder to install Docker
    Desktop. It will be installed at `/Applications/Docker.app`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To launch Docker, navigate to the Applications folder and double-click on **Docker**;
    this will start **Docker Desktop**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you first launch Docker Desktop, it will walk you through the remaining
    installation steps and run in the background once complete.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker Desktop on Windows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To install Docker Desktop on Windows, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the Docker Desktop Installer for Windows from this link: [https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe](https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the downloaded `C:\Program Files\Docker\Docker`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: During the installation, you may be prompted to choose whether to use **WSL
    2 (Windows Subsystem for Linux 2)** or **Hyper-V** as the backend. Select the
    **Use WSL 2 instead of Hyper-V** option, as we have used this throughout the book
    to run Ansible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the on-screen instructions provided by the installation wizard to authorize
    the installer and complete the installation process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the installation is completed, click **Close** to finish the setup.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From here, you can open Docker Desktop from the start menu, and it will run
    in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker Desktop on Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are running a Linux Desktop, the instructions will differ slightly depending
    on your Linux distribution; for detailed instructions, see [https://docs.docker.com/desktop/linux/install/](https://docs.docker.com/desktop/linux/install/).
  prefs: []
  type: TYPE_NORMAL
- en: Now, with Docker Desktop installed, we can look at the first of the two tools
    we will look at.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Checkov
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Checkov is an open source static code analysis tool maintained by Prisma Cloud
    designed for **infrastructure-as-code** (**IaC**).
  prefs: []
  type: TYPE_NORMAL
- en: It helps developers and DevOps teams identify misconfigurations in their files
    before deployment to cloud environments. By scanning the code for tools such as
    Terraform, CloudFormation, Kubernetes, and others, including Ansible, Checkov
    checks against best practices and compliance guidelines, ensuring your infrastructure
    deployments are secure, efficient, and compliant with industry standards before
    it is deployed.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: You may have noticed that Ansible is mentioned as “others” in the preceding
    description; that is because support for Ansible was only just introduced at the
    time of writing this in early 2024\. Because of this, while we will be looking
    at Checkov during this chapter, we will not be going into as much detail about
    Checkov or the second tool, Kics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we run our scan, we need a playbook; open your terminal and check out
    the scan GitHub repository by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This repository contains a copy of the final playbook code from [*Chapter 11*](B21620_11.xhtml#_idTextAnchor501),
    *Highly Available* *Cloud Deployments*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the code checked out, we can download the Checkov container
    image. To do this, we need to pull it from Docker Hub by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will download the image from [https://hub.docker.com/r/bridgecrew/checkov](https://hub.docker.com/r/bridgecrew/checkov),
    and with it downloaded, we can now scan our playbook code.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run the scan, issue the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we review the results, let’s quickly break down the command that we
    have just run:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker container run` executes a new Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--rm` instructs Docker to remove the container after it exits automatically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--tty` allocates a pseudo-TTY, which makes the scan output readable to our
    session.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--volume ./:/ansible` mounts the current directory, defined as `./`, to the
    `/ansible` path inside the container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--workdir /ansible` sets the working directory inside the container to `/ansible`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bridgecrew/checkov` specifies the Checkov Docker image we have just pulled
    from the Docker Hub.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--directory /ansible` instructs Checkov to scan files in `/ansible`; it is
    not part of the Docker command but is sending instructions to the Checkov binary,
    which is the default entry point for our container to run the scan. If we had
    Checkov installed locally, then this would be the equivalent to running the `checkov
    --directory /``ansible` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have broken down the command used to run the scan, we can look
    at the output of the scan itself, starting with the overview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have more passes than failed checks, which is a good start;
    the next section of the output details the checks, starting with the following
    passes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Our first pass checks to see if we are instructing the `ansible.builtin.get_url`
    module to bypass certificate validation when connecting to an HTTPS site to download
    content.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next four passes are for the two times our playbook uses the `ansible.builtin.apt`
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first pair of passes ensures that we are not installing any packages that
    are not correctly signed. The second pair of passes also checks for the same thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, this time, the check ensures that we are not using the force parameter,
    which, as you can see from the description, disables signature checks and can
    also leave our APT database in a little bit of a state if things go wrong.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we move on to the failures; the first failure is the one we called out
    as the example when we spoke about why you would want to use the tools we are
    covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So, what gives? As you may recall from [*Chapter 11*](B21620_11.xhtml#_idTextAnchor501),
    *Highly Available Cloud Deployments*, the instance we are launching is only temporary
    and accessible while the playbook is running. However, Checkov doesn’t know this,
    so it rightly calls it out and, as you can see, provides details on why this is
    via the guide URL, which, for this check, is [https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/public-policies/public-12](https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/public-policies/public-12).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the next failure in the scan, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Checkov believes a parameter is missing from the `amazon.aws.ec2_instance`
    block when we launch the temporary EC2 instance. It is recommended that the parameter
    `ebs_optimized` is set to `true` rather than keeping the value as `false`, which
    is the default for the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final failure in the scan output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As Checkov is doing static code analysis, it isn’t designed to check for the
    contents of variables. Because the policy checks that we are providing a secure
    URL (that is, `https://domain.com/` in the `url` section of the task) it fails,
    as it is just seeing the `{{ wp_cli.download }}` variable name rather than the
    contents of the variable.
  prefs: []
  type: TYPE_NORMAL
- en: If you are keeping count, that makes two of the three failed checks false positives;
    for the first failure, we can accept the risk, as we know the machine is only
    temporary, and we know that we are locking the EC2 instance down to trusted IP
    addresses.
  prefs: []
  type: TYPE_NORMAL
- en: For the third failure, we can confirm that the contents of the `{{ wp_cli.download
    }}` variable is a secure URL, as it is `https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar`.
  prefs: []
  type: TYPE_NORMAL
- en: The second failure is the only one we need to look at; let’s take a look at
    the tasks, starting with the `Amazon.aws.ec2_instance` one.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we need to add two things; the first thing is a comment to instruct Checkov
    that we accept the risk being highlighted by the `CKV_AWS_88` policy, and then
    we need to set `ebs_optimized` to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the updates I have made to `roles/ec2tmp/tasks/main.yml`;
    everything below the `name` parameter remains as is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, instructing Checkov to skip a check is straightforward; the
    comment is split into four parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`#` is the standard syntax for starting a comment in a YAML file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`checkov:` instructs Checkov to pay attention to the contents of the comment'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skip=CKV_AWS_88:` instructs Checkov to skip the `CKV_AWS_88` check when it
    runs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"While a public IP address is assigned to the instance, it is locked down
    by the security group and the instance is temporary."` is the suppress comment
    that will appear in the output when we run the scan'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next line in the update task implements the recommendation that we set the
    `ebs_optimized` parameter to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we move on to the second task, which we need to update, and can be found
    in `roles/wordpress/tasks/main.yml`. Here, we just add a comment to make Checkov
    skip `CKV2_ANSIBLE_2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are following along, the repository contains a branch called `checkov`;
    with the preceding detailed changes applied, you can switch to it by running the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we can re-run the scan using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'I can see that my changes have both suppressed and resolved the three failures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We have the pass for `CKV_AWS_135`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We also have the two false positives now showing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second one, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our comments are visible for all to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, returning to the call-out at the start of the section, why have we covered
    this tool if Checkov doesn’t have full coverage for Ansible? As you can see from
    the output of the scan of our playbook, while there is not much coverage now,
    each new release brings additional Ansible policies. Hence, as time goes on, coverage
    should only get more robust, and hopefully, we will bring this promising tool
    in line with the second tool we will look at: **KICS**, or to give it its full
    title, **keeping infrastructure as** **code secure**.'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring KICS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KICS is another static code analysis tool, and like Checkov, it is open source.
    It is designed to help you find common misconfiguration issues, potential compliance
    issues, and even security vulnerabilities within your IaC code. It ships with
    support for Kubernetes, Docker, AWS CloudFormation, Terram, and, of course, Ansible,
    which we will be focusing on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: KICS is designed to be easy to install, understand, and integrate into CI/CD
    pipelines. It includes over 2,400 customizable rules and is built for extensibility,
    allowing for the easy addition of support for new IaC tools and updates to existing
    integrations.
  prefs: []
  type: TYPE_NORMAL
- en: KICS is maintained and supported by **Checkmarx** specialists in software application
    security testing, meaning that KICS has a good pedigree.
  prefs: []
  type: TYPE_NORMAL
- en: Running the scan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s dive straight in. If you haven’t already, check out the example repository
    using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can pull the latest container image from Docker Hub ([https://hub.docker.com/r/checkmarx/kics](https://hub.docker.com/r/checkmarx/kics))
    by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Change to the folder containing our Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the scan itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the docker command follows the same pattern we discussed when
    we ran Checkov up until where we pass the options to the KICS binary; here, we
    instruct KICS to run `scan` against the `--path /ansible/`, which is the directory
    we have mounting from our host machine inside the container using the `--``volume`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the results
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s take a look at the result of the scan; KICS presents its output,
    which is slightly different from Checkov in that the initial output is designed
    to give real-time information on the scan itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now work through the various results and group them by severity levels.
  prefs: []
  type: TYPE_NORMAL
- en: Info and low-severity results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first result highlights potentially risky file permissions for the files
    we create (using templates) or copy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'It then goes on to list all the affected files; here is a snippet of the first
    few:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is another:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Moving on to the next issue, we see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, here is a sample of where it has spotted the issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next and final low-scoring result is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are the details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Let’s quickly review the low-scoring ones before moving on to the one result
    with a medium score.
  prefs: []
  type: TYPE_NORMAL
- en: So, the first result was, **“Some modules could end up creating new files on
    disk with permissions that might be too open or unpredictable”**. It called out
    11 places within our playbook where this could be an issue, so we should look
    at resolving these.
  prefs: []
  type: TYPE_NORMAL
- en: First off, if you ran the full scan, you will have noticed that three of the
    results are from the `destroy.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: Given that these tasks are removing files, we don’t care about the file permissions
    here. So, rather than adding the permissions to the individual tasks, we should
    instruct KICS not to run the check across the whole file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to add the following comment at the very top of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have `ansible.builtin.template` in `roles/efs/tasks/main.yml`. Rather
    than skip the test, I added the permissions using the `mode` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The final result is for the `ansible.builtin.get_url` module used by the task,
    which downloads `wp-cli` in the `roles/wordpress/tasks/main.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When reviewing the code, it looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This was immediately followed by the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, KICS highlights that we can set the mode as part of `ansible.builtin.get_url`,
    which means we do not have to do it separately, so I added the following to the
    download task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Then, I removed the second task. That clears the file permission issues KICS
    reported.
  prefs: []
  type: TYPE_NORMAL
- en: The next LOW score says, **“Setting state to latest performs an update and installs
    additional packages possibly resulting in performance degradation or loss** **of
    service”**.
  prefs: []
  type: TYPE_NORMAL
- en: 'This appears in `roles/stack-install/tasks/main.yml`, where the task uses `ansible.builtin.apt`
    to update the installed images, as this task is only called when we bootstrap
    our temporary EC2 instance and we made allowances for changes to the PHP version
    in the main playbook. I think it is safe to accept this as a false positive, so
    we can tell KICS not to run the test on this file by adding the following to the
    very top of `roles/stack-install/tasks/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This leaves us with `destroy.yml`, so the lack of tags does matter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s exclude the check from being run. To do this, we need to append it to
    the end of the comment we already added, which means the comment at the end of
    `destroy.yml` now reads this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When appending IDs, please ensure that a comma separates them; otherwise, KICS
    will read them as one string. Finally, we have the high-severity results.
  prefs: []
  type: TYPE_NORMAL
- en: High-severity results
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Luckily, here we have just two problems called out across four tasks, starting
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The second is in the `destroy.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'I think you can probably guess how we are going to resolve the second one;
    let’s get it to ignore the test in `destroy.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'For `roles/efs/tasks/main.yml`, the recommendation is to enable encryption,
    so let’s take that advice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the preceding snippet, we have added the `encrypt` parameter
    and set it to `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next issue highlighted by KICS also has to do with EFS filesystem encryption:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The results are for the same files as the previous issue, so we will append
    the ID to the list of checks to disable at the top of the `destroy.yml` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that this is just a demo environment, I am happy to accept the potential
    risk of not using a customer-managed key vault to store my own managed encryption
    keys; so, in this instance, I will add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: I’ll do so at the very top of the `roles/efs/tasks/main.yml` file. If this were
    a fixed production environment, then I would have added a role to launch and maintain
    AWS Key Management Service ([https://aws.amazon.com/kms/](https://aws.amazon.com/kms/))
    as part of the deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The results summary
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final part of the rules gives an overview of everything we have covered,
    which, for the initial scan with none of the fixes in place, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Re-running the scan
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As before, there is a branch containing all of the updated files we discussed
    and implemented in the previous section; to change to it, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then run the scan again using this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This should now return a clean bill of health:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, no problems are being reported now.
  prefs: []
  type: TYPE_NORMAL
- en: Output files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we finish the chapter, there is one more thing that we should quickly
    discuss about KICS: its ability to output a report in various file formats.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you were to re-run the scans against the `main` and `kics` branches but
    using the following command, then you will notice that a file called `results.html`
    appears in your repo folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are passing in two new flags; the first, `--report-formats`,
    tells KICS to output a report as an `html` file, and the second, `--output-path`,
    lets KICS know where to save the report file; in our case, as we are running KICS
    in a container that needs to be a location within the container that persists,
    once the container has finished running, the container will automatically be removed
    along with any files written.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running the command against the main branch, which does not contain any
    of the fixes, we applied the header of the report, which looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.1 – Viewing the report showing issues](img/B21620_13_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.1 – Viewing the report showing issues
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, re-running the scan against the KICS branch updates it to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.2 – A clean bill of health](img/B21620_13_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 13.2 – A clean bill of health
  prefs: []
  type: TYPE_NORMAL
- en: You can also output in PDF, JSON, and other standard reporting formats. As you
    can see, this is a little more digestible than reading the output of the command
    line report we covered in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: We will put these reports to good use when we get to [*Chapter 15*](B21620_15.xhtml#_idTextAnchor641),
    *Using Ansible with GitHub Actions and Azure DevOps*, as we will publish the results
    as part of our pipeline runs.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered two tools that we can add to our workflows,
    and we manually ran scans against the playbook we developed in [*Chapter 11*](B21620_11.xhtml#_idTextAnchor501),
    *Highly Available Cloud Deployments*. As mentioned in the chapter, Checkov's support
    for Ansible is relatively new, so it has a different coverage to KICS. However,
    I am sure you agree that both tools worked well.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There is one elephant in the room, though; even without the same coverage level,
    both tools came up with slightly different results, so you should never rely on
    them 100% to fully secure your deployments. Think of them as trusted colleagues
    reviewing your code for anything obvious that stands out as being an issue rather
    than a security-focused cloud platform architect with a working knowledge of your
    workload who dictates precisely what measures you should take when deploying your
    infrastructure in a secure way fully.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned at the end of the previous section, we will be revisiting
    KICS in [*Chapter 15*](B21620_15.xhtml#_idTextAnchor641), *Using Ansible with
    GitHub Actions and Azure DevOps*. Before we get there, now that we have looked
    at how we can review and secure our playbook code, we can now look at how we can
    secure our workload by quickly applying security best practices to the host operating
    systems that we are targeting using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information about the tools and their maintainers, see the following
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Checkov**: [https://www.checkov.io/](https://www.checkov.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prisma** **Cloud**: [https://www.paloaltonetworks.com/prisma/cloud/](https://www.paloaltonetworks.com/prisma/cloud/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KICS**: [http://kics.io/](http://kics.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Checkmarx**: [https://checkmarx.com/](https://checkmarx.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
