- en: Mastering Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 精通容器
- en: 'In the previous chapter, you learned how to optimally prepare your working
    environment for the productive and frictionless use of Docker. In this chapter,
    we are going to get our hands dirty and learn everything that is important to
    know when working with containers. Here are the topics we''re going to cover in
    this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学会了如何优化地准备你的工作环境，以便高效、顺畅地使用 Docker。在本章中，我们将开始动手实践，学习与容器相关的所有重要内容。以下是我们将在本章中覆盖的主题：
- en: Running the first container
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: Starting, stopping, and removing containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启动、停止和删除容器
- en: Inspecting containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查容器
- en: Exec into a running container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进入正在运行的容器
- en: Attaching to a running container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 附加到正在运行的容器
- en: Retrieving container logs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索容器日志
- en: Anatomy of containers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的结构
- en: 'After finishing this chapter, you will be able to do the following things:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做到以下几点：
- en: Run, stop, and delete a container based on an existing image, such as Nginx,
    BusyBox, or Alpine.
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于现有镜像（例如 Nginx、BusyBox 或 Alpine）运行、停止和删除容器。
- en: List all containers on the system.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出系统上的所有容器。
- en: Inspect the metadata of a running or stopped container.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查正在运行或已停止容器的元数据。
- en: Retrieve the logs produced by an application running inside a container.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检索在容器内运行的应用程序生成的日志。
- en: Run a process such as `/bin/sh` in an already-running container.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在已运行的容器中运行诸如 ` /bin/sh` 的进程。
- en: Attach a Terminal to an already-running container.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将终端附加到一个已经在运行的容器。
- en: Explain in your own words to an interested lay person the underpinnings of a
    container.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用你自己的话向一个感兴趣的外行解释容器的基本原理。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, you should have installed Docker for Desktop on your macOS
    or Windows PC. If you are on an older version of Windows or are using Windows
    10 Home Edition, then you should have Docker Toolbox installed and ready to use.
    On macOS, use the Terminal application, and on Windows, a PowerShell or Bash console,
    to try out the commands you will be learning.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章内容，你应该已经在你的 macOS 或 Windows 电脑上安装了 Docker for Desktop。如果你使用的是较旧版本的 Windows
    或 Windows 10 家庭版，那么你应该已经安装并准备好使用 Docker Toolbox。在 macOS 上，请使用终端应用程序，而在 Windows
    上，使用 PowerShell 或 Bash 控制台，来尝试你将要学习的命令。
- en: Running the first container
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行第一个容器
- en: 'Before we start, we want to make sure that Docker is installed correctly on
    your system and ready to accept your commands. Open a new Terminal window and
    type in the following command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们要确保 Docker 已正确安装在你的系统上并准备好接受你的命令。打开一个新的终端窗口并输入以下命令：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you are using Docker Toolbox then use the Docker Quickstart Terminal that
    has been installed with the Toolbox, instead of the Terminal on macOS or Powershell
    on Windows.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Docker Toolbox，请使用与 Toolbox 一起安装的 Docker Quickstart Terminal，而不是 macOS
    上的终端或 Windows 上的 PowerShell。
- en: 'If everything works correctly, you should see the version of Docker client
    and server installed on your laptop output in the Terminal. At the time of writing,
    it looks like this (shortened for readability):'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该能在终端中看到已安装的 Docker 客户端和服务器的版本信息。在撰写本文时，它看起来像这样（为了可读性已缩短）：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: You can see that I have `beta3` of version `19.03.0` installed on my macOS.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到我在我的 macOS 上安装了 `beta3` 版本 `19.03.0`。
- en: If this doesn't work for you, then something with your installation is not right.
    Please make sure that you have followed the instructions in the previous chapter
    on how to install Docker for Desktop or Docker Toolbox on your system.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这对你不起作用，那么说明你的安装可能有问题。请确保你按照上一章中关于如何在系统上安装 Docker for Desktop 或 Docker Toolbox
    的说明进行了操作。
- en: 'So, you''re ready to see some action. Please type the following command into
    your Terminal window and hit *Return*:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你已经准备好看到一些操作了。请在终端窗口中输入以下命令并按 *Return*：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When you run the preceding command the first time, you should see an output
    in your Terminal window similar to this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当你第一次运行前面的命令时，你应该会在终端窗口中看到类似这样的输出：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that was easy! Let''s try to run the very same command again:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单！让我们尝试再次运行完全相同的命令：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The second, third, or *n*^(th) time you run the preceding command, you should
    see only this output in your Terminal:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 第二次、第三次，或 *n*^(th) 次运行前面的命令时，你应该只在终端中看到这个输出：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Try to reason about why the first time you run a command you see a different
    output than all of the subsequent times. But don't worry if you can't figure it
    out; we will explain the reasons in detail in the following sections of this chapter.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试推理一下为什么第一次运行命令时，输出和后续的所有输出都不同。但如果你无法弄清楚，也不用担心；我们将在本章的后续部分详细解释原因。
- en: Starting, stopping, and removing containers
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启动、停止和删除容器
- en: 'You have successfully run a container in the previous section. Now, we want
    to investigate in detail what exactly happened and why. Let''s look again at the
    command we used:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你在上一节中已经成功运行了一个容器。现在，我们想详细调查一下到底发生了什么，以及为什么会这样。让我们再看看我们使用的命令：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command contains multiple parts. First and foremost, we have the word `docker`.
    This is the name of the Docker **Command-Line Interface** (**CLI**) tool, which
    we are using to interact with the Docker engine that is responsible to run containers.
    Next, we have the word `container`, which indicates the context we are working
    with. As we want to run a container, our context is the word `container`. Next
    is the actual command we want to execute in the given context, which is `run`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令包含多个部分。首先，我们有`docker`这个词。这是 Docker **命令行接口** (**CLI**) 工具的名称，我们用它与负责运行容器的
    Docker 引擎进行交互。接下来是`container`这个词，表示我们正在处理的上下文。因为我们想运行一个容器，所以我们的上下文是`container`这个词。接下来是我们想在给定上下文中执行的实际命令，即`run`。
- en: Let me recap—so far, we have `docker container run`, which means, *Hey Docker,
    we want to run a container.*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我总结一下——到目前为止，我们有 `docker container run`，这意味着，*嘿，Docker，我们要运行一个容器。*
- en: Now we also need to tell Docker which container to run. In this case, this is
    the so-called `alpine` container.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还需要告诉 Docker 运行哪个容器。在这种情况下，就是所谓的`alpine`容器。
- en: '`alpine` is a minimal Docker image based on Alpine Linux with a complete package
    index and is only 5 MB in size.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`alpine` 是一个基于 Alpine Linux 的最小 Docker 镜像，带有完整的软件包索引，大小仅为 5 MB。'
- en: Finally, we need to define what kind of process or task shall be executed inside
    the container when it is running. In our case, this is the last part of the command, `echo
    "Hello World"`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要定义当容器运行时，应该在容器内部执行什么样的进程或任务。在我们的例子中，这就是命令的最后一部分，`echo "Hello World"`。
- en: 'Maybe the following screenshot can help you to get a better idea of the whole
    thing:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 也许以下截图能帮助你更好地理解整个过程：
- en: '![](img/aa2c9ba0-11fb-4b2a-ae10-2c3419981032.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa2c9ba0-11fb-4b2a-ae10-2c3419981032.png)'
- en: Anatomy of the docker container run expression
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 容器运行表达式的组成
- en: 'Now that we have understood the various parts of a command to run a container,
    let''s try to run another container with a different process running inside it.
    Type the following command into your Terminal:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了运行容器命令的各个部分，接下来让我们尝试运行另一个容器，并在其中执行不同的进程。请输入以下命令到你的终端：
- en: '[PRE7]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see output in your Terminal window similar to the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在终端窗口中看到类似以下的输出：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What changed is that this time, the container image we're using is `centos` and
    the process we're executing inside the `centos` container is `ping -c 5 127.0.0.1`,
    which pings the loopback address five times until it stops.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这次改变的是，我们使用的容器镜像是 `centos`，而我们在 `centos` 容器中执行的进程是 `ping -c 5 127.0.0.1`，它会向回环地址发送五次
    ping 请求，直到停止。
- en: '`centos` is the official Docker image for CentOS Linux, which is a community-supported
    distribution derived from sources freely provided to the public by **Red Hat**for
    **Red Hat Enterprise Linux** (**RHEL**).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`centos` 是 CentOS Linux 的官方 Docker 镜像，CentOS 是一个由 **Red Hat** 提供支持的社区发行版，源代码免费公开，源自
    **Red Hat Enterprise Linux** (**RHEL**)。'
- en: Let's analyze the output in detail.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细分析输出内容。
- en: 'The first line is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行如下：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This tells us that Docker didn''t find an image named `centos:latest` in the
    local cache of the system. So, Docker knows that it has to pull the image from
    some registry where container images are stored. By default, your Docker environment
    is configured so that images are pulled from Docker Hub at `docker.io`. This is
    expressed by the second line, as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 Docker 没有在系统的本地缓存中找到名为 `centos:latest` 的镜像。因此，Docker 知道它必须从某个存储容器镜像的注册表中拉取镜像。默认情况下，Docker
    环境配置为从 Docker Hub（`docker.io`）拉取镜像。第二行表达了这一点，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The next three lines of output are as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三行输出如下：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This tells us that Docker has successfully pulled the `centos:latest` image from
    Docker Hub.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们 Docker 已成功从 Docker Hub 拉取了 `centos:latest` 镜像。
- en: All of the subsequent lines of the output are generated by the process we ran
    inside the container, which is the Ping tool in this case. If you have been attentive
    so far, then you might have noticed the `latest` keyword occurring a few times.
    Each image has a version (also called `tag`), and if we don't specify a version
    explicitly, then Docker automatically assumes it is `latest`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 所有后续的输出行都是由我们在容器内运行的进程生成的，在这个例子中是 Ping 工具。如果你到目前为止一直很专注，那么你可能已经注意到 `latest`
    关键字出现了几次。每个镜像都有一个版本（也叫做 `tag`），如果我们没有明确指定版本，Docker 会默认认为它是 `latest`。
- en: If we run the preceding container again on our system, the first five lines
    of the output will be missing since, this time, Docker will find the container
    image cached locally and hence won't have to download it first. Try it out and
    verify what I just told you.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们再次在系统中运行前面的容器，输出的前五行将会缺失，因为这次 Docker 会在本地找到已缓存的容器镜像，因此不需要先下载它。试试看，验证我刚才告诉你的内容。
- en: Running a random trivia question container
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行一个随机问答问题容器
- en: For the subsequent sections of this chapter, we need a container that runs continuously
    in the background and produces some interesting output. That's why we have chosen
    an algorithm that produces random trivia questions. The API that produces that
    free random trivia can be found at [http://jservice.io/](http://jservice.io/).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后续部分，我们需要一个容器，它会在后台持续运行并产生一些有趣的输出。这就是为什么我们选择了一个会产生随机问答问题的算法。生成这些免费随机问答问题的
    API 可以在 [http://jservice.io/](http://jservice.io/) 找到。
- en: 'Now the goal is to have a process running inside a container that produces
    a new random trivia question every five seconds and outputs the question to `STDOUT`.
    The following script will do exactly that:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的目标是在容器内运行一个进程，该进程每五秒产生一个新的随机问答问题，并将问题输出到 `STDOUT`。以下脚本将准确地做到这一点：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Try it in a Terminal window. Stop the script by pressing *Ctrl *+ *C*. The
    output should look similar to this:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端窗口中尝试一下。通过按 *Ctrl* + *C* 停止脚本。输出应该类似于下面这样：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Each response is a different trivia question.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 每个响应都是一个不同的问答问题。
- en: You may need to install `jq` first on your macOS or Windows computer. `jq` is
    a handy tool often used to nicely filter and format JSON output, which increases
    the readability of it on the screen.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要先在 macOS 或 Windows 计算机上安装 `jq`。`jq` 是一个常用的工具，通常用于漂亮地筛选和格式化 JSON 输出，从而提高它在屏幕上的可读性。
- en: 'Now, let''s run this logic in an `alpine` container. Since this is not just
    a simple command, we want to wrap the preceding script in a script file and execute
    that one. To make things simpler, I have created a Docker image called `fundamentalsofdocker/trivia`
    that contains all of the necessary logic, so that we can just use it here. Later
    on, once we have introduced Docker images, we will analyze this container image
    further. For the moment, let''s just use it as is. Execute the following command
    to run the container as a background service. In Linux, a background service is
    also called a daemon:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `alpine` 容器中运行这个逻辑。由于这不仅仅是一个简单的命令，我们希望将前面的脚本包装在一个脚本文件中并执行该文件。为了简化操作，我创建了一个名为
    `fundamentalsofdocker/trivia` 的 Docker 镜像，其中包含了所有必要的逻辑，这样我们就可以直接在这里使用它。稍后，当我们介绍
    Docker 镜像时，我们将进一步分析这个容器镜像。目前，让我们直接使用它。执行以下命令以将容器作为后台服务运行。在 Linux 中，后台服务也称为守护进程：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding expression, we have used two new command-line parameters, `-d` and `--name`.
    Now, `-d` tells Docker to run the process running in the container as a Linux
    daemon. The `--name` parameter, in turn, can be used to give the container an
    explicit name. In the preceding sample, the name we chose is `trivia`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表达式中，我们使用了两个新的命令行参数，`-d` 和 `--name`。现在，`-d` 告诉 Docker 以 Linux 守护进程的方式运行容器中的进程。`--name`
    参数则可以用来为容器指定一个明确的名称。在前面的示例中，我们选择的名称是 `trivia`。
- en: If we don't specify an explicit container name when we run a container, then
    Docker will automatically assign the container a random but unique name. This
    name will be composed of the name of a famous scientist and an adjective. Such
    names could be `boring_borg` or `angry_goldberg`. They're quite humorous, our
    Docker engineers, *aren't they?*
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在运行容器时没有指定明确的容器名称，那么 Docker 会自动为容器分配一个随机但唯一的名称。这个名称通常由一个著名科学家的名字和一个形容词组成。类似的名称可能是
    `boring_borg` 或 `angry_goldberg`。它们相当幽默，不是吗，我们的 Docker 工程师，*是不是？*
- en: We are also using the tag `ed2` for the container. This tag just tells us that
    this image has been created for the second edition of this book.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还为容器使用了 `ed2` 标签。这个标签只是告诉我们，这个镜像是为本书的第二版创建的。
- en: 'One important takeaway is that the container name has to be unique on the system.
    Let''s make sure that the trivia container is up and running:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的要点是容器名称在系统中必须是唯一的。让我们确保 `trivia` 容器正在运行：
- en: '[PRE15]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should give us something like this (shortened for readability):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该给我们类似于下面的结果（为了可读性，已缩短）：
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The important part of the preceding output is the `STATUS` column, which in
    this case is `Up 9 seconds`. That is, the container has been up and running for
    9 seconds now.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 上面输出的重要部分是 `STATUS` 列，在本例中显示为 `Up 9 seconds`，也就是说，容器已经运行了 9 秒钟。
- en: Don't worry if the last Docker command is not yet familiar to you, we will come
    back to it in the next section.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还不熟悉最后一条 Docker 命令，不用担心，我们将在下一节中再次讲解它。
- en: 'To complete this section, let''s stop and remove the `trivia` container with
    the following command:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本节内容，让我们通过以下命令停止并删除 `trivia` 容器：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now it is time to learn how to list containers running or dangling on our system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候学习如何列出系统中正在运行或悬挂的容器了。
- en: Listing containers
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出容器
- en: 'As we continue to run containers over time, we get a lot of them in our system.
    To find out what is currently running on our host, we can use the `container ls` command,
    as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们不断运行容器，系统中会积累很多容器。要查看当前在主机上运行的容器，我们可以使用 `container ls` 命令，如下所示：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This will list all currently running containers. Such a list might look similar
    to this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出当前正在运行的所有容器。这样的列表可能会类似于：
- en: '![](img/068c2859-04d5-43a4-9e16-e1326761f468.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/068c2859-04d5-43a4-9e16-e1326761f468.png)'
- en: List of all containers running on the system
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 列出系统上所有运行的容器
- en: 'By default, Docker outputs seven columns with the following meanings:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Docker 输出七列，含义如下：
- en: '|  **Column**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '|  **Column**'
- en: '|  **Description**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '|  **Description**'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Container ID` | This is the unique ID of the container. It is an SHA-256.
    |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `Container ID` | 这是容器的唯一 ID，采用 SHA-256 格式。 |'
- en: '| `Image` | This is the name of the container image from which this container
    is instantiated. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `Image` | 这是该容器所基于的容器镜像的名称。 |'
- en: '| `Command` | This is the command that is used to run the main process in the
    container. |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `Command` | 这是用于在容器中运行主进程的命令。 |'
- en: '| `Created` | This is the date and time when the container was created. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `Created` | 这是容器创建的日期和时间。 |'
- en: '| `Status` | This is the status of the container (created, restarting, running,
    removing, paused, exited, or dead). |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `Status` | 这是容器的状态（创建中、重启中、运行中、删除中、暂停中、已退出或已死亡）。 |'
- en: '| `Ports` | This is the list of container ports that have been mapped to the
    host. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `Ports` | 这是已映射到主机的容器端口列表。 |'
- en: '| `Names` | This is the name assigned to this container (multiple names are
    possible). |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `Names` | 这是分配给此容器的名称（可以有多个名称）。 |'
- en: 'If we want to list not only the currently running containers but all containers
    that are defined on our system, then we can use the command-line parameter `-a` or `--all`, as
    follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不仅想列出当前正在运行的容器，还想列出所有已定义的容器，则可以使用命令行参数 `-a` 或 `--all`，如以下所示：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will list containers in any state, such as `created`, `running`, or `exited`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这将列出所有状态的容器，如 `created`（创建），`running`（运行中），或 `exited`（退出）。
- en: 'Sometimes, we want to just list the IDs of all containers. For this, we have
    the `-q` parameter:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只需要列出所有容器的 ID。为此，我们可以使用 `-q` 参数：
- en: '[PRE20]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You might wonder where this is useful. I will show you a command where it is
    very helpful right here:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想，这有什么用处。我会在这里给你展示一个非常有用的命令：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Lean back and take a deep breath. Then, try to find out what the preceding command
    does. Don't read any further until you find the answer or give up.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 放松一下，深呼吸。然后，试着找出上面的命令到底做了什么。直到你找出答案或者放弃之前，不要继续往下读。
- en: The preceding command deletes all containers that are currently defined on the
    system, including the stopped ones. The `rm` command stands for remove, and it
    will be explained soon.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令会删除系统中当前定义的所有容器，包括已停止的容器。`rm` 命令表示删除，稍后会解释。
- en: 'In the previous section, we used the `-l` parameter in the list command. Try
    to use Docker help to find out what the `-l` parameter stands for. You can invoke
    help for the list command as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们在列出命令中使用了 `-l` 参数。尝试使用 Docker 帮助来了解 `-l` 参数的含义。你可以通过以下方式获取列出命令的帮助：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Next, let's learn how to stop and restart containers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们学习如何停止和重启容器。
- en: Stopping and starting containers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止和启动容器
- en: 'Sometimes, we want to (temporarily) stop a running container. Let''s try this
    out with the trivia container we used previously:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望（暂时）停止一个正在运行的容器。让我们用之前使用过的trivia容器来试试：
- en: 'Run the container again with this command:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个命令重新启动容器：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, if we want to stop this container, then we can do so by issuing this command:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果我们想停止这个容器，可以通过发出这个命令来做到：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: When you try to stop the trivia container, you will probably note that it takes
    a while until this command is executed. To be precise, it takes about 10 seconds. *Why
    is this the case?*
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 当你尝试停止trivia容器时，你可能会注意到该命令执行时需要一些时间。准确来说，大约需要10秒钟。*为什么会这样？*
- en: Docker sends a Linux `SIGTERM` signal to the main process running inside the
    container. If the process doesn't react to this signal and terminate itself, Docker
    waits for 10 seconds and then sends `SIGKILL`, which will kill the process forcefully
    and terminate the container.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Docker会向容器内运行的主进程发送一个Linux的`SIGTERM`信号。如果该进程没有响应这个信号并自行终止，Docker会等待10秒钟，然后发送`SIGKILL`，强制终止进程并停止容器。
- en: In the preceding command, we have used the name of the container to specify
    which container we want to stop. But we could have also used the container ID
    instead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的命令中，我们使用了容器的名称来指定我们想要停止哪个容器。但我们也可以使用容器ID代替。
- en: '*How do we get the ID of a container?* There are several ways of doing so.
    The manual approach is to list all running containers and find the one that we''re
    looking for in the list. From there, we copy its ID. A more automated way is to
    use some shell scripting and environment variables. If, for example, we want to
    get the ID of the trivia container, we can use this expression:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '*我们如何获取一个容器的ID？* 有几种方法可以做到这一点。手动的方法是列出所有正在运行的容器，然后从列表中找到我们要找的容器。从那里，我们复制它的ID。一种更自动化的方式是使用一些Shell脚本和环境变量。例如，如果我们想获取trivia容器的ID，可以使用这个表达式：'
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We are using the `-a` parameter with the Docker `container ls` command to list
    all containers, even the stopped ones. This is necessary in this case since we
    stopped the trivia container a moment ago.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在使用Docker的`container ls`命令时加上了`-a`参数，以列出所有容器，包括停止的容器。在这种情况下这是必要的，因为我们刚刚停止了trivia容器。
- en: 'Now, instead of using the container name, we can use the `$CONTAINER_ID` variable in
    our expression:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在表达式中使用`$CONTAINER_ID`变量，而不是使用容器名称：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we have stopped the container, its status changes to `Exited`.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们停止了容器，它的状态会变为`Exited`。
- en: 'If a container is stopped, it can be started again using the `docker container
    start` command. Let''s do this with our trivia container. It is good to have it
    running again, as we''ll need it in the subsequent sections of this chapter:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个容器被停止，可以使用`docker container start`命令再次启动它。让我们用我们的trivia容器来演示。将它重新启动是件好事，因为我们将在本章的后续部分需要它：
- en: '[PRE27]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It is now time to discuss what to do with stopped containers that we don't need
    anymore.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是讨论如何处理那些我们不再需要的停止容器的时候了。
- en: Removing containers
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除容器
- en: 'When we run the `docker container ls -a` command, we can see quite a few containers
    that are in the `Exited` status. If we don''t need these containers anymore, then
    it is a good thing to remove them from memory; otherwise, they unnecessarily occupy
    precious resources. The command to remove a container is as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行`docker container ls -a`命令时，我们可以看到许多处于`Exited`状态的容器。如果我们不再需要这些容器，那么移除它们是件好事；否则，它们会不必要地占用宝贵的资源。移除容器的命令如下：
- en: '[PRE28]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Another command to remove a container is the following:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个移除容器的命令如下：
- en: '[PRE29]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Try to remove one of your exited containers using its ID.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试使用容器ID删除一个已退出的容器。
- en: Sometimes, removing a container will not work as it is still running. If we
    want to force a removal, no matter what the condition of the container currently
    is, we can use the command-line parameter `-f` or `--force`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，删除容器会失败，因为容器仍在运行。如果我们想强制删除一个容器，无论容器当前的状态如何，我们可以使用命令行参数`-f`或`--force`。
- en: Inspecting containers
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查容器
- en: 'Containers are runtime instances of an image and have a lot of associated data
    that characterizes their behavior. To get more information about a specific container,
    we can use the `inspect` command. As usual, we have to provide either the container
    ID or name to identify the container of which we want to obtain the data. So,
    let''s inspect our sample container:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是镜像的运行时实例，具有许多与之相关的数据，这些数据描述了它们的行为。为了获取有关特定容器的更多信息，我们可以使用`inspect`命令。像往常一样，我们必须提供容器ID或名称来识别我们想要获取数据的容器。那么，让我们检查一下我们的示例容器：
- en: '[PRE30]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The response is a big JSON object full of details. It looks similar to this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 响应是一个包含详细信息的大JSON对象。它看起来类似于这个：
- en: '[PRE31]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The output has been shortened for readability.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 输出已被简化以提高可读性。
- en: 'Please take a moment to analyze what you got. You should see information such
    as the following:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请花点时间分析你得到的信息。你应该会看到如下内容：
- en: The ID of the container
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的ID
- en: The creation date and time of the container
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器的创建日期和时间
- en: The image from which the container is built
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器构建所用的镜像
- en: Many sections of the output, such as `Mounts` or `NetworkSettings`, don't make
    much sense right now, but we will certainly discuss those in the upcoming chapters
    of this book. The data you're seeing here is also named the metadata of a container.
    We will be using the `inspect` command quite often in the remainder of this book
    as a source of information.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的许多部分，比如`Mounts`或`NetworkSettings`，现在看起来没有太大意义，但我们肯定会在本书的后续章节中讨论这些内容。你在这里看到的数据也被称为容器的元数据。在本书的剩余部分，我们将频繁使用`inspect`命令作为获取信息的来源。
- en: 'Sometimes, we need just a tiny bit of the overall information, and to achieve
    this, we can either use the grep tool or a filter. The former method does not
    always result in the expected answer, so let''s look into the latter approach:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们只需要一小部分整体信息，为了实现这一点，我们可以使用`grep`工具或过滤器。前者的方法并不总是能得到预期的答案，所以我们来看一下后者的方法：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `-f` or `--filter` parameter is used to define the filter. The filter expression itself
    uses the Go template syntax. In this example, we only want to see the state part
    of the whole output in the JSON format.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`-f`或`--filter`参数用于定义过滤器。过滤器表达式本身使用Go模板语法。在这个例子中，我们只希望看到整个输出中的`state`部分，且格式为JSON。'
- en: 'To nicely format the output, we pipe the result into the `jq` tool:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了美化输出，我们将结果通过管道传输到`jq`工具：
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: After we have learned how to retrieve loads of important and useful meta information
    about a container, we now want to investigate how we can execute it in a running
    container.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们学会如何检索关于容器的大量重要和有用的元信息之后，现在我们想要研究如何在正在运行的容器中执行它。
- en: Exec into a running container
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进入正在运行的容器
- en: 'Sometimes, we want to run another process inside an already-running container.
    A typical reason could be to try to debug a misbehaving container. *How can we
    do this?* First, we need to know either the ID or the name of the container, and
    then we can define which process we want to run and how we want it to run. Once
    again, we use our currently running trivia container and we run a shell interactively
    inside it with the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望在已经运行的容器内运行另一个进程。一个典型的原因可能是尝试调试一个行为异常的容器。*我们该怎么做呢？* 首先，我们需要知道容器的ID或名称，然后我们可以定义想要运行的进程以及它如何运行。再次，我们使用当前正在运行的trivia容器，并使用以下命令在其中交互式地运行一个Shell：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `-i` flag signifies that we want to run the additional process interactively,
    and `-t` tells Docker that we want it to provide us with a TTY (a Terminal emulator)
    for the command. Finally, the process we run is `/bin/sh`.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i`标志表示我们希望以交互方式运行附加进程，`-t`则告诉Docker我们希望它为命令提供TTY（终端仿真器）。最后，我们运行的进程是`/bin/sh`。'
- en: 'If we execute the preceding command in our Terminal, then we will be presented
    with a new prompt, `/app #`. We''re now in a shell inside the trivia container.
    We can easily prove that by, for example, executing the `ps` command, which will
    list all running processes in the context:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们在终端中执行前面的命令，我们将看到一个新的提示符`/app #`。我们现在位于trivia容器的Shell中。我们可以通过执行`ps`命令轻松验证这一点，它会列出该上下文中的所有正在运行的进程：'
- en: '[PRE35]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The result should look somewhat similar to this:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该类似于这个：
- en: '![](img/4f28c7e4-bd1d-42f6-9b52-ed75c1a3f98e.png)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f28c7e4-bd1d-42f6-9b52-ed75c1a3f98e.png)'
- en: List of processes running inside the trivia container
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在trivia容器内运行的进程列表
- en: We can clearly see that the process with `PID 1` is the command that we have
    defined to run inside the trivia container. The process with `PID 1` is also named
    the main process.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，`PID 1`的进程是我们定义在trivia容器内运行的命令。`PID 1`的进程也被称为主进程。
- en: 'Leave the container by pressing *Ctrl *+ *D*. We cannot only execute additional
    processes interactive in a container. Please consider the following command:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *D*离开容器。我们不仅可以在容器中执行交互式的额外进程。请考虑以下命令：
- en: '[PRE36]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output evidently looks very similar to the preceding output:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显然看起来与之前的输出非常相似：
- en: '![](img/484111d6-69b2-44fc-9529-4d42a780eecc.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/484111d6-69b2-44fc-9529-4d42a780eecc.png)'
- en: List of processes running inside the trivia container
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 列出trivia容器中运行的进程
- en: 'We can even run processes as a daemon using the `-d` flag and define environment
    variables using the `-e` flag variables, as follows:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至可以使用`-d`标志以守护进程的方式运行进程，并使用`-e`标志定义环境变量，如下所示：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Great, we have learned how to execute into a running container and run additional
    processes. But there is another important way to mingle with a running container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 很好，我们已经学会了如何进入一个正在运行的容器并运行额外的进程。但是，还有另一种重要的方式可以与正在运行的容器进行交互。
- en: Attaching to a running container
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 附加到正在运行的容器
- en: 'We can use the `attach` command to attach our Terminal''s standard input, output,
    and error (or any combination of the three) to a running container using the ID
    or name of the container. Let''s do this for our trivia container:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`attach`命令将终端的标准输入、输出和错误（或三者的任意组合）通过容器的ID或名称附加到正在运行的容器上。我们以我们的trivia容器为例：
- en: '[PRE38]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: In this case, we will see every five seconds or so a new quote appearing in
    the output.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会看到大约每五秒钟输出中出现一个新的引用。
- en: To quit the container without stopping or killing it, we can press the key combination *Ctrl *+ *P*+
    *Ctrl *+ *Q*. This detaches us from the container while leaving it running in
    the background. On the other hand, if we want to detach and stop the container
    at the same time, we can just press *Ctrl* + *C.*
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 若要退出容器而不停止或杀死它，我们可以按下*Ctrl* + *P* + *Ctrl* + *Q*的组合键。这会使我们从容器中分离，同时保持容器在后台运行。另一方面，如果我们想要同时分离并停止容器，只需按下*Ctrl*
    + *C*即可。
- en: 'Let''s run another container, this time an Nginx web server:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行另一个容器，这次是一个Nginx web服务器：
- en: '[PRE39]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Here, we run the Alpine version of Nginx as a daemon in a container named `nginx`.
    The `-p 8080:80` command-line parameter opens port `8080` on the host for access
    to the Nginx web server running inside the container. Don''t worry about the syntax
    here as we will explain this feature in more detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml), *S**ingle-Host
    Networking*:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将Alpine版的Nginx作为守护进程运行在名为`nginx`的容器中。`-p 8080:80`命令行参数会为主机上的Nginx web服务器打开`8080`端口，以便访问容器内部的Nginx服务。这里的语法不需要担心，我们将在[第10章](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)中更详细地解释这一特性，*单主机网络*：
- en: 'Let''s see whether we can access Nginx using the `curl` tool and running this
    command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看是否可以通过`curl`工具访问Nginx，并运行以下命令：
- en: '[PRE40]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'If all works correctly, you should be greeted by the welcome page of Nginx
    (shortened for readability):'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会看到Nginx的欢迎页面（已简化以便阅读）：
- en: '[PRE41]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, let''s attach our Terminal to the `nginx` container to observe what''s
    happening:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将终端附加到`nginx`容器上，观察发生了什么：
- en: '[PRE42]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Once you are attached to the container, you first will not see anything. But
    now open another Terminal, and in this new Terminal window, repeat the `curl` command
    a few times, for example, using the following script:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你附加到容器，你首先不会看到任何内容。但是现在打开另一个终端窗口，并在这个新窗口中多次重复`curl`命令，例如使用以下脚本：
- en: '[PRE43]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see the logging output of Nginx, which looks similar to this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到Nginx的日志输出，类似于以下内容：
- en: '[PRE44]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Quit the container by pressing *Ctrl *+ *C*. This will detach your Terminal
    and, at the same time, stop the `nginx` container.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下*Ctrl* + *C*退出容器。这将分离你的终端，同时停止`nginx`容器。
- en: 'To clean up, remove the `nginx` container with the following command:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理，使用以下命令删除`nginx`容器：
- en: '[PRE45]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In the next section, we're going to learn how to work with container logs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将学习如何操作容器日志。
- en: Retrieving container logs
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检索容器日志
- en: It is a best practice for any good application to generate some logging information
    that developers and operators alike can use to find out what the application is
    doing at a given time, and whether there are any problems to help to pinpoint
    the root cause of the issue.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何优秀的应用程序来说，生成一些日志信息是最佳实践，开发人员和运维人员都可以用它来了解应用程序在某一时刻正在做什么，以及是否有任何问题，从而帮助定位问题的根本原因。
- en: 'When running inside a container, the application should preferably output the
    log items to `STDOUT` and `STDERR` and not into a file. If the logging output
    is directed to `STDOUT` and `STDERR`, then Docker can collect this information
    and keep it ready for consumption by a user or any other external system:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 当容器内部运行时，应用程序最好将日志项输出到`STDOUT`和`STDERR`，而不是写入文件。如果日志输出定向到`STDOUT`和`STDERR`，那么Docker可以收集这些信息，并准备好供用户或其他外部系统使用：
- en: 'To access the logs of a given container, we can use the `docker container logs` command.
    If, for example, we want to retrieve the logs of our `trivia` container, we can
    use the following expression:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问给定容器的日志，我们可以使用`docker container logs`命令。例如，如果我们想检索`trivia`容器的日志，可以使用以下表达式：
- en: '[PRE46]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will retrieve the whole log produced by the application from the very beginning
    of its existence.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将检索应用程序从一开始就生成的完整日志。
- en: Stop, wait a second—this is not quite true, what I just said. By default, Docker
    uses the so-called `json-file` logging driver. This driver stores the logging
    information in a file. And if there is a file rolling policy defined, then `docker
    container logs` only retrieves what is in the current active log file and not
    what is in previous rolled files that might still be available on the host.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 停，等一下——我刚才说的不完全正确。默认情况下，Docker使用所谓的`json-file`日志驱动程序。该驱动程序将日志信息存储在文件中。如果定义了文件滚动策略，那么`docker
    container logs`只会检索当前活动日志文件中的内容，而不会检索可能仍在宿主机上可用的之前滚动的文件。
- en: 'If we want to only get a few of the latest entries, we can use the `-t` or `--tail` parameter,
    as follows:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们只想获取一些最新的日志条目，可以使用`-t`或`--tail`参数，如下所示：
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will retrieve only the last five items the process running inside the container
    produced.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这将仅检索容器内部运行的进程生成的最后五个条目。
- en: 'Sometimes, we want to follow the log that is produced by a container. This
    is possible when using the `-f` or `--follow` parameter. The following expression
    will output the last five log items and then follow the log as it is produced
    by the containerized process:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望跟踪容器生成的日志。使用`-f`或`--follow`参数时，这是可能的。以下表达式将输出最后五个日志条目，并在容器化进程生成日志时跟随输出：
- en: '[PRE48]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Often using the default mechanism for container logging is not enough. We need
    a different way of logging. This is discussed in the following section.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，使用容器日志的默认机制是不够的。我们需要一种不同的日志记录方式。以下部分将讨论这一点。
- en: Logging drivers
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日志驱动程序
- en: 'Docker includes multiple logging mechanisms to help us to get information from
    running containers. These mechanisms are named** logging drivers**. Which logging
    driver is used can be configured at the Docker daemon level. The default logging
    driver is `json-file`. Some of the drivers that are currently supported natively
    are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Docker包括多种日志机制，帮助我们从运行中的容器中获取信息。这些机制被称为**日志驱动程序**。可以在Docker守护进程级别配置使用哪种日志驱动程序。默认的日志驱动程序是`json-file`。目前本地支持的部分驱动程序如下：
- en: '| **Driver**  | **Description**  |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| **驱动程序** | **描述** |'
- en: '| `none` | No log output for the specific container is produced. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `none` | 不会为特定容器生成日志输出。 |'
- en: '| `json-file` | This is the default driver. The logging information is stored
    in files, formatted as JSON. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `json-file` | 这是默认驱动程序。日志信息存储在格式为JSON的文件中。 |'
- en: '| `journald` | If the journals daemon is running on the host machine, we can
    use this driver. It forwards logging to the `journald` daemon. |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| `journald` | 如果宿主机上运行`journald`守护进程，我们可以使用此驱动程序，它将日志转发到`journald`守护进程。 |'
- en: '| `syslog` | If the `syslog` daemon is running on the host machine, we can
    configure this driver, which will forward the log messages to the `syslog` daemon.
    |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| `syslog` | 如果宿主机上运行`syslog`守护进程，我们可以配置此驱动程序，将日志消息转发到`syslog`守护进程。 |'
- en: '| `gelf` | When using this driver, log messages are written to a **Graylog
    Extended Log Format** (**GELF**) endpoint. Popular examples of such endpoints
    are Graylog and Logstash. |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| `gelf` | 使用此驱动程序时，日志消息将写入**Graylog扩展日志格式**（**GELF**）端点。此类端点的常见示例有Graylog和Logstash。
    |'
- en: '| `fluentd` | Assuming that the `fluentd` daemon is installed on the host system,
    this driver writes log messages to it. |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| `fluentd` | 假设主机系统上已安装`fluentd`守护进程，此驱动程序将日志消息写入该守护进程。 |'
- en: If you change the logging driver, please be aware that the `docker container
    logs` command is only available for the `json-file` and `journald` drivers.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你更改了日志驱动程序，请注意，`docker container logs`命令仅适用于`json-file`和`journald`驱动程序。
- en: Using a container-specific logging driver
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用容器特定的日志驱动程序
- en: 'We have seen that the logging driver can be set globally in the Docker daemon
    configuration file. But we can also define the logging driver on a container by
    container basis. In the following example, we are running a `busybox` container
    and use the `--log-driver` parameter to configure the `none` logging driver:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到，日志驱动程序可以在Docker守护进程配置文件中全局设置。但我们也可以为每个容器单独定义日志驱动程序。在以下示例中，我们运行一个`busybox`容器，并使用`--log-driver`参数配置`none`日志驱动程序：
- en: '[PRE49]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We should see the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到以下内容：
- en: '[PRE50]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, let''s try to get the logs of the preceding container:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试获取前一个容器的日志：
- en: '[PRE51]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The output is as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE52]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'This is to be expected since the `none` driver does not produce any logging
    output. Let''s clean up and remove the `test` container:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是预期的结果，因为`none`驱动程序不会产生任何日志输出。让我们清理并删除`test`容器：
- en: '[PRE53]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Advanced topic – changing the default logging driver
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级主题 – 更改默认日志驱动程序
- en: 'Let''s change the default logging driver of a Linux host:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更改Linux主机的默认日志驱动程序：
- en: 'The easiest way to do this is on a real Linux host. For this purpose, we''re
    going to use Vagrant with an Ubuntu image:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 做这件事最简单的方法是在一个真实的Linux主机上。为此，我们将使用带有Ubuntu镜像的Vagrant：
- en: '[PRE54]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '**Vagrant** is an open source tool developed by Hashicorp that is often used
    for building and maintaining portable virtual software development environments.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**Vagrant**是由Hashicorp开发的一个开源工具，通常用于构建和维护可移植的虚拟软件开发环境。'
- en: 'Once inside the Ubuntu VM, we want to edit the Docker daemon configuration
    file. Navigate to the `/etc/docker` folder and run `vi` as follows:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入Ubuntu虚拟机后，我们需要编辑Docker守护进程配置文件。请导航到`/etc/docker`文件夹并按如下方式运行`vi`：
- en: '[PRE55]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Enter the following content:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下内容：
- en: '[PRE56]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Save and exit `vi` by first pressing *Esc*and then typing `:w:q` and finally
    hitting the *Enter* key.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过先按*Esc*键，然后输入`:w:q`，最后按*Enter*键，保存并退出`vi`。
- en: The preceding definition tells the Docker daemon to use the `json-log` driver
    with a maximum log file size of 10 MB before it is rolled, and the maximum number
    of log files that can be present on the system is `3` before the oldest file gets
    purged.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的定义告诉Docker守护进程使用`json-log`驱动程序，最大日志文件大小为10MB，当日志文件达到该大小时会滚动，并且系统上可以存在的最大日志文件数量是`3`，超过这个数量时，最旧的文件会被清除。
- en: 'Now we have to send a `SIGHUP` signal to the Docker daemon so that it picks
    up the changes in the configuration file:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须向Docker守护进程发送一个`SIGHUP`信号，以便它能够读取配置文件中的更改：
- en: '[PRE57]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that the preceding command only reloads the config file and does not restart
    the daemon.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的命令只是重新加载配置文件，并不会重启守护进程。
- en: Anatomy of containers
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器的结构
- en: Many people wrongly compare containers to VMs. However, this is a questionable
    comparison. Containers are not just lightweight VMs. OK then, *what is the correct
    description of a container?*
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人错误地将容器与虚拟机进行比较。然而，这是一个值得质疑的比较。容器不仅仅是轻量级的虚拟机。那么，*容器的正确描述是什么？*
- en: Containers are specially encapsulated and secured processes running on the host
    system. Containers leverage a lot of features and primitives available in the Linux
    OS. The most important ones are *namespaces *and *cgroups*. All processes running
    in containers only share the same Linux kernel of the underlying host operating
    system. This is fundamentally different compared with VMs, as each VM contains
    its own full-blown operating system.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 容器是运行在主机系统上的特殊封装和安全进程。容器利用了Linux操作系统中可用的许多特性和原语。最重要的特性是*命名空间*和*控制组（cgroups）*。所有在容器中运行的进程仅共享底层主机操作系统的Linux内核。这与虚拟机有根本不同，因为每个虚拟机都有自己完整的操作系统。
- en: The startup times of a typical container can be measured in milliseconds, while
    a VM normally needs several seconds to minutes to start up. VMs are meant to be
    long-living. It is a primary goal of each operations engineer to maximize the
    uptime of their VMs. Contrary to that, containers are meant to be ephemeral. They
    come and go relatively quickly.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型容器的启动时间可以用毫秒来衡量，而虚拟机通常需要几秒到几分钟才能启动。虚拟机的设计目的是长时间运行。每个运维工程师的首要目标是最大化虚拟机的正常运行时间。与此相反，容器的设计目的是临时的。它们来得快，去得也快。
- en: Let's first get a high-level overview of the architecture that enables us to
    run containers.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先从高层次了解一下使我们能够运行容器的架构。
- en: Architecture
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: 'Here, we have an architectural diagram on how this all fits together:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个架构图，展示了所有这些如何结合在一起：
- en: '![](img/350f0f91-f671-4ed5-9eae-0f0d6c5dae6e.png)'
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![](img/350f0f91-f671-4ed5-9eae-0f0d6c5dae6e.png)'
- en: High-level architecture of Docker
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 高层架构
- en: In the lower part of the preceding diagram, we have the Linux operating system
    with its **cgroups**, **Namespaces**, and **Layer** **Capabilities** as well as
    **Other OS Functionality** that we do not need to explicitly mention here. Then,
    there is an intermediary layer composed of **containerd** and **runc**. On top
    of all that now sits the **Docker engine**. The **Docker engine** offers a RESTful
    interface to the outside world that can be accessed by any tool, such as the Docker
    CLI, Docker for macOS, and Docker for Windows or Kubernetes to name just a few.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图的下半部分，我们有 Linux 操作系统及其 **cgroups**、**命名空间** 和 **层级能力**，以及我们此处不需要明确提及的 **其他操作系统功能**。然后，是由
    **containerd** 和 **runc** 组成的中介层。所有这些上面现在是 **Docker 引擎**。**Docker 引擎** 提供了一个 RESTful
    接口，可以通过任何工具访问，例如 Docker CLI、Docker for macOS 和 Docker for Windows 或 Kubernetes，举几个例子。
- en: Let's now describe the main building blocks in a bit more detail.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地描述一下主要的构建模块。
- en: Namespaces
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命名空间
- en: Linux namespaces had been around for years before they were leveraged by Docker
    for their containers. A namespace is an abstraction of global resources such as
    filesystems, network access, and process trees (also named PID namespaces) or
    the system group IDs and user IDs. A Linux system is initialized with a single
    instance of each namespace type. After initialization, additional namespaces can
    be created or joined.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Docker 使用容器之前，Linux 命名空间已经存在多年。命名空间是全局资源的抽象，例如文件系统、网络访问、进程树（也称为 PID 命名空间），或系统组
    ID 和用户 ID。Linux 系统通过每种命名空间类型的单一实例进行初始化。初始化后，可以创建或加入额外的命名空间。
- en: The Linux namespaces originated in 2002 in the 2.4.19 kernel. In kernel version
    3.8, user namespaces were introduced and with it, namespaces were ready to be
    used by containers.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 命名空间起源于 2002 年的 2.4.19 内核。在 3.8 版本的内核中，用户命名空间被引入，从此命名空间准备好被容器使用。
- en: 'If we wrap a running process, say, in a filesystem namespace, then this process
    has the illusion that it owns its own complete filesystem. This, of course, is
    not true; it is only a virtual filesystem. From the perspective of the host, the
    contained process gets a shielded subsection of the overall filesystem. It is
    like a filesystem in a filesystem:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将一个正在运行的进程，比如，封装在一个文件系统命名空间中，那么该进程会有一种它拥有自己完整文件系统的错觉。当然，这并不是真的；它只是一个虚拟文件系统。从宿主的角度看，封装的进程得到的是整体文件系统的一个受保护子集。这就像是一个文件系统中的文件系统：
- en: '![](img/9ce9575c-b97c-4da2-8cf9-13bf1b9bd15b.png)'
  id: totrans-259
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9ce9575c-b97c-4da2-8cf9-13bf1b9bd15b.png)'
- en: Filesystem namespaces on Linux
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 上的文件系统命名空间
- en: The same applies to all of the other global resources for which namespaces exist.
    The user ID namespace is another example. Having a user namespace, we can now
    define a `jdoe `user many times on the system as long as it is living in its own
    namespace.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的情况适用于所有其他存在命名空间的全局资源。用户 ID 命名空间就是另一个例子。通过使用用户命名空间，我们现在可以在系统中多次定义一个 `jdoe`
    用户，只要它生活在自己的命名空间中。
- en: 'The PID namespace is what keeps processes in one container from seeing or interacting
    with processes in another container. A process might have the apparent PID **1** inside
    a container, but if we examine it from the host system, it would have an ordinary
    PID, say **334**:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: PID 命名空间是确保一个容器中的进程无法看到或与另一个容器中的进程交互的机制。一个进程可能在容器内看起来有 PID **1**，但如果我们从宿主系统查看它，它会有一个普通的
    PID，比如 **334**：
- en: '![](img/a4d80d0a-451d-40dd-9c62-90b7c451dce9.png)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a4d80d0a-451d-40dd-9c62-90b7c451dce9.png)'
- en: Process tree on a Docker host
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 主机上的进程树
- en: In a given namespace, we can run one to many processes. That is important when
    we talk about containers, and we have experienced that already when we executed
    another process in an already-running container.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定的命名空间中，我们可以运行一个或多个进程。这在我们谈论容器时非常重要，并且我们已经在执行另一个进程时体验过，在一个已经运行的容器中执行。
- en: Control groups (cgroups)
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制组（cgroups）
- en: Linux cgroups are used to limit, manage, and isolate resource usage of collections
    of processes running on a system. Resources are CPU time, system memory, network
    bandwidth, or combinations of these resources, and so on.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Linux cgroups 被用于限制、管理和隔离系统上运行的进程集合的资源使用。资源包括 CPU 时间、系统内存、网络带宽，或者这些资源的组合，等等。
- en: Engineers at Google originally implemented this feature in 2006\. The cgroups
    functionality was merged into the Linux kernel mainline in kernel version 2.6.24,
    which was released in January 2008.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Google 的工程师最初在 2006 年实现了这个功能。cgroups 功能在 Linux 内核版本 2.6.24 中合并到主线内核，该版本于 2008
    年 1 月发布。
- en: Using cgroups, administrators can limit the resources that containers can consume.
    With this, we can avoid, for example, the classical *noisy neighbor* problem,
    where a rogue process running in a container consumes all CPU time or reserves
    massive amounts of RAM and, as such, starves all of the other processes running
    on the host, whether they're containerized or not.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cgroups，管理员可以限制容器能够消耗的资源。通过这种方式，我们可以避免经典的 *噪声邻居* 问题，即容器中运行的恶意进程消耗所有的 CPU
    时间或占用大量的内存，从而导致主机上运行的其他进程（无论它们是否容器化）被饿死。
- en: Union filesystem (Unionfs)
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联合文件系统（Unionfs）
- en: Unionfs forms the backbone of what is known as container images. We will discuss
    container images in detail in the next chapter. At this time, we want to just
    understand a bit better what Unionfs is, and how it works. Unionfs is mainly used
    on Linux and allows files and directories of distinct filesystems to be overlaid
    to form a single coherent filesystem. In this context, the individual filesystems
    are called branches. Contents of directories that have the same path within the
    merged branches will be seen together in a single merged directory, within the
    new virtual filesystem. When merging branches, the priority between the branches
    is specified. In that way, when two branches contain the same file, the one with
    the higher priority is seen in the final filesystem.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: Unionfs 构成了所谓容器镜像的基础。我们将在下一章详细讨论容器镜像。在此时，我们仅需要稍微了解一下 Unionfs 是什么，以及它如何工作。Unionfs
    主要用于 Linux，并允许不同文件系统的文件和目录进行叠加，从而形成一个统一的文件系统。在这种情况下，单独的文件系统被称为分支。具有相同路径的目录内容将在合并后的新虚拟文件系统中作为一个统一的目录显示。当合并分支时，会指定分支之间的优先级。通过这种方式，当两个分支包含相同的文件时，优先级较高的文件会出现在最终的文件系统中。
- en: Container plumbing
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器管道
- en: The basement on top of which the Docker engine is built; is the **container
    plumbing** and is formed by two components, **runc** and **containerd**.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎构建之上的基础层就是 **容器管道**，它由两个组件组成：**runc** 和 **containerd**。
- en: Originally, Docker was built in a monolithic way and contained all of the functionality
    necessary to run containers. Over time, this became too rigid and Docker started
    to break out parts of the functionality into their own components. Two important
    components are runc and containerd.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Docker 是以单体方式构建的，包含了运行容器所需的所有功能。随着时间的推移，这种方式变得过于僵化，Docker 开始将一些功能拆分成独立的组件。其中两个重要的组件是
    runc 和 containerd。
- en: runC
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: runC
- en: runC is a lightweight, portable container runtime. It provides full support
    for Linux namespaces as well as native support for all security features available
    on Linux, such as SELinux, AppArmor, seccomp, and cgroups.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: runC 是一个轻量级、可移植的容器运行时。它完全支持 Linux 命名空间，并且原生支持 Linux 上的所有安全功能，如 SELinux、AppArmor、seccomp
    和 cgroups。
- en: runC is a tool for spawning and running containers according to the **Open Container
    Initiative** (**OCI**) specification. It is a formally specified configuration format,
    governed by the **Open Container Project** (**OCP**) under the auspices of the
    Linux Foundation.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: runC 是一个根据 **开放容器倡议**（**OCI**）规范启动和运行容器的工具。它是一个正式规范的配置格式，受 **开放容器项目**（**OCP**）的管理，OCP
    是由 Linux 基金会主办的。
- en: Containerd
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Containerd
- en: runC is a low-level implementation of a container runtime; containerd builds
    on top of it and adds higher-level features, such as image transfer and storage,
    container execution, and supervision as well as network and storage attachments.
    With this, it manages the complete life cycle of containers. Containerd is the
    reference implementation of the OCI specifications and is by far the most popular
    and widely used container runtime.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: runC 是一个低级容器运行时实现；containerd 基于它并添加了更高级的功能，如镜像传输与存储、容器执行和监控，以及网络与存储附件。通过这些，containerd
    管理容器的完整生命周期。Containerd 是OCI规范的参考实现，是目前最受欢迎和广泛使用的容器运行时。
- en: Containerd was donated to and accepted by the CNCF in 2017\. There exist alternative
    implementations of the OCI specification. Some of them are rkt by CoreOS, CRI-O
    by RedHat, and LXD by Linux Containers. However, containerd at this time is by
    far the most popular container runtime and is the default runtime of Kubernetes
    1.8 or later and the Docker platform.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Containerd 于2017年捐赠给CNCF并被接纳。OCI规范有其他替代实现。其中一些包括CoreOS的rkt、RedHat的CRI-O和Linux
    Containers的LXD。然而，当前containerd无疑是最受欢迎的容器运行时，并且是Kubernetes 1.8及以上版本和Docker平台的默认运行时。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to work with containers that are based on existing
    images. We showed how to run, stop, start, and remove a container. Then, we inspected
    the metadata of a container, extracted the logs of it, and learned how to run
    an arbitrary process in an already-running container. Last but not least, we dug
    a bit deeper and investigated how containers work and what features of the underlying
    Linux operating system they leverage.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用基于现有镜像的容器。我们展示了如何运行、停止、启动和删除容器。然后，我们检查了容器的元数据，提取了容器的日志，并学习了如何在一个已经运行的容器中执行任意进程。最后，我们深入探讨了容器是如何工作的，以及它们如何利用底层Linux操作系统的功能。
- en: In the next chapter, you're going to learn what container images are and how
    we can build and share our own custom images. We'll also be discussing the best
    practices commonly used when building custom images, such as minimizing their
    size and leveraging the image cache. Stay tuned!
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习什么是容器镜像以及我们如何构建和共享自己的自定义镜像。我们还将讨论构建自定义镜像时常用的最佳实践，如最小化镜像大小和利用镜像缓存。敬请期待！
- en: Questions
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess your learning progress, please answer the following questions:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你的学习进度，请回答以下问题：
- en: What are the states of a container?
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 容器的状态有哪些？
- en: Which command helps us to find out what is currently running on our Docker host?
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令帮助我们查找当前在Docker主机上运行的内容？
- en: Which command is used to list the IDs of all containers?
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个命令用于列出所有容器的ID？
- en: Further reading
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'The following articles give you some more information related to the topics
    we discussed in this chapter:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章为你提供了更多关于我们在本章讨论主题的相关信息：
- en: Docker containers at [http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器请访问[http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
- en: Getting started with containers at [http://dockr.ly/2gmxKWB](http://dockr.ly/2gmxKWB)
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用容器请访问[http://dockr.ly/2gmxKWB](http://dockr.ly/2gmxKWB)
- en: Isolating containers with a user namespace at [http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用用户命名空间隔离容器请访问[http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
- en: Limiting a container's resources at [http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器资源请访问[http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)
