- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mastering Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to optimally prepare your working environment
    for the productive and frictionless use of Docker. In this chapter, we are going
    to get our hands dirty and learn about everything that is important to know when
    working with containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the topics we’re going to cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Running the first container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Starting, stopping, and removing containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspecting containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exec into a running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching to a running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieving container logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anatomy of containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After finishing this chapter, you will be able to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Run, stop, and delete a container based on an existing image, such as Nginx,
    BusyBox, or Alpine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List all containers on the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inspect the metadata of a running or stopped container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the logs produced by an application running inside a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a process such as `/bin/sh` in an already-running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attach a terminal to an already-running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain in your own words, to an interested layman, the underpinnings of a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you should have Docker Desktop installed on your Linux workstation,
    macOS, or Windows PC. If you are on an older version of Windows or are using Windows
    10 Home Edition, then you should have Docker Toolbox installed and ready to use.
    On macOS, use the Terminal application, and on Windows, use the PowerShell console
    or Git Bash to try out the commands you will be learning.
  prefs: []
  type: TYPE_NORMAL
- en: Running the first container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start, we want to make sure that Docker is installed correctly on
    your system and ready to accept your commands. Open a new terminal window and
    type in the following command (note: do not type the `$` sign, as it is a placeholder
    for your prompt):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything works correctly, you should see the version of the Docker client
    and server installed on your laptop output in the terminal. At the time of writing,
    it looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Output of the docker version command](img/B19199_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Output of the docker version command
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I have version `20.10.20` installed on my MacBook Air M1 laptop.
  prefs: []
  type: TYPE_NORMAL
- en: If this doesn’t work for you, then something with your installation is not right.
    Please make sure that you have followed the instructions in the previous chapter
    on how to install Docker Desktop on your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, you’re ready to see some action. Please type the following command into
    your terminal window and hit the *Return* key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the preceding command the first time, you should see an output
    in your terminal window like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Running an Alpine container for the first time](img/B19199_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Running an Alpine container for the first time
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that was easy! Let’s try to run the very same command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The second, third, or nth time you run the preceding command, you should see
    only this output in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Try to reason why the first time you run a command you see a different output
    than all of the subsequent times. But don’t worry if you can’t figure it out;
    we will explain the reasons in detail in the following sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Starting, stopping, and removing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You successfully ran a container in the previous section. Now, we want to investigate
    in detail what exactly happened and why. Let’s look again at the command we used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This command contains multiple parts. First and foremost, we have the word `docker`.
    This is the name of the Docker `container`, which indicates the context we are
    working with, such as `container`, `image`, or `volume`. As we want to run a container,
    our context is `container`. Next is the actual command we want to execute in the
    given context, which is `run`.
  prefs: []
  type: TYPE_NORMAL
- en: Let me recap – so far, we have `docker container run`, which means, “hey Docker,
    we want to run a container.”
  prefs: []
  type: TYPE_NORMAL
- en: Now we also need to tell Docker which container to run. In this case, this is
    the so-called `alpine` container.
  prefs: []
  type: TYPE_NORMAL
- en: Alpine Linux
  prefs: []
  type: TYPE_NORMAL
- en: '`alpine` is a minimal Docker image based on Alpine Linux with a complete package
    index and is only about 5 MB in size. It is an official image supported by the
    Alpine open source project and Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to define what kind of process or task will be executed inside
    the container when it is running. In our case, this is the last part of the command,
    `echo "``Hello World"`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure may help you to get a better idea of the whole thing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – docker run command explained](img/B19199_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – docker run command explained
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have understood the various parts of a command to run a container,
    let’s try to run another container with a different process executed inside it.
    Type the following command into your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see output in your terminal window similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Running the ping command inside a CentOS container](img/B19199_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Running the ping command inside a CentOS container
  prefs: []
  type: TYPE_NORMAL
- en: What changed is that this time, the container image we’re using is `centos`
    and the process we’re executing inside the `centos` container is `ping -c 5 127.0.0.1`,
    which pings the loopback IP address (`127.0.0.1`) five times until it stops.
  prefs: []
  type: TYPE_NORMAL
- en: CentOS
  prefs: []
  type: TYPE_NORMAL
- en: '`centos` is the official Docker image for CentOS Linux, which is a community-supported
    distribution derived from sources freely provided to the public by Red Hat for
    **Red Hat Enterprise** **Linux** (**RHEL**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s analyze the output in detail. The first line is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells us that Docker didn’t find an image named `centos:latest` in the
    local cache of the system. So, Docker knows that it has to pull the image from
    some registry where container images are stored. By default, your Docker environment
    is configured so that images are pulled from Docker Hub at `docker.io`. This is
    expressed by the second line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The next three lines of output are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This tells us that Docker has successfully pulled the `centos:latest` image
    from Docker Hub. All of the subsequent lines of the output are generated by the
    process we ran inside the container, which is the `ping` tool in this case. If
    you have been attentive so far, then you might have noticed the `latest` keyword
    occurring a few times. Each image has a version (also called `tag`), and if we
    don’t specify a version explicitly, then Docker automatically assumes it is `latest`.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the preceding container again on our system, the first five lines
    of the output will be missing since, this time, Docker will find the container
    image cached locally and hence won’t have to download it first. Try it out and
    verify what I just told you.
  prefs: []
  type: TYPE_NORMAL
- en: Running a random trivia question container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the subsequent sections of this chapter, we need a container that runs continuously
    in the background and produces some interesting output. That’s why we have chosen
    an algorithm that produces random trivia questions. The API that produces free
    random trivia can be found at [http://jservice.io/](http://jservice.io/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the goal is to have a process running inside a container that produces
    a new random trivia question every 5 seconds and outputs the question to `STDOUT`.
    The following script will do exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using PowerShell, the preceding command can be translated to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `ConvertFrom-Json` cmdlet requires that the `Microsoft.PowerShell.Utility`
    module be imported. If it’s not already imported, you’ll need to run `Import-Module
    Microsoft.PowerShell.Utility` before running the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try it in a terminal window. Stop the script by pressing *Ctrl* + *C*. The
    output should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Output random trivia](img/B19199_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Output random trivia
  prefs: []
  type: TYPE_NORMAL
- en: 'Each response is a different trivia question. You may need to install `jq`
    first on your Linux, macOS, or Windows computer. `jq` is a handy tool often used
    to nicely filter and format JSON output, which increases its readability on screen.
    Use your package manager to install `jq` if needed. On Windows, using Chocolatey,
    the command would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'And on a Mac using Homebrew, you would type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s run this logic in an `alpine` container. Since this is not just
    a simple command, we want to wrap the preceding script in a script file and execute
    that one. To make things simpler, I have created a Docker image called `fundamentalsofdocker/trivia`
    that contains all of the necessary logic so that we can just use it here. Later
    on, once we have introduced Docker images, we will analyze this container image
    further. For the moment, let’s just use it as is. Execute the following command
    to run the container as a background service. In Linux, a background service is
    also called a daemon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `\` character to allow line breaks in a single logical command
    that does not fit on a single line. This is a feature of the shell script we use.
    In PowerShell, use the backtick (`` ` ``) instead.
  prefs: []
  type: TYPE_NORMAL
- en: Also note that on `zsh`, you may have to press *Shift* + *Enter* instead of
    only *Enter* after the `\` character to start a new line. Otherwise, you will
    get an error.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding expression, we have used two new command-line parameters, `--detach`
    and `--name`. Now, `--detach` tells Docker to run the process in the container
    as a Linux daemon.
  prefs: []
  type: TYPE_NORMAL
- en: The `--name` parameter, in turn, can be used to give the container an explicit
    name. In the preceding sample, the name we chose is `trivia`. If we don’t specify
    an explicit container name when we run a container, then Docker will automatically
    assign the container a random but unique name. This name will be composed of the
    name of a famous scientist and an adjective. Such names could be `boring_borg`
    or `angry_goldberg`. They’re quite humorous, the Docker engineers, aren’t they?
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the container we’re running is derived from the `fundamentalsofdocker/trivia:ed2`
    image. Note how we are also using a tag, `ed2`, for the container. This tag just
    tells us that this image was originally created for the second edition of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'One important takeaway is that the container name has to be unique on the system.
    Let’s make sure that the trivia container is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give us something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Details of the last run container](img/B19199_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Details of the last run container
  prefs: []
  type: TYPE_NORMAL
- en: An important part of the preceding output is the `STATUS` column, which in this
    case is `Up 6 minutes`. That is, the container has been up and running for 6 minutes
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Don’t worry if the previous Docker command is not yet familiar to you; we will
    come back to it in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete this section, let’s stop and remove the `trivia` container with
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command, while forcefully removing the `trivia` container from
    our system, will just output the name of the container, `trivia`, in the output.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time to learn how to list containers running or dangling on our system.
  prefs: []
  type: TYPE_NORMAL
- en: Listing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we continue to run containers over time, we get a lot of them in our system.
    To find out what is currently running on our host, we can use the `container ls`
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This will list all currently running containers. Such a list might look similar
    to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – List of all running containers on the system](img/B19199_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – List of all running containers on the system
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, Docker outputs seven columns with the following meanings:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Column | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `Container ID` | This is a short version of the unique ID of the container.
    It is an SHA-256, where Secure Hash Algorithm 256-bit (SHA-256) is a widely used
    cryptographic hash function that takes an input and generates a fixed-size (256-bit)
    output, known as a hash. The full ID is 64 characters long. |'
  prefs: []
  type: TYPE_TB
- en: '| `Image` | This is the name of the container image from which this container
    is instantiated. |'
  prefs: []
  type: TYPE_TB
- en: '| `Command` | This is the command that is used to run the main process in the
    container. |'
  prefs: []
  type: TYPE_TB
- en: '| `Created` | This is the date and time when the container was created. |'
  prefs: []
  type: TYPE_TB
- en: '| `Status` | This is the status of the container (created, restarting, running,
    removing, paused, exited, or dead). |'
  prefs: []
  type: TYPE_TB
- en: '| `Ports` | This is the list of container ports that have been mapped to the
    host. |'
  prefs: []
  type: TYPE_TB
- en: '| `Names` | This is the name assigned to this container (note: multiple names
    for the same container are possible). |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – Description of the columns of the docker container ls command
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to list not just the currently running containers but all containers
    that are defined on our system, then we can use the `-a` or `--all` command-line
    parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will list containers in any state, such as `created`, `running`, or `exited`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to just list the IDs of all containers. For this, we have
    the `-q` or `--``quiet` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You might wonder when this is useful. I will show you a command where it is
    very helpful right here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Lean back and take a deep breath. Then, try to find out what the preceding command
    does. Don’t read any further until you find the answer or give up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the solution: the preceding command forcefully deletes all containers
    that are currently defined on the system, including the stopped ones. The `rm`
    command stands for “remove,” and it will be explained soon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, we used the `-l` parameter in the list command, that
    is, `docker container ls -l`. Try to use the `docker help` command to find out
    what the `-l` parameter stands for. You can invoke help for the list command as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that you know how to list created, running, or stopped containers on your
    system, let’s learn how to stop and restart containers.
  prefs: []
  type: TYPE_NORMAL
- en: Stopping and starting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to (temporarily) stop a running container. Let’s try this
    out with the trivia container we used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the container again with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we want to stop this container, then we can do so by issuing this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When you try to stop the trivia container, you will probably notice that it
    takes a while until this command is executed. To be precise, it takes about 10
    seconds. *Why is this* *the case?*
  prefs: []
  type: TYPE_NORMAL
- en: Docker sends a Linux `SIGTERM` signal to the main process running inside the
    container. If the process doesn’t react to this signal and terminate itself, Docker
    waits for 10 seconds and then sends `SIGKILL`, which will kill the process forcefully
    and terminate the container.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding command, we have used the name of the container to specify
    which container we want to stop. But we could have also used the container ID
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'How do we get the ID of a container? There are several ways of doing so. The
    manual approach is to list all running containers and find the one that we’re
    looking for in the list. From there, we copy its ID. A more automated way is to
    use some shell scripting and environment variables. If, for example, we want to
    get the ID of the trivia container, we can use this expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The equivalent command in PowerShell would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `-a` (or `--all`) parameter with the `docker container ls`
    command to list all containers, even the stopped ones. This is necessary in this
    case since we stopped the trivia container a moment ago.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, instead of using the container name, we can use the `$CONTAINER_ID` variable
    in our expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once we have stopped the container, its status changes to `Exited`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a container is stopped, it can be started again using the `docker container
    start` command. Let’s do this with our `trivia` container. It is good to have
    it running again, as we’ll need it in the subsequent sections of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also start it by using the name of the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It is now time to discuss what to do with stopped containers that we don’t need
    anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Removing containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run the `docker container ls -a` command, we can see quite a few containers
    that are in the `Exited` status. If we don’t need these containers anymore, then
    it is a good thing to remove them from memory; otherwise, they unnecessarily occupy
    precious resources. The command to remove a container is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `<container ID>` stands for the ID of the container – a SHA-256 code
    – that we want to remove. Another way to remove a container is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use the name of the container.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs: []
  type: TYPE_NORMAL
- en: Try to remove one of your exited containers using its ID.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, removing a container will not work as it is still running. If we
    want to force a removal, no matter what the condition of the container currently
    is, we can use the `-f` or `--force` command-line parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have learned how to remove containers from our system, let’s learn
    how to inspect containers present in the system.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Containers are runtime instances of an image and have a lot of associated data
    that characterizes their behavior. To get more information about a specific container,
    we can use the `inspect` command. As usual, we have to provide either the container
    ID or the name to identify the container for which we want to obtain the data.
    So, let’s inspect our sample container. First, if it is not already running, we
    have to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use this command to inspect it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The response is a big JSON object full of details. It looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Inspecting the trivia container](img/B19199_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Inspecting the trivia container
  prefs: []
  type: TYPE_NORMAL
- en: Note that the preceding screenshot only shows the first part of a much longer
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Please take a moment to analyze what you have. You should see information such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The ID of the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The creation date and time of the container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From which image the container is built
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many sections of the output, such as `Mounts` and `NetworkSettings`, don’t make
    much sense right now, but we will discuss those in the upcoming chapters of this
    book. The data you’re seeing here is also named the *metadata* of a container.
    We will be using the `inspect` command quite often in the remainder of this book
    as a source of information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we need just a tiny bit of the overall information, and to achieve
    this, we can use either the `grep` tool or a filter. The former method does not
    always result in the expected answer, so let’s look into the latter approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `-f` or `--filter` parameter is used to define the `"{{json .State}}"`
    filter. The filter expression itself uses the Go template syntax. In this example,
    we only want to see the state part of the whole output in JSON format. To nicely
    format the output, we pipe the result into the `jq` tool:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – The state node of the inspect output](img/B19199_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – The state node of the inspect output
  prefs: []
  type: TYPE_NORMAL
- en: After we have learned how to retrieve loads of important and useful meta information
    about a container, we want to investigate how we can execute it in a running container.
  prefs: []
  type: TYPE_NORMAL
- en: Exec into a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, we want to run another process inside an already-running container.
    A typical reason could be to try to debug a misbehaving container. How can we
    do this? First, we need to know either the ID or the name of the container, and
    then we can define which process we want to run and how we want it to run. Once
    again, we use our currently running `trivia` container and we run a shell interactively
    inside it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `-i` (or `--interactive`) flag signifies that we want to run the additional
    process interactively, and `-t` (or `--tty`) tells Docker that we want it to provide
    us with a TTY (a terminal emulator) for the command. Finally, the process we run
    inside the container is `/bin/sh`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we execute the preceding command in our terminal, then we will be presented
    with a new prompt, `/app #`. We’re now in a Bourne shell inside the trivia container.
    We can easily prove that by, for example, executing the `ps` command, which will
    list all running processes in the context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should look somewhat similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Executing into the running trivia container](img/B19199_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Executing into the running trivia container
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly see that the process with PID `1` is the command that we have
    defined to run inside the trivia container. The process with PID `1` is also named
    the main process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exit the container by pressing *Ctrl* + *D*. We cannot only execute additional
    processes interactively in a container. Please consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The output evidently looks very similar to the preceding output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – List of processes running inside the trivia container](img/B19199_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – List of processes running inside the trivia container
  prefs: []
  type: TYPE_NORMAL
- en: 'The difference is that we did not use an extra process to run a shell but executed
    the `ps` command directly. We can even run processes as a daemon using the `-d`
    flag and define environment variables valid inside the container, using the `-e`
    or `--env` flag variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to start a shell inside a trivia container and define
    an environment variable named `MY_VAR` that is valid inside this container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You’ll find yourself inside the `trivia` container. Output the content of the
    `MY_VAR` environment variable, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see this output in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![Figure 3.12 – Running a trivia container and defining an environment variable](img/B19199_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – Running a trivia container and defining an environment variable
  prefs: []
  type: TYPE_NORMAL
- en: 'To exit the trivia container, press *Ctrl* + *D*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great, we have learned how to execute into a running container and run additional
    processes. But there is another important way to work with a running container.
  prefs: []
  type: TYPE_NORMAL
- en: Attaching to a running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `attach` command to attach our terminal’s standard input, output,
    or error (or any combination of the three) to a running container using the ID
    or name of the container. Let’s do this for our trivia container:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You may want to use another terminal than the integrated terminal of VS Code
    for this exercise, as it seems to cause problems with the key combinations that
    we are going to use. On Mac, use the Terminal app, as an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a new instance of the `trivia` Docker image in interactive mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open yet another terminal window and use this command to attach it to the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this case, we will see, every 5 seconds or so, a new quote appearing in the
    output.
  prefs: []
  type: TYPE_NORMAL
- en: To quit the container without stopping or killing it, we can use the *Ctrl +
    P* `+` *Ctrl* + *Q* key combination. This detaches us from the container while
    leaving it running in the background.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Stop and remove the container forcefully:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run another container, this time, an Nginx web server:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the Nginx web server as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Here, we run the Alpine version of Nginx as a daemon in a container named `nginx`.
    The `-p 8080:80` command-line parameter opens port `8080` on the host (that is,
    the user’s machine) for access to the Nginx web server running inside the container.
    Don’t worry about the syntax here as we will explain this feature in more detail
    in [*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using* *Single-Host Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: On Windows, you’ll need to approve a prompt that Windows Firewall will pop up.
    You have to allow Docker Desktop on the firewall.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see whether we can access Nginx using the `curl` tool by running this
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If all works correctly, you should be greeted by the welcome page of Nginx:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – Welcome message of the Nginx web server](img/B19199_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – Welcome message of the Nginx web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s attach our terminal to the Nginx container to observe what’s happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once you are attached to the container, you will not see anything at first.
    But now, open another terminal, and in this new terminal window, repeat the `curl`
    command a few times, for example, using the following script:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Or, in PowerShell, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the logging output of Nginx, which looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.14 – Output of Nginx](img/B19199_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.14 – Output of Nginx
  prefs: []
  type: TYPE_NORMAL
- en: Quit the container by pressing *Ctrl* + *C*. This will detach your terminal
    and, at the same time, stop the Nginx container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To clean up, remove the Nginx container with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the next section, we’re going to learn how to work with container logs.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving container logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is a best practice for any good application to generate some logging information
    that developers and operators alike can use to find out what the application is
    doing at a given time, and whether there are any problems to help to pinpoint
    the root cause of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running inside a container, the application should preferably output the
    log items to `STDOUT` and `STDERR` and not into a file. If the logging output
    is directed to `STDOUT` and `STDERR`, then Docker can collect this information
    and keep it ready for consumption by a user or any other external system:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a trivia container in `detach` mode:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let it run for a minute or so so that it has time to generate a few trivia questions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the logs of a given container, we can use the `docker container logs`
    command. If, for example, we want to retrieve the logs of our `trivia` container,
    we can use the following expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will retrieve the whole log produced by the application from the very beginning
    of its existence.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Stop, wait a second – this is not quite true, what I just said. By default,
    Docker uses the so-called `json-file` logging driver. This driver stores logging
    information in a file. If there is a file rolling policy defined, then `docker
    container logs` only retrieves what is in the currently active log file and not
    what is in previous rolled files that might still be available on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to only get a few of the latest entries, we can use the `-t` or
    `--tail` parameter, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will retrieve only the last five items that the process running inside
    the container produced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, we want to follow the log that is produced by a container. This
    is possible when using the `-f` or `--follow` parameter. The following expression
    will output the last five log items and then follow the log as it is produced
    by the containerized process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Press *Ctrl + C* to stop following the logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clean up your environment and remove the trivia container with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Often, using the default mechanism for container logging is not enough. We need
    a different way of logging. This is discussed in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Logging drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker includes multiple logging mechanisms to help us to get information from
    running containers. These mechanisms are named logging drivers. Which logging
    driver is used can be configured at the Docker daemon level. The default logging
    driver is `json-file`. Some of the drivers that are currently supported natively
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Driver** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `none` | No log output for the specific container is produced. |'
  prefs: []
  type: TYPE_TB
- en: '| `json-file` | This is the default driver. The logging information is stored
    in files, formatted as JSON. |'
  prefs: []
  type: TYPE_TB
- en: '| `journald` | If the `journald` daemon is running on the host machine, we
    can use this driver. It forwards logging to the `journald` daemon. |'
  prefs: []
  type: TYPE_TB
- en: '| `syslog` | If the `syslog` daemon is running on the host machine, we can
    configure this driver, which will forward the log messages to the `syslog` daemon.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gelf` | When using this driver, log messages are written to a **Graylog
    Extended Log Format (GELF)** endpoint. Popular examples of such endpoints are
    Graylog and Logstash. |'
  prefs: []
  type: TYPE_TB
- en: '| `fluentd` | Assuming that the `fluentd` daemon is installed on the host system,
    this driver writes log messages to it. |'
  prefs: []
  type: TYPE_TB
- en: '| `awslogs` | The `awslogs` logging driver for Docker is a logging driver that
    allows Docker to send log data to Amazon CloudWatch Logs. |'
  prefs: []
  type: TYPE_TB
- en: '| `splunk` | The Splunk logging driver for Docker allows Docker to send log
    data to Splunk, a popular platform for log management and analysis. |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – List of logging drivers
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you change the logging driver, please be aware that the `docker container
    logs` command is only available for the `json-file` and `journald` drivers. Docker
    20.10 and up introduce *dual logging*, which uses a local buffer that allows you
    to use the `docker container logs` command for any logging driver.
  prefs: []
  type: TYPE_NORMAL
- en: Using a container-specific logging driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The logging driver can be set globally in the Docker daemon configuration file.
    But we can also define the logging driver on a container-by-container basis. In
    the following example, we run a `busybox` container and use the `--logdriver`
    parameter to configure the `none` logging driver:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run an instance of the `busybox` Docker image and execute a simple script in
    it outputting a `Hello` message three times:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s try to get the logs of the preceding container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This is to be expected since the `none` driver does not produce any logging
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s clean up and remove the `test` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To end this section about logging, we want to discuss a somewhat advanced topic,
    namely, how to change the default logging driver.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced topic – changing the default logging driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s change the default logging driver of a Linux host. The easiest way to
    do this is on a real Linux host. For this purpose, we’re going to use Vagrant
    with an Ubuntu image. Vagrant is an open source tool developed by HashiCorp that
    is often used to build and maintain portable virtual software development environments.
    Please follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a new terminal window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you haven’t done so before, on your Mac and Windows machine, you may need
    to install a hypervisor such as VirtualBox first. If you’re using a Pro version
    of Windows, you can also use Hyper-V instead:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To install VirtualBox on a Mac with an Intel CPU, use Homebrew as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'On Windows, with Chocolatey, use the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'On a Mac with an M1/M2 CPU, at the time of writing, you need to install the
    developer preview of VirtualBox. Please follow the instructions here: [https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install Vagrant on your computer using your package manager, such as Chocolatey
    on Windows or Homebrew on Mac. On my MacBook Air M1, the command looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On a Windows machine, the corresponding command would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Once successfully installed, make sure Vagrant is available with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the time of writing, Vagrant replies with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'In your terminal, execute the following command to initialize an Ubuntu 22.04
    VM with Vagrant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here is the generated output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.15 – Initializing a Vagrant VM based on Ubuntu 22.04](img/B19199_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.15 – Initializing a Vagrant VM based on Ubuntu 22.04
  prefs: []
  type: TYPE_NORMAL
- en: Vagrant will create a file called `Vagrantfile` in the current folder. Optionally,
    you can use your editor to analyze the content of this file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: On a Mac with an M1/M2 CPU, at the time of writing, the `bento/ubuntu-22.4`
    image does not work. An alternative that seems to work is `illker/ubuntu-2004`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, start this VM using Vagrant:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Connect from your laptop to the VM using Secure Shell (`ssh`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this, you will find yourself inside the VM and can start working with
    Docker inside this VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once inside the Ubuntu VM, we want to edit the Docker daemon configuration
    file and trigger the Docker daemon to reload the configuration file thereafter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Navigate to the `/``etc/docker` folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run `vi` as follows:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following content:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding definition tells the Docker daemon to use the `json-log` driver
    with a maximum log file size of 10 MB before it is rolled, and the maximum number
    of log files that can be present on the system is three before the oldest file
    gets purged.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Save and exit `vi` by first pressing *Esc*, then typing `:w:q` (which means
    *write and quit*), and finally hitting the *Enter* key.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we must send a `SIGHUP` signal to the Docker daemon so that it picks up
    the changes in the configuration file:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the preceding command only reloads the config file and does not restart
    the daemon.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Test your configuration by running a few containers and analyzing the log output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clean up your system once you are done experimenting with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Great! The previous section was an advanced topic and showed how you can change
    the log driver on a system level. Let’s now talk a bit about the anatomy of containers.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many people wrongly compare containers to VMs. However, this is a questionable
    comparison. Containers are not just lightweight VMs. OK then, what is the correct
    description of a container?
  prefs: []
  type: TYPE_NORMAL
- en: Containers are specially encapsulated and secured processes running on the host
    system. Containers leverage a lot of features and primitives available on the
    Linux operating system. The most important ones are **namespaces** and **control
    groups** (**cgroups** for short). All processes running in containers only share
    the same Linux kernel of the underlying host operating system. This is fundamentally
    different from VMs, as each VM contains its own full-blown operating system.
  prefs: []
  type: TYPE_NORMAL
- en: The startup times of a typical container can be measured in milliseconds, while
    a VM normally needs several seconds to minutes to start up. VMs are meant to be
    long-living. It is a primary goal of each operations engineer to maximize the
    uptime of their VMs. Contrary to that, containers are meant to be ephemeral. They
    come and go relatively quickly.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first get a high-level overview of the architecture that enables us to
    run containers.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here, we have an architectural diagram of how this all fits together:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.16 – High-level architecture of Docker](img/B19199_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.16 – High-level architecture of Docker
  prefs: []
  type: TYPE_NORMAL
- en: In the lower part of the preceding diagram, we have the Linux operating system
    with its cgroups, namespaces, and layer capabilities as well as other operating
    system functionality that we do not need to explicitly mention here. Then, there
    is an intermediary layer composed of `containerd` and `runc`. On top of all that
    now sits the Docker engine. The Docker engine offers a RESTful interface to the
    outside world that can be accessed by any tool, such as the Docker CLI, Docker
    Desktop, or Kubernetes, to name just a few.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now describe the main building blocks in a bit more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux namespaces were around for years before they were leveraged by Docker
    for their containers. A **namespace** is an abstraction of global resources such
    as filesystems, network access, and process trees (also named PID namespaces)
    or the system group IDs and user IDs. A Linux system is initialized with a single
    instance of each namespace type. After initialization, additional namespaces can
    be created or joined.
  prefs: []
  type: TYPE_NORMAL
- en: The Linux namespaces originated in 2002 in the 2.4.19 kernel. In kernel version
    3.8, user namespaces were introduced, and with this, namespaces were ready to
    be used by containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wrap a running process, say, in a filesystem namespace, then this provides
    the illusion that the process owns its own complete filesystem. This, of course,
    is not true; it is only a virtual filesystem. From the perspective of the host,
    the contained process gets a shielded subsection of the overall filesystem. It
    is like a filesystem in a filesystem:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.17 – Namespaces explained](img/B19199_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.17 – Namespaces explained
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to all of the other global resources for which namespaces exist.
    The user ID namespace is another example. Now that we have a user namespace, we
    can define a `jdoe` user many times on the system as long as it is living in its
    own namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'The PID namespace is what keeps processes in one container from seeing or interacting
    with processes in another container. A process might have the apparent PID 1 inside
    a container, but if we examine it from the host system, it will have an ordinary
    PID, say, `334`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.18 – Process tree on a Docker host](img/B19199_03_18_new.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.18 – Process tree on a Docker host
  prefs: []
  type: TYPE_NORMAL
- en: In each namespace, we can run one-to-many processes. That is important when
    we talk about containers, which we already experienced when we executed another
    process in an already-running container.
  prefs: []
  type: TYPE_NORMAL
- en: Control groups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux cgroups are used to limit, manage, and isolate the resource usage of collections
    of processes running on a system. Resources are the CPU time, system memory, network
    bandwidth, or combinations of these resources.
  prefs: []
  type: TYPE_NORMAL
- en: Engineers at Google originally implemented this feature in 2006\. The cgroups
    functionality was merged into the Linux kernel mainline in kernel version 2.6.24,
    which was released in January 2008.
  prefs: []
  type: TYPE_NORMAL
- en: Using cgroups, administrators can limit the resources that containers can consume.
    With this, we can avoid, for example, the classic noisy neighbor problem, where
    a rogue process running in a container consumes all the CPU time or reserves massive
    amounts of RAM and, as such, starves all the other processes running on the host,
    whether they’re containerized or not.
  prefs: []
  type: TYPE_NORMAL
- en: Union filesystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Union filesystem** (**unionfs**) forms the backbone of what is known as container
    images. We will discuss container images in detail in the next chapter. Currently,
    we want to just understand what unionfs is and how it works a bit better. unionfs
    is mainly used on Linux and allows files and directories of distinct filesystems
    to be overlaid to form a single coherent filesystem. In this context, the individual
    filesystems are called branches. Contents of directories that have the same path
    within the merged branches will be seen together in a single merged directory,
    within the new virtual filesystem. When merging branches, the priority between
    the branches is specified. In that way, when two branches contain the same file,
    the one with the higher priority is seen in the final filesystem.'
  prefs: []
  type: TYPE_NORMAL
- en: Container plumbing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The foundation on top of which Docker Engine is built comprises two components,
    `runc` and `containerd`.
  prefs: []
  type: TYPE_NORMAL
- en: Originally, Docker was built in a monolithic way and contained all of the functionality
    necessary to run containers. Over time, this became too rigid, and Docker started
    to break out parts of the functionality into their own components. Two important
    components are `runc` and `containerd`.
  prefs: []
  type: TYPE_NORMAL
- en: runc
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: runc is a lightweight, portable container runtime. It provides full support
    for Linux namespaces as well as native support for all security features available
    on Linux, such as SELinux, AppArmor, seccomp, and cgroups.
  prefs: []
  type: TYPE_NORMAL
- en: runC is a tool for spawning and running containers according to the **Open Container
    Initiative** (**OCI**) specification. It is a formally specified configuration
    format, governed by the **Open Container Project** (**OCP**) under the auspices
    of the Linux Foundation.
  prefs: []
  type: TYPE_NORMAL
- en: containerd
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: runC is a low-level implementation of a container runtime; containerd builds
    on top of it and adds higher-level features, such as image transfer and storage,
    container execution, and supervision as well as network and storage attachments.
    With this, it manages the complete life cycle of containers. containerd is the
    reference implementation of the OCI specifications and is by far the most popular
    and widely used container runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Containerd was donated to and accepted by the CNCF in 2017\. There are alternative
    implementations of the OCI specification. Some of them are `rkt` by CoreOS, CRI-O
    by Red Hat, and LXD by Linux Containers. However, containerd is currently by far
    the most popular container runtime and is the default runtime of Kubernetes 1.8
    or later and the Docker platform.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to work with containers that are based on existing
    images. We showed how to run, stop, start, and remove a container. Then, we inspected
    the metadata of a container, extracted its logs, and learned how to run an arbitrary
    process in an already-running container. Last but not least, we dug a bit deeper
    and investigated how containers work and what features of the underlying Linux
    operating system they leverage.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you’re going to learn what container images are and how
    we can build and share our own custom images. We’ll also be discussing the best
    practices commonly used when building custom images, such as minimizing their
    size and leveraging the image cache. Stay tuned!
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following articles give you some more information related to the topics
    we discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Get started with containers at [https://docs.docker.com/get-started/](https://docs.docker.com/get-started/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get an overview of Docker container commands at [http://dockr.ly/2iLBV2I](http://dockr.ly/2iLBV2I)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about isolating containers with a user namespace at [http://dockr.ly/2gmyKdf](http://dockr.ly/2gmyKdf)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn about limiting a container’s resources at [http://dockr.ly/2wqN5Nn](http://dockr.ly/2wqN5Nn)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To assess your learning progress, please answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: Which two important concepts of Linux are enabling factors for containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the possible states a container can be in?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command helps us to find out which containers are currently running on
    our Docker host?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command is used to list only the IDs of all containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are some sample answers to the questions presented in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux had to first introduce **namespaces** and **cgroups** to make containers
    possible. Containers use those two concepts extensively. Namespaces are used to
    encapsulate and thus protect resources defined and/or running inside a container.
    cgroups are used to limit the resources processes running inside a container can
    use, such as memory, bandwidth, or CPU.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The possible states of a Docker container are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`created`: A container that has been created but not started'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`restarting`: A container that is in the process of being restarted'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`running`: A currently running container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`paused`: A container whose processes have been paused'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exited`: A container that ran and completed'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dead`: A container that Docker Engine tried and failed to stop'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can use the following (or the old, shorter version, `docker ps`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is used to list all containers that are currently running on our Docker
    host. Note that this will *not* list the stopped containers, for which you need
    the extra `--all` (or `-a`) parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To list all container IDs, running or stopped, we can use the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `-q` stands for output ID only, and `-a` tells Docker that we want to
    see all containers, including stopped ones.
  prefs: []
  type: TYPE_NORMAL
