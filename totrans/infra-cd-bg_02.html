<html><head></head><body>
<div><div><div><h1 id="_idParaDest-33" class="chapter-number"><a id="_idTextAnchor085"/>2</h1>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor086"/>Ansible and Terraform beyond the Documentation</h1>
			<p>The next phase in our journey to <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) is to take a look at <strong class="bold">Terraform</strong>, an IaC tool from HashiCorp, and <strong class="bold">Ansible</strong>, an IaC and configuration management tool from <em class="italic">Red Hat</em>.</p>
			<p>We will also compare the advantages and disadvantages of using them, set them up on macOS, Windows 11, and Ubuntu Linux, and look at using Visual Studio Code as an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) to write our code, plus look at which recommended extensions to install.</p>
			<p>In this chapter, we are going to take a look at the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor087"/>What is important when choosing a tool?</li>
				<li><a id="_idTextAnchor088"/>Introducing Terraform<a id="_idTextAnchor089"/></li>
				<li>Introducing Ansible</li>
				<li><a id="_idTextAnchor090"/>Introducing Visual Studio Code, the open source IDE from Microsoft</li>
			</ul>
			<p>Before we start looking at the tools we will be using throughout this title, let’s quickly discuss a checklist I use to choose which tools to use in a project.</p>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor091"/>What is important when choosing a tool?</h1>
			<p>So, you have a new project – you know which cloud provider you will use, and your development <a id="_idIndexMarker052"/>team has given you an overview of their application – meaning you already have a good idea of the resources you will deploy and manage. You have been given free rein to choose which IaC tool to use – so how do you choose?</p>
			<p>Personally, my approach is always to use the best tool for the job rather than trying to fit the job to the tool – that, in <a id="_idIndexMarker053"/>my experience, always ends up causing issues when it comes to deploying the code and managing the deployment once it has been deployed.</p>
			<p>Let us discuss some of the key things you will need to consider.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor092"/>Deployment types</h2>
			<p>There are two main types of deployment I come across, with the first being using IaC to repeatedly deploy <a id="_idIndexMarker054"/>the same resources in a predictable and consistent way.</p>
			<p>The most common use case for this approach is for dev, test, and other lower environments, <a id="_idIndexMarker055"/>not production.</p>
			<p>The goal is to integrate with your developer’s build, release, and test pipelines so that when they push their code changes for one of the environment branches mentioned, the following happens:</p>
			<ul>
				<li>The push triggers the deployment of the resources using your IaC scripts</li>
				<li>Once the resources have been deployed, your IaC pipeline hands back over to developers’ pipelines for them to build their code and deploy it to the resources that have just been launched</li>
				<li>Once the application code has been deployed, run the developer’s automated testing or notify someone within the team that the newly pushed code is ready for manual testing</li>
				<li>Finally, with testing complete, after the results are stored and either by an automated or manual decision gate in the pipeline, the resources deployed at the start of the process are terminated</li>
			</ul>
			<p>The process above is repeated for each push – with multiple deployments sometimes being executed in parall<a id="_idTextAnchor093"/>el.</p>
			<p>The advantage of taking <a id="_idIndexMarker056"/>an approach like this is that you not only get cost savings, but you are only running resources while they are needed. Additionally, configuration drift is avoided as you are launching the resources from scratch with each deployment.</p>
			<p>Configuration drift occurs when someone with the best intentions quickly tweaks a setting somewhere manually to get something working and doesn’t document it anywhere. In this case, ad-hoc fixes would need to be rolled into your code for them to persist through to the next deployment.</p>
			<p>The next deployment type is to launch and manage your resources using your IaC scripts. As you may <a id="_idIndexMarker057"/>have guessed, this approach is used in longer-running environments such as production.</p>
			<p>When you first think about this type of deployment, it is easy to assume that it is quite close to the first deployment type – however, in fact, the first deployment type is only executed once per deployment, whereas this type is executed multiple times against the same deployment which can introduce some interesting challenges, such as the following:</p>
			<ul>
				<li>Depending <a id="_idIndexMarker058"/>on the resource type, where is the line drawn between what is configured and managed by your IaC scripts and the application deployment?</li>
				<li>As you are dealing with long-running resources, what additional logic or error checking do you need to build into your IaC scripts so that the execution of your code is terminated rather than the resources you are running the code against? After all, you don’t want to cause an outage, no matter how easy it is to recreate your infrastructure!</li>
				<li>How are you managing the state of your infrastructure? As we will learn in the next section of this chapter, having a consistent state is important for one of the tools we will cover in this book – so where is it stored long term?</li>
			</ul>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor094"/>Infrastructure and configuration</h2>
			<p>While we will <a id="_idIndexMarker059"/>be talking a lot about IaC in this book, which I am hoping if you have made it this far shouldn’t be a surprise, where is the line drawn between your IaC scripts and the deployment/configuration of the application?</p>
			<p>A good example of this is when your project involves deploying <strong class="bold">Infrastructure as a Service</strong> (<strong class="bold">IaaS</strong>) resources such as virtual machines. Let’s say you need to deploy two Linux servers and <a id="_idIndexMarker060"/>then install NGINX along with a scripting language such as PHP on there; how will you achieve that?</p>
			<p>Most public cloud providers allow you to attach and execute a script when launching a virtual machine using a service such as cloud-init – while this should cover most basic use cases, using this approach does add a level of abstraction that could cause problems – for example, does <a id="_idIndexMarker061"/>your cloud provider provide any details on the execution of the script – and will your IaC execution know if that has failed?</p>
			<p>If you need more granular control or visibility of the commands being run as part of the deployment, then this will dictate which tool you choose as a pure IaC tool may not be enough for your needs.</p>
			<p>This will also influence the next decision.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor095"/>External interactions and secrets</h2>
			<p>As mentioned at the end of the last section, if your IaC script needs to interact with a resource using a <a id="_idIndexMarker062"/>service outside <a id="_idIndexMarker063"/>of a publicly accessible API – such as <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) or <strong class="bold">Windows Remote Management</strong> (<strong class="bold">WinRM)</strong> to run scripts on a virtual machine or an internally <a id="_idIndexMarker064"/>hosted API such as the vSphere API used to manage resources hosted in VMWare environments, then you will carefully need to choose where your IaC is executed from as you will need line of sight to the resource you are interacting with.</p>
			<p>Likewise, depending on how you manage secrets within your IaC scripts for things such as passwords or certificates for services you are launching, you will also need line of sight, by which I mean direct access, of your secret storage or a way of securely injecting them into your scripts because as storing them as <em class="italic">hardcoded values in plain text within your IaC is never an </em><em class="italic">option, ever!</em></p>
			<p>This means that you will need to assess where and how you execute your scripts, considering things such as firewalls plus access to resources and credentials – all without exposing any secrets.</p>
			<p>We will cover all of this when we roll up our sleeves and start building up our deployment in later chapters.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor096"/>Ease of use</h2>
			<p>The final consideration is simply how easy the tool is to use.</p>
			<p>It is easy to <a id="_idIndexMarker065"/>get swept up in the latest shiny new technologies, but if you are the only person in your team who has any experience with it, you will be adding complications as not only will you need to up-skill the rest of the team so they can also work with the code but also you will need to deal the issues that can occur from being an early adopter.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor097"/>Summary</h2>
			<p>Everything we have discussed in this section should be at the forefront of your mind when approaching any IaC project. By the end of this book, you will have both the answers and experience to all of the questions and considerations raised during this section to be able to choose the right tool for the job rather than trying to fit your project to the tool, or what sometimes can only be described as fitting a square peg in a round hole.</p>
			<p>Now is the time I hope you have been waiting for; we will look at our tw<a id="_idTextAnchor098"/>o main tools<a id="_idTextAnchor099"/>.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor100"/>Introducing Terraform</h1>
			<p>The first of the two tools we will look at is Terraform by HashiCorp.</p>
			<p>Hashicorp Terraform is an enterprise-ready cloud and virtualization management tool. It helps you manage your resources and deploy new instances with ease. Terraform is an open source tool for managing the cloud infrastructure, allowing you to not only efficiently configure and deploy your resources but also help you maintain your infrastructure while evolving it over time.</p>
			<p>Terraform has a unique <a id="_idIndexMarker066"/>architecture in that it uses a state machine to manage resources and it is fully modular, and you can scale the service as per your needs. Finally, it is also integrated with many third-party tools and services.</p>
			<p>Terraform uses the <strong class="bold">Hashicorp Configuration Language</strong> (<strong class="bold">HCL</strong>). You could be mistaken at first <a id="_idIndexMarker067"/>glance for thinking it is for JSON or YAML, but it’s a syntax and API designed by HashiCorp for building structured configuration formats, whereas YAML and JSON are just formats that define data structures in human- and machine-readable formats respectively.</p>
			<p>Rather than going <a id="_idIndexMarker068"/>into any more detail about HCL – let’s take a look at<a id="_idTextAnchor101"/> an HCL example.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor102"/>An HCL example – creating a resource group</h2>
			<p>I personally do a <a id="_idIndexMarker069"/>lot of my day-to-day work with Microsoft Azure, so I will target that w<a id="_idTextAnchor103"/>ith this example.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Feel free to follow along; if you need assistance installing Terraform, then there are links to the relevant documentation in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
			<p>Azure has a <a id="_idIndexMarker070"/>concept of resource groups that act as a logical container for your resources, so let us start by creating one of those:</p>
			<ol>
				<li>There are three main sections we need in our Terraform, the first of which tells Terraform which version of Terraform our code is compatible with and also which external providers we need to use. In the case of creating a resource group, this looks like the follow<a id="_idTextAnchor104"/>ing:<pre class="source-code">
terr<a id="_idTextAnchor105"/>aform {
  required_v<a id="_idTextAnchor106"/>ersion = "&gt;=1.0"
  requir<a id="_idTextAnchor107"/>ed_providers {
    azurerm = <a id="_idTextAnchor108"/>{
      source  = "hashicorp/azurerm"
      version = "~&gt;3.0"
    }
  }
}</pre></li>
			</ol>
			<p>One of the biggest selling points of Terraform is that it is both machine- and human-readable – I am sure you will agree from the small preceding  snippet of code that it is easy to figure out what is going on.</p>
			<p>Here we have said that <code>required_version</code> of Terraform should be greater or equal to <code>1.0</code>. Next up, we have <code>required_providers</code>; a provider is an external library that extends the functionality – in this example, we are telling Terraform to download and use the latest version of the <code>3.0</code> release of the <code>azurerm</code> provider from <code>hashicorp/azurerm</code>, which is where the official provider releases should be sourced from.</p>
			<ol>
				<li value="2">The next section configures the providers. For our example, we won’t do any additional <a id="_idIndexMarker071"/>configuration, so this just looks like the following:<pre class="source-code">
provider "azurerm" {
  features {}
}</pre></li>
				<li>Next up is the final section of our example; this is where we configure our resource group:<pre class="source-code">
resource "azurerm_resource_group" "example" {
  name     = "rg-example-uks"
  location = "UK South"
}</pre></li>
			</ol>
			<p>As you can see, there is not much to it – we simply define what we want the resource to be called by providing <code>name</code> and also which Azure region we would like the resource group to be placed in using <code>location</code>.</p>
			<p>All the preceding code is placed in a file called <code>terraform.tf</code> in an empty folder. Before we can create the resource group, we will need to initialize Terraform; this will download the <code>azurerm</code> provider and create a few supporting files, such as <code>locks</code>, which are needed to execute the code.</p>
			<ol>
				<li value="4">To deploy the resource group, we first need to run the following command to prepare our local environment:<pre class="source-code">
<strong class="bold">$ terraform init</strong></pre></li>
				<li>This will <a id="_idIndexMarker072"/>give something like the following output:<pre class="source-code">
Initializing the backend...
Initializing provider plugins...
- Finding hashicorp/azurerm versions matching "~&gt; 3.0"...
- Installing hashicorp/azurerm v3.32.0...
- Installed hashicorp/azurerm v3.32.0 (signed by HashiCorp)
Terraform has created a lock file .terraform.lock.hcl to record the provider selections it made above. Include this file in your version control repository so that Terraform can guarantee to make the same selections by default when you run "terraform init" in the future.
Terraform has been successfully initialized!</pre></li>
				<li>So now that Terraform is ready, we can run it – first of all, we need to run a plan:<pre class="source-code">
<strong class="bold">$ terraform plan</strong></pre></li>
			</ol>
			<p>This should give us an idea of what Terraform is going to do when we apply our configuration; in my case, this gave the following output:</p>
			<pre class="source-code">
Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:
  + create
Terraform will perform the following actions:
  # azurerm_resource_group.example will be created
  + resource "azurerm_resource_group" "example" {
      + id       = (known after apply)
      + location = "uksouth"<a id="_idTextAnchor109"/>
      + name     = "rg-example-uks"
    }
Plan: 1 to add, 0 to change, 0 to destroy.</pre>
			<p>What Terraform has done here are some basic flight checks, discovering that it doesn’t know about a resource group called <code>rg-example-uks</code> in the <code>uksouth</code> region and, therefore, it needs to add it, and because we are only creating a single resource there is <code>1</code> to add.</p>
			<ol>
				<li value="7"> To create the resource group, we need to run the following command:<pre class="source-code">
<strong class="bold">$ terraform apply</strong></pre></li>
			</ol>
			<p>When doing so, it <a id="_idIndexMarker073"/>will give us the same output as when running <code>terraform plan</code>, but this time, as usual, if we want to proceed, answering <code>yes</code> will then deploy the resource:</p>
			<pre class="source-code">
Do you want to perform these actions?
  Terraform will perform the actions described above.
  Only 'yes' will be accepted to approve.
  Enter a value: yes
azurerm_resource_group.example: Creating...
azurerm_resource_group.example: Creation complete after 0s [id=/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx/resourceGroups/rg-example-uks]</pre>
			<ol>
				<li value="8">There we have it; our <a id="_idIndexMarker074"/>resource group has been created. Running the <code>terraform apply</code> command again gives the following output:<pre class="source-code">
azurerm_resource_group.example: Refreshing state<a id="_idTextAnchor110"/>... [id=/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /resourceGroups/rg-example-uks]
No changes. Your infrastructure matches the configuration.
Terraform has compared your real infrastructure against your configuration and found no differences, so no changes are needed.
Apply complete! Resources: 0 added, 0 changed, 0 destroyed.</pre></li>
			</ol>
			<p>So, no changes are needed – now let’s add another resource – how about a storage account?</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor111"/>Adding more resources</h2>
			<p>Follow these <a id="_idIndexMarker075"/>steps to add a storage account:</p>
			<ol>
				<li>To do this, we simply need the following resource at the end of the <code>terraform.tf</code> file:<pre class="source-code">
resource "azurerm_storage_account" "example" {
  name                     = "saiacforbeg2022111534"
  resource_group_name      = "rg-example-uks"
  location                 = "UK South"
  account_tier             = "Standard"
  account_replication_type = "GRS"
}</pre></li>
			</ol>
			<p>Running <code>terraform apply</code> now gives the following output, which I have truncated as the total amount of lines has gone from 13 to 166 lines:</p>
			<pre class="source-code">
<strong class="bold">azurerm_resource_group.example: Refreshing state... [id=/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /resourceGroups/rg-example-uks]</strong>
<strong class="bold">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</strong>
<strong class="bold">  + create</strong>
<strong class="bold">Terraform will perform the following actions:</strong>
<strong class="bold">  # azurerm_storage_account.example will be created</strong>
<strong class="bold">  + resource "azurerm_storage_account" "example" {</strong>
<strong class="bold">      + account_kind                      = "StorageV2"</strong>
<strong class="bold">      + account_replication_type          = "GRS"</strong>
<strong class="bold">      + account_tier                      = "Standard"</strong>
<strong class="bold">      + location                          = "uksouth"</strong>
<strong class="bold">      + name                              = "saiacforbeg2022111534"</strong>
<strong class="bold">      + resource_group_name               = "rg-example-uks</strong>
<strong class="bold">Plan: 1 to add, 0 to change, 0 to destroy.</strong>
<strong class="bold">Do you want to perform these actions?</strong></pre>
			<ol>
				<li value="2">Answer <code>yes</code> to <a id="_idIndexMarker076"/>get the following output:<pre class="source-code">
<strong class="bold">azurerm_storage_account.example: Creating...</strong>
<strong class="bold">azurerm_storage_account.example: Still creating... [10s elapsed]</strong>
<strong class="bold">azurerm_storage_account.example: Still creating... [20s elapsed]</strong>
<strong class="bold">azurerm_storage_account.example: Creation complete after 25s [id=/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /resourceGroups/rg-example-uks/providers/Microsoft.Storage/storageAccounts/saiacforbeg2022111534]</strong></pre></li>
				<li>So, we now have our storage account – great, let’s destroy it and run it again:<pre class="source-code">
$ terraform destroy</pre></li>
			</ol>
			<p>The output <a id="_idIndexMarker077"/>of this command will tell us what is going to be removed (again, the output has been truncated):</p>
			<pre class="source-code">
<strong class="bold">Terraform used the selected providers to generate the following execution plan. Resource actions are indicated with the following symbols:</strong>
<strong class="bold">  - destroy</strong>
<strong class="bold">Terraform will perform the following actions:</strong>
<strong class="bold">  # azurerm_resource_group.example will be destroyed</strong>
<strong class="bold">  - resource "azurerm_resource_group" "example" {}</strong>
<strong class="bold">  # azurerm_storage_account.example will be destroyed</strong>
<strong class="bold">  - resource "azurerm_storage_account" "example" {}</strong>
<strong class="bold">Plan: 0 to add, 0 to change, 2 to destroy.</strong>
<strong class="bold">Do you really want to destroy all resources?</strong></pre>
			<ol>
				<li value="4">Answer <code>yes</code>, and that will, as you may have guessed, destroy the resources:<pre class="source-code">
<strong class="bold">azurerm_resource_group.example: Destroying... [id=/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /resourceGroups/rg-example-uks]</strong>
<strong class="bold">azurerm_storage_account.example: Destroying... [id=/subscriptions/xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx /resourceGroups/rg-example-uks/providers/Microsoft.Storage/storageAccounts/saiacforbeg2022111534]</strong>
<strong class="bold">azurerm_storage_account.example: Destruction complete after 3s</strong>
<strong class="bold">azurerm_resource_group.example: Destruction complete after 46s</strong>
<strong class="bold">Destroy complete! Resources: 2 destroyed.</strong></pre></li>
				<li>Now running <a id="_idIndexMarker078"/>the script again using <code>terraform apply</code> tells us that two resources are going to be added:<pre class="source-code">
<strong class="bold">Plan: 2 to add, 0 to change, 0 to destroy.</strong></pre></li>
				<li>However, when you say <code>yes</code> and try to proceed, it will give an error:<pre class="source-code">
<strong class="bold">│ Error: creating Azure Storage Account "saiacforbeg2022111534": storage.AccountsClient#Create: Failure sending request: StatusCode=404 -- Original Error: Code="ResourceGroupNotFound" Message="Resource group 'rg-example-uks' could not be found."</strong>
<strong class="bold">│   with azurerm_storage_account.example,</strong>
<strong class="bold">│   on terraform.tf line 21, in resource "azurerm_storage_account" "example":</strong>
<strong class="bold">│   21: resource "azurerm_storage_account" "example" {</strong></pre></li>
			</ol>
			<p>Why did it error? Let’s take a look at the error and figure out what happened.</p>
			<h3>Fixing the error</h3>
			<p>First of all, why <a id="_idIndexMarker079"/>are we getting the error?</p>
			<p>If you remember, in the previous chapter, we discus<a id="_idTextAnchor112"/>sed the differences between imperative and declarative; this is an example of what happens if you don’t plan your deployment right with an imperative tool.</p>
			<p>As the storage account is attached to a resource group, and at the time of execution, the resource group didn’t exist, and the storage account couldn’t be created.</p>
			<p>However, the resource group had no dependency failures as part of the Terraform run,<a id="_idTextAnchor113"/> meaning if you were to run <code>terraform apply</code> again, the storage account would be created – so how do we get around this so that it works the first time we run <code>terraform apply</code>?</p>
			<p>You may have noticed that Terraform refers to the two resources we are creating as <code>azurerm_resource_group.example</code> and <code>azurerm_storage_account.example</code>; these are internal references that we can use in our own code. Also, for most of these references, some outputs are only populated once <a id="_idIndexMarker080"/>the resource has been created. Some of these references are only known after the resource has been created because it is a return value of the resource being created in Azure, such as a unique ID, while for others, they are ones which we have defined – but are only populated once the resource has been launched. In the case of <code>azurerm_resource_group</code>, the name and location are populated as an output value once the group has been created.</p>
			<p>We can reference these in our <code>azurerm_storage_account</code> block by referring to the resource; this looks like the following:</p>
			<pre class="source-code">
resource "azurerm_storage_account" "example" {
  name                     = "saiacforbeg2022111534"
  resource_group_name      = azurerm_resource_group.example.name
  location                 = azurerm_resource_group.example.location
  account_tier             = "Standard"
  account_replication_type = "GRS"
}</pre>
			<p>What this will do is wait for the resource group to be deployed before Terraform will attempt to create the storage account – rather than just attempting to create both resources at the point of execution and failing.</p>
			<p>While I wouldn’t describe scenarios like this as errors or faults, they are more like quirks that you <a id="_idIndexMarker081"/>won’t discover until you attempt something. Because of this, as we progress through the book, I will call out quite a few examples of this and other similar approaches because the more complex your deployment code is, the more considerations you will need to make when writing it.</p>
			<p>The following screenshot shows the resources deployed in the Azure portal:</p>
			<div><div><img src="img/Figure_2.01_B19537.jpg" alt="Figure 2.1 – The deployed resources within the Azure portal" width="1633" height="857"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The deployed resources within the Azure portal</p>
			<p>You can clean <a id="_idIndexMarker082"/>up the resources you have launched by running the following command:</p>
			<pre class="source-code">
$ terraform destroy</pre>
			<p>This permanently deletes the resource group and storage account, so please ensure that you are happy to proceed before saying <code>Yes</code>.</p>
			<p>Now that we have learned a little about Terraform, let’s look at the other tool we will be using in the book, Ansible.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor114"/>Introducing Ansible</h1>
			<p>The second tool <a id="_idIndexMarker083"/>we cover in detail in this book is Ansible by Red Hat.</p>
			<p>Ansible is a popular configuration management tool that enables users to automate the deployment and management of their applications.</p>
			<p>It uses a hub-and-spoke model where a controlling machine instructs other machines to perform tasks. You can use it to manage your servers, deploy applications, or configure your network devices. One of the biggest advantages over other agentless devices is you don’t need to install anything on the target device you’re managing.</p>
			<p>It supports YAML and JSON for writing playbooks, the main configuration file, meaning that it is language-agnostic when managing your remote systems and their state.</p>
			<p>There is no one-size-fits-all <a id="_idIndexMarker084"/>solution when it comes to your IaC solution, and Ansible allows you to choose from various modules to achieve your desired result, providing a great deal of flexibility when managing your infrastructure.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor115"/>An Ansible example</h2>
			<p>Let’s take the <a id="_idIndexMarker085"/>same example we used for Terraform and recreate it in Ansible, creating an Azure resource group and placing an Azure storage account in it:</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Again, feel free to follow along; if you need assistance installing Ansible, there are links provided in the <em class="italic">Further reading</em> section at the end of this chapter.</p>
			<ol>
				<li>Place the following code in a blank file on your local machine called <code>playbook.yml</code>:<pre class="source-code">
<strong class="bold">---</strong>
<strong class="bold">- name: Ansible Infrastructure as Code example</strong>
<strong class="bold">  hosts: localhost</strong>
<strong class="bold">  tasks:</strong>
<strong class="bold">    - name: Create an example resource group</strong>
<strong class="bold">      azure.azcollection.azure_rm_resourcegroup:</strong>
<strong class="bold">        name: "rg-example-uks"</strong>
<strong class="bold">        location: "UK South"</strong>
<strong class="bold">    - name: Create an example storage account</strong>
<strong class="bold">      azure.azcollection.azure_rm_storageaccount:</strong>
<strong class="bold">        resource_group: "rg-example-uks"</strong>
<strong class="bold">        name: "saiacforbeg2022111534"</strong>
<strong class="bold">        account_type: "Standard_GRS"</strong></pre></li>
			</ol>
			<p class="callout-heading">Hint</p>
			<p class="callout">As this is a YAML file, the indentation is extremely important – before attempting to execute the playbook, I would <a id="_idIndexMarker086"/>reco<a href="https://www.yamllint.com/">mmend using an online too</a>l such as <a href="https://www.yamllint.com/">https://www.yamllint.com/</a> to quickly validate your file.</p>
			<ol>
				<li value="2">Once you are ready to run your playbook, y<a id="_idTextAnchor116"/>ou can run the following command:<pre class="source-code">
<strong class="bold">$ ansible-playbook playbook.yml</strong></pre></li>
			</ol>
			<p>On the first <a id="_idIndexMarker087"/>run, this gives the following error:</p>
			<pre class="source-code">
<strong class="bold">[WARNING]: No inventory was parsed, only implicit localhost is available</strong>
<strong class="bold">[WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'</strong>
<strong class="bold">PLAY [Ansible Infrastructure as Code example] ******************************************************</strong>
<strong class="bold">TASK [Gathering Facts] *****************************************************************************</strong>
<strong class="bold">ok: [localhost]</strong>
<strong class="bold">TASK [Create an example resource group] ************************************************************</strong>
<strong class="bold">An exception occurred during task execution. To see the full traceback, use -vvv. The error was: ModuleNotFoundError: No module named 'msrest'</strong>
<strong class="bold">fatal: [localhost]: FAILED! =&gt; {"changed": false, "msg": "Failed to import the required Python library (msrestazure) on Russs-Laptop.local's Python /opt/homebrew/Cellar/ansible/6.6.0/libexec/bin/python3.10. Please read the module documentation and install it in the appropriate location. If the required library is installed, but Ansible is using the wrong Python interpreter, please consult the documentation on ansible_python_interpreter"}</strong>
<strong class="bold">PLAY RECAP *****************************************************************************************</strong>
<strong class="bold">localhost: ok=1    changed=0    unreachable=0    failed=1     skipped=0    rescued=0    ignored=0</strong></pre>
			<p>The first two <a id="_idIndexMarker088"/>warnings can be ignored; however, the error is something we will need to take care of before we can run our playbook.</p>
			<ol>
				<li value="3">As mentioned in the introduction of this section, Ansible is modular – these modules are known as collections. As you can see from the code, we are using the <code>azure.azcollection</code> collection.</li>
			</ol>
			<p>To install it, we need to run two commands; the first downloads the collection itself, and the second installs the required Python dependencies needed for the collection to work:</p>
			<pre class="source-code">
<strong class="bold">$ ansible-galaxy collection install azure.azcollection</strong>
<strong class="bold">$ pip3 install -r ~/.ansible/collections/ansible_collections/azure/azcollection/requirements-azure.txt</strong></pre>
			<ol>
				<li value="4">Once installed, rerun the following command:<pre class="source-code">
<strong class="bold">$ ansible-playbook playbook.yml</strong></pre></li>
			</ol>
			<p>This should result in the following output (I have removed the warnings this time; as already <a id="_idIndexMarker089"/>mentioned, they can be ignored for now):</p>
			<pre class="source-code">
<strong class="bold">PLAY [Ansible Infrastructure as Code example] *************************************************************</strong>
<strong class="bold">TASK [Gathering Facts] ************************************************************************************</strong>
<strong class="bold">ok: [localhost]</strong>
<strong class="bold">TASK [Create an example resource group] *******************************************************************</strong>
<strong class="bold">changed: [localhost]</strong>
<strong class="bold">TASK [Create an example storage account] ******************************************************************</strong>
<strong class="bold">changed: [localhost]</strong>
<strong class="bold">PLAY RECAP ************************************************************************************************</strong>
<strong class="bold">localhost: ok=3    changed=2    unreachable=0    failed=0     skipped=0    rescued=0    ignored=0</strong></pre>
			<p>As you can see, everything went as planned this time, and of the three tasks executed (the first being a check on <code>localhost</code>), two show changes.</p>
			<ol>
				<li value="5">Running the command again results in a play recap showing three OKs:<pre class="source-code">
<strong class="bold">PLAY RECAP ************************************************************************************************</strong>
<strong class="bold">localhost: ok=3    changed=0    unreachable=0    failed=0     skipped=0    rescued=0    ignored=0</strong></pre></li>
			</ol>
			<p>You may have also noticed that it just ran the first time – if you ignore installing the prerequisites.</p>
			<p>Unlike Terraform, Ansible, when executed this way, is declarative. This means that it ran the tasks in order and <a id="_idIndexMarker090"/>waited for each of them to complete before progressing to the next task in the playbook file. This means that we didn’t find ourselves in a situation where Ansible was trying to launch resources linked to other resources that don’t already exist.</p>
			<p>Another key difference between Ansible and Terraform is that Ansible is stateless – which means Ansible does not track or store the state of your resources in a file and instead looks at each resource at the time of execution.</p>
			<p>Personally, I think this is one of the critical differences between Terraform and Ansible, as I have lost count <a id="_idIndexMarker091"/>of the times that I have had to debug problems <a id="_idIndexMarker092"/>because someone or something has made a change to a resource outside of Terraform, which Terraform has then struggled to reconcile between the resources that are actually there and ones that it thinks are there.</p>
			<p>Finding yourself in this situation is dangerous territory if you don’t pay attention.</p>
			<p>You may find that the only way Terraform can get its state back to how it thinks it should be deployed is to start terminating and redeploying resources – which would cause all sorts of chaos if you were in a production environment.</p>
			<p>On the other hand, because Ansible does not keep track of the state of the resources it manages, it won’t know about a resource’s state or configuration until you execute the playbook.</p>
			<p>99% of the time, running an Ansible playbook will execute tasks that launch or update existing resources, so Ansible not keeping track of the state is not an issue – in fact, it could be a benefit as it is not trying to enforce a state it knows about.</p>
			<p>The one downside to this is that because it doesn’t know what resources are present, there is not an Ansible equivalent of the <code>terraform destroy</code> command. When you run this command in Terraform, it simply removes the resources present within the state file giving a convenient way of removing everything Terraform is managing.</p>
			<p>To get around this with Ansible, I normally provide a second playbook that sets the state of all or just some of the resources to <code>absent</code> – given the default state for most resources is <code>present</code>, this will remove the resources listed.</p>
			<p>In the example we <a id="_idIndexMarker093"/>have just covered, the playbook to remove the resources looks like the following:</p>
			<pre class="source-code">
---
- name: Ansible Infrastructure as Code example
  hosts: localhost
  tasks:
    - name: Terminate the example resource group
      azure.azcollection.azure_rm_resourcegroup:
        name: "rg-example-uks"
        location: <a id="_idTextAnchor117"/>"UK South"
  <a id="_idTextAnchor118"/>      state: absent
        force_delete_nonempty: true</pre>
			<p>You may have noticed an empty line (<code>---</code>) at the end of the code block; it is important that these are present.</p>
			<p class="callout-heading">Warning</p>
			<p class="callout">You may have noticed that we are setting the <code>force_delete_nonempty</code> flag to <code>true</code> in the preceding code snippet. Please be careful when using that flag as you will not be asked if you are sure, and this overrides the default action of failing because there are resources within the resource group.</p>
			<p>Place the preceding code in a file called <code>destroy.yml</code> and run the following command:</p>
			<pre class="source-code">
$ ansible-playbook destroy.yml</pre>
			<p>This will delete the <a id="_idIndexMarker094"/>resource group. Because the storage account is a child resource within the resource group and we have instructed Ansible to remove resource groups even if they are not empty, it will also be removed.</p>
			<p>Now that we have learned about Ansible, let’s loo<a id="_idTextAnchor119"/>k at a tool we can use to write our code.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor120"/>Introducing Visual Studio Code</h1>
			<p>The final tool I am going to introduce isn’t an IaC tool but an IDE, which is used to write the code itself.</p>
			<p>Visual Studio Code is a powerful code editor perfect for most development languages, including your IaC <a id="_idIndexMarker095"/>projects. It is feature-rich, fast, and highly customizable, making it the ideal choice no matter which of the tools you decide to go with.</p>
			<p>The best part is that Visual Studio Code is completely free and open source. Whether you’re a professional web developer, system administrator, or DevOps practitioner, Visual Studio Code has everything you need to create well-structured code.</p>
			<p>Is it something I use on a daily basis – as you can see from the following screenshot, via the use of extensions, you ge<a id="_idTextAnchor121"/><a id="_idTextAnchor122"/><a id="_idTextAnchor123"/><a id="_idTextAnchor124"/><a id="_idTextAnchor125"/>t features such as syntax highlighting:</p>
			<div><div><img src="img/Figure_2.02_B19537.jpg" alt="Figure 2.2 – Our Terraform example opened in Visual Studio Code" width="1647" height="1147"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – Our Terraform example opened in Visual Studio Code</p>
			<p>But beyond syntax highlighting, with extensions you can also get powerful features such as the following:</p>
			<ul>
				<li><strong class="bold">Inline error checking</strong>: This is where your code is checked for syntax errors and general issues, such as referencing a variable or output that does not exist, and makes you aware of them</li>
				<li><strong class="bold">Auto-complete</strong>: This functionality <a id="_idIndexMarker096"/>varies between extensions, but they can fill in details as you type, suggesting which flags/keywords and values could be used</li>
				<li><strong class="bold">Formatting</strong>: As already mentioned, formatting is really important when it comes to both HCL and YAML; there are extensions for both languages that will check your formatting as you type and auto-correct if there are problems, which should hopefully save you from having to use an online tool such as the one linked in the Ansible section</li>
				<li><strong class="bold">Version Control and continuous integration/continuous delivery (CI/CD)</strong>: There is a <a id="_idIndexMarker097"/>built-in integration with Git, as well as extensions for services such as GitHub, Azure DevOps, and other popular version control and CI/CD tools and services</li>
			</ul>
			<p>While it is not essential <a id="_idIndexMarker098"/>to use an IDE such as Visual Studio Code, I think you will miss out on a lot of functionality and troubleshooting help if you don’t.</p>
			<p>For details on where to get Visual Studio Code from as well as recommended extensions that will be helpful throughout this book, please see the <em class="italic">Further </em><em class="italic">reading</em> section.</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor126"/>Summary</h1>
			<p>In this chapter, we got a very quick feel for the approach and considerations when it comes to choosing the right IaC tool for your project.</p>
			<p>We also looked at both Terraform and Ansible and some of the small differences between the two tools before discussing Visual Studio Code, which I hope you will install and make use of.</p>
			<p>In the next chapter, which is the last chapter of <em class="italic">Part 1</em> of this book, we will look at the example project, which we will execute throughout the remainder of the book and get our teeth into both Terraform and Ansible on the two major public cloud providers.</p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor127"/>Further reading</h1>
			<p>Here are some resour<a id="_idTextAnchor128"/>ces to help you delve deeper into Terraform:</p>
			<ul>
				<li>Main website: <a href="https://www.terraform.io/">https://www.terraform.io/</a></li>
				<li>Download and install guides: <a href="https://developer.hashicorp.com/terraform/downloads">https://developer.hashicorp.com/terraform/downloads</a></li>
				<li>Azure Resource Manager provider: <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest">https://registry.terraform.io/providers/hashicorp/azurerm/latest</a></li>
			</ul>
			<p>Here are some resources to help you delve deeper into Ansible:</p>
			<ul>
				<li>Main website: <a href="https://www.ansible.com/">https://www.ansible.com/</a></li>
				<li>Download and install guides: <a href="https://docs.ansible.com/ansible/latest/installation_guide/index.html">https://docs.ansible.com/ansible/latest/installation_guide/index.html</a></li>
				<li>Azure collection: <a href="https://galaxy.ansible.com/azure/azcollection">https://galaxy.ansible.com/azure/azcollection</a></li>
			</ul>
			<p>Here are some resources to help you delve deeper into Visual Studio Code:</p>
			<ul>
				<li>Main Website: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></li>
				<li>Downloads: <a href="https://code.visualstudio.com/Download">https://code.visualstudio.com/Download</a></li>
				<li>HashiCorp Terraform extension: <a href="https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform">https://marketplace.visualstudio.com/items?itemName=HashiCorp.terraform</a></li>
				<li>Red Hat Ansible extension: <a href="https://marketplace.visualstudio.com/items?itemName=redhat.ansible">https://marketplace.visualstudio.com/items?itemName=redhat.ansible</a></li>
				<li>GitHub Repositories extension: <a href="https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub">https://marketplace.visualstudio.com/items?itemName=GitHub.remotehub</a></li>
			</ul>
		</div>
	</div>
</div>
</body></html>