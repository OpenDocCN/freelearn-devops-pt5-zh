<html><head></head><body>
		<div><h1 id="_idParaDest-74"><em class="italic"><a id="_idTextAnchor073"/>Chapter 3</em>: Configuring Jenkins</h1>
			<p>To start any continuous delivery process, we need an automation server such as Jenkins. However, configuring Jenkins can be difficult, especially when the amount of tasks assigned to it increases over time. What's more, since Docker allows the dynamic provisioning of Jenkins agents, is it worth spending time to configure everything correctly upfront, with scalability in mind?</p>
			<p>In this chapter, we'll present Jenkins, which can be used separately or together with Docker. We will show that the combination of these two tools produces surprisingly good results – automated configuration and flexible scalability.</p>
			<p>This chapter will cover the following topics:</p>
			<ul>
				<li>What is Jenkins?</li>
				<li>Installing Jenkins</li>
				<li>Jenkins – Hello World</li>
				<li>Jenkins architecture</li>
				<li>Configuring agents</li>
				<li>Custom Jenkins images</li>
				<li>Configuration and management</li>
			</ul>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/>Technical requirements</h1>
			<p>To follow along with the instructions in this chapter, you'll need the following hardware/software:</p>
			<ul>
				<li>Java 8+</li>
				<li>At least 4 GB of RAM</li>
				<li>At least 1 GB of free disk space</li>
				<li>Docker Engine installed</li>
			</ul>
			<p>All the examples and solutions to the exercises in this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter03">https://github.com/PacktPublishing/Continuous-Delivery-With-Docker-and-Jenkins-3rd-Edition/tree/main/Chapter03</a>.</p>
			<p>Code in Action videos for this chapter can be viewed at <a href="https://bit.ly/3DP02TW">https://bit.ly/3DP02TW</a>.</p>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor075"/>What is Jenkins?</h1>
			<p>Jenkins <a id="_idIndexMarker224"/>is an open source automation server written in Java. With very active community-based support and a huge number of plugins, it is one of the most popular tools for implementing continuous integration and continuous delivery processes. Formerly <a id="_idIndexMarker225"/>known as <strong class="bold">Hudson</strong>, it was renamed after Oracle bought Hudson and decided to develop it as proprietary software. Jenkins was forked from Hudson but remained open source under the MIT license. It is highly valued for its simplicity, flexibility, and versatility.</p>
			<p>Jenkins outshines other continuous integration tools and is the most widely used software of its kind. That's all possible because of its features and capabilities.</p>
			<p>Let's walk through the most interesting parts of Jenkins' characteristics:</p>
			<ul>
				<li><strong class="bold">Language-agnostic</strong>: Jenkins<a id="_idIndexMarker226"/> has a lot of plugins, which support most programming languages and frameworks. Moreover, since it can use any shell command and any software, it is suitable for every automation process imaginable.</li>
				<li><strong class="bold">Extensible by plugins</strong>: Jenkins has a great community and a lot of available plugins (over a thousand). It also allows you to write your own plugins in order to customize Jenkins for your needs.</li>
				<li><strong class="bold">Portable</strong>: Jenkins is written in Java, so it can be run on any operating system. For convenience, it is also delivered in a lot of <a id="_idIndexMarker227"/>versions – <strong class="bold">Web Application Archive</strong> (<strong class="bold">WAR</strong>) files, Docker images, Helm charts, Kubernetes operators, Windows binaries, macOS binaries, and Linux binaries.</li>
				<li><strong class="bold">Supports most Source Control Management (SCM) tools</strong>: Jenkins integrates with virtually every source code management or build tool that exists. Again, because of its large community and number of plugins, there is no other continuous integration tool that supports so many external systems.</li>
				<li><strong class="bold">Distributed</strong>: Jenkins has <a id="_idIndexMarker228"/>a built-in mechanism for the master/agent mode, which distributes its execution across multiple nodes, located on multiple machines. It can also use heterogeneous environments; for example, different nodes can have different operating systems installed.</li>
				<li><strong class="bold">Simplicity</strong>: The installation and configuration process is simple. There is no need to configure any additional software or the database. It can be configured completely through a GUI, XML, or Groovy scripts.</li>
				<li><strong class="bold">Code-oriented</strong>: Jenkins pipelines are defined as code. Also, Jenkins itself can be configured using YAML/XML files or Groovy scripts. That allows you to keep the configuration in the <a id="_idIndexMarker229"/>source code repository and helps in the automation of the Jenkins configuration.</li>
			</ul>
			<p>Now that you have a basic understanding of Jenkins, let's move on to installing it.</p>
			<h1 id="_idParaDest-77"><a id="_idTextAnchor076"/>Installing Jenkins</h1>
			<p>There are different methods of installing Jenkins, and you should choose the one that best suits your needs. Let's walk through all the options you have and then describe the most common choices in detail:</p>
			<ul>
				<li><strong class="bold">Servlet</strong>: Jenkins<a id="_idIndexMarker230"/> is written in Java and natively distributed as a web application in the WAR format, dedicated to running inside an application server (such as Apache Tomcat or GlassFish); consider this option if you deploy all your applications as servlets.</li>
				<li><strong class="bold">Application</strong>: The <a id="_idIndexMarker231"/>Jenkins WAR file embeds the Jetty application server, so it can be directly run with the Java command, and therefore, the <strong class="bold">Java Runtime Environment</strong> (<strong class="bold">JRE</strong>) is the only requirement to start<a id="_idIndexMarker232"/> Jenkins; consider this option if you use bare-metal servers and/or you need to install multiple Jenkins instances on one machine.</li>
				<li><strong class="bold">Dedicated package</strong>: Jenkins<a id="_idIndexMarker233"/> is distributed for most operating systems in a form of dedicated packages (MSI for Windows, the Homebrew package for macOS, the deb package for Debian/Ubuntu, and so on); consider this option for the simplest installation and configuration if you use bare-metal servers.</li>
				<li><strong class="bold">Docker</strong>: Jenkins is<a id="_idIndexMarker234"/> distributed in a form of a Docker image, and so the only requirement is to have Docker installed; consider this option for the simplest installation if you use Docker in your ecosystem.</li>
				<li><strong class="bold">Kubernetes</strong>: Jenkins<a id="_idIndexMarker235"/> provides a Helm chart and a Kubernetes operator to simplify its installation, management, and scaling in a Kubernetes cluster; consider this option for the simplest Jenkins scaling and management.</li>
				<li><strong class="bold">Cloud</strong>: Jenkins is<a id="_idIndexMarker236"/> hosted in a form of <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>) by a <a id="_idIndexMarker237"/>number of platforms; consider this option if you don't want to think about server maintenance and Jenkins installation.</li>
			</ul>
			<p>Each installation method has its own pros and cons. Let's describe the most common approaches, starting from using a Jenkins Docker image.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">You can find a <a id="_idIndexMarker238"/>detailed description of each installation method at <a href="https://www.jenkins.io/doc/book/installing/">https://www.jenkins.io/doc/book/installing/</a>.</p>
			<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/>Installing Jenkins with Docker</h2>
			<p>The Jenkins<a id="_idIndexMarker239"/> image is available in the Docker Hub registry, so in order <a id="_idIndexMarker240"/>to install its latest version, we should execute the following command:</p>
			<pre>$ docker run -p &lt;host_port&gt;:8080 -v &lt;host_volume&gt;:/var/jenkins_home jenkins/jenkins</pre>
			<p>We need to specify the following parameters:</p>
			<ul>
				<li>The first <code>host_port</code> parameter: The port on which Jenkins is visible outside of the container.</li>
				<li>A second <code>host_volume</code> parameter: This specifies the directory where the Jenkins home is mapped. It needs to be specified as volume; therefore, it is persisted permanently because it contains the configuration, pipeline builds, and logs.</li>
			</ul>
			<p>As an example, let's <a id="_idIndexMarker241"/>follow the installation steps:</p>
			<ol>
				<li><strong class="bold">Prepare the volume directory</strong>: We <a id="_idIndexMarker242"/>need a separate directory to keep the Jenkins data. Let's prepare one with the following commands:<pre><strong class="bold">$ mkdir $HOME/jenkins_home</strong></pre></li>
				<li><strong class="bold">Run the Jenkins container</strong>: Let's run the container as a daemon and give it a proper name with the following command:<pre><strong class="bold">$ docker run -d -p 8080:8080 \</strong>
<strong class="bold">  -v $HOME/jenkins_home:/var/jenkins_home \ </strong>
<strong class="bold">  --name jenkins jenkins/jenkins</strong></pre></li>
				<li><strong class="bold">Check whether Jenkins is running</strong>: After a moment, we can check whether Jenkins has started correctly by printing the logs:<pre><strong class="bold">$ docker logs jenkins</strong>
<strong class="bold">Running from: /usr/share/jenkins/jenkins.war</strong>
<strong class="bold">webroot: EnvVars.masterEnvVars.get("JENKINS_HOME")</strong>
<strong class="bold">...</strong></pre><p class="callout-heading">Information</p><p class="callout">In the production environment, you may also want to set up some additional parameters; for details, please refer to <a href="https://www.jenkins.io/doc/book/installing/docker/">https://www.jenkins.io/doc/book/installing/docker/</a>.</p></li>
			</ol>
			<p>After performing these steps, you can access your Jenkins instance at <code>http://localhost:8080/</code>.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>Installing Jenkins with dedicated packages</h2>
			<p>If you don't use <a id="_idIndexMarker243"/>Docker on your servers, then the <a id="_idIndexMarker244"/>simplest way is to use dedicated packages. Jenkins supports most operating systems – for example, MSI for Windows, the Homebrew package for macOS, and the deb package for Debian/Ubuntu.</p>
			<p>As an example, in the case of Ubuntu, it's enough to run the following commands to install Jenkins (and the required Java dependency):</p>
			<pre>$ sudo apt-get update
$ sudo apt-get -y install default-jdk
$ wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add –
$ sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'
$ sudo apt-get update
$ sudo apt-get -y install jenkins</pre>
			<p>After successful installation, the Jenkins instance is accessible via <code>http://localhost:8080/</code>.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>Initial configuration</h2>
			<p>No matter which installation <a id="_idIndexMarker245"/>you choose, starting Jenkins requires a few <a id="_idIndexMarker246"/>configuration steps. Let's walk through them step by step:</p>
			<ol>
				<li value="1">Open Jenkins in the browser, at <code>http://localhost:8080</code>.</li>
				<li>Jenkins will ask for the administrator password. It can be found in the Jenkins logs:<pre>$ docker logs jenkins
...
Jenkins initial setup is required. An admin user has been 
created 
and a password generated.
Please use the following password to proceed to installation:
c50508effc6843a1a7b06f6491ed0ca6
...</pre></li>
				<li>After accepting the<a id="_idIndexMarker247"/> initial password, Jenkins asks whether to install <a id="_idIndexMarker248"/>the suggested plugins, which are adjusted for the most common use cases. Your answer depends on your needs, of course. However, as the first Jenkins installation, it's reasonable to let Jenkins install all the recommended plugins.</li>
				<li>After the plugin installation, Jenkins asks you to set up a username, password, and other basic information. If you skip it, the token from <em class="italic">step 2</em> will be used as the admin password.</li>
			</ol>
			<p>The installation is then complete, and you should see the <strong class="bold">Jenkins</strong> dashboard:</p>
			<div><div><img src="img/B18223_03_01.jpg" alt="Figure 3.1 – A successful Jenkins installation&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – A successful Jenkins installation</p>
			<p>Now, let's see how to install Jenkins if your deployment environment is a Kubernetes cluster.</p>
			<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/>Installing Jenkins in Kubernetes</h2>
			<p>There are two <a id="_idIndexMarker249"/>methods of installing Jenkins in Kubernetes – a<a id="_idIndexMarker250"/> Helm chart and a Kubernetes operator. Let's look at the simpler option and use the Helm tool.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">For more details about the Helm tool<a id="_idIndexMarker251"/> and its installation procedure, please visit <a href="https://helm.sh/">https://helm.sh/</a>.</p>
			<p>Use the following commands to install Jenkins:</p>
			<pre>$ helm repo add jenkinsci https://charts.jenkins.io
$ helm repo update
$ helm install jenkins jenkinsci/jenkins</pre>
			<p>After executing the preceding commands, Jenkins is installed. You can check its logs with the following command:</p>
			<pre>$ kubectl logs sts/jenkins jenkins
Running from: /usr/share/jenkins/jenkins.war
...</pre>
			<p>By default, the Jenkins instance is configured with one admin account, secured with the randomly generated password. To check this password, execute the following command:</p>
			<pre>$ kubectl get secret jenkins -o jsonpath="{.data.jenkins-admin-password}" | base64 --decode
nn1Pvq7asHPYz7EUHhc4PH</pre>
			<p>Now, you'll be able to log in to Jenkins with the following credentials:</p>
			<ul>
				<li><code>admin</code></li>
				<li><code>nn1Pvq7asHPYz7EUHhc4PH</code></li>
			</ul>
			<p>By default, Jenkins<a id="_idIndexMarker252"/> is not exposed outside the Kubernetes cluster. To<a id="_idIndexMarker253"/> make it accessible from your local machine, run the following command:</p>
			<pre>$ kubectl port-forward sts/jenkins 8080:8080</pre>
			<p>After this, you can open your browser at <code>http://localhost:8080/</code> and log in with the aforementioned credentials.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Please visit <a href="https://www.jenkins.io/doc/book/installing/kubernetes/">https://www.jenkins.io/doc/book/installing/kubernetes/</a> for more information about installing Jenkins in Kubernetes.</p>
			<p>One of the biggest benefits of installing Jenkins in the Kubernetes cluster instead of a single machine is that it provides horizontal scaling out of the box. Jenkins agents are automatically provisioned using Jenkins' Kubernetes plugin.</p>
			<p>We will cover scaling Jenkins in the <em class="italic">Jenkins architecture</em> section and more about Kubernetes in <a href="B18223_06_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 6</em></a>, <em class="italic">Clustering with Kubernetes</em>. Now, let's see how you can use Jenkins in the cloud.</p>
			<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/>Jenkins in the cloud</h2>
			<p>If you don't want to <a id="_idIndexMarker254"/>install Jenkins yourself, there are companies that offer Jenkins hosted in the cloud. Note, however, that Jenkins was never built with a cloud-first approach in mind, so most offerings are, in fact, generic cloud solutions that help in installing and managing the Jenkins application for you.</p>
			<p>The solution I recommend is Google Cloud Marketplace, which automatically deploys Jenkins in Google Kubernetes Engine. Read more at <a href="https://cloud.google.com/jenkins">https://cloud.google.com/jenkins</a>. Other companies that offer hosted Jenkins include Kamatera and Servana.</p>
			<p>When we finally have Jenkins up and running, we are ready to create our first Jenkins pipeline.</p>
			<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/>Jenkins – Hello World</h1>
			<p>Everything in the entire IT world starts <a id="_idIndexMarker255"/>with the <code>Hello World</code> example, to <a id="_idIndexMarker256"/>show that the basics work fine. Let's follow this rule and use it to create the first Jenkins pipeline:</p>
			<ol>
				<li value="1">Click on <strong class="bold">New Item</strong>:</li>
			</ol>
			<div><div><img src="img/B18223_03_02.jpg" alt="Figure 3.2 – New Item in the Jenkins web interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – New Item in the Jenkins web interface</p>
			<ol>
				<li value="2">Enter <code>hello world</code> as the item name, choose <strong class="bold">Pipeline</strong>, and click on <strong class="bold">OK</strong>:</li>
			</ol>
			<div><div><img src="img/B18223_03_03.jpg" alt="Figure 3.3 – A new pipeline in the Jenkins web interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – A new pipeline in the Jenkins web interface</p>
			<ol>
				<li value="3">There are <a id="_idIndexMarker257"/>a lot of options. We will skip them for now and<a id="_idIndexMarker258"/> go directly to the <strong class="bold">Pipeline</strong> section:</li>
			</ol>
			<div><div><img src="img/B18223_03_04.jpg" alt="Figure 3.4 – Pipeline script in the Jenkins web interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Pipeline script in the Jenkins web interface</p>
			<ol>
				<li value="4">Then, in<a id="_idIndexMarker259"/> the <strong class="bold">Script</strong> textbox, we can enter the pipeline<a id="_idIndexMarker260"/> script:<pre>pipeline {
     agent any
     stages {
          stage("Hello") {
               steps {
                    echo 'Hello World'
               }
          }
     }
}</pre></li>
				<li>Click on <strong class="bold">Save</strong>.</li>
				<li>Click on <strong class="bold">Build Now</strong>:</li>
			</ol>
			<div><div><img src="img/B18223_03_05.jpg" alt="Figure 3.5 – Build Now in the Jenkins web interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Build Now in the Jenkins web interface</p>
			<p>We should <a id="_idIndexMarker261"/>see <strong class="bold">#1</strong> under <strong class="bold">Build History</strong>. If we click on it, and then <a id="_idIndexMarker262"/>on <strong class="bold">Console Output</strong>, we will see the log from the pipeline build:</p>
			<div><div><img src="img/B18223_03_06.jpg" alt="Figure 3.6 – Console Output in the Jenkins web interface&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Console Output in the Jenkins web interface</p>
			<p>The successful output in this first example means that Jenkins is installed correctly. Now, let's look at the possible Jenkins architecture.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">We will describe more about the pipeline syntax in <a href="B18223_04_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 4</em></a>, <em class="italic">Continuous Integration Pipeline</em>.</p>
			<h1 id="_idParaDest-84"><a id="_idTextAnchor083"/>Jenkins architecture</h1>
			<p>Hello World is executed in almost<a id="_idIndexMarker263"/> no time at all. However, the pipelines are usually more complex, and time is spent on tasks such as downloading files from the internet, compiling source code, or running tests. One build can take from minutes to hours.</p>
			<p>In common scenarios, there are also many concurrent pipelines. Usually, a whole team, or even a whole organization, uses the same Jenkins instance. <em class="italic">How can we ensure that the builds will run quickly and smoothly?</em></p>
			<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/>Master and agents</h2>
			<p>Jenkins becomes overloaded sooner than it seems. Even in the case of a small (micro) service, the build can take a few minutes. That means that one team committing frequently can easily kill the Jenkins instance.</p>
			<p>For that reason, unless the project <a id="_idIndexMarker264"/>is really small, Jenkins should not execute builds at all but delegate them to the agent (slave) instances. To be precise, the Jenkins server we're currently running is called the <strong class="bold">Jenkins master</strong>, and it can delegate execution tasks<a id="_idIndexMarker265"/> to <strong class="bold">Jenkins agents</strong>.</p>
			<p>Let's look at a diagram<a id="_idIndexMarker266"/> presenting the master-agent interaction:</p>
			<div><div><img src="img/B18223_03_07.jpg" alt="Figure 3.7 – The Jenkins master-agent interaction&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – The Jenkins master-agent interaction</p>
			<p>In a distributed build <a id="_idIndexMarker267"/>environment, the Jenkins master is responsible for the following:</p>
			<ul>
				<li>Receiving build triggers (for example, after a commit to GitHub)</li>
				<li>Sending notifications (for example, email or Slack messages sent after a build failure)</li>
				<li>Handling HTTP requests (interaction with clients)</li>
				<li>Managing the build environment (orchestrating the job executions on agents)</li>
			</ul>
			<p>The build agent is a machine that takes care of everything that happens after the build has started.</p>
			<p>Since the responsibilities of the master and the agents are different, they have different environmental requirements:</p>
			<ul>
				<li><strong class="bold">Master</strong>: This is<a id="_idIndexMarker268"/> usually (unless the project is really small) a dedicated machine with RAM ranging from 200 MB for small projects to 70+ GB for huge single-master projects.</li>
				<li><strong class="bold">Agent</strong>: There are no <a id="_idIndexMarker269"/>general requirements (other than the fact that it should be capable of executing a single build; for example, if the project is a huge monolith that requires 100 GB of RAM, then the agent machine needs to satisfy these needs).</li>
			</ul>
			<p>Agents should also be as generic as possible. For instance, if we have different projects – one in Java, one in Python, and one in Ruby – then it would be perfect if each agent could build any of these projects. In such a case, the agents can be interchanged, which helps to optimize the usage of resources.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If agents cannot be generic enough to match all projects, then it's possible to label (tag) agents and projects so that the given build will be executed on a given type of agent.</p>
			<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/>Scalability</h2>
			<p>As with everything in the <a id="_idIndexMarker270"/>software world, with growing usage, a Jenkins instance can quickly become overloaded and unresponsive. That is why we need to think upfront about scaling it up. There are two possible methods – <strong class="bold">vertical scaling</strong> and <strong class="bold">horizontal scaling</strong>.</p>
			<h3>Vertical scaling</h3>
			<p>Vertical scaling means <a id="_idIndexMarker271"/>that when the master's load grows, more resources are applied to the master's machine. So, when new projects appear in our organization, we buy more RAM, add CPU cores, and extend the HDD drives. This may sound like a no-go solution; however, it is used often, even by well-known organizations. Having a single Jenkins master set on ultra-efficient hardware has one very strong advantage – maintenance. Any upgrades, scripts, security settings, role assignments, or plugin installations have to be done in one place only.</p>
			<h3>Horizontal scaling</h3>
			<p>Horizontal scaling means that when an organization grows, more master instances are launched. This requires a smart allocation of instances to teams, and in extreme cases, each team can have its own <a id="_idIndexMarker272"/>Jenkins master. In that case, it might even happen that no agents are needed.</p>
			<p>The drawbacks are that it may be difficult to automate cross-project integrations and that a part of the team's development time is spent on the maintenance of Jenkins. However, horizontal scaling has some significant advantages:</p>
			<ul>
				<li>Master machines don't need to be special, in terms of hardware.</li>
				<li>Different teams can have different Jenkins settings (for example, different sets of plugins).</li>
				<li>Teams usually feel better and work with Jenkins more efficiently if the instance is their own.</li>
				<li>If one master instance is down, it does not impact the whole organization.</li>
				<li>The infrastructure can be segregated into standard and mission-critical.</li>
			</ul>
			<h2 id="_idParaDest-87"><a id="_idTextAnchor086"/>Test and production instances</h2>
			<p>Apart from the scaling approach, there is one more issue – <em class="italic">how to test the Jenkins upgrades, new plugins, or pipeline definitions.</em> Jenkins is critical to the whole company. It guarantees the quality of the software and, in the case of continuous delivery, deploys to the <a id="_idIndexMarker273"/>production servers. That is why it needs to be highly available, and it is definitely not for the purpose of testing. It means there should always be two<a id="_idIndexMarker274"/> instances of the same Jenkins infrastructure – <strong class="bold">test</strong> and <strong class="bold">production</strong>.</p>
			<h2 id="_idParaDest-88"><a id="_idTextAnchor087"/>Sample architecture</h2>
			<p>We already know that <a id="_idIndexMarker275"/>there should be agents and (possibly multiple) masters and that everything should be duplicated in the test and production environments. However, <em class="italic">what would the complete picture look like?</em></p>
			<p>Luckily, there are a lot of companies that have published how they used Jenkins and what kind of architectures they created. It would be difficult to measure whether more of them preferred vertical or horizontal scaling, but it ranged from having only one master instance to having one master for each team.</p>
			<p>Let's look at the<a id="_idIndexMarker276"/> example of Netflix to get a picture of a complete Jenkins infrastructure (Netflix shared it as a <strong class="bold">planned infrastructure</strong> at the Jenkins User Conference in San Francisco in 2012):</p>
			<div><div><img src="img/B18223_03_08.jpg" alt="Figure 3.8 – The Jenkins infrastructure from Netflix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – The Jenkins infrastructure from Netflix</p>
			<p>They have test and production master instances, with each of them owning a pool of agents and additional ad hoc agents. Altogether, it serves around 2,000 builds per day. Also, note that a part of their infrastructure is hosted on AWS and another part is on their own servers.</p>
			<p>You should already have a rough idea of what the Jenkins infrastructure can look like, depending on the type of organization.</p>
			<p>Now, let's focus on the practical aspects of setting the agents.</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Configuring agents</h1>
			<p>You've seen what the agents<a id="_idIndexMarker277"/> are and when they can be used. However, <em class="italic">how do we set up an agent and let it communicate with the master?</em> Let's start with the second part of the question and describe the communication protocols between the master and the agent.</p>
			<h2 id="_idParaDest-90"><a id="_idTextAnchor089"/>Communication protocols</h2>
			<p>In order for the master and the agent to communicate, a bidirectional connection has to be established.</p>
			<p>There are different<a id="_idIndexMarker278"/> options for how it can be initiated:</p>
			<ul>
				<li><strong class="bold">SSH</strong>: The master connects to the agent using the standard SSH protocol. Jenkins has an SSH client<a id="_idIndexMarker279"/> built in, so the only requirement is the <strong class="bold">SSH daemon</strong> (<strong class="bold">sshd</strong>) server configured on the agents. This is the most convenient and stable method because it uses standard Unix mechanisms.</li>
				<li><strong class="bold">Java web start</strong>: A<a id="_idIndexMarker280"/> Java application is started on each agent machine, and the TCP connection is established between the Jenkins agent application and the master Java application. This method is often used if the agents are inside the firewalled network and the master cannot initiate the connection.</li>
			</ul>
			<p>Once we know the communication protocols, let's look at how we can use them to set the agents.</p>
			<h2 id="_idParaDest-91"><a id="_idTextAnchor090"/>Setting agents</h2>
			<p>At a low level, agents<a id="_idIndexMarker281"/> always communicate with the Jenkins master using one of the protocols described previously. However, at a higher level, we can attach agents to the master in various ways. The differences concern two aspects:</p>
			<ul>
				<li><strong class="bold">Static versus dynamic</strong>: The simplest option is to add agents permanently in the Jenkins master. The drawback of such a solution is that we always need to manually change something if we need more (or fewer) agent nodes. A better option is to dynamically provision agents as they are needed.</li>
				<li><strong class="bold">Specific versus general-purpose</strong>: Agents can be specific (for example, different agents for the projects based on Java 8 and Java 11) or general-purpose (an agent acts as a Docker host and a pipeline is built inside a Docker container).</li>
			</ul>
			<p>These differences <a id="_idIndexMarker282"/>resulted in four common strategies for how agents are configured:</p>
			<ul>
				<li>Permanent agents</li>
				<li>Permanent Docker host agents</li>
				<li>Jenkins Swarm agents</li>
				<li>Dynamically provisioned Docker agents</li>
				<li>Dynamically provisioned Kubernetes agents</li>
			</ul>
			<p>Let's examine each of the solutions.</p>
			<h3>Permanent agents</h3>
			<p>We will start with <a id="_idIndexMarker283"/>the simplest option, which is to permanently add specific agent nodes. It can be done entirely via the Jenkins web interface.</p>
			<h4>Configuring permanent agents</h4>
			<p>In the Jenkins<a id="_idIndexMarker284"/> master, when we open <strong class="bold">Manage Jenkins</strong> and then <strong class="bold">Manage Nodes and Clouds</strong>, we can view all the attached agents. Then, by clicking on <strong class="bold">New Node</strong>, giving it a name, setting its type to <strong class="bold">Permanent Agent</strong>, and confirming with the <strong class="bold">Create</strong> button, we should finally see the agent's setup page:</p>
			<div><div><img src="img/B18223_03_09.jpg" alt="Figure 3.9 – Permanent agent configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – Permanent agent configuration</p>
			<p>Let's walk through the<a id="_idIndexMarker285"/> parameters we need to fill in:</p>
			<ul>
				<li><strong class="bold">Name</strong>: This is the unique name of the agent.</li>
				<li><strong class="bold">Description</strong>: This is a human-readable description of the agent.</li>
				<li><strong class="bold">Number of executors</strong>: This is the number of concurrent builds that can be run on the agent.</li>
				<li><code>/var/jenkins</code>); the most important data is transferred back to the master, so the directory is not critical.</li>
				<li><strong class="bold">Labels</strong>: This includes the tags to match the specific builds (tagged the same) – for example, only projects based on Java 8.</li>
				<li><strong class="bold">Usage</strong>: This is the option to decide whether the agent should only be used for matched labels (for example, only for acceptance testing builds), or for any builds.</li>
				<li><code>ssh &lt;agent_hostname&gt; java -jar ~/bin/slave.jar</code>).</li><li><strong class="bold">Launch agents via SSH</strong>: Here, the master will connect to the agent using the SSH protocol.</li></ul></li>
				<li><code>50000</code> for communication with the Jenkins master; therefore, if you use the Docker-based Jenkins master, you need to publish that port (<code>-p 50000:50000</code>).</p></li>
			</ul>
			<p>When the agents are set up correctly, it's possible to update the master built-in node configuration with <code>0</code> so that no builds will be executed on it, and it will only serve as the <a id="_idIndexMarker287"/>Jenkins UI and the build's coordinator.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">For more details and step-by-step instructions on how to configure permanent Jenkins agents, visit <a href="https://www.jenkins.io/doc/book/using/using-agents/">https://www.jenkins.io/doc/book/using/using-agents/</a>.</p>
			<h4>Understanding permanent agents</h4>
			<p>As we've already <a id="_idIndexMarker288"/>mentioned, the drawback of such a solution is that we need to maintain multiple agent types (labels) for different project types. Such a situation is presented in the following diagram:</p>
			<div><div><img src="img/B18223_03_10.jpg" alt="Figure 3.10 – Permanent agents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – Permanent agents</p>
			<p>In our example, if we have three types of projects (<strong class="bold">java7</strong>, <strong class="bold">java8</strong>, and <strong class="bold">ruby</strong>), then we need to maintain three separately labeled (sets of) agents. That is the same issue we had while maintaining multiple production server types, as described in <a href="B18223_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing Docker</em>. We addressed the issue by having Docker Engine installed on the production servers. Let's try to do the same with Jenkins agents.</p>
			<h3>Permanent Docker host agents</h3>
			<p>The idea <a id="_idIndexMarker289"/>behind this solution is to permanently add general-purpose agents. Each agent is identically configured (with Docker Engine installed), and each build is defined along with the Docker image, inside of which the build is run.</p>
			<h4>Configuring permanent Docker host agents</h4>
			<p>The <a id="_idIndexMarker290"/>configuration is static, so it's done exactly the same way as we did with the permanent agents. The only difference is that we need to install Docker on each machine that will be used as an agent. Then, we usually don't need labels because all the agents can be the same. After the agents are configured, we define the Docker image in each pipeline script:</p>
			<pre>pipeline {
     agent {
          docker {
               image 'openjdk:8-jdk-alpine'
          }
     }
     ...
}</pre>
			<p>When the build is started, the Jenkins agent starts a container from the Docker image, <code>openjdk:8-jdk-alpine</code>, and then executes all the pipeline steps inside that container. This way, we always know the execution environment and don't have to configure each agent separately, depending on the particular project type.</p>
			<h4>Understanding permanent Docker host agents</h4>
			<p>Looking at the <a id="_idIndexMarker291"/>same scenario we used for the permanent agents, the diagram looks like this:</p>
			<div><div><img src="img/B18223_03_11.jpg" alt="Figure 3.11 – Permanent Docker host agents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Permanent Docker host agents</p>
			<p>Each agent is exactly the same, and if we want to build a project that depends on Java 8, then we would <a id="_idIndexMarker292"/>define the appropriate Docker image in the pipeline script (instead of specifying the agent label).</p>
			<h3>Jenkins Swarm agents</h3>
			<p>So far, we have always had to <a id="_idIndexMarker293"/>permanently define each of the agents in the Jenkins master. Such a solution, although good enough in many cases, can be a burden if we need to frequently scale the number of agent machines. Jenkins Swarm allows you to dynamically add agents without the need to configure them in the Jenkins master.</p>
			<h4>Configuring Jenkins Swarm agents</h4>
			<p>The first step to<a id="_idIndexMarker294"/> using Jenkins Swarm is to install the <strong class="bold">Swarm</strong> plugin in Jenkins. We can do it through the Jenkins web UI, under <strong class="bold">Manage Jenkins</strong> and <strong class="bold">Manage Plugins</strong>. After this step, the Jenkins master is prepared for Jenkins agents to be dynamically attached.</p>
			<p>The second step is to run the Jenkins Swarm agent application on every machine that will act as a Jenkins agent. We can do it using the <code>swarm-client.jar</code> application.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">The <code>swarm-client.jar</code> application<a id="_idIndexMarker295"/> can be downloaded from the Jenkins Swarm plugin page at <a href="https://plugins.jenkins.io/swarm/">https://plugins.jenkins.io/swarm/</a>. On that page, you can also find all the possible options for its execution.</p>
			<p>To attach the Jenkins Swarm agent node, run the following command:</p>
			<pre>$ java -jar path/to/swarm-client.jar -url ${JENKINS_URL} -username ${USERNAME}</pre>
			<p>After successful<a id="_idIndexMarker296"/> execution, we should notice that a new agent has appeared on the Jenkins master, and when we run a build, it will be started on this agent.</p>
			<h4>Understanding Jenkins Swarm agents</h4>
			<p>Let's look at the <a id="_idIndexMarker297"/>following diagram that presents the Jenkins Swarm configuration:</p>
			<div><div><img src="img/B18223_03_12.jpg" alt="Figure 3.12 – Jenkins Swarm agents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Jenkins Swarm agents</p>
			<p>Jenkins Swarm allows you to dynamically add agents, but it says nothing about whether to use specific or Docker-based agents, so we can use it for both. At first glance, Jenkins Swarm may not seem very useful. After all, we have moved setting agents from the master to the agent, but we still have to do it manually. However, with the use of a clustering system such as Kubernetes or Docker Swarm, Jenkins Swarm apparently enables the dynamic scaling of agents on a cluster of servers.</p>
			<h3>Dynamically provisioned Docker agents</h3>
			<p>Another option is to <a id="_idIndexMarker298"/>set up Jenkins to dynamically create a new agent each time a build is started. Such a solution is obviously the most flexible one, since the number of agents dynamically adjusts to the number of builds. Let's take a look at how to configure Jenkins this way.</p>
			<h4>Configuring dynamically provisioned Docker agents</h4>
			<p>First, we need to <a id="_idIndexMarker299"/>install the <strong class="bold">Docker</strong> plugin. As always, with Jenkins plugins, we can do this in <strong class="bold">Manage Jenkins</strong> and <strong class="bold">Manage Plugins</strong>. After the plugin is installed, we can start the following configuration steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Manage Jenkins</strong> page.</li>
				<li>Click on the <strong class="bold">Manage Nodes and Clouds</strong> link.</li>
				<li>Click on the <strong class="bold">Configure Clouds</strong> link.</li>
				<li>Click on <strong class="bold">Add a new cloud</strong> and choose <strong class="bold">Docker</strong>.</li>
				<li>Fill in the Docker agent details, as shown in the following screenshot:</li>
			</ol>
			<div><div><img src="img/B18223_03_13.jpg" alt="Figure 3.13 – Docker agent configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – Docker agent configuration</p>
			<ol>
				<li value="6">Most <a id="_idIndexMarker300"/>parameters do not need to be changed; however (apart from selecting <code>docker0</code> network interface. You can do it in a similar way as to what's described in the <em class="italic">Installing on a server</em> section in <a href="B18223_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing Docker</em>, by changing one line in the <code>/lib/systemd/system/docker.service</code> file to <code>ExecStart=/usr/bin/dockerd -H 0.0.0.0:2375 -H fd://</code>.</p></li>
				<li>Click on <strong class="bold">Docker Agent templates...</strong> and select <strong class="bold">Add Docker Template</strong>.</li>
				<li>Fill in the details about the Docker agent image:</li>
			</ol>
			<div><div><img src="img/B18223_03_14.jpg" alt="Figure 3.14 – Docker Agent templates configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Docker Agent templates configuration</p>
			<p>We can use the <a id="_idIndexMarker301"/>following parameters:</p>
			<ul>
				<li><code>jenkins/agent</code> (used for the default connect method, which is <strong class="bold">Attach Docker container</strong>).</li>
				<li><code>10</code>.<p class="callout-heading">Information</p><p class="callout">Instead of <code>jenkins/agent</code>, it's possible to build and use your own agent images. This may be helpful in the case of specific environment requirements – for example, you need Golang installed. Note also that for other agent connect methods (<code>jenkins/ssh-agent</code> or <code>jenkins/inbound-agent</code>). For details, please check <a href="https://plugins.jenkins.io/docker-plugin/">https://plugins.jenkins.io/docker-plugin/</a>.</p></li>
			</ul>
			<p>After saving, everything <a id="_idIndexMarker302"/>will be set up. We can run the pipeline to observe that the execution really takes place on the Docker agent, but first, let's dig a little deeper in order to understand how the Docker agents work.</p>
			<h4>Understanding dynamically provisioned Docker agents</h4>
			<p>Dynamically provisioned<a id="_idIndexMarker303"/> Docker agents can be treated as a layer over the standard agent mechanism. It changes neither the communication protocol nor how the agent is created. So, <em class="italic">what does Jenkins do with the Docker agent configuration we provided?</em></p>
			<p>The following diagram presents the Docker master-agent architecture we've configured:</p>
			<div><div><img src="img/B18223_03_15.jpg" alt="Figure 3.15 – Dynamically provisioned Docker agents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Dynamically provisioned Docker agents</p>
			<p>Let's describe how the Docker agent mechanism is used, step by step:</p>
			<ol>
				<li value="1">When the Jenkins job is started, the master runs a new container from the <code>jenkins/agent</code> image on the agent Docker host.</li>
				<li>The <code>jenkins/agent</code> container starts the Jenkins agent and attaches it to the Jenkins master's nodes pool.</li>
				<li>Jenkins executes the pipeline inside the <code>jenkins/agent</code> container.</li>
				<li>After the build, the master stops and removes the agent container.<p class="callout-heading">Information</p><p class="callout">Running the Jenkins master as a Docker container is independent of running Jenkins agents as Docker containers. It's reasonable to do both, but any of them will work separately.</p></li>
			</ol>
			<p>The solution is <a id="_idIndexMarker304"/>somehow similar to the permanent Docker agent solution because, as a result, we run the build inside a Docker container. The difference, however, is in the agent node configuration. Here, the whole agent is dockerized – not only the build environment.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">The Jenkins build usually needs to download a lot of project dependencies (for example, Gradle/Maven dependencies), which may take a lot of time. If Docker agents are automatically provisioned for each build, then it may be worthwhile to set up a Docker volume for them to enable caching between the builds.</p>
			<h3>Dynamically provisioned Kubernetes agents</h3>
			<p>We can dynamically<a id="_idIndexMarker305"/> provision agents on Kubernetes similar to how we did with the Docker host. The benefit of such an approach is that Kubernetes is a cluster of multiple physical machines that can easily scale up or down, according to needs.</p>
			<h4>Configuring dynamically provisioned Kubernetes agents</h4>
			<p>Firstly, we need to <a id="_idIndexMarker306"/>install the <strong class="bold">Kubernetes</strong> plugin. Then, we can follow the same steps when we installed the Docker agents. The difference starts when we click on <strong class="bold">Add a new cloud</strong>. This time, we need to select <strong class="bold">Kubernetes</strong> instead of <strong class="bold">Docker</strong> and fill in all the details about the Kubernetes cluster:</p>
			<div><div><img src="img/B18223_03_16.jpg" alt="Figure 3.16 – Kubernetes agent configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Kubernetes agent configuration</p>
			<p>You need to<a id="_idIndexMarker307"/> fill in <strong class="bold">Kubernetes URL</strong>, which is the address of your Kubernetes cluster. Usually, you will also need to enter the credentials of your Kubernetes cluster. Then, you must click on <strong class="bold">Add Pod Template</strong> and fill in <strong class="bold">Pod Template</strong> analogously to what you did for <strong class="bold">Docker Template</strong> in the case of the <strong class="bold">Docker</strong> plugin.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">For more detailed instructions on how to set <a id="_idIndexMarker308"/>up the Jenkins Kubernetes plugin, visit <a href="https://plugins.jenkins.io/kubernetes/">https://plugins.jenkins.io/kubernetes/</a>.</p>
			<p>After successful<a id="_idIndexMarker309"/> configuration, when you start a new build, Jenkins automatically provisions a new agent in Kubernetes and uses it for the pipeline execution.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">If you install Jenkins in Kubernetes using Helm, as described at the beginning of this chapter, it is automatically configured with the Kubernetes plugin and automatically provisions Jenkins agents in the same Kubernetes cluster where the Jenkins master is deployed. This way, with one Helm command, we install a fully functional and scalable Jenkins ecosystem!</p>
			<h4>Understanding dynamically provisioned Kubernetes agents</h4>
			<p>Dynamically provisioning an <a id="_idIndexMarker310"/>agent in Kubernetes works very similarly to provisioning an agent in the Docker host. The difference is that now we interact with a cluster of machines, not just a single Docker host. This approach is presented in the following diagram:</p>
			<div><div><img src="img/B18223_03_17.jpg" alt="Figure 3.17 – Dynamically provisioned Kubernetes agents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – Dynamically provisioned Kubernetes agents</p>
			<p>Kubernetes nodes can be dynamically added and removed, which makes the whole master-agent architecture very flexible in terms of needed resources. When we experience too many <a id="_idIndexMarker311"/>Jenkins builds, we can easily add a new machine to the Kubernetes cluster and, therefore, improve the Jenkins capacity.</p>
			<p>We have covered a lot of different strategies on how to configure Jenkins agents. Let's move on and test our configuration.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Testing agents</h2>
			<p>No matter<a id="_idIndexMarker312"/> which agent configuration you have chosen, you can now check whether everything works correctly.</p>
			<p>Let's go back to the Hello World pipeline. Usually, the builds last longer than the Hello World example, so we can simulate it by adding <code>sleeping</code> to the pipeline script:</p>
			<pre>pipeline {
     agent any
     stages {
          stage("Hello") {
               steps {
                    sleep 300 // 5 minutes
                    echo 'Hello World'
               }
          }
     }
}</pre>
			<p>After clicking on <strong class="bold">Build Now</strong> and going to the Jenkins main page, we should see that the build is executed on an agent. Now, if we click on the build many times, multiple builds should be started in <a id="_idIndexMarker313"/>parallel (as shown in the following screenshot):</p>
			<div><div><img src="img/B18223_03_18.jpg" alt="Figure 3.18 – Jenkins running multiple builds on Jenkins agents&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – Jenkins running multiple builds on Jenkins agents</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">To prevent job executions on the master, remember to set <code>0</code> for the master node in the <strong class="bold">Manage Nodes</strong> configuration.</p>
			<p>Having seen that the<a id="_idIndexMarker314"/> agents are executing our builds, we have confirmed that they are configured correctly. Before we move on and see how to create our own Jenkins images, let's clarify one nuance, the difference between Docker agents and the Docker pipeline build.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Comparing Docker pipeline builds and Docker agents</h2>
			<p>The Jenkins pipeline build executes inside a Docker container in two cases – permanent Docker host agents and dynamically provisioned Docker/Kubernetes agents. However, there is a subtle difference between both solutions, which requires a few words of clarification.</p>
			<h3>Docker pipeline builds</h3>
			<p>If your agent is a Docker host, then<a id="_idIndexMarker315"/> you can specify your pipeline runtime from the Jenkins user perspective. In other words, if your project has some special build runtime requirements, you can dockerize them and describe your pipeline script as follows:</p>
			<pre>agent {
     docker {
          image 'custom-docker-image'
     }
}</pre>
			<p>Such an approach means that from the user's perspective, you are free to choose the Docker image used for your build. What's more, you can even decide to execute the build directly on the host, not inside the Docker container, which may be especially useful when the steps in your pipeline need a Docker host that may not be accessible from inside the container. We will see an example of such a requirement in the later chapters of this book.</p>
			<h3>Docker agents</h3>
			<p>If your agent itself is a Docker <a id="_idIndexMarker316"/>container, then you specify the Docker image used from the Jenkins admin perspective. In such a situation, if your project has some specific build runtime requirements, then you need to do the following:</p>
			<ol>
				<li value="1">Create a custom Docker image that uses <code>jenkins/agent</code> as the base image.</li>
				<li>Ask a Jenkins admin to include it in the Docker/Kubernetes plugin configuration and assign a special label to the given agent.</li>
				<li>Use the specific agent label inside your pipeline script.</li>
			</ol>
			<p>This means that for a <a id="_idIndexMarker317"/>project with custom requirements, the setup is slightly more complex.</p>
			<p>There is one more open question: what about a scenario when your pipeline requires access to the Docker host – for example, to build Docker images? Is there a way to use Docker inside a Docker container? Docker-in-Docker comes to the rescue.</p>
			<h3>Docker-in-Docker</h3>
			<p>There is a solution <a id="_idIndexMarker318"/>called <strong class="bold">Docker-in-Docker</strong> (<strong class="bold">DIND</strong>), which allows you to use Docker inside a Docker container. Technically, it requires granting <strong class="bold">privileged</strong> permissions to the Docker container, and there is a related configuration field inside the Jenkins Docker plugin. Note, however, that allowing a container to access the Docker host is a potential security hole, so you should always take extra precautions before applying such a configuration.</p>
			<p>We have finally covered everything about the Jenkins agent configuration. Now, let's move on and look at how, and for what reasons, we can create our own Jenkins images.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Custom Jenkins images</h1>
			<p>So far, we have used Jenkins images<a id="_idIndexMarker319"/> pulled from the internet. We used <code>jenkins/jenkins</code> for the master container and <code>jenkins/agent</code> (or <code>jenkins/inbound-agent</code> or <code>jenkins/ssh-agent</code>) for the agent container. However, you may want to build your own images to satisfy the specific build environment requirements. In this section, we will cover how to do it.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Building the Jenkins agent</h2>
			<p>Let's start with the agent <a id="_idIndexMarker320"/>image because it's more frequently customized. The build execution is performed on the agent, so it's the agent that needs to have the environment adjusted to the project we want to build – for example, it may require the Python interpreter if our project is written in Python. The same applies to any library, tool, or testing framework, or anything that is needed by the project.</p>
			<p>There are four steps to building and using the custom image:</p>
			<ol>
				<li value="1">Create a Docker file.</li>
				<li>Build the image.</li>
				<li>Push the image into a registry.</li>
				<li>Change the agent configuration on the master.</li>
			</ol>
			<p>As an example, let's <a id="_idIndexMarker321"/>create an agent that serves the Python project. We can build it on top of the <code>jenkins/agent</code> image, for the sake of simplicity. Let's do it using the following four steps:</p>
			<ol>
				<li value="1"><code>Dockerfile</code>, with the following content:<pre>FROM jenkins/agent
USER root
RUN apt-get update &amp;&amp; \
    apt-get install -y python
USER jenkins</pre></li>
				<li><strong class="bold">Build the image</strong>: We can build the image by executing the following command:<pre><strong class="bold">$ docker build -t leszko/jenkins-agent-python .</strong></pre></li>
				<li><code>leszko</code> to your Docker Hub name) and that you have already executed <code>docker login</code>. We'll cover more on Docker registries in <a href="B18223_05_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 5</em></a>, <em class="italic">Automated Acceptance Testing</em>.</p></li>
				<li><code>leszko/jenkins-agent-python</code> instead of <code>jenkins/agent</code> in the<a id="_idIndexMarker322"/> Jenkins master's configuration (as described in the <em class="italic">Dynamically provisioned Docker agents</em> section).<p class="callout-heading">Tip</p><p class="callout">If you have pushed your image to the Docker Hub registry and the registry is private, then you'll also need to configure the appropriate credentials in the Jenkins master configuration.</p></li>
			</ol>
			<p><em class="italic">What if we need Jenkins to build two different kinds of projects – for example, one based on Python and another based on Ruby?</em> In that case, we can prepare an agent that's generic enough to support both – Python and Ruby. However, in the case of Docker, it's recommended to create a second agent image (<code>leszko/jenkins-agent-ruby</code> by analogy). Then, in the Jenkins configuration, we need to create two Docker templates and label them accordingly.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">We used <code>jenkins/agent</code> as the base image, but we can use <code>jenkins/inbound-agent</code> and <code>jenkins/ssh-agent</code> in exactly the same manner.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Building the Jenkins master</h2>
			<p>We already have a custom <a id="_idIndexMarker323"/>agent image. <em class="italic">Why would we also want to build our own master image?</em> One of the reasons might be that we don't want to use agents at all, and since the execution will be done on the master, its environment has to be adjusted to the project's needs. That is, however, a very rare case. More often, we will want to configure the master itself.</p>
			<p>Imagine the following scenario: your organization scales Jenkins horizontally, and each team has its own instance. There is, however, some common configuration – for example, a set of base plugins, backup strategies, or the company logo. Then, repeating the same configuration for each of the teams is a waste of time. So, we can prepare the shared master image and let the teams use it.</p>
			<p>Jenkins is natively configured using XML files, and it provides the Groovy-based DSL language to manipulate them. That is why we can add the Groovy script to the Dockerfile in order to manipulate the Jenkins configuration. Furthermore, there are special scripts to help with the Jenkins configuration if it requires something more than XML changes – for <a id="_idIndexMarker324"/>instance, plugin installation.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">All possibilities of the Dockerfile instructions are well described on the GitHub page at <a href="https://github.com/jenkinsci/docker">https://github.com/jenkinsci/docker</a>.</p>
			<p>As an example, let's create a master image with <code>docker-plugin</code> already installed and a number of executors set to <code>5</code>. In order to do it, we need to perform the following:</p>
			<ol>
				<li value="1">Create the Groovy script to manipulate <code>config.xml</code>, and set the number of executors to <code>5</code>.</li>
				<li>Create the Dockerfile to install <code>docker-plugin</code>, and execute the Groovy script.</li>
				<li>Build the image.</li>
			</ol>
			<p>Let's use the three steps mentioned and build the Jenkins master image:</p>
			<ol>
				<li value="1"><code>executors.groovy</code> file with the following content:<pre>import jenkins.model.*
Jenkins.instance.setNumExecutors(5)</pre><p class="callout-heading">Tip</p><p class="callout">The complete Jenkins API can be found on the official page at <a href="http://javadoc.jenkins.io/">http://javadoc.jenkins.io/</a>.</p></li>
				<li><strong class="bold">Dockerfile</strong>: In the same directory, create a Docker file:<pre>FROM jenkins/jenkins:lts-jdk11
COPY executors.groovy /usr/share/jenkins/ref/init.groovy.d/executors.groovy
RUN jenkins-plugin-cli --plugins docker-plugin github-branch-source:1.8</pre></li>
				<li><strong class="bold">Build the image</strong>: We can finally build the image:<pre><strong class="bold">$ docker build -t jenkins-master .</strong></pre></li>
			</ol>
			<p>After the<a id="_idIndexMarker325"/> image is created, each team in the organization can use it to launch their own Jenkins instance.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Similar to the Jenkins agent image, you can build the master image as <code>leszko/jenkins-master</code> and push it into your Docker Hub account.</p>
			<p>Having our own master and agent images lets us provide the configuration and build environment for the teams in our organization. In the next section, you'll see what else is worth being configured in Jenkins.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">You can also configure Jenkins master as well as Jenkins pipelines using the YAML-based configuration with the Configuration as Code plugin. Read more at <a href="https://www.jenkins.io/projects/jcasc/">https://www.jenkins.io/projects/jcasc/</a>.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Configuration and management</h1>
			<p>We have already covered the most crucial part of the Jenkins configuration – <strong class="bold">agent provisioning</strong>. Since Jenkins is highly configurable, you can expect many more possibilities to adjust it to your needs. The good news is that the configuration is intuitive and accessible via the web interface, so it does not require a detailed description. Everything can be changed under the <strong class="bold">Manage Jenkins</strong> sub-page. In this section, we will focus on only a few aspects that are most likely to be changed – plugins, security, and backup.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>Plugins</h2>
			<p>Jenkins is highly <a id="_idIndexMarker326"/>plugin-oriented, which means that a lot of features are delivered by the use <a id="_idIndexMarker327"/>of plugins. They can extend Jenkins in an almost unlimited way, which, taking into consideration the large community, is one of the reasons why Jenkins is such a successful tool. With Jenkins' openness comes risk, and it's better to download only plugins from a reliable source or check their source code.</p>
			<p>There are literally tons of plugins to choose from. Some of them were already installed automatically, during the initial configuration. Others (Docker and Kubernetes plugins) were installed when setting the Docker agents. There are plugins for cloud integration, source control tools, code coverage, and much more. You can also write your own plugin, but it's better to check whether the one you need is already available.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">There is an official Jenkins page to browse plugins at <a href="https://plugins.jenkins.io/">https://plugins.jenkins.io/</a>.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Security</h2>
			<p>The way you should approach <a id="_idIndexMarker328"/>Jenkins security depends on the Jenkins architecture you have <a id="_idIndexMarker329"/>chosen within your organization. If you have a Jenkins master for every small team, then you may not need it at all (under the assumption that the corporate network is firewalled). However, if you have a single Jenkins master instance for the whole organization, then you'd better be sure you've secured it well.</p>
			<p>Jenkins comes with its own user database; we already created a user during the initial configuration process. You can create, delete, and modify users by opening the <strong class="bold">Manage Users</strong> setting page. The built-in database can be a solution in the case of small organizations; however, for a large group of users, you will probably want to use the <strong class="bold">Lightweight Directory Access Protocol (LDAP</strong>) instead. You can choose it on the <strong class="bold">Configure Global Security</strong> page. There, you<a id="_idIndexMarker330"/> can also assign roles, groups, and users. By default, the <strong class="bold">Logged-in users can do anything</strong> option is set, but in a large-scale organization, you should probably consider using more detailed permission granularity.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Backup</h2>
			<p>As the old saying goes, <em class="italic">there are two types of people: those who back up, and those who will back up</em>. Believe it or not, the backup is something you probably want to configure. <em class="italic">What files should be backed up, and from which machines?</em> Luckily, agents automatically send <a id="_idIndexMarker331"/>all the relevant data back to the master, so we don't need to bother with them. If you run Jenkins in a container, then the container itself is also not of interest, since it does not hold a persistent state. The only place we are interested in is the Jenkins home directory.</p>
			<p>We can either install a Jenkins plugin (which will help us to set periodic backups) or simply set a cron job to archive the directory in a safe place. To reduce the size, we can exclude the subfolders that are not of interest (that will depend on your needs; however, almost certainly, you don't need to copy the following: <em class="italic">war</em>, <em class="italic">cache</em>, <em class="italic">tools</em>, and <em class="italic">workspace</em>).</p>
			<p class="callout-heading">Information</p>
			<p class="callout">If you automate your Jenkins master setup (by building a custom Docker image or using the Jenkins Configuration as Code plugin), then you may consider skipping the Jenkins backup configuration.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Jenkins Blue Ocean UI</h2>
			<p>The first version of <a id="_idIndexMarker332"/>Hudson (the former Jenkins) was released in 2005. It's been on the market for more than 15 years now. However, its look and feel haven't changed much. We've used it for quite a while, and it's hard to deny that it looks outdated. Blue Ocean is the plugin that has redefined the user experience of Jenkins. If Jenkins is aesthetically displeasing to you or its workflow does not feel intuitive enough, then it's definitely worth giving Blue Ocean a try (as shown in the following screenshot):</p>
			<div><div><img src="img/B18223_03_19.jpg" alt="Figure 3.19 – The Jenkins Blue Ocean UI&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – The Jenkins Blue Ocean UI</p>
			<p class="callout-heading">Information </p>
			<p class="callout">You can read more on the <a id="_idIndexMarker333"/>Blue Ocean page at <a href="https://www.jenkins.io/doc/book/blueocean/">https://www.jenkins.io/doc/book/blueocean/</a>.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Summary</h1>
			<p>In this chapter, we covered the Jenkins environment and its configuration. The knowledge we have gained is sufficient to set up the complete Docker-based Jenkins infrastructure. The key takeaway points from the chapter are as follows:</p>
			<ul>
				<li>Jenkins is a general-purpose automation tool that can be used with any language or framework.</li>
				<li>Jenkins is highly extensible by plugins, which can be written or found on the internet.</li>
				<li>Jenkins is written in Java, so it can be installed on any operating system. It's also officially delivered as a Docker image.</li>
				<li>Jenkins can be scaled using the master-agent architecture. The master instances can be scaled horizontally or vertically, depending on an organization's needs.</li>
				<li>Jenkins agents can be implemented with the use of Docker, which helps in automatic configuration and dynamic agent allocation.</li>
				<li>Custom Docker images can be created for both the Jenkins master and Jenkins agent.</li>
				<li>Jenkins is highly configurable, and some aspects that should always be considered are security and backups.</li>
			</ul>
			<p>In the next chapter, we will focus on something that we already touched on with the Hello World example – pipelines. We will describe the idea behind and the method for building a complete continuous integration pipeline.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Exercises</h1>
			<p>You learned a lot about Jenkins configuration throughout this chapter. To consolidate your knowledge, we recommend the following exercises on preparing Jenkins images and testing the Jenkins environment:</p>
			<ol>
				<li value="1">Create Jenkins master and agent Docker images and use them to run a Jenkins infrastructure capable of building Ruby projects:<ol><li>Create the Jenkins master Dockerfile, which automatically installs the Docker plugin.</li><li>Build the master image and run the Jenkins instance.</li><li>Create the agent Dockerfile (suitable for the dynamic agent provisioning), which installs the Ruby interpreter.</li><li>Build the agent image.</li><li>Change the configuration in the Jenkins instance to use the agent image.</li></ol></li>
				<li>Create a pipeline that runs a Ruby script printing <code>Hello World from Ruby</code>:<ol><li>Create a new pipeline.</li><li>Use the following shell command to create the <code>hello.rb</code> script on the fly:</li></ol></li>
			</ol>
			<p><strong class="bold"> sh "echo \"puts 'Hello World from Ruby'\" &gt; hello.rb"</strong></p>
			<ol>
				<li value="3">Add the command to run <code>hello.rb</code>, using the Ruby interpreter.</li>
				<li>Run the build and observe the console's output.</li>
			</ol>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Questions</h1>
			<p>To verify your knowledge from this chapter, please answer the following questions:</p>
			<ol>
				<li value="1">Is Jenkins provided in the form of a Docker image?</li>
				<li>What is the difference between a Jenkins master and a Jenkins agent (slave)?</li>
				<li>What is the difference between vertical and horizontal scaling?</li>
				<li>What are the two main options for master-agent communication when starting a Jenkins agent?</li>
				<li>What is the difference between setting up a permanent agent and a permanent Docker agent?</li>
				<li>When would you need to build a custom Docker image for a Jenkins agent?</li>
				<li>When would you need to build a custom Docker image for a Jenkins master?</li>
				<li>What is Jenkins Blue Ocean?</li>
			</ol>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor104"/>Further reading</h1>
			<p>To read more about Jenkins, please refer to the following resources:</p>
			<ul>
				<li><em class="italic">Jenkins Handbook</em>: <a href="https://www.jenkins.io/doc/book/">https://www.jenkins.io/doc/book/</a></li>
				<li><em class="italic">Jenkins Essentials</em>, <em class="italic">Mitesh Soni</em>: <a href="https://www.packtpub.com/virtualization-and-cloud/jenkins-essentials-second-edition">https://www.packtpub.com/virtualization-and-cloud/jenkins-essentials-second-edition</a></li>
				<li><em class="italic">Jenkins: The Definitive Guide</em>, <em class="italic">John Ferguson Smart</em>: <a href="https://www.oreilly.com/library/view/jenkins-the-definitive/9781449311155/">https://www.oreilly.com/library/view/jenkins-the-definitive/9781449311155/</a></li>
			</ul>
		</div>
	</body></html>