<html><head></head><body>
        

                            
                    <h1 class="header-title">Installing, Configuring, and Running Ansible</h1>
                
            
            
                
<p class="mce-root">Ansible is a relatively new addition to the DevOps and Configuration Management ecosystem. Its radical simplicity, structured automation format, and no brainer development paradigm has caught the eyes of both corporations and startups alike. Organizations such as Twitter have managed to successfully leverage Ansible for highly scaled deployments and Configuration Management implementations across, and have scaled it to manage and deploy to thousands of servers simultaneously. Twitter isn't the only player within the Ansible space that has managed to leverage Ansible at scale; other well-known organizations that have successfully leveraged Ansible include Logitech, NASA, NEC, Microsoft, and hundreds more.</p>
<p class="mce-root">As it stands today, Ansible is in use by some of the largest and well known technology companies and organizations around the world, and is responsible for managing thousands of deployments and maintaining the Configuration Management solutions for countless organizations. Learning the fundamentals of the Ansible solution will provide us with the tools we will need to properly install, configure and run Ansible at small and large scales.</p>
<p>In this chapter, we will formally introduce you to Ansible. Together we will learn how to install it, dive into its run-time architectures, and learn how to configure it to run simple automation sequences. In addition to these topics, we will cover the basics of the Ansible control server under Ubuntu Linux and learn how Ansible can be leveraged for local executions as well as remote management. Finally in this chapter, we will cover the basic concept of a playbook and discover the underlying constructs behind what makes Ansible so powerful. The goals for this chapter will be to grasp the following:</p>
<ul>
<li>Installing Ansible</li>
<li>The Ansible Architecture</li>
<li>The Ansible Command Line Interface</li>
<li>Configuring Ansible</li>
<li>The Ansible Inventory</li>
</ul>
<p>Now that we have the introductions out of the way let's get started!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing Ansible</h1>
                
            
            
                
<p>Ansible itself is cross-platform. The basic installation of the Ansible system is actually fairly easy. Before we can install it, we need to get the Ansible runtime packages. Ansible is available for consumption via the following online solutions:</p>
<ul>
<li>Yum (Red Hat Linux-based distributions)</li>
<li>Apt (Debian)</li>
<li>Apt (Ubuntu)</li>
<li>Portage (Gentoo)</li>
<li>Pkg (FreeBSD)</li>
<li>macOS (dmg)</li>
<li>OpenCSW (Solaris)</li>
<li>Pacman (Arch Linux)</li>
<li>Pip (Python)</li>
<li>Tarball (Source)</li>
<li>Source (Source)</li>
</ul>
<p>The following is a set of examples and command-line syntaxes for each of the listed options. These commands will help you get up-and-running with Ansible quickly (they are taken from the Ansible website).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Red Hat Enterprise Linux via Configuration Management</h1>
                
            
            
                
<p>Installing Ansible on most popular Red Hat Enterprise Linux flavor distributions is quite easy. This can be accomplished as follows:</p>
<pre>
# NOTE: Before installing Ansible you may need to install the epel-release repo<br/># for RHEL or <br/># Scientific Linux. Additional details on how to install EPEL can be found at<br/># http://fedoraproject.org/wiki/EPEL<br/><strong>$ sudo yum install ansible</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Apt for Debian/Apt for Ubuntu</h1>
                
            
            
                
<p>Installing Ansible on Debian or Ubuntu flavor Linux distributions is a breeze. This can be accomplished using the Apt package management solution as shown in the following commands:</p>
<pre>
<strong>$ sudo apt-get install software-properties-common</strong><br/><strong>$ sudo apt-add-repository ppa:ansible/ansible</strong><br/><strong>$ sudo apt-get update</strong><br/><strong>$ sudo apt-get install ansible</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Porting Ansible to Gentoo</h1>
                
            
            
                
<p>For Gentoo Linux users, installing Ansible can be accomplished fairly easily. The following command-line syntax can be leveraged to accomplish the installation:</p>
<pre>
# The first command is optional, you may need to unmask the Ansible package prior to running emerge:<br/><strong>$ echo 'app-admin/ansible' &gt;&gt; /etc/portage/package.accept_keywords</strong><br/><strong>$ emerge -av app-admin/ansible</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">PKG for FreeBSD</h1>
                
            
            
                
<p>FreeBSD-specific users can use <kbd>pkg install</kbd> to install the Ansible control server solution and get Ansible up-and-running quickly:</p>
<pre>
<strong>$ sudo pkg install ansible</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Pip for macOS</h1>
                
            
            
                
<p>The preferred way to install Ansible for macOS is to use Python's pip installation solution. An example of how to do this is provided next.</p>
<p>If needed, you can install <kbd>pip</kbd> via the following command:</p>
<pre>
<strong>$ sudo easy_install pip</strong>
</pre>
<p>Once <kbd>pip</kbd> is installed, you can install Ansible with the following command:</p>
<pre>
<strong>$ sudo pip install ansible</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">OpenCSW for Solaris/SunOS</h1>
                
            
            
                
<p>Solaris users have the ability to install and configure Ansible using the OpenCSW package management solution. This solution can be leveraged as follows:</p>
<pre>
<strong># pkgadd -d http://get.opencsw.org/now</strong><br/><strong># /opt/csw/bin/pkgutil -i ansible</strong><strong>Pacman for Arch Linux</strong>
</pre>
<p>Installing Ansible for Arch Linux is quite simple. The following command should help accomplish this task:</p>
<pre>
# Note: If you have Python3 selected you must set <br/># ansible_python_interpreter = /usr/bin/python2 # in your inventory variables<br/><strong>$&gt; pacman -S ansible</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Via Python pip</h1>
                
            
            
                
<p>Prior to installing Ansible using pip we may need to actually install pip. To accomplish this on the command line, the following command can be used:</p>
<pre>
<strong>$ sudo easy_install pip</strong>
</pre>
<p>Then install Ansible with the following command:</p>
<pre>
<strong>$ sudo pip install ansible</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Once Ansible has been installed</h1>
                
            
            
                
<p>Once Ansible is installed on the desired Linux machine, we will want to verify that it is properly installed and functioning. To do this from the command line, enter the following command:</p>
<pre>
# Display Ansible command line options available<br/><strong>$ ansible --help</strong><br/># Show the Ansible version number<br/><strong>$ ansible --version</strong>
</pre>
<p>Upon successful execution of these commands, Ansible should output version information and related help information respectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up authentication between the control server and hosts</h1>
                
            
            
                
<p class="mce-root">When connecting Ansible with remote hosts, Ansible's best practices encourage the use of SSH key sharing. SSH keys allow one Linux host to talk to another without asking for a specific password. In this section we are going to briefly look at how to set SSH key sharing up on the control server and <em>n</em> number of target machines.</p>
<p class="mce-root">If SSH key Sharing is not available Ansible also offers the option to ask for a password using the <kbd>--ask-become-pass</kbd> command-line argument.</p>
<p class="mce-root">To get started, create a <kbd>/etc/ansible/hosts</kbd> (if it doesn't exist) and add one or more remote systems into its contents. Your specific public SSH key should be located in <kbd>authorized_keys</kbd> on those target systems.</p>
<p class="mce-root">In this brief tutorial we will assume the SSH key authentication solution is being used. It helps us avoid having to enter or store raw passwords:</p>
<pre class="mce-root">
<strong>$ ssh-agent bash</strong><br/><strong>$ ssh-add ~/.ssh/id_rsa</strong>
</pre>
<p class="mce-root">Now ping all the nodes (assumes you have an inventory file created):</p>
<pre class="mce-root">
<strong>$ ansible all -m ping</strong>
</pre>
<p>For a complete documentation set around setting up SSH key sharing in Ubuntu the documentation can be found at <a href="http://linuxproblem.org/art_9.html">http://linuxproblem.org/art_9.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Ansible Architecture</h1>
                
            
            
                
<p>Ansible was created with an incredibly flexible and scalable automation engine. It allows users to leverage it in many diverse ways and can be adapted to be used in the way that best suits your specific needs. Since Ansible is agentless (meaning there is no permanently running daemon on the systems it manages or executes from), it can be used locally to control a single system (without any network connectivity) or leveraged to orchestrate and execute automation against many systems, via a control server.</p>
<p>In addition to the aforementioned architectures, Ansible can also be leveraged via Vagrant or Docker to provision infrastructure automatically. This type of solution basically allows Ansible users to bootstrap their hardware or infrastructure provisioning by running one or more Ansible playbooks.</p>
<p>If you happen to be a Vagrant user, there are instructions within the HashiCorp Ansible provisioning located at the following URL: <a href="https://www.vagrantup.com/docs/provisioning/ansible.html"><br/>
https://www.vagrantup.com/docs/provisioning/ansible.html</a>.<a href="https://www.vagrantup.com/docs/provisioning/ansible.html"/></p>
<p>As we mentioned briefly, Ansible is open source, module-based, pluggable, and agentless. These key differentiators from other Configuration Management solutions give Ansible a significant edge. Let's take a look at each of these differentiators in detail and see what it actually means for Ansible developers and users.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Open source</h1>
                
            
            
                
<p>It is no secret that successful open source solutions are usually extraordinarily feature-rich. This is because, instead of a simple eight-person (or even 100-person) engineering team, there are potentially thousands of developers. Each development and enhancement has been designed to fit a unique need. As a result, the end deliverable product provides consumers of Ansible with a very well-rounded solution that can be adapted or leveraged in numerous ways.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Module-based</h1>
                
            
            
                
<p>Ansible has been developed for integration with numerous other open and closed source software solutions. This idea means that Ansible is currently compatible with multiple flavors of Linux, Windows, and cloud providers. Aside from its OS-level support, Ansible currently integrates with hundreds of other software solutions: EC2, JIRA, Jenkins, Bamboo, Microsoft Azure, DigitalOcean, Docker, Google, and many more.</p>
<p>For a complete list of Ansible modules, consult the official Ansible module support list located at the following URL: <a href="http://docs.ansible.com/ansible/modules_by_category.html">http://docs.ansible.com/ansible/modules_by_category.html</a>﻿.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Agentless</h1>
                
            
            
                
<p>One of the key differentiators that gives Ansible an edge against the competition is the fact that it is completely agentless. This means there are no daemons that need to be installed on remote machines, no firewall ports that need to be opened (besides traditional SSH), no monitoring that needs to be performed on remote machines, and no management that needs to be performed on the infrastructure fleet. In effect, this makes Ansible very self-sufficient.</p>
<p>Since Ansible can be implemented in a few different ways, the aim of this section is to highlight these options and help get us familiar with the architecture types that Ansible supports. Generally, the architecture of Ansible can be categorized into three distinct architecture types. These are described next.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pluggable</h1>
                
            
            
                
<p>While Ansible comes out-of-the-box with a wide spectrum of software integration support, it is oftentimes a requirement to integrate the solution with a company-based internal software solution or a software solution that has not already been integrated into Ansible's robust playbook suite. The answer to such a requirement would be to create a plugin-based solution for Ansible, thus providing the custom functionality necessary.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Local automation execution using Ansible</h1>
                
            
            
                
<p>The easiest way to leverage Ansible is to instruct it to manage a local system. This means there is no need for SSH connections or port openings or SSH key sharing to be done. This implementation simply involves one user, a set of playbooks (or one), and a local system. Local automation execution is the scenario in which Ansible is leveraged to execute a playbook (a series of automation tasks) against a local machine. This specific architecture type means that Ansible does not need an available network connection or internet connection for it to perform its work.</p>
<p>This architecture type is diagrammed next:</p>
<div><img height="278" width="356" class="image-border" src="img/02a14c66-a572-400a-b83a-d16a907c27d1.png"/></div>
<p>As we can see from the diagram, Ansible can be used for local provisioning. This architecture may seem a bit unscalable, but with a bit of creativity, there is a significant amount of power behind this specific architecture. Let's take a look at some of the various ways in which this specific architecture can be applied:</p>
<ul>
<li>To locally provision a development environment and configure it to be a single click setup: ideally with this approach, Ansible playbooks will be written and stored in the local development source control system and then leveraged by new developers to setup and configure their development environments. This will save a significant amount of time on-boarding and getting an employee started.</li>
<li>To enforce local infrastructure-provisioning rules and revert changes made to the system that were done out of band: this solution would be ideal for enforcing infrastructure that gets tampered with or altered accidentally.</li>
<li>To execute a set of timed automations that could be leveraged to perform automated routines.</li>
</ul>
<p>As we can see from the architecture, Ansible's local execution gives us the ability to execute a playbook against a localized system without any fuss or complexity. Let's take a quick look at how to run an Ansible playbook against a local system using the command line. To begin though, let's learn how to run an ad hoc command against a local system. The example is provided as follows:</p>
<pre>
Example: Ad hoc Linux echo command against a local system<br/><strong>#&gt; ansible all -i "localhost," -c local -m shell -a 'echo hello DevOps World'</strong>
</pre>
<p>The command simply tells Ansible to target all systems in the ad hoc inventory implementation (which in our simple use case is only localhost), then execute the command <kbd>echo "hello DevOps world"</kbd> against this system. Simple, right? Now let's take a look at how this same implementation might look if it were in Ansible playbook form. An example of this in playbook form is provided as follows:</p>
<pre>
# File name: hellodevopsworld.yml<br/>---<br/>- hosts: all<br/> tasks:<br/> - shell: echo "hello DevOps world"
</pre>
<p>This example represents a very simple Ansible playbook. Ansible playbooks are written in <strong>Yet Another Markup Language</strong> (<strong>YAML</strong>). They are intended to be easy to read, easy to write, highly structured, and without complexity. The idea of a <em>playbook</em> in the Ansible world comes from the playbook one might receive when attending a broadway show. Playbooks describe in brief the upcoming scenes and actors. As such, Ansible playbooks also contain a list of upcoming events (defined as tasks, and the details of those events). In our simple example, we are telling Ansible to instruct the Linux shell (on the target system(s)) to display a simple introductory message: <kbd>hello DevOps world</kbd>.</p>
<p>At this point, you may be wondering, <em>how does one run such a playbook?</em> I'm glad you asked. Playbooks can be run from the command line by specifying the playbook name. An example of this is provided here:</p>
<pre>
# Running a Playbook from the command line:<br/><strong>#&gt; ansible-playbook -i 'localhost,' -c local hellodevopsworld.yml</strong>
</pre>
<p>Next let's take a look at remote automation execution. This methodology is significantly different from local execution as it allows for much larger scalability support.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Remote automation execution using Ansible</h1>
                
            
            
                
<p>The most popular use of Ansible is through remote execution. This architecture requires a network connection and SSH or Windows remoting. By using remote execution, we are essentially instructing Ansible to reach out over SSH to one or many machines, authenticate using a previously shared SSH or RM key, create a temporary TCP connection to one or more remote machines, and execute a set of playbook-based automations against them. If this sounds a bit confusing, let's take a look in depth at how this architecture and automation solution works.</p>
<p>To begin with, as a local administrator, we will need to pre-authorize the preferred Ansible user with the target machines. By doing this pre-authentication, we are essentially (most commonly through SSH key sharing) configuring at least two Linux-oriented machines (the control and the target) with the permissions needed for the control server to communicate with and control the target machine without further authorization. Details on how to perform a basic SSH key-sharing implementation are covered later in this chapter (or can be found at <a href="http://docs.ansible.com/ansible/intro_getting_started.html">http://docs.ansible.com/ansible/intro_getting_started.html</a>).</p>
<p>Once key sharing has been implemented and has been verified as working, Ansible can effectively take control of the remote systems and execute automation against them. This is accomplished through a nifty self-installation solution provided by Ansible. Effectively, the Ansible automation system (upon execution) will copy itself over to the remote system, install itself on the remote system, run a specified set of playbooks on the target system, verify the results of the execution, and delete itself (and the playbook) from the target system. This leaves the system in the desired state without the need to maintain a running daemon on the target system.</p>
<p>The remote automation execution architecture can be seen via the following illustration:</p>
<div><img height="275" width="389" class="image-border" src="img/e474c377-cd57-4561-a3b0-d0e493e60f31.png"/></div>
<p>As we can see from the previous diagram, the Linux control server (running Ansible) uses a set of secure protocols (<strong>SSH</strong> and <strong>Windows RM</strong> respectively) to control, automate, and configure the remote systems. These automation executions happen in parallel, meaning that Ansible has the ability to simultaneously control between 1 and 10,000 machines without a significant degradation in performance.</p>
<p>Now that we have a good idea of how a remote execution architecture works, let's take a look at a couple of examples. Ansible (as we discovered in the previous section) leverages playbooks to manage human-readable automation. In this first example, we will need two machines, both Linux based, with Ansible installed on the control server (see the previous diagram for which machine is the control server), and a target server with SSH keys shared so that the control server can properly control or manage the target.</p>
<p>Now to create a playbook, simply edit a file title <kbd>hellodevopsworld.yml</kbd> and paste the following lines of code into it:</p>
<div><pre>
# File name: HelloDevOpsWorld.yml<br/>---<br/>- hosts: all<br/>  tasks:<br/>   - shell: echo "hello DevOps world"
</pre></div>
<p>Save the file onto disk, in a location you prefer (we chose <kbd>/opt/hellodevopsworld.yml</kbd>). Next we will need to identify the IP address or <kbd>HOSTNAME/FQDN</kbd> of the target machine and run the playbook. For this example our target host is on <kbd>192.168.10.10</kbd>. Now let's run the playbook against the target machine from the control server:</p>
<div><pre>
# Example command: Execute the playbook hellodevopsworld.yml against<br/># 192.168.10.10<br/><strong>#&gt; ansible-playbook -i "192.168.10.10," -c local hellodevopsworld.yml</strong>
</pre></div>
<p>From this command, we should see Ansible execute the <kbd>hellowdevopsworld</kbd> playbook against the target machine (<kbd>192.168.10.10</kbd>) and the execution should output <kbd>hellodevopsworld</kbd> to the command-line interface. The following is the output we should see from the executions provided through Ansible:</p>
<div><pre>
PLAY [all] *********<br/>GATHERING FACTS *********<br/>ok: [192.168.10.10]<br/>TASK: [shell echo "hello world"] *********<br/>changed: [192.168.10.10]<br/>PLAY RECAP *********<br/>192.168.10.10 : ok=2 changed=1 unreachable=0 failed=0 
</pre></div>
<p>By default Ansible is configured to to execute <em>all</em> automations in parallel. This can be altered by specifying the <kbd>--limit</kbd> option on the command line, which allows the administrator to limit the number of parallel executions to a specific number. This can be handy when you need to be able to debug a playbook or restrict the number of simultaneous executions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Container-oriented automation</h1>
                
            
            
                
<p>Container-oriented automation is similar to local automation execution, although it leverages the Configuration Management and automation execution capabilities of Ansible on the container. This architecture is slightly different from the others in the sense that it does not rely on Ansible being installed on a given host or container prior to the execution of a playbook but rather installs Ansible on-the-fly (during the provisioning phase of the container) and then executes a playbook once Ansible is installed. As a result, the flow of automation would be better represented through a flow diagram:</p>
<div><img height="250" width="455" class="image-border" src="img/6aca378f-bdbe-4297-a7b6-8f00d4f1422a.png"/></div>
<p>Container-oriented automation can be especially useful for provisioning environments (development, testing, production, and so on) as well as helping get developers up and running quickly. Let's take a look at a quick Vagrant setup using Ansible as the bootstrapping solution within the VM.</p>
<p>To begin, let's log in to our local machine as the <kbd>root</kbd> user and create a directory setup to hold our local infrastructure. In this example, we are using a macOS machine with VirtualBox and Vagrant (<a href="https://www.vagrantup.com/about.html">https://www.vagrantup.com/about.html</a>) installed (and while these instructions are macOS-specific, they can be applied to Windows machines quite easily as well):</p>
<ol>
<li>Create a directory, which will house our project, and change into it:</li>
</ol>
<pre style="padding-left: 90px">
<strong>#&gt; mkdir -p ~/Desktop/helloVagrantAnsible</strong><br/><strong>#&gt; cd ~/Desktop/helloVagrantAnsible</strong>
</pre>
<ol start="2">
<li>Initialize Vagrant using the <kbd>vagrant init</kbd> command:</li>
</ol>
<pre style="padding-left: 90px">
<strong>#&gt; vagrant init ubuntu/trusty64</strong>
</pre>
<ol start="3">
<li>Edit the newly created <kbd>Vagrantfile</kbd>, which should be now located at <kbd>~/Desktop/helloVagrantAnsible/Vagrantfile</kbd>, to reflect what is shown here (taken from the Ansible website):</li>
</ol>
<pre>
# This guide is optimized for Vagrant 1.7 and above.<br/># Although versions 1.6.x should behave very similarly, it is recommended<br/># to upgrade instead of disabling the requirement below.<br/>Vagrant.require_version "&gt;= 1.7.0"<br/><br/>Vagrant.configure(2) do |config|<br/><br/> config.vm.box = "ubuntu/trusty64"<br/><br/> # Disable the new default behavior introduced in Vagrant 1.7, to<br/> # ensure that all Vagrant machines will use the same SSH key pair.<br/> # See https://github.com/mitchellh/vagrant/issues/5005<br/> config.ssh.insert_key = false<br/><br/> config.vm.provision "ansible" do |ansible|<br/> ansible.verbose = "v"<br/> ansible.playbook = "playbook.yml"<br/> end<br/>end
</pre>
<p>As we can see from the <kbd>Vagrantfile</kbd>, we are essentially configuring Vagrant to fire up and execute <kbd>playbook.yml</kbd> upon the initial fire-up. This implementation once understood is incredibly powerful as it provides us with a way of bootstrapping an infrastructure solution with Ansible as its provisioner. This implementation is ideal for developers or quality assurance engineers as it provides them with a way of storing their infrastructure as code.</p>
<p>Now that we have our <kbd>Vagrantfile</kbd>, let's create <kbd>playbook.yml</kbd> in the same directory as the <kbd>Vagrantfile</kbd>. Its contents should reflect the following:</p>
<pre>
# playbook.yml<br/>---<br/>- hosts: all<br/> tasks:<br/> - name: "Install Apache"<br/> apt: name={{ item }} state=present<br/> with_items:<br/> - apache2<br/><br/> - name: "Turn on Apache and set it to run on boot"<br/> service: name={{ item }} state=started enabled=yes<br/> with_items:<br/> - apache2
</pre>
<p>This playbook (as you may have guessed) simply installs Apache2 on the Ubuntu system we defined in our <kbd>vagrant init</kbd> command and tells Ansible to provision it with Apache enabled as a system service at boot.</p>
<p>The final step in this tutorial is to simply run our Vagrant setup by typing the following command into our command-line window:</p>
<pre>
# Start Vagrant and auto provision the system with Ubuntu,<br/># Ansible and Apache<br/><strong>$&gt; vagrant up</strong>
</pre>
<p>If everything was successful, you should be able to see your local Apache instance running within the VirtualBox provisioned and running through Vagrant.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Ansible Command-Line Interface</h1>
                
            
            
                
<p>Ansible provides a robust command-line interface, which provides users with the ability to run Ansible playbooks, simulate the execution of Ansible playbooks, run ad hoc commands, and much more. In the Ansible galaxy (more to come on that specific pun later in the book), there are two specific types of Ansible commands that can be run. The <kbd>ansible</kbd> command allows users to run ad hoc commands, whereas the <kbd>ansible-playbook</kbd> command allows the user to execute a set of Ansible playbook instructions against the targeted infrastructure.</p>
<p>This is ambiguous within the documentation, Ansible and Ansible-playbook appear to be symlinks but there are some reports of different functionality between the two. More research is needed before final drafting to ensure accuracy of information reported. For now, there will be a section for Ansible and Ansible-playbook (provided in the following sections) but these may change going forward.</p>
<p>The Ansible command-line interface is the gateway into the heart of Ansible and provides a wide array of options and configurable switches that will help you gain the most out of Ansible. Let's take a quick tour of the Ansible command-line interface and see what the available switches and knobs do.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Usage: ansible &lt;host-pattern&gt; [options]</h1>
                
            
            
                
<p>In this section we are going to take a look at the Ansible command-line patterns and see how they function. The implementation of the command line solution for Ansible is actually quite easy to understand. Let's take a look at a couple of easy examples.</p>
<p>The <kbd>--help</kbd> option will display a complete list of available command-line options. This is probably one of the most important command-line options within the Ansible CLI:</p>
<pre>
<strong>Help: [#&gt; ansible --help]<br/></strong>
</pre>
<p>Now that we know how to use the <kbd>help</kbd> command let's take a look at the <kbd>version</kbd> command. This command-line argument provides us with the version information for the Ansible installation we are using:</p>
<pre>
<strong>Version: [#&gt; ansible --version]</strong>
</pre>
<p>The <kbd>ansible --version</kbd> command will output the version information for the installed copy of Ansible. For example, you might see something like the following:</p>
<pre>
<strong>#&gt; ansible --version</strong><br/>ansible 2.0.0.2<br/>config file = /etc/ansible/ansble.cfg<br/>configured module search path = Default w/o overrides
</pre>
<p>Now that we understand the <kbd>version</kbd> command, let's see how to check our playbook's syntax and perform a test run of our playbook. This is accomplished through the <kbd>--check</kbd> option:</p>
<pre>
<strong>Check: [#&gt; ansible foo.yml --check]</strong>
</pre>
<p>This command-line option allows you to see what some of the changes Ansible would have made would potentially be. This is a great way to simulate the execution of a playbook and is a wise first step before actually running one:</p>
<pre>
<strong>Inventory: [#&gt; ansible -i 192.x.x.x, x.x.x.x]</strong>
</pre>
<p>Specifying an inventory on the command line is important. It is accomplished via the <kbd>-inventory-file</kbd> parameter. This command-line parameter allows us to specify a comma-separated list of hostnames that will be targeted by the execution of the playbook. This command line allows you to specify a path location to an Ansible inventory file (in YAML format). Inside it, you can specify the hostnames and groups that combined make up your infrastructure inventory (the host's Ansible will be targeted during execution):</p>
<pre>
<strong>InventoryFile: [#&gt; ansible -inventory-file 192.x.x.x, x.x.x.x]</strong>
</pre>
<p>This command-line option instructs Ansible to display a list of targeted hosts for this execution. This can be useful when you have a large number of hosts separated into groups and you only want to target a subset of those hosts:</p>
<pre>
<strong>ListHosts: [#&gt; ansible -list-hosts]</strong>
</pre>
<p>This command-line option instructs Ansible to condense all logging output to one line. This includes the facts-gathering processes, task execution output, and all <kbd>STDOUT</kbd> output:</p>
<pre>
<strong>OneLine: [#&gt; ansible –-one-line]</strong>
</pre>
<p>This command-line option instructs Ansible to pipe all output to a specific file instead of the traditional console location. Output in the file specified will be concatenated in the file:</p>
<pre>
<strong>Output: [#&gt; ansible –-output &lt;filename&gt;]</strong>
</pre>
<p>This command-line option instructs Ansible to perform a syntax check on the specified playbook instead of executing it. This is useful for developers who want to ensure their playbook is in valid YAML format prior to execution:</p>
<pre>
<strong>SyntaxCheck: [#&gt; ansible –-syntax-check]</strong>
</pre>
<p>This command-line option instructs Ansible to override the default timeout (in seconds) from 10 to another number:</p>
<pre>
<strong>TimeOut: [#&gt; ansible –timeout=X]</strong>
</pre>
<p>This command-line option instructs Ansible to use a remote user login instead of the default SSH shared keys approach when connecting to remote hosts. This can be useful if SSH access is not allowed when connecting to some hosts:</p>
<pre>
<strong>User: [#&gt; ansible -u | --user =USERNAME]</strong>
</pre>
<p>This command-line option instructs Ansible to add verbose logging to the output of the execution. This is handy when debugging specific host issues or odd behavior that isn't expected from traditional execution:</p>
<pre>
<strong>Verbose: [#&gt; ansible –verbose]</strong>
</pre>
<p>For additional command-line options, consult the Ansible CLI online help or documentation. Additional online help can be found at <a href="http://www.ansible.com">http://www.ansible.com</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible command-line examples</h1>
                
            
            
                
<p>Now that we have a pretty good understanding of the various knobs that the Ansible command line provides, let's take a look at a few examples of how to use them to enhance the execution of a playbook. The following examples show some basic ways in which Ansible can be leveraged to run:</p>
<pre>
Example: Run an ad hoc command against an Ansible inventory group and limit the execution of a playbook to a max of 5 simultaneous servers:<br/><strong>$ ansible europe -a "whoami" -f 5<br/></strong><br/>Example: Execute a playbook against the Europe group as a privileged account (different from the SSH account<br/><strong>$ ansible europe -a "/usr/bin/foo" -u username --become [--ask-become-pass</strong><strong>]</strong><br/><br/>Example: Transfer a local (on the ansible control server) file to a set of remote hosts simultaneously <br/><strong>$ ansible europe -m copy -a </strong><strong>"src=/opt/myfile dest=/opt/myfile"</strong><br/><br/>Example: Running an ansible playbook against a single hostname or IP address<br/><strong>#&gt; ansible-playbook -i "192.168.10.10," -c local hellodevopsworld.yml</strong><br/><br/>Example: Running an ansible playbook against an inventory group<br/><strong>#&gt; ansible-playbook myplaybook.yml</strong>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring Ansible</h1>
                
            
            
                
<p>Ansible maintains a central configuration file, which is used to instruct Ansible on how to behave. Ansible's primary configuration file should be located (for most Linux distributions) at the following location:</p>
<pre>
 /etc/ansible/ansible.cfg 
</pre>
<p>This configuration file instructs Ansible on how to behave at runtime. During the pre-startup sequences of Ansible's execution, the configuration file is loaded into memory and sets a number of environmental flags. These flags and configuration options can help you customize the Ansible runtime. The following configuration is a snapshot of the <kbd>ansible.cfg</kbd> file.</p>
<p>Nearly all Ansible configuration options can be overridden via modifications in a playbook. Changes to this configuration file will give you the ability to set base functionality/configuration.</p>
<p>The Ansible configuration file has a pretty detailed set of documentation items associated with each configurable option available. As such, it would be redundant to provide a complete configuration file walk-through within this section. Instead, let's take a look at the more commonly tweaked configuration options.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Common base configuration items</h1>
                
            
            
                
<p>The most common base configuration items are predefined within Ansible; these values however can be overridden through the <kbd>ansible.cfg</kbd> file and customized to suit your specific needs. To override any one of them, simply uncomment the line (by removing the <kbd>#</kbd> symbol in front). These configuration items are provided as follows:</p>
<pre>
# some basic default values...<br/><br/>#inventory = /etc/ansible/hosts<br/>#library = /usr/share/my_modules/<br/>#module_utils = /usr/share/my_module_utils/<br/>#remote_tmp = ~/.ansible/tmp<br/>#local_tmp = ~/.ansible/tmp<br/>#forks = 5<br/>#poll_interval = 15<br/>#sudo_user = root<br/>#ask_sudo_pass = True<br/>#ask_pass = True<br/>#transport = smart<br/>#remote_port = 22<br/>#module_lang = C<br/>#module_set_locale = False
</pre>
<p>In addition to the base configuration overrides, Ansible has a few other interesting configuration tweaks that can be made to the base installation that provide some level of flexibility in its operational functionality.</p>
<p>Disable host key checking (useful for auto provisioning new systems) by using this:</p>
<pre>
#host_key_checking = False
</pre>
<p>By default, the system is configured to run Ansible playbooks as <kbd>root</kbd>; however, this is not always desirable. To alter this, simply uncomment the following line and specify the user you would like to use instead:</p>
<pre>
# default user to use for playbooks if user is not specified<br/># (/usr/bin/ansible will use current user as default)<br/>#remote_user = root
</pre>
<p>Sometimes disabling logging is a good thing (for those with limited space options). To disable logging, change the following configuration item:</p>
<pre>
# prevents logging of task data, off by default<br/>#no_log = False
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The Ansible Inventory</h1>
                
            
            
                
<p>Ansible maintains a central configuration file, which is used to identify and maintain the infrastructure identifications. This inventory file allows the Ansible administrator/ playbook to easily list, group, and target infrastructure items during execution. The default Ansible inventory file created (upon installation of Ansible) is <kbd>/etc/ansible/hosts</kbd>. Inside it are a few examples of basic inventory grouping structures and organizational categories for infrastructure.</p>
<p>In general, the Ansible inventory file can be leveraged to organize hosts in a couple of specific ways: as a set of defined groups, or as a set of defined infrastructure pieces (loosely defined and not in a specific group). The inventory file can leverage either of the previously described methods or a combination of the two. Let's look in greater detail on how these two inventory organization systems operate.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defined inventory groups</h1>
                
            
            
                
<p>Ansible provides a robust and feature-rich mechanism for managing the information related to the infrastructure it controls. Specifically, inventory files can be created to define the infrastructure that will be managed by Ansible. An Ansible inventory file as you may have guessed is also in YAML format. Inventory items (such as servers or devices) are typically defined within the inventory file and are often organized into logically respective groups. An example of these types of groups (with inventory items defined within) is shown within the following code block:</p>
<pre>
[databaseservers]<br/>mydbserver105.example.org<br/>mydbserver205.example.org<br/><br/>[webservers]<br/>mywbserver105.example.org<br/>mywbserver205.example.org
</pre>
<p>Based on this information, we can see there are two groups: a web server and a database server group. These groups each have two unique servers assigned to them and as such provide us with the ability to target either or both groups of infrastructure by group name.</p>
<p>Ansible inventory items don't have to be unique to one group specifically. Ansible supports the idea that hostnames or IPs can belong to one or many groups. For example, a hostname may exist both in the web server group and the database group. This adds significant flexibility within the Ansible playbook execution system.</p>
<p>Ansible by nature allows this grouping to be targeted asynchronously. This means that the automation can be executed in parallel across either group to target a specific group specified in the hosts inventory file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loose inventory items/hosts/devices</h1>
                
            
            
                
<p>Ansible provides the ability to not group any specific hosts that you want. Or mix and match grouped hosts with 'loose hosts'. This functionality allows the Ansible developer or user to simply add raw hostnames into the inventory host file and not attach it to a specific group. For this specific implementation, the hosts file would look something like the following:</p>
<pre class="mce-root">
loosehost.example.com<br/><br/>[webservers]<br/>foo.mycorp.com<br/>bar.mycorp.com<br/><br/>[dbservers]<br/>apple.mycorp.com<br/>pear.mycorp.com<br/>peaches.mycorp.com 
</pre>
<p>As you can see from the screenshot, the raw entries that are not grouped are simply organized by IP address or hostname at the top of the inventory hosts file. This allows you to target these hosts by default automatically and without specifying a targeted group name on the command line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Executing playbook's and targeting specific inventory files and groups</h1>
                
            
            
                
<p>Now that we have a set of inventory groups or raw inventory items defined, the next step is to see how to call Ansible and target a specific set of groups or even inventory files (if different from the default <kbd>/etc/Ansible/hosts</kbd> file). This functionality is incredibly important as we gain experience using Ansible. Let's take a look at how to target specific groups first. The following example provides a simple example of an Ansible command line that executes a playbook against a grouped inventory:</p>
<pre>
<strong>#&gt; ansible playbookfoo.yml -l 'groupname'</strong>
</pre>
<p>As we can see from the example, we can execute Ansible playbooks against specific infrastructure groups. The outcome of these executions is the execution of a set of automated tasks against the group's infrastructure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we discussed the various architecture types that Ansible provides, we talked about how inventory files work, and how to target specific groups and servers using the <kbd>-l</kbd> command. We also talked about how to install, set up, and configure Ansible to work under most common conditions. In our examples we look at a lot of Ubuntu specific implementations but the conversion to other OS's should be easy.</p>
<p>In the next chapter, we will learn all about playbook files and inventory file extensibility as well as how to create additional inventory files to help manage your infrastructure more effectively. Playbook's represent the heart and soul of the Ansible platform and instruct it on how to behave on a given server or infrastructure.</p>
<p>By the time we complete the next chapter, we should begin to have the skills you will need to write a playbook and execute it against one of a few machines. In addition, you should be able to perform most basic Configuration Management and deployment tasks using Ansible. Also, upon completing this chapter, you should have a solid understanding of how Ansible inventories work and how to effectively create groups and manage infrastructure at scale.</p>


            

            
        
    </body></html>