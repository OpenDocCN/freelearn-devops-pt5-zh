<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Bringing In Your Code – Custom Commands and Scripts</h1></div></div></div><p>Ansible comes with a wide variety of built-in modules that allow us to manage various system components, for example, users, packages, network, files, and services. Ansible's battery-included approach also provides the ability to integrate the components with cloud platforms, databases, and applications such as <strong>Jira</strong>, <strong>Apache</strong>, <strong>IRC</strong>, and <strong>Nagios</strong>, and so on. However, every now and then, we would find ourselves in a position where we may not find a module that exactly does the job for us. For example, installing a package from source involves downloading it, extracting a source tarball, followed by the make command, and finally, "make install". There is no single module that does this. There will also be times when we would like to bring in our existing scripts that we have spent nights creating and just have them invoked or scheduled with Ansible, for example, nightly backup scripts. Ansible's command modules would come to our rescue in such situations.</p><p>In this chapter, we are going to introduce you to:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to run custom commands and scripts</li><li class="listitem" style="list-style-type: disc">Ansible command modules: raw, command, shell, and script</li><li class="listitem" style="list-style-type: disc">How to control the idempotence of a command module</li><li class="listitem" style="list-style-type: disc">Registered variables</li><li class="listitem" style="list-style-type: disc">How to create a WordPress application</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec36"/>The command modules</h1></div></div></div><p>Ansible has four modules that fall in to this category and provide us the options to choose from while running system <a id="id128" class="indexterm"/>commands or scripts. The four modules are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Raw</li><li class="listitem" style="list-style-type: disc">Command</li><li class="listitem" style="list-style-type: disc">Shell</li><li class="listitem" style="list-style-type: disc">Script</li></ul></div><p>We will start learning about these one at a time.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Using the raw module</h2></div></div></div><p>Most Ansible modules <a id="id129" class="indexterm"/>require Python to be present on the target node. However, as the name suggests, a raw module provides a way to communicate with <a id="id130" class="indexterm"/>hosts over SSH to execute raw commands without getting Python involved. The use of this module will bypass the module subsystem of Ansible completely. This can come in really handy in certain special situations or cases. For example:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For legacy systems running a Python version older than 2.6, Ansible requires the <code class="literal">Python-simplejson</code> package to be installed before you run playbooks. A raw module can be used to connect to the target host and install the prerequisite package before executing any Ansible code.</li><li class="listitem" style="list-style-type: disc">In the case of network devices, such as routers, switches, and other embedded systems, Python may not be present at all. These devices can still be managed with Ansible simply using a raw module.</li></ul></div><p>Apart from these exceptions, for all other cases, it is recommended that you use either command or shell modules, as they offer ways to control when, from where, and how the commands are run.</p><p>Let's take a look at the following given examples:</p><div><pre class="programlisting">
<strong>$ ansible -i customhosts all  -m raw -a "uptime"</strong>
<strong>[Output]</strong>
<strong>192.168.61.13 | success | rc=0 &gt;&gt;</strong>
<strong> 04:21:10 up 1 min,  1 user,  load average: 0.27, 0.10, 0.04</strong>
<strong>192.168.61.11 | success | rc=0 &gt;&gt;</strong>
<strong> 04:21:10 up 5 min,  1 user,  load average: 0.01, 0.07, 0.05</strong>
<strong>192.168.61.12 | success | rc=0 &gt;&gt;</strong>
<strong> 04:21:12 up  9:04,  1 user,  load average: 0.00, 0.01, 0.05</strong>
</pre></div><p>The preceding command connects to all the hosts in the inventory provided with <code class="literal">customhosts</code> using SSH, runs a raw command uptime, and returns the results. This would work even if the <a id="id131" class="indexterm"/>target host does not have Python installed. This is equivalent to writing a <code class="literal">for</code> loop to an ad hoc shell command on a group of hosts.</p><p>The same <a id="id132" class="indexterm"/>command can be converted to a task as:</p><div><pre class="programlisting">   - name: running a raw command 
     raw: uptime</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>Using the command module</h2></div></div></div><p>This is the most <a id="id133" class="indexterm"/>recommended module for executing commands on target nodes. This module takes the free-form command sequence and allows you to run any command that could be launched from a command-line interface. In addition to the command, we could optionally specify:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Which directory to run the command from</li><li class="listitem" style="list-style-type: disc">Which shell to use for execution</li><li class="listitem" style="list-style-type: disc">When not to run the commands</li></ul></div><p>Let's take a look at the following example:</p><div><pre class="programlisting">   - name: run a command on target node
     command: ls -ltr
     args:
       chdir: /etc</pre></div><p>Here, a command module is called to run <code class="literal">ls -ltr</code> on the target hosts with an argument to change the directory to <code class="literal">/etc</code> before running the command.</p><p>In addition to writing it as a task, the command module can directly be invoked as:</p><div><pre class="programlisting">
<strong>$ ansible -i customhosts all  -m command -a "ls -ltr"</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>Using the shell module</h2></div></div></div><p>This module is very <a id="id134" class="indexterm"/>similar to the command module we just learnt about. It takes a free-form command and optional parameters and executes them on the target node. However, there are subtle differences between shell modules and command modules, which are listed, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Shell runs the <a id="id135" class="indexterm"/>command through the '/<code class="literal">bin/sh</code>' shell on the target host, which also means that any command that gets executed with this module has access to all the shell variables on that system</li><li class="listitem" style="list-style-type: disc">Unlike the command module, shell also allows the usage of operators, such as redirects ( <code class="literal">&lt;, &lt;&lt;, &gt;&gt; , &gt;</code> ), pipes ( | ) , &amp;&amp;, and ||</li><li class="listitem" style="list-style-type: disc">Shell is less secure than a command module, as it can be affected by a shell environment on the remote host</li></ul></div><p>Let's take a look at the following example:</p><div><pre class="programlisting">   - name: run a shell command on target node
     shell: ls -ltr | grep host &gt;&gt; /tmp/hostconfigs
     args:
       chdir: /etc</pre></div><p>Similar to using the command module, the preceding task runs the command sequence with the shell module. However, in this case, it accepts operators such as <code class="literal">|</code> and <code class="literal">&gt;&gt;</code>, does filtering with <code class="literal">grep</code>, and redirects the results to a file.</p><p>Instead of specifying this <a id="id136" class="indexterm"/>task as part of the playbook, it can be run as an ad hoc command with Ansible as:</p><div><pre class="programlisting">ansible -i customhosts all --sudo -m shell \
 -a "ls -ltr | grep host &gt;&gt; /tmp/hostconfigs2 \
chdir=/etc"</pre></div><p>Here, you need to explicitly specify the <code class="literal">--sudo</code> option, as well as module options as arguments, such as <code class="literal">chdir=/etc</code> and the actual command sequence.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Using the script module</h2></div></div></div><p>The command <a id="id137" class="indexterm"/>modules that we learnt about so far only allow the execution <a id="id138" class="indexterm"/>of some system commands on the remote host. There will be situations where we would have an existing script that needs to be copied to the remote hosts and then executed there. Using the shell or command modules, this could be achieved in the following two steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Use a copy module to transfer the script file to a remote host.</li><li class="listitem">Then, use a command or shell module to execute the script transferred previously.</li></ol></div><p>Ansible has a tailor-made module that solves this in a more efficient way. Using a script module instead of command or shell, we can copy and execute a script in one step.</p><p>For example, consider <a id="id139" class="indexterm"/>the following code snippet:</p><div><pre class="programlisting">   - name: run script sourced from inside a role
     script:  backup.sh
   - name: run script sourced from a system path on target host
     script: /usr/local/bin/backup.sh</pre></div><p>As shown in the <a id="id140" class="indexterm"/>preceding code snippet, a script can be sourced either from:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An inside file directory of the role when invoking this module from a task inside a role as shown in the first example</li><li class="listitem" style="list-style-type: disc">An absolute system path on the control host (this is the host that runs Ansible commands)</li></ul></div><p>Just like all the other modules, a script can also be invoked as an ad hoc command, as follows:</p><div><pre class="programlisting">
<strong>$ ansible -i customhosts www --sudo -m script \</strong>

  -a "/usr/local/backup.sh"</pre></div><p>Here, the <code class="literal">script</code> module is invoked only on hosts that are part of the <code class="literal">www</code> group in the inventory. This command will copy a script at <code class="literal">/usr/local/backup.sh</code> from the control host and run it on the target nodes; in this case, all hosts in the <code class="literal">www</code> group.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec37"/>Deploying a WordPress application – a hands-on approach</h1></div></div></div><p>In our first <a id="id141" class="indexterm"/>iteration, we already configured an Nginx web server and a MySQL database to host a simple web page. We will now configure a WordPress application on the web server to host news and blogs.</p><div><div><h3 class="title"><a id="note04"/>Note</h3><p>
<strong>Scenario:</strong>
</p><p>Following our success of launching a simple web page in iteration 1, the project management department has asked us to set up a WordPress application to serve news articles and blogs in iteration 2.</p></div></div><p>WordPress is a popular open source web publishing framework based on the LAMP platform, which is Linux, Apache, MySQL, and PHP. WordPress is a simple, yet flexible, open source application that powers a lot of blogs and dynamic websites. Running WordPress requires a web server, PHP, and MySQL database. We already have an Nginx web server and MySQL database configured. We will begin by installing and configuring WordPress by creating a role for it and then later on, we will configure PHP.</p><p>To create the role, we will use the Ansible-Galaxy tool that we learnt about in the previous chapter:</p><div><pre class="programlisting">
<strong>$ ansible-galaxy init --init-path roles/ wordpress</strong>
</pre></div><p>This will create the scaffolding required for the WordPress role. By now, we know that the core logic goes in <a id="id142" class="indexterm"/>to tasks and is supported by files, templates, handlers, and so on. We will begin by writing tasks to install and configure WordPress. First, we will create the main tasks file as follows:</p><div><pre class="programlisting">---
# tasks file for wordpress
# filename: roles/wordpress/tasks/main.yml
 - include: install.yml 
 - include: configure.yml</pre></div><div><div><h3 class="title"><a id="note05"/>Note</h3><p>We are following best practices and further modularizing tasks here. Instead of putting everything in the <code class="literal">main.yml</code> file, we will create a <code class="literal">install.yml</code> file and a <code class="literal">configure.yml</code> file and include them from the main file.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>Installing WordPress</h2></div></div></div><p>The installation <a id="id143" class="indexterm"/>process of WordPress will be handled from the <code class="literal">install.yml</code> <a id="id144" class="indexterm"/>file in the tasks directory. The process of installing WordPress typically involves:</p><div><ol class="orderedlist arabic"><li class="listitem">Downloading the WordPress installation package from <a class="ulink" href="https://wordpress.org">https://wordpress.org</a>.</li><li class="listitem">Extracting the installation package.</li><li class="listitem">Moving the extracted directory inside the document's <code class="literal">root</code> directory of the web server.</li></ol></div><p>We will start writing <a id="id145" class="indexterm"/>code for each of the preceding steps mentioned, as follows:</p><div><pre class="programlisting">---
# filename: roles/wordpress/tasks/install.yml
  - name: download wordpress
    command: /usr/bin/wget -c https://wordpress.org/latest.tar.gz
    args: 
      chdir: "{{ wp_srcdir }}"
      creates: "{{ wp_srcdir }}/latest.tar.gz"
    register: wp_download</pre></div><p>We saw some new features in the preceding steps. Let's analyze this code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are using a new style to write tasks. In addition to using key-value pairs for tasks, we could separate parameters and write them one parameter per line in the key-value format.</li><li class="listitem" style="list-style-type: disc">To download the <a id="id146" class="indexterm"/>WordPress installer, we used the command module with the <code class="literal">wget</code> command. The command takes the executable sequence with additional arguments, which are <code class="literal">chdir</code>, and <code class="literal">creates</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Creates</code> is a special option here. With this, we specified the path to the file where WordPress installer is being downloaded. We will look at how this is useful.</li><li class="listitem" style="list-style-type: disc">We also registered the result of this module in a variable with the name <code class="literal">wp_download</code>, which we will use in subsequent tasks.</li></ul></div><div><div><h3 class="title"><a id="tip13"/>Tip</h3><p>It is recommended that you use the <code class="literal">get_url</code> module, which is built in to Ansible to download files using the HTTP/FTP protocol. Since we want to demonstrate the usage of command modules, we chose to use that instead of using the <code class="literal">get_url</code> module.</p></div></div><p>Let's now look at the new concepts that we introduced previously.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Controlling the idempotence of command modules</h3></div></div></div><p>Ansible <a id="id147" class="indexterm"/>comes with a wide range of modules built in it. As we learnt in <a class="link" href="ch01.html" title="Chapter 1. Blueprinting Your Infrastructure">Chapter 1</a>, <em>Blueprinting Your Infrastructure</em>, most of these modules are idempotent, and the logic to determine the configuration drift is built in to the module code.</p><p>However, command modules allow us to run shell commands that are not idempotent by nature. Since <a id="id148" class="indexterm"/>command modules have no way to determine the outcome of the task, it is expected that these modules are not idempotent by default. Ansible provides us with a few options to make these modules run conditionally and make them idempotent.</p><p>The following are the two parameters that determine whether a command is run or not:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Creates</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">Removes</code></li></ul></div><p>Both accept filename as the value of the parameter. In the case of <code class="literal">creates</code>, the command will not run if the file exists. The <code class="literal">removes</code> command does the opposite.</p><p>The "creates" and "removes" options are applicable for all command modules except for raw.</p><p>Here are some <a id="id149" class="indexterm"/>guidelines on how to use <code class="literal">creates</code> and <code class="literal">removes</code> flags:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the command sequence or script that you are executing creates a file, provide that filename as a parameter value</li><li class="listitem" style="list-style-type: disc">If the command sequence does not create a flag, make sure you incorporate the logic of creating a flag file in your command sequence or script</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec08"/>The registered variables</h3></div></div></div><p>We looked at <a id="id150" class="indexterm"/>variables earlier. However, we have never registered one before. In the tasks that we wrote to download WordPress, we use the following option:</p><div><pre class="programlisting">           register: wp_download</pre></div><p>This option stores the result of the task in a variable by the name <code class="literal">wp_download</code>. This registered result can then be accessed later. The following are some of the important components of a registered variable:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">changed</code>: This shows the status of whether the state was changed</li><li class="listitem" style="list-style-type: disc"><code class="literal">cmd</code>: Through this, the command sequence is launched</li><li class="listitem" style="list-style-type: disc"><code class="literal">rc</code>: This refers to the return code</li><li class="listitem" style="list-style-type: disc"><code class="literal">stdout</code>: This is the output of the command</li><li class="listitem" style="list-style-type: disc"><code class="literal">stdout_lines</code>: This is the output line by line</li><li class="listitem" style="list-style-type: disc"><code class="literal">stderr</code>: These state the errors, if any</li></ul></div><p>These can then be accessed as <code class="literal">wp_download.rc</code>, <code class="literal">wp_download.stdout</code> and could be used inside a template, in an action line, or more commonly, with the <code class="literal">when</code> statements. In this case, we are going to use the return code of <code class="literal">wp_download</code> to decide whether to extract the package <a id="id151" class="indexterm"/>or not. This makes sense because there is no point in extracting a file that does not even exist.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec09"/>Extracting WordPress with a shell module</h3></div></div></div><p>Let's now <a id="id152" class="indexterm"/>write a task to extract the WordPress <a id="id153" class="indexterm"/>installer and move it to the desired location. Before this, we also need to make sure that the document <code class="literal">root</code> directory has been created before running this code:</p><div><pre class="programlisting">  # filename: roles/wordpress/tasks/install.yml
  - name: create nginx docroot
    file:
      path: "{{ wp_docroot }}"
      state: directory
      owner: "{{ wp_user }}"
      group: "{{ wp_group }}"

  - name: extract wordpress
    shell: "tar xzf latest.tar.gz &amp;&amp; mv wordpress {{ wp_docroot }}/{{ wp_sitedir }}"
    args: 
      chdir: "{{ wp_srcdir }}"
      creates: "{{ wp_docroot }}/{{ wp_sitedir }}"
    when: wp_download.rc == 0</pre></div><p>Let's now analyze what we just wrote:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We use the <code class="literal">file</code> module to create the document root directory for a web server. Parameters such as path, user, and group all come from variables.</li><li class="listitem" style="list-style-type: disc">To extract WordPress, we use the <code class="literal">shell</code> module instead of a command. This is because we are combining the two commands with the <code class="literal">&amp;&amp;</code> operator here, which the command module does not support.</li><li class="listitem" style="list-style-type: disc">We use the <code class="literal">when</code> statement to decide whether to run extract commands or not. To <a id="id154" class="indexterm"/>check the condition, we <a id="id155" class="indexterm"/>use the return code of the download command that we stored in the registered variable <code class="literal">wp_download</code> earlier.</li></ul></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>Configuring WordPress</h2></div></div></div><p>After downloading and <a id="id156" class="indexterm"/>extracting WordPress, the next step is to configure it. The main configuration for WordPress is inside <code class="literal">wp-config.php</code> under the <code class="literal">wordpress</code> directory that we extracted. As a good practice, we will use a template to manage this configuration file. The following is the code to configure WordPress:</p><div><pre class="programlisting">---
# filename: roles/wordpress/tasks/configure.yml
  - name: change permissions for wordpress site
    file:
      path: "{{ wp_docroot }}/{{ wp_sitedir }}"
      state: directory
      owner: "{{ wp_user }}"
      group: "{{ wp_group }}"
      recurse: true

  - name: get unique salt for wordpress
    local_action: command curl https://api.wordpress.org/secret-key/1.1/salt
    register: wp_salt

  - name: copy wordpress template
    template:
      src: wp-config.php.j2
      dest: "{{ wp_docroot }}/{{ wp_sitedir }}/wp-config.php"
      mode: 0644</pre></div><p>Let's analyze this code:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The first task sets permissions for all WordPress files recursively.</li><li class="listitem" style="list-style-type: disc">The second task runs a command locally and registers the results in the <code class="literal">wp_salt</code> variable. This is to provide WordPress with secret keys for additional security. This variable will be used inside a template this time.</li><li class="listitem" style="list-style-type: disc">The final task is to generate a Jinja2 template and copy it over to the target host as the <code class="literal">wp-config.php</code> file.</li></ul></div><p>Let's also look at the <a id="id157" class="indexterm"/>Jinja2 template:</p><div><pre class="programlisting"># filename: roles/wordpress/templates/wp-config.php.j2
&lt;?php
define('DB_NAME', 'wp_dbname');
define('DB_USER', 'wp_dbuser');
define('DB_PASSWORD', '{{ wp_dbpass }}');
define('DB_HOST', '{{ wp_dbhost }}');
define('DB_CHARSET', 'utf8');
define('DB_COLLATE', '');
{{ wp_salt.stdout }}
$table_prefix  = 'wp_';
define('WP_DEBUG', false);
if ( !defined('ABSPATH') )
  define('ABSPATH', dirname(__FILE__) . '/');
require_once(ABSPATH . 'wp-settings.php');</pre></div><p>Here, we are filling in the values of the configuration parameters from variables. What is also interesting is that we are embedding the output of the salt download using the <code class="literal">stdout</code> variables:</p><div><pre class="programlisting">            {{ wp_salt.stdout }}</pre></div><p>The resulting file that is <a id="id158" class="indexterm"/>created from this template after filling in the variables and the <code class="literal">stdut</code> from a registered variable will be as follows:</p><div><img src="img/B03800_04_01.jpg" alt="Configuring WordPress"/></div><p>We will now add this new role to the <code class="literal">www.yml</code> playbook, so that it gets executed on all our web servers:</p><div><pre class="programlisting">#filename: www.yml
  roles:
     - nginx
     - wordpress</pre></div><p>Then, we will run the Ansible playbook only for web servers as:</p><div><pre class="programlisting">
<strong>$ ansible-playbook www.yml  -i customhosts</strong>
</pre></div><p>This will download, extract, and configure WordPress on all web server hosts. We still have not installed PHP <a id="id159" class="indexterm"/>and configured Nginx to serve WordPress pages, so our changes won't be reflected as yet.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec38"/>Review questions</h1></div></div></div><p>Do you think you've understood the chapter well enough? Try answering the following questions to test your understanding:</p><div><ol class="orderedlist arabic"><li class="listitem">Why do we need command modules when Ansible has a battery-included approach?</li><li class="listitem">When and why do we use the raw module?</li><li class="listitem">How do we use the <code class="literal">creates</code> parameter with a shell when the command being executed does not create a file?</li><li class="listitem">How are <code class="literal">command</code> and <code class="literal">shell</code> modules different? When would you use a shell?</li><li class="listitem">If <code class="literal">var3</code> is a registered variable, how would you print its output in a template?</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec39"/>Summary</h1></div></div></div><p>In this chapter, you learnt about how to run custom commands and scripts using Ansible's command modules, that is, raw, command, shell, and script. You also learnt how to control the idempotence of command modules using the <code class="literal">creates</code> and <code class="literal">removes</code> flags. We started using registered variables to store the result of a task that can then be used later to conditionally run other tasks or embed output in a template. Finally, we created a role to install and configure a WordPress application.</p><p>In the next chapter, we are going to start learning about how to control execution flow using conditionals, how to apply roles selectively, and also how to use conditional control structures in templates.</p></div></body></html>