- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Volumes and Configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build and share our container images.
    Focus was placed on how to build images that are as small as possible by only
    containing artifacts that are needed by the containerized application.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how we can work with stateful containers
    – that is, containers that consume and produce data. We will also learn how to
    configure our containers at runtime and at image build time, using environment
    variables and config files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the topics we’re going to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using host volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining volumes in images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After working through this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create, delete, and list data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount an existing data volume into a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create durable data from within a container using a data volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Share data between multiple containers using data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount any host folder into a container using data volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the access mode (read/write or read-only) for a container when accessing
    data in a data volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure environment variables for applications running in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameterize a Dockerfile by using build arguments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you need Docker Desktop installed on your machine. There is
    no code accompanying this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, we need to create a folder for [*Chapter 5*](B19199_05.xhtml#_idTextAnchor109)
    inside our code repository:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this command to navigate to the folder where you checked out the code from
    GitHub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you did not check out the GitHub repository at the default location, the
    preceding command may vary for you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a sub-folder for [*Chapter 5*](B19199_05.xhtml#_idTextAnchor109) and
    navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating and mounting data volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All meaningful applications consume or produce data. Yet containers are, ideally,
    meant to be stateless. How are we going to deal with this? One way is to use Docker
    volumes. Volumes allow containers to consume, produce, and modify a state. Volumes
    have a life cycle that goes beyond the life cycle of containers. When a container
    that uses a volume dies, the volume continues to exist. This is great for the
    durability of the state.
  prefs: []
  type: TYPE_NORMAL
- en: Modifying the container layer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we dive into volumes, let’s first discuss what happens if an application
    in a container changes something in the filesystem of the container. In this case,
    the changes are all happening in the writable container layer that we introduced
    in [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083), *Creating and Managing Container
    Images*. Let’s quickly demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a container and execute a script in it that is creating a new file, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command creates a container named `demo`, and, inside this container,
    creates a file called `sample.txt` with the content `This is a test`. The container
    exits after running the `echo` command but remains in memory, available for us
    to do our investigations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s use the `diff` command to find out what has changed in the container’s
    filesystem concerning the filesystem of the original image, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: A new file, as indicated by the letter `A`, has been added to the filesystem
    of the container, as expected. Since all layers that stem from the underlying
    image (Alpine, in this case) are immutable, the change could only happen in the
    writeable container layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Files that have changed compared to the original image will be marked with a
    `C` and those that have been deleted with a `D`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we remove the container from memory, its container layer will also be
    removed, and with it, all the changes will be irreversibly deleted. If we need
    our changes to persist even beyond the lifetime of the container, this is not
    a solution. Luckily, we have better options, in the form of Docker volumes. Let’s
    get to know them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When using Docker Desktop on a macOS or Windows computer, containers are not
    running natively on macOS or Windows but rather in a (hidden) VM created by Docker
    Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate how and where the underlying data structures are created in the
    respective filesystem (macOS or Windows), we need to be a bit creative. If, on
    the other hand, we are doing the same on a Linux computer, things are straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start with a simple exercise to create a volume:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal window and type in this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should get this response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, the name of the created volume will be the output.
  prefs: []
  type: TYPE_NORMAL
- en: The default volume driver is the so-called **local driver**, which stores the
    data locally in the host filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest way to find out where the data is stored on the host is by using
    the `docker volume inspect` command on the volume we just created. The actual
    location can differ from system to system, so this is the safest way to find the
    target folder. So, let’s use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Inspecting the Docker volume called sample](img/B19199_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Inspecting the Docker volume called sample
  prefs: []
  type: TYPE_NORMAL
- en: The host folder can be found in the output under `Mountpoint`. In our case,
    the folder is `/var/lib/docker/volumes/sample/_data`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can create a volume using the dashboard of Docker Desktop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Dashboard of Docker Desktop.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: On the left-hand side, select the **Volumes** tab.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the top-right corner, click the **Create** button, as shown in the following
    screenshot:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Creating a new Docker volume with Docker Desktop](img/B19199_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Creating a new Docker volume with Docker Desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in `sample-2` as the name for the new volume and click **Create**. You
    should now see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – List of Docker volumes shown in Docker Desktop](img/B19199_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – List of Docker volumes shown in Docker Desktop
  prefs: []
  type: TYPE_NORMAL
- en: There are other volume drivers available from third parties, in the form of
    plugins. We can use the `--driver` parameter in the `create` command to select
    a different volume driver.
  prefs: []
  type: TYPE_NORMAL
- en: Other volume drivers use different types of storage systems to back a volume,
    such as cloud storage, **Network File System** (**NFS**) drives, software-defined
    storage, and more. The discussion of the correct usage of other volume drivers
    is beyond the scope of this book, though.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting a volume
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we have created a named volume, we can mount it into a container by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, we can use the `--volume` or `-v` parameter in the `docker container
    run` command, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you are working on a clean Docker environment, then the output produced
    by this command should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, you should just see the prompt of the Bourne shell running inside
    the Alpine container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command mounts the sample volume to the `/data` folder inside
    the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the container, we can now create files in the `/data` folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we were to navigate to the host folder that contains the data of the volume
    and list its content, we should see the two files we just created inside the container.
    But this is a bit more involved so long as we are working on a Mac or Windows
    computer and will be explained in detail in the *Accessing Docker volumes* section.
    Stay tuned.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit the tool container by pressing *Ctrl* + *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s delete the dangling `test` container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we must run another one based on CentOS. This time, we are even mounting
    our volume to a different container folder, `/app/data`, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see an output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The last line of the preceding output indicates that we are at the prompt of
    the Bash shell running inside the CentOS container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once inside the CentOS container, we can navigate to the `/app/data` folder
    to which we have mounted the volume and list its content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As expected, we should see these two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is the definitive proof that data in a Docker volume persists beyond the
    lifetime of a container, as well as that volumes can be reused by other, even
    different, containers from the one that used it first.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the folder inside the container to which we mount
    a Docker volume is excluded from the Union filesystem. That is, each change inside
    this folder and any of its subfolders will not be part of the container layer
    but will be persisted in the backing storage provided by the volume driver. This
    fact is really important since the container layer is deleted when the corresponding
    container is stopped and removed from the system.
  prefs: []
  type: TYPE_NORMAL
- en: Exit the CentOS container with *Ctr*l + *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Great – we have learned how to mount Docker volumes into a container! Next,
    we will learn how to delete existing volumes from our system.
  prefs: []
  type: TYPE_NORMAL
- en: Removing volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Volumes can be removed using the `docker volume rm` command. It is important
    to remember that removing a volume destroys the containing data irreversibly,
    and thus is to be considered a dangerous command. Docker helps us a bit in this
    regard, as it does not allow us to delete a volume that is still in use by a container.
    Always make sure before you remove or delete a volume that you either have a backup
    of its data or you don’t need this data anymore. Let’s learn how to remove volumes
    by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command deletes the sample volume that we created earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After executing the preceding command, double-check that the folder on the
    host has been deleted. You can use this command to list all volumes defined on
    your system:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the `sample` volume has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Now, also remove the `sample-2` volume from your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To remove all running containers to clean up the system, run the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that by using the `-v` or `--volume` flag in the command you use to remove
    a container, you can ask the system to also remove any anonymous volume associated
    with that particular container. Of course, that will only work if the particular
    volume is only used by this container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we will show you how to access the backing folder of a
    volume when working with Docker Desktop.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing Docker volumes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s for a moment assume that we are on a Mac with macOS. This operating
    system is not based on Linux but on a different Unix flavor. Let’s see whether
    we can find the data structure for the `sample` and `sample-2` volumes, where
    the `docker volume inspect` command told us so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create two named Docker volumes, either using the command line
    or doing the same via the dashboard of Docker Desktop:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In your Terminal, try to navigate to that folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the author’s MacBook Air, this is the response to the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This was expected since Docker is not running natively on Mac but inside a slim
    VM, as mentioned earlier in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, if you are using a Windows machine, you won’t find the data where
    the `inspect` command indicated.
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that on a Mac, the data for the VM that Docker creates can be found
    in the `~/``Library/Containers/com.docker.docker/Data/vms/0` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To access this data, we need to somehow get into this VM. On a Mac, we have
    two options to do so. The first is to use the `terminal screen` command. However,
    this is very specific to macOS and thus we will not discuss it here. The second
    option is to get access to the filesystem of Docker on Mac via the special `nsenter`
    command, which should be executed inside a Linux container such as Debian. This
    also works on Windows, and thus we will show the steps needed using this second
    option.
  prefs: []
  type: TYPE_NORMAL
- en: 'To run a container that can inspect the underlying host filesystem on your
    system, use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When running the container, we execute the following command inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If that sounds complicated to you, don’t worry; you will understand more as
    we proceed through this book. If there is one takeaway, then it is to realize
    how powerful the right use of containers can be.
  prefs: []
  type: TYPE_NORMAL
- en: 'From within this container, we can now list all the volumes that are defined
    with `/ # ls -l /var/lib/docker/volumes`. What we get should look similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – List of Docker volumes via nsenter](img/B19199_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – List of Docker volumes via nsenter
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, navigate to the folder representing the mount point of the volume:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And then list its content, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The folder is currently empty since we have not yet stored any data in the volume.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, for our `sample-2` volume, we can use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Again, this indicates that the folder is currently empty.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s generate two files with data in the `sample` volume from within
    an Alpine container. First, open a new Terminal window, since the other one is
    blocked by our `nsenter` session.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To run the container and mount the `sample` volume to the `/data` folder of
    the container, use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Generate two files in the `/data` folder inside the container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exit the Alpine container by pressing *Ctrl* + *D*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in the `nsenter` session, try to list the content of the sample volume
    again using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This indicates that we have data written to the filesystem of the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try to create a file from within this special container, and then list
    the content of the folder, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s see what we got:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This gives us something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see whether we can see this new file from within a container mounting
    the sample volume. From within a new Terminal window, run this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That should output this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is showing us that we can add content directly to the host
    folder backing the volume and then access it from a container that has the volume
    mounted.
  prefs: []
  type: TYPE_NORMAL
- en: To exit our special privileged container with the `nsenter` tool, we can just
    press *Ctrl* + *D* twice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have now created data using two different methods:'
  prefs: []
  type: TYPE_NORMAL
- en: From within a container that has a sample volume mounted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a special privileged folder to access the hidden VM used by Docker Desktop,
    and directly writing into the backing folder of the sample volume
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to share data between containers.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing data between containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers are like sandboxes for the applications running inside them. This
    is mostly beneficial and wanted, to protect applications running in different
    containers from each other. It also means that the whole filesystem visible to
    an application running inside a container is private to this application, and
    no other application running in a different container can interfere with it.
  prefs: []
  type: TYPE_NORMAL
- en: At times, though, we want to share data between containers. Say an application
    running in **container A** produces some data that will be consumed by another
    application running in **container B**. How can we achieve this? Well, I’m sure
    you’ve already guessed it – we can use Docker volumes for this purpose. We can
    create a volume and mount it to container A, as well as to container B. In this
    way, both applications A and B have access to the same data.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as always when multiple applications or processes concurrently access data,
    we have to be very careful to avoid inconsistencies. To avoid concurrency problems
    such as race conditions, we should ideally have only one application or process
    that is creating or modifying data, while all other processes concurrently accessing
    this data only read it.
  prefs: []
  type: TYPE_NORMAL
- en: Race condition
  prefs: []
  type: TYPE_NORMAL
- en: A race condition is a situation that can occur in computer programming when
    the output of a program or process is affected by the order and timing of events
    in ways that are unpredictable or unexpected. In a race condition, two or more
    parts of a program are trying to access or modify the same data or resource simultaneously,
    and the outcome depends on the timing of these events. This can result in incorrect
    or inconsistent output, errors, or crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can enforce a process running in a container to only be able to read the
    data in a volume by mounting this volume as read-only. Here’s how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are creating a container called `writer` that has a volume, `shared-data`,
    mounted in default read/write mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to create a file inside this container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should succeed.
  prefs: []
  type: TYPE_NORMAL
- en: Exit this container by pressing *Ctrl* + *D* or typing `exit` and hitting the
    *Enter* key at the prompt.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we have a container called `reader` that has the same volume mounted as
    **read-only** (**ro**).
  prefs: []
  type: TYPE_NORMAL
- en: 'First, make sure you can see the file created in the first container, like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This should give you something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, try to create a file, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It will fail with the following message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This is expected since the volume was mounted as read-only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s exit the container by typing `exit` at the command prompt. Back on the
    host, let’s clean up all containers and volumes, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Exercise**: Analyze the preceding commands carefully and try to understand
    what exactly they do and how they work.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will show you how to mount arbitrary folders from the Docker host into
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: Using host volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In certain scenarios, such as when developing new containerized applications
    or when a containerized application needs to consume data from a certain folder
    produced – say, by a legacy application – it is very helpful to use volumes that
    mount a specific host folder. Let’s look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The preceding expression interactively starts an Alpine container with a shell
    and mounts the `src` subfolder of the current directory into the container at
    `/app/src`. We need to use `$(pwd)` (or `pwd`, for that matter), which is the
    current directory, as when working with volumes, we always need to use absolute
    paths.
  prefs: []
  type: TYPE_NORMAL
- en: Developers use these techniques all the time when they are working on their
    application that runs in a container and wants to make sure that the container
    always contains the latest changes to the code, without the need to rebuild the
    image and rerun the container after each change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s make a sample to demonstrate how that works. Let’s say we want to create
    a simple static website while using Nginx as our web server, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a new subfolder on the host. The best place to do this
    is inside the chapter folder we created at the beginning of the chapter. There,
    we will put our web assets such as HTML, CSS, and JavaScript files. Use this command
    to create the subfolder and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, create a simple web page, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add a Dockerfile that will contain instructions on how to build the image
    containing our sample website. Add a file called `Dockerfile` to the folder, with
    this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The Dockerfile starts with the latest Alpine version of Nginx and then copies
    all files from the current host directory into the `/usr/share/nginx/html` containers
    folder. This is where Nginx expects web assets to be located.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s build the image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Please do not forget the period (`.`) at the end of the preceding command.
    The output of this command will look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Building a Docker image for a sample Nginx web server](img/B19199_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – Building a Docker image for a sample Nginx web server
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will run a container from this image. We will run the container
    in detached mode, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the `-p 8080:80` parameter. We haven’t discussed this yet, but we will
    do so in detail in [*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using* *Single-Host
    Networking*. At the moment, just know that this maps the container port `80` on
    which Nginx is listening for incoming requests to port `8080` of your laptop,
    where you can then access the application.
  prefs: []
  type: TYPE_NORMAL
- en: Now, open a browser tab and navigate to `http://localhost:8080/index.xhtml`;
    you should see your website, which currently consists only of a title, **Personal
    Website**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, edit the `index.xhtml` file in your favorite editor so that it looks like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, save it, and then refresh the browser. Oh! That didn’t work. The browser
    still displays the previous version of the `index.xhtml` file, which consists
    only of the title. So, let’s stop and remove the current container, then rebuild
    the image and rerun the container, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Refresh the browser again. This time, the new content should be shown. Well,
    it worked, but there is way too much friction involved. Imagine having to do this
    every time that you make a simple change to your website. That’s not sustainable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now is the time to use host-mounted volumes. Once again, remove the current
    container and rerun it with the volume mount, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you are working on Windows, a pop-up window will be displayed that says Docker
    wants to access the hard drive and that you have to click on the **Share** **access**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Now, append some more content to the `index.xhtml` file and save it. Then, refresh
    your browser. You should see the changes. This is exactly what we wanted to achieve;
    we also call this an edit-and-continue experience. You can make as many changes
    in your web files and always immediately see the result in the browser, without
    having to rebuild the image and restart the container containing your website.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you’re done playing with your web server and wish to clean up your system,
    remove the container with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is important to note that the updates are now propagated bi-directionally.
    If you make changes on the host, they will be propagated to the container, and
    vice versa. It’s also important to note that when you mount the current folder
    into the container target folder, `/usr/share/nginx/html`, the content that is
    already there is replaced by the content of the host folder.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to define volumes used in a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Defining volumes in images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we go back to what we have learned about containers in [*Chapter 4*](B19199_04.xhtml#_idTextAnchor083),
    *Creating and Managing Container Images*, for more moment, then we have this:
    the filesystem of each container, when started, is made up of the immutable layers
    of the underlying image, plus a writable container layer specific to this very
    container. All changes that the processes running inside the container make to
    the filesystem will be persisted in this container layer. Once the container is
    stopped and removed from the system, the corresponding container layer is deleted
    from the system and irreversibly lost.'
  prefs: []
  type: TYPE_NORMAL
- en: Some applications, such as databases running in containers, need to persist
    their data beyond the lifetime of the container. In this case, they can use volumes.
    To make things a bit more explicit, let’s look at a concrete example. MongoDB
    is a popular open source document database. Many developers use MongoDB as a storage
    service for their applications. The maintainers of MongoDB have created an image
    and published it on Docker Hub, which can be used to run an instance of the database
    in a container. This database will be producing data that needs to be persisted
    long term, but the MongoDB maintainers do not know who uses this image and how
    it is used. So, they can’t influence the `docker container run` command with which
    the users of the database will start this container. So, how can they define volumes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, there is a way of defining volumes in the Dockerfile. The keyword
    to do so is `VOLUME`, and we can either add the absolute path to a single folder
    or a comma-separated list of paths. These paths represent the folders of the container’s
    filesystem. Let’s look at a few samples of such volume definitions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The first line in the preceding snippet defines a single volume to be mounted
    at `/app/data`. The second line defines three volumes as a comma-separated list.
    The last one defines the same as the second line, but this time, the value is
    formatted as a JSON array.
  prefs: []
  type: TYPE_NORMAL
- en: When a container is started, Docker automatically creates a volume and mounts
    it to the corresponding target folder of the container for each path defined in
    the Dockerfile. Since each volume is created automatically by Docker, it will
    have an SHA-256 as its ID.
  prefs: []
  type: TYPE_NORMAL
- en: At container runtime, the folders defined as volumes in the Dockerfile are excluded
    from the Union filesystem, and thus any changes in those folders do not change
    the container layer but are persisted to the respective volume. It is now the
    responsibility of the operations engineers to make sure that the backing storage
    of the volumes is properly backed up.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use the `docker image inspect` command to get information about the
    volumes defined in the Dockerfile. Let’s see what MongoDB gives us by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will pull the image with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will inspect this image, and use the `--format` parameter to only
    extract the essential part from the massive amount of data, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note `| jq .` at the end of the command. We are piping the output of `docker
    image inspect` into the `jq` tool, which nicely formats the output.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you haven’t installed `jq` yet on your system, you can do so with `brew install
    jq` on macOS or `choco install jq` on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding command will return the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the Dockerfile for MongoDB defines two volumes at `/data/configdb`
    and `/data/db`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s run an instance of MongoDB in the background as a daemon, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now use the `docker container inspect` command to get information about
    the volumes that have been created, among other things. Use this command to just
    get the volume information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command should output something like this (shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Inspecting the MongoDB volumes](img/B19199_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.6 – Inspecting the MongoDB volumes
  prefs: []
  type: TYPE_NORMAL
- en: The `Source` field gives us the path to the host directory, where the data produced
    by MongoDB inside the container will be stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you leave, clean up the Mongo DB container with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: That’s it for the moment concerning volumes. In the next section, we will explore
    how we can configure applications running in containers, and the container image
    build process itself.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: More often than not, we need to provide some configuration to the application
    running inside a container. The configuration is often used to allow the same
    container to run in very different environments, such as in development, test,
    staging, or production environments. In Linux, configuration values are often
    provided via environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that an application running inside a container is completely
    shielded from its host environment. Thus, the environment variables that we see
    on the host are different from the ones that we see within a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s prove this by looking at what is defined on our host:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this command to display a list of all environment variables defined for
    your Terminal session:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the author’s macOS, the output is something like this (shortened):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s run a shell inside an Alpine container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the container with this command:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just as a reminder, we are using the `--rm` command-line parameter so that we
    do not have to remove the dangling container once we stop it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, list the environment variables we can see there with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'This should produce the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is different than what we saw directly on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Hit *Ctrl* + *D* to leave and stop the Alpine container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, let’s define environment variables for containers.
  prefs: []
  type: TYPE_NORMAL
- en: Defining environment variables for containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, the good thing is that we can pass some configuration values into the
    container at start time. We can use the `--env` (or the short form, `-e`) parameter
    in the form of `--env <key>=<value>` to do so, where `<key>` is the name of the
    environment variable and `<value>` represents the value to be associated with
    that variable. Let’s assume we want the app that is to be run in our container
    to have access to an environment variable called `LOG_DIR`, with a value of `/var/log/my-log`.
    We can do so with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code starts a shell in an Alpine container and defines the requested
    environment inside the running container. To prove that this is true, we can execute
    this command inside the Alpine container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'The output looks as expected. We now have the requested environment variable
    with the correct value available inside the container. We can, of course, define
    more than just one environment variable when we run a container. We just need
    to repeat the `--env` (or `-e`) parameter. Have a look at this sample:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, we are left at the command prompt inside
    the Alpine container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s list the environment variables with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: Now, let’s look at situations where we have many environment variables to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Using configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complex applications can have many environment variables to configure, and thus
    our command to run the corresponding container can quickly become unwieldy. For
    this purpose, Docker allows us to pass a collection of environment variable definitions
    as a file. We have the `--env-file` parameter in the `docker container run` command
    for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s try this out, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the source folder for `chapter 5` that we created at the beginning
    of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `config-file` subfolder and navigate to it, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use your favorite editor to create a file called `development.config` in this
    folder. Add the following content to the file and save it, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how we have the definition of a single environment variable per line
    in `<key>=<value>` format, where, once again, `<key>` is the name of the environment
    variable, and `<value>` represents the value to be associated with that variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, from within the `config-file` subfolder, let’s run an Alpine container,
    pass the file as an environment file, and run the `export` command inside the
    container to verify that the variables listed inside the file have indeed been
    created as environment variables inside the container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And indeed, the variables are defined, as we can see in the output generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how to define default values for environment variables that
    are valid for all container instances of a given Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Defining environment variables in container images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we want to define some default value for an environment variable
    that must be present in each container instance of a given container image. We
    can do so in the Dockerfile that is used to create that image by following these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the source folder for `chapter 5` that we created at the beginning
    of this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a subfolder called `config-in-image` and navigate to it, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use your favorite editor to create a file called `Dockerfile` in the `config-in-image`
    subfolder. Add the following content to the file and save it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a container image called `my-alpine` using the preceding Dockerfile,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget the period at the end of the preceding line!
  prefs: []
  type: TYPE_NORMAL
- en: 'Run a container instance from this image that outputs the environment variables
    defined inside the container, like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following in your output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what we expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The good thing, though, is that we are not stuck with those variable values
    at all. We can override one or many of them by using the `--env` parameter in
    the `docker container run` command. Use this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, have a look at the following command and its output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also override default values by using environment files together with
    the `--env-file` parameter in the `docker container run` command. Please try it
    out for yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the next section, we are going to introduce environment variables that are
    used at the build time of a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables at build time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we want to be able to define some environment variables that are
    valid at the time when we build a container image. Imagine that you want to define
    a `BASE_IMAGE_VERSION` environment variable that shall then be used as a parameter
    in your Dockerfile. Imagine the following Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `ARG` keyword to define a default value that is used each time
    we build an image from the preceding Dockerfile. In this case, that means that
    our image uses the `node:12.7-stretch` base image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to create a special image for, say, testing purposes, we can
    override this variable at image build time using the `--build-arg` parameter,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the resulting `my-node-test:latest` image will be built from the
    `node:12.7-alpine` base image and not from the `node:12.7-stretch` default image.
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, environment variables defined via `--env` or `--env-file` are
    valid at container runtime. Variables defined with `ARG` in the Dockerfile or
    `--build-arg` in the `docker container build` command are valid at container image
    build time. The former is used to configure an application running inside a container,
    while the latter is used to parameterize the container image build process.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we have come to the end of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced Docker volumes, which can be used to persist
    the state produced by containers and make them durable. We can also use volumes
    to provide containers with data originating from various sources. We learned how
    to create, mount, and use volumes. We also learned various techniques for defining
    volumes such as by name, by mounting a host directory, or by defining volumes
    in a container image.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we also discussed how we can configure environment variables
    that can be used by applications running inside a container. We have shown how
    to define those variables in the `docker container run` command, either explicitly,
    one by one, or as a collection in a configuration file. Finally, we learned how
    to parameterize the build process of container images by using build arguments.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following arti[cles provide more in-de](http://dockr.ly/2EUjTml)pth information:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use* *volumes*: [http://dockr.ly/2EUjTml](http://dockr.ly/2EUjTml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Manage data in* *Docker*: [http://dockr.ly/2EhBpzD](http://dockr.ly/2EhBpzD)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Docker volumes* on **Play with Docker** (**PWD**): [http://bit.ly/2sjIfDj](http://bit.ly/2sjIfDj)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nsenter` —Linux man page, at [https://bit.ly/2MEPG0n](https://bit.ly/2MEPG0n)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Set environment* *variables*: [https://dockr.ly/2HxMCjS](https://dockr.ly/2HxMCjS)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Understanding how ARG and FROM* *interact*: [https://dockr.ly/2OrhZgx](https://dockr.ly/2OrhZgx)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please try to answer the following questions to assess your learning progress:'
  prefs: []
  type: TYPE_NORMAL
- en: How would you create a named data volume with a name such as `my-products` using
    the default driver?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you run a container using the Alpine image and mount the `my-products`
    volume in read-only mode into the `/data` container folder?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you locate the folder that is associated with the `my-products` volume
    and navigate to it? Also, how would you create a file, `sample.txt`, with some
    content?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you run another Alpine container where you mount the `my-products`
    volume to the `/app-data` folder, in read/write mode? Inside this container, navigate
    to the `/app-data` folder and create a `hello.txt` file with some content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you mount a host volume – for example, `~/my-project` – into a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you remove all unused volumes from your system?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The list of environment variables that an application running in a container
    sees is the same as if the application were to run directly on the host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Your application, which shall run in a container, needs a huge list of environment
    variables for configuration. What is the simplest method to run a container with
    your application and provide all this information to it?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a named volume, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To achieve this result, do this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To get the path on the host for the volume, use this command
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This should result in the following output
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, execute the following command to run a container and execute `nsenter`
    within it:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to the folder containing the data for the `my-products` volume:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file containing the text `"I love Docker"` within this folder:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Exit `nsenter` and its container by pressing *Ctrl* + *D*.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following command to verify that the file generated in the host
    filesystem is indeed part of the volume and accessible to the container to which
    we’ll mount this volume:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output of the preceding command should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: And indeed, we can see the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional: Run a modified version of the command to output the content of the
    `sample.txt` file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In another Terminal, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute a command such as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Exit both containers and then, back on the host, execute this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The answer is *False* (B). Each container is a sandbox and thus has its very
    own environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Collect all environment variables and their respective values in a configuration
    file, which you then provide to the container with the `--env-file` command-line
    parameter in the `docker container run` command, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
