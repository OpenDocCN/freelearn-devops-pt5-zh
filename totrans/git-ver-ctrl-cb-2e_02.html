<html><head></head><body>
        

                            
                    <h1 class="header-title">Configuration</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Configuration targets</li>
<li>Querying the existing configuration</li>
<li>Templates</li>
<li>A .git directory template</li>
<li>A few configuration examples</li>
<li>Git aliases</li>
<li>The refspec exemplified</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Git, while serving a basic and crucial role in the life of a developer, is also quite complex and highly configurable. This chapter will give an overview of the most important options available and will provide the right tools for learning and navigating the multitude of configuration flags and fields available, in order to tailor your Git experience to your own needs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration targets</h1>
                
            
            
                
<p>In this section, we will look at the different layers that can be configured. The layers are as follows:</p>
<ul>
<li><kbd>SYSTEM</kbd>: This layer is system-wide and can be found in <kbd>/etc/gitconfig</kbd></li>
<li><kbd>GLOBAL</kbd>: This layer is global for the user and can be found in <kbd>~/.gitconfig</kbd></li>
<li><kbd>LOCAL</kbd>: This layer is local to the current repository and can be found in <kbd>.git/config</kbd></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will use the <kbd>jgit</kbd> repository for this example; clone it, or use the clone you already have from <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>, as shown in the following command:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit</strong>
<strong>$ cd jgit</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the previous chapter, we saw how we could use the command <kbd>git config --list</kbd> to list configuration entries. This list is actually made from three different levels of configuration that Git offers: system-wide configuration, <kbd>SYSTEM</kbd>; global configuration for the user, <kbd>GLOBAL</kbd>; and local repository configuration, <kbd>LOCAL</kbd>.</p>
<ol>
<li>For each of the configuration layers, we can query the existing configuration. On a Windows box with a default installation of the Git extensions, the different configuration layers will look something like the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --list --system</strong>
<strong>core.symlinks=false</strong>
<strong>core.autocrlf=true</strong>
<strong>color.diff=auto</strong>
<strong>color.status=auto</strong>
<strong>color.branch=auto</strong>
<strong>color.interactive=true</strong>
<strong>pack.packsizelimit=2g</strong>
<strong>help.format=html</strong>
<strong>http.sslcainfo=/bin/curl-ca-bundle.crt</strong>
<strong>sendemail.smtpserver=/bin/msmtp.exe</strong>
<strong>diff.astextplain.textconv=astextplain</strong>
<strong>rebase.autosquash=true</strong>
<br/># list the global configuration    
<strong>$ git config --list --global</strong>
<strong>merge.tool=kdiff3</strong>
<strong>mergetool.kdiff3.path=C:/Program Files (x86)/KDiff3/kdiff3.exe</strong>
<strong>diff.guitool=kdiff3</strong>
<strong>difftool.kdiff3.path=C:/Program Files (x86)/KDiff3/kdiff3.exe</strong>
<strong>core.editor="C:/Program Files (x86)/GitExtensions/GitExtensions.exe" fileeditor</strong>
<strong>core.autocrlf=true</strong>
<strong>credential.helper=!"C:/Program Files (x86)/GitExtensions/GitCredentialWinStore/git-credential-winst</strong>
<strong>ore.exe"</strong>
<strong>user.name=John Doe</strong>
<strong>user.email=john.doe@example.com<br/></strong><br/># list the configuration for this repository
<strong>$ git config --list --local</strong>
<strong>core.repositoryformatversion=0</strong>
<strong>core.filemode=false</strong>
<strong>core.bare=false</strong>
<strong>core.logallrefupdates=true</strong>
<strong>core.symlinks=false</strong>
<strong>core.ignorecase=true</strong>
<strong>core.hidedotfiles=dotGitOnly</strong>
<strong>remote.origin.url=https://git.eclipse.org/r/jgit/jgit</strong>
    <strong>remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*</strong>
    <strong>branch.master.remote=origin</strong>
    <strong>branch.master.merge=refs/heads/master</strong></pre>
<ol start="2">
<li>We can also query a single key and limit the scope to one of the three layers, by using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --global user.email</strong>
<strong>john.doe@example.com<br/></strong></pre>
<ol start="3">
<li>We can set the email address of the user to a different one for the current repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --local user.email john@example.com<br/></strong></pre>
<p style="padding-left: 60px">Now, listing the <kbd>GLOBAL</kbd> layer <kbd>user.email</kbd> will return <kbd>john.doe@example.com</kbd>, listing <kbd>LOCAL</kbd> will give <kbd>john@example.com</kbd>, and listing <kbd>user.email</kbd> without specifying the layer will give the effective value that is used in the operations on this repository; in this case, the <kbd>LOCAL</kbd> value <kbd>john@example.com</kbd>. The effective value will take precedence when needed. When two or more values are specified for the same key, but on different layers, the lowest layer takes precedence. When a configuration value is needed, Git will first look in the <kbd>LOCAL</kbd> configuration. If not found here, the <kbd>GLOBAL</kbd> configuration is queried. If it is not found in the <kbd>GLOBAL</kbd> configuration, the <kbd>SYSTEM</kbd> configuration is used.</p>
<p style="padding-left: 60px">If none of this works, the default value in Git is used.</p>
<p>In the previous example, <kbd>user.email</kbd> is specified in both the <kbd>GLOBAL</kbd> and <kbd>LOCAL</kbd> layers. Therefore, the <kbd>LOCAL</kbd> layer will be used.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Querying the three layers of configuration simply returns the content of the configuration files; <kbd>/etc/gitconfig</kbd> for system-wide configuration, <kbd>~/.gitconfig</kbd> for user-specific configuration, and <kbd>.git/config</kbd> for repository-specific configuration. When not specifying the configuration layer, the returned value will be the effective value.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Instead of setting all the configuration values on the command line by the key value, it is possible to set them by just editing the configuration file directly. Open the configuration file in your favorite editor and set the configuration you need, or use the built-in <kbd>git config -e</kbd> repository to edit the configuration directly in the Git-configured editor. You can set the editor to the editor of your choice either by changing the $<kbd>EDITOR</kbd> environment variable or with the <kbd>core.editor</kbd> configuration target, for example:</p>
<pre><strong>$ git config --global core.editor vim</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Querying the existing configuration</h1>
                
            
            
                
<p>In this example, we will look at how we can query the existing configuration and set the configuration values.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use <kbd>jgit</kbd> again by using the following command:</p>
<pre><strong>$ cd jgit</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>You can use <kbd>git config</kbd> to query your local and global Git configuration. In this section, we will show a couple of examples.</p>
<ol>
<li>To view all the effective configurations for the current Git repository, run the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --list</strong>
<strong>user.name=John Doe</strong>
<strong>user.email=john.doe@example.com</strong>
<strong>core.repositoryformatversion=0</strong>
<strong>core.filemode=false</strong>
<strong>core.bare=false</strong>
<strong>core.logallrefupdates=true</strong>
<strong>remote.origin.url=https://git.eclipse.org/r/jgit/jgit</strong>
    <strong>remote.origin.fetch=+refs/heads/*:refs/remotes/origin/*</strong>
    <strong>branch.master.remote=origin</strong>
    <strong>branch.master.merge=refs/heads/master</strong></pre>
<p style="padding-left: 60px">The previous output will, of course, reflect the user running the command. Instead of <kbd>John Doe</kbd> as the name and the email, the output should reflect your settings.</p>
<ol start="2">
<li>If we are just interested in a single configuration item, we can just query it by its <kbd>section.key</kbd> or <kbd>section.subsection.key</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config user.name</strong>
<strong>John Doe</strong>
<strong>$ git config remote.origin.url</strong>
<strong>https://git.eclipse.org/r/jgit/jgit</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Git's configuration is stored in plain text files and works like a key-value storage. You can set/query by key and get the value back. An example of the text-based configuration file is shown as follows (from the <kbd>jgit</kbd> repository):</p>
<pre><strong>$ cat .git/config</strong>
  <strong>[core]</strong>
    <strong>repositoryformatversion = 0</strong>
    <strong>filemode = false</strong>
    <strong>bare = false</strong>
    <strong>logallrefupdates = true</strong>
  <strong>[remote "origin"]</strong>
  <strong>  url = https://git.eclipse.org/r/jgit/jgit</strong>
  <strong>  fetch = +refs/heads/*:refs/remotes/origin/*</strong>
  <strong>[branch "master"]</strong>
  <strong>  remote = origin</strong>
  <strong>  merge = refs/heads/master</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>It is also easy to set configuration values. You can use the same syntax as you did when querying the configuration, except you need to add an argument to the value. To set a new email address on the <kbd>LOCAL</kbd> layer, we can execute the following command line:</p>
<pre><strong>git config user.email john.doe@example.com</strong></pre>
<p>The <kbd>LOCAL</kbd> layer is the default, if nothing else is specified. If you require whitespaces in the value, you can enclose the string in quotation marks, as you would do when configuring your name:</p>
<pre><strong>git config user.name "John Doe"</strong></pre>
<p>You can even set your own configuration, which does not have any effect on the core Git, but which can be useful for scripting/builds, and so on:</p>
<pre><strong>$ git config my.own.config "Whatever I need"</strong>  </pre>
<p>List the value:</p>
<pre><strong>$ git config my.own.config </strong>
<strong>Whatever I need</strong>  </pre>
<p>It is also very easy to delete/unset configuration entries:</p>
<pre><strong>$ git config --unset my.own.config</strong>  </pre>
<p>List the value:</p>
<pre><strong>$ git config my.own.config </strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Templates</h1>
                
            
            
                
<p>In this example, we will see how to create a template commit message that will be displayed in the editor when creating a commit. The template is only for the local user and not distributed with the repository in general.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this example, we will use the example repository from <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition.git</strong>
<strong>$ cd Git-Version-Control-Cookbook-Second-Edition</strong>  </pre>
<p>We'll use the following command as a commit message template for commit messages:</p>
<pre><strong>Short description of commit 
 
Longer explanation of the motivation for the change 
 
</strong><strong>Fixes-Bug: Enter bug-id or delete line 
Implements-Requirement: Enter requirement-id or delete line</strong> </pre>
<p>Save the commit message template in <kbd>$HOME/.gitcommitmsg.txt</kbd>. The filename isn't fixed and you can choose a filename of your liking.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>To let Git know about our new commit message template, we can set the configuration variable <kbd>commit.template</kbd> to point at the file we just created with that template; we'll do it globally so it is applicable to all our repositories:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --global commit.template $HOME/.gitcommitmsg.txt</strong></pre>
<ol start="2">
<li>Now, we can try to change a file, add it, and create a commit. This will bring up our preferred editor with the commit message template preloaded:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit</strong>
    
<strong>Short description of commit</strong>
    
<strong>Longer explanation of the motivation for the change</strong>
    
<strong>Fixes-Bug: Enter bug-id or delete line</strong>
<strong>Implements-Requirement: Enter requirement-id or delete line</strong>
    
<strong># Please enter the commit message for your changes. Lines starting</strong>
<strong># with '#' will be ignored, and an empty message aborts the commit.</strong>
<strong># On branch master</strong>
<strong># Changes to be committed:</strong>
<strong>#   (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
<strong>#</strong>
<strong>#  modified:   another-file.txt</strong>
<strong>#</strong>
<strong>~</strong>
<strong>~</strong>
<strong>".git/COMMIT_EDITMSG" 13 lines, 396 characters</strong></pre>
<ol start="3">
<li>We can now edit the message according to our commit and save to complete the commit.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When <kbd>commit.template</kbd> is set, Git simply uses the content of the template file as a starting point for all commit messages. This is quite convenient if you have a commit-message policy, as it greatly increases the chances of the policy being followed. You can even have different templates tied to different repositories since you can just set the configuration at the local level.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A .git directory template</h1>
                
            
            
                
<p>Sometimes, having a global configuration isn't enough. You will also need to trigger the execution of scripts (also known as Git hooks), exclude files, and so on. It is possible to achieve this with the template option set to <kbd>git init</kbd>. It can be given as a command-line option to <kbd>git clone</kbd> and <kbd>git init</kbd>, or as the <kbd>$GIT_TEMPLATE_DIR</kbd> environment variable, or as the configuration option <kbd>init.templatedir</kbd>. It defaults to <kbd>/usr/share/git-core/templates</kbd>. The template option works by copying files in the template directory to the <kbd>.git ($GIT_DIR)</kbd> folder after it has been created. The default directory contains sample hooks and some suggested exclude patterns. In the following example, we'll see how we can set up a new template directory, and add a commit message hook and an exclude file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>First, we will create the template directory. We can use any name we want, and we'll use <kbd>~/.git_template</kbd>, as shown in the following command:</p>
<pre><strong>$ mkdir ~/.git_template</strong></pre>
<p>Now, we need to populate the directory with some template files. This could be a hook or an exclude file. We will create one hook file and one exclude file. The hook file is located in <kbd>.git/hooks/name-of-hook</kbd> and the exclude file in <kbd>.git/info/exclude</kbd>. Create the two directories needed, <kbd>hooks</kbd> and <kbd>info</kbd>, as shown in the following command:</p>
<pre><strong>$ mkdir ~/.git_template/{hooks,info}</strong></pre>
<p>To keep the sample hooks provided by the default template directory (the Git installation), we copy the files in the default template directory to the new one. When we use our newly created template directory, we'll override the default one. So, copying the default files to our template directory will make sure that, excepting our specific changes, the template directory is similar to the default one, as shown in the following command:</p>
<pre><strong>$ cd ~/.git_template/hooks</strong>
<strong>$ cp /usr/share/git-core/templates/hooks/* .</strong></pre>
<p>We'll use the <kbd>commit-msg</kbd> hook as the example hook:</p>
<pre><strong>#!/bin/sh</strong>
<strong>MSG_FILE="$1"</strong>
<strong>echo "\nHi from the template commit-msg hook" &gt;&gt; $MSG_FILE</strong></pre>
<p>The hook is very simple and will just add <kbd>Hi from the template commit-msg hook</kbd> to the end of the commit message. Save it as <kbd>commit-msg</kbd> in the <kbd>~/.git_template/hooks</kbd> directory and make it executable by using the following command:</p>
<pre><strong>chmod +x ~/.git_template/hooks/commit-msg</strong></pre>
<p>Now that the commit message hook is done, let's also add an exclude file to the example. The exclude file works like the <kbd>.gitignore</kbd> file, but is not tracked in the repository.</p>
<p>We'll create an exclude file that excludes all the <kbd>*.txt</kbd> files, as follows:</p>
<pre><strong>$ echo "*.txt" &gt; ~/.git_template/info/exclude</strong></pre>
<p>Now, our template directory is ready for use.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Our template directory is ready, and we can use it, as described earlier, as a command-line option, an environment variable or, as in this example, to be set as a configuration:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --global init.templatedir ~/.git_template</strong></pre>
<ol start="2">
<li>Now, all Git repositories we create using <kbd>init</kbd> or <kbd>clone</kbd> will have the default files of the template directory. We can test whether it works by creating a new repository as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git init template-example</strong>
<strong>$ cd template-example</strong></pre>
<ol start="3">
<li>Let's try to create a <kbd>.txt</kbd> file and see what <kbd>git status</kbd> tells us. It should be ignored by the exclude file from the template directory:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "this is the readme file" &gt; README.txt</strong>
<strong>$ git status</strong> </pre>
<p style="padding-left: 60px">The exclude file worked! You can put in the file endings yourself, or just leave it blank and keep to the <kbd>.gitignore</kbd> files.</p>
<ol start="4">
<li>To test whether the <kbd>commit-msg</kbd> hook works, let's try to create a commit. First, we need a file to commit. So, let's create that and commit it as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "something to commit" &gt; somefile</strong>
<strong>$ git add somefile</strong>
<strong>$ git commit -m "Committed something"</strong></pre>
<ol start="5">
<li>We can now check the history with <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit 1f7d63d7e08e96dda3da63eadc17f35132d24064</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Mon Jan 6 20:14:21 2014 +0100</strong>
    
  <strong>Committed something</strong>
    
  <strong>Hi from the template commit-msg hook</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When Git creates a new repository, either via <kbd>init</kbd> or <kbd>clone</kbd>, it will copy the files from the <kbd>template</kbd> directory (the default location is <kbd>/usr/share/git-core/templates</kbd>) to the new repository when creating the directory structure. The template directory can be defined either by a command-line argument, an environment variable, or a configuration option. If nothing is specified, the default template directory will be used (distributed with the Git installation). By setting the configuration as a <kbd>--global</kbd> option, the template directory defined will apply to all of the user's (new) repositories. This is a very nice way to distribute the same hooks across repositories, but it also has some drawbacks. As the files in the template directory are only copied to the Git repositories, updates to the template directory do not affect the existing repositories. This can be solved by running <kbd>git init</kbd> in each existing repository to reinitialize the repository, but this can be quite cumbersome. Also, the template directory can enforce hooks on some repositories where you don't want them. This is quite easily solved by simply deleting the hook files in <kbd>.git/hooks</kbd> of that repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>For more information on hooks in Git, please refer to <a href="fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml">Chapter 7</a>, <em>Enhancing Your Daily Work with Git Hooks, Aliases, and Scripts</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">A few configuration examples</h1>
                
            
            
                
<p>There are configuration targets in the core Git system. In this section, we'll take a closer look at a few of them that might be useful in your daily work.</p>
<p>We'll look at the following three different configuration areas:</p>
<ul>
<li>Rebase and merge setup</li>
<li>Expiry of objects</li>
<li>Autocorrect</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this exercise, we'll just set a few configurations. We'll use the data model repository from <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>:</p>
<pre><strong>$ cd Git-Version-Control-Cookbook-Second-Edition</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's take a closer look at the previously mentioned configuration areas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rebase and merge setup</h1>
                
            
            
                
<p>By default, when performing <kbd>git pull</kbd>, a merge commit will be created if the history of the local branch has diverged from the remote one. However, to avoid all these merge commits, a repository can be configured so that it will default to rebase instead of merging when doing <kbd>git pull</kbd>. Several configuration targets related to the option are available as follows:</p>
<ul>
<li><kbd>pull.rebase</kbd>: This configuration, when set to <kbd>true</kbd>, will pull to rebase the current branch on top of the fetched one when performing a <kbd>git pull</kbd>. It can also be set to <kbd>preserve</kbd> so that the local merge commit will not be flattened in the rebase, by passing <kbd>--preserve-merges</kbd> to <kbd>git rebase</kbd>. The default value is <kbd>false</kbd>,as the configuration is not set. To set this option in your local repository, run the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ git config pull.rebase true</strong>  </pre>
<ul>
<li><kbd>branch.autosetuprebase</kbd>: When this configuration is set to <kbd>always</kbd>, any new branch created with <kbd>&lt;git branch</kbd> or <kbd>git checkout</kbd> that tracks another branch will be set up to pull to rebase (instead of merge). The valid options are as follows:
<ul>
<li><kbd>never</kbd>: This is set to pull to rebase (default)</li>
<li><kbd>local</kbd>: This is set to pull to rebase for local tracked branches</li>
<li><kbd>remote</kbd>: This is set to pull to rebase for remote tracked branches</li>
<li><kbd>always</kbd>: This is set to pull to rebase for all tracked branches</li>
<li>To set this option for all the new branches regardless of tracking remote or local branches, run the following command:</li>
</ul>
</li>
</ul>
<pre style="padding-left: 150px"><strong>$ git config branch.autosetuprebase always</strong></pre>
<ul>
<li><kbd>branch.&lt;name&gt;.rebase</kbd>: This configuration, when set to <kbd>true</kbd>, applies only to the <kbd>&lt;name&gt;</kbd> branch and tells Git to pull to rebase when performing <kbd>git pull</kbd> on the given branch. It can also be set to <kbd>preserve</kbd> so that the local merge commit will not be flattened when running <kbd>git pull</kbd>. By default, the configuration is not set for any branch. To set the <kbd>feature/2</kbd> branch in the repository to default to rebase, instead of merge, we can run the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ git config branch.feature/2.rebase true</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Expiry of objects</h1>
                
            
            
                
<p>By default, Git will perform garbage collection on unreferenced objects and clean <kbd>reflog</kbd> for entries that are more than 90 days old. For an object to be referenced, something must point to it; a tree, a commit, a tag, a branch, or some of the internal Git bookkeeping, such as <kbd>stash</kbd> or <kbd>reflog</kbd>. There are three settings that can be used to change this time as follows:</p>
<ul>
<li><kbd>gc.reflogexpire</kbd>: This is the general setting to know for how long a branch's history is kept in <kbd>reflog</kbd>. The default time is 90 days. The setting is a length of time, for example, <kbd>10 days, 6 months</kbd>, and it can be turned completely with the value <kbd>never</kbd>. The setting can be set to match a <kbd>refs</kbd> pattern by supplying the pattern in the configuration setting. <kbd>gc.&lt;pattern&gt;.reflogexpire</kbd>: This pattern can, for example, be <kbd>/refs/remotes/*</kbd>,and the expire setting would then only apply for those refs.</li>
<li><kbd>gc.reflogexpireunreachable</kbd>: This setting controls how long the <kbd>reflog</kbd> entries that are not a part of the current branch history should be available in the repository. The default value is <kbd>30 days</kbd>, and similar to the previous option, it is expressed as a length of time or set to <kbd>never</kbd> in order to turn it off. This setting can, as the previous one, be set to match a <kbd>refs</kbd> pattern.</li>
<li><kbd>gc.pruneexpire</kbd>: This option tells <kbd>git gc</kbd> to prune objects older than the value. The default is <kbd>2.weeks.ago</kbd>, and the value can be expressed as a relative date, such as <kbd>3.months.ago</kbd>. To disable the grace period, the value <kbd>now</kbd> can be used. To set a non-default expiry date on remote branches only, use the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ git config gc./refs/remote/*.reflogexpire never</strong>
<strong>$ git config gc./refs/remote/*.reflogexpireunreachable "2 months"</strong>  </pre>
<ul>
<li class="packt_nosymbol">We can also set a date so <kbd>git gc</kbd> will prune objects sooner:</li>
</ul>
<pre style="padding-left: 60px"><strong>$ git config gc.pruneexpire 3.days.ago</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Autocorrect</h1>
                
            
            
                
<p>This configuration is useful when you get tired of messages such as the following one just because you made a typo on the keyboard:</p>
<pre><strong>$ git statis</strong>
<strong>git: 'statis' is not a git command. See 'git --help'.</strong>
    
<strong>Did you mean this?</strong>
<strong>  status  </strong></pre>
<p>By setting the configuration to <kbd>help.autocorrect</kbd>, you can control how Git will behave when you accidentally send a typo to it. By default, the value is <kbd>0</kbd> and it means to list the possible options similar to the input (if <kbd>statis</kbd>is given, <kbd>status</kbd> will be shown). A negative value means to immediately execute the corresponding command. A positive value means to wait the given number of deciseconds (0.1 sec) before running the command (so there is an amount of time in which to cancel it). If several commands can be deduced from the text entered, nothing will happen. Setting the value to half a second gives you some time to cancel a wrong command, as follows:</p>
<pre><strong>$ git config help.autocorrect 5</strong>
<strong>$ git statis</strong>
<strong>WARNING: You called a Git command named 'statis', which does not exist.</strong>
<strong>Continuing under the assumption that you meant 'status'</strong>
<strong>in 0.5 seconds automatically...</strong>
<strong># On branch master</strong>
<strong># Changes to be committed:</strong>
<strong>#   (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
<strong>#</strong>
<strong>#       modified:   another-file.txt</strong>
<strong>#</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Setting the configuration targets will change the way Git behaves. The previous examples describe a few useful methods to get Git to act differently than its default behavior. You should be sure when you are changing a configuration that you completely understand what that configuration does. Therefore, check the Git configuration help page by using <kbd>git help config</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are a lot of configuration targets available in Git. You can run <kbd>git help config</kbd> and all of them will be displayed and explained over a few pages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git aliases</h1>
                
            
            
                
<p>An alias is a nice way to configure long and/or complicated Git commands to represent short useful ones. An alias is simply a configuration entry under the alias section. It is usually configured to <kbd>--global</kbd> to apply it everywhere.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this example, we will use the <kbd>jgit</kbd> repository, which was also used in <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>, with the <kbd>master</kbd> branch pointing at <kbd>b14a93971837610156e815ae2eee3baaa5b7a44b</kbd>. Either use the clone from <a href="b475c6bd-71df-4b49-8062-57d065b83f51.xhtml">Chapter 1</a>, <em>Navigating Git</em>, or clone the repository again, as follows:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit</strong>
<strong>$ cd jgit</strong>
<strong>$ git checkout master &amp;&amp; git reset --hard b14a939</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we'll create a few simple aliases, then a couple of more special ones, and finally, a couple of aliases using external commands. Instead of writing <kbd>git checkout</kbd> every time we need to switch branches, we can create an alias of that command and call it <kbd>git co</kbd>. We can do the same for <kbd>git branch</kbd>, <kbd>git commit</kbd>, and <kbd>git status</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --global alias.co checkout </strong>
<strong>$ git config --global alias.br branch</strong>
<strong>$ git config --global alias.ci commit</strong>
<strong>$ git config --global alias.st status</strong> </pre>
<ol start="2">
<li>Now, try to run <kbd>git st</kbd> in the <kbd>jgit</kbd> repository as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git st</strong>
<strong># On branch master</strong>
<strong>nothing to commit, working directory clean</strong>  </pre>
<ol start="3">
<li>The <kbd>alias</kbd> method is also good for creating the Git commands you think are missing in Git. One of the common Git aliases is <kbd>unstage</kbd>, which is used to move a file out of the staging area, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --global alias.unstage 'reset HEAD --'</strong> </pre>
<p style="padding-left: 60px">Try to edit the <kbd>README.md</kbd> file in the root of the <kbd>jgit</kbd> repository and add it to the root.</p>
<ol start="4">
<li>Now, <kbd>git status/git st</kbd> should display something like the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git st</strong>
<strong># On branch master</strong>
<strong># Changes to be committed:</strong>
<strong>#   (use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
<strong>#</strong>
<strong>#       modified:   README.md</strong>
<strong>#</strong>  </pre>
<ol start="5">
<li>Let's try to unstage <kbd>README.md</kbd> and then look at <kbd>git st</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git unstage README.md</strong>
<strong>Unstaged changes after reset:</strong>
<strong>M       README.md</strong>
  
<strong>$ git st</strong>
<strong># On branch master</strong>
<strong># Changes not staged for commit:</strong>
<strong>#   (use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>#   (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
<strong>#</strong>
<strong>#       modified:   README.md</strong>
<strong>#</strong>
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong></pre>
<ol start="6">
<li>A common use case for aliases is to format the history of Git in specific ways. Let's say you want the number of lines added and deleted for each file in the commit displayed along with some common commit data. For this, we can create the following alias so we don't have to type everything each time:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --global alias.ll "log --pretty=format:"%C(yellow)%h%Cred%d %Creset%s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset" --numstat"</strong></pre>
<ol start="7">
<li>Now, we can execute <kbd>git ll</kbd> in the terminal and get a nice stat output, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git ll</strong>
<strong>b14a939 (HEAD, master) Prepare 3.3.0-SNAPSHOT builds (8 days ago) &lt;Matthias Sohn&gt;</strong>
<strong>6       6       org.eclipse.jgit.ant.test/META-INF/MANIFEST.MF</strong>
<strong>1       1       org.eclipse.jgit.ant.test/pom.xml</strong>
<strong>3       3       org.eclipse.jgit.ant/META-INF/MANIFEST.MF</strong>
<strong>1       1       org.eclipse.jgit.ant/pom.xml</strong>
<strong>4       4       org.eclipse.jgit.archive/META-INF/MANIFEST.MF</strong>
<strong>2       2       org.eclipse.jgit.archive/META-INF/SOURCE-MANIFEST.MF</strong>
<strong>1       1       org.eclipse.jgit.archive/pom.xml</strong>
<strong>6       6       org.eclipse.jgit.console/META-INF/MANIFEST.MF</strong>
<strong>1       1       org.eclipse.jgit.console/pom.xml</strong>
<strong>12      12      org.eclipse.jgit.http.server/META-INF/MANIFEST.MF</strong>
<strong>...</strong></pre>
<ol start="8">
<li>It is also possible to use an external command instead of a Git command. So, small shell scripts and so on can be embedded. To create an <kbd>alias</kbd> method with an external command, the alias must start with an exclamation mark <kbd>!</kbd>. The examples can be used when resolving conflicts from a rebase or merge. In your <kbd>~/.gitconfig</kbd> file under <kbd>[alias]</kbd>, add the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>editconflicted = "!f() {git ls-files --unmerged | cut -f2 | sort -u ; }; $EDITOR 'f'"</strong></pre>
<p style="padding-left: 60px">This will bring up your configured $<kbd>EDITOR</kbd> with all the files that are in the conflict state due to the merge/rebase. This quickly allows you to fix the conflicts and get on with the merge/rebase.</p>
<ol start="9">
<li>In the <kbd>jgit</kbd> repository, we can create two branches at an earlier point in time and merge these two branches:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch A 03f78fc</strong>
<strong>$ git branch B 9891497</strong>
<strong>$ git checkout A</strong>
<strong>Switched to branch 'A'</strong>
    
<strong>$ git merge B</strong>  </pre>
<p style="padding-left: 60px">Now, you'll see that this fails to perform the merge, and you can run <kbd>git st</kbd> to check the statuses of a lot of files that are in a conflicted state, <kbd>both modified</kbd>. To open and edit all the conflicted files, we can now run <kbd>git editconflicted</kbd>. This brings up <kbd>$EDITOR</kbd> with the files. If your environment variable isn't set, use the <kbd>EDITOR=&lt;your-favorite-editor&gt;</kbd> export to set it.</p>
<p style="padding-left: 60px">For this example, we don't actually resolve the conflicts. Just check that the alias works and you're ready for the next alias.</p>
<ol start="10">
<li>Now that we have solved all the merge conflicts, it is time to add all of those files before we conclude the merge. Luckily, we can create an <kbd>alias</kbd> method that can help us with that, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>addconflicted = "!f() { git ls-files --unmerged | cut -f2 | sort -u ; }; git add 'f'"</strong>  </pre>
<ol start="11">
<li>Now, we can run <kbd>git addconflicted</kbd>. Later, <kbd>git status</kbd> will tell us that all the conflicted files are added:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git st</strong>
<strong>On branch A</strong>
<strong>All conflicts fixed but you are still merging.</strong>
<strong>  (use "git commit" to conclude merge)</strong>
    
<strong>Changes to be committed:</strong>
    
<strong>  modified:   org.eclipse.jgit.console/META-INF/MANIFEST.MF</strong>
<strong>  modified:   org.eclipse.jgit.console/pom.xml</strong>
<strong>  modified:   org.eclipse.jgit.http.server/META-INF/MANIFEST.MF</strong>
<strong>  modified:   org.eclipse.jgit.http.server/pom.xml</strong>
<strong>  modified:   org.eclipse.jgit.http.test/META-INF/MANIFEST.MF</strong>
<strong>  modified:   org.eclipse.jgit.http.test/pom.xml</strong>
<strong>  ...</strong>
<strong>Now we can conclude the merge with git commit:</strong>
<strong>$ git commit</strong>
<strong>[A 94344ae] Merge branch 'B' into A</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Git simply runs the command the alias is short for. It is very convenient for long Git commands, or Git commands that are hard to remember exactly how to write. Now, all you have to remember is the alias and you can always look in the configuration file for it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Another way to create a kind of Git alias is to make a shell script and save the file with the name <kbd>git-&lt;your-alias-name&gt;</kbd>. Make the file executable and place it somewhere in your <kbd>$PATH</kbd>. You can now run that file simply by running <kbd>git&lt;your-alias-name&gt;</kbd> from the command line.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The refspec exemplified</h1>
                
            
            
                
<p>Though the <kbd>refspec</kbd> isn't the first thing that comes to mind when thinking about the Git configuration, it is actually quite close. In a lot of the Git commands, the <kbd>refspec</kbd> is used, but often implicitly, that is, the <kbd>refspec</kbd> is taken from the configuration file. If you don't remember setting a <kbd>refspec</kbd> configuration, you are probably right, but if you cloned the repository or added a remote, you'll have a section in <kbd>.git/config</kbd> that looks something like the following (this is for the <kbd>jgit</kbd> repository):</p>
<pre><strong>[remote "origin"]</strong>
<strong>  url = https://git.eclipse.org/r/jgit/jgit</strong>
<strong>  fetch = +refs/heads/*:refs/remotes/origin/*</strong></pre>
<p>The fetch line contains the configured <kbd>refspec</kbd> to fetch in relation to this repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>In this example, we'll be using the <kbd>jgit</kbd> repository as our server repository, but we have to make a clone of it to a bare repository so we can push it. You can't push to the checked-out branch on a non-bare repository, as this can overwrite the work area and index.</p>
<p>Create a bare repository from the <kbd>jgit</kbd> repository and create a new Git repository where we can play with the <kbd>refspec</kbd> as follows:</p>
<pre><strong>$ git clone --bare https://git.eclipse.org/r/jgit/jgit jgit-bare.git</strong>
<strong>$ git init refspec-tests<br/>Initialized empty Git repository in /Users/john.doe/refspec-tests/.git/</strong>
<strong>$ cd refspec-tests</strong>
<strong>$ git remote add origin ../jgit-bare.git</strong></pre>
<p>We also need to change the branch names on some of the branches to match the example for namespacing; the following will rename the <kbd>stable-xxx</kbd> branches to <kbd>stable/xxx</kbd>:</p>
<pre><strong>$ for br in $(git branch  -a | grep "stable-"); do new=$(echo $br| sed 's/-///'); git branch $new $br; done</strong></pre>
<p>In the previous shell scripting, the <kbd>$new</kbd> and <kbd>$br</kbd> variables aren't placed in double quotes (<kbd>"</kbd>), as good practice for shell scripting would otherwise suggest. This is okay, as the variables reflect the names of the branches in the repository and branch names cannot contain spaces.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>Let's set up our new repository to only fetch the <kbd>master</kbd> branch. We do this by changing the fetch line under <kbd>[remote "origin"]</kbd> in the configuration file (<kbd>.git/config</kbd>), as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>[remote "origin"]</strong>
<strong>  url = ../jgit-bare.git</strong>
  <strong>fetch = +refs/heads/master:refs/remotes/origin/master</strong></pre>
<ol start="2">
<li>Now, we will only fetch the <kbd>master</kbd> branch and not all the other branches when executing a <kbd>git fetch</kbd>, <kbd>git pull</kbd>, or a <kbd>git remote</kbd> update origin, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git pull</strong>
<strong>remote: Counting objects: 44033, done.</strong>
<strong>remote: Compressing objects: 100% (6927/6927), done.</strong>
<strong>remote: Total 44033 (delta 24063), reused 44033 (delta 24063)</strong>
<strong>Receiving objects: 100% (44033/44033), 9.45 MiB | 5.70 MiB/s, done.</strong>
<strong>Resolving deltas: 100% (24063/24063), done.</strong>
<strong>From ../jgit-bare</strong>
    <strong> * [new branch]      master     -&gt; origin/master</strong>
<strong>From ../jgit-bare</strong>
    <strong> * [new tag]         v0.10.1    -&gt; v0.10.1</strong>
    <strong> * [new tag]         v0.11.1    -&gt; v0.11.1</strong>
    <strong> * [new tag]         v0.11.3    -&gt; v0.11.3</strong>
    <strong>...</strong>
<strong>$ git branch -a</strong>
    <strong>* master</strong>
    <strong>  remotes/origin/master</strong></pre>
<ol start="3">
<li>Let's also set up a separate refspec to fetch all the <kbd>stable/*</kbd> branches to the local repository as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>[remote "origin"]</strong>
<strong>  url = ../jgit-bare.git</strong>
  <strong>fetch = +refs/heads/master:refs/remotes/origin/master</strong>
  <strong>fetch = +refs/heads/stable/*:refs/remotes/origin/stable/*</strong></pre>
<ol start="4">
<li>Now, fetch the branches locally, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git fetch</strong>
<strong>From ../jgit-bare</strong>
    <strong> * [new branch]      stable/0.10 -&gt; origin/stable/0.10</strong>
    <strong> * [new branch]      stable/0.11 -&gt; origin/stable/0.11</strong>
    <strong> * [new branch]      stable/0.12 -&gt; origin/stable/0.12</strong>
    <strong> * [new branch]      stable/0.7 -&gt; origin/stable/0.7</strong>
    <strong> * [new branch]      stable/0.8 -&gt; origin/stable/0.8</strong>
    <strong> * [new branch]      stable/0.9 -&gt; origin/stable/0.9</strong>
    <strong> * [new branch]      stable/1.0 -&gt; origin/stable/1.0</strong>
    <strong> * [new branch]      stable/1.1 -&gt; origin/stable/1.1</strong>
    <strong> * [new branch]      stable/1.2 -&gt; origin/stable/1.2</strong>
    <strong> * [new branch]      stable/1.3 -&gt; origin/stable/1.3</strong>
    <strong> * [new branch]      stable/2.0 -&gt; origin/stable/2.0</strong>
    <strong> * [new branch]      stable/2.1 -&gt; origin/stable/2.1</strong>
    <strong> * [new branch]      stable/2.2 -&gt; origin/stable/2.2</strong>
    <strong> * [new branch]      stable/2.3 -&gt; origin/stable/2.3</strong>
    <strong> * [new branch]      stable/3.0 -&gt; origin/stable/3.0</strong>
    <strong> * [new branch]      stable/3.1 -&gt; origin/stable/3.1</strong>
    <strong> * [new branch]      stable/3.2 -&gt; origin/stable/3.2</strong></pre>
<ol start="5">
<li>We can also set up a push <kbd>refspec</kbd> that specifies where branches are pushed to by default. Let's create a branch called <kbd>develop</kbd> and create one commit, as shown in the following commands:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b develop</strong>
<strong>Switched to a new branch 'develop'</strong>
<strong>$ echo "This is the developer setup, read carefully" &gt; readme-dev.txt</strong>
<strong>$ git add readme-dev.txt</strong></pre>
<pre style="padding-left: 60px"><strong>$ git commit -m "adds readme file for developers"</strong>
<strong>[develop ccb2f08] adds readme file for developers</strong>
<strong> 1 file changed, 1 insertion(+)</strong>
 <strong>create mode 100644 readme-dev.txt</strong></pre>
<ol start="6">
<li>Now, let's create a push <kbd>refspec</kbd> that will send the content of the <kbd>develop</kbd> branch to <kbd>integration/master</kbd> on origin:</li>
</ol>
<pre style="padding-left: 60px"><strong>[remote "origin"]</strong>
<strong>  url = ../jgit-bare.git</strong>
  <strong>fetch = +refs/heads/master:refs/remotes/origin/master</strong>
  <strong>fetch = +refs/heads/stable/*:refs/remotes/origin/stable/*</strong>
  <strong>push = refs/heads/develop:refs/remotes/origin/integration/master</strong></pre>
<ol start="7">
<li>Let's push our commit on <kbd>develop</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git push</strong>
<strong>Counting objects: 4, done.</strong>
<strong>Compressing objects: 100% (2/2), done.</strong>
<strong>Writing objects: 100% (3/3), 345 bytes | 0 bytes/s, done.</strong>
<strong>Total 3 (delta 1), reused 0 (delta 0)</strong>
<strong>To ../jgit-bare.git</strong>
<strong>* [new branch]      develop -&gt; origin/integration/master</strong></pre>
<p style="padding-left: 60px">As the <kbd>integration/master</kbd> branch didn't exist on the remote side, it was created for us.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The format of the <kbd>refspec</kbd> is in the form of <kbd>&lt;source&gt;:&lt;destination&gt;</kbd>. For a fetch <kbd>refspec</kbd>, this means that <kbd>&lt;source&gt;</kbd> is the source on the remote side and <kbd>&lt;destination&gt;</kbd> is <kbd>local</kbd>. For a push <kbd>refspec</kbd>, <kbd>&lt;source&gt;</kbd> is <kbd>local</kbd> and <kbd>&lt;destination&gt;</kbd> is <kbd>remote</kbd>. The <kbd>refspec</kbd> can be prefixed by a <kbd>+</kbd> to indicate that the <kbd>ref</kbd> pattern can be updated even though it isn't a fast-forward update. It is not possible to use partial globs in the <kbd>refspec</kbd> pattern, as shown in the following line:</p>
<pre><strong>fetch = +refs/heads/stable*:refs/remotes/origin/stable*</strong></pre>
<p>However, it is possible to use namespacing. That's why we had to rewrite the <kbd>stable-xxx</kbd> branches to <kbd>stable/xxx</kbd> to fit into a namespace pattern:</p>
<pre><strong>fetch = +refs/heads/stable/*:refs/remotes/origin/stable/*</strong></pre>


            

            
        
    </body></html>