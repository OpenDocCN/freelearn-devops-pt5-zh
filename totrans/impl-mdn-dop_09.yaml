- en: Monitoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控
- en: Introduction
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍
- en: So far, we have seen a large number of tools that we can use as DevOps engineers
    in our company to enhance our capabilities. Now we are able to provision servers
    with Ansible, create Kubernetes clusters on Google Cloud Platform, and set up
    a delivery pipeline for our microservices. We have also dived deep into how Docker
    works and how we should organize our company to be a successful delivering software.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了一大批可以作为 DevOps 工程师在公司中使用的工具，来增强我们的能力。现在我们能够使用 Ansible 配置服务器，在谷歌云平台上创建
    Kubernetes 集群，并为我们的微服务设置交付流水线。我们也深入探讨了 Docker 的工作原理，以及我们应该如何组织公司，才能成功交付软件。
- en: 'In this chapter, we are going to take a look at the **missing piece of the
    puzzle**: monitoring. Usually overlooked, monitoring is, in my opinion, a key
    component of a successful DevOps company. Monitoring is the first line of defense
    against problems. In [Chapter 8](127a7b5f-4bd7-4290-bea0-3e8db867e4af.xhtml),
    *Release Management – Continuous Delivery*, we talked about how we should shift
    our focus toward being able to fix the arising problems rather than spending a
    huge amount of resources in trying to prevent them:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将讨论 **缺失的拼图**：监控。通常被忽视，但在我看来，监控是成功的 DevOps 公司中一个关键的组成部分。监控是应对问题的第一道防线。在
    [第 8 章](127a7b5f-4bd7-4290-bea0-3e8db867e4af.xhtml)，*发布管理 – 持续交付* 中，我们谈到了如何将焦点转向解决出现的问题，而不是花费大量资源去预防它们：
- en: 20 percent of your time will create 80 percent of the functionality. The other
    20 percent is going to cost you 80 percent of your time.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 你 20% 的时间将创造出 80% 的功能。剩下的 20% 将花费你 80% 的时间。
- en: This non-written rule dominates the world. With monitoring, we can bend this
    rule to live comfortably with 20 percent of unknown outcomes as we are able to
    identify the problems quite quickly.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这条非书面规则主宰着世界。通过监控，我们可以利用这一规则，生活得更加舒适，因为我们能够快速识别问题，从而应对 20% 的未知结果。
- en: We will review some of the tools to monitor software, but our focus will be
    on Stackdriver, as it is the monitoring solution from Google Cloud Platform that,
    out of the box, provides us with a fairly comprehensive set of tools to deal with
    the flaws in our systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回顾一些用于监控软件的工具，但我们的重点将放在 Stackdriver 上，因为它是谷歌云平台的监控解决方案，开箱即用，提供了一个相当全面的工具集，帮助我们应对系统中的缺陷。
- en: Types of monitoring
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控类型
- en: 'In the SRE book from Google, there are two types of monitoring defined:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在谷歌的 SRE 书中，定义了两种类型的监控：
- en: BlackBox monitoring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 黑盒监控
- en: WhiteBox monitoring
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 白盒监控
- en: This is generally accepted by everyone, leading to a solid amount of tools that
    are clearly differentiated around whitebox and blackbox monitoring.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是大家普遍接受的观点，导致出现了大量明显区分的工具，围绕白盒和黑盒监控。
- en: 'One of the best comparisons I''ve ever heard on whitebox versus blackbox monitoring
    is the diagnosis of a bone fracture. When you first go to the doctor, he/she only
    has access to your blackbox metrics:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我听过的最好的白盒与黑盒监控的对比之一是骨折诊断。当你第一次去看医生时，他/她只能接触到你的黑盒指标：
- en: Does the area have any bump?
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个区域有任何凸起吗？
- en: Is it painful on movement?
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动时是否疼痛？
- en: Then, once the initial diagnoses has been pronounced, the next step is getting
    X-rays from the area. Now we can confirm whether the bone is broken and, if it
    is, what is the impact in the system. The X-rays are the WhiteBox monitoring that
    the doctor is using.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，一旦初步诊断已经做出，下一步就是获取该区域的 X 光片。现在我们可以确认骨头是否断了，如果断了，系统的影响是什么。X 光片就是医生使用的白盒监控。
- en: Blackbox monitoring
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 黑盒监控
- en: Whitebox monitoring is the type of monitoring that observes a system from outside
    without having to look into how the system is built. These metrics are the first
    ones that impact the users and the first external symptoms that something is going
    wrong in our application or server.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒监控是从外部观察系统的一种监控方式，而不需要了解系统是如何构建的。这些指标是首先影响用户的，亦是应用或服务器出现问题时的第一外部症状。
- en: 'Among the metrics that can be used for blackbox monitoring, we can find the
    following ones:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在可用于黑盒监控的指标中，我们可以找到以下几种：
- en: Latency
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 延迟
- en: Throughput
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 吞吐量
- en: These two metrics are the holy grail of blackbox monitoring.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种指标是黑盒监控的圣杯。
- en: 'The latency is, by definition, how long takes our system to respond. If we
    are looking at an HTTP server, from the very first time that we sent the request
    to the time when the server on the other side of the line replies is what we understand
    as latency. This metric is a fairly interesting one because it is the absolute
    truth about how the users see our system: the bigger the latency is, the worse
    the experience they get.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟的定义是系统响应所需的时间。如果我们看一个HTTP服务器，从我们第一次发送请求到对方服务器回复的时间，就是我们所理解的延迟。这个指标非常有趣，因为它直接反映了用户如何感知我们的系统：延迟越大，用户体验就越差。
- en: 'Throughput is extremely related to the latency. Basically, it is the number
    of requests that our software can serve per time unit, usually per second. This
    measure is a critical one for capacity planning, and you are discouraged to measure
    it in real time in a running system, as it pushes a lot of load through the system,
    which is surely going to affect the response time for live users. In general,
    throughput is measured at the performance testing stage of our application, which
    might be tricky:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 吞吐量与延迟密切相关。基本上，它是我们软件每单位时间可以处理的请求数量，通常以秒为单位。这个指标对容量规划至关重要，而且不建议在运行中的系统中实时测量它，因为它会给系统带来很大的负载，肯定会影响实时用户的响应时间。一般来说，吞吐量是在我们应用程序的性能测试阶段进行衡量的，但这可能会有些棘手：
- en: The hardware for testing has to match production
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试硬件必须与生产环境匹配
- en: The dataset for the database has to be similar to production
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库的数据集必须与生产环境类似
- en: The performance testing step is usually overlooked by many of the companies
    as it is fairly expensive. That is why preproduction is usually used for capacity
    testing in order to guess the amount of hardware needed in production. Nowadays,
    this is less problematic, as with auto scaling groups in the cloud infrastructure,
    it becomes less of a problem as the infrastructure is going to scale on its own
    when needed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 性能测试步骤通常被许多公司忽视，因为它非常昂贵。因此，通常使用预生产环境进行容量测试，以估算生产环境中所需的硬件数量。现在，随着云基础设施中自动扩展组的出现，这个问题变得不那么严重，因为基础设施在需要时会自动扩展。
- en: As you can see, these metrics are fairly simple to understand, and even though
    they play a key role in the error response time, they might not be the first indicators
    of problems.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这些指标非常容易理解，尽管它们在错误响应时间中起着关键作用，但它们可能不是问题的首要指标。
- en: Whitebox monitoring
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 白盒监控
- en: 'Whitebox monitoring, as the name indicates, is the monitoring that needs to
    know about how the system is built in order to raise alerts on certain events
    happening inside of our application or infrastructure. These metrics are quite
    fine-grained (unlike blackbox monitoring), and once we have been alerted, they
    are the answer to the main questions of a postmortem analysis:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒监控，顾名思义，是一种需要了解系统构建方式的监控，以便在应用程序或基础设施内部发生某些事件时发出警报。这些指标非常细粒度（与黑盒监控不同），一旦我们收到警报，它们就是事后分析的主要答案：
- en: Where is the problem?
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题出在哪里？
- en: What is causing the problem?
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 问题的原因是什么？
- en: Which flows are affected?
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 哪些流受到了影响？
- en: What can we do to avoid this in future?
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以做些什么来避免未来出现这种情况？
- en: 'Among other metrics, these are a fairly interesting set of examples:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是非常有趣的一组示例，除了其他指标：
- en: Function execution time
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数执行时间
- en: Errors per time unit
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每单位时间的错误数
- en: Requests per time unit
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每单位时间的请求数
- en: Memory usage
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存使用情况
- en: CPU usage
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU 使用率
- en: Hard drive usage
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 硬盘使用情况
- en: I/O operations per time unit
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每单位时间的I/O操作
- en: As you can see, there is an endless number of whitebox metrics to ensure the
    stability of our system. There are almost too many, so we usually need to pick
    the right ones in order to avoid the noise.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，为确保系统的稳定性，有无尽的白盒监控指标可供选择。数量几乎太多，所以我们通常需要选择合适的指标，以避免噪音。
- en: An important detail here is the fact that when a blackbox monitoring metric
    gives an abnormal reading, there is always a whitebox metric that can be used
    to diagnose, but it is not true the other way around. A server can have a spike
    in the memory usage due to an internal problem without impacting the users.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这里一个重要的细节是，当黑盒监控指标给出异常读数时，总会有一个白盒监控指标可以用来诊断，但反过来就不一定成立。服务器可能由于内部问题导致内存使用激增，但这不会影响用户。
- en: One of the most important artifacts in whitebox monitoring are the logging files.
    These files are the ordered chain of events happening in our software, and usually,
    they are the first line of attack to diagnose problems related to our software.
    The main problem with log files is the fact that they are stored on production
    servers and we should not access them on a regular basis just to check the log
    files as it is a security threat on its own. It only takes an open terminal to
    a server forgotten by someone to give access rights to the wrong person.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 白盒监控中最重要的一个工件就是日志文件。这些文件是我们软件中发生事件的有序链条，通常，它们是诊断与软件相关问题的第一道防线。日志文件的主要问题在于，它们存储在生产服务器上，我们不应定期访问这些日志文件，因为这本身就是一种安全威胁。只需要一个被遗忘的终端连接到服务器，就可能给不该访问的人提供权限。
- en: Monitoring third-party tools
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控第三方工具
- en: Monitoring is usually a good candidate to involve third-party companies. It
    requires a fair amount of redundancy in the systems in order to keep the monitoring
    active, which is primordial in order to ensure that we are not blind to what is
    happening in our system.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 监控通常是涉及第三方公司的一个不错选择。它需要系统中有相当多的冗余，以保持监控的持续运行，这对确保我们不会对系统发生的情况视而不见至关重要。
- en: Another positive aspect of using third-party apps for monitoring is the fact
    that they don't live in the same data center, and if they do (usually AWS), their
    redundancy is enough to ensure stability.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第三方应用进行监控的另一个积极方面是，它们不在同一数据中心运行，如果它们确实在同一个数据中心（通常是AWS），它们的冗余性足以确保稳定性。
- en: 'In this section, we are going to take a look at three tools in particular:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将特别关注三种工具：
- en: Pingdom
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pingdom
- en: Logentries
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logentries
- en: AppDynamics
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: AppDynamics
- en: 'That doesn''t mean that they are the best or the only tools in the market.
    There are other interesting alternatives (for example, New Relic instead of AppDynamics)
    that are worth exploring, but in this case, we are going to focus on Stackdriver,
    the monitoring solution for Google Cloud Platform, due to a number of factors:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着它们是市场上最好的或唯一的工具。还有其他一些有趣的替代品（例如，使用New Relic代替AppDynamics），值得探索，但在本节中，我们将重点讨论Stackdriver，这是Google
    Cloud Platform的监控解决方案，原因有以下几点：
- en: It integrates very well with Google Cloud Platform
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它与Google Cloud Platform的集成非常好
- en: It has a very interesting free tier
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供一个非常有趣的免费套餐
- en: The alerting systems are one of the most advanced systems you can find in the
    market
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报系统是市场上最先进的系统之一
- en: Pingdom
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Pingdom
- en: Pingdom is a tool used to measure the latency of our servers from different
    sides of the world. As you can see, if you have worked in a 24/7 company, latency
    across the globe varies a lot depending on where our customers are in relation
    to our data centers. As a matter of curiosity, if our server is in Europe, someone
    from Australia will have around 2-3 seconds extra on the latency.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Pingdom是一个用来衡量我们服务器从世界不同地方的延迟的工具。如你所见，如果你曾在一个24/7的公司工作过，你会发现全球各地的延迟差异很大，这取决于我们的客户与数据中心之间的距离。有趣的是，如果我们的服务器在欧洲，来自澳大利亚的用户将会多出2-3秒的延迟。
- en: Pingdom has servers spread across the globe to monitor how our users see the
    system and take adequate measures to solve the problem (for example, spawning
    a new data center closer to them).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Pingdom在全球多个地方都有服务器，用来监控用户如何看到系统并采取适当的措施解决问题（例如，建立一个离他们更近的数据中心）。
- en: You can register in Pingdom for free with a 14-days trial, but you need to enter
    a credit card (don't worry; they will advise you when your trial is over so you
    can cancel the plan if you don't want to continue with it).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以免费注册Pingdom，享受14天的试用期，但需要提供信用卡信息（不用担心；他们会在试用期结束时提醒你，这样你可以在不继续使用的情况下取消计划）。
- en: 'Take a look at the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 请看以下截图：
- en: '![](img/71c60795-f39a-4827-ae2a-ca8d4cc59ef0.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/71c60795-f39a-4827-ae2a-ca8d4cc59ef0.jpg)'
- en: As you can see, after specifying hosts, Pingdom will start issuing requests
    to the specified URL and measuring the response time from different parts of the
    world.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在指定主机之后，Pingdom将开始向指定的URL发出请求，并测量从世界不同地方的响应时间。
- en: 'Lately, Pingdom has included fairly interesting capabilities: now it can read
    custom metrics through an endpoint in order to monitor an endless amount of data:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Pingdom加入了一些相当有趣的功能：现在它可以通过端点读取自定义指标，从而监控大量数据：
- en: Free space on the disks
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘上的空闲空间
- en: Used amount of RAM
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 已使用的RAM量
- en: Stock levels (yes, you can send any number of items you have left in your warehouse
    to Pingdom)
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库存水平（是的，您可以将仓库中剩余的任何商品数量发送到 Pingdom）
- en: In general, I have used Pingdom quite successfully in the past to measure the
    latency in my servers and improve the experience of the users by distributing
    the data centers strategically across the globe to mitigate this problem. One
    of the most interesting insights that Pingdom (and similar tools) can give you
    is that your site might be down due to network splits on the internet or failures
    in some DNS servers (in the latter case, it is not really down but Pingdom and
    users won't be able to reach it).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总体来说，我过去使用 Pingdom 成功地测量了服务器的延迟，并通过在全球范围内战略性地分布数据中心来改善用户体验，缓解了这个问题。Pingdom（以及类似工具）能给您的一些最有趣的见解是，您的网站可能由于互联网网络分裂或某些
    DNS 服务器的故障而无法访问（在后一种情况下，网站并未真正宕机，但 Pingdom 和用户将无法访问它）。
- en: Logentries
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Logentries
- en: 'Logentries is one of these companies that makes your life much easier when
    dealing with a large number of logs. It basically solves one problem that was
    an impediment for few years: it aggregates all the logs from your system in a
    common place with access controls and a more than decent interface that allows
    you to quickly search through big datasets.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Logentries 是一家让您在处理大量日志时轻松许多的公司。它基本上解决了一个困扰了几年的问题：它将来自系统的所有日志聚合到一个公共位置，提供访问控制，并且拥有一个非常不错的界面，允许您在大型数据集中快速搜索。
- en: Creating an account is free, and it provides 30 days of usage with some limits
    that are more than enough for testing and evaluation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 创建账户是免费的，并且提供 30 天的使用期限，带有一些足够进行测试和评估的限制。
- en: 'Go to [https://logentries.com/](https://logentries.com/) and create an account.
    Once you are logged in, the first screen should be similar to what is shown in
    the following screenshot:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://logentries.com/](https://logentries.com/) 并创建一个账户。登录后，首个屏幕应与以下截图相似：
- en: '![](img/9206f600-80f6-49c8-baeb-25f49c96e4bd.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9206f600-80f6-49c8-baeb-25f49c96e4bd.png)'
- en: 'As you can see, there are explanations for how to configure the log aggregation
    in an endless number of platforms: you can monitor from systems to libraries going
    through a number of platforms (AWS, Docker, and so on).'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，关于如何配置日志聚合的平台有无尽的解释：您可以从系统到库，经过多个平台（如 AWS、Docker 等）进行监控。
- en: 'Agents are usually a good choice for two reasons:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 代理通常是一个不错的选择，原因有二：
- en: They do not create coupling in your application (the agent reads the log files
    and sends them to the Logentries servers)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们不会在您的应用程序中创建耦合（代理读取日志文件并将其发送到 Logentries 服务器）
- en: They push the complexity to a third-party software
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们将复杂性推给了第三方软件
- en: 'But there are also other interesting options, such as manual log aggregation.
    In this case, we are going to demonstrate how to use a custom logger to send logs
    from a very simple Node.js application to Logentries. Create a folder called `logentries`
    and execute the following command:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 但也有其他有趣的选择，例如手动日志聚合。在本例中，我们将演示如何使用自定义日志记录器将日志从一个非常简单的 Node.js 应用程序发送到 Logentries。创建一个名为
    `logentries` 的文件夹并执行以下命令：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This assumes that Node.js is installed on your system, so if it is not, download
    any version of Node.js from [https://nodejs.org/en/](https://nodejs.org/en/) and
    install it.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这假设您的系统已经安装了 Node.js，因此如果没有安装，请从[https://nodejs.org/en/](https://nodejs.org/en/)下载任何版本的
    Node.js 并安装。
- en: 'Now we need to install the Logentries library for Node.js. Logentries provides
    support for a number of platforms, but support for Node.js is particularly good.
    Execute the following command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为 Node.js 安装 Logentries 库。Logentries 支持多种平台，但特别支持 Node.js。执行以下命令：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once it is finished, we should have the required library installed. Now it
    is time to create a simple `Node.js` program to demonstrate how it works, but
    first, we need to create a service token. On the following screen, click on Manual
    and fill in the form, as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们应该已安装所需的库。现在是创建一个简单的 `Node.js` 程序以演示其工作原理的时候了，但首先，我们需要创建一个服务令牌。在接下来的屏幕上，点击“手动”并填写表单，如下所示：
- en: '![](img/a3e83f22-b897-479e-aec9-3ac93bc81282.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3e83f22-b897-479e-aec9-3ac93bc81282.png)'
- en: Logentries is able to understand many different types of logs, but it really
    shines on JSON logs. We don't need to specify any type of logs for it to catch
    them, so leave this option empty and give a name to the log and the set. Once
    you click on Create Log Token, the token should be displayed after the button.
    Save it for later; you are going to need it.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: Logentries 能理解多种不同类型的日志，但它在 JSON 日志方面表现尤为出色。我们不需要为它捕捉日志指定任何日志类型，所以将此选项留空，并为日志和集合命名。点击创建日志令牌后，令牌应该会显示在按钮下方。保存起来，稍后会用到。
- en: 'Now if we go to the main dashboard, we should be able to see our log set called
    Testing Set:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们进入主仪表盘，我们应该能看到名为 Testing Set 的日志集：
- en: '![](img/e34f1ba0-b38d-4145-89d9-0362d8b130bd.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e34f1ba0-b38d-4145-89d9-0362d8b130bd.png)'
- en: 'Now it is time to send some data:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候发送一些数据了：
- en: '[PRE2]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This script is enough to send data to Logentries. Be aware that the token specified
    has to be replaced by the token obtained in the previous step. Save it as `index.js`
    and execute it a few times:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本足以将数据发送到 Logentries。请注意，指定的 token 必须替换为在前一步中获取的 token。将其保存为`index.js`并执行几次：
- en: '[PRE3]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Once you have executed it a few times, head back to Logentries and open Test
    log inside Testing Set:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 执行几次后，返回 Logentries，打开 Testing Set 中的 Test log：
- en: '![](img/a75d0030-4bea-4b68-8eed-069b93254b0e.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a75d0030-4bea-4b68-8eed-069b93254b0e.png)'
- en: 'Now you can see our logs in Logentries being aggregated. There are some interesting
    things in Logentries that have been improving with time:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到我们在 Logentries 中的日志被聚合了。Logentries 中有一些随着时间不断改进的有趣功能：
- en: The UI is quite slick
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 界面非常简洁
- en: The search mechanisms are very powerful
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 搜索机制非常强大
- en: Logentries is able to live stream the logs in real time (more or less)
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Logentries 能够实时流式传输日志（或多或少）
- en: Regarding search mechanisms, Logentries has developed something called **LEQL**,
    which is basically a language designed by Logentries to search for certain events
    using JSON fields or just plain text searching. You can find more information
    about it at [https://docs.logentries.com/v1.0/docs/search/](https://docs.logentries.com/v1.0/docs/search/).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 关于搜索机制，Logentries 开发了一种名为**LEQL**的工具，这基本上是 Logentries 为了通过 JSON 字段或纯文本搜索某些事件而设计的一种语言。你可以在[https://docs.logentries.com/v1.0/docs/search/](https://docs.logentries.com/v1.0/docs/search/)找到更多信息。
- en: 'The other interesting feature is the live tailing of the logs. Let''s test
    that feature. Create another file in the project called `livetail.js` and add
    the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能是实时跟踪日志。让我们来测试一下这个功能。创建一个名为`livetail.js`的新文件，并添加以下代码：
- en: '[PRE4]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'It does not need explanation: a function that gets executed every 500 milliseconds
    and sends a log line to Logentries.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个不需要解释：一个每 500 毫秒执行一次的函数，并将一行日志发送到 Logentries。
- en: 'Execute the script:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 执行脚本：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It might look like nothing is happening, but things are actually happening.
    Go back to Logentries and click on the Start live tail button:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来似乎什么都没发生，但实际上事情正在发生。返回 Logentries 并点击“开始实时跟踪”按钮：
- en: '![](img/92fdd2ef-b97f-4e1f-8a25-4ada23391abc.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![](img/92fdd2ef-b97f-4e1f-8a25-4ada23391abc.png)'
- en: After a couple of seconds (or less), the logs will start flowing. This can be
    done on any log file that is stored in Logentries, and it is a fairly interesting
    mechanism to debug problems in our servers.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后（或更少），日志开始流动。这可以在 Logentries 中存储的任何日志文件上完成，而且这是一个非常有趣的机制，用于调试我们服务器中的问题。
- en: 'Logentries is also able to send alerts to a certain email. You can configure
    it to alert your team on the following:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Logentries 还能够向某个邮箱发送警报。你可以配置它向你的团队发送以下警报：
- en: Exceptions
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异常
- en: Patterns
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模式
- en: Lack of logs
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缺少日志
- en: Increased activity
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加的活动
- en: This alert is usually the first indicator of problems on a system, so if you
    want an early response to errors, the best practice is to try to reduce the noise
    up to a point where alerts are not missed and the false positives are reduced
    to a minimum.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个警报通常是系统出现问题的第一个指示器，因此，如果你希望对错误做出早期响应，最佳实践是尽量减少噪声，直到警报不会被遗漏，并将假阳性减少到最低限度。
- en: AppDynamics
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AppDynamics
- en: 'AppDynamics was the king for a while (as it was the only real option on monitoring).
    It is a very curated software that allows you to explore what is going on in your
    software and servers: exceptions, requests per time unit, and CPU usage are among
    many other metrics that AppDynamics can capture for us.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: AppDynamics 曾一度是监控领域的王者（因为它是唯一真正可用的选项）。它是一款非常精心设计的软件，允许你探索软件和服务器的运行情况：异常、单位时间内的请求数、CPU
    使用率等是 AppDynamics 能为我们捕捉的众多指标之一。
- en: 'It also captures interactions with the third-party endpoints: if our software
    is consuming a third-party API, AppDynamics will know about it and display the
    calls in a dashboard similar to the next screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 它还捕捉与第三方端点的交互：如果我们的软件正在使用第三方 API，AppDynamics 将会知道并在类似于下方截图的仪表板中显示这些调用：
- en: '![](img/907bb61f-fb55-430f-96c0-bf5544feb3e1.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/907bb61f-fb55-430f-96c0-bf5544feb3e1.png)'
- en: AppDynamics is quite advanced regarding proactive measures. One of these measures
    is automated actions, such as restarting a Tomcat server or reloading a service
    running on the server on certain events. For example, if we deploy a new version
    of our Java application that is having a problem with the PermGen space (this
    is not the case anymore in Java 8+), it is usually very tricky to fix as the problem
    comes from many classes loaded by the JVM and only manifests a few hours after
    the deployment. In some cases, we can instruct AppDynamics to restart the application
    when the usage reaches 80 percent and more of the assigned total so that instead
    of crashing badly and not being able to serve to any customers, we only have a
    few dropouts every few hour getting an air balloon to act and fix the problem.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: AppDynamics 在主动措施方面相当先进。其中一项措施是自动化操作，例如在某些事件发生时重启 Tomcat 服务器或重新加载服务器上运行的服务。例如，如果我们部署了一个新的
    Java 应用版本，并且它在 PermGen 空间方面出现问题（在 Java 8+ 中不再是这个问题），这个问题通常非常难以修复，因为它源自 JVM 加载的许多类，并且只有在部署后几个小时才会显现出来。在某些情况下，我们可以指示
    AppDynamics 在使用量达到分配总量的 80% 及以上时重新启动应用程序，这样我们就不会完全崩溃并无法为任何客户提供服务，而是每隔几个小时就会有少数掉线，借助气球动作来修复问题。
- en: AppDynamics works with what is known an agent model. An application needs to
    be installed on your server (for example, Tomcat) in order to collect metrics
    that are sent to a centralized server to process and create the pertinent dashboards
    and trigger the workflows. The interesting part of AppDynamics is that if you
    don't feel comfortable sending data to a third-party (which is usually a security
    requirement for companies handling high-profile data), they provide an on-premises
    version of the dashboard.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: AppDynamics 采用所谓的代理模型。一个应用程序需要安装在你的服务器上（例如，Tomcat），以便收集指标并将其发送到集中式服务器进行处理，生成相关的仪表板并触发工作流。AppDynamics
    的有趣之处在于，如果你不愿意将数据发送给第三方（这通常是处理高敏感数据的公司所要求的安全性），它们提供了一个本地部署版本的仪表板。
- en: Stackdriver
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Stackdriver
- en: Up until now, we have visited a set of tools from different third-parties but
    now we are going to take a look at Stackdriver. Stackdriver was a cloud monitoring
    solution acquired by Google and integrated (not fully) into Google Cloud Platform.
    This is an important step for GCP, as being able to provide an integrated monitoring
    solution is something that's pretty much mandatory nowadays.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了来自不同第三方的一组工具，但现在我们将来看看 Stackdriver。Stackdriver 是一个云监控解决方案，已被 Google
    收购并（未完全）集成到 Google Cloud Platform 中。这对于 GCP 来说是一个重要的步骤，因为提供集成的监控解决方案在如今几乎是必须的。
- en: With Stackdriver, we are not only able to monitor applications, but also Kubernetes
    clusters or even standalone VMs. As we will see, the integration is not yet as
    seamless as we would desire (it might be completed by the time you are reading
    this), but it is good enough to be considered a big player in the market.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Stackdriver，我们不仅能够监控应用程序，还能监控 Kubernetes 集群甚至独立的虚拟机。正如我们将看到的那样，集成还不像我们希望的那样无缝（可能在你阅读这篇文章时已经完成），但它足够好，可以被认为是市场中的重要玩家。
- en: Monitoring applications
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控应用程序
- en: 'Stackdriver can monitor standalone applications by capturing metrics and logs.
    It has support for major platforms and libraries, so our technology choices should
    not be a concern. In this case, we are going to create a Node.js application for
    several reasons:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Stackdriver 可以通过捕获指标和日志来监控独立应用程序。它支持主要平台和库，因此我们的技术选择不必担心。在这种情况下，我们将创建一个 Node.js
    应用程序，原因有几个：
- en: It is easy to understand
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它易于理解
- en: The official examples are well documented for the Node.js version
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方示例在 Node.js 版本上有很好的文档记录。
- en: Node.js is increasingly becoming a big platform for enterprise and startups
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js 正在逐渐成为企业和初创公司中的重要平台。
- en: 'The first thing we need to do is write a small Node.js application. Create
    a new folder and execute this command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是编写一个小的 Node.js 应用程序。创建一个新的文件夹并执行以下命令：
- en: '[PRE6]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Follow the instructions on the screen and you should now have `package.json`
    in the folder that you just created. Now it is time to install the dependencies:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 按照屏幕上的指示操作，你现在应该已经在刚创建的文件夹中得到了 `package.json`。现在是时候安装依赖项了：
- en: '[PRE7]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We are going to use four libraries:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用四个库：
- en: '**express**: To handle the HTTP requests'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**express**：用于处理 HTTP 请求'
- en: '**bunyan**: To log our application activity'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**bunyan**：用于记录我们应用程序的活动'
- en: 'The two libraries from Google are for interacting with Stackdriver:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 Google 的两个库用于与 Stackdriver 交互：
- en: '**logging-bunyan**: This will send the logs from bunyan to Stackdriver'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logging-bunyan**：这个库将把 bunyan 的日志发送到 Stackdriver'
- en: '**trace-agent**: This will trace the requests through our application'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**trace-agent**：这个库将追踪请求通过我们的应用程序'
- en: 'Now let''s create a simple application:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个简单的应用程序：
- en: '[PRE8]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now it is time to explain what the interesting parts of the code do:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候解释代码中有趣的部分了：
- en: The first line enables the tracing for Stackdriver. It is very important that
    this line happen before anything else; otherwise, the tracing won't work. We'll
    see how amazing the tracing is.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一行启用了 Stackdriver 的追踪功能。非常重要的是，这一行必须在其他任何操作之前执行，否则追踪将无法工作。我们将看到追踪功能的强大之处。
- en: In order to let Stackdriver collect logs, we need to add a stream to the bunyan
    logger, as shown in the code.
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了让 Stackdriver 收集日志，我们需要向 bunyan 日志记录器添加一个流，代码中已展示。
- en: 'Everything else is quite normal: an `Express.js` Node.js application that has
    a handler for the URL/replying with the classic Hello World.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 其他一切都很正常：一个 `Express.js` Node.js 应用程序，处理 URL 请求并返回经典的 Hello World。
- en: 'There is one thing missing: there are no credentials to access the remote APIs.
    This is done on purpose as Google Cloud Platform has a very sophisticated system
    for handling credentials: basically, it will be handled for you.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个缺失的东西：没有用于访问远程 API 的凭证。这样做是故意的，因为 Google Cloud Platform 有一个非常复杂的凭证管理系统：基本上，它会为你处理这些。
- en: Now, it is time to deploy our application. First, create a VM in Google Cloud
    Platform, as we have seen a few times in the previous chapters. A small one will
    suffice, but make sure that you allow HTTP traffic. Debian Stretch is a good choice
    as an operating system.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候部署我们的应用程序了。首先，在 Google Cloud Platform 创建一个虚拟机，就像我们在前面的章节中看到的几次一样。选择一个小型虚拟机即可，但要确保允许
    HTTP 流量。Debian Stretch 是一个不错的操作系统选择。
- en: Once the machine is up, install Node.js, as shown in [http://nodejs.org](http://nodejs.org.).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦机器启动，安装 Node.js，如[http://nodejs.org](http://nodejs.org)所示。
- en: 'Now we need to copy the code into our newly created machine. The best solution
    is to create a GitHub repository or use mine: [https://github.com/dgonzalez/stackdriver](https://github.com/dgonzalez/stackdriver).'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将代码复制到新创建的机器中。最好的解决方案是创建一个 GitHub 仓库，或者使用我的：[https://github.com/dgonzalez/stackdriver](https://github.com/dgonzalez/stackdriver)。
- en: 'By cloning it in our VM (don''t forget to install Git first via `apt`), we
    just need to install the dependencies with the following command:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的虚拟机中克隆它（别忘了先通过 `apt` 安装 Git），我们只需要使用以下命令来安装依赖项：
- en: '[PRE9]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And we are good to go. Just run the application with the following command:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好开始了。只需运行以下命令启动应用程序：
- en: '[PRE10]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now go to the external IP of the machine (shown in Google Compute Engine) on
    port `3000`. In my case, this is [http://35.195.151.10:3000/](http://35.195.151.10:3000/).
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在转到机器的外部 IP（在 Google Compute Engine 中显示）并访问 `3000` 端口。在我的案例中，这是 [http://35.195.151.10:3000/](http://35.195.151.10:3000/)。
- en: 'Once we have done it, we should see Hello World in the browser and something
    similar to the following in the logs of our app:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们完成，我们应该能在浏览器中看到 Hello World，并在我们的应用日志中看到类似以下内容：
- en: '[PRE11]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: If there are no errors, everything worked. In order to verify this, go to [http://console.cloud.google.com](http://console.cloud.google.com)
    and open the Logging section of Stackdriver.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有错误，那么一切正常。为了验证这一点，访问 [http://console.cloud.google.com](http://console.cloud.google.com)
    并打开 Stackdriver 的日志部分。
- en: Stackdriver is a different system from Google Cloud Platform; it might ask you
    to log in using a Google account.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: Stackdriver 是一个与 Google Cloud Platform 不同的系统；它可能会要求你使用 Google 账户登录。
- en: 'Once you are there, you should see something similar to what is shown in the
    following screenshot:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你到达那里，你应该看到类似于以下截图的内容：
- en: '![](img/03f49c27-f2be-4088-a08b-4ee15ef61622.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![](img/03f49c27-f2be-4088-a08b-4ee15ef61622.png)'
- en: Be aware that you have to select the section on the logs, in my case, GCE VM
    Instance, Instance-3.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你必须选择日志部分，在我的情况下是 GCE VM 实例，Instance-3。
- en: 'This is exactly the log from your app uploaded to Google Cloud Platform with
    a bunch of very interesting information. You can play around by having different
    handlers for other URLs and different logging events, but the result is the same:
    all your logs will be aggregated here.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是从你的应用程序上传到Google Cloud Platform的日志，包含了一些非常有趣的信息。你可以尝试使用不同的处理程序来处理其他URL和不同的日志事件，但结果是一样的：所有日志都会聚合到这里。
- en: Now we can do this with Trace as well. Open the trace section of Google Cloud
    Platform under Stackdriver.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们也可以使用Trace来实现这一点。打开Google Cloud Platform中Stackdriver下的trace部分。
- en: 'The screen should look similar to what is shown in the following screenshot
    (select the traces list option):'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕应类似于以下截图所示（选择trace列表选项）：
- en: '![](img/4f941972-0f9c-4d51-a960-6f139d553aaf.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4f941972-0f9c-4d51-a960-6f139d553aaf.png)'
- en: 'As you can see, there is a lot of useful information:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，提供了很多有用的信息：
- en: The call stack
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用栈
- en: Duration
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 持续时间
- en: Start and finish time
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 启始和结束时间
- en: 'You can also play around, issue multiple calls, and get familiar yourself with
    how it works. Now we are going to modify our program to call a third-party API
    and see how Stackdriver is able to trace it:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以自己玩一玩，发出多个调用，熟悉它是如何工作的。现在，我们将修改我们的程序，调用第三方API，看看Stackdriver如何追踪它：
- en: '[PRE12]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we are listing all the available APIs on Google by executing an HTTP GET
    into the [https://www.googleapis.com/discovery/v1/apis](https://www.googleapis.com/discovery/v1/apis.)
    URL. Redeploy it into your VM in Google Cloud Platform and go to the endpoint/discovery
    of your VM. A big JSON payload will be presented on your screen, but the interesting
    part is happening under the hood. Go back to Stackdriver in the Trace list section,
    and you''ll see that there is a new trace being captured:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过执行HTTP GET请求访问[https://www.googleapis.com/discovery/v1/apis](https://www.googleapis.com/discovery/v1/apis)
    URL，列出了所有可用的Google API。将其重新部署到Google Cloud Platform上的虚拟机中，然后访问虚拟机的endpoint/discovery。一个大的JSON负载将会显示在你的屏幕上，但真正有趣的部分发生在后台。返回Stackdriver的Trace列表部分，你会看到一个新的trace正在被捕捉：
- en: '![](img/e204ee46-fdff-4a4f-9bbf-85d13fad6481.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e204ee46-fdff-4a4f-9bbf-85d13fad6481.png)'
- en: Here, you can see how our program contacted the remote API and that it took
    68 seconds to reply.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到我们的程序如何联系远程API，并且它花费了68秒才得到回复。
- en: Getting this type of information in real time is very powerful--if customers
    are getting a very large response time, we can immediately see what is happening
    inside of our application pretty much real-time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实时获取这种信息非常强大——如果客户响应时间非常长，我们可以几乎实时地看到应用程序内部发生了什么。
- en: Monitoring Kubernetes clusters
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控Kubernetes集群
- en: 'Kubernetes covers 99 percent of the needs for any software company, but one
    part where it does not really shine is in embedded monitoring, leaving a space
    to be filled by third-parties. The main problem with Kubernetes comes from Docker:
    containers are ephemeral, so a common practice is to dump the logs into the standard
    output/error and use *syslogd* to gather them in a centralized location.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes覆盖了任何软件公司99%的需求，但它在嵌入式监控方面并不十分出色，因此留给了第三方来填补这一空白。Kubernetes的主要问题源于Docker：容器是临时性的，因此常见的做法是将日志转储到标准输出/错误中，并使用*syslogd*将它们收集到一个集中位置。
- en: 'With Kubernetes, we have an added problem: the orchestrator on top of Docker
    needs to know how to fetch logs in order to make them available via the API or
    dashboard, so it is possible for the user to access them when required. But then
    there is another problem. Usually, logs are rotated on the basis of time and archived
    in order to avoid a log sprawl that can consume all the free space in our servers,
    preventing the application (and the OS) from functioning normally.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Kubernetes，我们遇到了一个额外的问题：Docker上的调度器需要知道如何获取日志，以便通过API或仪表板将其提供，使用户在需要时能够访问它们。但是，随之而来的是另一个问题。通常，日志会根据时间进行轮换并归档，以避免日志溢出，这可能会消耗我们服务器上的所有可用空间，导致应用程序（以及操作系统）无法正常运行。
- en: 'The best solution is to use an external system to aggregate logs and events
    inside the cluster so that we push the complexity to the side, allowing Kubernetes
    to focus on what it does best: orchestrate containers.'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 最佳解决方案是使用外部系统在集群内聚合日志和事件，从而将复杂性转移到一旁，让Kubernetes专注于它最擅长的事情：调度容器。
- en: 'In this case, in order to integrate our cluster with Stackdriver in Google
    Cloud Platform, the only thing that we need to do is mark the two checkboxes in
    the cluster creation screen:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为了将我们的集群与Google Cloud Platform中的Stackdriver集成，我们需要做的唯一事情就是在集群创建屏幕上勾选两个复选框：
- en: '![](img/baf7c352-db8f-4c39-8c9b-536c8cdc520d.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/baf7c352-db8f-4c39-8c9b-536c8cdc520d.png)'
- en: This will enable the monitoring across the different nodes in our cluster and
    improve the way in which we tackle problems happening in our applications. Click
    on Create and allow the cluster to be provisioned (might take a few seconds or
    even minutes). It does not need to be a big cluster; just use the small size for
    the machines, and two VMs will be enough. In fairness, we will probably need to
    reduce the size during the load testing in order to speed up the alerting part.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将启用跨我们集群中不同节点的监控，并改善我们处理应用程序中出现问题的方式。点击“创建”，允许集群被配置（可能需要几秒钟或几分钟的时间）。集群不需要很大；只需使用小型机器，两个虚拟机就足够了。公平地说，我们可能需要在负载测试期间减少规模，以加速警报部分的处理。
- en: As we've seen in the previous section, with GKE monitoring active, Kubernetes
    also sends the logs to the Logging capabilities of Stackdriver, so you don't need
    to connect to the nodes to fetch the logs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前一部分看到的那样，启用 GKE 监控后，Kubernetes 还将日志发送到 Stackdriver 的日志功能，因此您无需连接到节点来获取日志。
- en: 'Once it is created, we are going to add monitoring from Stackdriver. The first
    thing that we need to do is open Monitoring in the Stackdriver section of Google
    Cloud Platform. This will open a new site, the original Stackdriver site, which
    looks very similar to what is shown in the following screenshot:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建完成，我们将从 Stackdriver 添加监控。我们需要做的第一件事是打开 Google Cloud Platform 中 Stackdriver
    部分的监控功能。这将打开一个新页面，原始的 Stackdriver 页面，外观与以下截图所示的非常相似：
- en: '![](img/19caa285-4659-4d30-bf1f-6a762404e29f.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/19caa285-4659-4d30-bf1f-6a762404e29f.png)'
- en: 'Even though the UI might be a bit confusing in the beginning, after a bit of
    usage, it becomes clear that it is really hard to pack the huge amount of functionality
    that Stackdriver offers in a better UI. By default, we can see some metrics about
    our cluster (the bottom-right section of the image), but they are not very useful:
    we don''t want to have someone looking at the metrics the full day in order to
    raise alerts. Let''s automate it. The first thing that we need to do is create
    a group. A group is basically a set of resources that work together, in this case,
    our cluster. Click on Groups and create a new one:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管一开始用户界面可能有些令人困惑，但经过一段时间的使用后，我们会发现，Stackdriver 提供的大量功能很难在更好的 UI 中打包展示。默认情况下，我们可以看到一些关于集群的指标（图像右下角部分），但它们并不是非常有用：我们不希望有人整天盯着这些指标来触发警报。让我们来自动化它。我们需要做的第一件事是创建一个组。组基本上是一起工作的资源集合，在这种情况下，就是我们的集群。点击“组”并创建一个新组：
- en: '![](img/c5ed7da1-5fe7-4c21-904f-a7d485473a22.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c5ed7da1-5fe7-4c21-904f-a7d485473a22.png)'
- en: By default, Stackdriver will suggest groupings to you. In this case, in the
    suggested Groups section, we can see that Stackdriver has suggested our cluster.
    It is possible to add more sophisticated criteria, but in this case, matching
    the start of the name of our machines will work as the GKE names them according
    to some criteria, including the name of the cluster in the very beginning.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Stackdriver 会为您提供分组建议。在此情况下，在建议的组部分，我们可以看到 Stackdriver 已经建议了我们的集群。虽然可以添加更复杂的标准，但在这种情况下，匹配我们机器名称的开头就足够了，因为
    GKE 会根据某些标准命名机器，集群名称会出现在名称的开头。
- en: 'Create a group (call it GKE, the default suggested name). Once the group is
    created, you can navigate to it and see different metrics such as CPU or even
    configure them, adding others such as disk I/O and similar. Get yourself familiar
    with the dashboard:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个组（命名为 GKE，这是默认建议的名称）。创建组后，您可以导航到该组并查看不同的指标，如 CPU，或者甚至配置它们，添加其他如磁盘 I/O 等指标。熟悉一下仪表板：
- en: '![](img/83a4112e-e61b-4e53-a521-96307731700f.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83a4112e-e61b-4e53-a521-96307731700f.png)'
- en: 'In my case, I have added a metric for capturing the used memory in the cluster.
    Even though this amount of available data is quite interesting, there is an even
    more powerful tool: the alerting policies.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，我添加了一个用于捕获集群中已用内存的指标。尽管这些可用数据非常有趣，但还有一个更强大的工具：警报策略。
- en: 'The alerting policies are criteria in which we should get alerted: high memory
    usage, low disk space, or high CPU utilization, among others, are events that
    we want to know about in order to take actions as soon as possible. The beauty
    of the alerting policies is that if we configure them as appropriated, we enter
    a state that I call the *autopilot* mode: we don''t need to worry about the performance
    of the system unless we get alerted, which drastically reduces the number of people
    required to operate a system.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 警报策略是我们应该得到警报的标准：高内存使用率、低磁盘空间或高CPU利用率等事件，是我们希望了解的，以便尽快采取行动。警报策略的优点是，如果我们正确配置它们，我们就进入我所称的*自动驾驶*模式：除非收到警报，否则我们无需担心系统的性能，这大大减少了操作系统所需的人员数量。
- en: 'Let''s create an alerting policy by clicking on the Create Alerting Policy
    button:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“创建警报策略”按钮，来创建一个警报策略：
- en: '![](img/3e07ab7d-4293-47e0-af8f-e49942c6999b.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e07ab7d-4293-47e0-af8f-e49942c6999b.png)'
- en: As shown in the preceding screen, we need to select a metric. We are going to
    use the type Metric Threshold as it is included in the basic package of Stackdriver,
    so we don't need to upgrade to a Premium subscription. Our alert is going to be
    raised if any of the members of our cluster has a CPU usage of more than 30 percent
    for one minute.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如前屏幕所示，我们需要选择一个度量标准。我们将使用“度量阈值”类型，因为它包含在Stackdriver的基础包中，所以我们不需要升级到Premium订阅。如果我们集群中的任何成员的CPU使用率超过30％，且持续超过一分钟，就会触发警报。
- en: The next step is to configure the notification. In the basic package, only email
    is included, but it is sufficient to test how the system works. Stackdriver also
    allows you to include text to be sent across with the notification. Just enter
    something like `Test alert` alongside your email and save the alert policy with
    the name of your choice.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置通知。在基础包中，仅包含电子邮件功能，但它足以用来测试系统的运行情况。Stackdriver还允许你在通知中包含文本。只需在电子邮件旁边输入类似`Test
    alert`的内容，并保存你选择名称的警报策略。
- en: As you can see, creating alerts is very simple in Stackdriver. This is a very
    simplistic example, but once you have set up your cluster, the next step is to
    set up the acceptable set of metrics where it should operate normally and get
    alerted if any of them is violated.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在Stackdriver中创建警报非常简单。这是一个非常简化的示例，但一旦你设置好了集群，下一步是设置一组正常操作的度量标准，并在其中任何一个被违反时接收警报。
- en: 'Now it is time to set off the alarm to see what happens. In order to do that,
    we need to overload the cluster with several replicas of the same image, and we
    are going to use a tool called Apache benchmark to generate a load on the system:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候触发警报，看看会发生什么。为此，我们需要通过多个相同镜像的副本来过载集群，我们将使用Apache Benchmark工具给系统施加负载：
- en: '[PRE13]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And now expose the deployment called `my-nginx`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在暴露名为`my-nginx`的部署：
- en: '[PRE14]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Be aware that you first need to configure `kubectl` to point to your cluster,
    as we've seen in previous chapters.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你首先需要配置`kubectl`指向你的集群，正如我们在之前的章节中看到的那样。
- en: 'Once nginx is deployed, it is time to stress it out:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: nginx部署完成后，接下来就该对其进行压力测试了：
- en: '[PRE15]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `ab` tool is a very powerful benchmark tool called Apache Benchmark. We
    are going to create 350 concurrent consumers, and they will issue 4 million requests
    in total. It might be possible that you need to reduce the size of your cluster
    in order to stress the CPU: if you reduce the size while the benchmark is running,
    Kubernetes will need to reschedule containers to reorganize the resources, adding
    more load to the system.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ab`工具是一个非常强大的基准测试工具，叫做Apache Benchmark。我们将创建350个并发消费者，它们将发出400万个请求。可能需要减少集群的规模来施加压力：如果在基准测试运行时减少规模，Kubernetes将需要重新调度容器以重新组织资源，这将增加系统的负载。'
- en: I would recommend that you further explore Apache Benchmark, as it is very useful
    for load testing.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你进一步探索Apache Benchmark工具，因为它对于负载测试非常有用。
- en: 'Once the CPU has gone beyond the threshold for any of our nodes for over a
    minute, we should receive an alert by email, and it should be displayed in the
    Stackdriver interface:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦任何节点的CPU使用超过阈值超过一分钟，我们应该通过电子邮件收到警报，并且它会显示在Stackdriver界面中：
- en: '![](img/54f0b210-4fd8-4c97-864e-8f60fca91024.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54f0b210-4fd8-4c97-864e-8f60fca91024.png)'
- en: In this case, I have received two alerts as two of the nodes went beyond the
    limits. These alerts follow a workflow. You can acknowledge them if the rule is
    still broken and they will go to resolved once they are acknowledged and the condition
    has disappeared. In this case, if you stop Apache Benchmark and acknowledge the
    raised alerts, they will go straight into the resolved state.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个案例中，我收到了两个警报，因为两个节点超出了限制。这些警报遵循一个工作流。如果规则仍然被违反，你可以确认它们，一旦确认并且条件消失，它们就会变为已解决状态。在这种情况下，如果你停止Apache
    Benchmark并确认已触发的警报，它们会直接进入已解决状态。
- en: In the Premium version, there are more advanced policies, such as Slack messages
    or SMS, which allows your team to set up a rota for acknowledging incidents and
    managing the actions.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在高级版本中，有更多高级策略，如Slack消息或短信，这使得你的团队能够设置一个轮班表来确认事件并管理相关操作。
- en: Summary
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'This is the final chapter of the book. Through the entire book, we visited
    the most important tools used by DevOps engineers, with a strong focus on the
    Google Cloud Platform. In this chapter, we experimented with what, in my opinion,
    is a very important aspect of any system: monitoring. I am of the opinion that
    monitoring is the best way to tackle problems once they have hit your production
    systems, which, no matter how much effort you put in it, will eventually happen.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章。在整本书中，我们探讨了DevOps工程师使用的最重要的工具，重点介绍了Google云平台。在本章中，我们实验了我认为对任何系统都非常重要的一个方面：监控。我认为监控是应对已经影响到生产系统的问题的最佳方法，无论你投入多少努力，这些问题最终都会发生。
- en: What is next?
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: 'This book did not go particularly in deep into any subject. This is intended.
    This book is meant to plant the seed of a big tree: the culture of DevOps, hoping
    that you have enough information to keep growing your knowledge of DevOps tools
    and processes.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 本书并没有对任何主题进行特别深入的探讨。这样做是有意为之。本书旨在播下大树的种子：DevOps文化，目的是希望你能获得足够的信息来继续拓展对DevOps工具和流程的了解。
- en: Keeping yourself up to date with the latest tools is a full-time job on its
    own, but it's very necessary if you want to be on the top of the wave. My opinion
    is that we are very lucky to be able to participate in the rise and shine of the
    DevOps culture, and the future is bright. Automation and better languages (Golang,
    Kotlin, Node.js, and so on) will allow us to reduce human intervention, improving
    the overall resilience of our systems.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 保持与最新工具同步是一项全职工作，但如果你想站在技术潮流的前沿，这非常必要。我认为我们很幸运能够参与DevOps文化的崛起与辉煌，未来一片光明。自动化和更好的编程语言（如Golang、Kotlin、Node.js等）将使我们减少人工干预，提升系统的整体弹性。
- en: If you look five years back and compare it with what it is there in the market
    today, can you imagine how our jobs are going to be in 15 years?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回顾五年前并与今天市场上的情况进行对比，你能想象我们在15年后的工作会是怎样的吗？
- en: 'If you want to follow up about any question or check what I am working on nowadays,
    you can always get in touch with me in LinkedIn:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想跟进任何问题或查看我现在正在做的事情，你可以随时通过LinkedIn与我联系：
- en: '[https://www.linkedin.com/in/david-gonzalez-microservices/](https://www.linkedin.com/in/david-gonzalez-microservices/)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.linkedin.com/in/david-gonzalez-microservices/](https://www.linkedin.com/in/david-gonzalez-microservices/)'
