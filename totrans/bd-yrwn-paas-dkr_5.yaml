- en: Chapter 5. Connecting Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s time to connect all our three containers to form a single unit of modularized
    parts. I''ll introduce you to two services, **Docker Compose** and **Crane**,
    which can be used to automate this. We''ll go through the following topics in
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Manually connecting containers together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the contents of a data volume container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting containers to a configuration file using Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting containers to a configuration file using Crane
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually connecting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to connect our service containers to our data volume
    container. First, we have to run our data volume container, then run our MySQL
    container, and lastly run our WordPress container, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have fired up and named the data volume container `data-one`. The next
    line fires up the MySQL container, named `mysql-one`, and gives it the data volume
    container. The last line fires up our WordPress container, named `wordpress-one`,
    links `mysql-one` as the MySQL link, and gives it the data volume container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manually connecting containers](img/3946OT_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open your web browser and head over to the container's URL and port in order
    to verify that all the services are running and the containers are tied together
    as they should be. You should see the, now familiar, WordPress installation page.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have figured out by now, you can fire up another WordPress container
    using the same MySQL link and the same data volume container. What do you think
    will happen?
  prefs: []
  type: TYPE_NORMAL
- en: The new WordPress container will be another instance of the same WordPress site,
    with the same files and the same database.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you link containers, Docker will set some environment variables in the
    target container in order to enable you to get information about the linked source
    container. In our case, these environment variables will be set when we link the
    MySQL container, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Exploring the contents of a data volume container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is the data being written to the data volume container? Or, is the data stored
    inside the MySQL and WordPress containers when connected? How can you tell?
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to determine this is to enter a container via a shell so that you can
    navigate around its filesystem. Since version 1.3, Docker has the ability to start
    a new instance of a container''s shell. Running the old `docker attach` command
    just gets you in the current shell instance, which in our case has `tail –f /dev/null`
    running. If we exit this `tail` command, the container will exit and shut down.
    Therefore, we need a new shell instance in a running container so that we can
    invoke any commands we want inside the container without the risk of the container
    exiting. The following command can be used to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `–i` and `–t` flags mean that we want to keep the session interactive and
    allocate a pseudo-TTY. `data-one` is the name of the container, but you can use
    the container ID if you like. I would choose `/bin/bash` over `/bin/sh`, but the
    container runs BusyBox and `/bin/bash` isn't available there. For the kinds of
    tasks that we are about to perform, it doesn't matter which shell we use.
  prefs: []
  type: TYPE_NORMAL
- en: What we want to do is to take a look in the directories we exposed as `VOLUMES`
    in this data volume container. The directories are `/var/www/html` and `/var/lib/mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the contents of a data volume container](img/3946OT_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We see files on both those directories, which indicates that the two other containers
    are writing to this one. It separates the services with the data. If you want
    further proof, launch `vi` in the shell, edit a file, and reload the site in your
    browser.
  prefs: []
  type: TYPE_NORMAL
- en: This worked out really smooth and easy, didn't it? The containers interact with
    each other and all we have to do is to link them together with just one command.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting containers using Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Docker Compose was previously called Fig, but Docker acquired Fig and the name
    was changed. This is how Docker describes Docker Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Compose is a tool for defining and running complex applications with Docker.
    With Compose, you define a multi-container application in a single file, then
    spin your application up in a single command which does everything that needs
    to be done to get it running."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Docker Compose basically gives us a way to define settings in a configuration
    file, so we don't have to remember all the names for all the containers when linking
    them together, the ports to expose, the data volume container to use, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Compose has regular releases on GitHub, and at the time of writing this
    book, the latest release is 1.0.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will install Docker Compose with the Python package manager, pip. Our EC2
    instance does not come with pip installed, so we have to start with the installation,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing Docker Compose](img/3946OT_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After pip is installed, you can go ahead and install Docker Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Now, you'll see Docker Compose installed along with all of its dependencies.
    Invoke `docker-compose --version` to verify that it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Basic Docker Compose commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the basic Docker Compose commands that you should be familiar
    with:'
  prefs: []
  type: TYPE_NORMAL
- en: '`build`: This is used to build or rebuild services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kill`: This forces the service containers to stop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: This views the output from the services'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`port`: This is used to print the public port for a port binding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`: This is used to list containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pull`: This is used to pull service images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm`: This is used to remove stopped service containers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run`: This is used to run a one-off command on a service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scale`: This sets the number of containers to be run for a service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`: This is used to start existing containers for a service'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stop`: This stops running containers without removing them'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`up`: This builds, recreates, starts, and attaches to containers for a service;
    linked containers will be started, unless they are already running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the commands are very similar to the Docker client commands
    and most of them do the exact same thing by forwarding the commands to the Docker
    daemon. We will go through some of them a little more in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When the word `service` is used with Docker Compose, it refers to a named container
    in a `docker-compose.yml` configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: Using the run command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are used to starting containers with the `run` command for the Docker client.
    With docker-compose, the `run` command is very different. When you `run` a command
    with docker-compose, it's a one-off command on a service. This means that if we
    name a container configuration `Ubuntu` and invoke `docker-compose run ubuntu
    /bin/bash echo hello`, the container will start and execute `/bin/bash echo hello`
    and then shut down. The difference with this and running the command directly
    with Docker is that all the linked containers and `VOLUME` containers will be
    started and connected when you use docker-compose.
  prefs: []
  type: TYPE_NORMAL
- en: Using the scale command
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `scale` command is very interesting. When we invoke `docker-compose scale
    web=3`, we actually start three containers of the service that we named `web`.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up our PaaS with Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Every Docker Compose instance lives in its own directory and has a configuration
    file named `docker-compose.yml` inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the contents of our `docker-compose.yml` file will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we have defined three services here, namely `wp`, `mysql`,
    and `paasdata`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lets try these services and the following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our PaaS with Docker Compose](img/3946OT_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Invoke `docker-compose up –d` to run `docker-compose` and the containers in
    daemon mode.
  prefs: []
  type: TYPE_NORMAL
- en: That's how easy it is. Open your web browser and head to your Docker host and
    the port stated in the table (in my case, port **49155**); you should see the
    very familiar WordPress installation page.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting containers using Crane
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Crane is much like Docker Compose, but it has more configuration possibilities.
    This is how its creator describes Crane:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Crane is a tool to orchestrate Docker containers. It works by reading in
    some configuration (JSON or YAML) which describes how to obtain images and how
    to run containers. This simplifies setting up a development environment a lot
    as you don''t have to bring up every container manually, remembering all the arguments
    you need to pass. By storing the configuration next to the data and the app(s)
    in a repository, you can easily share the whole environment."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: This paragraph can be about Docker Compose as well, as you can see.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Crane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Crane is easy to install but not easy to keep updated. The same command is used
    to install as well as update, so we have to invoke this once in a while in order
    to have the latest version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Invoke the following command on a single line to install Crane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Crane is now installed in `/usr/local/bin`.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I won''t go through all the commands here since they''re similar to Docker
    Compose''s commands, but I''ll comment on a few here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`lift`: This command, like Docker Compose''s `up` command, builds and runs
    containers from your configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`graph`: This prints your containers'' relations from the configuration file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`: This maps to the Dockers Compose''s command, but here you can get the
    logs for a whole group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status`: This also maps to the Dockers Compose''s command but lets you get
    the logs for a group'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is where Crane really leaves Docker Compose behind. You have many more
    configuration options for Crane apps. The configuration file must be named `crane.json`
    or `crane.yaml`. For every container, this is what you can configure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`image` (string, required): This is the name of the image to build/pull'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dockerfile` (string, optional): This gives the relative path to the Dockerfile'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`run` (object, optional): These parameters are mapped to Docker''s`run` and
    `create` commands:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'add-host (array): This adds custom host-to-IP mappings'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: cpuset (integer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: cpu-shares (integer)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: detach (boolean) `sudo docker attach <container name>` will work as normal
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'device (array): This adds host devices'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: dns (array)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: entrypoint (string)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: env (array)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'expose (array): This denotes the ports to be exposed to linked containers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: hostname (string)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: interactive (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'link (array): This links containers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: memory (string)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: privileged (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'publish (array): This maps network ports to the container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: publish-all (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: restart (string) Restart policy
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: rm (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: tty (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'volume (array): In contrast to plain Docker, the host path can be relative'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'volumes-from (array): This is used to mount volumes from other containers'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: workdir (string)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd` (array/string): This command is used to append to `docker run` (overwriting
    CMD)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm (object, optional):` These parameters are mapped to Docker''s `rm` command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: volumes (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start (object, optional)`: These parameters are mapped to Docker''s `start`
    command:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: attach (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: interactive (boolean)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Set up the same configuration that you did in Docker Compose; it will look
    something like the following code. As you might understand, you can write this
    in the JSON format as well, but for the comparison to Docker Compose''s version
    to be as easy as possible, I''ll keep it in the `yaml` format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify three containers, where the data container is added as a data
    volume container to the others and the MySQL container is linked to the WordPress
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Save this file as `crane.yaml` and type `crane lift` to run your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration](img/3946OT_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see the containers'' current statuses, we can type `crane status`. Take
    a look at the last column in our `wp` container. It says it''s not running. Type
    `crane` `logs wp` and see what it says in following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It seems that our WordPress container starts faster than our MySQL container,
    so the WordPress container can't find it when it starts.
  prefs: []
  type: TYPE_NORMAL
- en: This can happen in Docker Compose as well because there's no check if `--link:ed`
    containers are up, at least not at the time when this is being written.
  prefs: []
  type: TYPE_NORMAL
- en: This cannot be solved in Docker Compose; we have to rely on pure luck that the
    MySQL container will get ready before the WordPress container tries to use the
    linked MySQL container.
  prefs: []
  type: TYPE_NORMAL
- en: With Crane, you can group containers inside the configuration file in different
    groups and then `run` commands on that group instead of the whole configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is very easy; we just add these lines at the end of our `crane.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have separated the WordPress container from the other two containers
    we have so that we can `run` commands on them separately.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start our `data_db` group first by invoking the `crane lift data_db --recreate`
    command. I added the flag `--recreate` and to make sure that we're creating new
    containers and not reusing the old ones. Run `crane status data_db` to make sure
    they're running.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know that the MySQL container is running, we can start the WordPress
    container by invoking the `crane lift web --recreate` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following output is displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuration](img/3946OT_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we can connect containers in different ways to keep different services
    separate on different containers. We learned how to do this manually, which can
    be quite hard when you have lots of dependencies between containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We had a brief look at two orchestration tools: Docker Compose and Crane. Crane
    is an independent and more advanced tool for the administrators who want more
    control over containers. The ability to group containers in Crane makes it more
    reliable when there can be timing issues in dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will run two instances of our app using Crane to see
    what problems and possibilities crop up when we want to make both our blogs publicly
    accessible on the regular HTTP port (80).
  prefs: []
  type: TYPE_NORMAL
