- en: '*Chapter 3*: Sharing Containers Using Docker Hub'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to build a container and run it on our
    workstation using Docker. We used a Debian image as our starting point, but where
    did that image come from? The answer is that it came from Docker Hub. Docker Hub
    is the official container image library for Docker, run by the same folk who brought
    us Docker itself.
  prefs: []
  type: TYPE_NORMAL
- en: The container library contains the official images for numerous programs, servers,
    services, and so on that you might install within your own containers. For example,
    there are official images for various Linux distributions, versions of [Node.js](http://Node.js),
    versions of MySQL and MongoDB, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of Docker Hub as being like GitHub. You can explore existing organizations
    and pre-made containers, as well as upload your own containers and create your
    own organizations.
  prefs: []
  type: TYPE_NORMAL
- en: We will demonstrate how to use the Docker Hub website to search and get information
    for third-party containers that you can use in your applications. We will also
    demonstrate how to use third-party containers from Docker Hub using the command
    line. We will use the official MongoDB container from Docker Hub, which is published
    by MongoDB, Inc.
  prefs: []
  type: TYPE_NORMAL
- en: Entire backend applications can be implemented as a combination of multiple
    Docker containers working together. This application structure allows each of
    our custom container implementations to be simple and minimal. We'll apply microservices
    architecture to build a simple application. This demonstrates how containers can
    work together to create a complete working application. Lastly, we'll see how
    you can share your ready-for-production containers with third parties and your
    development team using Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a MongoDB container for our application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the microservices architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a sample microservices application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing your containers on Docker Hub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The only technical requirements are to have Docker installed on your host, and
    a browser, such as Google Chrome, Firefox, or Microsoft Edge. This is one of the
    best parts of Docker—you don't have to install the complex servers/services on
    your host; we install them in Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: We have prepared examples that you can use directly without modification in
    a public GitHub repository, which can be found at [https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/2PTADjH](https://bit.ly/2PTADjH)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will typically interact with Docker Hub from the command line or in Dockerfiles,
    but you can use the Docker Hub website ([https://hub.docker.com](https://hub.docker.com))
    to search for any pre-built containers that you know you want to use. You can
    also use the website to discover pre-built containers that might be of interest
    to you.
  prefs: []
  type: TYPE_NORMAL
- en: In general, you will inherit from some pre-built Docker containers on Docker
    Hub to create your own custom containers. For example, you might inherit from
    a Linux distribution container and install the software you want for your project
    within that inherited/custom container.
  prefs: []
  type: TYPE_NORMAL
- en: When you inherit from the Linux distribution, some of that distribution's base
    software packages are installed. If you inherit from a Debian-flavor Linux container,
    you will be able to use the `apt` package manager within the container to install
    software as if you were running that Debian-flavor Linux container on a dedicated
    or virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: Some pre-built containers inherit from a Linux flavor and provide pre-installed
    packages that are specific to the offering. When you inherit from a [Node.js](http://Node.js)
    container, that [Node.js](http://Node.js) container might inherit from a Linux
    distribution container and will have [Node.js](http://Node.js), `npm`, and `yarn`
    already installed.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Docker Hub from the command line
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The easiest way to see Docker Hub and Docker working together is to run the
    official `hello-world` container. The command to run a container from Docker Hub
    is `docker run name-of-container`; we''ll type `docker run hello-world`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Docker did not find the container in its local container cache, so it automatically
    downloaded it and then ran it within the Docker engine. This code in the container
    is simple—it just prints the preceding messages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can run any container you find on the Docker Hub website in the same way!
  prefs: []
  type: TYPE_NORMAL
- en: If your output does not resemble the preceding output, you either have an issue
    with your Docker installation or the Docker Hub servers are not accessible from
    your host. One possible problem may be that your installation of Docker requires
    you to run the `docker` commands as root or an administrator.
  prefs: []
  type: TYPE_NORMAL
- en: The installation instructions can be found at [https://docs.docker.com/install/](https://docs.docker.com/install/),
    while the post-installation instructions for Docker can be found at [https://docs.docker.com/install/linux/linux-postinstall/](https://docs.docker.com/install/linux/linux-postinstall/).
    These post-installation instructions explain how to set up Docker so that you
    can manage it as a non-root user.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Docker Hub website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go find the `hello-world` container page in Docker Hub—[https://hub.docker.com/_/hello-world](https://hub.docker.com/_/hello-world).
    The page will look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The hello-world image page on Docker Hub](img/B11641_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The hello-world image page on Docker Hub
  prefs: []
  type: TYPE_NORMAL
- en: This is typical of what you'll see for most containers shared on Docker Hub.
    Specific software packages encapsulated in a container, such as MongoDB, offer
    official images for various versions of the software. This allows you to deal
    with software that depends on a specific version of a Docker Hub package.
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB page on Docker Hub is [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo).
    To find it, simply type `mongodb` into the search box at the top of the **hello-world**
    (or any other package) page and select it from the search results page. You can
    use the search box to find any shared images for whatever software you might want.
  prefs: []
  type: TYPE_NORMAL
- en: Of interest are the **Simple Tags** and **Shared Tags** sections of the page.
    The various version images of MongoDB are tagged with simple tags and shared tags.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the **3.4-xenial** simple tag means there is an image for version
    3.4 of MongoDB running in an Ubuntu Xenial container.
  prefs: []
  type: TYPE_NORMAL
- en: The **3.4** shared tag means there are images of version 3.4 of MongoDB that
    run on more than one host operating system—typically, Windows Server, Linux, or
    macOS. The Docker daemon will choose the appropriate image for the host operating
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of the time of writing, there are images for the MongoDB 3.4, 3.6, 4.0,
    and 4.2 major versions, as well as minor point versions of these major versions:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Simple tags and shared tags for hello-world](img/B11641_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Simple tags and shared tags for hello-world
  prefs: []
  type: TYPE_NORMAL
- en: The process for finding the available pre-built third-party containers is the
    same. You can search for Redis, for example, and you will get a similar page with
    details about the available Redis containers.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a MongoDB container for our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can explore using pre-built containers from Docker Hub by implementing a
    MongoDB container. We'll use this container later as part of a demo application
    that is made up of several containers that work together.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the official Docker image for MongoDB, found on the Docker Hub website
    at [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo). We will create
    a `.sh` script to start running our image within Docker so that the startup process
    is easy and repeatable.
  prefs: []
  type: TYPE_NORMAL
- en: We learned in [*Chapter 2*](B11641_02_Final_NM_ePub.xhtml#_idTextAnchor028),
    *Using VirtualBox and Docker Containers for Development*, that we can expose a
    container's network ports to the host. That means we can run this MongoDB container
    image in Docker and access the running MongoDB server within that container by
    accessing the MongoDB port on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GitHub repository ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers))
    for this book, there is a `chapter3/` directory, which is a companion for this
    chapter. Within that directory is a shell script, [start-mongodb.sh](http://start-mongodb.sh).
    This script is a bit more elaborate than the simple ones we used in the previous
    chapter. We''re going to use environment variables to configure MongoDB, and we''re
    going to use a directory on the host for MongoDB''s data files—this makes backing
    up the data as easy as copying those files to back-up media:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You do need a Dockerfile to create a container image. However, if you are using
    a pre-made container image from Docker Hub that is standalone, such as MongoDB,
    you won't need one. The developers at MongoDB use Dockerfiles to generate the
    images before uploading them to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, you can see from the **Supported tags** section of the MongoDB page
    in Docker Hub that they produce and support quite a few images, including different
    versions—some for Windows OS, some for Linux, and so on. The MongoDB developers
    must have quite a few Dockerfiles—one for each image!
  prefs: []
  type: TYPE_NORMAL
- en: 'We must provide one environment variable to [start-mongodb.sh:](http://start-mongodb.sh:)
    `MONGO_DATADIR`, which is an existing directory on your workstation where you
    want MongoDB in the container to store its data files. There are a few ways to
    set this variable:'
  prefs: []
  type: TYPE_NORMAL
- en: You can add `export MONGODB_DATADIR=/path/to/data/dir` to your shell startup
    file (`.zshrc`, `.bashrc`, and so on).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can do the `export` (environment variable) operation by hand in the shell
    before running the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can set the value of the environment variable when using the command line
    to run the [start-mongodb.sh](http://start-mongodb.sh) script: `# MONGODB_DATADIR=~/data
    ./`[start-mongodb.sh](http://start-mongodb.sh).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can uncomment the line that sets `MONGO_DATADIR` in the [start-mongodb.sh](http://start-mongodb.sh)
    script file and edit it to set it to your desired data directory each time you
    run the script.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The last line in the [start-mongodb.sh](http://start-mongodb.sh) script is
    a single command line. The backslash (`\`) character at the end of the line signifies
    that the line is being continued or joined with the next line. This command is
    the one that starts the container. As you can imagine, if you had to type in this
    long command every time to start your MongoDB container, it would be painful.
    The `.sh` script makes it rather painless:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s take a look at the different parts of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: The `docker run` command names the `mongodb` running container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-d` switch runs the container in detached mode. The container will automatically
    start when your workstation is rebooted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-e` switch allows you to pass environment variables to the container; in
    this case, we pass the `TITLE=mongodb` environment variable. You can have multiple
    `-e` switches if you want to pass more than one variable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-p` switch exposes port `27017` in the container to port `27017` on the
    host. You can remap an exposed port in the container to a different port number
    on the host. You would do this if you have a MongoDB server already running in
    a container or on your host. However, Docker provides us the flexibility to always
    run MongoDB within a container, so we'll never have to install it on our host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We might want to install MongoDB client programs on the host so that we can
    access MongoDB using the MongoDB REPL/shell. Once port `27017` is exposed on the
    host, any program can access the MongoDB database, using it as if it were running
    on the host.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `-v` switch maps a directory on the host to the directory in the container
    where MongoDB will manage its database and other files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We choose to download and run `mongo:3.4` (tag/version 3.4) from Docker Hub.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `docker run` command only downloads the container from Docker Hub if it
    doesn't exist on your workstation yet or if the container image on Docker Hub
    is newer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can run any container you find on Docker Hub in the same way!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the script by using the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following output contains a few warnings about not being able to stop an
    already-running container named `mongodb` (this is expected):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Docker pulled the proper MongoDB image and ran it in the background in the
    Docker engine. You can observe the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The MongoDB image consists of several layers that were downloaded (`Pull complete`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There was already an existing (but older) image on the workstation (`Downloaded
    newer image…`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The container is running via the `docker ps` command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the container encounters errors, it may exit and print diagnostic messages
    in the output. You can run a shell in the container to perform forensic diagnosis.
  prefs: []
  type: TYPE_NORMAL
- en: Running a shell within a container
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, you would run a shell within the container so that you can discover
    more about the container's environment. For example, you may have a bug in your
    Dockerfile—such as forgetting to copy a file into the container. You can run a
    shell in the container and list directories and you will see that the file is
    missing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of the MongoDB container, you might want to run the MongoDB client
    commands from within the container. The Docker Hub page for the MongoDB container
    says we can run the client commands by simply attaching to the running container
    ([https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)). The command
    from the MongoDB Docker Hub page is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The different parts of this command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker exec` runs a command in a running container ([https://docs.docker.com/engine/reference/commandline/exec/](https://docs.docker.com/engine/reference/commandline/exec/)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `-it` switches specify that Docker is to run the container interactively—this
    means it gets input from the keyboard and sends output to the Terminal window.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Within the container, we can list directories using the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the Docker containers are running using the `ps` command within
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can run the command-line MongoDB tools inside the container. We did not
    have to install these on our workstation! Here, we run the MongoDB command and
    then run the `show collections` and `show databases` commands within the Mongo
    REPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We''re all set to go—MongoDB is running and we were able to use the REPL. The
    `show collections` command returned no collections because we haven''t created
    any. The `show databases` command shows that MongoDB has, by default, two databases:
    `admin` and `local`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker logs` command shows us the `stdout` and `stderr` output of the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You will likely use the `docker logs` command to see the debugging output from
    your containers.
  prefs: []
  type: TYPE_NORMAL
- en: What we see in our preceding logs is that MongoDB seems to be running just fine
    within the container. There are no error messages printed.
  prefs: []
  type: TYPE_NORMAL
- en: You can have the `docker logs` command follow the log file using the `-f` command-line
    switch. When the command is in follow mode, any new lines written to the log as
    the application is running will be appended to the display on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Up to point, we have explored using Docker to run a complex server application
    (MongoDB) without having to install MongoDB on our workstation. Using Docker,
    we have access to MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: We can start MongoDB using our `.sh` script, and we can also stop it—we can
    do this at will so that we don't have to always have MongoDB running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to run a Docker container, let's have a look at how to
    work with multiple containers that work together.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the microservices architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker and Docker Hub enable development using the microservices architecture.
    This architecture emphasizes building and running containers that focus on a single
    aspect of the overall application. When all the containers are running, you have
    your complete backend application. The containers can be complex, such as a full-blown
    database server, or simple, such as a short shell script. Ideally, the containers
    you implement for your application will be simple, short, and focused. Each microservice
    you write should be simple to debug since you don't need many lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we want to develop a backend application that uses MongoDB and Redis
    and whose application code is written using [Node.js](http://Node.js). We have
    the option to create a Dockerfile and start with the MongoDB image. We would then
    add Redis by installing it using `apt`, and then add our program to it as we did
    with the Debian image in [*Chapter 2*](B11641_02_Final_NM_ePub.xhtml#_idTextAnchor028),
    *Using VirtualBox and Docker Containers for Development*. The problem with creating
    the application using this method is that when you stop the container for development
    reasons, you're also stopping the running MongoDB and Redis servers.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of a monolithic container with everything installed, you can run MongoDB,
    Redis, and your custom application containers separately. You can even divide
    your custom application into multiple containers. All you need is a mechanism
    to communicate between your application containers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is far better to avoid using monolithic containers in your design! While
    it might seem that a large and complex program such as MongoDB is a monolithic
    sort of thing, it's just one dedicated service you can use as a microservice.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a brief understanding of microservices architecture, we can
    examine some of the benefits and requirements of containers as microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Scalability is almost always a huge consideration for backend implementations.
    For example, a simple HTTP/WWW (web page) server can grind to a halt if enough
    people are trying to fetch our pages from it at the same time. For this reason,
    server farms exist so that you can deploy two or more of these HTTP/WWW servers
    that duplicate the functionality of serving our pages. For a two-server farm,
    you basically get double the number of people fetching your pages from it than
    for a single server. As traffic grows—for example, if the site gains in popularity—you
    can add a third server, then a fourth server, and so on. The capability of the
    backend to serve pages grows as you need it.
  prefs: []
  type: TYPE_NORMAL
- en: In a microservices architecture, we achieve a similar means of scalability.
    We can run multiple instances of our MongoDB container to achieve more capacity
    for database operations. The only trick is to configure MongoDB as a cluster or
    as shards and the application containers to use this database setup.
  prefs: []
  type: TYPE_NORMAL
- en: Inter-container communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Inter-container communication usually involves some technology that allows
    messages to be sent from one container to another and for responses or statuses
    to be sent in return. Being able to communicate between running containers can
    be done via a few technologies, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database records
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTTP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MQTT
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss each of them now.
  prefs: []
  type: TYPE_NORMAL
- en: Using sockets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using sockets is a non-trivial way to communicate between containers. If you
    have five containers, you might have five sockets per container to provide communication
    paths between them all. As you scale, more sockets need to be created in each
    container, and you really want to automate this. There's quite a bit of business
    logic involved.
  prefs: []
  type: TYPE_NORMAL
- en: Using the filesystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the filesystem involves sharing something such as a network drive among
    all the containers. To send a message, a container writes to a file in the filesystem.
    To receive a message, the container reads from a file in the filesystem. The receiver
    needs to poll, or repeatedly check, the filesystem to detect when the file is
    written to. This is not ideal because we don't really want to share a network
    drive like this—the performance is going to be on the slow side.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Polling is a programming technique where you continuously check the status of
    a machine state (such as whether a file has changed).
  prefs: []
  type: TYPE_NORMAL
- en: Using database records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using database records is similar to the filesystem method, except the messages
    to be sent are simply written to records in the database and the receivers only
    need to poll the database records for changes. Some databases provide a notification
    mechanism to tell a client (receiver) that the database has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Both filesystem and database schemes require a good amount of business logic
    and debugging. You have to consider the order of messages sent and received and
    avoid missing a message because an older message is overwritten in the database
    or filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: Using HTTP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: HTTP is a stateless protocol, so you don't have to maintain a mesh of open sockets
    for communication. The protocol is well-defined and human-readable (for example,
    in text). To send a message, you send an HTTP request to the container you want
    to communicate with and wait for the response. You can close or persist the connection
    (keep it alive) as the HTTP protocol permits. Additionally, to avoid having to
    poll for messages or state change via HTTP, you can use WebSockets.
  prefs: []
  type: TYPE_NORMAL
- en: Using MQTT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MQTT is a well-designed message bus. It works much like IRC or Slack in that
    you have rooms (topics) and people in rooms (subscribers). Messages sent to a
    room (topic) are received by the people (subscribers). The people (subscribers)
    can join multiple rooms (topics) and they receive the messages for those rooms
    (topics).
  prefs: []
  type: TYPE_NORMAL
- en: For an MQTT application, there must be one MQTT server (broker) container that
    is accessible from the other containers. The other containers do not have to know
    about one another, only the address of the MQTT broker.
  prefs: []
  type: TYPE_NORMAL
- en: The MQTT broker accepts connections from one or more clients. The clients can
    subscribe to one or more topics. The topics are as arbitrary as the channel/room
    names are in IRC or Slack; they are typically strings. When a message is sent
    to the MQTT broker for a specific topic, the broker sends the message to all the
    clients who are subscribed to that topic.
  prefs: []
  type: TYPE_NORMAL
- en: Mosca ([https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca))
    is an MQTT broker written in JavaScript. You can run it in a container, as you
    do with MongoDB or Redis.
  prefs: []
  type: TYPE_NORMAL
- en: There are several other MQTT brokers to choose from, as well—you can find them
    on Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP versus MQTT
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MQTT is a protocol specifically designed for passing messages of key/value pairs.
    Its strength is in its broadcast capability. Each client is responsible for asking
    for modifications to values based on the specific keys it cares about. Each client
    can be assured that their updates are received by any and all other interested
    clients. MQTT also has the capability to retain specific key/value pairs, so when
    a new client subscribes, it can be notified of the current key/value pair (the
    most recently sent one).
  prefs: []
  type: TYPE_NORMAL
- en: MQTT does not provide a request/response protocol, although it is simple to
    implement one. The downside of using MQTT for request/response-type transactions
    is that the response is not guaranteed to happen as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP requires custom programming to provide the message-passing services that
    MQTT provides. You could implement a message bus sort of system that mimics MQTT's
    functionality, but that means more programming work for you and additional maintenance
    costs down the line. HTTP's strength is that it is a request/response protocol,
    so you can typically expect a response right away. The downside is that if the
    server is maintaining a set of key/value pairs, you would be required to poll
    the server from the clients to see whether the values have changed and post to
    the server to update the values. Polling causes the server to burn CPU, even when
    values haven't changed, and this can add up in a way that grinds your server to
    a halt if enough clients are polling frequently enough. You could use WebSockets,
    but in the end, you've reinvented MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP is a good choice if you need more than what MQTT provides. Certainly, HTTP
    supports PHP or [Node.js](http://Node.js) (and others) backend services.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to combine HTTP and MQTT. Use HTTP for request/response-type transactions
    and MQTT for state updates.
  prefs: []
  type: TYPE_NORMAL
- en: MQTT is a good choice for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: The `chapter3/` directory in the companion GitHub repository contains a simple
    microservices-based backend demonstration application. It uses MongoDB, Redis,
    and MQTT, along with some publisher and subscriber applications that you can find
    in the GitHub repository for this book ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)).
    Later in this chapter, we'll learn how to share our subscriber and publisher containers
    via Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a sample microservices application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the Mosca, MongoDB, and Redis containers, along with a couple of
    custom containers, to implement a simple but complete application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Diagram of our sample microservices application](img/B11641_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Diagram of our sample microservices application
  prefs: []
  type: TYPE_NORMAL
- en: The publisher and subscriber will communicate with each other using MQTT. The
    subscriber will listen for a handful of MQTT topics that direct it to operate
    on or retrieve information from the MongoDB and Redis databases. The publisher
    will send these MQTT topics and print the responses.
  prefs: []
  type: TYPE_NORMAL
- en: The publisher will be based on [Node.js](http://Node.js) version 11 and the
    subscriber will be based on [Node.js](http://Node.js) version 12\. Without Docker
    or a virtual machine, running two [Node.js](http://Node.js) versions on the same
    machine concurrently requires the use of **Node Version Manager** (**nvm**) and
    having multiple versions of [Node.js](http://Node.js) installed on your workstation.
    Docker containers make it simple to use as many versions as you need and to package
    the version, along with the app that uses it, in a nice package (a container).
  prefs: []
  type: TYPE_NORMAL
- en: The publisher and subscriber apps are in their own `publisher/` and `subscriber/`
    subdirectories of `chapter3/` in the companion repository. These programs each
    need their own Dockerfile so that we can build the two separate containers. They
    also have their own helper `.sh` scripts ([debug.sh](http://debug.sh), [run.sh](http://run.sh),
    [build.sh](http://build.sh), and so on). The publisher app only needs to have
    an MQTT library. The subscriber app needs the MQTT library and a MongoDB library
    and a Redis library. These libraries will be installed using `np`m (the [Node.js](http://Node.js)
    package manager) within the containers.
  prefs: []
  type: TYPE_NORMAL
- en: The publisher and subscriber apps demonstrate how a microservices architecture
    works, using multiple Docker containers.
  prefs: []
  type: TYPE_NORMAL
- en: The subscriber connects to the MongoDB and Redis containers using [Node.js](http://Node.js)
    packages/libraries, which are installed in the container with `npm`. The subscriber
    provides basic **Create, Read, Update, and Delete** (**CRUD**) functions for adding,
    listing, removing, and retrieving count of records in each of the MongoDB and
    Redis databases. The publisher sends MQTT messages to the subscriber to invoke
    this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our topics are strings that are derived from a pattern: container/command.
    If we want to communicate with the subscriber, the pattern is subscriber/command.
    If we want to communicate with the publisher, the pattern is publisher/command.
    This convention makes it obvious which topics each microservice would want to
    subscribe or publish to.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The MQTT topics and messages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`subscriber/mongo-count`: Responds with the count of records in the MongoDB
    database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/mongo-add`: Adds the message content to the MongoDB database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/mongo-list`: Returns a JSON object that contains a list of records
    in the MongoDB database. If the message is a non-zero length string, it is used
    to filter the list of records returned.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/mongo-remove`: Removes a record from the MongoDB database.  The
    message may contain a string or an object (JSON) suitable for passing to MongoDB''s
    `collection.deleteOne()` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/mongo-removeall`: Deletes all records from the MongoDB database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/redis-count`: Responds with the count of records in the Redis database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/redis-flushall`: Removes all the records from the Redis database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/redis-set`: Adds a record to the Redis database; the message is
    of the `key=value` form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/redis-list`: Lists all the records in the Redis database and returns
    a JSON array of records.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/redis-del`: Deletes a record from the Redis database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/commands`: Returns a list of available commands (MQTT topics).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are shell scripts in the root of the `chapter3/` directory that individually
    start Redis ([start-redis.sh](http://start-redis.sh)), MongoDB ([start-mongodb.sh](http://start-mongodb.sh)),
    and the Mosca MQTT broker ([start-mosca.sh](http://start-mosca.sh)), as well as
    a script, [start-all.sh](http://start-all.sh) that starts all three.
  prefs: []
  type: TYPE_NORMAL
- en: We've already detailed the workings of the [start-mongodb.sh](http://start-mongodb.sh)
    script earlier. The [start-redis.sh](http://start-redis.sh) and [start-mosca.sh](http://start-mosca.sh)
    scripts are roughly the same; just the names of the programs that are started
    (Redis and Mosca) are changed.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the [start-mongodb.sh](http://start-mongodb.sh)
    script connects the host's port `27017` to the container's port `27017`. This
    is so that other containers can reach MongoDB via the default port. The [start-mosca.sh](http://start-mosca.sh)
    script connects ports `1883` and `80` to the host so that MQTT and MQTT, over
    WebSocket, can be used from any of the containers. The [start-redis.sh](http://start-redis.sh)
    script connects port `6379` to the host so that Redis can be accessed from the
    containers via the default Redis port. Of course, the host can access any of the
    containers as well.
  prefs: []
  type: TYPE_NORMAL
- en: The subscriber/start-subscriber.sh and [publisher-start-publisher.sh](http://publisher-start-publisher.sh)
    scripts both run the applications locally on the host, not in containers.  This
    allows host native debugging functionality, using WebStorm or another IDE or [Node.js](http://Node.js)
    debugger. Developing and debugging our publisher and subscriber entirely within
    Docker containers is covered in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To use the [start-subscriber.sh](http://start-subscriber.sh) and [start-publisher.sh](http://start-publisher.sh)
    scripts, you will need to install [Node.js](http://Node.js) and `yarn` on your
    development workstation. Ensure that you run `yarn install` in both `subscriber/`
    and `publisher/` directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what [start-subscriber.sh](http://start-subscriber.sh) looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The [start-publisher.sh](http://start-publisher.sh) script is identical to the
    [start-subscriber.sh](http://start-subscriber.sh) script.  The `package.json`
    file in the publisher directory signals `yarn start` to launch the publisher program.
  prefs: []
  type: TYPE_NORMAL
- en: The `HOSTIP` variable must be set to your host machine's IP, available to our
    publisher and subscriber, and is used by our Node.js programs to address the MQTT
    broker, MongoDB server, and Redis server when connecting.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find your IP on macOS (assuming you use `192.168.*.*` as your home network
    IP address range):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The IP of the host is `192.168.0.19`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find your IP on Linux, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The IP of this host is `192.168.0.21`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will run the `start-publisher.sh` script using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To run the `start-subscriber.sh` script use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The publisher program is relatively simple. It connects to the MQTT broker and
    listens for topics starting with `publisher/`. The topics and messages received
    are then converted into the `subscriber/` format topics and published to MQTT.
    The subscriber responds with the `publisher` topic and the response message.
  prefs: []
  type: TYPE_NORMAL
- en: With both the publisher and subscriber running, we use the MQTT command-line
    tool to send messages to the publisher. In the following screenshot, you can see
    how we exercise a few of the subscriber commands.
  prefs: []
  type: TYPE_NORMAL
- en: These two scripts assume that we have Mosca installed on our host. We don't
    need to install it for the MQTT broker, but for the command-line tools. Being
    able to send MQTT topics/commands from the command line on the host, in `.sh`
    scripts on the host, and in crontabs on the host is very useful. You can also
    use Mosca as a library to implement a broker in your own [Node.js](http://Node.js)
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For curious readers, the screenshot is of a Terminal window running tmux with
    three panes. **tmux** is a **terminal multiplexer**: it enables several terminals
    to be created, accessed, and controlled from a single screen. The tmux GitHub
    repository can be found at [https://github.com/tmux/tmux](https://github.com/tmux/tmux).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, you can see how we exercise a few of the subscriber
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – Three shells demonstrating the publisher and subscriber working
    together](img/B11641_03_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – Three shells demonstrating the publisher and subscriber working
    together
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, the publisher and subscriber work as expected, as do the database
    queries between containers and the host. We can edit and debug the publisher and
    subscriber programs to get them working to our satisfaction.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have these working publisher and subscriber containers, we want
    to share them with the rest of the development team.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing your containers on Docker Hub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To share our containers, we'll use Docker Hub and publish the two containers.
    The rest of the team can pull the pre-built containers from Docker Hub and use
    them without having to deal with the source code repository at all. They are just
    microservices to them, just as we don't need the source to Mosca, MongoDB, or
    Redis with those containers.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, the development team is going to have to run them.
  prefs: []
  type: TYPE_NORMAL
- en: We have created an organization on Docker Hub, `dockerfordevelopers`, which
    we will use to publish the containers for this book. You won't be able to push
    to it, but we can. In order to publish to Docker Hub, you will need to use the
    `docker login` command, and you must have already created an account on [https://hub.docker.com/](https://hub.docker.com/).
  prefs: []
  type: TYPE_NORMAL
- en: You can also create your own organization on Docker Hub where you can share
    your own containers. If you want to use the examples in the GitHub repository
    for this chapter, you will have to edit the scripts to replace `dockerfordevelopers`
    with your own organization name.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are creating our own custom containers, we will need some `.sh` scripts
    for each container, as explained in the previous chapter. There are a set of `.sh`
    scripts for the publisher and the subscriber.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Dockerfile used to build the container for the publisher is almost identical
    to the one used in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The major difference in this Dockerfile and the one in the previous chapter
    is that we are not installing Apache and PHP, but we are inheriting from `node:12`
    and installing our [Node.js](http://Node.js) program's required packages.
  prefs: []
  type: TYPE_NORMAL
- en: We are inheriting from `node:12` in this Dockerfile for the publisher. The Dockerfile
    for the subscriber is identical, except that it inherits from `node:13`. This
    illustrates how you can have containers with different base software versions
    on the same host; this would be unpleasant to deal with on a host without containers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `node:12` and `node:13` containers are pulled from Docker Hub and updated
    each time we build the containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the [build.sh](http://build.sh) script that is used to build
    the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The [build.sh](http://build.sh) script is very short and only really consists
    of the line, a single command. It is easier to type `./`[build.sh](http://build.sh)
    instead of the whole `docker build -t dockerfordevelopers/publisher .` command.
    This also makes the process less error-prone and you don't have to memorize the
    command-line switches and format.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a nearly identical [build.sh](http://build.sh) script for the subscriber,
    too. Only the name of the container built is different: `dockerfordevelopers/subscriber`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the [build.sh](http://build.sh) script for the publisher is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the `1/9`, `2/9`, `3/9`, and so on steps map one to one to
    the lines in our Dockerfile. The first line in our Dockerfile reads `From Node:12`
    and the `Step 1/1` line reads `From Node:12`. Similarly, `Step 2/2` is the second
    line in the Dockerfile. The build process follows the Dockerfile as a series of
    steps to build the final container image.
  prefs: []
  type: TYPE_NORMAL
- en: The last line in the output tells us that the name of the container is `dockerfordevelopers/publisher:latest`.
    We use this name to push our build container to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the [push.sh](http://push.sh) script to perform the commands to push
    the publisher container to the organization on Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is another one-line `.sh` script for our convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the output of the [push.sh](http://push.sh) script for the
    publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a sort of template or pattern for working with custom containers in
    our microservices architecture project:'
  prefs: []
  type: TYPE_NORMAL
- en: We edit and debug the code for our container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We run the [build.sh](http://build.sh) script to build a container image.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We run the [push.sh](http://push.sh) script to push the container to Docker
    Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your fellow developers can now run the publisher image. This is run on a second
    machine, such as a developer''s workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, on this second machine, the developer has installed and run the
    required microservices: Mosca, MongoDB, and Redis. The application will not run
    without all the microservices running within Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: Pushing to Docker Hub on your development host and pulling from Docker Hub on
    a production host is a simple way to deploy containers for production. It is not
    very robust, however. We will cover better schemes for deployment in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to break up an application that would normally
    be run in a virtual machine with multiple services (MongoDB, Redis, and Mosca)
    into a microservices-based architecture run as containers within Docker.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to navigate the Docker Hub website and find useful pre-made Docker
    containers that you simply download and run.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned how to package our own microservices as Docker containers and
    how we can push them to Docker Hub for the public or development team members
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Several containers were used to launch the complete application as microservices
    communicated through ports mapped to the host's ports. This is not ideal, especially
    if you already have a WWW server running on port `80`; Mosca uses port `80`, too.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will discuss how we can use the Docker Compose tool
    to design complete microservice architecture applications and run them so that
    they have a private internal network and so host ports are not required.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official Docker documentation: [https://docs.docker.com](https://docs.docker.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Dockerfile reference: [https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Docker Hub site: [https://hub.docker.com/](https://hub.docker.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for Docker Hub: [https://docs.docker.com/docker-hub/](https://docs.docker.com/docker-hub/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for the Node.js containers on Docker Hub: [https://hub.docker.com/_/node](https://hub.docker.com/_/node)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for the Redis containers on Docker Hub: [https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for the MongoDB containers on Docker Hub: [https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The documentation for the Mosca containers on Docker Hub: [https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
