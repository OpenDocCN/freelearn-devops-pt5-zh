<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Reverse Proxy Requests</h1></div></div></div><p>One big problem in having many containers with public ports on the same server is that they can't all listen to the standard ports for their kinds of services. If we have a MySQL backend service and have 10 MySQL containers running, only one of them can listen to the MySQL standard port <code class="literal">3306</code>. For those who expose a web server, the standard port <code class="literal">80</code> can only be used by one of their WordPress containers. In this chapter, we'll cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Explaining the problem</li><li class="listitem" style="list-style-type: disc">Coming up with a solution to the problem</li><li class="listitem" style="list-style-type: disc">Implementing the solution with Nginx and HAProxy</li><li class="listitem" style="list-style-type: disc">Automating the process of mapping domains</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Explaining the problem</h1></div></div></div><p>The problem in having many containers with the same services on the same host is that there are <a class="indexterm" id="id266"/>standard ports used by user applications. Using a web browser and entering the IP to a Docker host running a WordPress container will ask for resources on port <code class="literal">80</code> by default. You can't expect your users to remember a nonstandard port in order to enter your website.</p><div><img alt="Explaining the problem" src="img/3946OT_06_01.jpg"/><div><p>The only way to reach each of the three containers is to manually enter the containers' exposed port number.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Finding a solution</h1></div></div></div><p>Before we head to the solution, let me explain what a regular proxy server is, in case you're not<a class="indexterm" id="id267"/> familiar with it.</p><p>A <a class="indexterm" id="id268"/>proxy server is a server that connects to services on your behalf and forwards all the results to you. After you've set up to route all your traffic through the proxy server, you—as a user—won't notice it's there. Everything will work as usual.</p><p>However, service owners only see that a certain machine (the proxy server) is connected to them. If another user uses the same proxy server and the same service as you do, the service owner can't tell the difference and will perceive you as one single user.</p><div><img alt="Finding a solution" src="img/3946OT_06_02.jpg"/><div><p>Different users connecting through a proxy server appear as one user.</p></div></div><p>As you can <a class="indexterm" id="id269"/>see in the preceding diagram, the service owners just see that someone with an IP of <strong>213.12.12.3</strong> has connected to them.</p><p>So, what if we use this on the Docker host? What if we put something in front of all the containers? Depending on which domain name is being requested, this thing will forward the request to the right container and port and then just forward the request's response to the requesting user.</p><p>There are things <a class="indexterm" id="id270"/>especially made to solve this kind of problem. They're called <strong>reverse proxies</strong> (reverse because the proxy is at the other end, making the user only see one IP and forwarding the request).</p><p>If we install and configure a reverse proxy on our Docker host server, then this is how the diagram will look:</p><div><img alt="Finding a solution" src="img/3946OT_06_03.jpg"/><div><p>A reverse proxy lets all Docker containers appear as one.</p></div></div><p>The <a class="indexterm" id="id271"/>reverse proxy listens to port <code class="literal">80</code>—the standard web port—and when a request for <code class="literal">domain1.com</code> comes in, the proxy looks at its configuration to see whether there is a specified forwarding endpoint for this domain. If there is, the reverse proxy forwards the request to the right Docker container, waits for its response, and forwards the container's response to the requesting users when it comes.</p><p>This is the solution we're after. The only question now is which reverse proxy we are going to use. There are quite a bunch of them out there; some reverse proxies have more specific purposes, such as load balancing, and some are services that do a lot of other stuff and have this feature as well, such as a web server.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Implementing the solution</h1></div></div></div><p>You will <a class="indexterm" id="id272"/>always have preferences when selecting a tool to solve a problem. Sometimes, you select a tool because you're comfortable using it and it's good enough; sometimes, you select it because it has great performance or because you just want to try something new.</p><p>That's why we will go through this problem and solve it with two different tools. The end result will be the same, but the tools have a slightly different setup.</p><p>Before we<a class="indexterm" id="id273"/> start implementing the solutions, we use Crane to start an instance of our three-container application and verify that it's working by connecting it to the site. Have Docker decide the public port for you, so it's <code class="literal">491XX</code>. Remember this port since we will use it when implementing the solutions.</p><p>We need to point out the domain names we want to use to our Docker host's IP address. We can do this either by setting the domain names A-record to our server's IP address or by adding a line in our local <code class="literal">/etc/hosts</code> file, which directs requests to the domain names to our server's IP address.</p><p>I'll go with the latter and enter this in my Mac's <code class="literal">/etc/hosts</code> file:</p><div><pre class="programlisting">
<strong>54.148.253.187 domain1.com</strong>
<strong>54.148.253.187 domain2.com</strong>
<strong>54.148.253.187 domain3.com</strong>
</pre></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>Make sure you replace the above IP address with your server's IP address.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec34"/>Implementation with HAProxy</h2></div></div></div><p>HAProxy (<a class="ulink" href="http://www.haproxy.org">http://www.haproxy.org</a>) is a load balancer, which has the role of forwarding<a class="indexterm" id="id274"/> traffic <a class="indexterm" id="id275"/>to different services behind it.</p><p>This<a class="indexterm" id="id276"/> is how HAProxy describe themselves:</p><div><blockquote class="blockquote"><p><em>"HAProxy is a free, very fast and reliable solution offering high availability, load balancing, and proxying for TCP and HTTP-based applications. It is particularly suited for very high traffic web sites and powers quite a number of the world's most visited ones. Over the years it has become the de-facto standard open source load balancer, is now shipped with most mainstream Linux distributions, and is often deployed by default in cloud platforms."</em></p></blockquote></div><p>This sounds like something that fits our needs.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec06"/>Installing HAProxy</h3></div></div></div><p>As noted in <a class="indexterm" id="id277"/>the quote, many systems are installed already and shipped <a class="indexterm" id="id278"/>with it. If you can't find it, it should be available in you package manager if you use Ubuntu or Debian (<code class="literal">apt-get install haproxy</code>) or in some other distro with a package manager.</p><p>On my Amazon EC2 instance that runs Amazon Linux, HAProxy can be installed using <code class="literal">yum install haproxy</code>.</p><p>The <a class="indexterm" id="id279"/>following<a class="indexterm" id="id280"/> output will be obtained as follows:</p><div><img alt="Installing HAProxy" src="img/3946OT_06_04.jpg"/></div><p>It's not the most recent version, but that's OK for the things we are about to do.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec07"/>Configuring HAProxy</h3></div></div></div><p>We'll write <a class="indexterm" id="id281"/>an HAProxy configuration in the file <code class="literal">/etc/haproxy/docker.cfg</code> so that we don't have to remove everything in the default configuration file, as it may be good for reference in the future.</p><p>HAProxy divides its configuration into four parts: global, defaults, frontend, and backend. Don't confuse frontend and backend with frontend and backend development. Here, frontend means the server part that's facing the Internet, and backend is the server part that's behind HAProxy, which in our case are the Docker containers.</p><p>Open the configuration file and start by typing in the generic stuff, as shown here:</p><div><pre class="programlisting">global
    daemon
    maxconn 4096
    pidfile /var/run/haproxy.pid
defaults
    mode http
    timeout connect 5000ms
    timeout client 50000ms
    timeout server 50000ms</pre></div><p>Now, we <a class="indexterm" id="id282"/>enter the port to listen on and the backend configurations to use for which domain:</p><div><pre class="programlisting">frontend http-in
    bind *:80
    acl is_site1 hdr_end(host) -i domain1.com
    use_backend site1 if is_site1</pre></div><p>We define that regular incoming HTTP traffic on port <code class="literal">80</code> should be captured. The <code class="literal">acl</code> here means access control list and is a flexible solution to take decisions based on content extracted from the requests. The <code class="literal">hdr_end(host) -i domain1.com</code> function call means that the end of the header host is case-insensitive, matched against the string <code class="literal">domain1.com</code>. The result (Boolean) of this match is saved in the <code class="literal">is_site1</code> variable.</p><p>Note that this means that all the subdomains for <code class="literal">domain1.com</code> will be matched with this setup. If you just want to match <code class="literal">www.domain1.com</code>, you can use <code class="literal">hdr(host) -i www.domain1.com</code> instead.</p><p>Now that we have the match result in the <code class="literal">is_site1</code> variable, we can send the request to a backend configuration, named <code class="literal">site1</code>.</p><p>We append this to our configuration file:</p><div><pre class="programlisting">backend site1
    balance roundrobin
    option httpclose
    option forwardfor
    server s1 127.0.0.1:49187 maxconn 450</pre></div><p>We define our backend name as <code class="literal">site1</code>, set a few options, and add the server and the port to our WordPress container.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Make sure you enter your WordPress container's exposed port instead of <code class="literal">49187</code> in the preceding code.</p></div></div><p>It's time to try this configuration. Save the configuration file and test it in a shell with this command:</p><div><pre class="programlisting">
<strong>haproxy -f /etc/haproxy/docker.cfg –c</strong>
</pre></div><p>The output should say <code class="literal">Configuration file is valid</code>.</p><p>Make<a class="indexterm" id="id283"/> sure you don't have something already listening to port <code class="literal">80</code> on your machine. You can use something such as <code class="literal">netstat –a</code> to verify that <code class="literal">80</code> or HTTP isn't listed. If they are, find the app that's listening and shut it down.</p><p>Start HAProxy with this command:</p><div><pre class="programlisting">
<strong>haproxy -f /etc/haproxy/docker.cfg –D</strong>
</pre></div><p>The <code class="literal">-D</code> option means that we want to run it as a daemon in the background. You shouldn't see any output when you invoke this command.</p><p>Let's check whether HAProxy is running by invoking <code class="literal">ps aux | grep haproxy</code>. You should see it listed there. Finally, let's verify that it is listening to port <code class="literal">80</code> by invoking <code class="literal">netstat –a | grep http</code>. Now, you should have something in that list.</p><p>The output obtained is displayed here:</p><div><img alt="Configuring HAProxy" src="img/3946OT_06_05.jpg"/></div><p>It all looks good!</p><p>Just to recap what we have done here: we set up a service that listens for incoming requests on port <code class="literal">80</code> on our server. When a request on this port comes in, a check on the request header's host is performed to see whether it matches <code class="literal">domain1.com</code>. If we have a match, the request is forwarded to the IP address <code class="literal">127.0.0.1</code> and to the port <code class="literal">49187</code>. The response from this IP and port are sent back to the requester.</p><p>Now to the moment of truth. Open your web browser and enter the URL <code class="literal">domain1.com</code>.</p><p>Make sure that you have entries for <code class="literal">domain1.com</code> in your host's file, pointing it to your server.</p><p>After you perform the preceding instructions, you will see the following website screen:</p><div><img alt="Configuring HAProxy" src="img/3946OT_06_06.jpg"/></div><p>You<a class="indexterm" id="id284"/> can see that in the location bar, no port is specified. Wonderful!</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec08"/>Adding more domains to HAProxy</h3></div></div></div><p>We did <a class="indexterm" id="id285"/>not go through all this just to serve a single web application on port <code class="literal">80</code>, which can be done without a reverse proxy. Start another WordPress application with Crane by copying the old configuration to a new directory and change the service's names, as shown here:</p><div><pre class="programlisting">
<strong>cd..</strong>
<strong>cp –r crane-wp crane-wp2</strong>
<strong>cd crane-wp2</strong>
<strong>sed -i "s/wp/wp2/g" crane.yaml</strong>
<strong>sed -i "s/mydata/mydata2/g" crane.yaml</strong>
<strong>sed -i "s/mymysql/mymysql2/g" crane.yaml</strong>
<strong>crane lift data_db</strong>
<strong>crane lift wp2</strong>

<strong>#check out port for new container named wp2</strong>
<strong>docker ps</strong>
</pre></div><p>Open the <a class="indexterm" id="id286"/>HAProxy configuration file again and add two lines in the frontend:</p><div><pre class="programlisting">
<strong>acl is_site2 hdr_end(host) -i domain2.com</strong>
<strong>use_backend site2 if is_site2</strong>
</pre></div><p>After that, add a new backend configuration named <code class="literal">site2</code>:</p><div><pre class="programlisting">
<strong>backend site2</strong>
<strong>    balance roundrobin</strong>
<strong>    option httpclose</strong>
<strong>    option forwardfor</strong>
<strong>    server s2 127.0.0.1:49188 maxconn 450</strong>
</pre></div><p>Make sure that you replace the port with the one you got. Restart HAProxy and do the checks we did the last time we started it.</p><p>To restart HAProxy, run <code class="literal">/etc/init.d/haproxy restart</code>.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>HAProxy can reload a new configuration without dropping active sessions with this command:</p><div><pre class="programlisting">
<strong>haproxy -f /etc/haproxy/docker.cfg -p /var/run/haproxy.pid -sf $(cat /var/run/haproxy.pid)</strong>
</pre></div></div></div><p>Open your browser and go to <code class="literal">domain1.com</code> in order to make sure that the old one is working. If it does, go to <code class="literal">domain2.com</code>. You should see another WordPress installation site. Just to be sure that it's not the same, go ahead and install one of them. Or, go to <code class="literal">domain3.com</code> and see what happens when a domain points to the server without having it match in HAProxy.</p></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec35"/>Implementation with Nginx</h2></div></div></div><p>Now, we<a class="indexterm" id="id287"/> are<a class="indexterm" id="id288"/> going to do the same thing as we did with HAProxy, but we will use the<a class="indexterm" id="id289"/> excellent web server Nginx (<a class="ulink" href="http://nginx.org/en/">http://nginx.org/en/</a>) as our reverse proxy instead. Nginx is a full featured and really fast web server that leaves a small footprint in the memory.</p><p>This is how Nginx is described:</p><div><blockquote class="blockquote"><p><em>"nginx [engine x] is an HTTP and reverse proxy server, as well as a mail proxy server, written by Igor Sysoev. For a long time, it has been running on many heavily loaded Russian sites including Yandex, Mail.Ru, VK, and Rambler. According to Netcraft, nginx served or proxied 20.41% busiest sites in November 2014. Here are some of the success stories: Netflix, Wordpress.com, FastMail.FM."</em></p></blockquote></div><p>This<a class="indexterm" id="id290"/> also sounds like<a class="indexterm" id="id291"/> what we need, just like it did with HAProxy.</p><div><div><div><div><h3 class="title"><a id="ch06lvl3sec09"/>Installing Nginx</h3></div></div></div><p>Nginx is <a class="indexterm" id="id292"/>available in all Linux package managers, such as <code class="literal">aptitude</code>/<code class="literal">apt</code>, <code class="literal">yum</code>, and <a class="indexterm" id="id293"/>others, so an install can be simply done with <code class="literal">apt-get install nginx</code> or <code class="literal">yum install nginx</code>. Since it's open source, you can, of course, install it from the source as well.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec10"/>Configuring Nginx</h3></div></div></div><p>We are <a class="indexterm" id="id294"/>going to add the configuration to a file named <code class="literal">/etc/nginx/conf.d/wp1.conf</code>.</p><p>Create and open this file in your favorite text editor:</p><div><pre class="programlisting">server {
    listen 80;
    server_name domain1.com;
    charset UTF-8;

    if ($host !~ ^(domain1.com)$ ) {
         return 444;
    }
}</pre></div><p>This block, as you can see, makes the server listen to port <code class="literal">80</code> and to match the domain <code class="literal">domain1.com</code> for this configuration to apply. It's always good to specify the server charset so that the website text does not get the wrong encoding during the forwarding process; so, we add that line as well. To just listen to <code class="literal">domain1.com</code> and nothing else (Nginx uses the first configuration found as a default configuration if there's no match in the server name part), we return the HTTP status code <code class="literal">444</code> (no response) on the other requests that get in there.</p><p>What are we going to do with the requests on port <code class="literal">80</code> for <code class="literal">domain1.com</code> then?</p><p>Add this inside the server's scope (curly brackets):</p><div><pre class="programlisting">location / {
    proxy_pass http://wp1;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-NginX-Proxy true;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_redirect off;
}</pre></div><p>The <code class="literal">location</code> block<a class="indexterm" id="id295"/> will match all the requests since it matches <code class="literal">/</code>. We will get back to the <code class="literal">proxy_pass</code> part in a while. Other than this, you'll see that we set a lot of headers, most of them telling our Docker container the requesters' real IP address and so on.</p><p>Back to the <code class="literal">proxy_pass</code> part. This is the part that actually forwards the request, to something named <code class="literal">wp1</code>. This is called an upstream, which we have to define.</p><p>Add this outside the server's scope:</p><div><pre class="programlisting">upstream wp1 {
    server 127.0.0.1:49187;
}</pre></div><p>The complete configuration file named <code class="literal">/etc/nginx/conf.d/wp1.conf</code> should look like this now:</p><div><pre class="programlisting">upstream wp1 {
  server 127.0.0.1:49187;
}

server {
  listen 80;
  server_name domain1.com;
  charset UTF-8;

  if ($host !~ ^(domain1.com)$ ) {
    return 444;
  }

  location / {
    proxy_pass http://wp1;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-NginX-Proxy true;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_redirect off;
  }
}</pre></div><p>Save the file and on most Linux systems, you can test it for syntax errors using the command <code class="literal">sudo /etc/init.d/nginx configtest</code> or <code class="literal">sudo service nginx configtest</code>.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>Make sure that you have shut down HAProxy before you start Nginx, or you will get an error saying that Nginx can't bind to port <code class="literal">80</code>. You can do this with the following command:</p><div><pre class="programlisting">
<strong>/etc/init.d/haproxy stop</strong>
</pre></div></div></div><p>If the<a class="indexterm" id="id296"/> test was successful, we can now restart (or start) the Nginx server. Again, use <code class="literal">sudo /etc/init.d/nginx restart</code> or <code class="literal">sudo service nginx restart</code> on most systems.</p><p>Head over to your web browser and enter the URL <code class="literal">domain1.com</code> to take a look at our WordPress installation site. To make sure nothing but <code class="literal">domain1.com</code> works, try to go to <code class="literal">domain2.com</code> and expect no response.</p></div><div><div><div><div><h3 class="title"><a id="ch06lvl3sec11"/>Adding more domains to Nginx</h3></div></div></div><p>To add<a class="indexterm" id="id297"/> another domain to match in Nginx, you can create a new file in the <code class="literal">/etc/nginx/conf.d/</code> directory and reload the Nginx configuration, as shown in the following code:</p><div><pre class="programlisting">
<strong>cp /etc/nginx/conf.d/wp1.conf /etc/nginx/conf.d/wp2.conf</strong>
<strong>sed -i "s/wp1/wp2/g" /etc/nginx/conf.d/wp2.conf</strong>
<strong>sed -i "s/domain1/domain2/g" /etc/nginx/conf.d/wp2.conf</strong>
<strong>sed -i "s/49187/49188/g" /etc/nginx/conf.d/wp2.conf</strong>

<strong>#test config</strong>
<strong>/etc/init.d/nginx configtest</strong>

<strong>#reload config</strong>
<strong>/etc/init.d/nginx reload</strong>
</pre></div><p>Copy the configuration file, replace a few names, run <code class="literal">configtest</code>, and reload Nginx.</p><p>Try <code class="literal">domain1.com</code> in your browser to make sure it still works. You should still see the WordPress installation page (unless you installed WordPress, of course); head over to <code class="literal">domain2.com</code> after that to see whether our new configuration is used.</p><p>If you want to take a site down, just change the file's extension from <code class="literal">.conf</code> to something else and reload Nginx.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec42"/>Automating the process of mapping domains</h1></div></div></div><p>The limitations in this setup are that it's manual and hands-on every time a new domain is added. On my website (<a class="ulink" href="http://oskarhane.com">http://oskarhane.com</a>), I've written some blog posts about how this process could be automated and those posts are my most-read posts of all time.</p><p>I was <a class="indexterm" id="id298"/>very glad when I found <strong>nginx-proxy</strong> by Jason Wilder. nginx-proxy solves this problem in a more clever way than me by monitoring <a class="indexterm" id="id299"/>Docker events via the Docker Remote API.</p><div><div><h3 class="title"><a id="note16"/>Note</h3><p>You can<a class="indexterm" id="id300"/> read more about nginx-proxy on its GitHub page (<a class="ulink" href="https://github.com/jwilder/nginx-proxy">https://github.com/jwilder/nginx-proxy</a>).</p></div></div><p>
<code class="literal">nginx-proxy</code> comes as a container and we can run it by executing the following command:</p><div><pre class="programlisting">
<strong>docker run -d -p 80:80 -v /var/run/docker.sock:/tmp/docker.sock jwilder/nginx-proxy</strong>
</pre></div><p>We are giving the container our Docker socket, so it can listen for the events we are interested in, which are container starts and stops. We also bind the Docker hosts' port 80 to this new container, making it the entrance container for all incoming web requests. Make sure you stop Nginx on the Docker host before starting the <code class="literal">nginx-proxy</code> container. You can do this with the following command:</p><div><pre class="programlisting">
<strong>/etc/init.d/nginx stop</strong>
</pre></div><p>When a container starts, <code class="literal">nginx-proxy</code> creates an nginx reverse proxy <code class="literal">config</code> file and reloads Nginx—just like we did, but fully automated with <code class="literal">nginx-proxy</code>.</p><p>To tell <code class="literal">nginx-proxy</code> which domain we want mapped to which container, we must run our containers with an environment variable named <code class="literal">VIRTUAL_HOST</code>.</p><p>In our <code class="literal">crane.yaml file </code>, we add an environment variable in the <code class="literal">wp</code> run section:</p><div><pre class="programlisting">
<strong>containers:</strong>
<strong>  wp:</strong>
<strong>    image: oskarhane/wordpress</strong>
<strong>    run:</strong>
<strong>      volumes-from: ["mydata"]</strong>
<strong>      link:</strong>
<strong>        - mymysql:mysql</strong>
<strong>      publish: ["80"]</strong>
<strong>      detach: true</strong>
<strong>      env: ["VIRTUAL_HOST=domain1.com"]</strong>
</pre></div><p>Now, we <a class="indexterm" id="id301"/>just have to lift this with crane again to <a class="indexterm" id="id302"/>have this container mapped to the domain <code class="literal">domain1.com</code> on port <code class="literal">80</code>:</p><div><pre class="programlisting">
<strong>crane lift web --recreate</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter, we saw how you can solve the problem of having multiple containers that want to serve data on the same public port. We learned what a proxy server and reverse proxy server is and how a reverse proxy is used in load balancing.</p><p>We installed and configured two different reverse proxies: HAProxy and Nginx. In my workflow, the Nginx setup fits better, just copying a file, replacing a few words, and then reloading Nginx to have it working. HAProxy might work better in your setup; the choice is yours and one cannot be said to be better than the other.</p><p>
<code class="literal">nginx-proxy</code> automates the process of creating a reverse proxy for containers that are started and is an OK solution for a PaaS, except for one thing: easy and straightforward deployment. That's what the next chapter is all about.</p></div></body></html>