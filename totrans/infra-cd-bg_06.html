<html><head></head><body>
<div><div><div><h1 id="_idParaDest-89" class="chapter-number"><a id="_idTextAnchor350"/>6</h1>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor351"/>Building upon the Foundations</h1>
			<p>As we continue to navigate the ever-evolving landscape of cloud computing, it is essential to understand the nuances of deploying high-level designs across different public cloud providers. In this chapter, we will investigate the differences that arise when using cloud-agnostic tools such as Terraform and Ansible.</p>
			<p>I have found that despite our best efforts to maintain consistency, variations will always crop up when deploying designs across different providers. In this chapter, I will share some of my own experiences addressing these variations and provide some practical approaches for building repeatable deployment processes for various applications and environments.</p>
			<p>We will also discuss the importance of creating modular code, a crucial aspect of streamlining deployment efforts and avoiding duplicating code. By implementing these techniques, we can efficiently and effectively deploy our designs across different public cloud providers.</p>
			<p>We will cover the following topics in the chapter:</p>
			<ul>
				<li><a id="_idTextAnchor352"/>Understanding cloud-agnostic tools</li>
				<li><a id="_idTextAnchor353"/>Understanding the differences between our two cloud deployments</li>
				<li><a id="_idTextAnchor354"/>Understanding the differences between our Terraform and Ansible deployments</li>
				<li><a id="_idTextAnchor355"/>Introducing more variables</li>
				<li><a id="_idTextAnchor356"/>Making the code more reusab<a id="_idTextAnchor357"/>le</li>
			</ul>
			<p>Let’s start by discussing how cloud-agnostic the tools we have been using are.</p>
			<h1 id="_idParaDest-91">Understanding <a id="_idTextAnchor358"/>cloud-agnostic tools</h1>
			<p><a id="_idTextAnchor359"/>In <a id="_idTextAnchor360"/><a id="_idTextAnchor361"/><a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to <a id="_idTextAnchor362"/>Microsoft Azure<a id="_idTextAnchor363"/></em>, and <a id="_idTextAnchor364"/><a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to <a id="_idTextAnchor365"/>Amazon Web Services</em>, we use <a id="_idIndexMarker348"/>both Terraform and Ansible to target these clouds – so we know they work with both cloud providers, but how much of the code did we reuse?</p>
			<p>The honest answer is very little.</p>
			<p>We used different providers/collections for each of the cloud providers. As a result, there were many allowances we needed to make. While conceptually, the cloud providers offer like-for-like services at a high level; they have evolved in very different ways to achieve the same task.</p>
			<p>For example, launching something as simple as a virtual machine requires two approaches: deploying services such as networking work requires different considerations and configurations as they simply just work differently.</p>
			<p>So why do we call the two tools we have been looking at cloud agnostic? Surely that should mean <em class="italic">they </em><em class="italic">just work</em>.</p>
			<p>In an ideal world, yes, that should be the case. With the trends in AI tools at the time of writing this book in <a id="_idIndexMarker349"/>early 2023, we might be close enough to define our <strong class="bold">Infrastructure-as-Code</strong> (<strong class="bold">IaC</strong>) deployments in natural language, with some constraints and rules, and have it target our cloud of choice.</p>
			<p>While that may be close, it doesn’t exist now.</p>
			<p>So back to the here and now with the two tools we have been working with, what changes could we make to how we work to make them as cloud agnostic as possible?</p>
			<p>As we discovered i<a id="_idTextAnchor366"/>n <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Microsoft Azure</em>, and <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>,<em class="italic"> Deploying to Amazon Web Services</em>, both Terraform and Ansible have some useful helper functions, tools, and utilities, so the more we can take advantage of these across our deployments, the better.</p>
			<p>Throughout the rest of this chapter, we will look at what we can consistently use across our deployments, no matter which cloud we are targeting.</p>
			<p>To do this, we need to look at the consistencies across our deployment and then figure out how we can best take them into account in our deployments by developing a more standard approach to writing, managing, and executing our code.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor367"/>Understand the differences between our Microsoft Azure and Amazon Web Services deployments</h1>
			<p>Let’s summarize our deployment as we have covered the deployment in four separate sets of code across the previous two chapters.</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor368"/>General</h2>
			<p>There is just a <a id="_idIndexMarker350"/>single service here, and as you can see – it is only available in one of our target cloud providers:</p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor369"/><a id="_idTextAnchor370"/><strong class="bold">Service/Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor371"/><strong class="bold">Microsoft Azure</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor372"/><strong class="bold">Amazon </strong><strong class="bold">Web Services</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Resource Container</p>
						</td>
						<td class="No-Table-Style">
							<p>Resource group</p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor373"/>Not available</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>There isn’t an equivalent of resource groups within Amazon Web Services, though some could argue that tagging does the same job. However, tags act more as a way of searching for and reporting against your resources rather than collecting them all together in a container, which, as we have seen, can be removed or have permissions applied to them.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor374"/>Network</h2>
			<p>Next up, we have <a id="_idIndexMarker351"/>the network resources; any resources marked with a <strong class="bold">*,</strong> while available, are not used in our WordPress deployment:</p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><a id="_idTextAnchor375"/>Service / </strong><strong class="bold">Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Microsoft Azure</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Amazon </strong><strong class="bold">Web Services</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Network</p>
						</td>
						<td class="No-Table-Style">
							<p>Virtual network</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Virtual Private </strong><strong class="bold">Cloud</strong> (<strong class="bold">VPC</strong>)</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Subnet</p>
						</td>
						<td class="No-Table-Style">
							<p>Subnet</p>
						</td>
						<td class="No-Table-Style">
							<p>Subnet</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Gateway</p>
						</td>
						<td class="No-Table-Style">
							<p>NAT gateway *</p>
						</td>
						<td class="No-Table-Style">
							<p>Internet gateway</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Route table</p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor376"/>Route table *</p>
						</td>
						<td class="No-Table-Style">
							<p>Route table</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Security</p>
						</td>
						<td class="No-Table-Style">
							<p>Network security groups</p>
						</td>
						<td class="No-Table-Style">
							<p>Security group</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Load balancer</p>
						</td>
						<td class="No-Table-Style">
							<p>Load Balancer/Application Gateway *</p>
						</td>
						<td class="No-Table-Style">
							<p>Elastic Load Balancer */Application Load Balancer</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>From a <a id="_idIndexMarker352"/>service point of view, we have an even coverage of services. At the same time, they are configured slightly differently between the two cloud services:</p>
			<ul>
				<li><strong class="bold">Resource name</strong>: All Azure resources require a name. </li>
				<li><strong class="bold">Resource regions and availability zones</strong>: Both clouds have a concept of regions – and in most of those regions, there are multiple availability zones though it is worth pointing out that some secondary regions in Microsoft Azure – for example, UK West, do not have availability zones.</li>
				<li><code>10.0.0.0/24</code>.</li>
				<li><strong class="bold">Subnet addresses</strong>: There were some critical differences between the subnets deployed in our two clouds; for example, in Microsoft Azure, we needed to delegate a particular service to them, whereas, in AWS, we didn’t need to delegate a service. Still, we did pin our subnets to an availability zone within our target region. However, outside of this, the information needed for each cloud is roughly the same.</li>
			</ul>
			<p>Of the network services we are deploying, a few of them would benefit from being configured using loops and passing in variables – though this could get a little complicated as we will need a little logic for both Terraform and Ansible for Azure Services, which may require a service delegated to the subnet.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor377"/>Storage</h2>
			<p>On the face of it, this <a id="_idIndexMarker353"/>should be simple as we <em class="italic">just</em> need to launch and configure some storage; however, as you may remember from our scripts, there are pretty big differences between the two cloud providers in terms of storage:</p>
			<table id="table003" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><a id="_idTextAnchor378"/></strong><strong class="bold">Service/Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Microsoft Azure</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Amazon </strong><strong class="bold">Web Services</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Storage (<strong class="bold">Network File </strong><strong class="bold">System</strong> (<strong class="bold">NFS</strong>))</p>
						</td>
						<td class="No-Table-Style">
							<p>Storage account with Azure Files enabled</p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor379"/>Amazon Elastic File Service</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Private <strong class="bold">Domain Name </strong><strong class="bold">System</strong> (<strong class="bold">DNS</strong>)</p>
						</td>
						<td class="No-Table-Style">
							<p>Private DNS zone</p>
						</td>
						<td class="No-Table-Style">
							<p>Mount targets</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Network integration</p>
						</td>
						<td class="No-Table-Style">
							<p>Private endpoint</p>
						</td>
						<td class="No-Table-Style">
							<p>Not required</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>As you can see, there are some differences in the way that Microsoft handles network <a id="_idTextAnchor380"/>integration of its services in Azure – with the key word there being <strong class="bold">integration</strong>.</p>
			<p>The most significant and consistent difference between the two cloud providers is how networking <a id="_idIndexMarker354"/>works on their <strong class="bold">Platform-as-a-Service</strong> (<strong class="bold">PaaS</strong>) services.</p>
			<p>I typically <a id="_idIndexMarker355"/>explain that Amazon has built its PaaS services from the ground up to be deployed within an Amazon VPC network.</p>
			<p>By contrast, Microsoft has built its PaaS services to allow you to link them to your virtual network. In some cases, that link is not always bi-directional, so certain PaaS services can only have access to resources within a virtual network rather than being able to be consumed within the virtual network – while this is not the case for any of the services in our example WordPress deployment, it is a consideration you need to make when planning your deployments.</p>
			<p>The information required to launch and configure the services is similar, even with the differences previously described.</p>
			<h3>Database</h3>
			<p>In typical <a id="_idIndexMarker356"/>fashion, after explaining that in Microsoft Azure, most PaaS services have a level of virtual network integration rather than being launched directly into the network, we launch one of the network Azure services that is hosted within the virtual network:</p>
			<table id="table004" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><a id="_idTextAnchor381"/></strong><strong class="bold">Service/Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Microsoft Azure</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Amazon </strong><strong class="bold">Web Services</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Database</p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor382"/>Azure Database for MySQL – Flexible Server</p>
						</td>
						<td class="No-Table-Style">
							<p>Amazon Relational Database Service</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Private DNS</p>
						</td>
						<td class="No-Table-Style">
							<p>Private DNS zone</p>
						</td>
						<td class="No-Table-Style">
							<p>Subnet group</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>While <a id="_idIndexMarker357"/>we don’t need to add a private endpoint when deploying Azure Database for MySQL – Flexible Server, we do need to delegate an entire subnet to the service, so there are a few considerations still to make when planning the deployment.</p>
			<p>Again, the bulk of the information required to launch the services is similar between the two cloud providers.<a id="_idTextAnchor383"/></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor384"/>Virtual machine (admin)</h2>
			<p>When deploying the <a id="_idIndexMarker358"/>admin virtual machine instance, we needed to make a few considerations; however, the information required is similar for each of our two cloud providers:</p>
			<table id="table005" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><a id="_idTextAnchor385"/></strong><strong class="bold">Service/Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Microsoft Azure</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Amazon </strong><strong class="bold">Web Services</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Image</p>
						</td>
						<td class="No-Table-Style">
							<p>Azure Image from the <a id="_idTextAnchor386"/>Azure Marketplace</p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold"><a id="_idTextAnchor387"/>Amazon Machine Image</strong> (<strong class="bold">AMI</strong>) from the AWS Marketplace</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Compute</p>
						</td>
						<td class="No-Table-Style">
							<p>Azure Virtual Machine</p>
						</td>
						<td class="No-Table-Style">
							<p>Amazon <strong class="bold">Elastic Compute </strong><strong class="bold">Cloud</strong> (<strong class="bold">EC2</strong>)</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Load Balancer Attachment</p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor388"/>Required</p>
						</td>
						<td class="No-Table-Style">
							<p>Required</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>As you may recall, when we launched our WordPress workload in Amazon Web Services, we needed to adjust our cloud-init script slightly to consider the differences in how some of the services are consumed. All we needed was to build in a bit of logic to check and, if <a id="_idIndexMarker359"/>required, wait for our resources to be available.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor389"/>Virtual machines with scaling (web)</h2>
			<p>Everything we <a id="_idIndexMarker360"/>mentioned for deploying the admin virtual machine instance also applies here; there is only really one main difference between the two providers:</p>
			<table id="table006" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Service/Function</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Microsoft Azure</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Amazon </strong><strong class="bold">Web Services</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Image</p>
						</td>
						<td class="No-Table-Style">
							<p>Azure Image from the Azure Marketplace</p>
						</td>
						<td class="No-Table-Style">
							<p>AMI from the AWS Marketplace</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor390"/>Configuration</p>
						</td>
						<td class="No-Table-Style">
							<p>Not required</p>
						</td>
						<td class="No-Table-Style">
							<p>Launch configuration</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor391"/>Compute</p>
						</td>
						<td class="No-Table-Style">
							<p>Azure Virtual Machine Scale Sets</p>
						</td>
						<td class="No-Table-Style">
							<p>Amazon EC2 <a id="_idTextAnchor392"/>Auto Scaling Group</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Load Balancer Attachment</p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor393"/>Inline</p>
						</td>
						<td class="No-Table-Style">
							<p>Inline</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>As you can see, all Azure configurations are inline; however, by contrast, Auto Scaling groups in Amazon Web Services require a launch configuration to use as the base for our deployment.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor394"/>Seeing it in action</h2>
			<p>As you can see, while <a id="_idIndexMarker361"/>the two cloud providers work slightly differently, there is close-enough feature parity for your deployment to take a similar approach, at least at a high level.</p>
			<p>So, what does all this mean when it comes to being cloud agnostic with a single tool?</p>
			<p>Well, as we have already discussed at a high level, the approach is similar, and while the modules/tasks may differ, you can use some of the same logic when it comes to your deployments.</p>
			<p>Let’s look at doing this with Terraform code; the code will create a primary network and then use a loop to create four subnets in both Microsoft Azure and Amazon Web Services:</p>
			<ol>
				<li>First of all, let’s look at the variables we are going to be using to achieve this – to start with, we have the <code>name</code>, <code>region</code>, and <code>default</code> tags:<pre class="source-code">
variable "name" {
  description = "Base name for resources"
  type        = string
  default     = "iac-wordpress"
}
variable "region" {
  description = "The region to deploy to"
  type        = string
  default     = "uksouth"
}
variable "tags" {
  description = "The default tags to use across all of our resources"
  type        = map(any)
  default = {
    project     = "iac-wordpress"
    environment = "example"
    deployed_by = "terraform"
  }
}</pre></li>
			</ol>
			<p>The only <a id="_idIndexMarker362"/>variable that will change between our two cloud providers is <code>region</code>, as each provider has different region names.</p>
			<ol>
				<li value="2">Next up, we define the address space:<pre class="source-code">
variable "address_space" {
  description = "The address space of the network"
  type        = string
  default     = "10.0.0.0/24"
}</pre></li>
				<li>Nothing <a id="_idIndexMarker363"/>too special here still; however, for the subnets, we define the following, from which, while quite lengthy, you should be able to quickly get an idea of what is happening:<pre class="source-code">
variable "subnets" {
  description = "The subnets to deploy the network"
  type = map(object({
    name                  = string
    address_prefix_size   = number
    address_prefix_number = number
  }))
  default = {
    subnet_001 = {
      name                  = "subnet001"
      address_prefix_size   = "3"
      address_prefix_number = "0"
    },
    subnet_002 = {
      name                  = "subnet002"
      address_prefix_size   = "3"
      address_prefix_number = "1"
    },
    subnet_003 = {
      name                  = "subnet003"
      address_prefix_size   = "3"
      address_prefix_number = "2"
    },
    subnet_004 = {
      name                  = "subnet004"
      address_prefix_size   = "3"
      address_prefix_number = "3"
    },
  }
}</pre></li>
			</ol>
			<p>As you <a id="_idIndexMarker364"/>can see, we are defining a map here as that will give us something we can loop through. Now let us move on to the <code>main.tf</code> files.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Please note that this is not the complete code – please see the GitHub repository that accompanies this title for the full executable code.</p>
			<ol>
				<li value="4">We first create the network itself; the following is for AWS, where we are creating a VPC:<pre class="source-code">
resource "aws_vpc" "network" {
  cidr_block           = var.address_space
  tags                 = merge(var.tags, tomap({ Name = "${var.name}-vpc" }))
}</pre></li>
				<li>Now <a id="_idIndexMarker365"/>we have the same task, but this time for Azure, which creates a virtual network:<pre class="source-code">
resource "azurerm_virtual_network" "network" {
  resource_group_name = azurerm_resource_group.resource_group.name
  location            = azurerm_resource_group.resource_group.location
  name                = "vnet-${var.name}-${var.region}"
  address_space       = [var.address_space]
  tags                = merge(var.tags, tomap({ Name = "vnet-${var.name}-${var.region}" }))
}</pre></li>
			</ol>
			<p>As you can see, they are not too dissimilar, and we are applying the same logic of taking the list of tags and adding one using the <code>merge</code> function to add the resource name.</p>
			<ol>
				<li value="6">Now that we have our networks, it’s time to loop over the <code>subnets</code> variable and add those, starting with AWS again:<pre class="source-code">
resource "aws_subnet" "subnets" {
  for_each          = var.subnets
  vpc_id            = aws_vpc.network.id
  cidr_block        = cidrsubnet("${aws_vpc.network.cidr_block}", each.value.address_prefix_size, each.value.address_prefix_number)
  tags              = merge(var.tags, tomap({ Name = "${var.name}-${each.value.name}" }))
}</pre></li>
				<li>Then <a id="_idIndexMarker366"/>the same again, this time for Azure:<pre class="source-code">
resource "azurerm_subnet" "subnets" {
  for_each             = var.subnets
  name                 = each.value.name
  resource_group_name  = azurerm_resource_group.resource_group.name
  virtual_network_n<a id="_idTextAnchor395"/>ame = azurerm_virtual_network.network.name
  address_prefixes     = [cidrsubnet("${azurerm_virtual_network.network.address_space[0]}", each.value.address_prefix_size, each.value.address_prefix_number)]
}</pre></li>
			</ol>
			<p>As you can see, we are using the same approach in both in that we are looping through the <code>var.subnets</code> variable using a <code>for_each</code> loop.</p>
			<p>We then use <code>each.value.name</code> to name the resource, in Azure’s case, using the <code>name</code> key, and for AWS, by creating a <code>Name</code> tag.</p>
			<p>For both, we use the output of creating the network to reference it; for AWS, we use <code>aws_vpc.network.id</code>; in Azure, we use <code>azurerm_virtual_network.network.name</code>.</p>
			<p>This will <a id="_idIndexMarker367"/>ensure that Terraform will only attempt to create the subnets once the network they are going to live in has been created.</p>
			<p>We can then use the <code>cidrsubnet</code> function to take our address space, which again is being referenced from the network resource we created using <code>"${aws_vpc.network.cidr_block}"</code> for AWS and <code>"${azurerm_virtual_network.network.address_space[0]}"</code> for Azure.</p>
			<p>We then use <code>each.value.address_prefix_size</code> to define the CIDR size of <a id="_idIndexMarker368"/>each subnet, which in our case is <code>/27</code>, and <code>each.value.address_prefix_number</code> to define where within the address space <code>/27</code> is placed.</p>
			<p>As you can see, while the application of variables and functions is slightly different between Amazon Web Services and Microsoft Azure, we can use the same logic to generate and loop through the subnets.</p>
			<p>We can also apply the same logic using Ansible – as we will discuss more in the next section.</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor396"/>Understanding the differences between our Terraform and Ansible deployments</h1>
			<p>We have discussed <a id="_idIndexMarker369"/>how we can take a <a id="_idIndexMarker370"/>cloud-agnostic approach to our deployments when using either Terraform or Ansible, as each tool has built-in functions and logic for manipulating our variables and the output of running tasks.</p>
			<p>Some big differences should have become apparent during the code walk-throughs in <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Micro<a id="_idTextAnchor397"/>soft Azure</em>, and <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon Web Services</em>. I am also sure you are forming an opinion on which of the two tools you prefer.</p>
			<p>The two tools are very different in their approach, which is to be expected as they were designed to do two different tasks.</p>
			<p>Terraform is primarily designed <a id="_idTextAnchor398"/>to manage infrastructure, whereas Ansible manages server and state <a id="_idIndexMarker371"/>configuration, which <a id="_idIndexMarker372"/>also includes a level of infrastructure management.</p>
			<p>During my day job, I have, and continue to use, both tools – so where does the decision to use one or the other come in?</p>
			<p>If a project <a id="_idIndexMarker373"/>requires the repeatable <a id="_idIndexMarker374"/>deployment and configuration of several PaaS services in either cloud – especially if the resources need to be launched, consumed, and then terminated, then I recommend using Terraform; this is for a few reasons:</p>
			<ul>
				<li>First, it stores everything in its state file, making terminating any workload a lot more straightforward as we discovered when terminating our AWS deployment using Ansible, we needed to build in quite a lot of logic to make sure that the workload was correctly terminated and removed.</li>
				<li>Secondly, it <a id="_idIndexMarker375"/>plays well into <strong class="bold">continuous integration/continuous delivery</strong> (<strong class="bold">CI/CD</strong>) services such as GitHub Actions, which we will d<a id="_idTextAnchor399"/>iscuss in more detail in <a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a>, <em class="italic">Leveraging CI/CD in </em><em class="italic">the Cloud</em>.</li>
				<li>Finally, I find it has much more coverage and support for some of the newer services and features the cloud providers are introducing. That’s not to knock the Ansible development team; it is just that Ansible, in most cases, appears to lag Terraform with new features depending on which of the clouds you are targeting.</li>
			</ul>
			<p>Some of the reasons to use Terraform are also some of the contributing factors when it comes to choosing to use Ansible – for example, as Ansible does not use state files and dynamically discovers resources, it is a lot more straightforward to manage in-life changes, for instance, ones that are made once the resources have been deployed and the service is in production, as you don’t run the risk of the tool trying to enforce a state it knows about strictly.</p>
			<p>Also, Ansible can be used if I need to interact with the host at the resource level itself, for example, I need to, <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) into a <a id="_idIndexMarker376"/>server that has just been launched or target a Windows Server using WinRM to <a id="_idIndexMarker377"/>configure the host to set Apache or <strong class="bold">Internet Information </strong><strong class="bold">Services</strong> (<strong class="bold">IIS</strong>).</p>
			<p>It is great for working with fixed points, meaning that, let’s say, you have been using Ansible to manage the state of the workload, which has been running a virtual machine on-premise when you can likely reuse a lot of that code to target a cloud environment.</p>
			<p>In these cases, Ansible will be the tool of choice.</p>
			<p>There is also another option – <em class="italic">use both</em>! That’s right; you can use Ansible to run your Terraform code using the <code>community.general.terraform</code> task.</p>
			<p>In the code <a id="_idIndexMarker378"/>repository accompanying <a id="_idIndexMarker379"/>this title, you will find a folder called <code>ansible-terraform-azure</code>. This contains an Ansible playbook, which will use Terraform to launch an Azure-hosted virtual machine and then, using Ansible, connect to it, install <code>index.html</code> file.</p>
			<p>The task that performs this is as follows:</p>
			<pre class="source-code">
- name: Launch an Azure Virtal Machine instance and supporting resources using Terraform
  community.general.terraform:
    project_path: "./terraform"
    state: "present"
    complex_vars: true
    variables:
      name: "{{ app.name }}"
      region: "{{ azure.region }}"
      address_space: "{{ azure.vnet_address_space }}"
      vm_admin_username: "{{ azure.vm_admin_username }}"
      vm_ssh_public_key: "{{ lookup('file', '{{ ssh.public_key_path }}') }}"
      tags:
        app: "{{ app.name }}"
        env: "{{ app.env }}"
        deployed_by: "{{ app.deployed_by }}"
    force_init: true
  register: terraform_output</pre>
			<p>As you can see, we are telling the task where our Terraform code is; in this case, it is in the <code>terrform</code> folder. We are then passing in several variables, which overwrite the defaults defined in the <code>variables.tf</code> file in the <code>terraform</code> folder.</p>
			<p>As part of <a id="_idIndexMarker380"/>the Terraform execution, we <a id="_idIndexMarker381"/>are outputting the public IP address and the name of the virtual machine, which we then add to a host group using the following task:</p>
			<pre class="source-code">
- name: Add the Virtual Machine to the vmgroup group
  ansible.builtin.add_host:
    groups: "{{ host_group_name }}"
    hostname: "{{ terraform_output.outputs.vm_name.value }}"
    ansible_host: "{{ terraform_output.outputs.public_ip.value }}"
    ansible_port: "{{ ssh.port_number }}"</pre>
			<p>Before finally setting some facts using the <code>ansible.builtin.set_fact</code> module:</p>
			<pre class="source-code">
- name: set some facts based on the virtual machine we just launch<a id="_idTextAnchor400"/>ed using Terraform
  ansible.builtin.set_fact:
    ansible_ssh_private_key_file: "{{ ssh.private_key_path }}"
    ansible_ssh_user: "{{ azure.vm_admin_username }}"
    the_public_ip: "{{ terraform_output.outputs.public_ip.value }}"
    the_vm_name: "{{ terraform_output.outpu<a id="_idTextAnchor401"/>ts.vm_name.value }}"</pre>
			<p>If you <a id="_idIndexMarker382"/>run the playbook, which you <a id="_idIndexMarker383"/>can do by running <a id="_idTextAnchor402"/>the following command:</p>
			<pre class="source-code">
$ ansible-playbook -i inv site.yml</pre>
			<p>You should see something like th<a id="_idTextAnchor403"/>e following output:</p>
			<div><div><img src="img/Figure_6.01_B19537.jpg" alt="Figure 6.1 – Having Ansible run Terraform" width="1650" height="826"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – Having Ansible run Terraform</p>
			<p>If you follow the link given in your output (the one in the previous screenshot is no longer active), you should be presented with a web page that looks like the <a id="_idTextAnchor404"/>following screen:</p>
			<div><div><img src="img/Figure_6.02_B19537.jpg" alt="Figure 6.2 – Having Ansible run Terraform" width="1650" height="460"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Having Ansible run Terraform</p>
			<p>You can remove everything using the following playbook:</p>
			<pre class="source-code">
$ ansible-playbook -i inv destroy.yml</pre>
			<p>As you may <a id="_idIndexMarker384"/>have imaged, as we are <a id="_idIndexMarker385"/>using Terraform to manage the Azure resources, the preceding playbook uses Ansible to run <code>terraform destroy</code> rather than us having to set each resource to <code>absent</code> as we have had to do in previous Ansible playbooks.</p>
			<p>Now that we have discussed how to use both Ansible and Terraform together to get the best out of both tools, we need to discuss variables next. As you will have noticed, we have used many variables in all our Ansible and Terraform code, so let’s now discuss how we can best use them.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor405"/>Introducing more variables</h1>
			<p>Personally, I try to <a id="_idIndexMarker386"/>do everything I can use variables rather than hardcoding values into the code itself – while this can take more time when it comes to writing your code, I highly recommend it as both tools we have looked at allow you to override variables at runtime via the command line.</p>
			<p>To do this in Terraform, you can use the following flag when run<a id="_idTextAnchor406"/>ning the <code>apply</code> command:</p>
			<pre class="source-code">
$ terra<a id="_idTextAnchor407"/>form apply -var region="eu-west-1"</pre>
			<p>When running the Terraform code, which we discussed earlier in the chapter, we launched a network in Amazon Web Services to change the region from <code>us-east-1</code>, which is the default set within the code, to <code>eu-west-1</code> instead.</p>
			<p>You can add multiple variables; the following example expands on the previous one by adding a new address space to<a id="_idTextAnchor408"/> use:</p>
			<pre class="source-code">
$ terraform apply <a id="_idTextAnchor409"/>-var region="eu-west-1" -var address_space="172.16.0.0/24"</pre>
			<p>When running <a id="_idIndexMarker387"/>Ansible code, for example, in the playbook we executed in the last section, you can run the followi<a id="_idTextAnchor410"/>ng command to override<a id="_idTextAnchor411"/> a top-level variable:</p>
			<pre class="source-code">
$ ansible-playbook -i inv site.yml --extra-vars 'host_group_name: "azure_vms "'</pre>
			<p>Here we are changing the host group name to <code>azure_vms</code>; you may have noticed that I said top-level variable because many of the variables we are using in the Ansible playbook are multi-level sub-variables – these look like the following:</p>
			<pre class="source-code">
page:
  title: "Infrastructure as Code for Beginners"
  body: "<a id="_idTextAnchor412"/>This Virtual Machine was launched using Terraform and Ansible"</pre>
			<p>To override these, we need to pass in multiple variables as JSON; this turns our command into the following:</p>
			<pre class="source-code">
$ ansible-<a id="_idTextAnchor413"/>playbook -i inv site.yml -<a id="_idTextAnchor414"/>-extra-vars '{"page": { "title": "Changing a variable at runtime", "body": "Redeploying using a different variable" }}'</pre>
			<p>It is important to pass in everything if I try and override a single variable, for example, <code>title</code>, as it replaces the whole block, which means that there is no longer a <code>body</code> variable, and our playbook run will error.</p>
			<p>We will use some of these techniques and<a id="_idTextAnchor415"/> more in our next chapter, <a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a>,<em class="italic"> Leveraging CI/CD in </em><em class="italic">the Cloud</em>.</p>
			<p>As mentioned at the start of the section, it can sometimes add more time to creating your code when trying to use as many variables as possible – especially if you have quickly prototyped your code to deploy something and have hardcoded some of the values in for ease of use.</p>
			<p>It is possible to use tools such as <strong class="bold">ChatGPT</strong> and other AI services to help add variables to take your <a id="_idIndexMarker388"/>code and replace hardcoded values quite quickly.</p>
			<p>Use the following <a id="_idIndexMarker389"/>prompt to ask ChatGPT to turn some basic Terraform code into one with variables:</p>
			<pre class="source-code">
Add variables to this Terraform code using the current values as the defaults, making sure to add a description and the type of variable.
```
resource "azurerm_resource_group" "example" {
  name     = "example"
  location = "West Europe"
}
```</pre>
			<p>It gave the following response:</p>
			<pre class="source-code">
variable "resource_group_name" {
  description = "The name of the Azure resource group."
  type        = string
  default     = "example"
}
variable "location" {
  description = "The location of the Azure resource group."
  type        = string
  default     = "West Europe"
}
resource "azurerm_resource_group" "example" {
  name     = var.resource_group_name
  location = var.location
}</pre>
			<p>As you can see, we have <a id="_idIndexMarker390"/>everything we need to copy and paste into our code – at the time of writing, responses from tools such as ChatGPT need to be double-checked, but as mentioned earlier in this chapter – as tools like this get more powerful, it is fully expected that you will be using them a lot more in your day-to-day workflows.</p>
			<p>One of the advantages of using variables is that it makes our code more reusable, let’s discuss this in a little more detail now.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor416"/>Making the code more reusable</h1>
			<p>As well as using variables, we are also able to reuse <em class="italic">chunks</em> of code – when we discussed Ansible in <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon Web Services</em>, we discussed <em class="italic">roles</em>. In Ansible, roles <a id="_idIndexMarker391"/>are designed to be called repeatedly, so while we used them to logically split our project into more manageable sections, we can go one step further and have them only perform a single function.</p>
			<p>We can also do the same thing in Terraform. For most of our Azure deployments so far, we have been using a module downloaded from the Terraform registry to manage the region settings.</p>
			<p><strong class="bold">Claranet</strong>, the publisher <a id="_idIndexMarker392"/>of that module, also has others – let us look at how we can create a virtual network in Azure using only modules (the complete executable code can be found in this book’s GitHub repository):</p>
			<ol>
				<li>To start, we need to initialize the region module as we have been doing in our other Terraform code:<pre class="source-code">
module "azure_region" {
  source       = "claranet/regions/azurerm"
  azure_region = var.region
}</pre></li>
				<li>Once we have the region locked in, we can then use the output of that module to create a resource group:<pre class="source-code">
module "rg" {
  source      = "clarane<a id="_idTextAnchor417"/>t/rg/azurerm"
  location    = m<a id="_idTextAnchor418"/>odule.azure_region.location
  client_name = var.name
  en<a id="_idTextAnchor419"/>vironment = var.environment
  stack       = var.project_name
}</pre></li>
			</ol>
			<p>As you can see, we <a id="_idIndexMarker393"/>are using <code>module.azure_region.location</code> to define the location. Then we are passing in some details about our project – as Claranet is a managed service provider, it uses <code>client_name</code> and <code>stack</code> throughout its modules.</p>
			<ol>
				<li value="3">Next up, we need to create a virtual network:<pre class="source-code">
module "azure_virtual_network" {
  source              = "claranet/vnet/azurerm"
  environment         = var.environment
  location            = module.azure_region.location
  location_short      = module.azure_region.location_short
  client_name         = var.name
  stack               = var.project_name
  resource_group_name = module.rg.resource_group_name
  vnet_cidr           = var.address_space
}</pre></li>
			</ol>
			<p>Again, we can see more o<a id="_idTextAnchor420"/>f the same information and the CIDR space we want to use.</p>
			<ol>
				<li value="4">The final pa<a id="_idTextAnchor421"/>rt is to create the subnet(s):<pre class="source-code">
module "azure_network_subnet" {
  for_each             = var.sub<a id="_idTextAnchor422"/>nets
  source               = "claranet/subnet/azurerm"
  environment          = var.environment
  location_short       = module.azure_region.location_short
  custom_subnet_name   = each.value.name
  client_name          = var.name
  stack                = var.project_name
  resource_group_name  = module.rg.resource_group_name
  virtual_network_name = module.azure_virtual_network.virtual_network_name
  subnet_cidr_list     = [cidrsubnet("${module.azure_virtual_network.virtual_network_space[0]}", each.value.address_prefix_size, each.value.address_prefix_number)]
}</pre></li>
			</ol>
			<p>As you can see, I am <a id="_idIndexMarker394"/>using the same logic we used to create the subnets earlier in this chapter using the <code>cidrsubnet</code> function in a <code>for_each</code> loop across the <code>subnets</code> variable.</p>
			<p>So why would you want to do this?</p>
			<p>As we saw when we used Terraform to deploy our WordPress workload in Microsoft Azure in <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Microsoft Azure</em>, we had to build in logic to handle changes in subnet settings – in our case, this was to del<a id="_idTextAnchor423"/>egate a subnet for use with the Azure Database for MySQL – Flexible Server service.</p>
			<p>The module <a id="_idIndexMarker395"/>provided by Claranet has this logic built in; for example, the code to add this would look like the following:</p>
			<pre class="source-code">
modul<a id="_idTextAnchor424"/>e "azure_network_subnet_001" {
  for_each             = var.subnets
  source               = "claranet/subnet/azurerm"
  environment          = var.environment
  location_short       = module.azure_region.location_short
  custom_subnet_name   = each.value.name
  client_name          = var.name
  stack                = var.project_name
  resource_group_name  = module.rg.resource_group_name
  virtual_network_name = module.azure_virtual_network.virtual_network_name
  subnet_cidr_list     = ["10.0.0.0/27"]
  subnet_delegation = {
    flexibleServers = [
      {
        name    = "Microsoft.DBforMySQL/flexibleServers"
        actions = ["Microsoft.Network/virtualNetworks/subnets/join/action"]
      }
    ]
  }
}</pre>
			<p>Claranet has over 80 other modules for Microsoft Azure and Amazon Web Services on Terraform registry, and they are not the only provider to have modules published there – both other providers and individuals have modules published there that are all free to use.</p>
			<p>You can also publish your own modules on the Terraform registry or even host them on GitHub as either <a id="_idIndexMarker396"/>public or private repositories; the advantage of using modules and taking this approach is that it enables you very quickly to develop your IaC deployments with consistent reusable components.</p>
			<p>So, what about Ansible?</p>
			<p>As already mentioned, you can use roles, which are distributed via Ansible Galaxy – there are far fewer roles there compared to the modules available in Terraform – but you can publish your ow<a id="_idTextAnchor425"/>n or reuse them locally.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor426"/>Pop quiz</h1>
			<p>Before we finish the chapter, let’s have a quick pop quiz:</p>
			<ol>
				<li>What is the name of the function we use to work with CIDR ranges in Terraform?</li>
				<li>When passing in variables at runtime, which tools use the <code>--extra-vars</code> flag, and which one uses <code>-var</code>?</li>
				<li>What key can be used to loop through a list or map of variables in Terraform tasks or modules?</li>
				<li>When working with NFS, which of the two public clouds requires a mount target to be configured?</li>
				<li>Azure Database for MySQL – Flexible Server requires us to do what to a subnet?</li>
			</ol>
			<p>You can find the answers after the summary.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor427"/>Summary</h1>
			<p>With the use of variables, modules, or roles, you can quickly build up your IaC deployments in a consistent way that can be shared with the rest of your team, allowing everyone to build their environments using a set of shared building blocks.</p>
			<p>Another advantage of this approach is that you are deploying the same sort of infrastructure repeatedly for your project because you have multiple environments or multiple customers.</p>
			<p>Having a set of variables per deployment changing things such as the <strong class="bold">stock keeping units</strong> (<strong class="bold">SKUs</strong>) or resource names, with everything else being the same, will save time and allow you to manage all your deployments centrally. We will look at how to centrally manage our deployment in our next chapter, <a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a>, <em class="italic">Leveraging CI/CD in </em><em class="italic">the Cloud</em>.</p>
			<p>Before we move on, let us quickly summarize what we have discussed in this chapter. We started by clearing up what we mean by cloud-agnostic tools before looking at the difference between our Amazon Web Services and Microsoft Azure deployments.</p>
			<p>We then discussed the differences in the approaches we need to take when choosing to use Terraform or Ansible; we also did a bit of a deep dive into how we can combine the two tools and use Ansible to manage our Terraform deployment.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor428"/>Further reading</h1>
			<p>You can find more details on the services and documentation we have mentioned in this chapter at the following URLs:</p>
			<ul>
				<li>Terraform Registry: <a href="https://registry.terraform.io">https://registry.terraform.io</a></li>
				<li>Claranet Terraform modules and providers: <a href="https://registry.terraform.io/namespaces/claranet">https://registry.terraform.io/namespaces/claranet</a></li>
				<li>Ansible Galaxy: <a href="https://galaxy.ansible.com">https://galaxy.ansible.com</a></li>
				<li>Ansible Terraform module: <a href="https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.html">https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.html</a></li>
				<li>ChatGPT: <a href="https://openai.com/blog/chatgpt/">https://openai.com/blog/chatgpt/</a></li>
			</ul>
			<h1 id="_idParaDest-105"><a id="_idTextAnchor429"/>Answers</h1>
			<p>Here are the answers to the pop quiz:</p>
			<ol>
				<li>What is the name of the function we use to work with CIDR ranges in Terraform? The answer is <code>cidrsubnet</code>.</li>
				<li>When passing in variables at runtime, which tools use the <code>--extra-vars</code> flag, and which one uses <code>-var</code>?  The <code>--extra-vars</code> flag is used by Ansible, and <code>-var</code> is Terraform.</li>
				<li>What key can be used to loop through a list or map of variables in Terraform tasks or modules? The key is <code>for_each</code> with the value being the variable you wish to loop through.</li>
				<li>When working with NFS, which of the two public clouds requires a mount target to be configured? The answer is Amazon Web Services.</li>
				<li>Azure Database for MySQL – Flexible Server requires us to do what to a subnet? Azure Database for MySQL – Flexible Server must have an entire subnet delegated to it using the <code>delegate</code> key.</li>
			</ol>
		</div>
	</div>
</div>


<div><div><div><h1 id="_idParaDest-106"><a id="_idTextAnchor430"/>Part 3: CI/CD and Best Practices</h1>
			<p>In this part, we will look at using <strong class="bold">Continuous Integration/Continuous Deployment</strong> (<strong class="bold">CI/CD</strong>) hosted in the cloud. We will be using GitHub Actions to execute our Terraform and Ansible deployments.</p>
			<p>We will then move on to discussing best practices and some common troubleshooting tips, before finally reviewing a few alternatives to Terraform and Ansible.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a><em class="italic">, Leveraging CI/CD in the Cloud</em></li>
				<li><a href="B19537_08.xhtml#_idTextAnchor509"><em class="italic">Chapter 8</em></a><em class="italic">, Common Troubleshooting Tips and Best Practices</em></li>
				<li><a href="B19537_09.xhtml#_idTextAnchor545"><em class="italic">Chapter 9</em></a><em class="italic">, Exploring Alternative Infrastructure-as-Code Tools</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</div>
</div>
</body></html>