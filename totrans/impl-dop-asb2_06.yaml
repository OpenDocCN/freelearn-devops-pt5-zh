- en: Jinja in Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JINJA was created in 2008 by Armin Ronacher and aims to replace similar template
    engines with a more modern and structured solution. Jinja was designed for Python
    (the programming language that Ansible was created with) and, coupled with Ansible,
    to provide a framework that integrates seamlessly with YAML. Ansible's YAML implementation
    and programmatic playbook solution incorporates this robust Jinja template engine.
    Like many other template solutions (Django, Smarty, and so on), Jinja was designed
    to provide structural support for reusable text with context specific alterations
    (environments, hosts, and so on) and comprehensive functionality that developers
    have come to rely on.
  prefs: []
  type: TYPE_NORMAL
- en: For those who have experience with Smarty or Django-styled tempting solutions,
    Jinja will indeed be familiar. The design of the Jinja template solution aims
    to provide support for designers, developers, and operators alike by providing
    the ability to add conditional logic, iterative behaviors, and logic oriented
    solutions while adhering to Python best practices. This solution is particularly
    useful for playbook developers because it provides a highly adaptive programmatic
    flexibility that can be leveraged by organizations using environments that are
    similar in nature but have slight differences. Suffice to say, the initial learning
    curve of Jinja is low and the usefulness of the markup and logic is high.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how Ansible integrates with Jinja and how Jinja
    can be leveraged to provide advanced functionality within Ansible playbook''s.
    We will discover how Jinja came about, see how it can be leveraged to create comprehensive
    playbook implementations, learn how its syntax cohabitates with Ansible''s YAML
    playbook syntax, and see how Jinja complements Ansible''s playbook implementation.
    By the end of this chapter, we will have covered the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jinja.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How is Jinja2 used by Ansible?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jinja programming constructs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying Jinja to Ansible playbooks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create loops and iterators in Jinja2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to make and use Jinja2 template files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to use data structures with Jinja2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Jinja
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja is a templating engine that was developed in 2008 by Armin Ronacher in
    an effort to provide Python developers with a framework that would supply comprehensive
    Python-like syntax that could be used within strings and data documents. The solution
    was designed with similar solutions such as Smarty and Django in mind. Jinja executes
    its template translations in a sandbox (isolated from the rest of the program
    execution) so as to prevent the template engine from interfering with the normal
    operational execution of the Python program.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 represents the second major version of the Jinja Python library. Jinja
    is leveraged to generate string-based documents based on one or more predefined
    templates (also made of strings). As of the writing of this book, Jinja is in
    use by numerous open source solutions that are actively developed with Python.
    Some notable examples of solutions that use Jinja include Salt, Flask, and Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: When coupled with Ansible and YAML, Jinja adds significant amounts of power
    to the Ansible playbook architecture. Jinja in this context provides Ansible playbook
    developers with the ability to add programming constructs (including variables,
    conditional logic, loops, and more) to a playbook and structure it in such a way
    where it can be leveraged as a complete programming solution for automation. Before
    we get ahead of ourselves and start looking at all the neat stuff that Jinja can
    do, let's first understand how it actually works.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja is a software solution designed to combine templates with a data model
    to produce result documents. The templates contain special markup tags and logic
    that are parsed and logically combined during the execution of the template-parsing
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better explain the concept of a template engine, the following Python code
    shows a basic example of string manipulation using Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Basic Jinja Python implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'From the example we just saw, we can observe that this simple Python script
    does the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Imports the Jinja template engine library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Defines a simple string template, `['Hello {{ place }] ']`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Renders the template and substitutes the `{{ place }}` tag with the word `World`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you are planning on implementing Jinja directly within Python, the Python
    Jinja module must be installed within Python first. This can be performed fairly
    easily, and the instructions on how to do this are readily available at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://jinja.pocoo.org/docs/2.9/intro/#installation](http://jinja.pocoo.org/docs/2.9/intro/#installation)'
  prefs: []
  type: TYPE_NORMAL
- en: The output of the previous example is `Hello World`. From this example, we can
    observe that the Jinja template tag `{{ ... }}` is translated during the rendering
    process, whereas the rest of the string-based document is left intact.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a pretty good idea of the basic concepts surrounding Jinja,
    let's take a look at a more realistic example of Jinja in action by looking at
    a simple Ansible playbook that uses Jinja.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content of the `playbook.yml` is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`motdexample.j2`: This is a Jinja2-generated **motd** file also known as **message
    of the day**. The following content tags will be replaced by the variable data
    we defined in our playbook (`my_var` and `my_var2`, respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Can you guess what this example will do when executed using Ansible with the
    assistance of the Jinja2 templating engine? Ansible in conjunction with Jinja
    will copy the motd file to the target hosts *and* replace the `{{}}` styled variables
    at the same time with the contents of `my_var` and `my_var2`. Let''s take a look
    at the output of the motd file on the target host:'
  prefs: []
  type: TYPE_NORMAL
- en: '`/etc/motd content`: This is a Jinja2-generated motd file. The following content
    tags will be replaced by the variable data we defined in our playbook (`my_var`
    and `my_var2`, respectively):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the context of an Ansible playbook, Jinja allows us to add the `{...}` style
    tags within our playbook (or within a templated file as we just saw), and Ansible
    will tell the Jinja library to translate the tags and generate a new document
    prior to execution. This means we can add common programming constructs either
    directly to our playbooks or to templated files and make our automation significantly
    more intelligent. While this example may not seem all that useful, the Jinja implementation
    overall provides a significant enhancement when coupled with Ansible and YAML.
  prefs: []
  type: TYPE_NORMAL
- en: Consider this implementation for when it is necessary to generate, say, Apache
    configuration files or MySQL queries. We could although arduously generate each
    config manually, *or* we could template the content of these and have Ansible
    iterate. In the coming sections, we will take a deep dive into Jinja programming
    constructs and learn how to leverage Jinja effectively.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 Programming Constructs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 was incorporated into the Ansible architecture back in 2012 when Ansible
    0.5 was released. The implementation of Ansible at the time incorporated the concept
    of Jinja2 filters and supported basic Jinja2 syntax. As ansible evolved, so did
    its developer support for Jinja. By coupling YAML and Jinja2, Ansible was soon
    able to provide a comprehensive scripting-oriented solution for Ansible playbook
    developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the time Ansible 1.0 was released, the Ansible playbook concept (including
    Jinja and YAML) had evolved enough to support a wide array of syntax implementations.
    As a result of the integration of YAML, Jinja and Ansible''s popularity skyrocketed.
    After the release of Ansible 1.0, playbooks could be authored to incorporate the
    following syntaxes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Jinja tag syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Each of these tags serves a unique role within the Jinja universe, and it is
    important to understand each completely (so as not to mix them up). In the coming
    sections, we will learn about these special tags and learn how they can be leveraged
    to enhance our playbook logic. By the time we're done, we should have a solid
    understanding of how to wield Jinja implementations of expressions, control statements,
    and comments.
  prefs: []
  type: TYPE_NORMAL
- en: Expressions, filters, and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jinja filters (also known as **variable expressions**) are very similar in
    nature to programming variables, although with a key difference. Filter expressions
    represent a data value item *or* the computed value of a data point in conjunction
    with another data source. Expressions are evaluated at runtime and can provide
    a level of flexibility for playbook and template developers. The syntax of Jinja2''s
    expression format is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The source data for the `var` section can be from multiple different places.
    Within an Ansible playbook, there are presently four unique methods for sourcing
    variable values and content within the context of Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass a YAML or JSON file with the `--var-file` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create environment variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a top-level defaults section to the playbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Capture the value from `stdout`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we can see from the example syntax we just looked at, Jinja expressions provide
    significant power that can be now wielded by Ansible playbook developers. Let's
    take a look at a more comprehensive playbook example using Ansible and Jinja2
    expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '`playbook.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run the playbook, Ansible''s output looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '**![](img/c0343c61-4d5b-4827-9276-2e83523e3f13.png)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Output (contents of `/etc/motd`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we simply set the content of the MOTD file using a basic variable.
    Simple enough, right? But the real power of Jinja expressions comes when we realize
    we can source the variable data from multiple sources and perform operations on
    the variable inline and in real time.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja string concatenation and manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja provides an excellent solution for manipulating strings and concatenating
    text (joining it with other text). For example, we might want to create a unique
    MOTD file by adding some additional information to the MOTD contents based on
    perhaps the hostname. This could be easily achieved via the following ansible
    playbook and Jinja syntax.
  prefs: []
  type: TYPE_NORMAL
- en: '`playbook.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the example shows how easy it is to concatenate string variables
    using Jinja. While the example we just looked at is useful, the expression implementation
    of Jinja is not limited to simple string concatenation. We can also manipulate
    strings using Jinja. For example, we might use any of the following solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use *regular expressions* within a Jinja variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'To convert Jinja variables to *upper* and *lower* case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In addition to string manipulation, the Jinja implementation is *far* more powerful.
    We can also perform math operations using Jinja. Let's learn how.
  prefs: []
  type: TYPE_NORMAL
- en: Basic arithmetic operations in Jinja
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In addition to basic string concatenation, we can also perform math and computational
    operations in Jinja. For example, we can add numerical values together using the
    following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting output would have been calculated as *1+1 = 2*, thus resulting
    in *2* as the value of the `incremented_var` variable. In conjunction with basic
    addition, we can also perform multiplication, subtraction, division, and more.
    A complete list of the basic math operations available is provided next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: From what we just saw, it is easy to see how Jinja can perform basic math operations.
    But it's not limited to just simple math.
  prefs: []
  type: TYPE_NORMAL
- en: Compound math equations and order of operations in Jinja
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Basic operations such as adding, subtracting, multiplying, and dividing can
    also be combined to create more robust calculated results. This is implemented
    via the `()` ordering of operations solution, which is common across many programming
    languages. It basically states that mathematical operations contained within the
    parentheses will be performed first with precedence of multiplication, division,
    addition, and then subtraction. Once the items inside a given set of parentheses
    are complete, the logic moves outward. An example of this is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Within the context of a Jinja expression, this math operation would look something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Filters available
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jinja2 is not limited to strictly computational operations. It can be leveraged
    for any number of operational tasks. Ansible has kindly also provided a number
    of handy filters, which can be applied to our variable implementations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a table with a set of examples for the more popular operational
    tasks one might need to perform using Jinja filter expressions:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Expression name** | **Example** | **Description of the expression** |'
  prefs: []
  type: TYPE_TB
- en: '| `to_json` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| Converts the variable data into JSON format and renders it. |'
  prefs: []
  type: TYPE_TB
- en: '| `to_yaml` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| Converts the variable data into YAML format and renders it. |'
  prefs: []
  type: TYPE_TB
- en: '| `mandatory` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '| Makes the variable declaration and setting mandatory for the playbook to
    execute properly. |'
  prefs: []
  type: TYPE_TB
- en: '| `default value` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '| Sets a default value for the variable if it is not defined. |'
  prefs: []
  type: TYPE_TB
- en: '| `min&#124;max` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '| Fetches the minimum or maximum value from an array. In this case, the values
    would be `2` or `4`, respectively. |'
  prefs: []
  type: TYPE_TB
- en: '| `random` |'
  prefs: []
  type: TYPE_TB
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '| Fetches a random item from a list, a random number, or seed value, respectively.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Shuffle |'
  prefs: []
  type: TYPE_TB
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '| Generates a new random list from an existing random list. |'
  prefs: []
  type: TYPE_TB
- en: '| Math log |'
  prefs: []
  type: TYPE_TB
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '| Log algorithm math function and log numeric algorithm, respectively. |'
  prefs: []
  type: TYPE_TB
- en: '| Square root |'
  prefs: []
  type: TYPE_TB
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '| Square root math. |'
  prefs: []
  type: TYPE_TB
- en: '| IPV filter |'
  prefs: []
  type: TYPE_TB
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '| Tests whether a string is a specific IPV version. |'
  prefs: []
  type: TYPE_TB
- en: '| Quote filter |'
  prefs: []
  type: TYPE_TB
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '| Wraps the expression evaluated in quotes. |'
  prefs: []
  type: TYPE_TB
- en: '| Concatenate lists |'
  prefs: []
  type: TYPE_TB
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '| Joins list items into a single unified string. |'
  prefs: []
  type: TYPE_TB
- en: '| Basename |'
  prefs: []
  type: TYPE_TB
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '| Linux path basename. Gets `foo.txt` out of `/etc/bar/foo.txt`, for example.
    |'
  prefs: []
  type: TYPE_TB
- en: '| WIN basename |'
  prefs: []
  type: TYPE_TB
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '| Same as basename but for MS Windows. |'
  prefs: []
  type: TYPE_TB
- en: Now that we have a good understanding of how Ansible and Jinja leverage filters,
    let's move on to control structures.
  prefs: []
  type: TYPE_NORMAL
- en: For a complete list of available filters and expressions, consult the official
    Ansible 2.0 documentation provided at [http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data](http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data).
  prefs: []
  type: TYPE_NORMAL
- en: Conditional logic (if-then-else)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control structures within any programming language provide a way of defining
    paths for an executing program to flow through based on a condition. In addition
    to conditional logic, control structures also provide us with a way of repeating
    like tasks without duplicating code. This is commonly known as **conditional logic
    and looping**, respectively. Jinja provides us with a set of operators that allow
    us to loop or conditionally execute code. In this section, we will discuss conditional
    logic specifically and learn how to leverage it within the context of Jinja.
  prefs: []
  type: TYPE_NORMAL
- en: 'A conditional statement provides the developer with a way of conditionalizing
    a sequence of events based on the evaluation of an expression. In most languages,
    this is accomplished through an `if...then`-styled solution. Take for example
    the following flowchart that illustrates the basic principles of conditional logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a6397c9-aeee-4272-84c7-dedb89bc4824.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Conditional logic in code form might look something like the following (Python
    code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This Python code presents a simplistic example of conditional logic. It simply
    says that if `x` is equal to `0`, then execute the `print` statement telling the
    user so. Within Jinja, we can implement a very similar set of logical operators.
    The only real difference in context is that within Jinja, all control structures
    and conditionalizations are wrapped within `{% %}` tags. Let''s look at the same
    implementation using Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the Jinja implementation also gives us the optional `else-if`
    statement. This provides us with additional capabilities when it comes to implementing
    conditional logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ansible, Jinja''s conditional logic can be used in many different ways.
    It can be used to wrap entire tasks with a conditional statement (only execute
    these tasks if a variable is set). This provides a huge amount of flexibility
    and power to playbook developers. Let''s look at a real-world example of implementing
    conditional logic within an Ansible playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When we run this playbook, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e3b7ebe-88a8-40be-80c3-0aad9a1d33aa.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Based on the conditional statements we defined within our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can flip the `hello` variable to false and get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c483724d-fb56-4ad0-bd37-b7e8faa379c4.png)'
  prefs: []
  type: TYPE_IMG
- en: It is important to note that Jinja syntax leveraged within an Ansible playbook
    will need to be inside of quotes and continue to adhere to YAML dictionary formatting
    standards. Jinja conditional syntax outside of the playbook (inside a Jinja template
    file) doesn't need to adhere to YAML standards.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional logic can be compounded to provide significantly more flexibility
    and power within Ansible playbooks. In the example we saw, the `{% ... %}` tags
    were placed within the vars section, but they don't necessarily need to be there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Aside from placing conditionals within an Ansible playbook directly, we can
    leverage Jinja conditional logic within a Jinja template file. This is where Jinja''s
    true power can be felt. Let''s look at an example of a Jinja template file implemented
    with conditional logic:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible playbook:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '`httpdconf.j2`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: On running this example, Anisble will translate the Jinja template, transfer
    it over to the remote host, and place it in the `/etc/httpd/httpd.conf` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Loops and iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'No programming language would be complete without the capability of reducing
    the amount of code implemented by iterating over repetitive tasks, and Jinja is
    no exception. Jinja offers multiple loop types within its syntax arsenal. Loops
    can come in many forms within a modern traditional programming language. For example,
    most modern programming languages support most of the following loop types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`For` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Foreach` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`While` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Do...Until` loops'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In addition to these loop options, some programming languages support other
    OOP-oriented loop types. Within Ansible's implementation of Jinja, there is currently
    only support for the for loop. While the implementation of the types of loops
    is limited, there is the ability to perform counter-based iterations, list iterations,
    and compound loop conditionals. In this section, we will discuss loops within
    Jinja and learn how to implement them within our playbooks and our Jinja templates.
  prefs: []
  type: TYPE_NORMAL
- en: Simple counters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Counter loops involve the repetitive increment or decrement of a variable until
    a condition is met. Counter loops can be really useful for code that would only
    need a minor integer change as part of its iteration loop sequence. To better
    understand the concept of a counter loop, let''s look at a flowchart illustration
    of a common programming loop that increments a counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b79ab38b-622d-4080-ab92-98d21ffc7179.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In this illustration, we basically repeat the increment task until the variable
    `X` is equal to the number `10`. Once the evaluation of `X` is equal to `10`,
    the iterator stops. The illustrated example of our loop could be represented in
    basic Python programming via the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Loops don't always need to perform mathematical operations. They can also execute
    automation, iterate over a list, or do pretty much anything your imagination can
    dream up. This example of a loop simply increments a counter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have understood the basic concept of a loop, let''s look at how
    we might implement the same type of loop within the context of Jinja and Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Simple enough implementation, right? The next obvious question is *how would
    we go about implementing this same type of logic within a Jinja template file*?
    I''m glad you asked! Let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Simple enough also, right? Beyond counting values within a loop, we can also
    iterate other data items.
  prefs: []
  type: TYPE_NORMAL
- en: List iterators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'List iterators in programming solutions offer the ability to take a list of
    items and perform a sequence of operations on them. For example, we might have
    a list of fruit, `[apples, oranges, grapes, pears]`, and want to iterate over
    this list. In traditional programming languages, we could use a `foreach` loop.
    The basic flow of a `foreach` loop might look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0eaa273-a47d-4c51-926b-50b0c4fbc0ab.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This example simply iterates through each item in the list and executes a code
    block based on the new list item presented. This type of implementation of looping
    is very basic within most programming languages, and Jinja is no exception. Based
    on this flow, we can look at a Python example and map this to the following code
    fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In Jinja, the implementation of the list iterator has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s look at the translation of this loop sequence into Jinja:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Hosts file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Playbook:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Jinja template:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Thise example will autopopulate a file titled `configfile.conf` and upload it
    to the target hosts with the contents transformed using the Jinja `for` iterator.
  prefs: []
  type: TYPE_NORMAL
- en: Complex iterators using Jinja
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The iterators that we discussed earlier in this chapter are very simple in
    nature. Jinja also provides a more complex way of operating loops within Jinja.
    Complex (or compound) iterators are common practice within programming and are
    what make modern algorithms possible. A complex iterator may take many forms,
    but often includes adding additional compound conditionals or nested loops within
    the loop sequence. Let''s look at a flowchart illustrating a complex iterator
    (nested loop):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c96816bd-c34c-48ea-90b1-798d11a3db48.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Does this flowchart looks pretty complex? It doesn''t need to be. Let''s look
    at the same algorithm in Python:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'In Jinja, implementing nested for loops can be done in much the same way. Let''s
    look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The Jinja template would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, the implementation of this Jinja loop is also pretty simple.
    Let''s take a look at how to make a slightly more complex loop that uses both
    iterators and conditionals. Following are the code fragments for variables in
    loops from a `vars` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Now run it and check the output. Nice right?
  prefs: []
  type: TYPE_NORMAL
- en: Applying Jinja in Ansible Playbook's
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Jinja can be applied to playbooks in a few specific ways. The most common implementation
    of Jinja is the use of filters and variables within playbook YAML files. This
    information must be placed within the quoted context of YAML key/value structures.
    The key/value structure of YAML *does* normally support non-quoted values, but
    within the context of Jinja, we *must* have it within quotes. For example, let''s
    consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see from this playbook, the implementation of Jinja within the playbook
    has the `{{...}}` tags directly within quotes. The *only* location that supports
    non-quoted implementations of Jinja tags is within a Jinja template. Jinja templates
    are parsed differently from YAML and therefore support loose implementations of
    Jinja tags. Let''s consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how Jinja specifically and uniquely fits within
    the Ansible world. We learned how Jinja filters work and discovered how these
    filters can be leveraged within a playbook to provide us with clever playbook
    implementations. In addition to Jinja filters, we spent time learning how to perform
    mathematical operations on variables within a Jinja filter context.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the concept of Jinja filters, we also learned about loops and
    iterators. These iterators provided us with good insights into iterating over
    structured data, counting forward and in reverse. We learned also that iterators
    can be used for iterating through lists (such as the list of fruits that we iterated
    over in our example). Finally, we learned how to apply Jinja within our playbooks
    and the specific requirements that surround leveraging Jinja.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover the Ansible vault. The Ansible vault represents
    a unique and secure solution for encrypting, storing, and decrypting data with
    Ansible. This solution is *highly* useful as it can be used to store password
    data, usernames, secure database queries, and so much more. Oftentimes within
    an organization, sensitive user data is needed to configure and deploy software.
    This sensitive data is often usernames and passwords. Ansible provides an out-of-the-box
    solution to help encrypt and hide sensitive information. The next chapter will
    be on the Ansible vault. The next chapter of the book will outline the Ansible
    way of managing, storing, and deploying sensitive information. We will cover how
    to best leverage the Ansible vault utility to ensure that sensitive data is kept
    safe and secret. We will learn (by example) how to best control and manage highly
    secure information and learn the underpinnings of how Ansible keeps your information
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: Let's proceed to learning about the Ansible vault.
  prefs: []
  type: TYPE_NORMAL
