<html><head></head><body><div><div><p id="_idParaDest-169" class="chapter-number"><a id="_idTextAnchor261"/><em class="italic">Chapter 9</em></p>
			<h1 id="_idParaDest-170"><a id="_idTextAnchor262"/>Portainer – A GUI for Docker</h1>
			<p>In this chapter, we will take a look at Portainer. Portainer is a tool that allows you to manage Docker resources from a web interface. </p>
			<p>As Portainer itself is distributed in containers, it is simple to install and you can run it anywhere you can launch a container, making it the perfect interface for those who would prefer to not manage their containers using the command line as we have been doing in the previous chapters.</p>
			<p>In this chapter, we will be covering the following topics:</p>
			<ul>
				<li>The road to Portainer</li>
				<li>Getting Portainer up and running</li>
				<li>Using Portainer</li>
				<li>Portainer and Docker Swarm</li>
			</ul>
			<h1 id="_idParaDest-171"><a id="_idTextAnchor263"/>Technical requirements</h1>
			<p>As in previous chapters, we will continue to use our local Docker installations. Also, the screenshots in this chapter will be from my preferred operating system, macOS. Toward the end of the chapter, we will use Multipass to launch a local Docker Swarm cluster.</p>
			<p>As before, the Docker commands we will be running will work on all three of the operating systems we have installed Docker on so far, however, some of the supporting commands, which will be few and far between, may only apply to macOS and Linux-based operating systems.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3jR2HBa">https://bit.ly/3jR2HBa</a></p>
			<h1 id="_idParaDest-172"><a id="_idTextAnchor264"/>The road to Portainer</h1>
			<p>Before we roll up our sleeves and dive into installing and using Portainer, we should discuss the <a id="_idIndexMarker645"/>background of the project. The first edition of this book covered <em class="italic">Docker UI.</em> <em class="italic">Docker UI</em> was written by <em class="italic">Michael Crosby</em>, who handed the project over to <em class="italic">Kevan Ahlquist</em> after about a year of development. It was at this stage, due to trademark concerns, that the project was renamed UI for Docker.</p>
			<p>The development of UI for Docker continued up until the point Docker started to accelerate the introduction of features such as Swarm mode into the core Docker Engine. It was around this time that the UI for Docker project was forked into the project that would become Portainer, which had its first major release in June 2016. Since their first public release, the team behind Portainer estimate the majority of the code has already been updated or rewritten, and by mid-2017, new features were added, such as role-based controls and Docker Compose support.</p>
			<p>In December 2016, a notice was committed to the UI for Docker GitHub repository stating that the project was deprecated and that Portainer should be used. Since its release, it has been downloaded over 1.3 billion times.</p>
			<p>Now we know a little about the background of Portainer, let's look at the steps needed to get it launched and configured.</p>
			<h1 id="_idParaDest-173"><a id="_idTextAnchor265"/>Getting Portainer up and running</h1>
			<p>We are first going<a id="_idIndexMarker646"/> to be looking at using Portainer to manage a single Docker<a id="_idIndexMarker647"/> instance running locally. I am running Docker for Mac so I will be using that, but these instructions should also work with other Docker installations.</p>
			<p>First of all, to grab the container image from Docker Hub, we just need to run the following commands:</p>
			<pre>$ docker image pull portainer/portainer
$ docker image ls</pre>
			<p>As you may see from the output if you are following along when we run the <code>docker image ls</code> command, the Portainer image is only 78.6 MB. To launch Portainer, you simply have to run the following command if you are running macOS or Linux:</p>
			<pre>$ docker volume create portainer_data
$ docker container run -d \
      -p 9000:9000 \
      -v /var/run/docker.sock:/var/run/docker.sock \
      portainer/portainer</pre>
			<p>Windows<a id="_idIndexMarker648"/> users <a id="_idIndexMarker649"/>will have to run the following:</p>
			<pre>$ docker container run -d -p 9000:9000 -v \\.\pipe\docker_engine:\\.\pipe\docker_engine portainer/portainer</pre>
			<p>As you can see from the command we have just run, we are mounting the socket file for Docker Engine on our Docker host machine. Doing this will allow Portainer full, unrestricted access to Docker Engine on our host machine. It needs this so it can manage Docker on the host; however, it does mean that your Portainer container has full access to your host machine, so be careful in how you give access to it and also when publicly exposing Portainer on remote hosts.</p>
			<p>The following screenshot shows this being executed on macOS:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.01_B15659.jpg" alt="Figure 9.1 – Downloading and launching the Portainer container&#13;&#10;" width="1650" height="888"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1 – Downloading and launching the Portainer container</p>
			<p>For the most <a id="_idIndexMarker650"/>basic type of installation, that is all we need to run. There are a <a id="_idIndexMarker651"/>few more steps to complete the installation; they are all performed in the browser. To complete them, go to <a href="http://localhost:9000/">http://localhost:9000/</a>. The first screen you will be greeted by asks you to set a password for the admin user.</p>
			<p>Once you have set the password, you will be taken to a login page: enter the username admin and the password you just configured. Once logged in, you will be asked about the Docker instance you wish to manage. </p>
			<p>There are four options:</p>
			<ul>
				<li>Manage the Docker instance where Portainer is running</li>
				<li>Manage a remote Docker instance</li>
				<li>Connect to a Portainer Agent</li>
				<li>Connect to <a id="_idIndexMarker652"/>Microsoft <strong class="bold">Azure Container Instances</strong> (<strong class="bold">ACI</strong>)</li>
			</ul>
			<p>For the moment, we want to manage the instance where Portainer is running, which is the <strong class="bold">Local</strong> option, rather than the default <strong class="bold">Remote</strong> one: </p>
			<div><div><img src="img/Figure_9.02_B15659.jpg" alt="Figure 9.2 – Choosing which environment you want to manage with Portainer&#13;&#10;" width="1647" height="909"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2 – Choosing which environment you want to manage with Portainer</p>
			<p>As we have already<a id="_idIndexMarker653"/> taken mounting the Docker socket file into account<a id="_idIndexMarker654"/> when launching our Portainer container, we can click on <strong class="bold">Connect</strong> to complete our installation. This will take us straight into Portainer itself, showing us the dashboard. With Portainer launched and configured, we can now look at some of the features.</p>
			<h1 id="_idParaDest-174"><a id="_idTextAnchor266"/>Using Portainer</h1>
			<p>Now that we have <a id="_idIndexMarker655"/>Portainer running and configured to communicate with our Docker installation, we can start to work through the features listed in the left-hand side menu, starting at the top with the Dashboard, which is also the default landing page of your Portainer installation, as you can see from the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.03_B15659.jpg" alt="Figure 9.3 – Viewing the default page&#13;&#10;" width="1650" height="806"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3 – Viewing the default page</p>
			<p>You are first taken to the list of endpoints. As we only have our local installation, click on that and then we can start exploring.</p>
			<h2 id="_idParaDest-175"><a id="_idTextAnchor267"/>The dashboard</h2>
			<p>As you can see from the<a id="_idIndexMarker656"/> following screenshot, the dashboard gives us an overview of the current state of the Docker instance that Portainer is configured to communicate with:</p>
			<div><div><img src="img/Figure_9.04_B15659.jpg" alt="Figure 9.4 – Getting an overview&#13;&#10;" width="1638" height="1088"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4 – Getting an overview</p>
			<p>In my case, this shows how many containers I have running, which at the moment is just the already running Portainer container, as well as the number of images I have downloaded. We <a id="_idIndexMarker657"/>can also see the number of <strong class="bold">Volumes</strong> and <strong class="bold">Networks</strong> available on the Docker instance. It will also show the number of running <strong class="bold">Stacks</strong>:</p>
			<p>It also shows basic information on the Docker instance itself; as you can see, the Docker instance is running Moby Linux, and has 6 CPUs and 2.1 GB of RAM. This is the default configuration for Docker for Mac.</p>
			<p>The dashboard will adapt to the environment you have Portainer running in, so we will revisit it when we look at attaching Portainer to a Docker Swarm cluster.</p>
			<h2 id="_idParaDest-176"><a id="_idTextAnchor268"/>Application templates</h2>
			<p>Next up in the<a id="_idIndexMarker658"/> left-hand menu, we have <strong class="bold">App Templates</strong>. This section is probably the only feature not to be a direct feature available in the core Docker Engine; it is instead a way of launching common applications using containers downloaded from Docker Hub:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.05_B15659.jpg" alt="Figure 9.5 – Exploring the templates&#13;&#10;" width="1633" height="1478"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5 – Exploring the templates</p>
			<p>There are around 25 templates<a id="_idIndexMarker659"/> that ship with Portainer by default. The templates are defined in JSON format. For example, the NGINX template looks like the following:</p>
			<pre>{
  'type': 'container',
  'title': 'Nginx',
  'description': 'High performance web server',
  'categories': ['webserver'],
  'platform': 'linux',
  'logo': 'https://portainer.io/images/logos/nginx.png',
  'image': 'nginx:latest',
  'ports': [
    '80/tcp',
    '443/tcp'
  ],
  'volumes': ['/etc/nginx', '/usr/share/nginx/html']
}</pre>
			<p>There are more <a id="_idIndexMarker660"/>options you can add, for example, the MariaDB template:</p>
			<pre>{
  'type': 'container',
  'title': 'MariaDB',
  'description': 'Performance beyond MySQL',
  'categories': ['database'],
  'platform': 'linux',
  'logo': 'https://portainer.io/images/logos/mariadb.png',
  'image': 'mariadb:latest',
  'env': [
    {
      'name': 'MYSQL_ROOT_PASSWORD',
      'label': 'Root password'
    } ],
  'ports': ['3306/tcp' ],
  'volumes': ['/var/lib/mysql']
}</pre>
			<p>As you can see, the templates look similar to a Docker Compose file; however, this format is only used by Portainer. For the most part, the options are pretty self-explanatory, but we should touch upon the <strong class="bold">Name</strong> and <strong class="bold">Label</strong> options.</p>
			<p>For containers <a id="_idIndexMarker661"/>that typically require options defined by passing custom values via environment variables, the <strong class="bold">Name</strong> and <strong class="bold">Label</strong> options allow you to present the user with custom form fields that need to be completed before the container is launched, as demonstrated by the following screenshot:</p>
			<div><div><img src="img/Figure_9.06_B15659.jpg" alt="Figure 9.6 – Launching MariaDB using the template&#13;&#10;" width="1614" height="913"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6 – Launching MariaDB using the template</p>
			<p>As you can see, we have a field where we can enter the root password we would like to use for our MariaDB container. Filling this in will take that value and pass it as an environment variable, building the following command to launch the container:</p>
			<pre>$ docker container run --name [Name of Container] -p 3306 -e MYSQL_ROOT_PASSWORD=[Root password] -d mariadb:latest</pre>
			<p>For more<a id="_idIndexMarker662"/> information on app templates, I recommend reviewing the documentation – a link to this can be found in the <em class="italic">Further reading</em> section of this chapter.</p>
			<h2 id="_idParaDest-177"><a id="_idTextAnchor269"/>Containers</h2>
			<p>The next thing we are <a id="_idIndexMarker663"/>going to look at in the left-hand menu is <strong class="bold">Containers</strong>. This is where you launch and interact with the containers running on your Docker instance. Clicking on the <strong class="bold">Containers</strong> menu entry will bring up a list of all of the containers, both running and stopped, on your Docker instance:</p>
			<div><div><img src="img/Figure_9.07_B15659.jpg" alt="Figure 9.7 – Listing the containers&#13;&#10;" width="1646" height="562"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.7 – Listing the containers</p>
			<p>As you can see, I currently have only a single container running, and that just happens to be the Portainer one. Rather than interacting with that, let's click the <strong class="bold">+ Add container</strong> button to launch a container running the cluster application we used in previous chapters.</p>
			<p>There are several options on the <strong class="bold">Create container</strong> page; these should be filled in as follows:</p>
			<ul>
				<li><code>cluster</code></li>
				<li><code>russmckendrick/cluster</code></li>
				<li><strong class="bold">Always pull the image</strong>: On</li>
				<li><strong class="bold">Publish all exposed network ports to random host ports</strong>: On</li>
			</ul>
			<p>Finally, add a port mapping from port 8080 on the host to port 80 on the container by clicking on <strong class="bold">+ publish a new network port</strong>. Your completed form should look something like the<a id="_idIndexMarker664"/> following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.08_B15659.jpg" alt="Figure 9.8 – Launching a container&#13;&#10;" width="1643" height="1006"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8 – Launching a container</p>
			<p>Once that's done, click on <strong class="bold">Deploy the container</strong>, and after a few seconds, the list of running containers will be returned, where you should see your newly launched container:</p>
			<div><div><img src="img/Figure_9.09_B15659.jpg" alt="Figure 9.9 – Listing the containers&#13;&#10;" width="1656" height="510"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9 – Listing the containers</p>
			<p>Using the tick box on the left of each container in the list will enable the buttons at the top, where you can <a id="_idIndexMarker665"/>control the status of your containers. Make sure not to <strong class="bold">Kill</strong> or <strong class="bold">Remove</strong> the Portainer container. Clicking on the name of the container in our case cluster will bring up more information on the container itself:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.10_B15659.jpg" alt="Figure 9.10 – Drilling down into our container&#13;&#10;" width="1624" height="954"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10 – Drilling down into our container</p>
			<p>As you can see, the information about the container is the same information you would get if you were to run this command:</p>
			<pre>$ docker container inspect cluster</pre>
			<p>You can see the full output of this command by clicking on <strong class="bold">Inspect</strong>. You will also notice that there<a id="_idIndexMarker666"/> are buttons for <strong class="bold">Stats</strong>, <strong class="bold">Logs</strong>, <strong class="bold">Console</strong>, and <strong class="bold">Attach</strong>, which we will be discussing next.</p>
			<h3>Stats</h3>
			<p>The <strong class="bold">Stats</strong> page shows <a id="_idIndexMarker667"/>the CPU, memory, and network utilization, as well as a list of the processes for the container you are inspecting:</p>
			<div><div><img src="img/Figure_9.11_B15659.jpg" alt="Figure 9.11 – Viewing the container stats&#13;&#10;" width="1644" height="1047"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11 – Viewing the container stats</p>
			<p>The graphs will automatically refresh if you leave the page open, and refreshing the page will zero the graphs and start afresh. This is because Portainer is receiving this information from the Docker API using the following command:</p>
			<pre>$ docker container stats cluster</pre>
			<p>Each time the page is refreshed, the command is started from scratch as Portainer currently does not <a id="_idIndexMarker668"/>poll Docker in the background to keep a record of statistics for each of the running containers.</p>
			<h3>Logs</h3>
			<p>Next up, we have <a id="_idIndexMarker669"/>the <strong class="bold">Logs</strong> page. This shows you the results of running the following command:</p>
			<pre>$ docker container logs cluster</pre>
			<p>It displays both the STDOUT and STDERR logs:</p>
			<div><div><img src="img/Figure_9.12_B15659.jpg" alt="Figure 9.12 – Viewing the container logs&#13;&#10;" width="1623" height="594"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12 – Viewing the container logs</p>
			<p>You also have the option of adding timestamps to the output; this is the equivalent of running the following:</p>
			<pre>$ docker container logs --timestamps cluster</pre>
			<p>As we have previously discussed, remember that the timestamps may be different depending on<a id="_idIndexMarker670"/> your host machine's time zone settings.</p>
			<h3>Console and Attach</h3>
			<p>Next up, we <a id="_idIndexMarker671"/>have <code>/bin/bash , bin/sh, or /bin/ash</code>, and also which user to connect as – root is the default. While the cluster image has both shells installed, I choose to use <code>/bin/bash</code>:</p>
			<div><div><img src="img/Figure_9.13_B15659.jpg" alt="Figure 9.13 – Opening a session to the container&#13;&#10;" width="1632" height="1000"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13 – Opening a session to the container</p>
			<p>This is the equivalent of running the following command to gain access to your container:</p>
			<pre>$ docker container exec -it cluster /bin/sh</pre>
			<p>As you can see from the screenshot, the bash process has a PID of 15. This process was created by the <code>docker container exec</code> command, and that will be the only process that is terminated once you disconnect from your shell session.</p>
			<p>If we had launched our container with the <code>TTY</code> flag, we could have also used the <code>TTY</code> of the container rather than <a id="_idIndexMarker674"/>spawning a shell to attach to, as we did when using <strong class="bold">Console</strong>, like the like when attaching on the command line your process will stop when disconnect.</p>
			<p>Images</p>
			<p>Next up in the left-hand<a id="_idIndexMarker675"/> menu is <strong class="bold">Images</strong>. From here, you can manage, download, and upload images:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.14_B15659.jpg" alt="Figure 9.14 – Managing your images&#13;&#10;" width="1628" height="1146"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14 – Managing your images</p>
			<p>At the top of the page, you have the option of pulling an image. For example, simply entering <code>amazonlinux</code> into the box and then clicking on <strong class="bold">Pull the image</strong> will download a copy of the Amazon Linux container image from Docker Hub. The command executed by Portainer would be this:</p>
			<pre>$ docker image pull amazonlinux:latest</pre>
			<p>You can find more information about each image by clicking on the image ID; this will take you to a <a id="_idIndexMarker676"/>page that nicely renders the output of running this command:</p>
			<pre>$ docker image inspect russmckendrick/cluster</pre>
			<p>Look at the following screenshot:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.15_B15659.jpg" alt="Figure 9.15 – Getting more information on your image&#13;&#10;" width="1623" height="1461"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15 – Getting more information on your image</p>
			<p>Not only do you get <a id="_idIndexMarker677"/>all of the information about the image, but you also get options to push a copy of the image to your chosen registry or, by default, Docker Hub. You also get a complete breakdown of each of the layers contained within the image, showing the command that was executed during the build and the size of each layer.</p>
			<p>The next two items in the menu allow you to manage networks and volumes; I am not going to go into<a id="_idIndexMarker678"/> too much detail here as there is not much to them.</p>
			<h3>Networks</h3>
			<p>Here, you can quickly<a id="_idIndexMarker679"/> add a network using the default bridge driver. Clicking on <strong class="bold">Advanced settings</strong> will take you to a page with more options. These include using other drivers, defining the subnets, adding labels, and restricting external access to the network. As with other sections, you can also remove networks and inspect existing networks.</p>
			<h3>Volumes</h3>
			<p>There are not many <a id="_idIndexMarker680"/>options here other than adding or removing a volume. When adding a volume, you get a choice of drivers as well as being able to fill in options to pass to the driver, which allows the use of third-party driver plugins. Other than that, there is not much to see here, not even an inspect option.</p>
			<h3>Events</h3>
			<p>The events page <a id="_idIndexMarker681"/>shows you all of the events from the last 24 hours; you also have an option of filtering the results, meaning you can quickly find the information you are after:</p>
			<div><div><img src="img/Figure_9.16_B15659.jpg" alt="Figure 9.16 – Viewing Docker events&#13;&#10;" width="1340" height="736"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16 – Viewing Docker events</p>
			<p>This is the<a id="_idIndexMarker682"/> equivalent of running the following command:</p>
			<pre>$ docker events --since '2020-04-17T16:30:00' --until '2020-04-
17T16:30:00'</pre>
			<p>This leaves us with one more option to cover.</p>
			<h3>Host</h3>
			<p>The final entry<a id="_idIndexMarker683"/> simply shows you the output of the following:</p>
			<pre>$ docker info</pre>
			<p>The following shows the output of the command:</p>
			<div><div><img src="img/Figure_9.17_B15659.jpg" alt="Figure 9.17 – Viewing information on the Docker host&#13;&#10;" width="1349" height="1243"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17 – Viewing information on the Docker host</p>
			<p>This can be useful<a id="_idIndexMarker684"/> if you are targeting multiple Docker instance endpoints and need information on the environment the endpoint is running on.</p>
			<p>At this point, we are moving on to looking at Portainer running on Docker Swarm, so now would be a good time to remove the running containers and also the volume that was created when we<a id="_idIndexMarker685"/> first launched Portainer. You can remove the volume using the following:</p>
			<pre>$ docker volume prune</pre>
			<p>Now we have cleaned up, let's look at launching a Docker Swarm cluster.</p>
			<h1 id="_idParaDest-178"><a id="_idTextAnchor270"/>Portainer and Docker Swarm</h1>
			<p>In the previous <a id="_idIndexMarker686"/>section, we looked at how to use Portainer on a standalone Docker<a id="_idIndexMarker687"/> instance. Portainer also supports Docker Swarm clusters, and the options in the interface adapt to the clustered environment. We should look at spinning up a Swarm and then launching Portainer as a service and see what changes.</p>
			<p>So let's start by launching a new Docker Swarm cluster.</p>
			<h2 id="_idParaDest-179"><a id="_idTextAnchor271"/>Creating the Swarm</h2>
			<p>As in the Docker <a id="_idIndexMarker688"/>Swarm chapter, we are going to be creating the Swarm locally using Multipass; to do this, run the following commands to launch the three nodes:</p>
			<pre>$ multipass launch -n node1
$ multipass launch -n node2
$ multipass launch -n node3</pre>
			<p>Now install Docker:</p>
			<pre>$ multipass exec node1 -- \
	/bin/bash -c 'curl -s https://get.docker.com | sh - &amp;&amp; sudo 
usermod -aG docker ubuntu'
$ multipass exec node2 -- \
	/bin/bash -c 'curl -s https://get.docker.com | sh - &amp;&amp; sudo 
usermod -aG docker ubuntu'
$ multipass exec node3 -- \
	/bin/bash -c 'curl -s https://get.docker.com | sh - &amp;&amp; sudo
usermod -aG docker ubuntu'</pre>
			<p>Once Docker is<a id="_idIndexMarker689"/> installed, initialize and create the cluster:<code>P=$(multipass info node1 | grep IPv4 | a</code></p>
			<pre>$ multipass exec node1 -- \
	/bin/bash -c 'docker swarm init --advertise-addr $IP:2377 
--listen-addr $IP:2377'
$ SWARM_TOKEN=$(multipass exec node1 -- /bin/bash -c 'docker 
swarm join-token --quiet worker')
$ multipass exec node2 -- \
	/bin/bash -c 'docker swarm join --token $SWARM_TOKEN 
$IP:2377'
$ multipass exec node3 -- \
	/bin/bash -c 'docker swarm join --token $SWARM_TOKEN 
$IP:2377'</pre>
			<p>Make a note of the IP address of <code>node1</code> by running the following command:</p>
			<pre>$ multipass list </pre>
			<p>Finally, log in to the Swarm manager node:</p>
			<pre>$ multipass shell node1</pre>
			<p>You should now <a id="_idIndexMarker690"/>be logged into the primary Swarm node and ready to progress.</p>
			<h2 id="_idParaDest-180"><a id="_idTextAnchor272"/>The Portainer service</h2>
			<p>Now that we have a <a id="_idIndexMarker691"/>Docker Swarm cluster, we can launch a Portainer stack by simply running the following:</p>
			<pre>$ curl -L https://downloads.portainer.io/portainer-agent-stack.yml -o portainer-agent-stack.yml
$ docker stack deploy --compose-file=portainer-agent-stack.yml portainer</pre>
			<p>This should give you something that looks like the following output:</p>
			<div><div><img src="img/Figure_9.18_B15659.jpg" alt="Figure 9.18 – Launching the Portainer Stack on our Docker Swarm cluster&#13;&#10;" width="1650" height="405"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18 – Launching the Portainer Stack on our Docker Swarm cluster</p>
			<p>Once the stack has been created, you should be able to go to the IP address of <code>node1</code> with <code>:9000</code> at the end in your browser; for example, I opened <a href="http://192.168.64.9:9000">http://192.168.64.9:9000</a>.</p>
			<h2 id="_idParaDest-181"><a id="_idTextAnchor273"/>Swarm differences</h2>
			<p>As already <a id="_idIndexMarker692"/>mentioned, there are a few changes to <a id="_idIndexMarker693"/>the Portainer interface when it is connected to a Docker Swarm cluster. In this section, we will cover them. If a part of the interface is not mentioned, then there is no difference between running Portainer in single-host <a id="_idIndexMarker694"/>mode or Docker Swarm mode. The first change <a id="_idIndexMarker695"/>we are going to look at is what changes when you first log in to the newly launched Portainer.</p>
			<h3>Endpoints</h3>
			<p>The first thing you<a id="_idIndexMarker696"/> will have to do when you log in is to select an endpoint. As you can see from the following screen, there is a single one called <strong class="bold">primary</strong>:</p>
			<div><div><img src="img/Figure_9.19_B15659.jpg" alt="Figure 9.19 – Viewing the endpoint&#13;&#10;" width="1645" height="634"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19 – Viewing the endpoint</p>
			<p>Clicking on the endpoint will take you to the dashboard. We will look at endpoints again at the end of the section.</p>
			<h3>The dashboard and Swarm</h3>
			<p>One of the first<a id="_idIndexMarker697"/> changes you will notice is that the dashboard now displays some information on the Swarm cluster. As you can see in the following screen, there is a <strong class="bold">Cluster information</strong> section at the top: </p>
			<div><div><img src="img/Figure_9.20_B15659.jpg" alt="Figure 9.20 – Getting a cluster overview&#13;&#10;" width="1614" height="1096"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20 – Getting a cluster overview</p>
			<p>Clicking<a id="_idIndexMarker698"/> on <strong class="bold">Go to cluster vizualizer</strong> will take you to the Swarm page. This gives you a visual overview of the cluster, where the only running containers are currently the ones needed to provide and support the Portainer service:</p>
			<div><div><img src="img/Figure_9.21_B15659.jpg" alt="Figure 9.21 – Visualizing the cluster&#13;&#10;" width="1624" height="878"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21 – Visualizing the cluster</p>
			<h3>Stacks</h3>
			<p>The one item we <a id="_idIndexMarker699"/>haven't covered in the left-hand menu is <strong class="bold">Stacks</strong>. From here, you can launch stacks as we did when we looked at Docker Swarm. In fact, let's take the Docker Compose file we used, which looks like the following:</p>
			<pre>version: '3'
services:
  redis:
    image: redis:alpine
    volumes:
      - redis_data:/data
    restart: always
  mobycounter:
    depends_on:
      - redis
    image: russmckendrick/moby-counter
    ports:
      - '8080:80'
    restart: always
volumes:
  redis_data:</pre>
			<p>Click on the <code>MobyCounter</code>. Do not add any spaces or special characters to the name as this is used by Docker for. Then click on <strong class="bold">Deploy the stack</strong>.</p>
			<p>Once deployed, you will be able to click on <strong class="bold">MobyCounter</strong> and manage the stack:</p>
			<div><div><img src="img/Figure_9.22_B15659.jpg" alt="Figure 9.22 – Launching a stack&#13;&#10;" width="1645" height="988"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.22 – Launching a stack</p>
			<p>Stacks are a collection of services. Let's take a look at them next.</p>
			<h3>Services</h3>
			<p>This page is where<a id="_idIndexMarker701"/> you can create and manage services; it should already be showing several services, including Portainer. So that we don't cause any problems with the running Portainer container, we are going to create a new service. To do this, click on the <strong class="bold">+ Add Service</strong> button. On the page that loads, enter the following:</p>
			<ul>
				<li><code>cluster</code></li>
				<li><code>russmckendrick/cluster</code></li>
				<li><code>Replicated</code></li>
				<li><code>1</code></li>
			</ul>
			<p>This time, we need to add a port mapping for port <code>7000</code> on the host to map to port <code>80</code> to the container, this is because some of the common ports we have been using previously are already taken on the hosts due to the services and stacks we have already launched:</p>
			<div><div><img src="img/Figure_9.23_B15659.jpg" alt="Figure 9.23 – Launching a service&#13;&#10;" width="1627" height="1054"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.23 – Launching a service</p>
			<p>Once you have<a id="_idIndexMarker702"/> entered the information, click on the <strong class="bold">Create the service</strong> button. You will be taken back to the list of services, which should now contain the cluster service we just added. You may have noticed that in the <strong class="bold">Scheduling mode</strong> section, there is an option to scale. Click on it and increase the number of replicas to <strong class="bold">6</strong> for our <strong class="bold">cluster</strong> service.</p>
			<p>Clicking on <strong class="bold">cluster</strong> in the <strong class="bold">Name</strong> section takes us to an overview of the service. As you can see, there is a lot of information on the service:</p>
			<div><div><img src="img/Figure_9.24_B15659.jpg" alt="Figure 9.24 – Viewing details on the service&#13;&#10;" width="1635" height="872"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.24 – Viewing details on the service</p>
			<p>You can make a lot<a id="_idIndexMarker703"/> of changes to the service on the fly, including placement constraints, the restart policy, adding service labels, and more. Right at the bottom of the page is a list of the tasks associated with the service:</p>
			<div><div><img src="img/Figure_9.25_B15659.jpg" alt="Figure 9.25 – Viewing the tasks&#13;&#10;" width="1650" height="792"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.25 – Viewing the tasks</p>
			<p>As you can see, we <a id="_idIndexMarker704"/>have six running tasks, two on each of our three nodes. Clicking on <strong class="bold">Containers</strong> in the left-hand menu may show something different than you expect:</p>
			<div><div><img src="img/Figure_9.26_B15659.jpg" alt="Figure 9.26 – Listing all of the containers&#13;&#10;" width="1630" height="893"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.26 – Listing all of the containers</p>
			<p>You can see all of the containers that are running within the cluster, rather than just the ones on the <a id="_idIndexMarker705"/>node where we deployed Portainer. You may recall that when we looked at the cluster visualizer, there were Portainer Agent containers running on each of the nodes within the cluster that were launched as part of the stack. These are feeding information back, giving us an overall view of our cluster.</p>
			<p>Going back to the cluster visualizer now shows us that there are a lot more containers running:</p>
			<div><div><img src="img/Figure_9.27_B15659.jpg" alt="Figure 9.27– Viewing the visualizer&#13;&#10;" width="1644" height="1063"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.27– Viewing the visualizer</p>
			<p>Let's take a look <a id="_idIndexMarker706"/>at what else has changed now we have moved to running Docker Swarm.</p>
			<h3>App Templates</h3>
			<p>Going to<a id="_idIndexMarker707"/> the <strong class="bold">App Templates</strong> page now shows stacks instead of containers:</p>
			<div><div><img src="img/Figure_9.28_B15659.jpg" alt="Figure 9.28 – Viewing the stack templates&#13;&#10;" width="1635" height="1286"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.28 – Viewing the stack templates</p>
			<p>As you can see, there <a id="_idIndexMarker708"/>are quite a few defaults listed, clicking on one, such as <strong class="bold">Wordpress</strong> will take you to a page where you simply have to enter a few details and then click on the <strong class="bold">Deploy the stack</strong> button. Once deployed, you should be able to then go to the <strong class="bold">Stacks</strong> page and view the port that has been assigned to the service:</p>
			<div><div><img src="img/Figure_9.29_B15659.jpg" alt="Figure 9.29 – Launching Wordpress&#13;&#10;" width="1633" height="352"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.29 – Launching Wordpress</p>
			<p>Once you know the port, entering the IP address of any of your nodes and the port will take you to<a id="_idIndexMarker709"/> the application, which, after following the installation instructions, looks like the following:</p>
			<p class="figure-caption"> </p>
			<div><div><img src="img/Figure_9.30_B15659.jpg" alt="Figure 9.30 – WordPress up and running&#13;&#10;" width="1650" height="881"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.30 – WordPress up and running</p>
			<p>These templates are hosted on GitHub and you can find a link in the <em class="italic">Further reading</em> section.</p>
			<h3>Removing the cluster</h3>
			<p>Once you have <a id="_idIndexMarker710"/>finished exploring Portainer on Docker Swarm, you can remove the cluster by running the following commands on your local machine:</p>
			<pre>$ multipass delete --purge node1
$ multipass delete --purge node2
$ multipass delete --purge node3</pre>
			<p>It is important to remove your running nodes on your local machine, because if you don't, they will continue to run and consume resources.</p>
			<h1 id="_idParaDest-182"><a id="_idTextAnchor274"/>Summary</h1>
			<p>That concludes our deep dive with Portainer. As you can see, Portainer is very powerful, yet simple to use, and will only continue to grow and integrate more of the Docker ecosystem as features are released. With Portainer, you can do a lot of manipulation with not only your hosts but also the containers and services running on single or cluster hosts.</p>
			<p>In the next chapter, we are going to look at another container clustering solution supported by Docker called Kubernetes.</p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor275"/>Questions</h1>
			<ol>
				<li value="1">On a macOS or Linux machine, what is the path to mount the Docker socket file?</li>
				<li>What is the default port Portainer runs on?</li>
				<li>True or false: You can use Docker Compose files as application templates.</li>
				<li>True or false: The stats shown in Portainer are only real time, you can't view historical data.</li>
			</ol>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor276"/>Further reading</h1>
			<p>You can find more information on Portainer here:</p>
			<ol>
				<li value="1">Main website: <a href="https://www.portainer.io">https://www.portainer.io</a></li>
				<li>Portainer on GitHub: <a href="https://github.com/portainer/">https://github.com/portainer/</a></li>
				<li>Latest documentation: <a href="https://portainer.readthedocs.io/en/latest/index.html">https://portainer.readthedocs.io/en/latest/index.html</a></li>
				<li>Template documentation: <a href="https://portainer.readthedocs.io/en/latest/templates.html">https://portainer.readthedocs.io/en/latest/templates.html</a></li>
				<li>Templates: <a href="https://github.com/portainer/templates">https://github.com/portainer/templates</a></li>
			</ol>
		</div>
	</div>



  </body></html>