- en: Continuous Integration with Docker Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 容器的持续集成
- en: It is paradoxical, yet true, to say, that the more we know, the more ignorant
    we become in the absolute sense, for it is only through enlightenment that we
    become conscious of our limitations. Precisely one of the most gratifying results
    of intellectual evolution is the continuous opening up of new and greater prospects.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种矛盾但真实的说法：我们知道的越多，在绝对意义上我们变得越无知，因为只有通过启蒙，我们才能意识到自己的局限性。正是知识演化最令人欣慰的成果之一，就是不断开辟新的、更广阔的前景。
- en: —Nikola Tesla
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: —尼古拉·特斯拉
- en: To fully understand the challenges and benefits that Docker Swarm brings, we
    need to start from the beginning. We need to go back to a code repository and
    decide how are we going to build, test, run, update, and monitor the services
    we're developing. Even though the objective is to implement continuous deployment
    to a Swarm cluster, we need to step back and explore **Continuous Integration**
    (**CI***)* first. The steps we'll define for the CI process will dictate how we
    proceed towards **Continuous Delivery** (**CD***)*, from there towards **Continuous
    Deployment** (**CDP***)*, and, finally, how we ensure that our services are monitored
    and able to self-heal. This chapter explores Continuous Integration as a prerequisite
    for the more advanced processes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分理解 Docker Swarm 所带来的挑战和好处，我们需要从头开始。我们需要回到代码库，决定如何构建、测试、运行、更新以及监控我们正在开发的服务。尽管目标是实现对
    Swarm 集群的持续部署，但我们需要退后一步，首先探讨 **持续集成** (**CI***)*。我们为 CI 过程定义的步骤将决定我们如何朝着 **持续交付**
    (**CD***)* 迈进，再从那里迈向 **持续部署** (**CDP***)*，最后确保我们的服务得到监控并能够自我修复。本章将探讨持续集成，作为更高级过程的前提条件。
- en: '**A note to The DevOps 2.0 Toolkit readers** The text that follows is identical
    to the one published in *The DevOps 2.0 Toolkit*. If it is still fresh in your
    mind, feel free to jump to the sub-section *Defining a fully Dockerized manual
    Continuous Integration flow* . Since I wrote the *2.0*, I discovered a few better
    ways to implement CI processes. I hope you''ll benefit from this chapter even
    if you consider yourself a veteran CI practitioner.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**致《DevOps 2.0 工具包》读者的说明** 以下内容与 *《DevOps 2.0 工具包》* 中发布的文本完全相同。如果你记得这些内容，随时可以跳到子章节
    *定义完全 Docker 化的手动持续集成流程*。自从我写了 *2.0* 版后，我发现了一些更好的方式来实现 CI 过程。即使你已经是 CI 方面的老手，我希望你仍能从本章中受益。'
- en: To understand Continuous Deployment we should first define its predecessors,
    Continuous Integration and Continuous Delivery.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解持续部署，我们首先应该定义它的前身——持续集成和持续交付。
- en: Integration phase of a project development tended to be one of the most painful
    stages of **Software Development Life Cycle **(**SDLC**). We would spend weeks,
    months or even years working in separate teams dedicated to separate applications
    and services. Each of those teams would have their set of requirements and tried
    their best to meet them. While it wasn't hard to periodically verify each of those
    applications and services in isolation, we all dreaded the moment when team leads
    would decide that the time has come to integrate them into a unique delivery.
    Armed with the experience from previous projects, we knew that integration would
    be problematic. We knew that we would discover problems, unmet dependencies, interfaces
    that do not communicate with each other correctly and that managers will get disappointed,
    frustrated, and nervous. It was not uncommon to spend weeks or even months in
    this phase. The worse part of all that was that a bug found during the integration
    phase could mean going back and redoing days or weeks worth of work. If someone
    asked me how I felt about integration back then, I'd say that it was closest I
    could get to becoming permanently depressed. Those were different times. We thought
    that was the *right* way to develop applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 项目开发的集成阶段往往是 **软件开发生命周期** (**SDLC**) 中最痛苦的阶段之一。我们会花费数周、数月甚至数年时间，分别在不同团队中为各自的应用程序和服务工作。每个团队都有自己的一组需求，并尽力满足这些需求。尽管定期独立验证这些应用程序和服务并不困难，但我们都害怕那一刻的到来——团队负责人决定是时候将它们集成到一个统一的交付中。凭借之前项目的经验，我们知道集成将会很有问题。我们知道会发现问题、未满足的依赖、接口之间的通讯不畅，而管理人员将会感到失望、沮丧和紧张。花费数周甚至数个月时间来处理这个阶段并不罕见。最糟糕的是，在集成阶段发现的一个
    bug 可能意味着需要回头重做几天或几周的工作。如果当时有人问我对集成的看法，我会说，这是我离永久抑郁症最接近的状态。那是不同的时代，我们曾认为那是开发应用程序的
    *正确* 方式。
- en: A lot changed since then. **Extreme Programming** (**XP**) and other agile methodologies
    became familiar, automated testing became frequent, and Continuous Integration
    started to take ground. Today we know that the way we developed software back
    then was wrong. The industry moved a long way since those days.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 自那以后，发生了许多变化。**极限编程**（**XP**）和其他敏捷方法变得普及，自动化测试变得频繁，持续集成开始占据主导地位。今天我们知道，当时我们开发软件的方式是错误的。从那些日子起，行业已经走了很长的路。
- en: Continuous Integration usually refers to integrating, building, and testing
    code within the development environment. It requires developers to integrate code
    into a shared repository often. How often is often can be interpreted in many
    ways and it depends on the size of the team, the size of the project and the number
    of hours we dedicate to coding. In most cases, it means that coders either push
    directly to the shared repository or merge their code with it. No matter whether
    we're pushing or merging, those actions should, in most cases, be done at least
    a couple of times a day. Getting code to the shared repository is not enough,
    and we need to have a pipeline that, as a minimum, checks out the code and runs
    all the tests related, directly or indirectly, to the code corresponding to the
    repository. The result of the execution of the pipeline can be either *red* or
    *green*. Something failed, or everything was run without any problems. In the
    former case, minimum action would be to notify the person who committed the code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成通常指的是在开发环境中集成、构建和测试代码。它要求开发人员经常将代码集成到共享代码库中。多频繁才算“经常”可以有多种解释，这取决于团队的规模、项目的大小以及我们投入编码的时间。在大多数情况下，这意味着开发人员要么直接推送代码到共享代码库，要么将代码与共享代码库进行合并。不管是推送还是合并，在大多数情况下，这些操作应当至少每天进行几次。将代码推送到共享代码库并不够，我们需要一个流水线，至少要检查代码并运行所有与代码相关的测试（无论是直接还是间接的）。流水线执行的结果可以是*红色*或者*绿色*。即要么某些东西失败了，要么所有的测试都没有问题。在前者的情况下，最基本的行动是通知提交代码的人。
- en: The Continuous Integration pipeline should run on every commit or push. Unlike
    Continuous Delivery, Continuous Integration does not have a clearly defined goal
    of that pipeline. Saying that one application integrates with others does not
    tell us a lot about its production readiness. We do not know how much more work
    is required to get to the stage when the code can be delivered to production.
    All we are striving for is the knowledge that a commit did not break any of the
    existing tests. Nevertheless, CI is a vast improvement when done right. In many
    cases, it is a very hard practice to implement, but once everyone is comfortable
    with it, the results are often very impressive.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 持续集成流水线应该在每次提交或推送时运行。与持续交付不同，持续集成并没有明确的流水线目标。说一个应用与其他应用集成并没有告诉我们它的生产准备情况。我们并不知道还需要做多少工作才能将代码交付到生产环境。我们唯一追求的目标是确保一次提交没有破坏任何现有的测试。然而，当做得对时，CI是一个巨大的改进。在许多情况下，它是一个非常难以实施的实践，但一旦每个人都适应了它，通常结果会非常令人印象深刻。
- en: Integration tests need to be committed together with the implementation code,
    if not before. To gain maximum benefits, we should write tests in **Test-Driven
    Development** (**TDD**) fashion. That way, not only that tests are ready for commit
    together with implementation, but we know that they are not faulty and would not
    pass no matter what we do. There are many other benefits TDD brings to the table
    and, if you haven't already, I strongly recommend to adopt it. You might want
    to consult the *Test-Driven Development* ([http://technologyconversations.com/category/test-driven-development/](http://technologyconversations.com/category/test-driven-development/)) section
    of the *Technology Conversations* ([http://technologyconversations.com/](http://technologyconversations.com/)) blog.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试需要与实现代码一起提交，或者至少在实现代码之前提交。为了获得最大效益，我们应当采用**测试驱动开发**（**TDD**）的方式来编写测试。这样，不仅测试能够和实现代码一起提交，而且我们知道测试没有问题，无论我们做什么都不会失败。TDD带来了许多其他好处，如果你还没有采用它，我强烈建议你采纳。你可能想参考*测试驱动开发*（[http://technologyconversations.com/category/test-driven-development/](http://technologyconversations.com/category/test-driven-development/)）部分，位于*技术对话*（[http://technologyconversations.com/](http://technologyconversations.com/)）博客中。
- en: Tests are not the only CI prerequisite. One of the most important rules is that
    when the pipeline fails, fixing the problem has higher priority than any other
    task. If this action is postponed, next executions of the pipeline will fail as
    well. People will start ignoring the failure notifications and, slowly, CI process
    will begin losing its purpose. The sooner we fix the problem discovered during
    the execution of the CI pipeline, the better we are. If corrective action is taken
    immediately, knowledge about the potential cause of the problem is still fresh
    (after all, it's been only a few minutes between the commit and the failure notification)
    and fixing it should be trivial.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 测试并不是唯一的 CI 前提条件。最重要的规则之一是，当流水线失败时，修复问题的优先级高于其他任何任务。如果这项工作被推迟，那么下一次流水线执行也会失败。人们将开始忽略失败通知，渐渐地，CI
    流程将失去其意义。我们越早解决在 CI 流水线执行过程中发现的问题，我们就越好。如果立即采取纠正措施，那么关于问题潜在原因的知识仍然是新鲜的（毕竟，从提交到失败通知只有几分钟的时间），修复起来应该是微不足道的。
- en: Defining a fully Dockerized manual Continuous Integration flow
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义一个完全 Docker 化的手动持续集成流程
- en: Every Continuous Integration process starts with a code that is checked out
    from a repository. We'll use the GitHub repository `vfarcic/go-demo` ([https://github.com/vfarcic/go-demo](https://github.com/vfarcic/go-demo))
    throughout the book. It contains the code of the service we'll use throughout
    the book. The service is written in *Go* ([https://golang.org/](https://golang.org/)).
    Fear not! Even though I consider it one of the best currently available languages,
    you will not be required to learn Go. We'll use the go-demo service only as a
    demonstration of the processes explained throughout the book. Even though I strongly
    recommend learning Go, the book does not assume any knowledge of the language.
    All the examples will be programming language agnostic.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个持续集成过程都从从仓库中检出的代码开始。本书中，我们将使用 GitHub 仓库 `vfarcic/go-demo` ([https://github.com/vfarcic/go-demo](https://github.com/vfarcic/go-demo))。它包含了本书中将使用的服务的代码。该服务是用
    *Go* ([https://golang.org/](https://golang.org/)) 编写的。别担心！尽管我认为它是目前最好的编程语言之一，你并不需要学习
    Go。本书将使用 go-demo 服务仅作为展示整个流程的示范。虽然我强烈推荐学习 Go，但本书不假设你有任何关于该语言的知识。所有的示例都将是与编程语言无关的。
- en: All the commands from this chapter are available in the `01-continuous-integration.sh` ([https://gist.github.com/vfarcic/886ae97fe7a98864239e9c61929a3c7c](https://gist.github.com/vfarcic/886ae97fe7a98864239e9c61929a3c7c))
    Gist.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章节中的所有命令都可以在 `01-continuous-integration.sh` ([https://gist.github.com/vfarcic/886ae97fe7a98864239e9c61929a3c7c](https://gist.github.com/vfarcic/886ae97fe7a98864239e9c61929a3c7c))
    Gist 中找到。
- en: '**A note to Windows users**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 用户提示**'
- en: Please make sure that your Git client is configured to check out the code *AS-IS*.
    Otherwise, Windows might change carriage returns to the Windows format.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保你的 Git 客户端已配置为按原样检出代码 *AS-IS*。否则，Windows 可能会将回车符转换为 Windows 格式。
- en: 'Let''s get going and check out the `go-demo` code:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧，首先检出 `go-demo` 代码：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Some of the files will be shared between the host file system and Docker Machines
    we'll start creating soon. Docker Machine makes the whole directory that belongs
    to the current user available inside the VM. Therefore, please make sure that
    the code is checked out inside one of the user's sub-folders.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 有些文件将在主机文件系统和我们即将创建的 Docker Machines 之间共享。Docker Machine 使当前用户所属的整个目录可以在虚拟机内访问。因此，请确保代码已检出到用户的某个子文件夹内。
- en: Now that we have the code checked out from the repository, we need a server
    that we'll use to build and run tests. For now, we'll use Docker Machine, since
    it provides an easy way to create a "Docker ready" VMs on our laptops.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经从仓库中检出了代码，接下来我们需要一台服务器来构建和运行测试。暂时，我们将使用 Docker Machine，因为它提供了一种在我们的笔记本上轻松创建“Docker
    就绪”虚拟机的方式。
- en: The *Docker Machine* ([https://docs.docker.com/machine/overview/](https://docs.docker.com/machine/overview/)) is
    a tool that lets you install Docker Engine on virtual hosts, and manage the hosts
    with the `docker-machine` commands. You can use Machine to create Docker hosts
    on your local Mac or Windows box, on your company network, in your data center,
    or on cloud providers like AWS or DigitalOcean.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '*Docker Machine* ([https://docs.docker.com/machine/overview/](https://docs.docker.com/machine/overview/))
    是一款工具，允许你在虚拟主机上安装 Docker 引擎，并使用 `docker-machine` 命令来管理主机。你可以使用 Docker Machine
    在本地的 Mac 或 Windows 主机、公司网络、数据中心，或者像 AWS 或 DigitalOcean 这样的云服务提供商上创建 Docker 主机。'
- en: Using `docker-machine` commands, you can start, inspect, stop, and restart a
    managed host, upgrade the Docker client and daemon, and configure a Docker client
    to talk to your host.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`docker-machine`命令，你可以启动、检查、停止和重启托管主机，升级Docker客户端和守护进程，并配置Docker客户端与主机通信。
- en: Machine was the only way to run Docker on Mac or Windows previous to *Docker
    v1.12.* Starting with the beta program and *Docker v1.12*, Docker for Mac and
    Docker for Windows are available as native apps and the better choice for this
    use case on newer desktops and laptops. I encourage you to try out these new apps.
    The installers for Docker for Mac and Docker for Windows include Docker Machine,
    along with Docker Compose.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Docker v1.12*之前，Machine是唯一在Mac或Windows上运行Docker的方法。从Beta版本和*Docker v1.12*开始，Docker
    for Mac和Docker for Windows作为本地应用程序发布，是更新桌面和笔记本电脑上的更好选择。我鼓励你尝试这些新应用。Docker for
    Mac和Docker for Windows的安装程序包括Docker Machine以及Docker Compose。
- en: The examples that follow assume that you have *Docker Machine version v0.9* ([https://www.docker.com/products/docker-machine](https://www.docker.com/products/docker-machine))
    that includes *Docker Engine v1.13+* ([https://www.docker.com/products/docker-engine](https://www.docker.com/products/docker-engine)).
    The installation instructions can be found in the *Install Docker Machine* ([https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)) page.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例假设你使用的是*Docker Machine v0.9*（[https://www.docker.com/products/docker-machine](https://www.docker.com/products/docker-machine)），其中包括*Docker
    Engine v1.13+*（[https://www.docker.com/products/docker-engine](https://www.docker.com/products/docker-engine)）。安装说明可以在*Install
    Docker Machine*（[https://docs.docker.com/machine/install-machine/](https://docs.docker.com/machine/install-machine/)）页面找到。
- en: '**A note to Windows users**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows用户注意**'
- en: The recommendation is to run all the examples from *Git Bash* (installed through
    *Docker Toolbox* as well as Git). That way the commands you'll see throughout
    the book will be same as those that should be executed on *OS X* or any *Linux*
    distribution.**A note to Linux users**
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用*Git Bash*运行所有示例（通过*Docker Toolbox*以及Git安装）。这样，你将在本书中看到的命令与在*OS X*或任何*Linux*发行版上执行的命令相同。**Linux用户注意**
- en: 'Docker Machine on Linux might not be able to mount a host volume inside VMs.
    The problem is related to the fact that both host and Docker Machine OSes use
    `/home` directory. Mounting `/home` from the host would overwrite some of the
    required files. If you experience problems with mounting of the host volume, please
    export the `VIRTUALBOX_SHARE_FOLDER` variable:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux上，Docker Machine可能无法将主机卷挂载到虚拟机中。问题与主机和Docker Machine操作系统都使用`/home`目录有关。挂载主机的`/home`目录会覆盖一些必要的文件。如果你遇到挂载主机卷的问题，请导出`VIRTUALBOX_SHARE_FOLDER`变量：
- en: '`export VIRTUALBOX_SHARE_FOLDER="$PWD:$PWD"`'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`export VIRTUALBOX_SHARE_FOLDER="$PWD:$PWD"`'
- en: If machines are already created, you'll have to destroy them and create them
    again.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果机器已经创建，你需要销毁它们并重新创建。
- en: Please note that this problem should be fixed in newer Docker Machine versions
    so use this workaround only if you notice that the volume is not mounted (files
    from the host are not available inside VMs).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个问题应该在更新版本的Docker Machine中得到解决，所以只有在你注意到卷没有被挂载（主机中的文件在虚拟机内不可用）时才使用这个解决方法。
- en: 'Let''s create our first server called `go-demo` use the following command:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第一个名为`go-demo`的服务器，使用以下命令：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '**A note to Windows users**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows用户注意**'
- en: If you're using *Docker for Windows* instead of *Docker Toolbox*, you will need
    to change the driver from virtualbox to Hyper-V. The problem is that Hyper-V does
    not allow mounting host volumes, so it is still highly recommended to use *Docker
    Toolbox* when working with *Docker Machine*. The reason behind the choice of running
    *Docker* inside *Docker Machines* instead natively on the host lies in the need
    to run a cluster (coming in the next chapter). *Docker Machine* is the easiest
    way to simulate a multi-node cluster.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是*Docker for Windows*而非*Docker Toolbox*，你需要将驱动程序从virtualbox更改为Hyper-V。问题在于，Hyper-V不允许挂载主机卷，因此在使用*Docker
    Machine*时，仍然强烈建议使用*Docker Toolbox*。选择在*Docker Machines*内运行*Docker*而不是直接在主机上运行的原因在于需要运行集群（将在下一章介绍）。*Docker
    Machine*是模拟多节点集群的最简单方法。
- en: 'The command should be self-explanatory. We specified virtualbox as the driver
    (or Hyper-V if you''re running *Docker for Windows*) and named the machine `go-demo`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令应该是自解释的。我们指定了virtualbox作为驱动程序（或者如果你使用*Docker for Windows*则是Hyper-V），并将机器命名为`go-demo`：
- en: '**A note to Windows users**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows用户注意**'
- en: 'In some cases, Git Bash might think that it is still running as BAT. If you
    experience a problem with the `docker-machine env` commands, please export the
    `SHELL` variable:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，Git Bash 可能会认为它仍然以 BAT 模式运行。如果你在运行 `docker-machine env` 命令时遇到问题，请导出 `SHELL`
    变量：
- en: '`export SHELL=bash`'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`export SHELL=bash`'
- en: 'Now that the machine is running, we should instruct our local Docker Engine
    to use it, use the following command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在机器已经在运行，我们应该指示本地的 Docker 引擎使用它，使用以下命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `docker-machine env go-demo` command outputs environment variables required
    for the local engine to find the server we'd like to use. In this case, the remote
    engine is inside the VM we created with the `docker-machine create` command.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-machine env go-demo`命令输出本地引擎需要的环境变量，以便找到我们想要使用的服务器。在这种情况下，远程引擎位于我们通过`docker-machine
    create`命令创建的虚拟机中。'
- en: 'The output is as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can envelop the `env` command into an `eval` that will evaluate the output
    and, in this case, create the environment variables using the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将`env`命令封装进一个`eval`命令中，该命令会评估输出，并在这种情况下，使用以下命令创建环境变量：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: From now on, all the Docker commands we execute locally will be channeled to
    the engine running inside the `go-demo` machine.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们在本地执行的所有 Docker 命令都会通过 `go-demo` 机器内的引擎执行。
- en: Now we are ready to run the first two steps in the CI flow. We'll execute unit
    tests and build the service binary.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好运行 CI 流程中的前两步。我们将执行单元测试并构建服务二进制文件。
- en: Running unit tests and building service binary
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行单元测试并构建服务二进制文件
- en: We'll use Docker Compose for the CI flow. As you will see soon, Docker Compose
    has little, if any, value when operating the cluster. However, for operations
    that should be performed on a single machine, Docker Compose is still the easiest
    and the most reliable way to go.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Docker Compose 来执行 CI 流程。正如你很快会看到的，Docker Compose 在操作集群时几乎没有任何价值。然而，对于应该在单一机器上执行的操作，Docker
    Compose 仍然是最简单且最可靠的方式。
- en: Compose is a tool for defining and running multi-container Docker applications.
    With Compose, you use a Compose file to configure your application's services.
    Then, using a single command, you create and start all the services from your
    configuration. Compose is great for development, testing, and staging environments,
    as well as CI workflows.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Compose 是一个定义和运行多容器 Docker 应用程序的工具。使用 Compose，你可以通过 Compose 文件来配置应用程序的服务。然后，使用一个命令，你就可以从配置中创建并启动所有服务。Compose
    非常适合开发、测试、暂存环境以及 CI 工作流。
- en: The repository that we cloned earlier, already has all the services we'll need
    defined inside the `docker-compose-test-local.yml` ([https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-loc](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-loc))
    file.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前克隆的仓库已经在`docker-compose-test-local.yml`文件中定义了我们需要的所有服务([https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-loc](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-loc))。
- en: 'Let''s take a look at the content of the `docker-compose-test-local.yml` ([https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml))
    file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看`docker-compose-test-local.yml`文件的内容：([https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml))
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The service we''ll use for our unit tests is called `unit`. It is as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用于单元测试的服务名为`unit`，它如下所示：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is a relatively simple definition. Since the service is written in *Go*,
    we are using the `golang:1.6` image.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相对简单的定义。由于服务是用*Go*编写的，我们使用的是`golang:1.6`镜像。
- en: Next, we are exposing a few volumes. Volumes are directories that are, in this
    case, mounted on the host. They are defined with two arguments. The first argument
    is the path to the host directory while the second represents a directory inside
    the container. Any file already inside the host directory will be available inside
    the container and vice versa.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将暴露一些卷。卷是指在这种情况下挂载到主机上的目录。它们通过两个参数定义。第一个参数是主机目录的路径，第二个表示容器内部的目录。任何已经存在于主机目录中的文件都将可以在容器内访问，反之亦然。
- en: The first volume is used for the source files. We are sharing the current host
    directory `.` with the container directory `/usr/src/myapp`. The second volume
    is used for *Go* libraries. Since we want to avoid downloading all the dependencies
    every time we run unit tests, they will be stored inside the host directory `/tmp/go`.
    That way, dependencies will be downloaded only the first time we run the service.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个卷用于源文件。我们将当前的主机目录 `.` 与容器目录 `/usr/src/myapp` 共享。第二个卷用于*Go*库。由于我们希望避免每次运行单元测试时都下载所有依赖项，因此它们将存储在主机目录
    `/tmp/go` 中。这样，依赖项只有在第一次运行服务时才会被下载。
- en: Volumes are followed with the `working_dir` instruction. When the container
    is run, it will use the specified value as the starting directory.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 卷后面跟着 `working_dir` 指令。当容器运行时，它将使用指定的值作为起始目录。
- en: Finally, we are specifying the command we want to run inside the container.
    I won't go into details since they are specific to *Go*. In short, we download
    all the dependencies `go get -d -v -t`, run `unit` tests `go test --cover -v ./...`,
    and build the go-demo binary `go build -v -o go-demo`. Since the directory with
    the source code is mounted as a volume, the binary will be stored on the host
    and available for later use.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们指定了要在容器内运行的命令。我不会详细介绍这些命令，因为它们特定于*Go*。简而言之，我们下载所有依赖项 `go get -d -v -t`，运行
    `unit` 测试 `go test --cover -v ./...`，并构建 go-demo 二进制文件 `go build -v -o go-demo`。由于包含源代码的目录已作为卷挂载，因此二进制文件将存储在主机上并可供后续使用。
- en: With this single Compose service, we defined two steps of the CI flow. It contains
    unit tests and build of the binary.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个单一的 Compose 服务，我们定义了 CI 流程的两个步骤。它包含单元测试和二进制文件的构建。
- en: Please note that even though we run the service called `unit`, the real purpose
    of this CI step is to run any type of tests that do not require deployment. Those
    are the tests we can execute before we build the binary and, later on, Docker
    images.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，尽管我们运行名为 `unit` 的服务，但该 CI 步骤的实际目的是运行任何不需要部署的测试。这些测试是在构建二进制文件之前，我们可以执行的测试，稍后还可以运行
    Docker 镜像。
- en: 'Let''s run the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下代码：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '**A note to Windows users**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Windows 用户注意**'
- en: 'You might experience a problem with volumes not being mapped correctly. If
    you see an `Invalid volume specification error`, please export the environment
    variable `COMPOSE_CONVERT_WINDOWS_PATHS set` to  `0`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到卷未正确映射的问题。如果你看到 `Invalid volume specification error` 错误，请将环境变量 `COMPOSE_CONVERT_WINDOWS_PATHS`
    导出并设置为 `0`：
- en: '`export COMPOSE_CONVERT_WINDOWS_PATHS=0`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`export COMPOSE_CONVERT_WINDOWS_PATHS=0`'
- en: If that fixed the problem with volumes, please make sure that the variable is
    exported every time you run `docker-compose`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这解决了卷的问题，请确保每次运行 `docker-compose` 时都导出该变量。
- en: We specified that Compose should use `docker-compose-test-local.yml` file (default
    is `docker-compose.yml`) and run the service called `unit`. The `--rm` argument
    means that the container should be removed once it stops. The run command should
    be used for services that are not meant to run forever. It is perfect for batch
    jobs and, as in this case, for running tests.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定 Compose 使用 `docker-compose-test-local.yml` 文件（默认是 `docker-compose.yml`）并运行名为
    `unit` 的服务。`--rm` 参数表示容器停止后应被移除。该命令适用于那些不打算长期运行的服务。它非常适合批处理任务，以及在本例中用于运行测试。
- en: As you can see from the output, we pulled the `golang` image, downloaded service
    dependencies, successfully ran the tests, and built the binary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中可以看到，我们拉取了 `golang` 镜像，下载了服务依赖项，成功运行了测试，并构建了二进制文件。
- en: 'We can confirm that the binary is indeed built and available on the host by
    listing the files in the current directory using the following command. For brevity,
    we''ll filter the result:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过列出当前目录中的文件来确认二进制文件确实已构建并且可以在主机上使用。为了简便起见，我们将过滤结果：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we passed the first round of tests and have the binary, we can proceed
    and build the Docker images.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过了第一轮测试并且有了二进制文件，我们可以继续构建 Docker 镜像。
- en: Building service images
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建服务镜像
- en: Docker images are built through a definition stored in a Dockerfile. With few
    exceptions, it takes a similar approach as if we would define a simple script.
    We will not explore all the options we can use when defining a Dockerfile, but
    only those used for the `go-demo` service. Please consult the *Dockerfile reference*
    ([https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)) page
    for more info.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是通过存储在 Dockerfile 中的定义来构建的。除少数例外，它采用的方式类似于定义一个简单的脚本。我们不会探索定义 Dockerfile
    时可以使用的所有选项，而仅会讲解 `go-demo` 服务使用的选项。有关更多信息，请参考 *Dockerfile 参考*（[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)）页面。
- en: 'The [`go-demo`](https://github.com/vfarcic/go-demo/blob/master/Dockerfile)
    Dockerfile is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[`go-demo`](https://github.com/vfarcic/go-demo/blob/master/Dockerfile) Dockerfile
    如下所示：'
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Each of the statements will be built as a separate image. A container is a collection
    of images stacked one on top of the other.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 每个语句将构建为一个独立的镜像。容器是多个镜像层叠在一起的集合。
- en: Every Dockerfile starts with the `FROM` statement. It defines the base image
    that should be used. In most cases, my preference is to use `alpine` Linux. With
    its size being around 2MB it is probably the smallest distribution we can use.
    That is aligned with the idea that containers should have only things that are
    needed and avoid any extra overhead.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 Dockerfile 都以 `FROM` 语句开始。它定义了应使用的基础镜像。在大多数情况下，我更倾向于使用 `alpine` Linux。由于它的大小约为
    2MB，可能是我们可以使用的最小的发行版。这与容器应该只包含所需的内容，并避免任何额外开销的理念一致。
- en: '`MAINTAINER` is for informational purposes only.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`MAINTAINER` 仅用于提供信息。'
- en: The `RUN` statement executes any command set as its argument. I won't explain
    this one since it is very specific to the service we're building.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`RUN` 语句执行作为其参数设置的任何命令。由于它非常具体于我们正在构建的服务，我就不再解释了。'
- en: The `EXPOSE` statement defines the port the service will be listening to. It
    is followed by the definition of the environment variable `DB` that tells the
    service the address of the database. The default value is `db` and, as you'll
    see soon, it can be changed at runtime. The `CMD` statement represents the command
    that will be run when containers start.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXPOSE` 语句定义了服务监听的端口。接下来是环境变量 `DB` 的定义，它告诉服务数据库的地址。默认值为 `db`，如你将很快看到的，它可以在运行时进行更改。`CMD`
    语句表示容器启动时将执行的命令。'
- en: The `HEALTHCHECK` instruction tells Docker how to test a container to check
    that it is still working. This can detect cases such as a web server that is stuck
    in an infinite loop and unable to handle new connections, even though the server
    process is still running. When a container has a healthcheck specified, it has
    a health status in addition to its normal status. This status is initially starting.
    Whenever a health check passes, it becomes healthy (from whatever state it was
    previously in). After a certain number of consecutive failures, it becomes unhealthy.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`HEALTHCHECK` 指令告诉 Docker 如何测试容器，以确保它仍然正常工作。这可以检测出诸如 Web 服务器卡在无限循环中，无法处理新连接的情况，尽管服务器进程仍在运行。当容器指定了健康检查时，它将拥有健康状态，除了正常状态外。该状态最初为“启动中”。每当健康检查通过时，它就变为“健康”（无论之前处于什么状态）。在连续失败达到一定次数后，它会变为“不健康”。'
- en: In our case, the healthcheck will be executed every ten seconds. The command
    sends a simple request to one of the API endpoints. If the service responds with
    status `200`, the `wget` command will return `0` and Docker will consider the
    service healthy. Any other response will be considered as unhealthy and Docker
    Engine will perform certain actions to fix the situation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，健康检查将每十秒执行一次。该命令向 API 端点之一发送一个简单的请求。如果服务返回状态 `200`，`wget` 命令将返回 `0`，Docker
    会认为服务是健康的。任何其他响应都将被视为不健康，Docker 引擎会采取某些措施来修复该情况。
- en: Finally, we copy the `go-demo` binary from the host to the `/usr/local/bin/`
    directory inside the image and give it executable permissions with the `chmod`
    command.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `go-demo` 二进制文件从主机复制到镜像内的 `/usr/local/bin/` 目录，并使用 `chmod` 命令赋予其可执行权限。
- en: To some, the order of the statements might not look logical. However, there
    is a good reason behind such declarations and their order. Those that are less
    likely to change are defined before those that are prone to changes. Since `go-demo`
    will be a new binary every time we build the images, it is defined last.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对某些人来说，语句的顺序可能看起来不太合逻辑。然而，这些声明及其顺序背后是有充分理由的。那些不太可能更改的声明会先于那些容易更改的声明定义。由于 `go-demo`
    每次构建镜像时都会是一个新的二进制文件，所以它被定义在最后。
- en: The reasons behind such order lie in the way Docker Engine creates images. It
    starts from the top-most definition and checks whether it changed since the last
    time the build was run. If it didn't, it moves to the next statement. As soon
    as it finds a statement that would produce a new image, it, and all the statements
    following it are built into Docker images. By placing those that are less likely
    to change closer to the top, we can reduce the build time, disk usage, and bandwidth.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这种顺序的原因在于Docker引擎创建镜像的方式。它从最上面的定义开始，检查自上次构建以来是否有变化。如果没有变化，它将跳到下一个语句。一旦找到可能会生成新镜像的语句，它和所有后续的语句都将构建成Docker镜像。通过将那些不太可能改变的部分放置在顶部，我们可以减少构建时间、磁盘使用量和带宽消耗。
- en: Now that we understand the Dockerfile behind the `go-demo` service, we can build
    the images.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们理解了`go-demo`服务背后的Dockerfile，我们可以构建镜像。
- en: 'The command is very straightforward and is as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令非常简单，如下所示：
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As an alternative, we can define build arguments inside a Docker Compose file.
    The service defined in `docker-compose-test-local.yml` ([https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml))
    file is as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替代，我们可以在Docker Compose文件中定义构建参数。`docker-compose-test-local.yml`文件中定义的服务如下：[https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml)
- en: '[PRE11]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In both cases, we specified that the current directory should be used for the
    build process `.` and that the name of the image is `go-demo`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，我们都指定了当前目录应作为构建过程的工作目录`。`，并且镜像的名称为`go-demo`。
- en: 'We can run the build through Docker compose with the command that is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下命令使用Docker Compose运行构建：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We'll use the latter method throughout the rest of the book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的其余部分中使用后一种方法。
- en: 'We can confirm that the image was indeed built, by executing the `docker images`
    command as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行`docker images`命令来确认镜像确实已经构建，如下所示：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The output is as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As you can see, `go-demo` is one of the images we have inside the server.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`go-demo`是我们服务器中存储的镜像之一。
- en: Now that the images are built, we can run staging tests that depend on the service
    and its dependencies to be deployed on a server.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在镜像已经构建完成，我们可以运行依赖于该服务及其依赖项在服务器上部署的预发布测试。
- en: Running staging tests
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行预发布测试
- en: Please note that the real purpose of this step in the CI flow is to run the
    tests that require the service and its dependencies to be running. Those are still
    not integration tests that require production or production-like environment.
    The idea behind those tests is to run the service together with its direct dependencies,
    run the tests, and, once they're finished, remove everything and free the resources
    for some other task. Since these are still not integration tests, some, if not
    all, dependencies can be mocks.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此步骤在CI流程中的真正目的是运行那些需要服务及其依赖项正在运行的测试。这些还不是需要生产环境或类似生产环境的集成测试。这些测试的目的是将服务与其直接依赖项一起运行，执行测试，并在测试完成后移除所有内容并释放资源以进行其他任务。由于这些还不是集成测试，所以某些（如果不是全部）依赖项可以是模拟对象。
- en: 'Due to the nature of these tests, we need to split the task into three actions:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些测试的性质，我们需要将任务分为三个步骤：
- en: Run the service and all the dependencies.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行服务及所有依赖项。
- en: Run the tests.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试。
- en: Destroy the service and all the dependencies.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 销毁服务及所有依赖项。
- en: 'The dependencies are defined as the `staging-dep` service inside the `docker-compose-test-local.yml` ([https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml))
    file. The definition is as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖项在`docker-compose-test-local.yml`文件中被定义为`staging-dep`服务。该定义如下：[https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-test-local.yml)
- en: '[PRE15]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The image is `go-demo`, and it exposes the port `8080` (both on the host and
    inside the container). It depends on the service `db` which is a `mongo` image.
    Services defined as `depends_on` will be run before the service that defines the
    dependency. In other words, if we run the `staging-dep` target, Compose will run
    the `db` first.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像为`go-demo`，并且暴露了`8080`端口（在主机和容器内均为该端口）。它依赖于名为`db`的`mongo`镜像。定义为`depends_on`的服务将在定义该依赖关系的服务之前运行。换句话说，如果我们运行`staging-dep`目标，Compose会首先运行`db`。
- en: 'Let''s run the dependencies as shown in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下代码运行依赖项：
- en: '[PRE16]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the command is finished, we will have two containers running (`go-demo`
    and `db`). We can confirm that by listing all the processes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令完成，我们将有两个容器在运行（`go-demo`和`db`）。我们可以通过列出所有进程来确认这一点：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The output is as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now that the service and the database it depends on are running, we can execute
    the tests. They are defined as the service staging. The definition is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，服务及其依赖的数据库正在运行，我们可以执行测试。它们被定义为服务暂存。其定义如下：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Since the definition of the staging tests is very similar to those we run as
    unit tests, the staging service extends unit. By extending a service, we inherit
    its full definition. Further on, we defined an environment variable `HOST_IP`.
    The tests code uses that variable to determine the location of the service under
    test. In this case, since the `go-demo` service is running on the same server
    as tests, the IP is server's localhost. Since, by default, localhost inside a
    container is not the same as the one on the host, we had to define `network_mode`
    as `host`. Finally, we defined the command that should be executed. It will download
    tests dependencies `go get -d -v -t` and run the tests `go test --tags integration
    -v`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 由于暂存测试的定义与我们作为单元测试运行的测试非常相似，暂存服务扩展了单元测试。通过扩展服务，我们继承了它的完整定义。接下来，我们定义了一个环境变量`HOST_IP`。测试代码使用该变量来确定待测试服务的位置。在此情况下，由于`go-demo`服务与测试在同一服务器上运行，因此
    IP 是服务器的本地主机。由于默认情况下，容器内的 localhost 与主机上的 localhost 不相同，我们不得不将`network_mode`定义为`host`。最后，我们定义了应该执行的命令。它将下载测试依赖项`go
    get -d -v -t`并运行测试`go test --tags integration -v`。
- en: 'Let''s run the following commands:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE20]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: All the tests passed, and we are one step closer to the goal of having full
    confidence that the service is indeed safe to be deployed to production.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都通过了，我们离实现完全确信服务确实可以安全部署到生产环境的目标又近了一步。
- en: 'We don''t have any use for keeping the service and the database running so
    let''s remove them and free the resources for some other task:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要保持服务和数据库运行，因此让我们将它们移除，释放资源以供其他任务使用：
- en: '[PRE21]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `down` command stops and removes all services defined in that Compose file.
    We can verify that by running the following  `ps` command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`down`命令停止并移除在该 Compose 文件中定义的所有服务。我们可以通过运行以下`ps`命令来验证这一点：'
- en: '[PRE22]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The output is as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There is only one thing missing for the CI flow to be complete. At this moment
    we have the `go-demo` image that is usable only inside the go-demo server. We
    should store it in a registry so that it can be accessed from other servers as
    well.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 只有一件事还缺少，才能完成 CI 流程。目前，我们有一个只在 go-demo 服务器内部可用的`go-demo`镜像。我们应该将其存储在一个注册表中，以便其他服务器也能访问它。
- en: Pushing images to the registry
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将镜像推送到注册表
- en: Before we push our `go-demo` image, we need a place to push to. Docker offers
    multiple solutions that act as a registry. We can use *Docker Hub* ([https://hub.docker.com/](https://hub.docker.com/)),
    *Docker Registry* ([https://docs.docker.com/registry/](https://docs.docker.com/registry/)),
    and *Docker Trusted Registry* ([https://docs.docker.com/docker-trusted-registry/](https://docs.docker.com/docker-trusted-registry/)).
    On top of those, there are many other solutions from third party vendors.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在推送我们的`go-demo`镜像之前，我们需要一个目标位置来推送。Docker 提供了多种作为注册表的解决方案。我们可以使用*Docker Hub*（[https://hub.docker.com/](https://hub.docker.com/)）、*Docker
    Registry*（[https://docs.docker.com/registry/](https://docs.docker.com/registry/)）和*Docker
    Trusted Registry*（[https://docs.docker.com/docker-trusted-registry/](https://docs.docker.com/docker-trusted-registry/)）。除此之外，还有许多第三方供应商提供的其他解决方案。
- en: Which registry should we use? Docker Hub requires a username and password, and
    I do not trust you enough to provide my own. One of the goals I defined before
    I started working on the book is to use only open source tools so Docker Trusted
    Registry, while being an excellent choice under different circumstances, is also
    not suitable. The only option left (excluding third party solutions), is *Docker
    Registry* ([https://docs.docker.com/registry/](https://docs.docker.com/registry/)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该使用哪个注册表？Docker Hub 需要用户名和密码，而我不够信任你来提供我的密码。开始编写本书之前，我定义的一个目标是只使用开源工具，因此
    Docker Trusted Registry，尽管在不同的情况下是一个很好的选择，但也不适合。剩下的唯一选择（不包括第三方解决方案）是*Docker Registry*（[https://docs.docker.com/registry/](https://docs.docker.com/registry/)）。
- en: 'The registry is defined as one of the services inside the `docker-compose-local.yml` ([https://github.com/vfarcic/go-demo/blob/master/docker-compose-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-local.yml))
    Compose file. The definition is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表在 `docker-compose-local.yml` ([https://github.com/vfarcic/go-demo/blob/master/docker-compose-local.yml](https://github.com/vfarcic/go-demo/blob/master/docker-compose-local.yml))
    这个 Compose 文件中被定义为其中的一个服务。定义如下：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We set registry as an explicit container name, specified the image, and opened
    the port `5000` (both on the host and inside the container).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将注册表设置为一个明确的容器名称，指定了镜像，并打开了 `5000` 端口（主机和容器内都开放）。
- en: Registry stores the images inside the `/var/lib/registry` directory, so we mounted
    it as a volume on the host. That way, data will not be lost if the container fails.
    Since this is a production service that could be used by many, we defined that
    it should always be restarted on failure.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表将镜像存储在 `/var/lib/registry` 目录下，因此我们将其挂载为主机上的一个卷。这样，如果容器失败，数据就不会丢失。由于这是一个生产环境服务，可能会被许多人使用，我们定义了在失败时它应始终重启。
- en: 'Let''s run the following commands:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下命令：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now that we have the registry, we can do a dry-run. Let''s confirm that we
    can pull and `push` images to it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了注册表，可以进行一次干运行。让我们确认我们能否从中拉取并 `push` 镜像：
- en: '[PRE26]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Docker uses a naming convention to decide where to pull and push images from.
    If the name is prefixed with an address, the engine will use it to determine the
    location of the registry. Otherwise, it assumes that we want to use Docker Hub.
    Therefore, the first command pulled the alpine image from Docker Hub.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 使用命名约定来决定从哪里拉取和推送镜像。如果名称前面有地址，Docker 引擎将利用这个地址来确定注册表的位置。否则，系统会默认我们要使用
    Docker Hub。因此，第一条命令从 Docker Hub 拉取了 alpine 镜像。
- en: The second command created a tag of the alpine image. The tag is a combination
    of the address of our registry `localhost:5000` and the name of the image. Finally,
    we pushed the `alpine` image to the registry running on the same server.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条命令创建了 alpine 镜像的标签。这个标签是我们注册表地址 `localhost:5000` 和镜像名称的组合。最后，我们将 `alpine`
    镜像推送到了同一台服务器上的注册表。
- en: 'Before we start using the registry in a more serious fashion, let''s confirm
    that the images are indeed persisted on the host:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始更正式地使用注册表之前，先确认镜像确实已经在主机上持久化：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The output is as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE28]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: I won't go into details what each of those sub-directories contains. The important
    thing to note is that registry persists the images on the host so no data will
    be lost if it fails or, in this case, even if we destroy the VM since that Machine
    directory is mapped to the same directory on our laptop.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会详细说明这些子目录各自包含的内容。需要注意的重要事项是，注册表在主机上持久化存储镜像，因此如果它失败，或者在这种情况下，即使我们销毁了虚拟机，由于该机器目录映射到我们笔记本上的相同目录，数据也不会丢失。
- en: We were a bit hasty when we declared that this registry should be used in production.
    Even though data is persisted, if the whole VM crashes, there would be a downtime
    until someone brings it up again or creates a new one. Since one of the goals
    is to avoid downtime whenever possible, later on, we should look for a more reliable
    solution. The current setup should do for now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在声明这个注册表应该用于生产时有点匆忙。即使数据得到了持久化，如果整个虚拟机崩溃，仍会有停机时间，直到有人重新启动它或创建一个新的。由于我们的目标之一是尽可能避免停机，因此稍后我们应该寻找更可靠的解决方案。目前的设置暂时可以使用。
- en: 'Now we are ready to push the `go-demo` image to the registry:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备将 `go-demo` 镜像推送到注册表：
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As with the Alpine example, we tagged the image with the registry prefix and
    pushed it to the registry. We also added a version number `1.0`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 和 Alpine 示例一样，我们使用注册表前缀标记了镜像并将其推送到注册表。我们还添加了版本号 `1.0`。
- en: The push was the last step in the CI flow. We run unit tests, built the binary,
    built the Docker image, ran staging tests, and pushed the image to the registry.
    Even though we did all those things, we are not yet confident that the service
    is ready for production. We never tested how it would behave when deployed to
    a production (or production-like) cluster. We did a lot, but not enough.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 推送是持续集成流程中的最后一步。我们运行了单元测试，构建了二进制文件，构建了 Docker 镜像，运行了预发布测试，并将镜像推送到了注册表。尽管我们完成了所有这些步骤，但我们仍然不确定服务是否已准备好进入生产环境。我们从未测试过它在部署到生产（或类似生产环境的）集群后会如何表现。我们做了很多，但还不够。
- en: If CI were our final objective, this would be the moment when manual validations
    should occur. While there is a lot of value in manual labor that requires creativity
    and critical thinking, we cannot say the same for repetitive tasks. Tasks required
    for converting this Continuous Integration flow into Continuous Delivery and,
    later on, deployment are, indeed repetitive.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果持续集成是我们的最终目标，那么此时应该进行手动验证。虽然手动工作中有很多需要创造力和批判性思维的价值，但我们不能对重复性任务说同样的话。将这个持续集成流程转化为持续交付，并最终实现部署的任务，确实是重复性的。
- en: We have the CI process done, and it is time to do the extra mile and convert
    it into Continuous Delivery.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了CI流程，现在是时候再多做一步，将其转换为持续交付（Continuous Delivery）。
- en: Before we move into the steps required for the Continuous Integration process
    to become Continuous Delivery, we need to take a step back and explore cluster
    management. After all, in most cases, there is no production environment without
    a cluster.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入将持续集成（Continuous Integration）过程转化为持续交付（Continuous Delivery）的步骤之前，我们需要退后一步，探索集群管理。毕竟，在大多数情况下，没有集群就没有生产环境。
- en: 'We''ll destroy the VMs at the end of each chapter. That way, you can come back
    to any of part of the book and do the exercises without the fear that you might
    need to do some steps from one of the earlier chapters. Also, such a procedure
    will force us to repeat a few things. Practice makes perfect. To reduce your waiting
    times, I did my best to keep things as small as possible and keep download times
    to a minimum. Execute the following command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在每一章结束时销毁虚拟机。这样，你可以随时回到书中的任何部分并进行练习，而不必担心可能需要执行前面章节中的某些步骤。此外，这样的操作会迫使我们重复一些内容，熟能生巧。为了减少你的等待时间，我尽力将事情做到尽可能小，并将下载时间降到最低。执行以下命令：
- en: '[PRE30]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The next chapter is dedicated to the setup and operation of a Swarm cluster.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专门讲解Swarm集群的设置和操作。
