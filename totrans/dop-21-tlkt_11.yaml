- en: 'Embracing Destruction: Pets versus Cattle'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any roles involved in a project that do not directly contribute toward the goal
    of putting valuable software in the hands of users as quickly as possible should
    be carefully considered.
  prefs: []
  type: TYPE_NORMAL
- en: -Stein Inge Morisbak
  prefs: []
  type: TYPE_NORMAL
- en: We should discuss the high-level strategies before we start exploring tools
    and processes that will help us create and operate a "real" Swarm cluster. How
    are we going to treat our servers? Are they going to be pets or cattle?
  prefs: []
  type: TYPE_NORMAL
- en: How do you know whether you are treating your servers as pets or cattle? Ask
    yourself the following question. What will happen if several of your servers went
    offline right now? If they are pets, such a situation will cause a significant
    disruption for your users. If they are cattle, such an outcome will go unnoticed.
    Since you are running multiple instances of a service distributed across multiple
    nodes, failure of a single server (or a couple of them), would not result in a
    failure of all replicas. The only immediate effect would be that some services
    would run fewer instances and would have a higher load. Failed replicas would
    be rescheduled so the original number would soon be restored. In parallel, failed
    nodes would be replaced with new VMs. The only adverse effect of a failure of
    a couple of servers would be increased response time due to lower capacity. After
    a couple of minutes, everything would get back to normal with failed replicas
    rescheduled, and failed nodes replaced with new VMs. And the best thing is, it
    would all happen without manual interaction. If that's how your cluster is operating
    right now, you are treating your servers as cattle. Otherwise, you have pets in
    your data center.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional systems administration is based on physical servers. To add a new
    machine to a data center, we need to purchase it upfront, wait until it arrives
    from the vendor, configure it in our office, move it to the data center location,
    and plug it in. The whole process can take a considerable amount of time. It is
    not uncommon for weeks, or even months to pass until we get a new fully provisioned
    server operating inside a data center.
  prefs: []
  type: TYPE_NORMAL
- en: Considering such a big waiting period and the costs, it is only natural that
    we do our best to keep servers as healthy as possible. If one of them starts behaving
    badly, we will do everything in our power to fix it as quickly as possible. What
    else can we do? Wait for weeks or months until a replacement arrives? Of course
    not. SSH into the faulty machine, find out what’s wrong, and fix it. If a process
    died, bring it up again. If a hard disk broke, replace it. If a server is overloaded,
    add more memory.
  prefs: []
  type: TYPE_NORMAL
- en: It is only natural that, in such circumstances, we develop an emotional attachment
    to each of our servers. It starts with a name. Each new server gets one. There
    is Garfield, Mordor, Spiderman, and Sabrina. We might even decide on a theme.
    Maybe all our servers will get a name based on comic book superheroes. Or perhaps
    you prefer mythical creatures? How about ex-boyfriends and ex-girlfriends? Once
    we give a server a name, we start treating it as a pet. How do you feel? Do you
    need something? What’s wrong? Should I take you to a veterinary? Each pet server
    is unique, hand raised, and cared for.
  prefs: []
  type: TYPE_NORMAL
- en: The change started with virtualization. The ability to create and destroy virtual
    machines allowed us to take a different approach to computing. Virtualization
    enabled us to stop treating our servers as pets. If virtualized servers are created
    and destroyed on a whim, it is pointless to give them names. There is no emotional
    attachment since their lifespan can be very short. Instead of *Garfield*, now
    we have *vm262.ecme.com*. Tomorrow, when we try to log into it, we might discover
    that it was replaced with *vm435.ecme.com*.
  prefs: []
  type: TYPE_NORMAL
- en: With virtualization, we started treating our servers as cattle. They do not
    have names, but numbers. We don’t deal with them individually but as a herd. If
    a specimen is sick, we kill it. Curing it is slow and runs a risk of infecting
    the rest of the herd. If a server starts manifesting problems, terminate it immediately,
    and replace it with a new one.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with this approach lies in habits we have accumulated over the years
    working with physical hardware. The switch from pets to cattle requires a mental
    change. It requires unlearning obsolete practices before switching to new ways
    of working.
  prefs: []
  type: TYPE_NORMAL
- en: Even though on-premise virtualization opened doors to quite a few new possibilities,
    many continued treating virtualized servers in the same way as they were treating
    physical nodes. Old habits die hard. Even though our servers became a herd, we
    keep treating each as pets. Part of the reason for the difficulty making a switch
    towards more elastic and dynamic computing lies in physical limitations of our
    data center. New VMs can be created only if there are available resources. Once
    we reach the limit, a VM has to be destroyed for a new one to be created. Our
    physical servers are still a valuable commodity. VMs gave us elasticity that is
    still bound by limitations imposed by the total of the computing power we possess.
  prefs: []
  type: TYPE_NORMAL
- en: We treat our valuable possessions with care since they are not cheap or easy
    to replace. We take good care of them since they should last for a long time.
    On the other hand, we have an entirely different approach to cheap things that
    are easy to replace. If a glass breaks, you probably don’t try to glue the pieces
    together. You throw them to trash. There are plenty of other glasses in a cupboard,
    and all we have to do when their number becomes too small is buy a new set the
    next time we visit a shopping mall. Today we do not even need to go to a shopping
    mall but can order a new set online, and it will be delivered to our doorstep
    the same day. We should apply the same logic to servers.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud computing made a big difference. Servers are no longer a valuable possession
    but a commodity. We can replace a node at any time without any additional cost.
    We can add a dozen servers to our cluster in a matter of minutes. We can remove
    them when we don't need them and reduce the cost.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud computing is fundamentally different from "traditional" data centers.
    When utilized to its full potential, no server is indispensable or unique. The
    worst thing we can do is transition to the cloud without changing our processes
    and architecture. If we simply move our on-premise servers to the cloud without
    changing the processes we use to maintain them, the only thing we'll accomplish
    is higher cost.
  prefs: []
  type: TYPE_NORMAL
- en: With cloud computing, the notion of a server, its value, and the time required
    to get it, changed drastically. Such a significant change needs to be followed
    with a new set of processes and tools that execute them. Fault tolerance is the
    goal, speed is the key, and automation is a must.
  prefs: []
  type: TYPE_NORMAL
- en: What now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until this point, we used Docker Machine to create servers locally and join
    them into a cluster. The intention was to teach you the fundamentals of creating
    and operating a Swarm cluster without spending money on hosting providers. Now
    that we reached the point where you are comfortable with how Docker Swarm Mode
    works, the time has come to move to "real" servers. We’ll continue being "cheap"
    by using small instances that are either free or very inexpensive, and create
    just enough servers to demonstrate the process. The goal of the chapters that
    follow will be to walk you through a few setups, compare them, and choose the
    one we'll apply to our production. The only things you should change are VM instance
    types and the number of servers. Everything else can be the same as in the examples
    we’ll work with.
  prefs: []
  type: TYPE_NORMAL
- en: We already saw how to accomplish fault tolerance by utilizing Docker Swarm as
    the service scheduler. The chapters that follow will try to achieve the required
    speed and automation on the infrastructure level. We'll use different tools and
    processes to automate the creation of a cluster in a few cloud computing providers.
    The first in line is **Amazon Web Services** (**AWS**).
  prefs: []
  type: TYPE_NORMAL
- en: 'struction: Pets vs Cattle'
  prefs: []
  type: TYPE_NORMAL
