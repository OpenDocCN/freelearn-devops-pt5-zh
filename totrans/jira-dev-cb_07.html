<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Programming Issues</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating an issue from your plugin</li><li class="listitem" style="list-style-type: disc">Creating subtasks on an issue</li><li class="listitem" style="list-style-type: disc">Updating an issue</li><li class="listitem" style="list-style-type: disc">Deleting an issue</li><li class="listitem" style="list-style-type: disc">Adding new issue operations</li><li class="listitem" style="list-style-type: disc">Conditions on issue operations</li><li class="listitem" style="list-style-type: disc">Working with attachments</li><li class="listitem" style="list-style-type: disc">Time tracking and worklog management</li><li class="listitem" style="list-style-type: disc">Working with comments on issues</li><li class="listitem" style="list-style-type: disc">Programming Change Logs</li><li class="listitem" style="list-style-type: disc">Programming Issue Links</li><li class="listitem" style="list-style-type: disc">Validations on issue linking</li><li class="listitem" style="list-style-type: disc">Discarding fields while cloning!</li><li class="listitem" style="list-style-type: disc">JavaScript tricks on issue fields</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>Introduction</h1></div></div></div><p>We have so far seen how to develop custom fields, workflows, Reports &amp; Gadgets, JQL functions, and other pluggable things associated with them. In this chapter, we will learn about programming "issues", that is, creating, editing, or deleting issues, creating new issue operations, and managing the various other operations available on issues via JIRA APIs etc.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec76"/>Creating an issue from a plugin</h1></div></div></div><a id="id1186" class="indexterm"/><a id="id1187" class="indexterm"/><a id="id1188" class="indexterm"/><p>In this recipe, we will see how to create an issue from a plugin programmatically. Prior to version 4.1, JIRA used <code class="literal">IssueManager</code><a id="id1189" class="indexterm"/> to create an issue. From JIRA 4.1, there is this <code class="literal">IssueService</code> class that drives the issue operations. Since <code class="literal">IssueService</code><a id="id1190" class="indexterm"/> is recommended over <code class="literal">IssueManager</code>, we will use it in our recipes to create an issue.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec222"/>How to do it...</h2></div></div></div><a id="id1191" class="indexterm"/><p>The main advantage of <code class="literal">IssueService</code> over the <code class="literal">IssueManager</code> class is that it takes care of the validation and error handling. The following are the steps to create an issue using the <code class="literal">IssueService</code>:</p><div><ol class="orderedlist arabic"><li class="listitem"><a id="id1192" class="indexterm"/><a id="id1193" class="indexterm"/>Create an instance of the <code class="literal">IssueService</code> class. You can either inject it in the constructor or get it from the <code class="literal">ComponentManager</code>, as shown:<div><pre class="programlisting">IssueService issueService = ComponentManager.getInstance().getIssueService();</pre></div></li><li class="listitem">Create the issue input parameters. In this step, we will set all the values that are required to create the issue using the <code class="literal">IssueInputParameters</code> class<a id="id1194" class="indexterm"/>.<div><ol class="orderedlist loweralpha"><li class="listitem">Create an instance of the <code class="literal">IssueInputParameters</code> class.<div><pre class="programlisting">IssueInputParameters issueInputParameters = new IssueInputParametersImpl();</pre></div></li><li class="listitem">Populate the <code class="literal">IssueInputParameters</code> with the values required to create the issue as shown in the next few lines of code:<div><pre class="programlisting">issueInputParameters.setProjectId(10100L).setIssueTypeId("8").setSummary("Test Summary").setReporterId("jobinkk").setAssigneeId("jobinkk").setDescription("Test Description").setStatusId("10010").setPriorityId("2").setFixVersionIds(10000L, 12121L);</pre></div></li><li class="listitem">Make sure all the required values like project, issue type, summary, and other mandatory values required when the issue is created using the user interface is set on the <code class="literal">IssueInputParameters</code>.</li><li class="listitem">Here, we have used test values, but make sure to replace them with appropriate values. For example, the project, issue type ID, priority ID, Fix version IDs, reporter, and assignee should have appropriate values.</li></ol></div></li><li class="listitem">Validate the input parameters using <code class="literal">IssueService</code>.<div><pre class="programlisting">CreateValidationResult createValidationResult = issueService.validateCreate(user, issueInputParameters);</pre></div><a id="id1195" class="indexterm"/><a id="id1196" class="indexterm"/><a id="id1197" class="indexterm"/><a id="id1198" class="indexterm"/><a id="id1199" class="indexterm"/><p>Here, the <code class="literal">user</code> is the one creating the issue. The validation is done based on the user permissions and the <code class="literal">createValidationResult</code> variable<a id="id1200" class="indexterm"/> will have errors if the validation fails due to permission issues or due to invalid input parameters!</p></li><li class="listitem">If the <code class="literal">createValidationResult</code> is valid, create the issue using <code class="literal">IssueService</code>.<div><pre class="programlisting">if (createValidationResult.isValid()) {
  IssueResult createResult = issueService.create(user,createValidationResult);
}</pre></div><p>Here, we use the<a id="id1201" class="indexterm"/> <code class="literal">createValidationResult</code> object to create the issue, as it already has the processed input parameters. If the result is not valid, handle the errors as shown in the following code:</p><div><pre class="programlisting">if (!createValidationResult.isValid()) {
  Collection&lt;String&gt; errorMessages = createValidationResult.getErrorCollection().getErrorMessages();
  for (String errorMessage : errorMessages) {
    System.out.println(errorMessage);
  }
  Map&lt;String, String&gt; errors = createValidationResult.getErrorCollection().getErrors();
  Set&lt;String&gt; errorKeys = errors.keySet();
  for (String errorKey : errorKeys) {
    System.out.println(errors.get(errorKey));
  }
}</pre></div><p>Here, we just print the error to the console if the result is invalid. The <code class="literal">errorMessages</code> will have all non-field-specific errors like permission issue-related errors, and so on, but any field-specific errors, like input validation errors, will appear in the <code class="literal">errors</code> map where the key will be the field name. We should handle both the error types as appropriate.</p></li><li class="listitem">After the creation of an issue, check if the <code class="literal">createResult</code><a id="id1202" class="indexterm"/> is valid or not. If not, handle it appropriately. The <code class="literal">createResult</code> object will have errors only if there is a severe problem with JIRA (for example, one can't communicate with the DB, the workflow has changed since you invoked validate, and so on).<div><pre class="programlisting">if (!createResult.isValid()) {
  Collection&lt;String&gt; errorMessages = createResult.getErrorCollection().getErrorMessages();
  for (String errorMessage : errorMessages) {
    System.out.println(errorMessage);
  }
}</pre></div><p>Here again, we just print the error to the console.</p></li><li class="listitem">If <code class="literal">createResult</code><a id="id1203" class="indexterm"/> is valid, then the issue is created successfully and you can retrieve it as:<div><pre class="programlisting">MutableIssue issue = createResult.getIssue();</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec223"/>How it works...</h2></div></div></div><a id="id1204" class="indexterm"/><a id="id1205" class="indexterm"/><a id="id1206" class="indexterm"/><a id="id1207" class="indexterm"/><a id="id1208" class="indexterm"/><p>By using <code class="literal">IssueService</code>, JIRA now validates the inputs we give using the rules we have set up in JIRA via the user interfaces, such as the mandatory fields, permission checks, individual field validations, and so on. Behind the scenes, it still uses the <code class="literal">IssueManager</code> class.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec224"/>There's more...</h2></div></div></div><p>As mentioned before, prior to JIRA 4.1, we need to use the <code class="literal">IssueManager</code> class to create the issues. It can still be used in JIRA 4.1+, but this is not recommended as it overrides all the validations. Here is how we do it, if it is required.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec42"/>Using IssueManager to create the issue</h3></div></div></div><a id="id1209" class="indexterm"/><a id="id1210" class="indexterm"/><p>Follow these steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Initialize an issue object using the<a id="id1211" class="indexterm"/> <code class="literal">IssueFactory</code> class:<div><pre class="programlisting">MutableIssue issue = ComponentManager.getInstance().getIssueFactory().getIssue();</pre></div></li><li class="listitem">Set all the fields required on the issue object:<div><pre class="programlisting">issue.setProjectId(10100L);
issue.setIssueTypeId("8");
issue.setAssigneeId("jobinkk");</pre></div></li><li class="listitem">Create the issue using <code class="literal">IssueManager:</code><div><pre class="programlisting">GenericValue createdIssue = ComponentManager.getInstance().getIssueManager().createIssue(user, issue);</pre></div></li><li class="listitem">Handle <code class="literal">CreateException</code><a id="id1212" class="indexterm"/> to capture any errors.</li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec77"/>Creating subtasks on an issue</h1></div></div></div><a id="id1213" class="indexterm"/><a id="id1214" class="indexterm"/><a id="id1215" class="indexterm"/><p>In this recipe, we will see how to create a subtask on an existing issue programmatically.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec225"/>How to do it...</h2></div></div></div><p>There are two steps in creating a subtask:</p><div><ol class="orderedlist arabic"><li class="listitem">Create an issue object. A subtask<a id="id1216" class="indexterm"/> is nothing but an issue object in the backend. The only difference is that it has a parent issue associated with it. So, when we create a subtask issue object, we will have to define the parent issue in addition to what we normally do while creating a normal issue.</li><li class="listitem">Link the newly created subtask issue to the parent issue.</li></ol></div><p>Let's see the steps in more detail:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the subtask issue object similar to how we created the issue in the previous recipe. Here, the <code class="literal">IssueInputParameters</code> is constructed (after changing the methods like <a id="id1217" class="indexterm"/><code class="literal">setIssueTypeId()</code> appropriately).<p>For this issue, we will use the <code class="literal">validateSubTaskCreate</code> method<a id="id1218" class="indexterm"/> instead of <code class="literal">validateCreate</code>, which takes an extra parameter <code class="literal">parentId</code>.</p><div><pre class="programlisting">CreateValidationResult createValidationResult = issueService.validateSubTaskCreate(user, parent.getId(), issueInputParameters);</pre></div><p>Here, parent is the issue object on which we are creating the subtask.</p></li><li class="listitem">Create an issue after checking for errors, as we have seen before.<div><pre class="programlisting">if (createValidationResult.isValid()) {
  IssueResult createResult = issueService.create(user, createValidationResult);
}</pre></div></li><li class="listitem">Create a link between the newly created subtask issue and the parent issue:<div><ol class="orderedlist loweralpha"><li class="listitem">Get an instance of <code class="literal">SubTaskManager</code>. You can either inject it in the constructor or get it from <code class="literal">ComponentManager</code>.<div><pre class="programlisting">SubTaskManager subTaskManager = ComponentManager.getInstance().getSubTaskManager();</pre></div></li><li class="listitem">Create the subtask link.<div><pre class="programlisting">subTaskManager.createSubTaskIssueLink(parent, createResult.getIssue(), user);</pre></div></li></ol></div></li><li class="listitem">The subtask should now be created with a link back to the original parent issue.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec226"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating an Issue from your plugin</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec78"/>Updating an issue</h1></div></div></div><a id="id1219" class="indexterm"/><a id="id1220" class="indexterm"/><p>In this recipe, let's look at editing an existing issue.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec227"/>How to do it...</h2></div></div></div><p>Let's assume that we have an existing issue object. We will just modify the <code class="literal">Summary</code> to a new summary. Following are the steps to do the same:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">IssueInputParameters</code> object<a id="id1221" class="indexterm"/> with the input fields that need to be modified:<div><pre class="programlisting">IssueInputParameters issueInputParameters = new IssueInputParametersImpl();issueInputParameters.setSummary("Modified Summary");</pre></div><p>In JIRA 4.1.x version, there is a bug, because of which we need to populate <code class="literal">IssueInputParameters</code> with all the current fields on the issue along with the modified field to make sure the existing values are not lost in an update. However, it is resolved in JIRA 4.2+ and hence the previous code is enough to modify the summary alone.</p><p>Still, if you do not want to retain the existing values and just want the summary on the issue to be updated, you can set the <code class="literal">retainExistingValuesWhenParameterNotProvided</code> flag<a id="id1222" class="indexterm"/> as shown:</p><div><pre class="programlisting">issueInputParameters.setRetainExistingValuesWhenParameterNotProvided(false);</pre></div></li><li class="listitem">Validate the input parameters using <code class="literal">IssueService</code>:<div><pre class="programlisting">UpdateValidationResult updateValidationResult = issueService.validateUpdate(user, issue.getId(), issueInputParameters);</pre></div><p>Here, the issue is the existing issue object.</p></li><li class="listitem">If <code class="literal">updateValidationResult</code> is valid, update the issue:<div><pre class="programlisting">if (updateValidationResult.isValid()) {
    IssueResult updateResult = issueService.update(user, updateValidationResult);
}</pre></div><p>If it is not valid, handle the errors as we did while creating the issue.</p></li><li class="listitem"><a id="id1223" class="indexterm"/><a id="id1224" class="indexterm"/>Validate the <code class="literal">updateResult</code> and handle the error if any. If it is not valid, the updated issue object can be retrieved as:<div><pre class="programlisting">MutableIssue updatedIssue = updateResult.getIssue();</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec79"/>Deleting an issue</h1></div></div></div><a id="id1225" class="indexterm"/><a id="id1226" class="indexterm"/><p>In this recipe, let us look at deleting an issue programmatically.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec228"/>How to do it...</h2></div></div></div><p>Let us assume that we have an existing issue object. For deletion as well, we will use the <code class="literal">IssueService</code> class<a id="id1227" class="indexterm"/>. Following are the steps to do it:</p><div><ol class="orderedlist arabic"><li class="listitem">Validate the delete operation on the issue using <code class="literal">IssueService</code><div><pre class="programlisting">DeleteValidationResult deleteValidationResult = issueService.validateDelete(user, issue.getId());</pre></div><p>Here, the issue is the existing issue object that needs to be deleted.</p></li><li class="listitem">If <code class="literal">deleteValidationResult</code> is valid, invoke the delete operation:<div><pre class="programlisting">ErrorCollection deleteErrors = issueService.delete(user, deleteValidationResult);</pre></div></li><li class="listitem">If the <code class="literal">deleteValidationResult</code> is invalid, handle the errors appropriately.</li><li class="listitem">Confirm whether the deletion was successful by checking <code class="literal">deleteErrors </code>ErrorCollection.<div><pre class="programlisting">if (deleteErrors.hasAnyErrors()){
  Collection&lt;String&gt; errorMessages = deleteErrors.getErrorMessages();
  for (String errorMessage : errorMessages) {
    System.out.println(errorMessage);
  }
} else {
  System.out.println("Deleted Succesfully!");
}</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec80"/>Adding new issue operations</h1></div></div></div><a id="id1228" class="indexterm"/><a id="id1229" class="indexterm"/><p>In this recipe, we will look at adding new operations to an issue. The existing issue operations include <strong>Edit</strong> <strong>Issue</strong>, <strong>Clone</strong> <strong>Issue</strong>, and so on, and most of the time, people tend to look for similar operations with variations or entirely new operations that they can perform on an issue.</p><p>Prior to JIRA 4.1, the issue operations were added using the Issue Operations Plugin Module (<a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module">http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module</a>). But since JIRA 4.1, new issue operations are added using <strong>Web Item Plugin Module</strong> (<a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module">http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module</a>).</p><p>A <strong>Web</strong> <strong>Item</strong> <strong>Plugin</strong> module is a generic module that is used to define links in various application menus. One such menu is the issue operations menu. We will see more about the web items module and how it can be used to enhance the UI, later in this book; so, in this recipe, we will only concentrate on using the web-item module to create issue operations.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec229"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using Atlassian Plugin SDK.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec230"/>How to do it...</h2></div></div></div><a id="id1230" class="indexterm"/><a id="id1231" class="indexterm"/><p>Creating a web item is pretty easy! All we need to do is to place it in the appropriate section. There are already defined web sections in JIRA and we can add more sections using the <strong>Web</strong> <strong>Section</strong> module, if needed.</p><p>Let us create a new operation that lets us administer the project of an issue when we are on the view issue page. All we need here is to add an operation that takes us to the <strong>Administer</strong> <strong>Project</strong> page. Following are the steps to create the new operation:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the web section where the new operation should be placed.<p>For issue operations, JIRA already has multiple web sections<a id="id1232" class="indexterm"/> defined. We can add our new operation on any one of the sections. The following is a diagram from the Atlassian documentation detailing on each of the available web sections for the issue operations:</p><div><img src="img/1803-07-01.jpg" alt="How to do it..."/></div></li><li class="listitem"><a id="id1233" class="indexterm"/><a id="id1234" class="indexterm"/>For example, if we want to add a new operation along with <strong>Move</strong>, <strong>Link</strong>, and so on, we need to add the new web item under the <strong>operations-operations</strong> section. If you are rather hoping to add it right at the top, along with <strong>Edit</strong>, <strong>Assign</strong>, and <strong>Comment</strong>, the section must be <strong>operations-top-level</strong>. We can reorder the operation using the <code class="literal">weight</code> attribute.</li><li class="listitem">Define the web item module in the plugin descriptor with the section identified in the previous step! For our example, the module definition in <code class="literal">atlassian-plugin.xml</code> will look like the following:<div><pre class="programlisting">&lt;web-item key="manage-project" name="Manage Project" section="operations-operations" weight="100"&gt;
  &lt;label&gt;Manage Project&lt;/label&gt;
  &lt;tooltip&gt;Manages the Project  in which the issue belongs &lt;/tooltip&gt;
  &lt;link linkId="manage-project-link"&gt;
    /secure/project/ViewProject.jspa?pid=${issue.project.id}
  &lt;/link&gt;
&lt;/web-item&gt;</pre></div><p>As you can see, it has a unique <code class="literal">key</code> and a human-readable <code class="literal">name</code>. The section here is <code class="literal">operations-operations</code>. The <code class="literal">weight</code> attribute is used to reorder the operations as we saw earlier and here we use weight as 100 to put it at the bottom of the list.</p><p>The <code class="literal">label</code> is the name of the operation that will appear to the user. We can add a <code class="literal">tooltip</code> as well, which can have a friendly description of the operation. The next part, that is, <code class="literal">link</code> attribute, is the most important one as that links us to the operation that we want to perform. Essentially, it is just a link and hence you can use it to redirect to anywhere, the Atlassian site, for example.</p><p>In our example, we need to take the user to the <em>administer</em> project area. Luckily, in this case, we know the action to be invoked as it is an existing action in JIRA. All we need to do is to invoke the <code class="literal">ViewProject</code> action by passing the project ID as pid. The issue object is available on the view issue page as <code class="literal">$issue</code> and hence we can retrieve the project ID on the link as <code class="literal">${issue.project.id}</code>.</p><p>In cases where we need to do new things, we will have to create an action by ourselves and point the link to the same. We will see more about creating new actions and extending actions later in the book.</p></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec231"/>How it works...</h2></div></div></div><a id="id1235" class="indexterm"/><a id="id1236" class="indexterm"/><p>At runtime, you will see a new operation on the <strong>View</strong> <strong>Issue</strong> page on the <strong>More</strong> <strong>Actions</strong> drop-down menu, as shown in the next screenshot:</p><div><img src="img/1803-07-02.jpg" alt="How it works..."/></div><p>After clicking on the link, the <strong>Administer</strong> <strong>Project</strong> screen will appear, as expected. As you might notice, the URL is populated with the correct <code class="literal">pid</code> from the expression <code class="literal">${issue.project.id}</code>.</p><a id="id1237" class="indexterm"/><a id="id1238" class="indexterm"/><p>Also, just change the section or weight and see how the operation appears at various places on the screen!</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec232"/>There's more...</h2></div></div></div><p>Prior to JIRA 4.1, The <strong>Issue</strong> <strong>Operations</strong> module was used in creating new issue operations. It is outside the scope of the book, though you can find the details in the Atlassian documentation at: <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module">http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module</a> .</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec233"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Extending</em> a <em>Webwork</em> <em>action</em> <em>in</em> <em>JIRA</em></li><li class="listitem" style="list-style-type: disc"><em>Adding</em> <em>new</em> <em>Links</em> <em>in</em> <em>the</em> <em>UI</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec81"/>Conditions on issue operations</h1></div></div></div><a id="id1239" class="indexterm"/><a id="id1240" class="indexterm"/><p>When new operations are created, it is often a requirement to hide them or show them, based on the permissions or state of the issue or something else. JIRA allows conditions to be added while defining the web items, and when the conditions are not satisfied, the web item won't show up!</p><p>In this recipe, we will lock down the new issue operation we created in the previous recipe to <em>Project</em> <em>Administrators</em> exclusively.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec234"/>Getting ready...</h2></div></div></div><p>Create the <strong>Manage</strong> <strong>Project</strong> issue operation, as explained in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec235"/>How to do it...</h2></div></div></div><p>Following are the steps to add a new condition to an issue operation's web item:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">condition</code> class. The class should implement the <code class="literal">com.atlassian.plugin.web.Condition</code> interface, but it is recommended to extend <code class="literal">com.atlassian.jira.plugin.webfragment.conditions.AbstractIssueCondition</code> when creating an issue condition.<p>While extending <code class="literal">AbstractIssueCondition</code>, we will have to implement the <code class="literal">shouldDisplay</code> method<a id="id1241" class="indexterm"/>, as shown here:</p><div><pre class="programlisting">public class AdminCondition extends AbstractIssueCondition {
  private final PermissionManager permissionManager;
  
  public AdminCondition(PermissionManager permissionManager) {
    this.permissionManager = permissionManager;
  }
  
  @Override
  public boolean shouldDisplay(User user, Issue issue, JiraHelper jiraHelper) {
        return this.permissionManager.hasPermission(Permissions.PROJECT_ADMIN, issue.getProjectObject(), user);
  }
}</pre></div><p>Here, a <code class="literal">true</code> value is returned if the user has the <code class="literal">PROJECT_ADMIN </code>permission on the project. That is all we need on the <code class="literal">condition</code> class.</p></li><li class="listitem">Include the <code class="literal">condition</code> in the web item.<div><pre class="programlisting">&lt;web-item key="manage-project" name="Manage Project" section="operations-operations" weight="100"&gt;
  &lt;label&gt;Manage Project&lt;/label&gt;
  &lt;tooltip&gt;Manages the Project  in which the issue belongs &lt;/tooltip&gt;
  &lt;link linkId="manage-project-link"&gt;
    /secure/project/ViewProject.jspa?pid=${issue.project.id}
  &lt;/link&gt;
  &lt;condition class="com.jtricks.conditions.AdminCondition"/&gt;
&lt;/web-item&gt;</pre></div><p>It is possible to invert a condition by using the invert flag<a id="id1242" class="indexterm"/>, as shown:</p><div><pre class="programlisting">&lt;condition class="com.jtricks.conditions.AdminCondition" invert="true"/&gt;</pre></div><a id="id1243" class="indexterm"/><a id="id1244" class="indexterm"/><p>Condition elements can also take optional parameters, as shown:</p><div><pre class="programlisting">&lt;condition class="com.atlassian.jira.plugin.webfragment.conditions.JiraGlobalPermissionCondition"&gt;
   &lt;param name="permission"&gt;sysadmin&lt;/param&gt;
&lt;/condition&gt;</pre></div><p>The parameters can be retrieved in the <code class="literal">condition</code> class by overriding the <code class="literal">init(Map params)</code> method. Here, <code class="literal">params</code> is a map of string key/value pairs that hold these parameters, in which case, the Map will have permission as the key, and the value passed (sysadmin in the example) can be accessed using the key and can then be used in passing or failing the condition.</p><p>For example, the following code in the conditions class will get you the appropriate permission type.</p><div><pre class="programlisting">int permission = Permissions.getType((String) params.get("permission")); 
// Permissions.SYSTEM_ADMIN in this case</pre></div><p>It is also possible to combine multiple conditions using the <code class="literal">conditions</code> element. <code class="literal">conditions</code> element will have multiple condition elements connected through logical AND<a id="id1245" class="indexterm"/>
<a id="id1246" class="indexterm"/> (default) or OR condition.</p><p>For example, if we want to make our example operation available to both project administrators<a id="id1247" class="indexterm"/> as well JIRA System Administrators<a id="id1248" class="indexterm"/>, we can do it using an <code class="literal">OR</code> condition, as shown:</p><div><pre class="programlisting">&lt;conditions type="OR"&gt;
  &lt;condition class="com.atlassian.jira.plugin.webfragment.conditions.JiraGlobalPermissionCondition"&gt;
  &lt;param name="permission"&gt;sysadmin&lt;/param&gt;
  &lt;/condition&gt;
  &lt;condition class="com.jtricks.conditions.AdminCondition"/&gt;
&lt;/conditions&gt;</pre></div></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec236"/>How it works...</h2></div></div></div><a id="id1249" class="indexterm"/><a id="id1250" class="indexterm"/><p>Once the plugin is deployed, we can go and check the operation on the View Issue Page, as we did in the previous chapter. If you are a Project Administrator (or a JIRA's system admin, depending on which condition you used), you will see the operation. If the user doesn't have the permissions, the operation won't be shown.</p><p>For example, if we added a <strong>Manage</strong> <strong>Project</strong> issue operation and limited it only to project admin, and a <strong>New</strong> <strong>Manage</strong> <strong>Project</strong> operation, and limited it to project admin or JIRA's system admin, a logged in <strong>Project</strong> <strong>Admin</strong> would see both the operations, but a logged in <strong>Admin</strong> will see only the latter operation as shown in the following screenshot:</p><div><img src="img/1803-07-03.jpg" alt="How it works..."/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec82"/>Working with attachments</h1></div></div></div><a id="id1251" class="indexterm"/><p>Attachments feature is a useful feature in JIRA, and it sometimes helps to manage the attachments on an issue through the JIRA APIs. In this recipe, we will learn how to work with attachments using the JIRA API.</p><p>There are three major operations that can be done on attachments - Create<a id="id1252" class="indexterm"/>, Read<a id="id1253" class="indexterm"/>
<a id="id1254" class="indexterm"/>, and Delete. We will see each of them in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec237"/>Getting ready...</h2></div></div></div><p>Make sure the attachments are enabled in your JIRA instance. You can do this from <strong>Administration</strong> <strong>|</strong> <strong>Global</strong> <strong>Settings</strong> <strong>|</strong> <strong>Attachments</strong>, as mentioned at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments">http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec238"/>How to do it...</h2></div></div></div><a id="id1255" class="indexterm"/><p>All the operations on the attachments can be performed using the <code class="literal">AttachmentManager</code><a id="id1256" class="indexterm"/> API. The <code class="literal">AttachmentManager</code> can be retrieved either by injecting it in the constructor or from the <code class="literal">ComponentManager</code> class<a id="id1257" class="indexterm"/>, as shown:.</p><div><pre class="programlisting">AttachmentManager attachmentManager = ComponentManager.getInstance().getAttachmentManager();</pre></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec43"/><strong>Creating an attachment</strong></h3></div></div></div><a id="id1258" class="indexterm"/><p>An attachment can be created on an issue using the <code class="literal">createAttachment</code> method<a id="id1259" class="indexterm"/> on the <code class="literal">AttachmentManager</code>, as shown:</p><div><pre class="programlisting">ChangeItemBean changeBean = attachmentManager.createAttachment(new File(fileName), newFileName, "text/plain", user, issue.getGenericValue());</pre></div><a id="id1260" class="indexterm"/><p>The following are the arguments:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">fileName</code><a id="id1261" class="indexterm"/> here needs to be the full path to the file on the server. You can also create a File object by uploading from the client machine, depending on the requirement.</li><li class="listitem" style="list-style-type: disc"><code class="literal">newFileName</code><a id="id1262" class="indexterm"/> is the name with which the file will be attached to the issue, and it can be different from the original filename.</li><li class="listitem" style="list-style-type: disc">The third parameter is the <code class="literal">contentType</code><a id="id1263" class="indexterm"/> of the file. In this case, we are uploading a text file and hence the content type is text/plain.</li><li class="listitem" style="list-style-type: disc"><code class="literal">user</code> <a id="id1264" class="indexterm"/><a id="id1265" class="indexterm"/>is the user who is attaching the file</li><li class="listitem" style="list-style-type: disc"><code class="literal">issue</code> is the issue to which the file will be attached</li></ul></div><p>If you also want to set a list of properties on an attachment as a key/value pair and create the attachment on a specific <strong>time</strong>, it can be done using the overloaded method <code class="literal">createAttachment</code><a id="id1266" class="indexterm"/>, which takes two extra parameters: <code class="literal">attachmentProperties</code>, a Map containing the key/value properties and <code class="literal">createdTime</code> which is of type <code class="literal">java.util.Date</code>.</p><a id="id1267" class="indexterm"/><p>These properties will be stored in the database using <code class="literal">PropertySet</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec44"/><strong>Reading attachments on an issue</strong></h3></div></div></div><a id="id1268" class="indexterm"/><a id="id1269" class="indexterm"/><a id="id1270" class="indexterm"/><p><code class="literal">AttachmentManager</code> has a method to retrieve the list of attachments, of type <code class="literal">com.atlassian.jira.issue.attachment.Attachment</code>, available on an issue. The following is how we do it:</p><div><pre class="programlisting">List&lt;Attachment&gt; attachments = this.attachmentManager.getAttachments(issue);
for (Attachment attachment : attachments) {
  System.out.println("Attachment: "+attachment.getFilename()+" attached by "+attachment.getAuthor());
}</pre></div><p>The object attachment holds all the information of the attachment, including any properties set during the creation of the attachment.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec45"/><strong>Deleting an attachment</strong></h3></div></div></div><a id="id1271" class="indexterm"/><p>All you need to do here is to retrieve the attachment object that needs to be deleted and invoke the <code class="literal">deleteAttachment</code> method<a id="id1272" class="indexterm"/> on <code class="literal">AttachmentManager</code>.</p><div><pre class="programlisting">this.attachmentManager.deleteAttachment(attachment);</pre></div><p>Here, attachment is an attachment that can be retrieved using the getAttachment(id) method or by iterating on the list of attachments retrieved above.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec239"/>There's more...</h2></div></div></div><p><code class="literal">AttachmentManager</code><a id="id1273" class="indexterm"/> also has other useful methods like <code class="literal">attachmentsEnabled()</code><a id="id1274" class="indexterm"/>, <code class="literal">isScreenshotAppletEnabled()</code><a id="id1275" class="indexterm"/>, <code class="literal">isScreenshotAppletSupportedByOS()</code><a id="id1276" class="indexterm"/>, and so on, to check whether the respective functionality is enabled or not.</p><p>Check out: <a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html</a> for a full list of available methods.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec83"/>Time tracking and worklog management</h1></div></div></div><a id="id1277" class="indexterm"/><p>Time tracking<a id="id1278" class="indexterm"/> is one of the biggest pluses for any issue tracking system. JIRA's time tracking is highly configurable and gives plenty of options to manage the work done and the remaining time.</p><p>Even though the time tracking in JIRA can be done using the JIRA UI, many users want to do it from the customized pages or third-party applications or plugins. In this recipe, we will see how to do time tracking using the JIRA APIs.</p><a id="id1279" class="indexterm"/><a id="id1280" class="indexterm"/><p>Before we start, each of the operations on worklogs, namely, create, edit, or delete, have different modes. Whenever one of these operations is performed, we can adjust the remaining amount of work to be done in the following ways:</p><div><ol class="orderedlist arabic"><li class="listitem">Let JIRA adjust the remaining work automatically.<p>For example, if the remaining estimate is 2 hours and if we log 30 minutes, JIRA will automatically adjust the remaining estimate to 1 hour 30 minutes.</p></li><li class="listitem">Enter a new remaining estimate time while performing the operations.<p>For example, if the remaining estimate is 2 hours and if we log 30 minutes, we can force JIRA to change the remaining estimate to 1 hour (instead of the automatically calculated 1 hour 30 minutes).</p></li><li class="listitem">Adjust the remaining estimate or in other words reduce a specific amount of time from the remaining estimate<p>For example, if the remaining estimate is 2 hours and if we log 30 minutes, we can force JIRA to reduce the remaining estimate by 1 hour 30 minutes (instead of automatically reducing the logged 30 minutes). When we do that, the remaining estimate will come out to be 30 minutes.</p></li><li class="listitem">Leave the remaining estimate as it is.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec240"/>Getting ready...</h2></div></div></div><a id="id1281" class="indexterm"/><p>Make sure time tracking is turned on as explained at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking">http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking</a>. It can be enabled from the <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Time</strong> <strong>Tracking</strong> menu.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec241"/>How to do it...</h2></div></div></div><p>Worklogs<a id="id1282" class="indexterm"/>
<a id="id1283" class="indexterm"/> in JIRA can be managed using the <code class="literal">WorklogService</code> class<a id="id1284" class="indexterm"/>. It does all the major operations like creating worklogs, updating them, or deleting them, and that too, in all the four different modes we have seen earlier.</p><p>We will see how to create worklogs, or in other words, log work in the following four modes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id1285" class="indexterm"/><a id="id1286" class="indexterm"/>Auto adjusting the remaining estimate</li><li class="listitem" style="list-style-type: disc">Logging work and retaining the remaining estimate</li><li class="listitem" style="list-style-type: disc">Logging work with a new remaining estimate</li><li class="listitem" style="list-style-type: disc">Logging work and adjusting the remaining estimate by a value</li></ul></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec46"/>Auto adjusting the remaining estimate</h3></div></div></div><div><ol class="orderedlist arabic"><li class="listitem"><a id="id1287" class="indexterm"/><a id="id1288" class="indexterm"/>Create the JIRA Service Context for the user who is logging work.<div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);</pre></div></li><li class="listitem">Create a <code class="literal">WorklogInputParametersImpl.Builder</code> object to create the parameters needed for the worklog creation.<div><pre class="programlisting">final WorklogInputParametersImpl.Builder builder = WorklogInputParametersImpl.issue(issue).timeSpent(timeSpent).startDate(new Date()).comment(null).groupLevel(null).roleLevelId(null);</pre></div><p>Here, the issue is the issue on which work is logged, and <code class="literal">timeSpent</code> is the time that we are going to log in. <code class="literal">timeSpent</code> is a String that represents the format in which time is entered in JIRA , that is, <code class="literal">*w *d *h *m</code> (representing weeks, days, hours, and minutes, where * can be any number).</p><p><code class="literal">startDate</code> here can be the date from where the work has started. We can also optionally add comments and set the worklog visibility to certain groups or project roles! Set these parameters as null when the worklog is visible to all.</p></li><li class="listitem">Create the <code class="literal">WorklogInputParameters</code> object from the builder and validate it using the <code class="literal">WorklogService</code>.<div><pre class="programlisting">WorklogResult result = this.worklogService.validateCreate(jiraServiceContext, builder.build());</pre></div></li><li class="listitem">Create the worklog using <code class="literal">WorklogService</code>.<div><pre class="programlisting">Worklog worklog = this.worklogService.createAndAutoAdjustRemainingEstimate(jiraServiceContext, result, false);</pre></div><p>Here, as you can see, the method invoked is <code class="literal">createAndAutoAdjustRemainingEstimate</code>, which will create the worklog and automatically adjust the remaining estimate on the issue.</p><p>The method takes as input the service context we created, the <code class="literal">WorklogResult</code> object after validating the input parameters, and a Boolean which will be used to dispatch an event, if needed. When the Boolean value is true, the <strong>Work</strong> <strong>Logged</strong> <strong>On</strong> <strong>Issue</strong> event is fired.</p></li></ol></div><p>With this, the work will be logged on the issue.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec47"/>Logging work and retaining the remaining estimate</h3></div></div></div><a id="id1289" class="indexterm"/><a id="id1290" class="indexterm"/><p>Here, the first three steps are similar to what was discussed in the <em>Auto</em> <em>adjusting</em> <em>remaining</em> <em>estimate</em> section. The only difference is that the method invoked on <code class="literal">WorklogService</code> is <code class="literal">createAndRetainRemainingEstimate</code> instead of <code class="literal">createAndAutoAdjustRemainingEstimate</code>. The full code is as shown:</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
final WorklogInputParametersImpl.Builder builder = WorklogInputParametersImpl.issue(issue).timeSpent(timeSpent).startDate(new Date()).comment(null).groupLevel(null).roleLevelId(null);
WorklogResult result = this.worklogService.validateCreate(jiraServiceContext, builder.build());
Worklog worklog = this.worklogService.createAndRetainRemainingEstimate(jiraServiceContext, result, false);</pre></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec48"/>Logging work with a new remaining estimate</h3></div></div></div><a id="id1291" class="indexterm"/><p>Here the first two steps are similar to what was discussed in the <em>Auto</em> <em>adjusting</em> <em>remaining</em> <em>estimate</em> section.</p><div><ol class="orderedlist arabic"><li class="listitem">Create the JIRA Service Context for the user who is logging work.<div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);</pre></div></li><li class="listitem">Create a <code class="literal">WorklogInputParametersImpl.Builder</code> object to create the parameters needed for the worklog creation.<div><pre class="programlisting">final WorklogInputParametersImpl.Builder builder = WorklogInputParametersImpl.issue(issue).timeSpent(timeSpent)      .startDate(new Date()).comment(null).groupLevel(null).roleLevelId(null);</pre></div></li><li class="listitem">Create the New Estimate Input Parameters from the Builder object.<div><pre class="programlisting">final WorklogNewEstimateInputParameters params = builder.newEstimate(newEstimate).buildNewEstimate();</pre></div><p>Here, we specify the <code class="literal">newEstimate</code>, which is a String representation similar to <code class="literal">timeSpent</code>. The <code class="literal">newEstimate</code> will be set as the remaining estimate on the issue.</p></li><li class="listitem">Create the <code class="literal">WorklogResult</code> from <code class="literal">WorklogNewEstimateInputParameters</code> using <code class="literal">WorklogService</code>:<div><pre class="programlisting">WorklogResult result = this.worklogService.validateUpdateWithNewEstimate(jiraServiceContext, params);</pre></div><p>The result here will be an instance of <code class="literal">WorklogNewEstimateResult</code>, which will be used in the next step!</p></li><li class="listitem">Create the worklog using <code class="literal">WorklogService</code>.<div><pre class="programlisting">Worklog worklog = this.worklogService.createWithNewRemainingEstimate(jiraServiceContext, (WorklogNewEstimateResult) result, false);</pre></div><a id="id1292" class="indexterm"/><p>Here, the method used is <code class="literal">createWithNewRemainingEstimate</code>, which sets the <code class="literal">newEstimate</code> as the remaining estimate on the issue, after logging the work using <code class="literal">timeSpent</code>! As you can see, the result object is converted to <code class="literal">WorklogNewEstimateResult</code>.</p></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec49"/>Logging work and adjusting the remaining estimate by a value</h3></div></div></div><a id="id1293" class="indexterm"/><a id="id1294" class="indexterm"/><p>Here the process is much similar to the above. The only difference is that the <code class="literal">adjustmentAmount</code> method is used on Builder instead of <code class="literal">newEstimate</code> and <code class="literal">validateCreateWithManuallyAdjustedEstimate</code> is used on <code class="literal">WorklogService</code> to create the worklog. Also, the <code class="literal">WorklogResult</code> is an instance of <code class="literal">WorklogAdjustmentAmountResult</code>.</p><p>The code is as follows:</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
final WorklogInputParametersImpl.Builder builder = WorklogInputParametersImpl.issue(issue).timeSpent(timeSpent).startDate(new Date()).comment(null).groupLevel(null).roleLevelId(null);
final WorklogAdjustmentAmountInputParameters params = builder.adjustmentAmount(estimateToReduce).buildAdjustmentAmount();
WorklogResult result = worklogService.validateCreateWithManuallyAdjustedEstimate(jiraServiceContext, params);
Worklog worklog = this.worklogService.createWithManuallyAdjustedEstimate(jiraServiceContext, (WorklogAdjustmentAmountResult) result, false);</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec242"/>How it works...</h2></div></div></div><p>Once we create or update the worklogs using the <code class="literal">WorklogService</code> API, the changes will be reflected on the issue under the <strong>Work</strong> <strong>Log</strong> tab, as shown in the following screenshot:</p><div><img src="img/1803-07-04.jpg" alt="How it works..."/></div><a id="id1295" class="indexterm"/><a id="id1296" class="indexterm"/><p>You can also see that the graphical representation of time tracking reflects these changes.</p><p>When a worklog is deleted, it appears on the <strong>Change</strong> <strong>history</strong> as shown:</p><div><img src="img/1803-07-05.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec243"/>There's more</h2></div></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec50"/>Updating worklogs</h3></div></div></div><a id="id1297" class="indexterm"/><a id="id1298" class="indexterm"/><p>Updating worklogs is similar to the creating them in many ways. Here, we pass the ID of the <code class="literal">Worklog</code> object to be updated instead of the issue we pass while creating a worklog. And, of course, the methods invoked on <code class="literal">WorklogService</code> are different. The following is the code to update a given <strong>Worklog</strong> for the first mode where the remaining estimate is auto adjusted.</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
final WorklogInputParametersImpl.Builder builder = WorklogInputParametersImpl.worklogId(worklog.getId()).timeSpent(timeSpent).startDate(new Date()).comment(null).groupLevel(null).roleLevelId(null);
WorklogResult result = this.worklogService.validateUpdate(jiraServiceContext, builder.build());
Worklog updatedLog = this.worklogService.updateAndAutoAdjustRemainingEstimate(jiraServiceContext, result, false);</pre></div><p>As you can see, a <em>builder</em> is created by passing the worklog ID, which is unique across issues. The <code class="literal">WorklogResult</code> here is created using the <code class="literal">validateUpdate</code> method<a id="id1299" class="indexterm"/> and the worklog is finally updated using the <code class="literal">updateAndAutoAdjustRemainingEstimate</code> method<a id="id1300" class="indexterm"/>.</p><p>The other modes are also similar to how we created the worklogs. Let us quickly see how to update a worklog with a new remaining estimate:</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
final WorklogInputParametersImpl.Builder builder = WorklogInputParametersImpl.worklogId(worklog.getId()).timeSpent(timeSpent).startDate(new Date()).comment(null).groupLevel(null).roleLevelId(null);
final WorklogNewEstimateInputParameters params = builder.newEstimate(newEstimate).buildNewEstimate();
WorklogResult result = this.worklogService.validateUpdateWithNewEstimate(jiraServiceContext, params);
Worklog updatedLog = this.worklogService.updateWithNewRemainingEstimate(jiraServiceContext, (WorklogNewEstimateResult) result, false);</pre></div><p>The above looks pretty familiar, doesn't it? It is similar to creating a worklog with a new estimate, except that we call the respective update methods, as discussed before.</p><a id="id1301" class="indexterm"/><a id="id1302" class="indexterm"/><p>We can update a worklog by retaining the estimate and also adjust it by a specified amount of time from the remaining estimate in the same way.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec51"/>Deleting worklogs</h3></div></div></div><a id="id1303" class="indexterm"/><p>Deleting a worklog is slightly different and maybe easier than creating or updating one, as it doesn't involve building the input parameters.</p><div><div><div><div><h4 class="title"><a id="ch07lvl4sec11"/>Auto Adjusting remaining estimate</h4></div></div></div><a id="id1304" class="indexterm"/><p>All we need here is the worklog ID and to create the JIRA Service Context. The code is as shown below:</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
WorklogResult worklogResult = worklogService.validateDelete(jiraServiceContext, worklog.getId());
worklogService.deleteAndAutoAdjustRemainingEstimate(jiraServiceContext, worklogResult, false);</pre></div><p>Here, the <code class="literal">validateDelete</code> method takes the worklog ID as input and creates a <code class="literal">WorklogResult</code>, which is then used in the <code class="literal">deleteAndAutoAdjustRemainingEstimate</code> method.</p></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec12"/>Deleting a worklog and retaining the remaining estimate</h4></div></div></div><a id="id1305" class="indexterm"/><a id="id1306" class="indexterm"/><p>This is done in much the same way as mentioned in the previous section, expect that the <code class="literal">deleteAndRetainRemainingEstimate</code> method is used instead of <code class="literal">deleteAndAutoAdjustRemainingEstimate</code>.</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
WorklogResult worklogResult = worklogService.validateDelete(jiraServiceContext, worklog.getId());
worklogService.deleteAndRetainRemainingEstimate(jiraServiceContext, worklogResult, false);</pre></div></div><div><div><div><div><h4 class="title"><a id="ch07lvl4sec13"/>Deleting a worklog with a new remaining estimate</h4></div></div></div><a id="id1307" class="indexterm"/><p>As mentioned before, we don't create the input parameters while deleting worklogs. Instead, the <code class="literal">newEstimate</code> is used to create <code class="literal">WorklogResult</code>, which is an instance of <code class="literal">WorklogNewEstimateResult</code>, while validating. The code is as follows:</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
WorklogResult worklogResult = worklogService.validateDeleteWithNewEstimate(jiraServiceContext, worklog.getId(), newEstimate);
worklogService.deleteWithNewRemainingEstimate(jiraServiceContext, (WorklogNewEstimateResult) worklogResult, false);Deleting a worklog and adjusting the remaining estimate</pre></div><a id="id1308" class="indexterm"/><a id="id1309" class="indexterm"/><p>This is also pretty much the same as mentioned in the previous section, except for the method names.</p><div><pre class="programlisting">JiraServiceContext jiraServiceContext = new JiraServiceContextImpl(user);
WorklogResult worklogResult = worklogService.validateDeleteWithManuallyAdjustedEstimate(jiraServiceContext, worklog.getId(), adjustmentAmount);
worklogService.deleteWithManuallyAdjustedEstimate(jiraServiceContext, (WorklogAdjustmentAmountResult) worklogResult, false);</pre></div><p>Here, <code class="literal">adjustmentAmount</code> is the value that is used to increase the remaining estimate on the issue.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec84"/>Working with comments on issues</h1></div></div></div><p>In this recipe, we will see how to manage commenting on issues using the JIRA API.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec244"/>How to do it...</h2></div></div></div><a id="id1310" class="indexterm"/><a id="id1311" class="indexterm"/><p>JIRA uses the <code class="literal">CommentService</code> class<a id="id1312" class="indexterm"/> to manage the comments on an issue. Let us have a look at all the three major operations—creating, editing, and deleting comments. We will also have a look at how to restrict the comment visibility to a specific group of people or to a project role.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec52"/>Creating comments on issues</h3></div></div></div><a id="id1313" class="indexterm"/><a id="id1314" class="indexterm"/><p>A comment can be added on to an issue as follows:</p><div><pre class="programlisting">Comment comment = this.commentService.create(user, issue, commentString, false, new SimpleErrorCollection());</pre></div><p>Here, <code class="literal">commentString</code> is the comment we are adding, user is the user adding the comment, and issue is the issue on which the comment is added. The fourth argument is a boolean that determines whether an event should be dispatched or not. If it is true, an <code class="literal">Issue</code> <code class="literal">Commented</code> event is thrown.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec53"/>Creating comments on an issue and restricting it to a project role or group</h3></div></div></div><p>If we need to restrict the visibility of the comments, we need to use the overridden <code class="literal">create</code> meth<a id="id1315" class="indexterm"/>
<a id="id1316" class="indexterm"/>od on the <code class="literal">CommentService</code> class that takes the role ID and group name along with the other attributes. Only one of them should be passed at one time.</p><p>In order to restrict the comment visibility to groups, the <code class="literal">Comment</code> <code class="literal">visibility</code> property under <strong>General</strong> <strong>Configuration</strong> should be set to <strong>Groups</strong> <strong>&amp;</strong> <strong>Project</strong> <strong>Roles</strong>. The default is to allow restricting comments only for project roles.</p><p>For example, the comment can be restricted to a <strong>group</strong> as follows:</p><div><pre class="programlisting">Comment comment = this.commentService.create(user, issue, commentString, group, null, false, new SimpleErrorCollection());</pre></div><p>In this group, <code class="literal">group</code> is the name of the group, and the fifth parameter (<code class="literal">null</code>) is the <code class="literal">roleId</code>.</p><p>Restricting to a <strong>role</strong> is done as follows:</p><div><pre class="programlisting">Comment comment = this.commentService.create(user, issue, commentString, null, roleId, false, new SimpleErrorCollection());</pre></div><p>In this case, the <code class="literal">group</code> is <code class="literal">null</code> and <code class="literal">roleId</code> is the unique ID of the <code class="literal">ProjectRole</code> that we need to restrict the comment to.</p><a id="id1317" class="indexterm"/><a id="id1318" class="indexterm"/><a id="id1319" class="indexterm"/><a id="id1320" class="indexterm"/><p>The Boolean to dispatch events can be used in both cases.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec54"/>Updating comments</h3></div></div></div><a id="id1321" class="indexterm"/><p>Following are the steps to update a comment:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">MutableComment</code> object from the comment to be updated<div><pre class="programlisting">MutableComment comm = this.commentService.getMutableComment(user, comment.getId(), new SimpleErrorCollection());</pre></div></li><li class="listitem">Modify the comment with the following statement:<div><pre class="programlisting">comm.setBody("New Comment");</pre></div><p>Here, we update the body of the comment, though we can also update other attributes like the author, group level, role level, and so on.</p></li><li class="listitem">Update the comment using <code class="literal">CommentService</code>:<div><pre class="programlisting">this.commentService.update(user, comm, false, new SimpleErrorCollection());</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec55"/>Deleting comments</h3></div></div></div><a id="id1322" class="indexterm"/><p>A comment can be deleted as shown:</p><div><pre class="programlisting">this.commentService.delete(new JiraServiceContextImpl(user), comment, false);</pre></div><p><code class="literal">comment</code> is the comment object to be deleted.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec85"/>Programming Change Logs</h1></div></div></div><p>Tracking changes to an issue is very important. JIRA stores all the changes that are done on an issue as change logs along with the information of who made the change and when. Sometimes, when we do custom development, we will have to update the <strong>Change</strong> <strong>History</strong> by ourselves when something changes on the issue by our plugin.</p><p>Change Histories are logged as change groups which are a group of one or more change items made by a user at any one time. Each change item will be a change made on any single field.</p><p>In this recipe, we will see how to add change logs<a id="id1323" class="indexterm"/>
<a id="id1324" class="indexterm"/> on an issue using the JIRA API.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec245"/>How to do it...</h2></div></div></div><p>Each change item in JIRA is created as a <code class="literal">ChangeItemBean</code>. <code class="literal">ChangeItemBean</code> can be of two different types—one for <strong>system</strong> fields where the field type is <code class="literal">ChangeItemBean.STATIC_FIELD</code> and another for <strong>custom</strong> fields where the field type is <code class="literal">ChangeItemBean.CUSTOM_FIELD</code>.</p><p>The following are the steps to add a Change History.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">ChangeItemBean</code> for the change that needs to be recorded for every item that is changed.<div><pre class="programlisting">ChangeItemBean changeBean = new ChangeItemBean(ChangeItemBean.STATIC_FIELD, IssueFieldConstants.SUMMARY,  "Old Summary", "New Summary");</pre></div><p>Here, the first attribute is the <code class="literal">fieldType</code> and the second one is the name of the field. For system fields of type <code class="literal">ChangeItemBean.STATIC_FIELD</code>, the name can be retrieved from <code class="literal">IssueFieldConstants</code> class. For example, <code class="literal">IssueFieldConstants.SUMMARY</code> represents the issue summary.</p><p>The third and fourth arguments are the <em>old</em> <em>value</em> and the <em>new</em> <em>value</em> of the field respectively.</p><p>As we know, some of the JIRA fields have an id value and a String value. For example, the issue Status has the status name and the corresponding status ID. In such cases, we can use an overridden constructor that also takes the old id and new id as shown below.</p><div><pre class="programlisting">ChangeItemBean changeBean = new ChangeItemBean(ChangeItemBean.STATIC_FIELD, IssueFieldConstants.STATUS,"1", "Open", "3", "In Progress");</pre></div><p>For custom fields, we use the field type <code class="literal">ChangeItemBean.CUSTOM_FIELD</code> and the custom field name. Everything else is same.</p><div><pre class="programlisting">ChangeItemBean changeBean = new ChangeItemBean(ChangeItemBean.CUSTOM_FIELD, "My Field",  "Some Old Value", "Some New Value");</pre></div><p>It is worth noting that the field name can be manipulated to give any value when the <code class="literal">fieldType</code> is <code class="literal">ChangeItemBean.CUSTOM_FIELD</code>. It is probably a useful feature when you want to programmatically add change logs that are not directly relates to a field. Say, for adding a subtask!</p><div><pre class="programlisting">ChangeItemBean changeBean = new ChangeItemBean(ChangeItemBean.CUSTOM_FIELD, "Some Heading", "Some Old Value", "Some New Value");</pre></div></li><li class="listitem">Create a change holder and add the change items in to it.<div><pre class="programlisting">IssueChangeHolder changeHolder = new DefaultIssueChangeHolder();
changeHolder.addChangeItem(changeBean);</pre></div></li><li class="listitem"><a id="id1325" class="indexterm"/><a id="id1326" class="indexterm"/>Create and store the <code class="literal">changelog</code> using the items in the <code class="literal">changeHolder</code> using <code class="literal">ChangeLogUtils</code> class.<div><pre class="programlisting">GenericValue changeLog = ChangeLogUtils.createChangeGroup(user, issue, issue, changeHolder.getChangeItems(),  false);</pre></div><p>Here <strong>user</strong> is the user making the change. The second and third arguments are the original issue and the issue after changes. You can give both the same if the change items are explicitly created and added to <code class="literal">changeHolder</code>.</p><p>But if we are modifying an issue using the setter methods, an easier way might be to pass the original issue object along with the modified issue object (object after setter methods are invoked) and set the last argument as <code class="literal">true</code> which determines whether a list of change items needs to be generated from the before and after objects. In that case, we don't need to explicitly create <code class="literal">changeItems</code> and hence the third argument can be an empty list. We can still pass additional <code class="literal">changeItems</code> if needed as the third argument in which case both the passed <code class="literal">changeItems</code> and generated <code class="literal">changeItems</code> (from issue before and after modification) will be created!</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec246"/>How it works...</h2></div></div></div><p>Once the change logs are added, they will appear in the issues change log panel, as shown in the following screenshot:</p><div><img src="img/1803-07-06.jpg" alt="How it works..."/></div><a id="id1327" class="indexterm"/><a id="id1328" class="indexterm"/><p>Notice that the highlighted <em>change</em> <em>log</em> is added even though there is no field named <strong>Some</strong> <strong>Heading</strong>. Also, see how both the ID and name are shown for the <strong>Status</strong> field!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec86"/>Programming issue links</h1></div></div></div><p>Issue linking<a id="id1329" class="indexterm"/> is another important feature in JIRA. It helps us to define the relationship between issues. In this recipe, we will see how to create links between issues and to break them using the JIRA APIs!</p><p>Before we start, an issue link type has an inward and an outward description. For every issue link, there will be a source issue and a destination issue. From a source issue, we can look up the destination issues by looking up the outward links. Similarly, from a destination issue, we can look up the source issues by looking up inward links.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec247"/>Getting Ready...</h2></div></div></div><a id="id1330" class="indexterm"/><a id="id1331" class="indexterm"/><p>Make sure the Issue Linking feature is turned ON in JIRA and valid link types are created. This can be done from <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>Issue</strong> <strong>Linking</strong>, as explained at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking">http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking</a> .</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec248"/>How to do it...</h2></div></div></div><a id="id1332" class="indexterm"/><a id="id1333" class="indexterm"/><p>Issue Links<a id="id1334" class="indexterm"/> are managed in JIRA with the help of the <code class="literal">IssueLinkManager</code> class. The following are the steps to create an issue link between two given issues:</p><div><ol class="orderedlist arabic"><li class="listitem">Get the <code class="literal">IssueLinkType</code> object for the link type we are going to create. This can be retrieved using the <code class="literal">IssueLinkTypeManager</code> class. The <code class="literal">IssueLinkTypeManager</code> class can be retrieved from the <code class="literal">ComponentManager</code> or can be injected in the constructor.<div><pre class="programlisting">IssueLinkTypeManager issueLinkTypeManager = ComponentManager.getInstance().getComponentInstanceOfType(IssueLinkTypeManager.class);
IssueLinkType linkType = issueLinkTypeManager.getIssueLinkTypesByName("Duplicate").iterator().next();</pre></div><p>Here we are getting the <code class="literal">Duplicate</code> issue link type. Even though the <code class="literal">getIssueLinkTypesByName</code> method<a id="id1335" class="indexterm"/> returns a Collection, there will be only one link with the same name.</p></li><li class="listitem">Create the issue link using the <code class="literal">IssueLinkManager</code> class. The <code class="literal">IssueLinkManager</code> class can also be retrieved from the <code class="literal">ComponentManager</code> class or injected in the constructor.<div><pre class="programlisting">IssueLinkManager issueLinkManager = ComponentManager.getInstance().getIssueLinkManager();
issueLinkManager.createIssueLink(sourceIssue.getId(), destIssue.getId(), linkType.getId(), null, user);</pre></div><p>Here, we pass the source and destination issue IDs, in the order mentioned, along with the link type ID. The fourth parameter is the sequence, which is of type <code class="literal">long</code>, used to order the links on the user interface. <code class="literal">user</code> is the user who is performing the link action.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec249"/>There's more...</h2></div></div></div><p>Let's now see how to delete them or just display links.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec56"/>Deleting Issue Links</h3></div></div></div><a id="id1336" class="indexterm"/><p>Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Retrieve the <code class="literal">IssueLinkType</code>, as we did earlier:<div><pre class="programlisting">IssueLinkTypeManager issueLinkTypeManager = ComponentManager.getInstance().getComponentInstanceOfType(IssueLinkTypeManager.class);
IssueLinkType linkType = issueLinkTypeManager.getIssueLinkTypesByName("Duplicate").iterator().next();</pre></div></li><li class="listitem">Get the <code class="literal">IssueLink</code> to be deleted using the <code class="literal">IssueLinkManager</code> class<a id="id1337" class="indexterm"/>.:<div><pre class="programlisting">IssueLink issueLink = issueLinkManager.getIssueLink(sourceIssue.getId(), destIssue.getId(), linkType.getId());</pre></div></li><li class="listitem">Here the <code class="literal">sourceIssue</code> and <code class="literal">destIssue</code> are the source and destination issues, respectively.</li><li class="listitem">Delete the Link using the <code class="literal">IssueLinkManager</code> class.<div><pre class="programlisting">issueLinkManager.removeIssueLink(issueLink, user);</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec57"/>Retrieving Issue Links on an issue</h3></div></div></div><a id="id1338" class="indexterm"/><a id="id1339" class="indexterm"/><p>We can retrieve the inward or outward links on an issue or all the linked issues using different methods on the <code class="literal">IssueLinkManager</code> class<a id="id1340" class="indexterm"/>.</p><p>All inward links can be retrieved as shown:</p><div><pre class="programlisting">List&lt;IssueLink&gt; links = issueLinkManager.getInwardLinks(issue.getId());
for (IssueLink issueLink : links) {
  System.out.println(issueLink.getIssueLinkType().getName()+": Linked from "+issueLink.getSourceObject().getKey());
}</pre></div><p>Here, <code class="literal">issue</code> is the destination object and we are getting all the inward issue links and displaying the source issue key.</p><p>Similarly, outward links can be retrieved as shown:</p><div><pre class="programlisting">links = issueLinkManager.getOutwardLinks(issue.getId());
for (IssueLink issueLink : links) {
  System.out.println(issueLink.getIssueLinkType().getName()+": Linked to "+issueLink.getDestinationObject().getKey());
}</pre></div><p>Here, issue is the source object and we are getting all the outward issue links and displaying the destination issue key.</p><p>All the linked issues can be retrieved in a single method as shown:</p><div><pre class="programlisting">LinkCollection links = this.issueLinkManager.getLinkCollection(issue, user);
Collection&lt;Issue&gt; linkedIssues = links.getAllIssues();</pre></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec87"/>Validations on issue linking</h1></div></div></div><a id="id1341" class="indexterm"/><a id="id1342" class="indexterm"/><p>There are scenarios that we might come across where we need to do extra validations while linking. In this recipe, we will quickly look at adding some extra validations by extending the existing link issue action in JIRA.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec250"/>Getting Ready...</h2></div></div></div><p>Create a Skeleton plugin using Atlassian Plugin SDK. It is recommended to read the <em>Extending</em> <em>JIRA</em> <em>actions</em> recipe before proceeding.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec251"/> How to do it...</h2></div></div></div><a id="id1343" class="indexterm"/><a id="id1344" class="indexterm"/><p>As we have seen while extending JIRA actions, all we need to do here is to create a new webwork action that extends the existing JIRA action and override the required method. In this specific case, will be overriding the <code class="literal">doValidation()</code> method<a id="id1345" class="indexterm"/> to do some extra validation.</p><p>Let us, for example, consider that we want to restrict linking to all issues of type <strong>New</strong> <strong>Feature</strong>. Following are the steps to do the same.</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new webwork module in the <code class="literal">atlassian-plugin.xml</code> with a new action class and the same alias as JIRA's link action, <code class="literal">LinkExistingIssue</code>. Once we do that, the new action class will be executed while linking issues.<div><pre class="programlisting">&lt;webwork1 key="jtricks-link-issue-details" name="JTricks Link Issue Details" &gt; 
  &lt;actions&gt;
    &lt;action name="com.jtricks.JTricksLinkExistingIssue" alias="LinkExistingIssue"&gt;
    &lt;view name="error"&gt;/secure/views/issue/linkexistingissue.jsp&lt;/view&gt; 
    &lt;view name="input"&gt;/secure/views/issue/linkexistingissue.jsp&lt;/view&gt;
    &lt;/action&gt;
  &lt;/actions&gt;
&lt;/webwork1&gt;</pre></div></li><li class="listitem">Create the new class extending the existing action class.<div><pre class="programlisting">public class JTricksLinkExistingIssue extends LinkExistingIssue {
  ...
}</pre></div></li><li class="listitem">Override the <code class="literal">doValidation</code>() method to add extra validation.<div><pre class="programlisting">@Override
protected void doValidation() {
  super.doValidation();
  // Custom Validation
}</pre></div></li><li class="listitem">Add the custom validation as appropriate. In our example, we throw an error if any of the issues selected for linking is of type <strong>New</strong> <strong>Feature</strong>. The selected issues can be found using the <code class="literal">getLinkKey()</code> method<a id="id1346" class="indexterm"/>, which returns a String array of selected issue keys.<div><pre class="programlisting">List&lt;String&gt; invalidIssues = new ArrayList&lt;String&gt;();
for (String key : getLinkKey()) {
  MutableIssue issue = this.issueManager.getIssueObject(key);
  if (issue.getIssueTypeObject().getName().equals("New Feature")) {
    invalidIssues.add(key);
  }
}
if (!invalidIssues.isEmpty()) {
  addErrorMessage("Linking not allowed to New Features:" + getString(invalidIssues));
}

private String getString(List&lt;String&gt; invalidIssues) {
  StringBuffer invalidIssue = new StringBuffer("{ ");
  for (String key : invalidIssues) {
    invalidIssue.append(key + " ");
  }
  invalidIssue.append("}");
  return invalidIssue.toString();
}</pre></div></li><li class="listitem">As you can see, all we do here is check for the issue key and mark it as invalid if the issue type is <strong>New</strong> <strong>Feature</strong>. If invalid, we then throw an error for those invalid keys.</li><li class="listitem">Package the plugin and deploy it.</li></ol></div><a id="id1347" class="indexterm"/><a id="id1348" class="indexterm"/><p>We can use the same approach to add extra validations.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>An action can be overridden only once. Care must be taken not to override it again in another plugin (might be a third-party plugin) as only one will be picked up.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec252"/>How it works...</h2></div></div></div><p>Let us consider linking to three existing issues, out of which, two are <strong>New</strong> <strong>Features</strong>. Once the plugin is deployed, we will see an error as shown:</p><div><img src="img/1803-07-07.jpg" alt="How it works..."/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec253"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Extending a Webwork action in JIRA</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec88"/>Discarding fields while cloning</h1></div></div></div><p>Cloning<a id="id1349" class="indexterm"/> of issues in JIRA is an easy way to replicate an existing issue. While cloning, a new issue is created exactly similar to the original issue with identical values for all its fields except for a few special ones. The special ones include <code class="literal">created</code> <code class="literal">date</code>, <code class="literal">updated</code> <code class="literal">date</code>, <code class="literal">issue</code> <code class="literal">key</code>, <code class="literal">status</code>, and so on.</p><a id="id1350" class="indexterm"/><a id="id1351" class="indexterm"/><p>But, in addition to the special fields JIRA has chosen, we might want to ignore a few other fields while cloning an issue. How about a unique custom field? We surely don't want to replicate it while cloning?</p><p>Here is an easy way to discard any such fields while cloning an issue.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec254"/>Getting ready...</h2></div></div></div><p>Create a Skeleton plugin using Atlassian Plugin SDK. It is recommended to read the <em>Extending</em> <em>JIRA</em> <em>actions</em> recipe before proceeding.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec255"/>How to do it...</h2></div></div></div><a id="id1352" class="indexterm"/><a id="id1353" class="indexterm"/><p>As we have seen while extending JIRA actions in the previous recipe, all we need to do here is to create a new webwork action that extends the existing JIRA Clone action and overrides the required method. In this specific case, will be overriding the <code class="literal">setFields()</code> method<a id="id1354" class="indexterm"/> to remove the cloning of the specific fields we are interested in!</p><p>Let us, for example, say that we want to avoid cloning a unique number field named <code class="literal">Test</code> <code class="literal">Number</code>. Following are the steps to follow:</p><div><ol class="orderedlist arabic"><li class="listitem">Add a new webwork module in the <code class="literal">atlassian-plugin.xml</code> with a new action class and the same alias as JIRA's clone action, <code class="literal">CloneIssueDetails</code>. Once we do that, the new action class will be executed while cloning issues.<div><pre class="programlisting">&lt;webwork1 key="jtricks-link-issue-details" name="JTricks Link Issue Details" &gt;	
  &lt;actions&gt;
    &lt;action name="com.jtricks.JTricksCloneIssueDetails" alias="CloneIssueDetails"&gt;
      &lt;view name="input"&gt;/secure/views/cloneissue-start.jsp&lt;/view&gt;
      &lt;view name="error"&gt;/secure/views/cloneissue-start.jsp&lt;/view&gt;
    &lt;/action&gt;
  &lt;/actions&gt;
&lt;/webwork1&gt;</pre></div></li><li class="listitem">Create the new class extending the existing action class.<div><pre class="programlisting">public class JTricksCloneIssueDetails extends CloneIssueDetails{
  ...
}</pre></div></li><li class="listitem">Override the <code class="literal">setFields ()</code> method to set a <code class="literal">null</code> value for the fields we do not want to clone.<div><pre class="programlisting">@Override
protected void setFields() throws FieldLayoutStorageException {
  super.setFields();
  // Set null values for interested fields here	
}</pre></div></li><li class="listitem">Add the code to set <code class="literal">null</code> values. In our example, we set null value for the <code class="literal">Test</code> <code class="literal">Number</code> custom field.<div><pre class="programlisting">CustomField customField = customFieldManager.getCustomFieldObjectByName("Test Number");
getIssueObject().setCustomFieldValue(customField, null);</pre></div><p>Here we get the cloned issue using the method <code class="literal">getIssueObject</code> and set the null value for the custom field. Don't forget to use the <code class="literal">getCustomFieldObject</code> method<a id="id1355" class="indexterm"/> by passing the custom field ID if the field name is not unique!</p><p>If we want to set null values for a system field like fix for versions, the method is the same.</p><div><pre class="programlisting">getIssueObject().setFixVersions(null);</pre></div></li><li class="listitem">Package the plugin and deploy it.<div><div><h3 class="title"><a id="note16"/>Note</h3><p>An action can be overridden only once. Care must be taken not to override it again in another plugin (might be a third-party plugin) as only one will be picked up.</p></div></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec256"/>How it works...</h2></div></div></div><a id="id1356" class="indexterm"/><a id="id1357" class="indexterm"/><p>Once the clone operation is invoked, the new action we have created will be executed. The clone operation creates a new issue object and copies the values to its fields from the original issue. This is done in the <code class="literal">setFields</code> method<a id="id1358" class="indexterm"/>.</p><p>It is only logical to override this method and set <code class="literal">null</code> values for fields we do not want to clone. As shown above, the <code class="literal">setFields</code> method from the super class, which is the JIRA's in-built class, is first executed. Once the method is executed, the new issue object, which can be retrieved using the method <code class="literal">getIssueObject</code><a id="id1359" class="indexterm"/>, has all the values populated. We just reset some of the values by setting them to <code class="literal">null</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec257"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Extending</em> <em>a</em> <em>Webwork</em> <em>action</em> <em>in</em> <em>JIRA</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec89"/>JavaScript tricks on issue fields</h1></div></div></div><a id="id1360" class="indexterm"/><a id="id1361" class="indexterm"/><p>JIRA provides a lot of options to manage the various fields on an issue. Field configuration schemes, screen schemes, and so on, help the JIRA admins to show or hide fields, mark them as mandatory, and so on, differently for different issue types and projects.</p><p>Irrespective of how configurable these schemes are, there are still areas where we need to perform custom development. For example, if we need to show or hide fields, based on the values of another field, then JIRA doesn't have any in-built options to do so.</p><p>Then, what is the best way to deal with this? It is always possible to create a new composite custom field that can have multiple fields driven by each other's behavior. But probably an easier way—that doesn't need developing a plugin—is to drive this using JavaScript. And to make things better, JIRA offers jQuery library that can be used to write neat JavaScript code!</p><a id="id1362" class="indexterm"/><a id="id1363" class="indexterm"/><p>However, using JavaScript to handle field behavior can create problems. It limits the behavior to the browser, it is client side and is dependent on whether JavaScript is enabled or not. But given its advantages and ease of use, most users prefer to do it. In this recipe, we will see a small example of using JavaScript to show or hide the values of a custom field based on the issue's priority value!</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec258"/>How to do it...</h2></div></div></div><p>Let us assume that we have a custom field named <strong>Why</strong> <strong>Critical?</strong>. The field should be shown only if the priority of the issue is <strong>Critical</strong>.</p><p>Following are the simple steps to achieve it using JavaScript:</p><div><ol class="orderedlist arabic"><li class="listitem">Write the JavaScript to achieve the functionality.<p>In our example, we need to show the <strong>Why</strong> <strong>Critical</strong> field only when the priority is Critical. Let us write the JavaScript for these purposes as an example!</p><div><ol class="orderedlist loweralpha"><li class="listitem">Identify the ID value for priority. We can get it by looking at the URL while editing the priority or from the JIRA database by looking at the <code class="literal">priority</code> table.</li><li class="listitem">Identify the ID of the custom field. We can get this also in a similar fashion, either by looking at the URL while editing the custom field or from the <code class="literal">customfield</code> table!</li><li class="listitem">Write the JavaScript to show or hide the field depending on the priority value. Here, we use the JIRA's jQuery library, which has a predefined namespace <code class="literal">AJS</code>, a short name for Atlassian JavaScript!<div><pre class="programlisting">&lt;script type="text/javascript"&gt;
(function($){
  $(document).ready(function(){
    var priority = document.getElementById('priority');
    hideOrShow(priority.value);
    priority.onchange=function() {
      hideOrShow(priority.value);
    };
  });

  function hideOrShow(priorityVal){
    if (priorityVal == '2'){
      AJS.$("#customfield_10170").closest('div.field-group').show();
    } else {
      AJS.$("#customfield_10170").closest('div.field-group').hide();
    }
  }
})(AJS.$);
&lt;/script&gt;</pre></div></li><li class="listitem">Here 10170 is the <code class="literal">id</code> of the <code class="literal">customfield</code> and hence <code class="literal">customfield_10170</code> represents the unique custom field ID! Also, 2 is the ID of the priority system field.<p>In the example, we created a page load event where the script looks at the priority value and sets the visibility of the div surrounding the custom field as hidden or shown.</p><p>The following part captures the on load event of the page where custom field is in edit mode.</p><div><pre class="programlisting">(function($){
$(document).ready(function(){
    ...
  });
})(AJS.$);
</pre></div><p>And the following code shows the field, if priority is 2.</p><div><pre class="programlisting">(AJS.$("#customfield_10170").closest('div.field-group').show();</pre></div><p>For every other priority value, the closet <code class="literal">div</code> surrounding field is hidden.</p></li></ol></div></li><li class="listitem">Add the above JavaScript to the description of the custom field.</li></ol></div><p>The field behavior will be effective on the next reload after the JavaScript is added on to the field description.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec259"/>How it works...</h2></div></div></div><a id="id1364" class="indexterm"/><a id="id1365" class="indexterm"/><p>Whenever the field is rendered under the velocity view in the edit mode, the field description is executed along with all the JavaScript code in there!</p><p>Once the script is added in the relevant field configuration screen, the field will not appear for priority values other than <strong>Critical</strong>, as shown in the next screenshot:</p><div><img src="img/1803-07-08.jpg" alt="How it works..."/></div><a id="id1366" class="indexterm"/><a id="id1367" class="indexterm"/><p>Here, the <strong>Priority</strong> is <strong>Major</strong> (value 3), and hence the field <strong>Why</strong> <strong>Critical?</strong> is not available. But the moment the priority is changed to <strong>Critical</strong>, we can see the field appearing back on the page.</p><div><img src="img/1803-07-09.jpg" alt="How it works..."/></div><a id="id1368" class="indexterm"/><a id="id1369" class="indexterm"/><p>The JavaScript can now be modified to do a lot of other useful stuff! Don't forget to modify the scripts according to your needs, specifically your browser and your version of JIRA.</p></div></div></body></html>