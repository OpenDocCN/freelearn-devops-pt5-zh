<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor015"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Getting Started with Ansible</h1>
<p>Ansible enables you to easily deploy applications and systems consistently and repeatably using native <a id="_idIndexMarker000"/>communication protocols such as SSH and WinRM. As a result, Ansible is agentless and so requires nothing to be installed on the managed systems (except for Python, which, these days, is present on most systems). As a result, it enables you to build a simple yet robust automation platform for your environment.</p>
<p>Ansible is straightforward to install and also comes packaged for many modern systems. Its architecture is serverless as well as agentless, so it has a minimal footprint. You can choose to run it from a central server or your own laptop—the choice is entirely yours. You can manage anything from a single host to hundreds of thousands of remote hosts from one Ansible control machine. All remote machines can be managed by Ansible, and with sufficient playbooks created, you may never have to log in to any of these machines individually again.</p>
<p>In this chapter, we will begin to teach you practical skills to cover the very fundamentals of Ansible, starting with how to install Ansible on a wide variety of operating systems. We will then look at how to configure Windows hosts to enable them to be managed with Ansible automation, before delving in greater depth into how Ansible connects to its target hosts. We’ll then look at node requirements and how to validate your Ansible installation, before finally looking at how to obtain and run the very latest Ansible source code if you wish to either contribute to its development or gain access to the very latest features.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Installing and configuring Ansible</li>
<li>Getting to know your Ansible installation</li>
<li>Managed node requirements<a id="_idTextAnchor017"/></li>
</ul>
<h1 id="_idParaDest-17"><a id="_idTextAnchor018"/>Technical requirements</h1>
<p>Ansible has a fairly minimal set of system requirements—as such, you should find that if you have a machine (either a laptop, a server, or a <strong class="bold">virtual machine</strong> (<strong class="bold">VM</strong>)) that is capable of running Python, then you will be able to run Ansible on it. Later in this chapter, we will demonstrate the installation methods for Ansible on a variety of operating systems—it is hence left to you to decide which operating systems are right for you.</p>
<p>The one exception to the preceding statement is Microsoft Windows—although there are Python environments available for Windows, there is as yet no native build of Ansible for Windows. Readers running more recent versions of Windows will be able to install Ansible using <strong class="bold">Windows Subsystem for Linux</strong> (henceforth, <strong class="bold">WSL</strong>) by following the procedures outlined later for their chosen WSL environment (for example, if you install Ubuntu on WSL, you should simply follow the instructions given in this chapter for installing Ansible on Ubuntu)<a id="_idTextAnchor019"/>.<a id="_idTextAnchor020"/></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor021"/>Installing and configuring Ansible</h1>
<p>Ansible is written in <a id="_idIndexMarker001"/>Python and, as such, can be run on a wide range of systems. This includes the most popular flavors of Linux, FreeBSD, and macOS. The one exception to this is<a id="_idIndexMarker002"/> Windows, where though native Python distributions exist, there is as yet no native Ansible build. As a result, your best option at the time of writing is to install Ansible under WSL, proceeding as if you were running on a native Linux host.</p>
<p>Once you have established the system on which you wish to run Ansible, the installation process is normally simple. In the following sections, we will discuss how to install Ansible on a wide range of different systems so that most readers should be able to get up and running with Ansible in a matter of minute<a id="_idTextAnchor022"/>s.</p>
<h2 id="_idParaDest-19"><a id="_idTextAnchor023"/>Understanding Ansible version numbers</h2>
<p>When the previous edition <a id="_idIndexMarker003"/>of this book was published, Ansible followed a relatively simple version numbering scheme. All releases of Ansible included all the modules, plugins, and other code accepted into the Ansible release (which was version 2.9 in the previous edition of this book).</p>
<p>This worked well for many years but also created a problem for the maintainers of Ansible—as its popularity and adoption grew, the number of modules (the lifeblood of Ansible, which perform the actual automation tasks you will run) numbered in the thousands. Releasing these with the core Ansible software meant that if a bug was discovered in a module, or perhaps a new release with new features was available, then there had to be a new release of Ansible before end users could take advantage of this. Not only did this slow down releases of new module code, but it also created a significant workload for the Ansible maintainers.</p>
<p>As a direct result of this, Ansible was split into two separate packages. The first is called <code>ansible-core</code>, and this contains just the Ansible runtime code (such as the <code>ansible-playbook</code> command, which we’ll see in use later), as well as some built-in functionality that is core to all playbooks and roles. The <code>ansible-core</code> package follows the <em class="italic">classic</em> Ansible<a id="_idIndexMarker004"/> versioning scheme, and so where the previous release of this book was written around Ansible 2.9, this version of the book will be based around <code>ansible-core</code> 2.15.</p>
<p>All the modules and plugins that provided the functionality present in the 2.9 release (the last release before the package split was implemented) are contained in the <strong class="bold">Ansible community package</strong> release. This<a id="_idIndexMarker005"/> follows semantic versioning, meaning that, as the current release at the time of writing is 8.0, the next major release will be 9.0.</p>
<p>To enable this separate management of <code>ansible-core</code> and modules, plugins, and the like, an<a id="_idIndexMarker006"/> implementation called <strong class="bold">collections</strong> was created. Collections are individually bundled sets of modules, plugins, and roles intended for a specific purpose; we’ll be learning all about these in det<a id="_idTextAnchor024"/>ail in <a href="B20846_06.xhtml#_idTextAnchor318"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating and Consuming Collections</em>, so don’t worry if this all seems a bit daunting—it will all become clear later in the book.</p>
<p>Each release of the Ansible community package is dependent on a specific version of the <code>ansible-core</code> package, and the 8.0 release we will use in this book depends upon <code>ansible-core</code> version 2.15. You can find the change log and other details about the 8.0 release here: <a href="https://github.com/ansible-community/ansible-build-data/blob/8.0.0/8/CHANGELOG-v8.rst#v8-0-0">https://github.com/ansible-community/ansible-build-data/blob/8.0.0/8/CHANGELOG-v8.rst#v8-0-0</a>.</p>
<p>The beauty of this separation of code lies in this: let’s say you want to create a playbook or role based around new functionality in a module; you can install an updated collection containing the module without updating your entire Ansible installation (or, indeed, waiting for the next release, as you would have had to until after version 2.9 was released).</p>
<p>With this information in hand, we’ll proceed to explore the specifics of installing Ansible on a variety of systems, but it’s important to discuss this upfront as if you’ve had exposure to any of the 2.x releases of Ansible, the new versioning scheme will look rather different.</p>
<p>If you’d like to read <a id="_idIndexMarker007"/>more details on the rationale behind the new versioning scheme, release cadence, and how it works, the official Ansible documentation here has more details: <a href="https://docs.ansible.com/ansible/latest/reference_appendices/release_and_maintenance.xhtml">https://docs.ansible.com/ansible/latest/reference_appendices/release_and_maintenance.xhtml</a>.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor026"/>Installing Ansible on Linux and FreeBSD</h2>
<p>The release cycle for Ansible is usually about six months, and during this short release cycle, there are normally <a id="_idIndexMarker008"/>many changes, from minor bug fixes to major ones, new features, and even sometimes fundamental changes to the language. At the <a id="_idIndexMarker009"/>end of each release cycle, you would expect to see a new version of the Ansible community package (for example, 8.0), and a corresponding release<a id="_idIndexMarker010"/> of the <code>ansible-core</code> package (for example, 2.15). While there are native packages still built for many operating<a id="_idIndexMarker011"/> systems, your mileage will vary as to how up to date these are, and the recommended way to install Ansible is now to use the PIP package manager for Python.</p>
<p>There will, of course, be exceptions to this. For <a id="_idIndexMarker012"/>example, if you are using a commercial Linux distribution such as <strong class="bold">Red Hat Enterprise Linux</strong> (<strong class="bold">RHEL</strong>), especially to perform workflows supported by your operating system vendor, then you should make sure you use the packages provided by that vendor. They will invariably also provide instructions on how to install Ansible.</p>
<p>This does bring with it a separate challenge. When Ansible was installed using your native package manager such as <code>yum</code>, <code>dnf</code>, or <code>apt</code>, it would be updated along with your system. When using PIP, you will need to ensure that you update Ansible separately (we will show you how shortly).</p>
<p>Talking of upgrades, most playbooks that were created under the 2.x releases of Ansible will still work today, and you will often find that updating does not specifically cause any issues. However, it is strongly recommended that you read the porting notes for each release to ensure your code remains functional as you intended it. As such, an Ansible upgrade should be a planned activity, and it is almost certainly not desirable to patch Ansible in line with your operating system. In short, the move away from native operating system packages to PIP package management is unlikely to cause you any issues, and may even prove<a id="_idIndexMarker013"/> beneficial.</p>
<p>Suppose you want<a id="_idIndexMarker014"/> to install Ansible on a node—the following procedure should<a id="_idIndexMarker015"/> work on any version of Linux or FreeBSD provided the required version of <a id="_idIndexMarker016"/>Python is available:</p>
<ol>
<li>Check that Python is installed on your intended node—henceforth, we will refer to this as the <code>PATH</code> using a command such as this:<pre class="source-code">
<strong class="bold">$ python3 --version</strong>
<strong class="bold">Python 3.10.6</strong></pre></li> </ol>
<p>Here, you can see that Python 3.10.6 is installed. The minimum requirement for Ansible 8.0 is Python 3.9, so in this instance, we are good to proceed. However, if you find that Python is not present, please refer to the documentation for your operating system for guidance on how to install it.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Depending upon your system, Python may be run using a command such as <code>python</code>, <code>python3</code>, or <code>python3.10</code>—again, please refer to the documentation for your operating system to learn more. Ansible will work in any of these cases, but it is important to understand how to run Python on your system to complete the rest of this process. Here, we will assume that Python is executed using th<a id="_idTextAnchor027"/><a id="_idTextAnchor028"/>e <code>python3</code> command.</p>
<ol>
<li value="2">Once you know that Python is installed, the next step is to ensure that the PIP package manager is installed. A successful query of this should look something like this:<pre class="source-code">
<strong class="bold">$ python3 -m pip -V</strong>
<strong class="bold">pip 22.0.2 from /usr/lib/python3/dist-packages/pip (python 3.10)</strong></pre></li> </ol>
<p>You may see output<a id="_idIndexMarker019"/> such as this:</p>
<pre class="source-code">
<strong class="bold">$ python3 -m pip -V</strong>
<strong class="bold">/usr/bin/python3: No module named pip</strong></pre> <p>In such cases, you <a id="_idIndexMarker020"/>will need to install PIP. You can do this by running the following command:</p>
<pre class="source-code">
<strong class="bold">$ curl https://bootstrap.pypa.io/get-pip.py -o get-pip.py</strong>
<strong class="bold">$ python3 get-pip.py --user</strong></pre> <p>Most operating systems will also have a native package for installing PIP—for example, on Ubuntu, you can install PIP using this command:</p>
<pre class="source-code">
<strong class="bold">$ apt install python3-pip</strong></pre> <p>How you install <a id="_idIndexMarker021"/>PIP doesn’t matter—as long as it’s installed, you can proceed to the next step.</p>
<ol>
<li value="3">With these steps<a id="_idIndexMarker022"/> completed, all that is left is to install Ansible. Now, this might seem like a bit of a departure from the previous ways of installing Ansible, where operating-system-native packages were available for most major operating systems. Yet the beauty of using PIP is that once you’ve learned how to install and manage Ansible on one system, the method is exactly the same on all others, regardless of whether you are using Fedora, Ubuntu, FreeBSD, Debian, or Gentoo.</li>
</ol>
<p>In fact, even if you’re using Linux under WSL, the installation method is exactly the same once you’ve got <a id="_idIndexMarker023"/>WSL up and running. The simplest and<a id="_idIndexMarker024"/> easiest way to complete your Ansible install is to ru<a id="_idTextAnchor029"/>n the following command:</p>
<pre class="source-code">
<strong class="bold">$ python3 -m pip install --user ansible</strong></pre> <p>The output should look something like this:</p>
<div><div><img alt="Figure 1.1 – Installing Ansible using PIP on Linux" height="1099" src="img/B20846_01_001.jpg" width="824"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Installing Ansible using PIP on Linux</p>
<p>From the output here, you<a id="_idIndexMarker025"/> can see that this command has successfully installed<a id="_idIndexMarker026"/> Ansible 8.0.0, along with its <a id="_idIndexMarker027"/>dependent package, <code>ansible-core</code> 2.15.0—these are the latest versions<a id="_idIndexMarker028"/> available at the time of writing.</p>
<p>Also, you will note that Ansible has been installed in <code>/home/james/.local/bin</code>, which is not on the system path, so you won’t be able to run commands such as <code>ansible-playbook</code> without either updating the path or specifying the full path.</p>
<p>Thus, if you want to run the <code>ansible-playbook</code> command, you could run it as follows:</p>
<pre class="source-code">
<strong class="bold">$ /home/$USER/.local/bin/ansible-playbook</strong></pre> <p>Alternatively, you could update your path, and then you can run the command without needing to specify t<a id="_idTextAnchor030"/>he full path, as follows:</p>
<pre class="source-code">
<strong class="bold">$ export PATH=$PATH:/home/$USER/.local/bin</strong>
<strong class="bold">$ ansible-playbook --version</strong>
<strong class="bold">ansible-playbook [core 2.15.0]</strong>
<strong class="bold">…</strong></pre> <p>Of course, this process is <a id="_idIndexMarker029"/>only installing Ansible for the current user. This will often be sufficient for most scenarios, but there might be times when you have multiple developers accessing the same control node, and in this case, you would want<a id="_idIndexMarker030"/> them all to access one centrally installed copy of Ansible—otherwise, one developer might have version 6.2.0 and another 8.0.0, and your development processes would be inconsistent.</p>
<p>If you want to install Ansible for everyone, you should follow the preceding process up to <em class="italic">step 2</em> to ensure that PIP is installed. Then, proceed as follows:</p>
<ol>
<li>Install Ansible as the root user by running the following command:<pre class="source-code">
<strong class="bold">$ sudo python3 -m pip install ansible</strong></pre></li> <li>Now, you will find that Ansible is installed centrally—on my Ubuntu Server 22.04 test system, I see<a id="_idIndexMarker031"/> the following results after running this command:<pre class="source-code">
<strong class="bold">$ which ansible-playbook</strong>
<strong class="bold">/usr/bin/ansible-playbook</strong>
<strong class="bold">$ ansible-playbook --version</strong>
<strong class="bold">ansible-playbook [core 2.15.0]</strong>
<strong class="bold">…</strong></pre></li> </ol>
<p>PIP has more tricks up its sleeve, however, and we’re going to show you another one now—specifying your installation version.</p>
<p>So far, we’ve just been specifying<a id="_idIndexMarker032"/> the <code>ansible</code> package for installation. This works great if you always want the<a id="_idIndexMarker033"/> latest and greatest version, but what if, for reasons of development or consistency, you want to install a specific version?</p>
<p>First of all, suppose that<a id="_idIndexMarker034"/> you want to install Ansible 6.2.0 because you need to test or develop against that version. You could do this by altering<a id="_idTextAnchor031"/> your <code>install</code> command as follows:</p>
<pre class="console">
$ python3 -m pip install --user ansible==6.2.0</pre> <p>This will install version <code>6.2.0</code> (and the corresponding version of <code>ansible-core</code>, which in this example is <code>2.13.8</code>) in your local user directory, and if you watch the installation process closely, you’ll see that it uninstalls any version you have already installed, even if it’s newer. Proceed with caution if this isn’t what you want.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can, of course, add a <code>==6.2.0</code> suffix to any of the installation commands we’ve given previously to specify the version to be installed. You can also change <code>6.2.0</code> to any valid version number. You can explore the available versions by browsing to the following URL: <a href="https://pypi.org/project/ansible/#history">https://pypi.org/project/ansible/#history</a>.</p>
<p>Any time you want to upgrade your installed Ansible version (when it has been installed using PIP), you can simply add the <code>--upgrade</code> flag to the installation comma<a id="_idTextAnchor032"/>nd, as in the following example:</p>
<pre class="console">
$ python3 -m pip install --user --upgrade ansible</pre> <p>This example command will install the <a id="_idIndexMarker035"/>very latest version, as we have not explicitly set one otherwise.</p>
<p>If you ever need to<a id="_idIndexMarker036"/> remove Ansible from your system for any reason, PIP can also handle this—for example, you could run this command to remove the version of Ansible and <code>ansible-core</code> that you installed (note that you must specify both—dependencies are not automatically removed):</p>
<pre class="console">
$ python3 -m pip uninstall ansible ansible-core</pre> <p>Once you’ve mastered these commands, you will be set to install, maintain, and uninstall Ansible on all your control nodes.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor033"/>Working with virtual environments</h2>
<p>Another incredibly useful and <a id="_idIndexMarker037"/>powerful feature of Python is <strong class="bold">virtual environments</strong> (henceforth <strong class="bold">venvs</strong>). Venvs are small isolated Python environments that are separate from both the system install of<a id="_idIndexMarker038"/> Python (and its libraries) and all other virtual environments. This is incredibly useful for Ansible development. For example, let’s say that you have a set of playbooks and roles that you developed under Ansible 2.7.18, and these have all been tested and known to work well. You want to upgrade to Ansible 8.0.0, but you can’t take the risk of the existing code being inoperable in case you have to use it.</p>
<p>With venvs, you can have an isolated Ansible 2.7.18 and an isolated Ansible 8.0.0 environment on the same machine, and you can switch between them at will. To get started, follow the process provided next:</p>
<ol>
<li>To start with, you will need to make sure you have both an operable Python environment and PIP, as described earlier in this chapter. Once these are in place, proceed to <em class="italic">step 2</em>. If you are going back to a version of Ansible as old as 2.7.18, you’ll also need to ensure it supports the Python version you are using. My Python environment on Ubuntu Server 22.04 is version 3.10, which is not supported by Ansible 2.7.18. As a result, I’ll install Python 2.7, like so:<pre class="source-code">
<code>venv</code> installed—this can be installed using PIP, and <a id="_idIndexMarker039"/>while most operating systems have a native package for it, Ubuntu Server 22.04 only has it for Python 3. Thus, I installed it with the following command:<pre class="source-code">
<strong class="bold">$ sudo pip2 install virtualenv</strong></pre></li> <li>You’re now ready to create your first venv—let’s create one for Ansible 2.7.18:<pre class="source-code">
<strong class="bold">$ python2 -m virtualenv ansible-2.7.18</strong></pre></li> <li>This will create a venv under the current directory containing the minimum set of files for an operating Python 2 environment. Now, we’ll activate the environment (without this step, you will still be u<a id="_idTextAnchor035"/>sing the system Python environme<a id="_idTextAnchor036"/>nt):<pre class="source-code">
<strong class="bold">$ . ./ansible-2.7.18/bin/activate</strong>
<code>--user</code> flag is not required in a venv):<pre class="source-code">
<strong class="bold">(ansible-2.7.18) $ python -m pip install ansible==2.7.18</strong></pre></li> <li>You’ll see Ansible installed via PIP in the usual way. Now, you should be able to query the ve<a id="_idTextAnchor038"/>rsion of Ansible installed, as follows:<pre class="source-code">
<strong class="bold">(ansible-2.7.18) $ ansible-playbook --version</strong>
<strong class="bold">ansible-playbook 2.7.18</strong>
<strong class="bold">…</strong></pre></li> <li>That’s it—we have Ansible 2.7.18 working in its own Python environment, all isolated from the system and other environments. Now, we can repeat the process for Ansible 8.0.0. You will doubtless have received warnings that Python 2.7 is deprecated during this process (this is to be expected), so we definitely want to use our system-installed version of Python 3.10 for the later version of Ansible. As such, we<a id="_idIndexMarker041"/> first want to deactivate our venv so that we can revert to the system-installed Python libraries. Here’s how we can do that:<pre class="source-code">
<strong class="bold">(ansible-2.7.18) $ deactivate</strong>
<strong class="bold">$</strong></pre></li> <li>Note how your prompt returns to normal, demonstrating that the venv is no longer active. As before, we need to ensure we have the Python venv library installed—however, there is a native package for it, so we can simply install it using this command:<pre class="source-code">
<strong class="bold">$ sudo apt install python3-venv</strong></pre></li> <li>Now, you can create a Python 3 venv for Ansible 8.0.0 and activate it using the following commands:<pre class="source-code">
<strong class="bold">$  python3 -m venv ansible-8.0.0</strong>
<strong class="bold">$ . ./ansible-8.0.0/bin/activate</strong>
<strong class="bold">(ansible-8.0.0) $</strong></pre></li> <li>You can now install<a id="_idIndexMarker042"/> Ansi<a id="_idTextAnchor039"/>ble via PIP in the same manner as before:<pre class="source-code">
<strong class="bold">(ansible-8.0.0) $ python3 -m pip install ansible</strong>
<strong class="bold">…</strong>
<strong class="bold">(ansible-8.0.0) $  ansible-playbook --version</strong>
<strong class="bold">ansible-playbook [core 2.15.0]</strong>
<code>deactivate</code> command first, and then using the appropriate <code>activate</code> command as demonstrated previously.</li>
</ol>
<p>In this example, we’ve used <a id="_idIndexMarker043"/>completely different versions of Python and Ansible, yet they remain isolated from each other on the system. As such, you can safely use the older version to run your playbooks while you test your updated code on the newer version. This is quite an extreme example, and you almost certainly won’t need to go back to Python 2.7 and Ansible 2.7.18, but it does demonstrate how nicely you can create completely separate Python environments for your development and testing work without needing multiple systems.</p>
<h2 id="_idParaDest-22"><a id="_idTextAnchor040"/>Installing from GitHub</h2>
<p>It has always been possible to run the very latest development version of Ansible from GitHub, and this is as true <a id="_idIndexMarker044"/>today as it has always been. However, there is <a id="_idIndexMarker045"/>now one important caveat. If you have done this previously (on releases of Ansible from the 2.x series or earlier, on which the previous edition of this book was based), then you would be working with the complete install of Ansible, including all the modules you might want to use. Since the introduction of collections, you will now only be checking out the code for <code>ansible-core</code> when you do this. As such, if you want to test code including module calls, you will need to install or manage collections to go alongside your <code>ansible-core</code> setup.</p>
<p>We will explore the management of collections in <a href="B20846_06.xhtml#_idTextAnchor318"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating and Consuming Collections</em>, so we won’t specifically explore this here—however, for completeness, we will show you how to install <code>ansible-core</code> development releases from code.</p>
<p>To do this, follow these steps:</p>
<ol>
<li>Check that you have PIP installed—if you don’t, please take a look at how we did this earlier in the chapter. Once you have this (and, by inference, a working Python 3 environment), you can move forward to the next step.</li>
<li>Clone the Ansible GitHub repository, like so:<pre class="source-code">
<strong class="bold">$ git clone https://github.com/ansible/ansible.git</strong>
<strong class="bold">$ cd ansible</strong></pre></li> <li>Ensure you have all development requirements installed using PIP:<pre class="source-code">
<code>hacking</code> environment setup—this will set your shell up so that you can access the development version of Ansible you just cloned. You will need to do this every<a id="_idIndexMarker046"/> time you open a new shell or reconnect to your development host so that the setup is transient, which is normally perfect for development work:<pre class="source-code">
<code>ansible</code>, <code>ansible-playbook</code>, and <code>ansible-galaxy</code>.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">On Linux distributions such as Ubuntu 22.04, the default Python installation is Python 3, and the binary used to execute it is named <code>python3</code>. This won’t work on the development install of Ansible, which expects the Python binary to be called <code>python</code>. You can fix this on Ubuntu 22.04 by installing a special meta package. To do so, run this command: <code>sudo apt install python-is-python3</code>. Or, you could just create a symbolic link from <code>python3</code> to <code>python</code> by running the following command: <code>sudo ln -s /</code><code>usr/bin/python3 /usr/bin/python</code>.</p>
<ol>
<li value="6">When you run the <code>env-setup</code> script, Ansible runs from the source code checkout, and the default inventory file is <code>/etc/ansible/hosts</code>, which will not have been<a id="_idIndexMarker047"/> created by your code checkout; however, you can optionally specify an inventory file wherever you want on your machine (see <em class="italic">How to build your inventory</em>, <a href="https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml#inventory-basics-formats-hosts-and-groups">https://docs.ansible.com/ansible/latest/inventory_guide/intro_inventory.xhtml#inventory-basics-formats-hosts-and-groups</a>, for more details). The following command provides an example of how you might do this, but obviously, your filename and <a id="_idTextAnchor041"/>contents are almost certainly going to vary:<pre class="source-code">
<strong class="bold">$ echo <a id="_idTextAnchor042"/>"app01.example.org" &gt; ~/my_ansible_inventory</strong>
<strong class="bold">$ export ANSIBLE_INVENTORY=~/my_ansible_inventory</strong></pre></li> </ol>
<p>This demonstrates another powerful way to configure Ansible—environment variables. The <code>ANSIBLE_INVENTORY</code> variable is used to tell Ansible where to look for its inventory <a id="_idIndexMarker048"/>file by default—this is normally <code>/etc/ansible/hosts</code>, but in the preceding example, we are changing this to the <code>my_ansible_inventory</code> file in our home directory.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can learn about the various Ansible configuration variables here: <a href="https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#environment-variables">https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#environment-variables</a>.</p>
<ol>
<li value="7">Once you have completed these steps, you can run Ansible exactly as we have discussed throughout this chapter. The <code>env-setup</code> script alters your <code>PATH</code> variable so that you don’t need to specify the location where you checked out the Ansible<a id="_idIndexMarker049"/> repository. By way of example, if you set up your inventory using the environment variable as demonstrated previously, and have cloned the Ansible source and run the <code>env-setup</code> script, you could run the ad hoc <code>ansible.builtin.ping</code> comm<a id="_idTextAnchor043"/>and that we are now familiar with, as follows:<pre class="source-code">
<strong class="bold">$ ansible all -m ansible.builtin.ping</strong>
<strong class="bold">[WARNING]: You are running the development version of Ansible. You should only run Ansible from "devel" if you are modifying the Ansible engine,</strong>
<strong class="bold">or trying out features under development. This is a rapidly changing source of code and can become unstable at any point.</strong>
<strong class="bold">app01.example.org | SUCCESS =&gt; {</strong>
<strong class="bold">    "ansible_facts": {</strong>
<strong class="bold">        "discovered_interpreter_python": "/usr/bin/python3"</strong>
<strong class="bold">    },</strong>
<strong class="bold">    "changed": false,</strong>
<strong class="bold">    "ping": "pong"</strong>
<strong class="bold">}</strong></pre></li> </ol>
<p>With this in place, you can now work with the development branch of Ansible just as you would if you had installed it by any other means.</p>
<ol>
<li value="8">Of course, the Ansible <a id="_idIndexMarker050"/>source tree is constantly changing, and it is unlikely you would just want to stick with the copy you cloned. When the time comes to update it, you don’t need to clone a new copy; you can simply update your exis<a id="_idTextAnchor044"/>ting working copy u<a id="_idTextAnchor045"/>sing the following commands:<pre class="source-code">
<strong class="bold">$ git pull –rebase</strong>
<strong class="bold">$ git submodule update --init --recursive</strong></pre></li> </ol>
<p>This concludes our look at<a id="_idIndexMarker051"/> installing Ansible on Linux—now that we’ve done that, we’ll look at so<a id="_idTextAnchor046"/>m<a id="_idTextAnchor047"/>e of the specifics of installing Ansible on macOS.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor048"/>Installing Ansible on macOS</h2>
<p>In this section, you will learn how <a id="_idIndexMarker052"/>to install Ansible on macOS. The<a id="_idIndexMarker053"/> easiest installation method is to use Homebrew, but you could also use the Python package manager (PIP). The procedure for installation with PIP is the same as for Linux, so we won’t go over that again here.</p>
<p>Instead, let’s get started with the Homebrew installation method, which is probably your fastest and easiest approach on macOS.</p>
<p>If you don’t already have Homebrew installed on macOS, you can easily install it, as detailed here:</p>
<ol>
<li>Normally, the two commands shown here are all that is required to install Homebrew on macOS:<pre class="source-code">
<strong class="bold">$ xcode-select –install</strong>
<strong class="bold">$ /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</strong></pre></li> </ol>
<p>If you have already installed the Xcode command-line tools for another purpose, you might see the<a id="_idIndexMarker054"/> following error message:</p>
<pre class="source-code">
<strong class="bold">xcode-select: error: command line tools are already installed, use "Software Update" in System Settings to install updates</strong></pre> <p>You may want to open the <strong class="bold">Software Update</strong> setting from <strong class="bold">System Settings</strong> on macOS and check whether updates to the Xcode command-line tools are required, but as long as they are installed, your Homebrew installation should proceed smoothly.</p>
<ol>
<li value="2">If you wish to confirm that your installation of Homebrew was successful, you can run the following command, which will warn you about any potential issues with your install—for <a id="_idIndexMarker055"/>example, the following output is warning us that, although Homebrew is installed successfully, it is not in our <code>PATH</code>, and so we may not be able to run any executables without specifying their absolute path:<pre class="source-code">
<strong class="bold">$ brew doctor</strong>
<strong class="bold">Please note that these warnings are just used to help the Homebrew maintainers</strong>
<strong class="bold">with debugging if you file an issue. If everything you use Homebrew for is</strong>
<strong class="bold">working fine: please don't worry or file an issue; just ignore this. Thanks!</strong>
<strong class="bold">Warning: Homebrew's sbin was not found in your PATH but you have installed</strong>
<strong class="bold">formulae that put executables in /opt/homebrew/sbin.</strong>
<strong class="bold">Consider setting the PATH for example like so</strong>
<code>/usr/bin/python3</code>—this should be the case with almost all modern<a id="_idIndexMarker056"/> installations of macOS) or you can install a newer version via Homebrew by running the following command:<pre class="source-code">
<strong class="bold">$ brew install python3</strong>
<strong class="bold">…</strong>
<strong class="bold">$ which python3</strong>
<strong class="bold">/opt/homebrew/bin/python3</strong>
<strong class="bold">$ python3  --version</strong>
<strong class="bold">Python 3.11.3</strong></pre></li> </ol>
<p>With this completed, you can now proceed to install Ansible.</p>
<ol>
<li value="4">To install Ansible via Homebrew, run the following command:<pre class="source-code">
<code>ansible</code> command<a id="_idIndexMarker057"/> as before, and if all has gone according to plan, you will see output similar to the following:<pre class="source-code">
<strong class="bold">$ ansible --version</strong>
<strong class="bold">ansible [core 2.15.0]</strong>
<strong class="bold">  config file = None</strong>
<strong class="bold">  configured module search path = ['/Users/james/.ansible/plugins/modules', '/usr/share/ansible/plugins/modules']</strong>
<strong class="bold">  ansible python module location = /opt/homebrew/Cellar/ansible/8.0.0/libexec/lib/python3.11/site-packages/ansible</strong>
<strong class="bold">  ansible collection location = /Users/james/.ansible/collections:/usr/share/ansible/collections</strong>
<strong class="bold">  executable location = /opt/homebrew/bin/ansible</strong>
<strong class="bold">  python version = 3.11.3 (main, Apr  7 2023, 20:13:31) [Clang 14.0.0 (clang-1400.0.29.202)] (/opt/homebrew/Cellar/ansible/8.0.0/libexec/bin/python3.11)</strong>
<strong class="bold">  jinja version = 3.1.2</strong>
<code>brew</code> command, as follows:<pre class="source-code">
<strong class="bold">$ brew upgrade ansible</strong></pre></li> </ol>
<p>Now that you have<a id="_idIndexMarker059"/> learned the steps to install Ansible on macOS, let’s see h<a id="_idTextAnchor049"/>o<a id="_idTextAnchor050"/>w to configure a Windows host for automation with Ansible.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor051"/>Configuring Windows hosts for Ansible</h2>
<p>As discussed earlier, there is no<a id="_idIndexMarker060"/> direct installation method for Ansible on Windows—simply, it is recommended that, where available, you install WSL <a id="_idIndexMarker061"/>and install Ansible as if you were running Linux natively, using the processes outlined earlier in this chapter.</p>
<p>Despite this limitation, however, Ansible is not limited to managing just Linux- and BSD-based systems—it is capable of the agentless management of Windows hosts using the native WinRM protocol, with modules and raw commands making use of PowerShell, which is available in every <a id="_idIndexMarker062"/>modern Windows installation. In this section, you will learn how to configure Windows to enable task automation with Ansible.</p>
<p>Here are some examples of what Ansible is capable of when automating Windows hosts:</p>
<ul>
<li>Gathering facts about remote hosts</li>
<li>Installing and uninstalling Windows features</li>
<li>Managing and querying Windows services</li>
<li>Managing user accounts and a list of users</li>
<li>Managing packages using Chocolatey (a software repository and accompanying management tool for Windows)</li>
<li>Performing Windows updates</li>
<li>Fetching multiple files from a remote machine to the Windows host</li>
<li>Executing raw PowerShell commands and scripts on target hosts</li>
</ul>
<p>Ansible allows you to automate tasks on Windows machines by connecting with either a local user or a domain user. You can run actions as an administrator using the Windows <code>runas</code> support, just as with the <code>sudo</code> command on Linux distributions.</p>
<p>Also, as <a id="_idIndexMarker063"/>Ansible is <strong class="bold">open source software</strong> (<strong class="bold">OSS</strong>), it is easy to extend its functionality by creating your own modules in PowerShell or even sending raw PowerShell commands. For example, an InfoSec team could manage filesystem <strong class="bold">access control lists</strong> (<strong class="bold">ACLs</strong>), configure<a id="_idIndexMarker064"/> Windows Firewall, and manage hostnames and domain membership with ease, using a mix of native Ansible modules and, where necessary, raw commands.</p>
<p>The Windows host <a id="_idIndexMarker065"/>must meet the following requirements for the Ansible control machine to communicate with it:</p>
<ul>
<li>Ansible attempts to support all Windows versions that are under either current or extended support from Microsoft, including desktop platforms such as Windows 8.1, 10, and 11, along with server operating systems, including Windows Server 2012 (and R2), 2016, 2019, and 2022.</li>
<li>You will also need to install PowerShell 3.0 or later and at least .NET 4.0 on your Windows host.</li>
<li>You will need to create and activate a WinRM listener, which is described in detail later. For security reasons, this is not enabled by default.</li>
</ul>
<p>Let’s look in more<a id="_idIndexMarker066"/> detail at how to prepare a Windows host to be automated by Ansible:</p>
<ol>
<li>With regard to prerequisites, you have to make sure PowerShell 3.0 and .NET Framework 4.0 are installed on Windows machines. On many modern Windows versions, you will find these are already in place, but if you’re still using an older version of PowerShell or .NET Framework, you will need to upgrade them. You are free to perform this manually, or the following PowerShell script can handle it automatically for you. You will observe that this script is not from the official Ansible repository—however, the owner is a maintainer and reviewer of the official Ansible repository. Nonetheless, whenever downloading scripts, it is good practice to review the source code and ensure <a id="_idTextAnchor052"/>that it is aligned with your security protocols and requirements:<pre class="source-code">
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$url = "https://raw.githubusercontent.com/jborean93/ansible-windows/master/scripts/Upgrade-PowerShell.ps1"
$file = "$env:temp\Upgrade-PowerShell.ps1"
$username = "Administrator"
$password = "Password"
(New-Object -TypeName System.Net.WebClient).DownloadFile($url, $file)
Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Force
&amp;$file -Version 5.1 -Username $username -Password $password -Verbose</pre></li> </ol>
<p>This script works by examining the programs that need to be installed (such as .NET Framework 4.5.2) and the required PowerShell version (we have specified <code>5.1</code> on the last line of the preceding code snippet—valid values for this are <code>3.0</code>, <code>4.0</code>, or <code>5.1</code>. We also specify an account with administrator privileges, so be sure to set the <code>$username</code> and <code>$password</code> variables appropriately for your system. If a valid username and password are set, and a reboot is required after the script finishes, it will automatically restart and log on at reboot so that no more action is<a id="_idIndexMarker067"/> required, and the script will continue until the PowerShell version matches the target version.</p>
<p>It is important to<a id="_idIndexMarker068"/> note that if the credentials are set to enable automatic reboots, they are also stored in plaintext in the registry, so it’s important to check that they have been cleared out after the script run. The following snippet of PowerShell will achieve this, and it is recommended you run it after the script as a matter of routine to ensure your credentials do not get leaked:</p>
<pre class="source-code">
<strong class="bold">$reg_winlogon_path = "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon"</strong>
<strong class="bold">Set-ItemProperty -Path $reg_winlogon_path -Name AutoAdminLogon -Value 0</strong>
<strong class="bold">Remove-ItemProperty -Path $reg_winlogon_path -Name DefaultUserName -ErrorAction SilentlyContinue</strong>
<code>username</code> and <code>password</code> parameters aren’t set, the script will ask the user to reboot and log in manually if necessary, and the next time the user logs in, the script will continue at the point where it was interrupted. The process continues until the host meets the requirements for Ansible automation.</p>
<p>Once you have<a id="_idIndexMarker069"/> completed the script run, you should set the <a id="_idIndexMarker070"/>execution policy back to a more secure value. For W<a id="_idTextAnchor053"/>indows servers, this would be achieved using this PowerShell command:</p>
<pre class="source-code">
<strong class="bold">Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Force</strong></pre> <p>On Windows clients (for example, Windows 10 or Windows 11), this would be achieved via the following command:</p>
<pre class="source-code">
<strong class="bold">Set-ExecutionPolicy -ExecutionPolicy Restricted -Force</strong></pre> <p>These are the default settings for the aforementioned operating systems, but if you want to check the execution policy setting prior to performing any of the script runs, you can query it before running your scripts with the following command:</p>
<pre class="source-code">
<strong class="bold">Get-ExecutionPolicy</strong></pre> <p>Once you have the required version of PowerShell and the .NET Framework installed, you can move on to the next step.</p>
<ol>
<li value="2">When PowerShell has been upgraded to at least version 3.0, the next step will be to configure the WinRM service so that Ansible can connect to it. WinRM service configuration defines how Ansible can interface with the Windows hosts, including the listener port and protocol.</li>
</ol>
<p>If you have never set up a WinRM listener before, you have three options to do <a id="_idTextAnchor054"/><a id="_idTextAnchor055"/>this, as follows:</p>
<ul>
<li>Firstly, you can use <code>winrm quickconfig</code> for HTTP and <code>winrm quickconfig -transport:https</code> for HTTPS. This is the simplest method to use when you need to run outside of the domain environment and just create a<a id="_idIndexMarker071"/> simple listener. This process has the advantage of opening the required port in the Windows Firewall and automatically starting the WinRM service.</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">More recent versions of<a id="_idIndexMarker072"/> Windows (for example, Windows Server 2022) will only let you run <code>winrm quickconfig -transport:https</code> if you already have a <strong class="bold">Secure Sockets Layer</strong> (<strong class="bold">SSL</strong>) certificate installed on your node that matches its hostname and is not self-signed. If this is not the case in your environment, the simplest approach is actually to use the PowerShell commands given next.</p>
<ul>
<li>If you are running in a domain environment, I strongly recommend using<strong class="bold"> group policy objects</strong> (<strong class="bold">GPOs</strong>) because<a id="_idIndexMarker073"/> if the host is the domain member, then the configuration is done automatically without user input. There are many <a id="_idIndexMarker074"/>documented procedures for doing this available, but as this is a very Windows domain-centric task, it is beyond <a id="_idIndexMarker075"/>the scope of this book.</li>
<li>Finally, you can create a listener with a specific configuration by<a id="_idTextAnchor056"/> running the following PowerShell commands with administrative privileges:<pre class="source-code">
<strong class="bold">$selector_set = @{</strong>
<strong class="bold">    Address = "*"</strong>
<strong class="bold">    Transport = "HTTPS"</strong>
<strong class="bold">}</strong>
<strong class="bold">$value_set = @{</strong>
<strong class="bold">    CertificateThumbprint = "2c8951160e63b33593e7bbc3a22414a5ab259717"</strong>
<strong class="bold">}</strong>
<strong class="bold">New-WSManInstance -ResourceURI "winrm/config/Listener" -SelectorSet $selector_set -ValueSet $value_set</strong></pre></li> </ul>
<p>The preceding <code>CertificateThumbprint</code> value should match the thumbprint of a valid SSL certificate that you previously created or imported into the Windows<a id="_idIndexMarker076"/> Certificate Store. Note that if you use this method to configure your WinRM listener, the Windows Firewall is not automatically configured. You can<a id="_idIndexMarker077"/> configure it appropriately to l<a id="_idTextAnchor057"/>isten on port <code>5986</code> (HTTPS) using a PowerShell command such as the following:</p>
<pre class="source-code">
<strong class="bold">New-NetFirewallRule -DisplayName 'WinRM over HTTPS' -Profile 'Any' -Direction Inbound -Action Allow -Protocol TCP -LocalPort 5986</strong></pre> <p>In this simple example, we will perform basic authentication against a Windows host—this will only work with local accounts (not domain accounts) but is a quick and easy way to get acquainted with Windows automation. When you are ready to start experimenting with Kerberos authentication, the Ansible documentation provides a valuable reference for you to work from: <a href="https://docs.ansible.com/ansible/latest/os_guide/windows_winrm.xhtml">https://docs.ansible.com/ansible/latest/os_guide/windows_winrm.xhtml</a>.</p>
<p>In the meantime, it is important to note that basic authentication isn’t enabled by default on Windows hosts. To enable it, run the following PowerShell command:</p>
<pre class="console">
Set-Item -Path "WSMan:\localhost\Service\Auth\Basic" -Value $true</pre> <p>If you are running in PowerShell v3.0, you might face an issue with the WinRM service that limits the amount of memory available. This is a known bug, and a hotfix is available to resolve it. An example process (written in PowerShell) to apply this hotfix is given here:</p>
<pre class="source-code">
[Net.ServicePointManager]::SecurityProtocol = [Net.SecurityProtocolType]::Tls12
$url = "https://raw.githubusercontent.com/jborean93/ansible-windows/master/scripts/Install-WMF3Hotfix.ps1"
$file = "$env:temp\Install-WMF3Hotfix.ps1"
(New-Object -TypeName System.Net.WebClient).DownloadFile($url, $file)
powershell.exe -ExecutionPolicy ByPass -File $file -Verbose</pre> <p>Configuring WinRM<a id="_idIndexMarker078"/> listeners can be a complex task, so it is important to be able to check the results of your configuration process. The following <a id="_idIndexMarker079"/>command (which can be r<a id="_idTextAnchor058"/>un from Command Prompt) will display the current WinRM listener configuration:</p>
<pre class="console">
winrm enumerate winrm/config/Listener</pre> <p>If all goes well, you should have output similar to this:</p>
<pre class="console">
Listener
    Address = *
    Transport = HTTP
    Port = 5985
    Hostname
    Enabled = true
    URLPrefix = wsman
    CertificateThumbprint
    ListeningOn = 10.0.50.100, 127.0.0.1, ::1, fe80::460:ba22:fac4:71ff%5
Listener
    Address = *
    Transport = HTTPS
    Port = 5986
    Hostname
    Enabled = true
    URLPrefix = wsman
    CertificateThumbprint = 2c8951160e63b33593e7bbc3a22414a5ab259717
    ListeningOn = 10.0.50.100, 127.0.0.1, ::1, fe80::460:ba22:fac4:71ff%5</pre> <p>According to the preceding output, two listeners are active—one to listen on port <code>5985</code> over HTTP and the other to listen on port <code>5986</code> over HTTPS, providing greater security. By way of additional <a id="_idIndexMarker080"/>explanation, the following parameters are also displayed in the preceding output:</p>
<ul>
<li><code>Transport</code>: This <a id="_idIndexMarker081"/>should be set to either <code>HTTP</code> or <code>HTTPS</code>, though it is strongly recommended that you use the <code>HTTPS</code> listener to ensure your automation commands are not subject to snooping or manipulation.</li>
<li><code>Port</code>: This is the port on which the listener operates, by default <code>5985</code> for <code>HTTP</code> or <code>5986</code> for <code>HTTPS</code>.</li>
<li><code>URLPrefix</code>: This is the URL prefix to communicate with—by default, <code>wsman</code>. If you change it, you must set the <code>ansible_winrm_path</code> host on your Ansible control host to the same value.</li>
<li><code>CertificateThumbprint</code>: If running on an HTTPS listener, this is the certificate thumbprint of the Windows Certificate Store used by the connection.</li>
</ul>
<p>If you need to debug any connection issues after setting up your WinRM listener, you may find the following commands valuable as they perform WinRM-based connections between Windows hosts without Ansible—hence, you can use them to distinguish whether an issue you might be experiencing is related to your Ansible h<a id="_idTextAnchor059"/>ost or whether there is an issue with the WinRM listener itself:</p>
<pre class="console">
# test out HTTP
winrs -r:http://&lt;server address&gt;:5985/wsman -u:Username <a id="_idTextAnchor060"/>-p:Password ipconfig
# test out HTTPS (will fail if the cert is not verifiable)
winr<a id="_idTextAnchor061"/>s -r:https://&lt;server address&gt;:5986/wsman -u:Username<a id="_idTextAnchor062"/> -p:Password -ssl ipconfig
# test out HTTPS, ignoring certificate verification
$username = "Username"
$password = ConvertTo-SecureString -String "Password" -AsPlainText -Force
$cred = New-Object -TypeName System.Management.Automation.PSCredential -ArgumentList $username, $password
$session_option = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck
Invoke-Command -ComputerName &lt;server address&gt; -UseSSL -ScriptBlock { ipconfig } -Credential $cred -SessionOption $session_option</pre> <p>If one of the preceding commands fails, you should investigate your WinRM listener setup before <a id="_idIndexMarker082"/>attempting to set up or configure your Ansible control host.</p>
<p>At this stage, Windows<a id="_idIndexMarker083"/> should be ready to receive communication from Ansible over WinRM. To complete this process, you will need to also perform some additional configuration on your Ansible control host. First of all, you will need to install the <code>winrm</code> Python module, which, depending on your control host’s configuration, may or may not have been installed before. The installation method will vary from one operating system to another, but it can generally be installed on most platforms with PIP, as follows:</p>
<pre class="console">
$ python3 -m pip install pywinrm</pre> <p>Once this is complete, you will <a id="_idIndexMarker084"/>need to define some additional inventory variables for your Windows hosts—don’t worry too much about inventories for now as w<a id="_idTextAnchor063"/>e will cover these later in this book. The following example is just for reference:</p>
<pre class="source-code">
[windows]
10.0.50.101
[windows:vars]
ansible_user=administrator
ansible_password=password
ansible_port=5986
ansible_connection=winrm
ansible_winrm_server_cert_validation=ignore</pre> <p>Finally, you should be able to run the Ansible <code>ansible.windows.win_ping</code> module to perform an end-to-end connectivity test with a command such as the following (adjust for your inventory):</p>
<pre class="console">
$ ansible -i inventory -m ansible.windows.win_ping windows
10.0.50.101 | SUCCESS =&gt; {
 "changed": false,
 "ping": "pong"
}</pre> <p>This is just the beginning of Windows automation with Ansible—once you decide on your connectivity strategy and way of configuring (whether it be through Group Policy, PowerShell scripts, or <a id="_idIndexMarker085"/>otherwise), you will be able to automate your Windows tasks with as much effectiveness as you automate your Linux tasks.</p>
<p>In Ansible 2.8, support was even added for OpenSSH connectivity to Windows hosts, removing the complexity of WinRM configuration and the various authentication mechanisms. While<a id="_idIndexMarker086"/> this looks like a great addition to Ansible’s Windows automation capabilities, it must be stressed that even now (on release 8.0.0) it is marked as experimental and that the future may bring changes that are not backward compatible with the current code. As such, we will not explore the setup here, but if you are interested in experimenting with this Windows support for yourself, you <a id="_idIndexMarker087"/>are encouraged to look at this section of the official Ansible documentation: <a href="https://docs.ansible.com/ansible/latest/os_guide/windows_setup.xhtml#windows-ssh-setup">https://docs.ansible.com/ansible/latest/os_guide/windows_setup.xhtml#windows-ssh-setup</a>.</p>
<p>Now that you have learned<a id="_idIndexMarker088"/> the fundamental steps to configure Windows ho<a id="_idTextAnchor064"/>s<a id="_idTextAnchor065"/>ts for Ansible, let’s see how to manage multiple nodes via Ansible in the next section.</p>
<h1 id="_idParaDest-25"><a id="_idTextAnchor066"/>Getting to know your Ansible installation</h1>
<p>By this stage in this <a id="_idIndexMarker089"/>chapter, regardless of your choice of operating system for your Ansible control machine, you should have a working installation of Ansible with which to begin exploring the world of automation. In this section, we will carry out a practical exploration of the fundamentals of Ansible to help you to understand how to work with it. Once you have mastered these basic skills, you will then have the knowledge required to get the most out of the remainder of th<a id="_idTextAnchor067"/>i<a id="_idTextAnchor068"/>s book. Let’s get started with an overview of how Ansible connects to non-Windows hosts.</p>
<h2 id="_idParaDest-26"><a id="_idTextAnchor069"/>Understanding how Ansible connects to hosts</h2>
<p>With the exception <a id="_idIndexMarker090"/>of Windows hosts (as discussed at the end of the previous section), Ansible uses the SSH protocol to communicate with hosts. The reasons for this choice in the Ansible design are many, not least that just about every Linux/FreeBSD/macOS host has it built in, as do many network devices such as switches and routers. The SSH service is normally integrated with the operating system authentication stack, enabling you to take advantage of host-based identity verification, and a variety of authentication mechanisms, including Kerberos, to improve authentication security. Also, features of OpenSSH such as <code>ControlPersist</code> are used to increase the performance of automation tasks and SSH jump hosts/bastions for network isolation and security.</p>
<p class="callout-heading">Note</p>
<p class="callout"><code>ControlPersist</code> is enabled by default on most modern Linux distributions as part of the OpenSSH server installation. However, on some older operating systems such as RHEL 6 (and CentOS 6), it is not supported, so you will not be able to use it. Ansible automation is still perfectly possible, but longer playbooks might run slower.</p>
<p>Ansible makes use of the same authentication methods that you will already be familiar with, and SSH keys are normally the easiest way to proceed as they remove the need for users to input the authentication password every time a playbook is run. However, this is by no means mandatory, and Ansible supports password authentication through the use of the <code>--ask-pass</code> switch. If you are connecting to an unprivileged account on the managed nodes and need to perform the Ansible equivalent of running commands under <code>sudo</code> with a password, you can also add <code>--ask-become-pass</code> when you run your playbooks to allow this to be specified at runtime as well.</p>
<p>The goal of automation is to<a id="_idIndexMarker091"/> be able to run tasks securely but with minimal user intervention. As a result, it is highly recommended that you use SSH keys for authentication, and if you have several keys to manage, then it is advisable to make use of <code>ssh-agent</code>.</p>
<p>Every Ansible task, whether it is run individually or as part of a complex playbook, is run against an inventory. An inventory is, quite simply, a list of hosts that you wish to run automation tasks against. Ansible supports a wide range of inventory formats, including the use of dynamic inventories, which can populate themselves automatically from an orchestration<a id="_idIndexMarker092"/> provider (for example, you can generate an Ansible inventory dynamically from your Amazon <strong class="bold">Elastic Compute Cloud</strong> (<strong class="bold">EC2</strong>) instances, meaning you don’t have to keep up with all of the changes in your cloud infrastructure).</p>
<p>Dynamic inventory plugins<a id="_idIndexMarker093"/> have been written for most major cloud providers (for example, Amazon EC2, <strong class="bold">Google Cloud Platform</strong> (<strong class="bold">GCP</strong>), and Microsoft Azure), as well as on-premises systems such as OpenShift and OpenStack. There are even plugins for Docker. The beauty of OSS is that for most of the major use cases you can dream of, someone has already contributed the code, so you don’t need to figure it out or write it for yourself.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Ansible’s agentless architecture and the fact that it doesn’t rely on SSL means that you don’t need to worry about DNS not being set up or even time skew problems as a result of the <strong class="bold">Network Time Protocol</strong> (<strong class="bold">NTP</strong>) not<a id="_idIndexMarker094"/> working—these can, in fact, be tasks performed by an Ansible playbook! Ansible really was designed to get your infrastructure running from a virtually bare operating system image.</p>
<p>For now, let’s focus on the INI-formatted inventory. An example is shown here with four servers, each split into two<a id="_idIndexMarker095"/> groups. Ansible commands and playbooks can be run against an entire inventory (that<a id="_idTextAnchor070"/> is, all four servers), one or more groups (for example, <code>webservers</code>), or even a single server:</p>
<pre class="source-code">
[webservers]
web01.example.org
web02.example.org
[apservers]
app01.example.org
app02.example.org</pre> <p>Let’s use this inventory file along with the Ansible <code>ping</code> module, which is used to test whether Ansible can successfully perform automation tasks on the inventory host in question. The following example assumes you have installed the inventory in the default location, which is normally <code>/etc/ansible/hosts</code>. When you run the following <code>ansible</code> command against this inventory with the <code>ping</code> module, you should see output similar to this:</p>
<pre class="console">
$ ansible webservers -m anisble.builtin.ping
web01.example.org | SUCCESS =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
web02.example.org | SUCCESS =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}</pre> <p>Notice that the <code>ansible.builtin.ping</code> module was only run on the two hosts in the <code>webservers</code> group and not the entire inventory—this was by virtue of us specifying this group name in the command-line parameters.</p>
<p>The <code>ansible.builtin.ping</code> module is one of many thousands of modules for Ansible, all of which perform a given set of tasks (from copying files between hosts to text substitution to complex <a id="_idIndexMarker096"/>network device configuration). Again, as Ansible is OSS, there is a veritable army of coders out there who are writing and contributing modules, which means if you can dream of a task, there’s probably already an Ansible module for it. Even in the instance that no module exists, Ansible supports sending raw shell commands (or PowerShell commands for Windows hosts), and so even in this eventuality, you can complete your desired tasks without having to move away from Ansible.</p>
<p>As long as the Ansible control node can communicate with the managed nodes in your inventory, you can automate your tasks. However, it is worth giving some consideration to where you place your control node. For example, if you are working exclusively with a set of Amazon EC2 machines, it arguably would make more sense for your Ansible control machine to be an EC2 instance—in this way, you are not sending all of your automation commands over the internet. It also means that you don’t need to expose the SSH port of your EC2 hosts to the internet, hence keeping them more secure.</p>
<p>We have so far covered a brief explanation of how Ansible communicates with its target hosts, including what inventories are and the importance of SSH communication to all except Windows hosts. In the next section<a id="_idTextAnchor071"/>,<a id="_idTextAnchor072"/> we will build on this by looking in greater detail at how to verify your Ansible installation.</p>
<h2 id="_idParaDest-27"><a id="_idTextAnchor073"/>Verifying the Ansible installation</h2>
<p>In this section, you will learn how you can verify your Ansible installation with simple ad hoc commands.</p>
<p>As discussed<a id="_idIndexMarker097"/> previously, Ansible can authenticate with your managed nodes in several ways. In this section, we will assume you want to make use of SSH keys and that you have already generated your public and private key pair and applied your public key to all of the managed nodes that you will be automating tasks on.</p>
<p class="callout-heading">Tip</p>
<p class="callout">The <code>ssh-copy-id</code> utility is incredibly useful for distributing your public SSH key to your target hosts before you proceed any further. An example command might be <code>ssh-copy-id -i ~/.</code><code>ssh/id_rsa ansibleuser@web1.example.com</code>.</p>
<p>To ensure Ansible can authenticate with your private key, you could make use of <code>ssh-agent</code>—the following commands show a simple example of how to start <code>ssh-agent</code> and add your private key to it. Naturally, you should replace the path with that to your own private key:</p>
<pre class="console">
$ eval $(ssh-agent)
Agent pid 3064
$ ssh-add ~/.ssh/id_rsa
Identity added: /home/james/.ssh/id_rsa (james@controlnode)</pre> <p>As we discussed in the previous section, we must also define an inventory for Ansible to run against. Another simple example is shown here:</p>
<pre class="source-code">
[webservers]
web01.example.org
web02.example.org</pre> <p>The <code>ansible</code> command that we used in the previous section has two important switches that you will almost always use: <code>-m &lt;MODULE_NAME&gt;</code> to run a module on the managed nodes from your inventory that you specify and, optionally, the module arguments passed using the <code>-a OPT_ARGS</code> switch. Commands run using the <code>ansible</code> binary are known as ad hoc commands.</p>
<p>The following are three simple examples that demonstrate ad hoc commands—they are also valuable for verifying both the installation of Ansible on your control machine and the configuration of your target hosts, and they will return an error if there is an issue with any part of the configuration. Here, we are introducing the <code>-i</code> switch, which is used to tell Ansible that <a id="_idIndexMarker098"/>we are specifying a different inventory file from the default— we’ll be using this frequently throughout the book from here on:</p>
<ul>
<li><code>ping</code> on your inventory hosts using the following command:<pre class="source-code">
<strong class="bold">$ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.ping</strong></pre></li> <li><strong class="bold">Display gathere<a id="_idTextAnchor075"/>d facts</strong>: You can display gathered facts about your inventory hosts using the following command:<pre class="source-code">
<strong class="bold">$ ansible webservers -i /etc/ansible/hosts -m ansible.builtin<a id="_idTextAnchor076"/>.setup | less</strong></pre></li> <li><strong class="bold">Filter gathered facts</strong>: You can filter gathered facts using the following command:<pre class="source-code">
<strong class="bold">$ ansible webservers -i /etc/ansible/hosts -m ansible.builtin.setup -a "filter=ansible_distribution*"</strong></pre></li> </ul>
<p>For every ad hoc command you run, you will get a response in JSON format—t<a id="_idTextAnchor077"/>he following example output results from running the <code>ansible.builtin.ping</code> module successfully:</p>
<pre class="console">
$ ansible webservers -m ansible.builtin.ping
web02.example.org | SUCCESS =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}
web01.example.org | SUCCESS =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}</pre> <p>Ansible can also gather and return facts about your target hosts—facts are all manner of useful information about your hosts, from CPU and memory configuration, to network parameters, to disk geometry. These facts are intended to enable you to write intelligent playbooks that perform conditional actions—for example, you might only want to install a given software <a id="_idIndexMarker099"/>package on hosts with more than 4 GB of RAM or perhaps perform a specific configuration only on macOS hosts. The following is an example of the filtered facts from a macOS-based host—note the special syntax of the  <code>-i</code> inventory parameter; by placing a comma after the hostname, we are telling the <code>ansible</code> command to read the inventory <a id="_idTextAnchor078"/>from the command line, rather than a file (a handy shortcut when you’re testing and developing):</p>
<pre class="console">
$ ansible -i machost.example.org, -m ansible.builtin.setup -a "filter=ansible_distribution*" all
machost.example.org | SUCCESS =&gt; {
    "ansible_facts": {
        "ansible_distribution": "MacOSX",
        "ansible_distribution_major_version": "13",
        "ansible_distribution_release": "22.4.0",
        "ansible_distribution_version": "13.3.1",
        "discovered_interpreter_python": "/opt/homebrew/bin/python3.11"
    },
    "changed": false
}</pre> <p>Ad hoc commands are incredibly powerful, both for verifying your Ansible installation and for learning Ansible and how to work with modules, as you don’t need to write a whole playbook—you can just run a module with an ad hoc command and learn how it responds. Here are some<a id="_idIndexMarker100"/> more ad hoc examples for you to consider:</p>
<ul>
<li>Copy a file from <a id="_idTextAnchor079"/>the Ansible control node to all managed nodes in the <code>webservers</code> group with the following command:<pre class="source-code">
<code>webservers</code> inventory group, and create it with specific ownership and permissions, as follows:<pre class="source-code">
<code>webservers</code> group with the following command:<pre class="source-code">
<code>apache2</code> package with <code>apt</code> if it is not already present—if it is present, do not update it. Again, this applies to all hosts in the <code>webservers</code> inventory group. Note the presence of the <code>--become</code> switch—as we’re installing packages, we must <em class="italic">become</em> the root user using <code>sudo</code>. Thi<a id="_idTextAnchor081"/>s <a id="_idTextAnchor082"/>command assumes that the user account on the managed node can perform passwordless <code>sudo</code> commands:<pre class="source-code">
<code>state=present</code> to <code>state=latest</code> causes Ansible to install the (latest version of the) package if it is not present, and update it to the latest version if it is present:<pre class="source-code">
<strong class="bold">$ ansible webservers -m ansible.builtin.apt -a "name=apache2 state=latest" --become</strong></pre></li> <li>Di<a id="_idTextAnchor083"/>splay all facts about all the hosts in your inventory (warning—this will produce a lot of JSON!):<pre class="source-code">
<strong class="bold">$ ansible all -m ansible.builtin.setup</strong></pre></li> </ul>
<p>Now that you have learned <a id="_idIndexMarker101"/>more about verifying your Ansible installation and about how to run ad hoc commands, let’s<a id="_idTextAnchor084"/> <a id="_idTextAnchor085"/>proceed to look in a bit more detail at the requirements of nodes that are to be managed by Ansible.</p>
<h1 id="_idParaDest-28"><a id="_idTextAnchor086"/>Managed node requirements</h1>
<p>So far, we have <a id="_idIndexMarker102"/>focused almost exclusively on the requirements for the Ansible control host and have assumed that (except for the distribution of the SSH keys) the target hosts will just work. This, of course, is not always the case, and for example, while a modern installation of Linux installed from an ISO will often just work, cloud operating system images are often stripped down to keep them small, and so might lack important packages such as Python, without which Ansible cannot operate.</p>
<p>If your target hosts are lacking Python, it is usually easy to install it through your operating system’s package management system. Ansible requires you to install either Python version 2.7 or 3.5 (and above) on the Ansible-managed nodes but has more stringent requirements for the control node. At the time of writing, <code>ansible-core</code> 2.15 (which accompanies Ansible 8.0.0) requires a version of Python between 3.9 and 3.11 to be installed on the control node. This is likely to change with new releases, so you are advised to always consult the official documentation to check the latest requirements: <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements">https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements</a>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Again, the exception here is Windows, which relies on PowerShell instead of Python.</p>
<p>If you are working with operating system images on managed nodes that lack Python, the following commands provide a quick guide to getting Python installed:</p>
<ul>
<li>To install Python using <code>yum</code> (on older releases of Fedora and CentOS/RHEL 7 and below), use the following command:<pre class="source-code">
<code>dnf</code> package manager instead. Here’s the command you’d execute:<pre class="source-code">
<strong class="bold">$ sudo dnf install python</strong></pre></li> </ul>
<p>You might also<a id="_idIndexMarker103"/> elect to install a specific version to suit your needs, as in this example:</p>
<pre class="source-code">
<strong class="bold">$ sudo dnf install python39</strong></pre> <ul>
<li>On Debian and Ubuntu systems, you would use the <code>apt</code> package manager to install Python, again specifying a version if required (the example given here is to install Python 3.10 and would work on Ubuntu 22.04):<pre class="source-code">
<strong class="bold">$ sudo apt update</strong>
<strong class="bold">$ sudo apt install python3.10</strong></pre></li> </ul>
<p>The <code>ansible.builtin.ping</code> module we discussed earlier in this chapter for Ansible not only checks connectivity and authentication with your managed hosts but also uses the managed hosts’ Python environment to perform some basic host checks. As a result, it is a fantastic end-to-end test to give you confidence that your managed nodes are configured correctly, with the connectivity and authentication set up perfectly, and to be safe in the knowledge that if Python is missing, the test would return a <code>failed</code> result.</p>
<p>Of course, a perfect question at this stage would be: How can Ansible help if you roll out 100 cloud servers using a stripped-down base image without Python? Does that mean you have to manually go through all 100 nodes and install Python by hand before you can start automating?</p>
<p>Thankfully, Ansible has you covered even in this case, thanks to the <code>ansible.builtin.raw</code> module. This module is used to send raw shell commands to the managed nodes—and it works both with SSH-managed hosts and Windows PowerShell-managed hosts. As a result, you can use Ansible to install Python on a whole set of systems from which it is missing, or even run an entire shell script to bootstrap a managed node. Most importantly, the <code>ansible.builtin.raw</code> module is one of very few that does<a id="_idIndexMarker104"/> not require Python to be installed on the managed node, so it is perfect for our use case where we must roll out Python to enable further automation.</p>
<p>The following are some examples of tasks in an Ansible playbook that you might use to bootstrap a managed node and prepare it for Ansible management:</p>
<pre class="source-code">
- name: Bootstrap a host without python3 installed
  ansible.builtin.raw: dnf install -y python3 python3-dnf libselinux-python3
- name: Run a command that uses non-posix shell-isms (in this example /bin/sh doesn't handle redirection and wildcards together but bash does)
  ansible.builtin.raw: cat &lt; /tmp/*txt
  args:
    executable: /bin/bash
- name: safely use templated variables. Always use quote filter to avoid injection issues.
  ansible.builtin.raw: "{{package_mgr|quote}} {{pkg_flags|quote}} install {{python|quote}}"</pre> <p>We have now covered the basics of setting up Ansible both on the control host and the managed nodes, and we gave you a brief primer on configuring your first connections. It is hoped that you’ve<a id="_idIndexMarker105"/> fo<a id="_idTextAnchor087"/><a id="_idTextAnchor088"/>u<a id="_idTextAnchor089"/>nd this chapter helpful and that it forms the foundation for the rest of your journey through this book.</p>
<h1 id="_idParaDest-29"><a id="_idTextAnchor090"/>Summary</h1>
<p>Ansible is a powerful and versatile yet simple automation tool, of which the key benefits are its agentless architecture and its simple installation process. Ansible was designed to get you from zero to automation rapidly and with minimal effort, and we have demonstrated the simplicity with which you can get up and running with Ansible in this chapter.</p>
<p>In this chapter, you learned the basics of setting up Ansible—how to install it to control other hosts, and the requirements for nodes being managed by Ansible. You learned about the fundamentals required to set up SSH and WinRM for Ansible automation, as well as how to bootstrap managed nodes to ensure they are suitable for Ansible automation. You also learned about ad hoc commands and their benefits. Finally, you learned how to run the latest version of the code directly from GitHub, which both enables you to contribute directly to the development of Ansible and gives you access to the very latest features should you wish to make use of them on your infrastructure.</p>
<p>In the next chapter, we will learn Ansible language fundamentals to enable you to write your first playboo<a id="_idTextAnchor091"/>k<a id="_idTextAnchor092"/>s and to help you to create templated configurations and start to build up complex automation workflows.</p>
<h1 id="_idParaDest-30"><a id="_idTextAnchor093"/>Questions</h1>
<ol>
<li>On which operating systems can you set up an Ansible control node? (There are multiple correct answers.)<ol><li>Ubuntu 22.04</li><li>Fedora 35</li><li>Windows Server 2022</li><li>HP-UX</li><li>Mainframe</li></ol></li>
<li>Which protocol does Ansible use to connect to non-Windows managed nodes for running tasks?<ol><li>HTTP</li><li>HTTPS</li><li>SSH</li><li>TCP</li><li>UDP</li></ol></li>
<li>T<a id="_idTextAnchor094"/>o<a id="_idTextAnchor095"/> execute a specific module in the Ansible ad hoc command line, you need to use the <code>-</code><code>m</code> option.<ol><li>True</li><li>False</li></ol></li>
</ol>
<h1 id="_idParaDest-31"><a id="_idTextAnchor096"/>Further reading</h1>
<ul>
<li><a id="_idTextAnchor097"/>For any questions about installation via Ansible’s mailing list on Google Groups, refer to the following URL:</li>
</ul>
<p><a href="https://groups.google.com/forum/#!forum/ansible-project">https://groups.google.com/forum/#!forum/ansible-project</a></p>
<ul>
<li>Information on how to install the latest version of <code>pip</code> can be found here:</li>
</ul>
<p><a href="https://pip.pypa.io/en/stable/installation/">https://pip.pypa.io/en/stable/installation/</a></p>
<ul>
<li>Details of specific Windows modules using PowerShell can be found here:</li>
</ul>
<p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml">https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml</a></p>
<ul>
<li>If you have a GitHub account and want to follow the GitHub project, you can keep tracking issues, bugs, and ideas for Ansible at the following URL:</li>
</ul>
<p><a href="https://github.com/ansible/ansible">https://github.com/ansible/ansible</a></p>
</div>
</div></body></html>