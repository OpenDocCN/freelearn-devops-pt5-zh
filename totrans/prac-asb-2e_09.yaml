- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Advanced Ansible Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have worked hard to give you a solid foundation in Ansible
    so that, whatever your desired automation task, you can implement it with ease
    and confidence. However, when you really start to ramp up your automation, how
    do you ensure that you can handle any condition that arises in a graceful manner?
    For example, how can you ensure that when you have to initiate long-running actions,
    you can run them asynchronously and come back to them to check on the results
    reliably later? Or, if you are updating a large group of servers, how can you
    ensure that the play fails early if a handful of servers suffer failures? The
    last thing you want to do is to roll out a broken update (let’s face it, problems
    do occur with everyone’s code from time to time) across 100 servers—far better
    to detect that a small percentage have failed and abort the entire play on this
    basis than attempt to continue and break an entire load-balanced cluster.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at how to solve these particular issues, as well
    as many more, using some of the more advanced features of Ansible to control playbook
    flow and error handling. We will explore, through practical examples, how to perform
    rolling updates with Ansible, how to work with proxies and jump hosts (which is
    vital for secure environments and often for core network configuration), and how
    to secure sensitive Ansible data at rest using the native Ansible Vault technology.
    By the end of this chapter, you will have a full picture of how to run Ansible
    not only in a small environment but also in a large, secure, mission-critical
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous versus synchronous actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling play execution for rolling updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the maximum failure percentage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting task execution delegation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `run_once` option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running playbooks locally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with proxies and jump hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring playbook prompts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Placing tags in the plays and tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Securing data with Ansible Vault
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started
    with Ansible*, and are using the most recent version available. The examples in
    this chapter are tested with Ansible 2.15\. This chapter also assumes that you
    have at least one additional host to test against and, ideally, this should be
    Linux-based. Although we will give specific examples of hostnames in this chapter,
    you are free to substitute them with your own hostname and/or IP addresses; details
    of how to do this are provided at the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle for this chapter is available at [https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%209](https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%209).
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous versus synchronous actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in this book so far, Ansible plays are executed in sequence,
    with each task running to completion before the next task is started. Although
    this is often advantageous for flow control and logical sequencing, there are
    times when you may not want this. In particular, it might be the case that a particular
    task runs for longer than the configured SSH connection timeout, and as Ansible
    uses SSH to perform its automation tasks on most platforms, this would be an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Ansible tasks can be run asynchronously—that is to say, tasks can
    be run in the background on the target host and polled on a regular basis. This
    is in contrast to synchronous tasks, where the connection to the target host is
    kept open until the task completes (which runs the risk of a timeout occurring).
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, let’s explore this through a practical example. Suppose we have two
    servers in a simple INI-formatted inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in order to simulate a long-running task, we’ll run the `sleep` command
    using the `shell` module. However, rather than have it run with the SSH connection
    blocked for the duration of the `sleep` command, we’ll add two special parameters
    to the task, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The two new parameters are `async` and `poll`. The `async` parameter tells Ansible
    that this task should be run asynchronously (so that the SSH connection will not
    be blocked) for a maximum of `30` seconds. If the task runs for longer than this
    configured time, Ansible considers the task to have failed and the play is failed,
    accordingly. When `poll` is set to a positive integer, Ansible checks the status
    of the asynchronous task at the specified interval—in this example, every `5`
    seconds. If `poll` is set to `0`, then the task is run in the background and never
    checked—it is up to you to write a task to manually check its status later on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you don’t specify the `poll` value, it will be set to the default value defined
    by the `DEFAULT_POLL_INTERVAL` configuration parameter of Ansible (which is `10`
    seconds).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run this playbook, you will find that it runs just like any other
    playbook; from the terminal output, you won’t be able to see any difference. But
    behind the scenes, Ansible checks the task every `5` seconds until it succeeds
    or reaches the `async` timeout value of `30` seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to check on the task later (that is, if `poll` is set to `0`),
    you could add a second task to your playbook so that it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In this playbook, the initial asynchronous task is defined as before, except
    we have now set `poll` to `0`. We have also chosen to register the result of this
    task to a variable called `long_task`—this is so that we can query the job ID
    for the task when we check it later on. The next (new) task in the play uses the
    `async_status` module to check on the job ID we registered from the first task
    and loops until the job either finishes or reaches `30` retries—whichever comes
    first. When using these in a playbook, you almost certainly wouldn’t add the two
    tasks back to back like this—usually, you would perform additional tasks in between
    them—but to keep this example simple, we will run the two tasks sequentially.
    Running this playbook should yield an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we can see that the long-running task is left running
    and the next task polls its status until the conditions we set are met. In this
    case, we can see that the task finished successfully and the overall play result
    was successful. Asynchronous actions are especially useful for large downloads,
    package updates, and other tasks that might take a long time to run. You may find
    them useful in your playbook development, especially in more complex infrastructures.
  prefs: []
  type: TYPE_NORMAL
- en: With this under our belt, let’s take a look at another advanced technique that
    might be useful in large infrastructures—performing rolling updates with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling play execution for rolling updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By default, Ansible parallelizes tasks on multiple hosts at the same time to
    speed up automation tasks in large inventories. The setting for this is defined
    by the `forks` parameter in the Ansible configuration file, which defaults to
    `5` (so, by default, Ansible attempts to run its automation job on five hosts
    at the same time).
  prefs: []
  type: TYPE_NORMAL
- en: In a load-balanced environment, this is not ideal, especially if you want to
    avoid downtime. Suppose we have five frontend servers in an inventory (or perhaps
    even fewer). If we allow Ansible to update all of these at the same time, the
    end users may experience a loss of service. So, it is important to consider updating
    all of the servers at different times. Let’s reuse our inventory from the previous
    section with just two servers in it. Obviously, if these were in a load-balanced
    environment, it would be vital that we only update one of these at a time; if
    both were taken out of service simultaneously, then end users would definitely
    lose access to the service until the Ansible play completes successfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer to this is to use the `serial` keyword in the play definition to
    determine how many hosts are operated on at once. Let’s demonstrate this through
    a practical example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following simple playbook to run two commands on the two hosts in
    our inventory. The content of the command is not important at this stage, but
    if you run the `date` command using the `command` module, you will be able to
    see the time that each task is run, as well as if you specify `-v` to increase
    the verbosity when you run the play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if you run this play, you will see that it performs all the operations
    on each host simultaneously, as we have fewer hosts than the default number of
    forks—`5`. This behavior is normal for Ansible, but not really what we want as
    our users will experience a service outage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: Simple serial demonstration play'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'hosts: frontends'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'serial: 1'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'gather_facts: false'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the presence of the `serial: 1` line. This tells Ansible to complete
    the play on `1` host at a time before moving on to the next. If we run the play
    again, we can see this in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Much better! If you imagine that this playbook actually disables these hosts
    on a load balancer, performs an upgrade, and then re-enables the hosts on the
    load balancer, this is exactly how you would want the operation to proceed. Doing
    so without the `serial: 1` directive would result in all the hosts being removed
    from the load balancer at once, causing a loss of service.'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is useful to note that the `serial` directive can also take a percentage
    instead of an integer. When you specify a percentage, you are telling Ansible
    to run the play on that percentage of hosts at one time. So, if you have four
    hosts in your inventory and specify `serial: 25%`, Ansible will only run the play
    on one host at a time. If you have eight hosts in your inventory, it will run
    the play on two hosts at a time. I’m sure you get the idea!'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can even build on this by passing a list to the `serial` directive. Consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This tells Ansible to run the play on `1` host, initially, then on the next
    `3`, and then on batches of `5` at a time until the inventory is completed for
    deploying a new change to particular servers. You can also specify a list of percentages
    in place of the integer numbers of hosts. In doing this, you will build up a robust
    playbook that can perform rolling updates without causing a loss of service to
    end users. With this complete, let’s further build on this knowledge by looking
    at controlling the maximum failure percentage that Ansible can tolerate before
    it aborts a play, which will again be useful in highly available or load-balanced
    environments such as this.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the maximum failure percentage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In its default mode of operation, Ansible continues to execute a play on a batch
    of servers (the batch size is determined by the `serial` directive we discussed
    in the preceding section) as long as there are hosts in the inventory and a failure
    isn’t recorded. Obviously, in a highly available or load-balanced environment
    (such as the one we discussed previously), this is not ideal. If there is a bug
    in your play, or perhaps a problem with the code being rolled out, the last thing
    that you want is for Ansible to faithfully roll it out to all servers in the cluster,
    causing a service outage because all the nodes suffered a failed upgrade. It would
    be far better, in this kind of environment, to fail early on and leave at least
    some hosts in the cluster untouched until someone can intervene and resolve the
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our practical example, let’s consider an expanded inventory with 10 hosts
    in it. We’ll define this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s create a simple playbook to run on these hosts. We will set our
    batch size to `5` and `max_fail_percentage` to `50%` in the play definition:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the following play definition to demonstrate the use of the `max_fail_percentage`
    directive:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have defined 10 hosts in our inventory, so it will process them in batches
    of 5 (as specified by `serial: 5`). The play will be aborted, and processing will
    stop if more than 50% of the hosts in one batch fail.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The percentage of failed hosts must exceed the value of `max_fail_percentage`;
    if it is equal, the play continues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will define two simple tasks. The first task has a special clause
    under it that we use to deliberately simulate a failure—this line starts with
    `failed_when` and we use it to tell the task that if it runs this task on the
    first three hosts in the batch, then it should deliberately fail this task, regardless
    of the result; otherwise, it should allow the task to run as normal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will add a second task that will always succeed. This is run if
    the play is allowed to continue, but not if it is aborted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, we have deliberately constructed a playbook that will run on a 10-host inventory
    in batches of 5 hosts at a time, but the play is aborted if more than 50% of the
    hosts in any given batch experience a failure. We have also deliberately set up
    a failure condition that causes 3 of the hosts in the first batch of 5 (60%) to
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the playbook and observe what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the results of this playbook. We deliberately failed three of the first
    batch of five, exceeding the threshold for `max_fail_percentage` that we set.
    This immediately causes the play to abort and the second task is not performed
    on the first batch of five. You will also notice that the second batch of 5, out
    of the 10 hosts, is never processed, so our play was truly aborted. This is exactly
    the behavior you would want to see to prevent a failed update from rolling out
    across a cluster. Through the careful use of batches and `max_fail_percentage`,
    you can safely run automated tasks across an entire cluster without the fear of
    breaking the entire cluster in the event of an issue. In the next section, we
    will take a look at another feature of Ansible that can be incredibly useful when
    it comes to working with clusters—task delegation.
  prefs: []
  type: TYPE_NORMAL
- en: Setting task execution delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In every play we have run so far, we have assumed that all the tasks are executed
    on each host in the inventory in turn. However, what if you need to run one or
    two tasks on a different host? For example, we have talked about the concept of
    automating upgrades on clusters. Logically, however, we would want to automate
    the entire process, including the removal of each host in turn from the load balancer
    and their return after the task is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although we still want to run our play across our entire inventory, we certainly
    don’t want to run the load balancer commands from those hosts. Let’s once again
    explain this in more detail with a practical example. We’ll reuse the two simple
    host inventories that we used earlier in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to work on this, let’s create two simple shell scripts in the same directory
    as our playbook. These are only examples, as setting up a load balancer is beyond
    the scope of this book. However, imagine that you have a shell script (or other
    executables) that you can call that can add and remove hosts to and from a load
    balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, create a script called `remove_from_loadbalancer.sh`, which
    will contain the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '#!/bin/sh'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: echo Adding $1 to load balancer...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Obviously, in a real-world example, there would be much more code in these scripts!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a playbook that will perform the logic we outlined here. We will
    first create a quite simple play definition (you are free to experiment with the
    `serial` and `max_fail_percentage` directives as you wish) and an initial task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice the task structure—most of it will be familiar to you. We are using the
    `command` module to call the script we created earlier, passing the hostname from
    the inventory being removed from the load balancer to the script. We use the `chdir`
    argument with the `playbook_dir` magic variable to tell Ansible that the script
    is to be run from the same directory as the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The special part of this task is the `delegate_to` directive, which tells Ansible
    that even though we’re iterating through an inventory that does not contain `localhost`,
    we should run this action on `localhost` (we are not copying the script to our
    remote hosts, so it will not run if we attempt to run it from there).
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we add a task where the upgrade work is carried out. This task
    has no `delegate_to` directive, so it is run on the remote host from the inventory
    (as desired):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the host back to the load balancer using the second script
    we created earlier. This task is almost identical to the first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'See this playbook in action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how even though Ansible is working through the inventory (which doesn’t
    feature `localhost`), the load balancer-related scripts are actually run from
    `localhost`, while the upgrade task is performed directly on the remote host.
    This, of course, isn’t the only thing you can do with task delegation, but it’s
    a common example of a way that it can help you.
  prefs: []
  type: TYPE_NORMAL
- en: 'In truth, you can delegate any task to `localhost`, or even another non-inventory
    host. You could, for example, run an `rsync` command delegated to `localhost`
    to copy files to remote hosts using a similar task definition to the previous
    one. Also, note that you can choose to use a form of shorthand notation in your
    playbooks (and roles) for `delegate_to`, called `local_action`. This allows you
    to specify a task on a single line that would ordinarily be run with `delegate_to:
    localhost` added below it. Wrapping this all up into a second example, our playbook
    will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding shorthand notation is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this playbook, we can see that `local_action` simply runs a module
    on the machine running Ansible (which is often `localhost`, but not necessarily
    always), enabling us to efficiently copy whole directory trees across to remote
    servers in the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This concludes our look at task delegation; although, as stated, these are just
    two common examples. I’m sure you can think up some more advanced use cases for
    this capability. Let’s continue looking at controlling the flow of Ansible code
    by proceeding, in the next section, to look at the special `run_once` option.
  prefs: []
  type: TYPE_NORMAL
- en: Using the run_once option
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with clusters, you will sometimes encounter a task that should
    only be executed once for the entire cluster. For example, you might want to upgrade
    the schema of a clustered database or issue a command to reconfigure a Pacemaker
    cluster, which would typically be issued on one node and then automatically propagated
    to all other nodes by the cluster management software. You could, of course, address
    this with a special inventory with only one host in it, or even by writing a special
    play that references one host from the inventory, but this is inefficient and
    starts to make your code fragmented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, you can write your code as you normally would but make use of the
    special `run_once` directive for any tasks you want to run only once on your inventory.
    For example, let’s reuse the 10-host inventory that we defined earlier in this
    chapter. Now, let’s proceed to demonstrate this option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the simple playbook as in the following code block. We are using a `debug`
    statement to display some output, but in real life, you would insert your script
    or command that performs your one-off cluster function here (for example, upgrading
    a database schema):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, run this playbook and see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice that, just as desired, although the playbook was run on all 10 hosts
    (and, indeed, gathered facts from all 10 hosts), Ansible only ran the upgrade
    task on one host.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is important to note that the `run_once` option applies per batch of servers,
    so if we add `serial: 5` to our play definition (running our play in 2 batches
    of 5 on our inventory of 10 servers), the schema upgrade task runs twice! It runs
    once as requested, but once per batch of servers, not once for the entire inventory.
    Be careful of this nuance when working with this directive in a clustered environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add `serial: 5` to your play definition and rerun the playbook. The output
    should appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[local]'
  prefs: []
  type: TYPE_NORMAL
- en: localhost
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible -i localhosts -m ping all --ask-pass
  prefs: []
  type: TYPE_NORMAL
- en: The authenticity of host 'localhost (::1)' can't be established.
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA key fingerprint is SHA256:DUwVxH+45432pSr9qsN8Av4l0KJJ+r5jTo123n3XGvZs.
  prefs: []
  type: TYPE_NORMAL
- en: ECDSA key fingerprint is MD5:78:d1:dc:23:cc:28:51:42:eb:fb:58:49:ab:92:b6:96.
  prefs: []
  type: TYPE_NORMAL
- en: Are you sure you want to continue connecting (yes/no)? yes
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH password:'
  prefs: []
  type: TYPE_NORMAL
- en: localhost | SUCCESS => {
  prefs: []
  type: TYPE_NORMAL
- en: '"ansible_facts": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"discovered_interpreter_python": "/usr/bin/python"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"changed": false,'
  prefs: []
  type: TYPE_NORMAL
- en: '"ping": "pong"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[local]'
  prefs: []
  type: TYPE_NORMAL
- en: localhost ansible_connection=local
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[local]'
  prefs: []
  type: TYPE_NORMAL
- en: frt01.example.com ansible_connection=local
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: ls -l /tmp/foo
  prefs: []
  type: TYPE_NORMAL
- en: 'ls: cannot access /tmp/foo: No such file or directory'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible -i localhosts2 -m file -a "path=/tmp/foo state=touch" all
  prefs: []
  type: TYPE_NORMAL
- en: frt01.example.com | CHANGED => {
  prefs: []
  type: TYPE_NORMAL
- en: '"ansible_facts": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"discovered_interpreter_python": "/usr/bin/python"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"changed": true,'
  prefs: []
  type: TYPE_NORMAL
- en: '"dest": "/tmp/foo",'
  prefs: []
  type: TYPE_NORMAL
- en: '"gid": 0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"group": "root",'
  prefs: []
  type: TYPE_NORMAL
- en: '"mode": "0644",'
  prefs: []
  type: TYPE_NORMAL
- en: '"owner": "root",'
  prefs: []
  type: TYPE_NORMAL
- en: '"size": 0,'
  prefs: []
  type: TYPE_NORMAL
- en: '"state": "file",'
  prefs: []
  type: TYPE_NORMAL
- en: '"uid": 0'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: $ ls -l /tmp/foo
  prefs: []
  type: TYPE_NORMAL
- en: -rw-r--r-- 1 root root 0 Apr 24 16:28 /tmp/foo
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[switches]'
  prefs: []
  type: TYPE_NORMAL
- en: cmls01.example.com
  prefs: []
  type: TYPE_NORMAL
- en: cmls02.example.com
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[switches:vars]'
  prefs: []
  type: TYPE_NORMAL
- en: ansible_ssh_common_args='-o ProxyCommand="ssh -W %h:%p -q bastion.example.com"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible -i switches -m ping all
  prefs: []
  type: TYPE_NORMAL
- en: cmls02.example.com | SUCCESS => {
  prefs: []
  type: TYPE_NORMAL
- en: '"ansible_facts": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"discovered_interpreter_python": "/usr/bin/python"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"changed": false,'
  prefs: []
  type: TYPE_NORMAL
- en: cmls01.example.com | SUCCESS => {
  prefs: []
  type: TYPE_NORMAL
- en: '"ansible_facts": {'
  prefs: []
  type: TYPE_NORMAL
- en: '"discovered_interpreter_python": "/usr/bin/python"'
  prefs: []
  type: TYPE_NORMAL
- en: '},'
  prefs: []
  type: TYPE_NORMAL
- en: '"changed": false,'
  prefs: []
  type: TYPE_NORMAL
- en: '"ping": "pong"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: A simple play to demonstrate prompting in a playbook'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'hosts: frontends'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'vars_prompt:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: loginid'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'prompt: "Enter your username"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'private: no'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: password'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'prompt: "Enter your password"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'private: yes'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'tasks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: Proceed with login'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'debug:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'msg: "Logging in as {{ loginid }}..."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible-playbook -i hosts prompt.yml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter your username: james'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Enter your password:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PLAY [A simple play to demonstrate prompting in a playbook] ********************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TASK [Gathering Facts] *********************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt01.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt02.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TASK [Proceed with login] ******************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt01.example.com] => {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"msg": "Logging in as james..."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt02.example.com] => {'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '"msg": "Logging in as james..."'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PLAY RECAP *********************************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: Simple play to demonstrate use of tags'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'hosts: frontends'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: Install nginx'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'yum:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'name: nginx'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'state: present'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'tags:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- install'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: Install nginx configuration from template'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'template:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'src: templates/nginx.conf.j2'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'dest: /etc/nginx.conf'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'tags:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- customize'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible-playbook -i hosts tags.yml --tags install
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PLAY [Simple play to demonstrate use of tags] **********************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TASK [Gathering Facts] *********************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt02.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt01.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TASK [Install nginx] ***********************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'changed: [frt02.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'changed: [frt01.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PLAY RECAP *********************************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frt01.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frt02.example.com : ok=2 changed=1 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible-playbook -i hosts tags.yml --skip-tags customize
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PLAY [Simple play to demonstrate use of tags] **********************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TASK [Gathering Facts] *********************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt02.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt01.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: TASK [Install nginx] ***********************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt02.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ok: [frt01.example.com]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: PLAY RECAP *********************************************************************
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible-playbook -i hosts tags.yml --skip-tags customize --list-tasks
  prefs: []
  type: TYPE_NORMAL
- en: 'playbook: tags.yml'
  prefs: []
  type: TYPE_NORMAL
- en: 'play #1 (frontends): Simple play to demonstrate use of tags TAGS: []'
  prefs: []
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install nginx TAGS: [install]'
  prefs: []
  type: TYPE_NORMAL
- en: $ ansible-playbook -i hosts tags.yml --tags install,customize --list-tasks
  prefs: []
  type: TYPE_NORMAL
- en: 'playbook: tags.yml'
  prefs: []
  type: TYPE_NORMAL
- en: 'play #1 (frontends): Simple play to demonstrate use of tags TAGS: []'
  prefs: []
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install nginx TAGS: [install]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install nginx configuration from template TAGS: [customize]'
  prefs: []
  type: TYPE_NORMAL
- en: $ ansible-playbook -i hosts tags.yml --list-tasks
  prefs: []
  type: TYPE_NORMAL
- en: 'playbook: tags.yml'
  prefs: []
  type: TYPE_NORMAL
- en: 'play #1 (frontends): Simple play to demonstrate use of tags TAGS: []'
  prefs: []
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install nginx TAGS: [install]'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install nginx configuration from template TAGS: [customize]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-vault create secret.yml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'New Vault password:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Confirm New Vault password:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'secretdata: "Ansible is cool!"'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ cat secret.yml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: $ANSIBLE_VAULT;1.1;AES256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '63333734623764633865633237333166333634353334373862346334643631303163653931306138'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6334356465396463643936323163323132373836336461370a343236386266313331653964326334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '62363737663165336539633262366636383364343663396335643635623463626336643732613830'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 6139363035373736370a646661396464386364653935636366633663623261633538626230616630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '35346465346430636463323838613037386636333334356265623964633763333532366561323266'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'variables file (although, obviously, you must tell Ansible your vault password).
    Create a simple playbook as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible-playbook -i hosts vaultplaybook.yml
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'variables file that is encrypted with ansible-vault, but we must manually tell
    it about the password for it to proceed. There are several ways of specifying
    passwords for vaults (more on this in a minute), but for simplicity, try running
    the following command and enter your vault password when prompted:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible-vault encrypt_string 'Ansible is cool!' --name secretdata
  prefs: []
  type: TYPE_NORMAL
- en: 'New Vault password:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Confirm New Vault password:'
  prefs: []
  type: TYPE_NORMAL
- en: 'secretdata: !vault |'
  prefs: []
  type: TYPE_NORMAL
- en: $ANSIBLE_VAULT;1.1;AES256
  prefs: []
  type: TYPE_NORMAL
- en: '34393431303339353735656236656130336664666337363732376262343837663738393465623930'
  prefs: []
  type: TYPE_NORMAL
- en: 3366623061306364643966666565316235313136633264310a623736643362663035373861343435
  prefs: []
  type: TYPE_NORMAL
- en: '62346264313638656363323835323833633264636561366339326332356430383734653030306637'
  prefs: []
  type: TYPE_NORMAL
- en: 3736336533656230380a316364313831666463643534633530393337346164356634613065396434
  prefs: []
  type: TYPE_NORMAL
- en: '33316338336266636666353334643865363830346566666331303763643564323065'
  prefs: []
  type: TYPE_NORMAL
- en: Encryption successful
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '---'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: A play that makes use of an Ansible Vault'
  prefs: []
  type: TYPE_NORMAL
- en: 'hosts: frontends'
  prefs: []
  type: TYPE_NORMAL
- en: 'vars:'
  prefs: []
  type: TYPE_NORMAL
- en: 'secretdata: !vault |'
  prefs: []
  type: TYPE_NORMAL
- en: $ANSIBLE_VAULT;1.1;AES256
  prefs: []
  type: TYPE_NORMAL
- en: 34393431303339353735656236656130336664666337363732376262343837 663738393465623930
  prefs: []
  type: TYPE_NORMAL
- en: 3366623061306364643966666565316235313136633264310a623736643362 663035373861343435
  prefs: []
  type: TYPE_NORMAL
- en: 62346264313638656363323835323833633264636561366339326332356430 383734653030306637
  prefs: []
  type: TYPE_NORMAL
- en: 3736336533656230380a316364313831666463643534633530393337346164 356634613065396434
  prefs: []
  type: TYPE_NORMAL
- en: 33316338336266636666353334643865363830346566666331303763643564 323065
  prefs: []
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '- name: Tell me a secret'
  prefs: []
  type: TYPE_NORMAL
- en: 'debug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'msg: "Your secret data is: {{ secretdata }}"'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-playbook -i hosts inlinevaultplaybook.yml --ask-vault-pass
  prefs: []
  type: TYPE_NORMAL
- en: 'Vault password:'
  prefs: []
  type: TYPE_NORMAL
- en: PLAY [A play that makes use of an Ansible Vault] *******************************
  prefs: []
  type: TYPE_NORMAL
- en: TASK [Gathering Facts] *********************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [frt02.example.com]'
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [frt01.example.com]'
  prefs: []
  type: TYPE_NORMAL
- en: TASK [Tell me a secret] ********************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [frt01.example.com] => {'
  prefs: []
  type: TYPE_NORMAL
- en: '"msg": "Your secret data is: Ansible is cool!"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [frt02.example.com] => {'
  prefs: []
  type: TYPE_NORMAL
- en: '"msg": "Your secret data is: Ansible is cool!"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: PLAY RECAP *********************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'frt01.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs: []
  type: TYPE_NORMAL
- en: 'frt02.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0
    ignored=0'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Part 3:Using Ansible in an Enterprise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will take a practical look at how to get the most out of
    Ansible in an enterprise environment. We will start by looking at how to automate
    your network devices with Ansible, before moving on to the use of Ansible to manage
    both cloud and container environments. We will then look at some of the more advanced
    testing and troubleshooting strategies that will assist you in your use of Ansible
    in an enterprise, before looking at the Ansible Automation Controller/ **Ansible
    Web eXecutable** (**AWX**) product, which provides rich **Role-Based Access Control**
    (**RBAC**) and auditing capabilities in enterprise settings in a variety of execution
    environments. Finally, we will deep dive into execution environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B20846_10.xhtml#_idTextAnchor423), *Network Automation with
    Ansible*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B20846_11.xhtml#_idTextAnchor456), *Container and Cloud Management*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B20846_12.xhtml#_idTextAnchor523), *Troubleshooting and Testing
    Strategies*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B20846_13.xhtml#_idTextAnchor562), *Getting Started with Ansible
    Automation Controller*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B20846_14.xhtml#_idTextAnchor592), *Execution Environments*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
