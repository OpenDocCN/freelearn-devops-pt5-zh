- en: Chapter 7. Programming Issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an issue from your plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating subtasks on an issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting an issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new issue operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions on issue operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with attachments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time tracking and worklog management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with comments on issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Change Logs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Programming Issue Links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validations on issue linking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discarding fields while cloning!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript tricks on issue fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have so far seen how to develop custom fields, workflows, Reports & Gadgets,
    JQL functions, and other pluggable things associated with them. In this chapter,
    we will learn about programming "issues", that is, creating, editing, or deleting
    issues, creating new issue operations, and managing the various other operations
    available on issues via JIRA APIs etc.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an issue from a plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to create an issue from a plugin programmatically.
    Prior to version 4.1, JIRA used `IssueManager` to create an issue. From JIRA 4.1,
    there is this `IssueService` class that drives the issue operations. Since `IssueService`
    is recommended over `IssueManager`, we will use it in our recipes to create an
    issue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main advantage of `IssueService` over the `IssueManager` class is that
    it takes care of the validation and error handling. The following are the steps
    to create an issue using the `IssueService`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an instance of the `IssueService` class. You can either inject it in
    the constructor or get it from the `ComponentManager`, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the issue input parameters. In this step, we will set all the values
    that are required to create the issue using the `IssueInputParameters` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of the `IssueInputParameters` class.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Populate the `IssueInputParameters` with the values required to create the
    issue as shown in the next few lines of code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Make sure all the required values like project, issue type, summary, and other
    mandatory values required when the issue is created using the user interface is
    set on the `IssueInputParameters`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Here, we have used test values, but make sure to replace them with appropriate
    values. For example, the project, issue type ID, priority ID, Fix version IDs,
    reporter, and assignee should have appropriate values.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Validate the input parameters using `IssueService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `user` is the one creating the issue. The validation is done based
    on the user permissions and the `createValidationResult` variable will have errors
    if the validation fails due to permission issues or due to invalid input parameters!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If the `createValidationResult` is valid, create the issue using `IssueService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we use the `createValidationResult` object to create the issue, as it
    already has the processed input parameters. If the result is not valid, handle
    the errors as shown in the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we just print the error to the console if the result is invalid. The `errorMessages`
    will have all non-field-specific errors like permission issue-related errors,
    and so on, but any field-specific errors, like input validation errors, will appear
    in the `errors` map where the key will be the field name. We should handle both
    the error types as appropriate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: After the creation of an issue, check if the `createResult` is valid or not.
    If not, handle it appropriately. The `createResult` object will have errors only
    if there is a severe problem with JIRA (for example, one can't communicate with
    the DB, the workflow has changed since you invoked validate, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here again, we just print the error to the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If `createResult` is valid, then the issue is created successfully and you
    can retrieve it as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By using `IssueService`, JIRA now validates the inputs we give using the rules
    we have set up in JIRA via the user interfaces, such as the mandatory fields,
    permission checks, individual field validations, and so on. Behind the scenes,
    it still uses the `IssueManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, prior to JIRA 4.1, we need to use the `IssueManager` class
    to create the issues. It can still be used in JIRA 4.1+, but this is not recommended
    as it overrides all the validations. Here is how we do it, if it is required.
  prefs: []
  type: TYPE_NORMAL
- en: Using IssueManager to create the issue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialize an issue object using the `IssueFactory` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Set all the fields required on the issue object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the issue using `IssueManager:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Handle `CreateException` to capture any errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating subtasks on an issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to create a subtask on an existing issue programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two steps in creating a subtask:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an issue object. A subtask is nothing but an issue object in the backend.
    The only difference is that it has a parent issue associated with it. So, when
    we create a subtask issue object, we will have to define the parent issue in addition
    to what we normally do while creating a normal issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Link the newly created subtask issue to the parent issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s see the steps in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the subtask issue object similar to how we created the issue in the previous
    recipe. Here, the `IssueInputParameters` is constructed (after changing the methods
    like `setIssueTypeId()` appropriately).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this issue, we will use the `validateSubTaskCreate` method instead of `validateCreate`,
    which takes an extra parameter `parentId`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, parent is the issue object on which we are creating the subtask.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an issue after checking for errors, as we have seen before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a link between the newly created subtask issue and the parent issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get an instance of `SubTaskManager`. You can either inject it in the constructor
    or get it from `ComponentManager`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Create the subtask link.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The subtask should now be created with a link back to the original parent issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating an Issue from your plugin*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating an issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, let's look at editing an existing issue.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s assume that we have an existing issue object. We will just modify the
    `Summary` to a new summary. Following are the steps to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `IssueInputParameters` object with the input fields that need to
    be modified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In JIRA 4.1.x version, there is a bug, because of which we need to populate
    `IssueInputParameters` with all the current fields on the issue along with the
    modified field to make sure the existing values are not lost in an update. However,
    it is resolved in JIRA 4.2+ and hence the previous code is enough to modify the
    summary alone.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Still, if you do not want to retain the existing values and just want the summary
    on the issue to be updated, you can set the `retainExistingValuesWhenParameterNotProvided`
    flag as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate the input parameters using `IssueService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the issue is the existing issue object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If `updateValidationResult` is valid, update the issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If it is not valid, handle the errors as we did while creating the issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Validate the `updateResult` and handle the error if any. If it is not valid,
    the updated issue object can be retrieved as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deleting an issue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, let us look at deleting an issue programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us assume that we have an existing issue object. For deletion as well,
    we will use the `IssueService` class. Following are the steps to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate the delete operation on the issue using `IssueService`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the issue is the existing issue object that needs to be deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If `deleteValidationResult` is valid, invoke the delete operation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the `deleteValidationResult` is invalid, handle the errors appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Confirm whether the deletion was successful by checking `deleteErrors` ErrorCollection.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Adding new issue operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at adding new operations to an issue. The existing
    issue operations include **Edit** **Issue**, **Clone** **Issue**, and so on, and
    most of the time, people tend to look for similar operations with variations or
    entirely new operations that they can perform on an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Prior to JIRA 4.1, the issue operations were added using the Issue Operations
    Plugin Module ([http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module)).
    But since JIRA 4.1, new issue operations are added using **Web Item Plugin Module**
    ([http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Web+Item+Plugin+Module)).
  prefs: []
  type: TYPE_NORMAL
- en: A **Web** **Item** **Plugin** module is a generic module that is used to define
    links in various application menus. One such menu is the issue operations menu.
    We will see more about the web items module and how it can be used to enhance
    the UI, later in this book; so, in this recipe, we will only concentrate on using
    the web-item module to create issue operations.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a web item is pretty easy! All we need to do is to place it in the
    appropriate section. There are already defined web sections in JIRA and we can
    add more sections using the **Web** **Section** module, if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us create a new operation that lets us administer the project of an issue
    when we are on the view issue page. All we need here is to add an operation that
    takes us to the **Administer** **Project** page. Following are the steps to create
    the new operation:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the web section where the new operation should be placed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For issue operations, JIRA already has multiple web sections defined. We can
    add our new operation on any one of the sections. The following is a diagram from
    the Atlassian documentation detailing on each of the available web sections for
    the issue operations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-07-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: For example, if we want to add a new operation along with **Move**, **Link**,
    and so on, we need to add the new web item under the **operations-operations**
    section. If you are rather hoping to add it right at the top, along with **Edit**,
    **Assign**, and **Comment**, the section must be **operations-top-level**. We
    can reorder the operation using the `weight` attribute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the web item module in the plugin descriptor with the section identified
    in the previous step! For our example, the module definition in `atlassian-plugin.xml`
    will look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, it has a unique `key` and a human-readable `name`. The section
    here is `operations-operations`. The `weight` attribute is used to reorder the
    operations as we saw earlier and here we use weight as 100 to put it at the bottom
    of the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `label` is the name of the operation that will appear to the user. We can
    add a `tooltip` as well, which can have a friendly description of the operation.
    The next part, that is, `link` attribute, is the most important one as that links
    us to the operation that we want to perform. Essentially, it is just a link and
    hence you can use it to redirect to anywhere, the Atlassian site, for example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, we need to take the user to the *administer* project area. Luckily,
    in this case, we know the action to be invoked as it is an existing action in
    JIRA. All we need to do is to invoke the `ViewProject` action by passing the project
    ID as pid. The issue object is available on the view issue page as `$issue` and
    hence we can retrieve the project ID on the link as `${issue.project.id}`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In cases where we need to do new things, we will have to create an action by
    ourselves and point the link to the same. We will see more about creating new
    actions and extending actions later in the book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At runtime, you will see a new operation on the **View** **Issue** page on
    the **More** **Actions** drop-down menu, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: After clicking on the link, the **Administer** **Project** screen will appear,
    as expected. As you might notice, the URL is populated with the correct `pid`
    from the expression `${issue.project.id}`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, just change the section or weight and see how the operation appears at
    various places on the screen!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prior to JIRA 4.1, The **Issue** **Operations** module was used in creating
    new issue operations. It is outside the scope of the book, though you can find
    the details in the Atlassian documentation at: [http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Issue+Operations+Plugin+Module)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Extending* a *Webwork* *action* *in* *JIRA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Adding* *new* *Links* *in* *the* *UI*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conditions on issue operations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When new operations are created, it is often a requirement to hide them or show
    them, based on the permissions or state of the issue or something else. JIRA allows
    conditions to be added while defining the web items, and when the conditions are
    not satisfied, the web item won't show up!
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will lock down the new issue operation we created in the
    previous recipe to *Project* *Administrators* exclusively.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the **Manage** **Project** issue operation, as explained in the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps to add a new condition to an issue operation''s web
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `condition` class. The class should implement the `com.atlassian.plugin.web.Condition`
    interface, but it is recommended to extend `com.atlassian.jira.plugin.webfragment.conditions.AbstractIssueCondition`
    when creating an issue condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'While extending `AbstractIssueCondition`, we will have to implement the `shouldDisplay`
    method, as shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, a `true` value is returned if the user has the `PROJECT_ADMIN` permission
    on the project. That is all we need on the `condition` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Include the `condition` in the web item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is possible to invert a condition by using the invert flag, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Condition elements can also take optional parameters, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The parameters can be retrieved in the `condition` class by overriding the `init(Map
    params)` method. Here, `params` is a map of string key/value pairs that hold these
    parameters, in which case, the Map will have permission as the key, and the value
    passed (sysadmin in the example) can be accessed using the key and can then be
    used in passing or failing the condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, the following code in the conditions class will get you the appropriate
    permission type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is also possible to combine multiple conditions using the `conditions` element.
    `conditions` element will have multiple condition elements connected through logical
    AND (default) or OR condition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, if we want to make our example operation available to both project
    administrators as well JIRA System Administrators, we can do it using an `OR`
    condition, as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the plugin is deployed, we can go and check the operation on the View Issue
    Page, as we did in the previous chapter. If you are a Project Administrator (or
    a JIRA's system admin, depending on which condition you used), you will see the
    operation. If the user doesn't have the permissions, the operation won't be shown.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we added a **Manage** **Project** issue operation and limited
    it only to project admin, and a **New** **Manage** **Project** operation, and
    limited it to project admin or JIRA''s system admin, a logged in **Project** **Admin**
    would see both the operations, but a logged in **Admin** will see only the latter
    operation as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Working with attachments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Attachments feature is a useful feature in JIRA, and it sometimes helps to manage
    the attachments on an issue through the JIRA APIs. In this recipe, we will learn
    how to work with attachments using the JIRA API.
  prefs: []
  type: TYPE_NORMAL
- en: There are three major operations that can be done on attachments - Create, Read
    , and Delete. We will see each of them in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the attachments are enabled in your JIRA instance. You can do this
    from **Administration** **|** **Global** **Settings** **|** **Attachments**, as
    mentioned at [http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments](http://confluence.atlassian.com/display/JIRA/Configuring+File+Attachments).
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the operations on the attachments can be performed using the `AttachmentManager`
    API. The `AttachmentManager` can be retrieved either by injecting it in the constructor
    or from the `ComponentManager` class, as shown:.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '**Creating an attachment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An attachment can be created on an issue using the `createAttachment` method
    on the `AttachmentManager`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: The `fileName` here needs to be the full path to the file on the server. You
    can also create a File object by uploading from the client machine, depending
    on the requirement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`newFileName` is the name with which the file will be attached to the issue,
    and it can be different from the original filename.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third parameter is the `contentType` of the file. In this case, we are uploading
    a text file and hence the content type is text/plain.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`user` is the user who is attaching the file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`issue` is the issue to which the file will be attached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you also want to set a list of properties on an attachment as a key/value
    pair and create the attachment on a specific **time**, it can be done using the
    overloaded method `createAttachment`, which takes two extra parameters: `attachmentProperties`,
    a Map containing the key/value properties and `createdTime` which is of type `java.util.Date`.'
  prefs: []
  type: TYPE_NORMAL
- en: These properties will be stored in the database using `PropertySet`.
  prefs: []
  type: TYPE_NORMAL
- en: '**Reading attachments on an issue**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`AttachmentManager` has a method to retrieve the list of attachments, of type
    `com.atlassian.jira.issue.attachment.Attachment`, available on an issue. The following
    is how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The object attachment holds all the information of the attachment, including
    any properties set during the creation of the attachment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deleting an attachment**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All you need to do here is to retrieve the attachment object that needs to be
    deleted and invoke the `deleteAttachment` method on `AttachmentManager`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Here, attachment is an attachment that can be retrieved using the getAttachment(id)
    method or by iterating on the list of attachments retrieved above.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AttachmentManager` also has other useful methods like `attachmentsEnabled()`,
    `isScreenshotAppletEnabled()`, `isScreenshotAppletSupportedByOS()`, and so on,
    to check whether the respective functionality is enabled or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out: [http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/AttachmentManager.html)
    for a full list of available methods.'
  prefs: []
  type: TYPE_NORMAL
- en: Time tracking and worklog management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time tracking is one of the biggest pluses for any issue tracking system. JIRA's
    time tracking is highly configurable and gives plenty of options to manage the
    work done and the remaining time.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the time tracking in JIRA can be done using the JIRA UI, many users
    want to do it from the customized pages or third-party applications or plugins.
    In this recipe, we will see how to do time tracking using the JIRA APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, each of the operations on worklogs, namely, create, edit,
    or delete, have different modes. Whenever one of these operations is performed,
    we can adjust the remaining amount of work to be done in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Let JIRA adjust the remaining work automatically.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, if the remaining estimate is 2 hours and if we log 30 minutes,
    JIRA will automatically adjust the remaining estimate to 1 hour 30 minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Enter a new remaining estimate time while performing the operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, if the remaining estimate is 2 hours and if we log 30 minutes,
    we can force JIRA to change the remaining estimate to 1 hour (instead of the automatically
    calculated 1 hour 30 minutes).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Adjust the remaining estimate or in other words reduce a specific amount of
    time from the remaining estimate
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, if the remaining estimate is 2 hours and if we log 30 minutes,
    we can force JIRA to reduce the remaining estimate by 1 hour 30 minutes (instead
    of automatically reducing the logged 30 minutes). When we do that, the remaining
    estimate will come out to be 30 minutes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Leave the remaining estimate as it is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure time tracking is turned on as explained at [http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking](http://confluence.atlassian.com/display/JIRA/Configuring+Time+Tracking).
    It can be enabled from the **Administration** | **Global** **Settings** | **Time**
    **Tracking** menu.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Worklogs in JIRA can be managed using the `WorklogService` class. It does all
    the major operations like creating worklogs, updating them, or deleting them,
    and that too, in all the four different modes we have seen earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see how to create worklogs, or in other words, log work in the following
    four modes:'
  prefs: []
  type: TYPE_NORMAL
- en: Auto adjusting the remaining estimate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging work and retaining the remaining estimate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging work with a new remaining estimate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging work and adjusting the remaining estimate by a value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto adjusting the remaining estimate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create the JIRA Service Context for the user who is logging work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `WorklogInputParametersImpl.Builder` object to create the parameters
    needed for the worklog creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the issue is the issue on which work is logged, and `timeSpent` is the
    time that we are going to log in. `timeSpent` is a String that represents the
    format in which time is entered in JIRA , that is, `*w *d *h *m` (representing
    weeks, days, hours, and minutes, where * can be any number).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`startDate` here can be the date from where the work has started. We can also
    optionally add comments and set the worklog visibility to certain groups or project
    roles! Set these parameters as null when the worklog is visible to all.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the `WorklogInputParameters` object from the builder and validate it
    using the `WorklogService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the worklog using `WorklogService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, as you can see, the method invoked is `createAndAutoAdjustRemainingEstimate`,
    which will create the worklog and automatically adjust the remaining estimate
    on the issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The method takes as input the service context we created, the `WorklogResult`
    object after validating the input parameters, and a Boolean which will be used
    to dispatch an event, if needed. When the Boolean value is true, the **Work**
    **Logged** **On** **Issue** event is fired.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With this, the work will be logged on the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Logging work and retaining the remaining estimate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Here, the first three steps are similar to what was discussed in the *Auto*
    *adjusting* *remaining* *estimate* section. The only difference is that the method
    invoked on `WorklogService` is `createAndRetainRemainingEstimate` instead of `createAndAutoAdjustRemainingEstimate`.
    The full code is as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Logging work with a new remaining estimate
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here the first two steps are similar to what was discussed in the *Auto* *adjusting*
    *remaining* *estimate* section.
  prefs: []
  type: TYPE_NORMAL
- en: Create the JIRA Service Context for the user who is logging work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `WorklogInputParametersImpl.Builder` object to create the parameters
    needed for the worklog creation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the New Estimate Input Parameters from the Builder object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we specify the `newEstimate`, which is a String representation similar
    to `timeSpent`. The `newEstimate` will be set as the remaining estimate on the
    issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `WorklogResult` from `WorklogNewEstimateInputParameters` using `WorklogService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The result here will be an instance of `WorklogNewEstimateResult`, which will
    be used in the next step!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the worklog using `WorklogService`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the method used is `createWithNewRemainingEstimate`, which sets the `newEstimate`
    as the remaining estimate on the issue, after logging the work using `timeSpent`!
    As you can see, the result object is converted to `WorklogNewEstimateResult`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Logging work and adjusting the remaining estimate by a value
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Here the process is much similar to the above. The only difference is that the
    `adjustmentAmount` method is used on Builder instead of `newEstimate` and `validateCreateWithManuallyAdjustedEstimate`
    is used on `WorklogService` to create the worklog. Also, the `WorklogResult` is
    an instance of `WorklogAdjustmentAmountResult`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once we create or update the worklogs using the `WorklogService` API, the changes
    will be reflected on the issue under the **Work** **Log** tab, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also see that the graphical representation of time tracking reflects
    these changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a worklog is deleted, it appears on the **Change** **history** as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Updating worklogs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Updating worklogs is similar to the creating them in many ways. Here, we pass
    the ID of the `Worklog` object to be updated instead of the issue we pass while
    creating a worklog. And, of course, the methods invoked on `WorklogService` are
    different. The following is the code to update a given **Worklog** for the first
    mode where the remaining estimate is auto adjusted.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a *builder* is created by passing the worklog ID, which is unique
    across issues. The `WorklogResult` here is created using the `validateUpdate`
    method and the worklog is finally updated using the `updateAndAutoAdjustRemainingEstimate`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other modes are also similar to how we created the worklogs. Let us quickly
    see how to update a worklog with a new remaining estimate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The above looks pretty familiar, doesn't it? It is similar to creating a worklog
    with a new estimate, except that we call the respective update methods, as discussed
    before.
  prefs: []
  type: TYPE_NORMAL
- en: We can update a worklog by retaining the estimate and also adjust it by a specified
    amount of time from the remaining estimate in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting worklogs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Deleting a worklog is slightly different and maybe easier than creating or updating
    one, as it doesn't involve building the input parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Auto Adjusting remaining estimate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All we need here is the worklog ID and to create the JIRA Service Context.
    The code is as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `validateDelete` method takes the worklog ID as input and creates
    a `WorklogResult`, which is then used in the `deleteAndAutoAdjustRemainingEstimate`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a worklog and retaining the remaining estimate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: This is done in much the same way as mentioned in the previous section, expect
    that the `deleteAndRetainRemainingEstimate` method is used instead of `deleteAndAutoAdjustRemainingEstimate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a worklog with a new remaining estimate
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned before, we don''t create the input parameters while deleting worklogs.
    Instead, the `newEstimate` is used to create `WorklogResult`, which is an instance
    of `WorklogNewEstimateResult`, while validating. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This is also pretty much the same as mentioned in the previous section, except
    for the method names.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, `adjustmentAmount` is the value that is used to increase the remaining
    estimate on the issue.
  prefs: []
  type: TYPE_NORMAL
- en: Working with comments on issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to manage commenting on issues using the JIRA
    API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIRA uses the `CommentService` class to manage the comments on an issue. Let
    us have a look at all the three major operations—creating, editing, and deleting
    comments. We will also have a look at how to restrict the comment visibility to
    a specific group of people or to a project role.
  prefs: []
  type: TYPE_NORMAL
- en: Creating comments on issues
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A comment can be added on to an issue as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, `commentString` is the comment we are adding, user is the user adding
    the comment, and issue is the issue on which the comment is added. The fourth
    argument is a boolean that determines whether an event should be dispatched or
    not. If it is true, an `Issue` `Commented` event is thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Creating comments on an issue and restricting it to a project role or group
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we need to restrict the visibility of the comments, we need to use the overridden
    `create` meth od on the `CommentService` class that takes the role ID and group
    name along with the other attributes. Only one of them should be passed at one
    time.
  prefs: []
  type: TYPE_NORMAL
- en: In order to restrict the comment visibility to groups, the `Comment` `visibility`
    property under **General** **Configuration** should be set to **Groups** **&**
    **Project** **Roles**. The default is to allow restricting comments only for project
    roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the comment can be restricted to a **group** as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In this group, `group` is the name of the group, and the fifth parameter (`null`)
    is the `roleId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Restricting to a **role** is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the `group` is `null` and `roleId` is the unique ID of the `ProjectRole`
    that we need to restrict the comment to.
  prefs: []
  type: TYPE_NORMAL
- en: The Boolean to dispatch events can be used in both cases.
  prefs: []
  type: TYPE_NORMAL
- en: Updating comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following are the steps to update a comment:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `MutableComment` object from the comment to be updated
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Modify the comment with the following statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we update the body of the comment, though we can also update other attributes
    like the author, group level, role level, and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the comment using `CommentService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deleting comments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A comment can be deleted as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '`comment` is the comment object to be deleted.'
  prefs: []
  type: TYPE_NORMAL
- en: Programming Change Logs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Tracking changes to an issue is very important. JIRA stores all the changes
    that are done on an issue as change logs along with the information of who made
    the change and when. Sometimes, when we do custom development, we will have to
    update the **Change** **History** by ourselves when something changes on the issue
    by our plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Change Histories are logged as change groups which are a group of one or more
    change items made by a user at any one time. Each change item will be a change
    made on any single field.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to add change logs on an issue using the JIRA
    API.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each change item in JIRA is created as a `ChangeItemBean`. `ChangeItemBean`
    can be of two different types—one for **system** fields where the field type is
    `ChangeItemBean.STATIC_FIELD` and another for **custom** fields where the field
    type is `ChangeItemBean.CUSTOM_FIELD`.
  prefs: []
  type: TYPE_NORMAL
- en: The following are the steps to add a Change History.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `ChangeItemBean` for the change that needs to be recorded for every
    item that is changed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the first attribute is the `fieldType` and the second one is the name
    of the field. For system fields of type `ChangeItemBean.STATIC_FIELD`, the name
    can be retrieved from `IssueFieldConstants` class. For example, `IssueFieldConstants.SUMMARY`
    represents the issue summary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The third and fourth arguments are the *old* *value* and the *new* *value* of
    the field respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As we know, some of the JIRA fields have an id value and a String value. For
    example, the issue Status has the status name and the corresponding status ID.
    In such cases, we can use an overridden constructor that also takes the old id
    and new id as shown below.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For custom fields, we use the field type `ChangeItemBean.CUSTOM_FIELD` and the
    custom field name. Everything else is same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is worth noting that the field name can be manipulated to give any value
    when the `fieldType` is `ChangeItemBean.CUSTOM_FIELD`. It is probably a useful
    feature when you want to programmatically add change logs that are not directly
    relates to a field. Say, for adding a subtask!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a change holder and add the change items in to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create and store the `changelog` using the items in the `changeHolder` using
    `ChangeLogUtils` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here **user** is the user making the change. The second and third arguments
    are the original issue and the issue after changes. You can give both the same
    if the change items are explicitly created and added to `changeHolder`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But if we are modifying an issue using the setter methods, an easier way might
    be to pass the original issue object along with the modified issue object (object
    after setter methods are invoked) and set the last argument as `true` which determines
    whether a list of change items needs to be generated from the before and after
    objects. In that case, we don't need to explicitly create `changeItems` and hence
    the third argument can be an empty list. We can still pass additional `changeItems`
    if needed as the third argument in which case both the passed `changeItems` and
    generated `changeItems` (from issue before and after modification) will be created!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the change logs are added, they will appear in the issues change log panel,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the highlighted *change* *log* is added even though there is no
    field named **Some** **Heading**. Also, see how both the ID and name are shown
    for the **Status** field!
  prefs: []
  type: TYPE_NORMAL
- en: Programming issue links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Issue linking is another important feature in JIRA. It helps us to define the
    relationship between issues. In this recipe, we will see how to create links between
    issues and to break them using the JIRA APIs!
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, an issue link type has an inward and an outward description.
    For every issue link, there will be a source issue and a destination issue. From
    a source issue, we can look up the destination issues by looking up the outward
    links. Similarly, from a destination issue, we can look up the source issues by
    looking up inward links.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure the Issue Linking feature is turned ON in JIRA and valid link types
    are created. This can be done from **Administration** | **Global** **Settings**
    | **Issue** **Linking**, as explained at [http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking](http://confluence.atlassian.com/display/JIRA/Configuring+Issue+Linking)
    .
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Issue Links are managed in JIRA with the help of the `IssueLinkManager` class.
    The following are the steps to create an issue link between two given issues:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the `IssueLinkType` object for the link type we are going to create. This
    can be retrieved using the `IssueLinkTypeManager` class. The `IssueLinkTypeManager`
    class can be retrieved from the `ComponentManager` or can be injected in the constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we are getting the `Duplicate` issue link type. Even though the `getIssueLinkTypesByName`
    method returns a Collection, there will be only one link with the same name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the issue link using the `IssueLinkManager` class. The `IssueLinkManager`
    class can also be retrieved from the `ComponentManager` class or injected in the
    constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we pass the source and destination issue IDs, in the order mentioned,
    along with the link type ID. The fourth parameter is the sequence, which is of
    type `long`, used to order the links on the user interface. `user` is the user
    who is performing the link action.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's now see how to delete them or just display links.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Issue Links
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Retrieve the `IssueLinkType`, as we did earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the `IssueLink` to be deleted using the `IssueLinkManager` class.:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here the `sourceIssue` and `destIssue` are the source and destination issues,
    respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete the Link using the `IssueLinkManager` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Retrieving Issue Links on an issue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can retrieve the inward or outward links on an issue or all the linked issues
    using different methods on the `IssueLinkManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'All inward links can be retrieved as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Here, `issue` is the destination object and we are getting all the inward issue
    links and displaying the source issue key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, outward links can be retrieved as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Here, issue is the source object and we are getting all the outward issue links
    and displaying the destination issue key.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the linked issues can be retrieved in a single method as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Validations on issue linking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are scenarios that we might come across where we need to do extra validations
    while linking. In this recipe, we will quickly look at adding some extra validations
    by extending the existing link issue action in JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: Getting Ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Skeleton plugin using Atlassian Plugin SDK. It is recommended to read
    the *Extending* *JIRA* *actions* recipe before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen while extending JIRA actions, all we need to do here is to create
    a new webwork action that extends the existing JIRA action and override the required
    method. In this specific case, will be overriding the `doValidation()` method
    to do some extra validation.
  prefs: []
  type: TYPE_NORMAL
- en: Let us, for example, consider that we want to restrict linking to all issues
    of type **New** **Feature**. Following are the steps to do the same.
  prefs: []
  type: TYPE_NORMAL
- en: Add a new webwork module in the `atlassian-plugin.xml` with a new action class
    and the same alias as JIRA's link action, `LinkExistingIssue`. Once we do that,
    the new action class will be executed while linking issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the new class extending the existing action class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Override the `doValidation`() method to add extra validation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the custom validation as appropriate. In our example, we throw an error
    if any of the issues selected for linking is of type **New** **Feature**. The
    selected issues can be found using the `getLinkKey()` method, which returns a
    String array of selected issue keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, all we do here is check for the issue key and mark it as invalid
    if the issue type is **New** **Feature**. If invalid, we then throw an error for
    those invalid keys.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use the same approach to add extra validations.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An action can be overridden only once. Care must be taken not to override it
    again in another plugin (might be a third-party plugin) as only one will be picked
    up.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us consider linking to three existing issues, out of which, two are **New**
    **Features**. Once the plugin is deployed, we will see an error as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Extending a Webwork action in JIRA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discarding fields while cloning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cloning of issues in JIRA is an easy way to replicate an existing issue. While
    cloning, a new issue is created exactly similar to the original issue with identical
    values for all its fields except for a few special ones. The special ones include
    `created` `date`, `updated` `date`, `issue` `key`, `status`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: But, in addition to the special fields JIRA has chosen, we might want to ignore
    a few other fields while cloning an issue. How about a unique custom field? We
    surely don't want to replicate it while cloning?
  prefs: []
  type: TYPE_NORMAL
- en: Here is an easy way to discard any such fields while cloning an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Skeleton plugin using Atlassian Plugin SDK. It is recommended to read
    the *Extending* *JIRA* *actions* recipe before proceeding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we have seen while extending JIRA actions in the previous recipe, all we
    need to do here is to create a new webwork action that extends the existing JIRA
    Clone action and overrides the required method. In this specific case, will be
    overriding the `setFields()` method to remove the cloning of the specific fields
    we are interested in!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us, for example, say that we want to avoid cloning a unique number field
    named `Test` `Number`. Following are the steps to follow:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new webwork module in the `atlassian-plugin.xml` with a new action class
    and the same alias as JIRA's clone action, `CloneIssueDetails`. Once we do that,
    the new action class will be executed while cloning issues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the new class extending the existing action class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Override the `setFields ()` method to set a `null` value for the fields we do
    not want to clone.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the code to set `null` values. In our example, we set null value for the
    `Test` `Number` custom field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we get the cloned issue using the method `getIssueObject` and set the null
    value for the custom field. Don't forget to use the `getCustomFieldObject` method
    by passing the custom field ID if the field name is not unique!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we want to set null values for a system field like fix for versions, the
    method is the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: An action can be overridden only once. Care must be taken not to override it
    again in another plugin (might be a third-party plugin) as only one will be picked
    up.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the clone operation is invoked, the new action we have created will be
    executed. The clone operation creates a new issue object and copies the values
    to its fields from the original issue. This is done in the `setFields` method.
  prefs: []
  type: TYPE_NORMAL
- en: It is only logical to override this method and set `null` values for fields
    we do not want to clone. As shown above, the `setFields` method from the super
    class, which is the JIRA's in-built class, is first executed. Once the method
    is executed, the new issue object, which can be retrieved using the method `getIssueObject`,
    has all the values populated. We just reset some of the values by setting them
    to `null`.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Extending* *a* *Webwork* *action* *in* *JIRA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript tricks on issue fields
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIRA provides a lot of options to manage the various fields on an issue. Field
    configuration schemes, screen schemes, and so on, help the JIRA admins to show
    or hide fields, mark them as mandatory, and so on, differently for different issue
    types and projects.
  prefs: []
  type: TYPE_NORMAL
- en: Irrespective of how configurable these schemes are, there are still areas where
    we need to perform custom development. For example, if we need to show or hide
    fields, based on the values of another field, then JIRA doesn't have any in-built
    options to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Then, what is the best way to deal with this? It is always possible to create
    a new composite custom field that can have multiple fields driven by each other's
    behavior. But probably an easier way—that doesn't need developing a plugin—is
    to drive this using JavaScript. And to make things better, JIRA offers jQuery
    library that can be used to write neat JavaScript code!
  prefs: []
  type: TYPE_NORMAL
- en: However, using JavaScript to handle field behavior can create problems. It limits
    the behavior to the browser, it is client side and is dependent on whether JavaScript
    is enabled or not. But given its advantages and ease of use, most users prefer
    to do it. In this recipe, we will see a small example of using JavaScript to show
    or hide the values of a custom field based on the issue's priority value!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us assume that we have a custom field named **Why** **Critical?**. The field
    should be shown only if the priority of the issue is **Critical**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the simple steps to achieve it using JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: Write the JavaScript to achieve the functionality.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In our example, we need to show the **Why** **Critical** field only when the
    priority is Critical. Let us write the JavaScript for these purposes as an example!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identify the ID value for priority. We can get it by looking at the URL while
    editing the priority or from the JIRA database by looking at the `priority` table.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Identify the ID of the custom field. We can get this also in a similar fashion,
    either by looking at the URL while editing the custom field or from the `customfield`
    table!
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the JavaScript to show or hide the field depending on the priority value.
    Here, we use the JIRA's jQuery library, which has a predefined namespace `AJS`,
    a short name for Atlassian JavaScript!
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here 10170 is the `id` of the `customfield` and hence `customfield_10170` represents
    the unique custom field ID! Also, 2 is the ID of the priority system field.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: In the example, we created a page load event where the script looks at the priority
    value and sets the visibility of the div surrounding the custom field as hidden
    or shown.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The following part captures the on load event of the page where custom field
    is in edit mode.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: And the following code shows the field, if priority is 2.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: For every other priority value, the closet `div` surrounding field is hidden.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the above JavaScript to the description of the custom field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The field behavior will be effective on the next reload after the JavaScript
    is added on to the field description.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the field is rendered under the velocity view in the edit mode, the
    field description is executed along with all the JavaScript code in there!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the script is added in the relevant field configuration screen, the field
    will not appear for priority values other than **Critical**, as shown in the next
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, the **Priority** is **Major** (value 3), and hence the field **Why** **Critical?**
    is not available. But the moment the priority is changed to **Critical**, we can
    see the field appearing back on the page.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-07-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The JavaScript can now be modified to do a lot of other useful stuff! Don't
    forget to modify the scripts according to your needs, specifically your browser
    and your version of JIRA.
  prefs: []
  type: TYPE_NORMAL
