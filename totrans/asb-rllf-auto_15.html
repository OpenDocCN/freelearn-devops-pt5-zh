<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-275"><a id="_idTextAnchor275"/>15</h1>
<h1 id="_idParaDest-276"><a id="_idTextAnchor276"/>Automating Non-Standard Platforms and Operations</h1>
<p>So far, you have learned about the different systems and platforms (managed nodes) such as Linux systems, Microsoft Windows systems, network devices, and cloud platforms, all of which can be automated using Ansible. You have used different methods and protocols to connect to the target system or platform to execute the automated operations. You do not need to understand how complex operations are running inside these systems because Ansible will understand and take appropriate actions on the target systems to reach the desired state.</p>
<p>What if there are no standard Ansible modules or connection methods available for a specific operation on the managed node? Or what if the module is missing some feature you are looking for? For example, let’s say you want to automate a machine that doesn’t have the supported Python version installed, and you want to use Ansible to automate this Python installation or run raw commands on a firewall device that does not have an appropriate module available.</p>
<p>Since Ansible is flexible and modular, you have multiple ways to overcome these challenges. In this chapter, you will learn how to automate such non-standard operations using Ansible.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Executing low-down raw commands</li>
<li>Using raw commands for network operations</li>
<li>Using API calls for automation</li>
<li>Creating custom modules for Ansible</li>
</ul>
<p>We will start with the Ansible <code>raw</code> module and the lifesaving situations where the <code>raw</code> module helps automate non-standard use cases. Then, you will learn how to use API calls to automate operations when Ansible modules or SSH-based connections are not available. You will also explore custom Ansible modules and how to develop simple custom modules using Python.</p>
<h1 id="_idParaDest-277"><a id="_idTextAnchor277"/>Technical requirements</h1>
<p>You will need the following technical requirements for this chapter: </p>
<ul>
<li>A Linux machine for the Ansible control node</li>
<li>Basic knowledge of commands for network devices (for example, FortiOS and Cisco ASA)</li>
<li>Basic knowledge of REST API endpoints and their usages</li>
<li>Basic knowledge of bash scripting and the Python programming language</li>
</ul>
<p>All the Ansible artifacts, commands, and snippets for this chapter can be found in this book’s GitHub repository at <a href="https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-15">https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-15</a>.  </p>
<h1 id="_idParaDest-278"><a id="_idTextAnchor278"/>Executing low-down raw commands</h1>
<p>So far, you <a id="_idIndexMarker979"/>have learned about different Ansible modules and collections for developing automation content. Most of these modules expect a supported Python version on the target node (or PowerShell for Microsoft Windows) to execute the automation scripts in the backend (refer to Ansible’s managed node requirements documentation for more details: <a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements">https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.xhtml#managed-node-requirements</a>). When there is no required Python version or packages available, then you need to install it manually (or using some scripts) on every node before Ansible can automate the tasks on that nodes. When several managed nodes need to onboard to Ansible, then it will be a tedious task to log into each node and install these dependencies manually. In such situations, it is possible to execute the raw commands (such as the ones you use inside a bash script or PowerShell script) to install and configure the systems, as follows:</p>
<pre class="source-code">
sudo yum install python36</pre>
<p>Before using the low-down raw commands, please note the following:</p>
<ul>
<li>Low-down raw commands are the same commands that you use inside the system to handle the operations manually.</li>
<li>These low-down raw commands will not go through the Ansible module system; instead, they will be executed through the configured remote shell.</li>
<li>You will have to assume the output, success, and error conditions of the commands.</li>
</ul>
<p>It is <a id="_idIndexMarker980"/>possible to automate such operations via Ansible by executing low-down raw commands using the <code>ansible.builtin.raw</code> module. </p>
<p class="callout-heading">The Difference in Ansible Network Automation</p>
<p class="callout">We cannot install Python on network devices. Because of that, network automation is different in the backend. Refer to <a href="B18383_06.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Automating Microsoft Windows and Network Devices</em>, to learn more.</p>
<p>The <code>ansible.builtin.raw</code> module helps execute raw commands on the target nodes over an SSH connection. It is not a best practice to use raw commands on the target nodes as the command’s result will not be predictable; therefore, Ansible will not be able to handle the validations and errors like other standard modules. However, the <code>ansible.builtin.raw</code> module is useful for some special cases, as you’ll learn in the following sections.</p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor279"/>Installing Python using the raw module</h2>
<p>As I mentioned in <a id="_idIndexMarker981"/>the introduction of this chapter, what<a id="_idIndexMarker982"/> if your managed node doesn’t have Python installed and you want to use Ansible to automate the Python installation? Let’s learn how to create a playbook for installing Python using Ansible.</p>
<p>We assume that the required package repositories have been configured on the target node as per standard system configuration. </p>
<p>The following screenshot shows the sample playbook for installing and verifying the Python version:</p>
<div><div><img alt="Figure 15.1 – Playbook for installing and verifying Python using the raw module " height="524" src="img/B18383_15_01.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – Playbook for installing and verifying Python using the raw module</p>
<p>Note the <code>gather_facts: false</code> line in the preceding screenshot; this is a fact-gathering task that <a id="_idIndexMarker983"/>relies on Python. The playbook will not <a id="_idIndexMarker984"/>work otherwise. </p>
<p>The playbook’s installation output can be seen in the following screenshot:</p>
<div><div><img alt="Figure 15.2 – Output of the Python installation playbook " height="551" src="img/B18383_15_02.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – Output of the Python installation playbook</p>
<p>Once you have Python installed on the target nodes, use any other Ansible modules as usual. The <code>ansible.builtin.raw</code> module also supports Windows, network, and firewall <a id="_idIndexMarker985"/>devices for <a id="_idIndexMarker986"/>executing low-down raw commands. </p>
<p class="callout-heading">Ansible Raw Module</p>
<p class="callout">The raw <a id="_idIndexMarker987"/>module is part of <code>ansible-core</code> and is included in your installation by default. Refer to the documentation at <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/raw_module.xhtml">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/raw_module.xhtml</a> to learn more. As mentioned earlier, the <code>raw</code> modules are only used in special situations; otherwise, use the <code>ansible.builtin.shell</code> or <code>ansible.builtin.command</code> module to execute shell commands (check out the alternative <code>ansible.windows.win_command</code> and <code>ansible.windows.win_shell</code> modules for Windows machines).</p>
<p>In the next section, you will learn how to use the <code>ansible.builtin.raw</code> module for network automation when there are no appropriate modules available to use.</p>
<h1 id="_idParaDest-280"><a id="_idTextAnchor280"/>Using raw commands for network operations</h1>
<p>Ansible has <a id="_idIndexMarker988"/>a large collection of modules and plugins to support most of the well-known network and firewall devices. The following figure shows some of the supported network devices and brands for network automation:</p>
<div><div><img alt="Figure 15.3 – Supported brands for Ansible network automation (source: https://www.ansible.com/integrations/networks) " height="686" src="img/B18383_15_03.jpg" width="1084"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – Supported brands for Ansible network automation (source: https://www.ansible.com/integrations/networks)</p>
<p>However, there<a id="_idIndexMarker989"/> will be situations where you must overcome the following challenges:</p>
<ul>
<li>No supported Ansible module is available to execute a specific network or firewall operation.</li>
<li>There is a module available for operation but the specific feature or parameter you are looking for doesn’t exist in the current module version.</li>
<li>The supported module for the operation is using a slow method compared to the CLI command on the device.</li>
</ul>
<p class="callout-heading">Network Collections in the Ansible Collection Index</p>
<p class="callout">Refer to the documentation page at <a href="https://docs.ansible.com/ansible/latest/collections/index.xhtml">https://docs.ansible.com/ansible/latest/collections/index.xhtml</a> to see the network collections in the Ansible collection index.</p>
<p>To overcome such situations, use the same <code>ansible.builtin.raw</code> module and execute the raw<a id="_idIndexMarker990"/> commands on the target network devices over an SSH connection. </p>
<p>In the next section, you will learn how to use the <code>ansible.builtin.raw</code> module to execute the necessary operations in FortiOS and Cisco devices, such as taking a configuration backup, upgrading software, and more.</p>
<h2 id="_idParaDest-281"><a id="_idTextAnchor281"/>Backup FortiOS configurations</h2>
<p>The <code>fortinet.fortios</code> Ansible collection contains more than 600 modules for managing and <a id="_idIndexMarker991"/>operating devices or appliances with FortiOS. Let’s look at a simple operation, such as taking a configuration backup from a FortiOS device. </p>
<p>The following screenshot shows the inventory variables for the FortiOS device connection:</p>
<div><div><img alt="Figure 15.4 – Inventory variables for the FortiOS connection " height="383" src="img/B18383_15_04.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – Inventory variables for the FortiOS connection</p>
<p>We can use <code>fortinet.fortios.fortios_monitor_fact</code> to collect and save the backup to a system, as shown here:</p>
<div><div><img alt="Figure 15.5 – Backing up FortiOS using the fortios_monitor_fact module " height="230" src="img/B18383_15_05.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – Backing up FortiOS using the fortios_monitor_fact module</p>
<p class="callout-heading">Ansible fortinet.fortios Collection</p>
<p class="callout">Find the modules and plugin containers in the <code>fortinet.fortios</code> Ansible collection at <a href="https://galaxy.ansible.com/fortinet/fortios">https://galaxy.ansible.com/fortinet/fortios</a>.</p>
<p>However, the<a id="_idIndexMarker992"/> configuration backup needs to be transferred to the file server (for example, a TFTP server) securely using another task in Ansible. Some organizations may want to follow the standard and legacy way of backing up, which involves backing up from the device itself without copying to the Ansible control node (or automation controller). In such cases, use the <code>raw</code> module to execute the raw commands, as shown here:</p>
<div><div><img alt="Figure 15.6 – FortiOS backup using raw commands " height="211" src="img/B18383_15_06.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – FortiOS backup using raw commands</p>
<p>In the preceding example, we used raw CLI commands to copy the configurations directly to the TFTP server.</p>
<p>Remember to modify the inventory variables to use the default SSH connection instead of <code>ansible.netcommon.httpapi</code>:</p>
<div><div><img alt="Figure 15.7 – Inventory variables for the FortiOS connection without httpapi " height="383" src="img/B18383_15_07.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.7 – Inventory variables for the FortiOS connection without httpapi</p>
<p>Ansible will <a id="_idIndexMarker993"/>use the default SSH connection and execute the raw commands on the target FortiOS device.</p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor282"/>FortiOS software upgrade</h2>
<p>Let’s take a<a id="_idIndexMarker994"/> look at another example of a FortiOS software upgrade or patching. We have a module called <code>fortios_system_federated_upgrade</code> to do this task in the standard Ansible way. However, this module needs the new software image to be uploaded from the localhost (which is the Ansible control node or the Ansible execution environment), so first, you need to copy this image from some location to the localhost. Also, if there is a restriction in the network stopping you from copying large images such as firmware files, then the only choice is to execute the legacy raw commands inside the FortiOS device, as shown in the following screenshot:</p>
<div><div><img alt="Figure 15.8 – Running the FortiOS software upgrade using the raw module " height="211" src="img/B18383_15_08.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.8 – Running the FortiOS software upgrade using the raw module</p>
<p>The <code>execute restore image</code> command will ask you to confirm the image upgrade; <code>Y</code> on the second line is the input to that confirmation question. </p>
<p>The <code>fortios_system_federated_upgrade</code> module will take care of all such confirmations<a id="_idIndexMarker995"/> and programmatic upgrades. Keep in mind that the raw command method should only be followed in special cases.</p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor283"/>Raw commands on Cisco devices</h2>
<p>Similarly, it is<a id="_idIndexMarker996"/> possible to use raw commands on any device that supports an SSH connection. Let’s take a look at another example for Cisco ASA device backup. </p>
<p>The <code>cisco.asa.asa_config</code> module is part of the <code>cisco.asa</code> Ansible collection (<a href="https://galaxy.ansible.com/cisco/asa">https://galaxy.ansible.com/cisco/asa</a>). Use this module to configure the Cisco ASA device and take a configuration backup in the standard Ansible way. However, the backup will be downloaded to your <code>localmachine</code> (Ansible control node or the Ansible execution environment), so it will need to be transferred to the destination file server (for example, a TFTP server). The backup may contain sensitive information, so the organization may prefer to copy the backup directly to the TFTP server (or other supported target file servers). </p>
<p>In such situations, utilize the same <code>ansible.builtin.raw</code> module to execute the Cisco ASA commands on the target Cisco devices. But before you use the <code>ansible.builtin.raw</code> module, you need to check the respective Ansible collection (for example, the <code>cisco.asa</code> collection here) for any modules to execute the raw network commands in the Ansible way. In this case, the <code>cisco.asa.asa_command</code> module can be used to execute the Cisco ASA raw commands, as shown here:</p>
<div><div><img alt="Figure 15.9 – Cisco ASA backup using raw commands " height="202" src="img/B18383_15_09.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.9 – Cisco ASA backup using raw commands</p>
<p>Similarly, you can utilize the <code>cisco.ios.ios_command</code> and <code>cisco.nxos.nxos_command</code> modules on Cisco IOS and Cisco Nexus OS devices, respectively. If there is no device-specific module available to execute raw commands, then utilize <code>ansible.builtin.raw</code>, as you learned earlier.</p>
<p>The raw module <a id="_idIndexMarker997"/>can be used on any device that supports SSH and command-line execution. But for devices or platforms that don’t support SSH connections, or no such commands are available, then it is possible to use API calls. In the next section, you will learn how to use API calls to automate operations from Ansible.</p>
<h1 id="_idParaDest-284"><a id="_idTextAnchor284"/>Using API calls for automation</h1>
<p>In <a href="B18383_06.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Automating Microsoft Windows and Network Devices</em>, you learned about the different ways Ansible can talk to managed nodes, platforms, or applications. So as long as there is a supported <a id="_idIndexMarker998"/>method to access the target system, it is possible use Ansible to automate these tasks. In the previous chapters, you learned about the integration between Ansible and other tools such as Jira, ServiceNow, Kubernetes, public or private cloud platforms, and so on. For such platforms, most of those modules use HTTP/HTTPS API calls to execute operations. This means that if there are no modules available to automate your operations but there is an API method, you can use the same raw API calls from your Ansible playbook.</p>
<p class="callout-heading">Python SDK and API Calls</p>
<p class="callout">Please remember that not all modules use direct or native API calls to execute the operations; some modules use Python<a id="_idIndexMarker999"/> libraries and <code>fortiosapi</code> Python library, but now, <code>httpapi</code> is the preferred way to execute <a id="_idIndexMarker1000"/>the playbooks. Read more about <strong class="bold">the httpapi</strong> plugins at https://docs.ansible.com/ansible/latest/plugins/httpapi.xhtml.</p>
<p>For example, the <code>amazon.aws.ec2_instance_info</code> module (part of the Ansible <code>amazon.aws</code> collection) helps gather information about EC2 instances in AWS. Its usage is straightforward, as shown in the following screenshot, and you do not need to worry about the <a id="_idIndexMarker1001"/>complex API calls to the AWS EC2 endpoints:</p>
<div><div><img alt="Figure 15.10 – Gathering AWS EC2 information using amazon.aws.ec2_instance_info module " height="269" src="img/B18383_15_10.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.10 – Gathering AWS EC2 information using amazon.aws.ec2_instance_info module</p>
<p>Let’s assume you have a requirement to collect some additional requirement that is not available as part of the module’s output. In this case, it is also <a id="_idIndexMarker1002"/>possible to use the AWS EC2 API endpoints (<a href="https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Welcome.xhtml">https://docs.aws.amazon.com/AWSEC2/latest/APIReference/Welcome.xhtml</a>) to utilize the full features of API calls.</p>
<p>In the following sections, you will learn how to use API calls from Ansible to automate the platform or applications.</p>
<h2 id="_idParaDest-285"><a id="_idTextAnchor285"/>Automating a ToDo app using Ansible</h2>
<p>In this section, you <a id="_idIndexMarker1003"/>will automate a simple ToDo application using the API provided. This demonstration will help you understand how to make API calls using Ansible and how to handle the API call output appropriately. This section will help you understand how to handle API calls for any other service (for example, the cloud, network devices, software applications, and so on) by following the product’s API documentation.</p>
<h3>Introducing the Ansible uri module</h3>
<p>The <code>ansible.builtin.uri</code> module<a id="_idIndexMarker1004"/> is used to interact with the HTTP and HTTPS endpoints and implement web-related operations using Ansible. The <code>ansible.builtin.uri</code> module supports multiple authentication mechanisms, such as Digest, Basic, and WSSE HTTP (<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml</a>). The <code>ansible.builtin.uri</code> module can be used for several use cases, as follows:</p>
<ul>
<li>Calling an AWS API service to fetch EC2 instance details </li>
<li>Calling a Jira API to update a ticket</li>
<li>Fetching details from a web server</li>
<li>Verifying a web service health check</li>
</ul>
<p>Now, let’s learn <a id="_idIndexMarker1005"/>how to use the <code>ansible.builtin.uri</code> module to interact with a ToDo application API.</p>
<p>Assume you have a ToDo application running, and the API is available at <a href="http://todo-app.example.com:8081/api">http://todo-app.example.com:8081/api</a> without any authentication. Test the API using the default <code>curl</code> command, as shown here:</p>
<div><div><img alt="Figure 15.11 – Testing the ToDo API’s access " height="174" src="img/B18383_15_11.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.11 – Testing the ToDo API’s access</p>
<p>Let’s use Ansible and the <code>ansible.builtin.uri</code> module (<a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml</a>) to handle the ToDo application.</p>
<p>Here, you have <code>Chapter-15/todo-app.yaml</code> (refer to the GitHub repository) whose content is as follows:</p>
<div><div><img alt="Figure 15.12 – ToDo app playbook details " height="325" src="img/B18383_15_12.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.12 – ToDo app playbook details</p>
<p>In the preceding screenshot, we<a id="_idIndexMarker1006"/> can see the following:</p>
<ul>
<li><code>hosts: localhost</code>: This is used because we are running this API call from a localhost machine.</li>
<li><code>gather_facts: false</code>: This is used because we do not require any facts from <code>localhost</code> (enable this if there is a requirement to use Ansible facts).</li>
<li><code>become: false</code>: This is used because the API calls don’t require privileged access.</li>
</ul>
<p>The <code>method</code> parameter uses <code>GET</code> as the default value in the <code>uri</code> module. Since we are fetching the data from a URL, the default GET HTTP method will be used in the following example. The first task is to fetch the health status of the API and then print the output with a debug module, as shown in the following screenshot:</p>
<div><div><img alt="Figure 15.13 – API health check task " height="361" src="img/B18383_15_13.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.13 – API health check task</p>
<p>The <code>status_code: 200</code> parameter helps validate the API call and task success since you are expecting <code>OK success status</code>; you do not need to add additional validation tasks. If the status code is anything other than <code>200</code>, the task will fail. </p>
<p>The following screenshot shows the sample output for when you execute the playbook:</p>
<div><div><img alt="Figure 15.14 – API health check sample output " height="637" src="img/B18383_15_14.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.14 – API health check sample output</p>
<p>If you only <a id="_idIndexMarker1007"/>need the returned content (result) of the API call, then modify the <code>msg</code> parameter by setting it to <code>msg: “{{ health_status.content }}”</code>. By doing this, you will get a more accurate result, as shown here:</p>
<div><div><img alt="Figure 15.15 – API call returned content " height="308" src="img/B18383_15_15.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.15 – API call returned content</p>
<p>The <code>uri</code> call will return detailed JSON output. Filter out the content as needed.</p>
<p class="callout-heading">HTTP Request Methods</p>
<p class="callout">Depending on the API or the web endpoint, different HTTP methods will be available, such as GET, POST, PUT or DELETE. Refer to <a href="https://www.w3schools.com/tags/ref_httpmethods.asp">https://www.w3schools.com/tags/ref_httpmethods.asp</a> to understand more about HTTP methods.</p>
<p>The next task is<a id="_idIndexMarker1008"/> to fetch the items in the ToDo list, as shown here:</p>
<div><div><img alt="Figure 15.16 – Fetching the items in the ToDo app using the API " height="334" src="img/B18383_15_16.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.16 – Fetching the items in the ToDo app using the API</p>
<p>When you execute the playbook, you will get the list of ToDo items, as follows:</p>
<div><div><img alt="Figure 15.17 – ToDo items fetched using the API call " height="784" src="img/B18383_15_17.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.17 – ToDo items fetched using the API call</p>
<p>The<a id="_idIndexMarker1009"/> individual items can be handled by filtering the JSON output. This will allow you to retrieve the exact content as needed.</p>
<p>For creating or updating new items, use the <code>POST HTTP</code> method, along with content to post and other details as needed. Let’s add a new item to the ToDo list by using the <code>POST</code> method and the <code>body</code> content. The first step is to prepare the data to post. In this case, you have a dictionary variable called <code>new_item</code> that contains item details, as shown in the following screenshot:</p>
<div><div><img alt="Figure 15.18 – Variable for the new ToDo item " height="282" src="img/B18383_15_18.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.18 – Variable for the new ToDo item</p>
<p>The task to <code>POST</code> the content to the ToDo list requires a few more parameters, as shown here:</p>
<div><div><img alt="Figure 15.19 – Adding a new task to the ToDo app via an API call " height="399" src="img/B18383_15_19.jpg" width="1081"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.19 – Adding a new task to the ToDo app via an API call</p>
<p>In the preceding <a id="_idIndexMarker1010"/>screenshot, we can see the following:</p>
<ul>
<li><code>status_code: 201</code>-<code>201</code> is the status code for <code>created</code>. If you do not mention <code>status_code</code>, Ansible will use a value of <code>200</code> (default) and the task will show as failed (for example, <code>"msg": "Status code was 201 and not [200]: OK (unknown bytes)"</code>).</li>
<li><code>body_format: json</code>: The default value is <code>raw</code>. This is where you are passing the JSON formatted input.</li>
</ul>
<p>The following screenshot shows the sample output for the tasks when you execute the playbook:</p>
<div><div><img alt="Figure 15.20 – Output of the tasks " height="971" src="img/B18383_15_20.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.20 – Output of the tasks</p>
<p>This simple <a id="_idIndexMarker1011"/>demonstration explains the different ways to interact with an API endpoint using Ansible. Depending on the API endpoint you want to manage, explore more automation use cases and workflows.</p>
<p>Some of the API calls may require you to prepare complex <code>body</code> content, and in such cases, use Ansible Jinja2 templates; this will be covered in the next section.</p>
<p class="callout-heading">The Ansible uri Module and REST APIs</p>
<p class="callout">The <code>uri</code> module is a multipurpose module with parameters available for most API operations, including credentials, certificates, agent configuration, and more. Check out the module documentation at <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/uri_module.xhtml</a> to learn more.</p>
<h2 id="_idParaDest-286"><a id="_idTextAnchor286"/>Interacting with the Akamai API</h2>
<p>Let’s <a id="_idIndexMarker1012"/>assume there’s a situation where you want to automate a DNS management device such as Akamai and no supported Ansible modules are available. Fortunately, the Akamai device provides a simple API endpoint for managing the DNS entries. Use the same in Ansible to automate the necessary operations. </p>
<p>The API needs to be input in a complex body format. For that, a Jinja2 template called <code>akamai-url-block-format.j2</code> can be used, as shown here:</p>
<div><div><img alt="Figure 15.21 – The Jinja2 template for preparing the Akamai API call body " height="211" src="img/B18383_15_21.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.21 – The Jinja2 template for preparing the Akamai API call body</p>
<p>The <code>akamai-dns-block.yaml</code> playbook contains a few variables, as shown in the following screenshot: </p>
<div><div><img alt="Figure 15.22 – Variables for Akamai DNS blocking " height="512" src="img/B18383_15_22.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.22 – Variables for Akamai DNS blocking</p>
<p>Remember to keep the sensitive items (such as credentials) in encrypted format using Ansible Vault (or <strong class="bold">Credentials</strong> in the Ansible automation controller).</p>
<p>The list of DNS <a id="_idIndexMarker1013"/>entries (<code>dns_list</code>) can be converted into the desired format using the <code>template</code> lookup plugin and passed to the <code>uri</code> module (<code>body: “{{ dns_list_templated }}”</code>), as shown here:</p>
<div><div><img alt="Figure 15.23 – The Akamai API call using the uri module " height="642" src="img/B18383_15_23.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.23 – The Akamai API call using the uri module</p>
<p>You need to add all validation and verification tasks as required before executing the API POST calls. Refer to the Akamai documentation (<a href="https://techdocs.akamai.com/home/page/products-tools-a-z">https://techdocs.akamai.com/home/page/products-tools-a-z</a>) for the products to learn more.</p>
<p>In this section, you learned how to automate non-supported operations using raw commands and API calls. In the next section, you will explore Ansible modules and the basic steps to create custom modules for Ansible.</p>
<h1 id="_idParaDest-287"><a id="_idTextAnchor287"/>Creating custom modules for Ansible</h1>
<p>In the <a id="_idIndexMarker1014"/>previous sections, you learned how to automate operations if the standard modules are not available for specific tasks. But modules are the standard way of implementing automation and help you develop Ansible playbooks without worrying about the complex operations in the backend. If you know the backend operations and how to execute the tasks in the backend, then create a module for Ansible to execute a specific operation. Finally, contribute it back to the community via Ansible collections. That is the way the open source community grows. </p>
<h2 id="_idParaDest-288"><a id="_idTextAnchor288"/>Facts to check before creating a custom Ansible module</h2>
<p>You can use any <a id="_idIndexMarker1015"/>programming language (which can be called by the Ansible API, the <code>ansible</code> command, or the <code>ansible-playbook</code> command), libraries, and methods for your new Ansible module. Most of the Ansible modules that you are using now are written in the Python programming language. Before developing a new module, check yourself on the following facts:</p>
<ul>
<li>If the specific task can be completed using an Ansible role, then develop a role instead of an Ansible module.</li>
<li>If the actual execution is happening on the control node (instead of a managed node) then create an action plugin instead of a module (read <em class="italic">Developing plugins</em> at <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_plugins.xhtml</a> for more details).</li>
<li>If there are similar modules available, then modify that module, add features, and contribute it back to the community.</li>
<li>If the module you are planning to develop requires a lot of dependencies, then try to create it as an Ansible collection with all the dependencies, custom libraries, and plugins as required. </li>
</ul>
<p class="callout-heading">Should You Develop an Ansible Module?</p>
<p class="callout">Refer to the Ansible documentation at <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_modules.xhtml</a> to learn more.</p>
<p>If you are using<a id="_idIndexMarker1016"/> your custom module without an Ansible collection (or as a standalone module), then make sure the module script has been copied to the right location. The following are the common locations and methods we can use to store custom modules:</p>
<ul>
<li>Use <code>DEFAULT_MODULE_UTILS_PATH</code> in the Ansible configuration and mention all the directories to look for modules.</li>
<li>Add the modules to the user’s directory: <code>~/.ansible/plugins/modules/</code>.</li>
<li>Add the modules to system directory: <code>/usr/share/ansible/plugins/modules/</code>.</li>
<li>The <code>ANSIBLE_LIBRARY</code> environment variable can be configured to set the custom module directory.</li>
</ul>
<p>The following screenshot shows the configured module paths for Ansible:</p>
<div><div><img alt="Figure 15.24 – Ansible module path " height="141" src="img/B18383_15_24.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.24 – Ansible module path</p>
<ul>
<li>If the module is used for a specific Ansible role, then store the module inside the <code>library</code> directory of the role. Ansible will automatically detect the module.</li>
<li>If the module is being used by playbooks and different roles, then store it in the <code>library</code> directory of the project directory. The following screenshot shows an example of <code>ansible.cfg</code> with <code>library</code> configured:</li>
</ul>
<div><div><img alt="Figure 15.25 – Library path in ansible.cfg " height="168" src="img/B18383_15_25.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.25 – Library path in ansible.cfg</p>
<p class="callout-heading">Ansible Module Directory Configuration</p>
<p class="callout">Read the documentation at <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_locally.xhtml</a> to learn more about adding modules and plugins locally.</p>
<p>In the next section, you will learn how to use simple bash scripts for Ansible modules and explore more with Python-based Ansible modules.</p>
<h2 id="_idParaDest-289"><a id="_idTextAnchor289"/>Developing Ansible modules using bash scripts</h2>
<p>Modules are <a id="_idIndexMarker1017"/>simply reusable scripts for executing a specific task. Before moving on, you will need to create a simple bash script and use it as an Ansible module.</p>
<p><code>library/customhello.sh</code> is a simple Bash script that displays the operating system, hostname, and a custom message, as shown in the following screenshot:</p>
<div><div><img alt="Figure 15.26 – Bash script for an Ansible module " height="654" src="img/B18383_15_26.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.26 – Bash script for an Ansible module</p>
<p>Notice the<a id="_idIndexMarker1018"/> echo line, where the output is formatted as JSON. The module should provide a defined interface (that also accepts arguments) and should return the result or information to Ansible by printing a JSON string to <code>stdout</code> before exiting.</p>
<p>We have a playbook with a task for calling this custom module, as shown in the following screenshot:</p>
<div><div><img alt="Figure 15.27 – Ansible playbook with the custom hello module task " height="494" src="img/B18383_15_27.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.27 – Ansible playbook with the custom hello module task</p>
<p>When you <a id="_idIndexMarker1019"/>execute this playbook, the bash script will be executed in the backend, and Ansible will get information from the script, as shown here:</p>
<div><div><img alt="Figure 15.28 – Ansible playbook output for the custom module " height="414" src="img/B18383_15_28.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.28 – Ansible playbook output for the custom module</p>
<p>This is a very basic concept of an Ansible module and its parameters and variables. Expand it as required.</p>
<p class="callout-heading">Developing Ansible Modules</p>
<p class="callout">Following the best practices will help you create quality Ansible modules that can be enhanced when required. Refer to the documentation (<a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml</a>) and Ansible module architecture (<a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_program_flow_modules.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_program_flow_modules.xhtml</a>) to learn more about developing Ansible modules.</p>
<p>In the next section, you will learn more about custom modules by following the Ansible module development guidelines.</p>
<h2 id="_idParaDest-290"><a id="_idTextAnchor290"/>Developing Ansible modules using Python</h2>
<p>When you <a id="_idIndexMarker1020"/>create a module, follow the best practices as much as possible and increase the reusability of the module by adding appropriate documentation, examples or expected results.</p>
<p>Check the <code>library/hello_message.py</code> file in the <code>Chapter-15</code> directory of this book’s GitHub repository and explore the standard module components inside the Python script:</p>
<ul>
<li>The script starts with a <code>ansible_python_interpreter</code> to work.</li>
<li>Add the copyright and other contact information as needed after that.</li>
<li>The <code>DOCUMENTATION</code> block is a very important part of the module since it helps users understand the usages of this module, such as its available parameters, options to use, field types, and so on. The following screenshot shows the documentation portion of our custom <code>hello_message.py</code> module:</li>
</ul>
<div><div><img alt="Figure 15.29 – Module documentation " height="573" src="img/B18383_15_29.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.29 – Module documentation</p>
<ul>
<li>The <code>EXAMPLES</code> block <a id="_idIndexMarker1021"/>contains the sample usage of the module:</li>
</ul>
<div><div><img alt="Figure 15.30 – EXAMPLE part of the module " height="255" src="img/B18383_15_30.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.30 – EXAMPLE part of the module</p>
<ul>
<li>The <code>RETURN</code> block should contain the sample output or result of the module being returned after being executed successfully:</li>
</ul>
<div><div><img alt="Figure 15.31 – The module’s RETURN block " height="389" src="img/B18383_15_31.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.31 – The module’s RETURN block</p>
<ul>
<li>Finally, there’s the<a id="_idIndexMarker1022"/> actual script. This contains all the necessary libraries and dependencies, just like a normal Python script:</li>
</ul>
<div><div><img alt="Figure 15.32 – The script portion of an Ansible module " height="494" src="img/B18383_15_32.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.32 – The script portion of an Ansible module</p>
<p class="callout-heading">Module Format and Documentation</p>
<p class="callout">Following the best practices will help those who are using the module to understand how it’s used. Refer to https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_documenting.xhtml#developing-modules-documenting to learn more about the module format and documentation.</p>
<p>Verify the module <a id="_idIndexMarker1023"/>using the <code>ansible-doc</code> command, as shown in the following screenshot:</p>
<div><div><img alt="Figure 15.33 – Custom module details after using the ansible-doc command " height="573" src="img/B18383_15_33.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.33 – Custom module details after using the ansible-doc command</p>
<p>When scrolling down using the keyboard, you will see the <code>EXAMPLES</code> and <code>RETURN VALUES</code> sections of the module’s documentation, as shown here:</p>
<div><div><img alt="Figure 15.34 – Ansible custom module documentation details after using the ansible-doc command " height="621" src="img/B18383_15_34.jpg" width="1178"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.34 – Ansible custom module documentation details after using the ansible-doc command</p>
<p>Let’s use the<a id="_idIndexMarker1024"/> module inside the <code>hello-python.yaml</code> playbook and pass the <code>message</code> and <code>name</code> module parameters:</p>
<div><div><img alt="Figure 15.35 – Using the hello_message module in the playbook " height="524" src="img/B18383_15_35.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.35 – Using the hello_message module in the playbook</p>
<p>Execute the playbook and verify its output, as shown here:</p>
<div><div><img alt="Figure 15.36 – Verifying the playbook’s execution and the hello_message module " height="389" src="img/B18383_15_36.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.36 – Verifying the playbook’s execution and the hello_message module</p>
<p>Check <a id="_idIndexMarker1025"/>the <code>Chapter-15</code> directory in this book’s GitHub repository to learn more about Ansible custom modules. Also, refer to the <em class="italic">Further reading</em> section at the end of this chapter for more resources on Ansible custom module development.</p>
<h2 id="_idParaDest-291"><a id="_idTextAnchor291"/>Using Ansible collections and contributing back</h2>
<p>As mentioned in the <a id="_idIndexMarker1026"/>previous section, store and distribute modules, roles, and libraries as an Ansible collection. This collection can be distributed to the public <a id="_idIndexMarker1027"/>via Ansible Galaxy (<a href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a>) or internally using Red Hat Ansible <strong class="bold">Private Automation Hub </strong>(<strong class="bold">PAH</strong>).</p>
<p>In this section, you will learn how to export a collection to Ansible Galaxy.</p>
<h3>Preparing the collection directory </h3>
<p>The following <a id="_idIndexMarker1028"/>screenshot shows a typical Ansible collection’s directory structure:</p>
<div><div><img alt="Figure 15.37 – Ansible collection directory structure " height="693" src="img/B18383_15_37.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.37 – Ansible collection directory structure</p>
<p>In our scenario, we <a id="_idIndexMarker1029"/>will make various adjustments without moving the original playbooks and module directories. (This is only for demonstration purposes; it is possible to keep the collection directories and files in the root of your GitHub repository.)</p>
<p>Similar to the <code>ansible-galaxy role init</code> command, use the <code>ansible-galaxy collection init</code> command to initialize the collection with the base directories and structure. In this example, we will be manually creating the collection and subdirectories to demonstrate the required directory structure and files for the collection. This will also allow us to reuse the existing playbooks and modules:</p>
<ol>
<li>Create the <code>collection</code> directory.</li>
<li>Create the <code>collection/playbook</code> directory and copy the playbooks into it.</li>
<li>Create the <code>collection/plugins/modules</code> directory and copy the custom modules into it.</li>
<li>Create <code>collection/meta/runtime.yml</code>.</li>
<li>Create <code>collection/galaxy.yml</code>, as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.38 – galaxy.yml for the Ansible collection " height="599" src="img/B18383_15_38.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.38 – galaxy.yml for the Ansible collection</p>
<ol>
<li value="6">Create <code>collection/README.md</code> with the necessary documentation and details. Add/update the <code>.gitignore</code> file (in the root of the GitHub repository) and add <a id="_idIndexMarker1030"/>the following content (this is for ignoring unwanted files when you sync the content to the GitHub server):<pre>*.tar.gz
test/results</pre></li>
</ol>
<p>Once you have prepared the collection’s content, you must build and publish it to Ansible Galaxy. This will be covered in the next section.</p>
<h3>Publishing an Ansible collection to Ansible Galaxy</h3>
<p>Publish the<a id="_idIndexMarker1031"/> collection to Ansible Galaxy via a GUI or using the CLI. Follow these steps to publish the collection using the CLI:</p>
<ol>
<li value="1">Log in to Ansible Galaxy and get the Ansible Galaxy API key (token) from <a href="https://galaxy.ansible.com/me/preferences">https://galaxy.ansible.com/me/preferences</a>.</li>
<li>Export the token to an environment variable:<pre>$ export ANSIBLE_GALAXY_TOKEN='YOUR_ANSIBLE_GALAXY_API_TOKEN'</pre></li>
<li>Build the collection archive using the <code>ansible-galaxy collection build</code> command:</li>
</ol>
<div><div><img alt="Figure 15.39 – Building the Ansible collection archive " height="202" src="img/B18383_15_39.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.39 – Building the Ansible collection archive</p>
<p>Use <code>--force</code> to overwrite the collection archive if there’s an existing archive with the same version.</p>
<ol>
<li value="4">Now, publish the collection to Ansible Galaxy using the <code>ansible-galaxy collection publish</code> command:</li>
</ol>
<div><div><img alt="Figure 15.40 – Publishing the collection to Ansible Galaxy " height="282" src="img/B18383_15_40.jpg" width="1191"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.40 – Publishing the collection to Ansible Galaxy</p>
<ol>
<li value="5">Verify the published collection in the Ansible Galaxy portal (<a href="https://galaxy.ansible.com/my-content/namespaces">https://galaxy.ansible.com/my-content/namespaces</a>), as shown in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 15.41 – New collection published in Ansible Galaxy " height="598" src="img/B18383_15_41.jpg" width="822"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.41 – New collection published in Ansible Galaxy</p>
<ol>
<li value="6">Open the <a id="_idIndexMarker1032"/>collection and view its content:</li>
</ol>
<div><div><img alt="Figure 15.42 – Ansible collection content " height="488" src="img/B18383_15_42.jpg" width="948"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.42 – Ansible collection content</p>
<p>In this section, you<a id="_idIndexMarker1033"/> created a subdirectory (<code>collection</code>) where you can keep the collection’s content and build the archive. As I mentioned earlier, keep the collection’s content in the root directory of the GitHub repository. Refer to <a href="https://github.com/ginigangadharan/ansible-collection-custom-modules">https://github.com/ginigangadharan/ansible-collection-custom-modules</a> to see a sample collection repository.</p>
<h1 id="_idParaDest-292"><a id="_idTextAnchor292"/>Summary</h1>
<p>In this chapter, you learned how to use Ansible to automate non-supported and non-standard operations using the Ansible <code>raw</code> module. You explored the <code>raw</code> command’s execution on servers, network devices, firewall devices, and more.</p>
<p>Then, you learned how to interact with the devices that provide API-based operations. The Ansible <code>uri</code> module was used to interact with a ToDo application; you explored the options for fetching and adding items to the application via APIs. You also learned about the API-based operations for devices and explored some sample usage using the Akamai DNS API.</p>
<p>In addition to the <code>raw</code> command and API-based operations, you learned about Ansible custom modules and how to create custom modules using bash and Python. In the end, you distributed the custom modules to Ansible Galaxy as an Ansible content collection.</p>
<p>With that, you have explored a common production use case where you can use Ansible as a perfect automation tool and Red Hat Ansible Automation Platform as an enterprise automation solution. </p>
<p>In the next chapter, you will learn about the best practices in Ansible, such as storing playbooks and their content, organizing inventories, the YAML style guide, and more.</p>
<h1 id="_idParaDest-293"><a id="_idTextAnchor293"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li><em class="italic">Network Automation with Ansible</em>: <a href="https://www.ansible.com/integrations/networks">https://www.ansible.com/integrations/networks</a></li>
<li><em class="italic">Developing Ansible modules</em>: <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml</a></li>
<li><em class="italic">Ansible module best practices – conventions, tips, and pitfalls</em>: <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_best_practices.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_best_practices.xhtml</a></li>
<li><em class="italic">Control your content with a private Automation Hub (Ansible blog)</em>: <a href="https://www.ansible.com/blog/control-your-content-with-private-automation-hub">https://www.ansible.com/blog/control-your-content-with-private-automation-hub</a></li>
</ul>
</div>
</div></body></html>