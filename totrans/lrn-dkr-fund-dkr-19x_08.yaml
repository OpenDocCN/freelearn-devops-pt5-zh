- en: Debugging Code Running in Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中调试代码
- en: In the previous chapter, we learned how to work with stateful containers, that
    is, containers that consume and produce data. We also learned how to configure
    our containers at runtime and at image build time using environment variables
    and config files.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何使用有状态容器，即那些消耗和生成数据的容器。我们还学习了如何使用环境变量和配置文件在运行时和镜像构建时配置容器。
- en: In this chapter, we're going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
    With these techniques at hand, you will enjoy a frictionless development process
    for applications running in a container, similar to what you experience when developing
    applications that run natively.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些常用的技术，允许开发者在容器中运行代码时进行演进、修改、调试和测试。掌握这些技术后，你将体验到容器内应用程序的顺畅开发过程，类似于开发本地运行的应用程序时的体验。
- en: 'Here is a list of the topics we''re going to discuss:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们将讨论的主题列表：
- en: Evolving and testing code running in a container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中演进和测试代码
- en: Auto restarting code upon changes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码在更改后自动重启
- en: Line-by-line code debugging inside a container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器内逐行调试代码
- en: Instrumenting your code to produce meaningful logging information
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的代码加入有意义的日志记录信息
- en: Using Jaeger to monitor and troubleshoot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Jaeger 进行监控和故障排除
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够做到以下几点：
- en: Mount source code residing on the host in a running container
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在正在运行的容器中挂载宿主机上的源代码
- en: Configure an application running in a container to auto-restart after a code
    change
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置在容器中运行的应用程序，在代码更改后自动重启
- en: Configure Visual Studio Code to debug applications written in Java, Node.js,
    Python, or .NET running inside a container line by line
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置 Visual Studio Code 逐行调试在容器内运行的 Java、Node.js、Python 或 .NET 编写的应用程序
- en: Log important events from your application code
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从应用程序代码中记录重要事件
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, if you want to follow along with the code, you need Docker
    for Desktop on macOS or Windows and a code editor—preferably Visual Studio Code.
    The sample will also work on a Linux machine with Docker and VS Code installed.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果你想跟着代码一起操作，你需要在 macOS 或 Windows 上安装 Docker for Desktop 和代码编辑器——最好是 Visual
    Studio Code。此示例在安装了 Docker 和 VS Code 的 Linux 机器上也能运行。
- en: Evolving and testing code running in a container
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中演进和测试代码
- en: 'When developing code that will eventually be running in a container, it is
    often the best approach to run the code in the container from the very beginning,
    to make sure there will be no unexpected surprises. But, we have to do this in
    the right way in order not to introduce any unnecessary friction into our development
    process. Let''s first look at a naive way that we could run and test code in a
    container:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发最终将在容器中运行的代码时，通常最好从一开始就让代码在容器中运行，以确保不会出现意外问题。但我们必须以正确的方式进行操作，避免在开发过程中引入不必要的摩擦。让我们先看看一种我们可以在容器中运行和测试代码的初步方法：
- en: 'Create a new project folder and navigate to it:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目文件夹并导航到该文件夹：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s use `npm` to create a new Node.js project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用`npm`创建一个新的 Node.js 项目：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Accept all the defaults. Notice that a `package.json` file is created with
    the following content:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接受所有默认设置。注意，一个`package.json`文件将被创建，其内容如下：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We want to use the Express.js library in our Node application; thus, use `npm`
    to install it:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们希望在 Node 应用程序中使用 Express.js 库，因此使用`npm`安装它：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This will install the newest version of Express.js on our machine and, because
    of the `--save` parameter, add a reference to our `package.json` file that looks
    similar to this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装 Express.js 的最新版本，并且由于`--save`参数的使用，它会在我们的`package.json`文件中添加一个类似于以下内容的引用：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Start VS Code from within this folder:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从此文件夹内启动 VS Code：
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In VS Code, create a new `index.js` file and add this code snippet to it. Do
    not forget to save:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，创建一个新的`index.js`文件并将以下代码片段添加到其中。不要忘记保存：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'From back within your terminal window, start the application:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端窗口内启动应用程序：
- en: '[PRE7]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You should see this as the output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到以下输出：
- en: '[PRE8]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This means that the application is running and ready to listen at `0.0.0.0:3000`.
    You may ask yourself what the meaning of the host address `0.0.0.0` is and why
    we have chosen it. We will come back to that later, when we run the application
    inside a container. For the moment, just know that `0.0.0.0` is a reserved IP
    address with a special meaning, similar to the loopback address `127.0.0.1`. The `0.0.0.0` address
    simply means *all IPv4 addresses on the local machine*. If a host has two IP addresses,
    say `52.11.32.13` and `10.11.0.1`, and a server running on the host listens on
    `0.0.0.0`, it will be reachable at both of those IPs.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着应用程序正在运行并准备在 `0.0.0.0:3000` 上监听。你可能会问，`0.0.0.0` 这个主机地址的含义是什么，为什么我们选择了它。稍后，当我们在容器内运行应用程序时，我们会回到这个问题。暂时只需要知道，`0.0.0.0`
    是一个具有特殊意义的保留 IP 地址，类似于回环地址 `127.0.0.1`。`0.0.0.0` 地址表示 *本地机器上的所有 IPv4 地址*。如果一台主机有两个
    IP 地址，比如 `52.11.32.13` 和 `10.11.0.1`，而主机上运行的服务器监听在 `0.0.0.0`，那么它可以通过这两个 IP 地址访问。
- en: 'Now open a new tab in your favorite browser and navigate to `localhost:3000`.
    You should see this:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开你最喜欢的浏览器新标签页，并导航到 `localhost:3000`。你应该看到如下内容：
- en: '![](img/90516b3c-77d7-4443-9850-c5483270a0ea.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![](img/90516b3c-77d7-4443-9850-c5483270a0ea.png)'
- en: Sample Node.js app running in a browser
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中运行的示例 Node.js 应用程序
- en: Great—our Node.js application is running on our developer machine. Stop the
    application by pressing *Ctrl* + *C* in the terminal.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了——我们的 Node.js 应用程序正在开发机器上运行。在终端按 *Ctrl* + *C* 停止应用程序。
- en: 'Now we want to test the application we have developed so far by running it
    inside a container. To do this, we have to create a `Dockerfile` first, so that
    we can build a container image, from which we can then run a container. Let''s
    use VS Code again to add a file called `Dockerfile` to our project folder and
    give it the following content:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们想通过在容器内运行应用程序来测试我们目前开发的应用程序。为此，我们必须首先创建一个 `Dockerfile`，以便可以构建一个容器镜像，从该镜像中我们可以运行容器。让我们再次使用
    VS Code 向项目文件夹中添加一个名为 `Dockerfile` 的文件，并给它以下内容：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We can then use this `Dockerfile` to build an image called `sample-app` as
    follows:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们可以使用这个 `Dockerfile` 来构建一个名为 `sample-app` 的镜像，如下所示：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After building, run the application in the container with this command:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建完成后，使用以下命令在容器中运行应用程序：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding command runs a container with the name `my-sample-app` from the
    container image `sample-app` and maps the container port `3000` to the equivalent
    host port. The port mapping is necessary; otherwise, we could not access the application
    running inside the container from outside the container. We will learn more about
    port mapping in *[Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)*, *Single-Host
    Networking*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的命令会从容器镜像 `sample-app` 运行一个名为 `my-sample-app` 的容器，并将容器的端口 `3000` 映射到主机的相应端口。端口映射是必要的，否则我们无法从容器外部访问容器内运行的应用程序。我们将在
    *[第10章](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)*、*单主机网络* 中了解更多关于端口映射的内容。
- en: 'Similar to when we ran the application directly on our host, the output is
    as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们直接在主机上运行应用程序时类似，输出如下：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Refresh the browser tab from before (or open a new browser tab and navigate
    to `localhost:3000`, if you closed it). You should see that the application still
    runs and produces the same output as when running natively. This is good. We have
    just shown that our application not only runs on our host but also inside a container.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 刷新之前的浏览器标签页（如果你关闭了它，可以打开一个新的浏览器标签页并导航到 `localhost:3000`）。你应该看到应用程序仍然在运行，并产生与本地运行时相同的输出。这很好。我们刚刚证明了我们的应用程序不仅在主机上运行，而且也可以在容器内运行。
- en: Stop and remove the container by pressing *Ctrl* + *C* in the terminal.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端按 *Ctrl* + *C* 停止并移除容器。
- en: 'Now let''s modify our code and add some additional functionality. We will define
    another `HTTP GET` endpoint at `/hobbies`. Please add the following code snippet
    to your `index.js` file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们修改代码并添加一些额外的功能。我们将在 `/hobbies` 定义另一个 `HTTP GET` 端点。请将以下代码片段添加到 `index.js`
    文件中：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can first test the new functionality on our host by running the app with
    `node index.js` and navigating to `localhost:3000/hobbies` in the browser. We
    should see the expected output in the browser window. Don't forget to stop the
    application with *Ctrl* + *C* when done testing.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在主机上运行 `node index.js` 来先测试新功能，然后在浏览器中导航到 `localhost:3000/hobbies`。我们应该能够在浏览器窗口中看到预期的输出。测试完成后，别忘了按
    *Ctrl* + *C* 停止应用程序。
- en: 'Next, we need to test the code when it runs inside the container. Thus, first,
    we create a new version of the container image:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在容器内运行代码进行测试。因此，首先，我们创建一个新的容器镜像版本：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we run a container from this new image:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们从这个新镜像运行一个容器：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, we can navigate to `localhost:3000/hobbies` in our browser and confirm
    that the application works as expected inside the container too. Once again, don't
    forget to stop the container when done by pressing *Ctrl* + *C*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在浏览器中导航到`localhost:3000/hobbies`，并确认应用程序在容器内也按预期工作。再次提醒，完成后不要忘记按*Ctrl*
    + *C*停止容器。
- en: We can repeat this sequence of tasks over and over again for each feature we
    add or any existing features we improve. It turns out that this is a lot of added
    friction compared to times when all the applications we developed always ran directly
    on the host.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以对每个添加的特性或改进的现有特性反复执行这一系列任务。与所有应用程序总是直接在主机上运行的时代相比，事实证明，这增加了很多摩擦。
- en: However, we can do better. In the next section, we will look at a technique
    that allows us to remove most of the friction.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以做得更好。在下一节中，我们将介绍一种可以去除大部分摩擦的技术。
- en: Mounting evolving code into the running container
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将不断变化的代码挂载到运行中的容器中
- en: What if, after a code change, we do not have to rebuild the container image
    and rerun a container? Wouldn't it be great if the changes would immediately,
    as we save them in an editor such as VS Code, be available inside the container
    too? Well, exactly that is possible with volume mapping. In the last chapter,
    we learned how to map an arbitrary host folder into an arbitrary location inside
    a container. We want to leverage exactly that in this section.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在代码更改后，我们不需要重建容器镜像并重新运行容器呢？如果修改能够立即生效，正如我们在VS Code等编辑器中保存时，它也能在容器内生效，那不是太棒了吗？嗯，正是通过卷映射可以实现这一点。在上一章中，我们学习了如何将任意主机文件夹映射到容器内的任意位置。在本节中，我们正是想利用这一点。
- en: 'We saw in [*Chapter 5*](f3a48b12-d541-467b-aeb3-df014e60da6b.xhtml), *Data
    Volumes and Configuration*, how we can map host folders as volumes in a container.
    If I want, for example, to mount a host folder, `/projects/sample-app`, into a
    container at `/app`, the syntax for this looks as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[*第5章*](f3a48b12-d541-467b-aeb3-df014e60da6b.xhtml)《数据卷与配置》中看到，如何将主机文件夹映射为容器中的卷。如果我想例如将主机文件夹`/projects/sample-app`挂载到容器的`/app`，其语法如下所示：
- en: '[PRE16]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice the line `--volume <host-folder>:<container-folder>`. The path to the
    host folder needs to be an absolute path, as in the example, `/projects/sample-app`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意行`--volume <host-folder>:<container-folder>`。主机文件夹的路径需要是绝对路径，如示例中所示，`/projects/sample-app`。
- en: 'If we now want to run a container from our `sample-app` container image, and,
    if we do that from the project folder, then we can map the current folder into
    the `/app` folder of the container as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在想从我们的`sample-app`容器镜像中运行一个容器，并且如果我们从项目文件夹中运行它，那么我们可以将当前文件夹映射到容器的`/app`文件夹，具体如下：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Please note the `$(pwd)` in place of the host folder path. `$(pwd)` evaluates
    to the absolute path of the current folder, which comes in very handy.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`$(pwd)`代替主机文件夹路径。`$(pwd)`会解析为当前文件夹的绝对路径，这非常方便。
- en: Now, if we do mount the current folder into the container as described above,
    then whatever was in the `/app` folder of the `sample-app` container image will
    be overridden by the content of the mapped host folder, that is, in our case,
    the current folder. That's exactly what we want—we want the current source to
    be mapped from the host in the container.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们像上面描述的那样将当前文件夹挂载到容器中，那么`sample-app`容器镜像中的`/app`文件夹中的任何内容都会被映射的主机文件夹的内容覆盖，也就是我们当前文件夹的内容。这正是我们想要的——我们希望将当前的源代码从主机映射到容器中。
- en: 'Let''s test whether it works:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们测试一下它是否有效：
- en: Stop the container if you have started it by pressing *Ctrl* + *C.*
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经启动了容器，按*Ctrl* + *C*来停止容器。
- en: 'Then add the following snippet to the end of the `index.js` file:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后将以下代码片段添加到`index.js`文件的末尾：
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Do not forget to save.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记保存。
- en: 'Then run the container again – this time without rebuilding the image first
    – to see what happens:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后再次运行容器——这次不先重建镜像——来看看会发生什么：
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In your browser, navigate to `localhost:3000/status` and expect to see the `OK`
    output in the browser window. Alternatively, you could use `curl` in another terminal
    window:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中，导航到`localhost:3000/status`，你应该能看到浏览器窗口中显示`OK`输出。或者，你也可以在另一个终端窗口中使用`curl`：
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: For all those working on Windows and/or Docker for Windows, you can use the
    PowerShell command `Invoke-WebRequest` or `iwr` for short instead of `curl`. The
    equivalent to the preceding command would then be `iwr -Url localhost:3000/status`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有在Windows和/或Windows上使用Docker的人员，您可以使用PowerShell命令 `Invoke-WebRequest` 或简称为
    `iwr`，而不是 `curl`。然后，前面命令的等效命令将是 `iwr -Url localhost:3000/status`。
- en: Leave the application in the container running for the moment and make yet another
    change. Instead of just returning `OK` when navigating to `/status`, we want the
    message `OK, all good` to be returned. Make your modification and save the changes.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 暂时保持容器中运行的应用程序，并进行另一个更改。在导航到 `/status` 时，我们希望返回消息 `OK, all good` 而不仅仅是返回 `OK`。进行您的修改并保存更改。
- en: Then execute the `curl` command again or, if you did use the browser, refresh
    the page. What do you see? Right—nothing happened. The change we made is not reflected
    in the running application.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后再次执行 `curl` 命令，或者如果您使用了浏览器，请刷新页面。看到了什么？没错——什么也没发生。我们所做的更改没有反映在运行的应用程序中。
- en: 'Well, let''s double-check whether the change has been propagated in the running
    container. To do this, let''s execute the following command:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 嗯，让我们再次检查更改是否已传播到运行中的容器中。为此，让我们执行以下命令：
- en: '[PRE21]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We should see something like this—I have shortened the output for readability:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到类似于这样的情况——为了便于阅读，我已经缩短了输出：
- en: '[PRE22]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Evidently, our changes have been propagated into the container as expected.
    Why, then, are the changes not reflected in the running application? Well, the
    answer is simple: for changes to be applied to the application, the application
    has to be restarted.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我们的更改如预期地传播到了容器中。那么，为什么更改没有反映在运行的应用程序中呢？答案很简单：为了应用更改到应用程序中，必须重新启动应用程序。
- en: 'Let''s try that. Stop the container with the application running by pressing
    *Ctrl* + *C*. Then re-execute the preceding `docker container run` command and
    use `curl` to probe the endpoint `localhost:3000/status`. Now, the following new
    message should be displayed:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们试试这个。通过按下 *Ctrl* + *C* 停止运行应用程序的容器。然后重新执行前述的 `docker container run` 命令，并使用
    `curl` 探测端点 `localhost:3000/status`。现在，应该显示以下新消息：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: So, we have achieved a significant reduction in the friction in the development
    process by mapping the source code in the running container. We can now add new
    or modify existing code and test it without having to build the container image
    first. Yet, there is still a bit of friction left in play. We have to manually
    restart the container every time we want to test some new or modified code. Can
    we automate this? The answer is yes! We will demonstrate exactly this in the next
    section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，通过映射运行容器中的源代码，我们在开发过程中显著减少了摩擦。现在我们可以添加新的或修改现有的代码，并在不必先构建容器镜像的情况下进行测试。然而，仍然存在一些摩擦。我们必须每次想要测试新的或修改的代码时手动重新启动容器。我们能自动化这个过程吗？答案是肯定的！我们将在下一节中演示如何做到这一点。
- en: Auto restarting code upon changes
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在代码更改时自动重启代码
- en: Cool—in the last section, we showed how we can massively reduce friction by
    volume mapping the source code folder in the container, thus avoiding having to
    rebuild the container image and rerun the container over and over again.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们展示了如何通过在容器中进行源代码文件的卷映射，大大减少摩擦，从而避免反复重建容器镜像和重新运行容器。
- en: Yet we still feel some remaining friction. The application running inside the
    container does not automatically restart when a code change happens. Thus, we
    have to manually stop and restart the container to pick up the new changes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然感觉到一些残留的摩擦。容器内运行的应用程序在代码更改时不会自动重启。因此，我们必须手动停止和重新启动容器才能应用新的更改。
- en: Auto-restarting for Node.js
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js 的自动重启
- en: 'If you have been coding for a while, you will certainly have heard about helpful
    tools that can run your applications and restart them automatically whenever they
    discover a change in the code base. For Node.js applications, the most popular
    such tool is `nodemon`. We can install `nodemon` globally on our system with the
    following command:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经编程了一段时间，您肯定听说过一些有用的工具，它们可以在检测到代码库中的更改时运行您的应用程序并自动重启它们。对于Node.js应用程序，最流行的此类工具是
    `nodemon`。我们可以使用以下命令在系统上全局安装 `nodemon`：
- en: '[PRE24]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, having `nodemon` available, instead of starting our application (for example,
    on the host) with `node index.js`, we can just execute `nodemon` and we should
    see the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有了 `nodemon` 可用，我们可以不再像在主机上那样使用 `node index.js` 启动我们的应用程序，而是只需执行 `nodemon`，然后我们应该看到以下内容：
- en: '![](img/22d2758a-af1d-4dde-8ad2-130203229506.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/22d2758a-af1d-4dde-8ad2-130203229506.png)'
- en: Using nodemon to run a Node.js application
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 nodemon 运行 Node.js 应用程序
- en: Evidently, `nodemon` has recognized, from parsing our `package.json` file, that
    it should use `node index.js` as the start command.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`nodemon`已经通过解析我们的`package.json`文件，识别到应该使用`node index.js`作为启动命令。
- en: 'Now try to change some code, for example, add the following code snippet at
    the end of `index.js` and then save the file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试修改一些代码，例如，在`index.js`的末尾添加以下代码片段，然后保存文件：
- en: '[PRE25]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Look at the terminal window. Did you see something happening? You should see
    this additional output:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下终端窗口。你看到什么了吗？你应该看到以下附加输出：
- en: '[PRE26]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This clearly indicates that `nodemon` has recognized some changes and automatically
    restarted the application. Try it out with your browser by navigating to `localhost:3000/colors`.
    You should see the following expected output in the browser:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这清楚地表明，`nodemon`已经检测到某些更改，并自动重启了应用程序。通过浏览器访问`localhost:3000/colors`，你应该在浏览器中看到以下预期的输出：
- en: '![](img/83c6ee39-05cc-4c27-a7d2-c609feb6f425.png)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/83c6ee39-05cc-4c27-a7d2-c609feb6f425.png)'
- en: Getting colors
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 获取颜色
- en: 'This is cool—you got this result without having to manually restart the application.
    This makes us yet another bit more productive. Now, can we do the same within
    the container? Yes, we can. We won''t use the start command `node index.js`, as
    defined in the last line of our `Dockerfile`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这很酷——你不需要手动重启应用程序就能得到这个结果。这使我们更具生产力。现在，我们能在容器中做同样的事情吗？是的，我们可以。我们不会使用`Dockerfile`最后一行定义的启动命令`node
    index.js`：
- en: '[PRE27]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We will use `nodemon` instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`nodemon`。
- en: Do we have to modify our `Dockerfile`? Or do we need two different `Dockerfiles`,
    one for development and one for production?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要修改`Dockerfile`吗？还是我们需要两个不同的`Dockerfile`，一个用于开发，一个用于生产环境？
- en: 'Our original `Dockerfile` creates an image that unfortunately does not contain
    `nodemon`. Thus, we need to create a new `Dockerfile`. Let''s call it `Dockerfile-dev`.
    It should look like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们原来的`Dockerfile`创建的镜像不幸没有包含`nodemon`。因此，我们需要创建一个新的`Dockerfile`。我们将其命名为`Dockerfile-dev`，它应该如下所示：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Comparing with our original Dockerfile, we have added line 2 where we install
    `nodemon`. We have also changed the last line and are now using `nodemon` as our
    start command.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们原来的 Dockerfile 比较，我们添加了第 2 行，其中安装了`nodemon`。我们还修改了最后一行，现在使用`nodemon`作为我们的启动命令。
- en: 'Let''s build our development image as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按如下方式构建我们的开发镜像：
- en: '[PRE29]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll run a container like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样运行一个容器：
- en: '[PRE30]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Now, while the application is running in the container, change some code, save,
    and notice that the application inside the container is automatically restarted.
    Thus, we have achieved the same reduction in friction running in a container as
    we did when running directly on the host.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在容器中运行应用程序时，修改一些代码并保存，注意容器中的应用程序会自动重启。因此，我们在容器中达到了与直接在主机上运行时相同的减少摩擦效果。
- en: You may ask, does this only apply to Node.js? No, fortunately many of the popular
    languages support similar concepts.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问，这是否仅适用于 Node.js？不，幸运的是，许多流行的编程语言都支持类似的概念。
- en: Auto-restarting for Python
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Python 的自动重启
- en: 'Let''s look at how the same thing works for Python:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 Python 中如何实现相同的功能：
- en: 'First, create a new project folder for our sample Python application and navigate
    to it:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为我们的示例 Python 应用程序创建一个新的项目文件夹，并进入该文件夹：
- en: '[PRE31]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Open VS Code from within this folder with the command `code .`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令`code .`从该文件夹打开 VS Code。
- en: We will create a sample Python application that uses the popular Flask library.
    Thus, add a `requirements.txt` file with the `flask` content to this folder.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个使用流行 Flask 库的示例 Python 应用程序。因此，向该文件夹中添加一个`requirements.txt`文件，并包含`flask`内容。
- en: 'Next, add a `main.py` file and give it this content:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个`main.py`文件，并将其内容设置为：
- en: '[PRE32]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This is a simple **Hello World** type app that implements a single RESTful endpoint
    at `localhost:5000/`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的**Hello World**类型应用程序，它在`localhost:5000/`实现了一个单一的 RESTful 接口。
- en: 'Before we can run and test this application, we need to install the dependencies—Flask
    in our case. In the terminal, run the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们运行和测试此应用程序之前，我们需要安装依赖项——在我们的例子中是 Flask。在终端中，运行以下命令：
- en: '[PRE33]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This should install Flask on your host. We are now ready to go.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该在你的主机上安装 Flask。现在我们准备好了。
- en: 'When using Python, we can also use `nodemon` to have our application auto restart
    upon any changes to the code. For example, assume that your command to start the
    Python application is `python main.py`. Then you would just use `nodemon` as follows:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Python时，我们也可以使用`nodemon`让我们的应用程序在任何代码更改时自动重启。例如，假设你启动Python应用程序的命令是`python
    main.py`。那么你只需要使用`nodemon`，如下所示：
- en: '[PRE34]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You should see this:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下内容：
- en: '![](img/ad1953cc-ef81-47b5-98a3-f1e499a79d2e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ad1953cc-ef81-47b5-98a3-f1e499a79d2e.png)'
- en: 'Using `nodemon` to start and monitor a Python application, we can test the
    application by using `curl` and should see this:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`nodemon`启动并监控Python应用程序，我们可以通过使用`curl`来测试该应用程序，应该会看到如下输出：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Let''s now modify the code by adding this snippet to `main.py`, right after
    the definition of the `/` endpoint, and save:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，修改代码，在`main.py`中，在定义`/`端点之后添加以下代码片段，并保存：
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`nodemon` will discover the changes and restart the Python app, as we can see
    in the output produced in the terminal:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`nodemon`会发现这些更改并重新启动Python应用程序，如我们在终端中看到的输出：'
- en: '![](img/4a5a9882-9ffa-4e7c-b3f4-96291e0a18a8.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a5a9882-9ffa-4e7c-b3f4-96291e0a18a8.png)'
- en: nodemon discovering a change in the Python code
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: nodemon 发现了Python代码的变化
- en: 'Once again, believing is good, testing is better. Thus, let''s use our friend
    `curl` once again to probe the new endpoint and see what we get:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次提醒，相信是好的，但测试更好。所以，让我们再次使用我们的好朋友`curl`来探测新的端点，看看我们得到的是什么：
- en: '[PRE37]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Nice—it works! With that, we have covered Python. .NET is another popular platform.
    Let's see if we can do something similar to this when developing a C# application
    on .NET.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了——它有效！至此，我们已经覆盖了Python部分。`.NET`是另一个流行的平台。让我们看看在开发C#应用程序时，能否做类似的事情。
- en: Auto-restarting for .NET
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET的自动重启
- en: Our next candidate is a .NET application written in C#. Let's look at how auto-restart
    works in .NET.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个候选者是一个用C#编写的.NET应用程序。让我们看看在.NET中自动重启是如何工作的。
- en: 'First, create a new project folder for our sample C# application and navigate
    to it:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为我们的示例C#应用程序创建一个新的项目文件夹并进入该文件夹：
- en: '[PRE38]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: If you have not done so before, please install .NET Core on your laptop or workstation.
    You can get it at [https://dotnet.microsoft.com/download/dotnet-core](https://dotnet.microsoft.com/download/dotnet-core).
    At the time of writing, version 2.2 is the current stable version. Once it's installed,
    check the version with `dotnet --version`. It is `2.2.401` for me.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前没有做过，请在你的笔记本或工作站上安装.NET Core。你可以在[https://dotnet.microsoft.com/download/dotnet-core](https://dotnet.microsoft.com/download/dotnet-core)获取它。截至写作时，2.2版本是当前的稳定版本。安装完成后，可以通过`dotnet
    --version`检查版本，对我来说是`2.2.401`。
- en: 'Navigate to the source folder for this chapter:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到本章的源文件夹：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'From within this folder, use the `dotnet` tool to create a new Web API and
    have it placed in the `dotnet` subfolder:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内，使用`dotnet`工具创建一个新的Web API，并将其放置在`dotnet`子文件夹中：
- en: '[PRE40]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Navigate to this new project folder:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到这个新的项目文件夹：
- en: '[PRE41]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Once again, use the `code .` command to open VS Code from within the `dotnet` folder.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`code .`命令从`dotnet`文件夹内打开VS Code。
- en: If this is the first time you have opened a .NET Core 2.2 project with VS Code,
    then the editor will start to download some C# dependencies. Wait until all dependencies
    have been downloaded. The editor may also display a popup asking you to add the
    missing dependencies for our `dotnet` project. Click the `Yes` button in this
    case.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是你第一次在VS Code中打开.NET Core 2.2项目，那么编辑器会开始下载一些C#依赖项。请等待所有依赖项下载完成。编辑器还可能弹出一个提示，询问你是否需要添加我们`dotnet`项目中缺少的依赖项。在这种情况下，点击`Yes`按钮。
- en: 'In the project explorer of VS Code, you should see this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code的项目资源管理器中，你应该看到如下内容：
- en: '![](img/e3bc6adf-1a8c-47a6-abaa-c82a45273bf6.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e3bc6adf-1a8c-47a6-abaa-c82a45273bf6.png)'
- en: DotNet Web API project in the VS Code Project Explorer
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在VS Code项目资源管理器中看到DotNet Web API项目
- en: Please note the `Controllers` folder with the `ValuesController.cs` file in
    it. Open this file and analyze its content. It contains the definition for a `ValuesController` class,
    which implements a simple RESTful controller with `GET`, `PUT`, `POST`, and `DELETE`
    endpoints at `api/values`.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意`Controllers`文件夹中有`ValuesController.cs`文件。打开此文件并分析其内容。它包含了`ValuesController`类的定义，该类实现了一个简单的RESTful控制器，具有`GET`、`PUT`、`POST`和`DELETE`端点，路径为`api/values`。
- en: 'From your terminal, run the application with `dotnet run`. You should see something
    like this:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从终端运行应用程序，命令是`dotnet run`。你应该会看到如下输出：
- en: '![](img/ce9234ee-0777-4f2a-b923-096fa5eed231.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ce9234ee-0777-4f2a-b923-096fa5eed231.png)'
- en: Running the .NET sample Web API on the host
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在主机上运行.NET示例Web API
- en: 'We can use `curl` to test the application as follows, for example:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`curl`来测试应用程序，例如：
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The application runs and returns the expected result.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序运行并返回预期的结果。
- en: Please note that the application is configured to redirect `http://localhost:5000`
    to `https://localhost:5001` by default. But, this is an insecure endpoint and
    to suppress the warning, we use the `--insecure` switch.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，默认情况下，应用程序被配置为将`http://localhost:5000`重定向到`https://localhost:5001`。但是，这是一个不安全的端点，为了抑制警告，我们使用`--insecure`开关。
- en: 'We can now try to modify the code in `ValuesController.cs` and return, say,
    three items instead of two from the first `GET` endpoint:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以尝试修改`ValuesController.cs`中的代码，从第一个`GET`端点返回三个项目，而不是两个：
- en: '[PRE43]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Save your changes and rerun the `curl` command. Notice how the result does not
    contain the new added value. It is the same problem as we observed for Node.js
    and Python. To see the new updated return value, we need to (manually) restart
    the application.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改并重新运行`curl`命令。注意结果中没有包含新添加的值。这是我们在Node.js和Python中观察到的相同问题。为了看到更新后的返回值，我们需要（手动）重新启动应用程序。
- en: Thus, in your terminal, stop the application with *Ctrl* + *C *and restart it
    with `dotnet run`. Try the `curl` command again. The result should now reflect
    your changes.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，在终端中，使用*Ctrl* + *C*停止应用程序，然后使用`dotnet run`重新启动它。再次尝试`curl`命令。结果现在应该反映出你的更改。
- en: 'Luckily for us, the `dotnet` tool has the `watch` command. Stop the application
    by pressing *Ctrl* + *C* and execute `dotnet watch run`. You should see output
    resembling the following:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 幸运的是，`dotnet`工具有`watch`命令。通过按*Ctrl* + *C*停止应用程序，然后执行`dotnet watch run`。你应该看到类似如下的输出：
- en: '![](img/301a815c-a80b-481b-9dc9-62e4c3c3b1c4.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/301a815c-a80b-481b-9dc9-62e4c3c3b1c4.png)'
- en: Running the .NET sample application with the watch task
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行带有watch任务的.NET示例应用程序
- en: Notice the second line in the preceding output, which states that the running
    application is now watched for changes.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前述输出中的第二行，它表明正在运行的应用程序现在正在监视更改。
- en: 'Make another change in `ValuesController.cs`; for example, add a fourth item
    to the return value of the first `GET` endpoint and save. Observe the output in
    the terminal. It should look something like this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ValuesController.cs`中进行另一次更改；例如，向第一个`GET`端点的返回值中添加第四项并保存。观察终端中的输出，应该类似如下：
- en: '![](img/9fba6353-e07a-4a10-b126-527c6a8db185.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9fba6353-e07a-4a10-b126-527c6a8db185.png)'
- en: Auto restarting the running sample .NET Core application
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 自动重启正在运行的示例.NET Core应用程序
- en: 'With that automatic restart of the application upon changes to the code, the
    result is immediately available to us and we can easily test it by running the `curl`
    command:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在代码更改后自动重新启动应用程序，结果立即可用，我们可以通过运行`curl`命令轻松测试它：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now that we have auto restart working on the host, we can author a Dockerfile
    that does the same for the application running inside a container. In VS Code,
    add a new file called `Dockerfile-dev` to the project and add the following content
    to it:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们已经让主机上的自动重启正常工作，可以编写一个Dockerfile，让容器内运行的应用程序也执行相同的操作。在VS Code中，向项目添加一个名为`Dockerfile-dev`的新文件，并将以下内容添加到其中：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Before we can continue and build the container image, we need to add a slight
    modification to the startup configuration of the .NET application, such that the
    web server (Kestrel in this case) listens, for example, at `0.0.0.0:3000` and
    will thus be able to run inside a container and be accessible from outside of
    the container. Open the `Program.cs` file and make the following modification
    to the `CreateWebHostBuilder` method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续并构建容器镜像之前，我们需要对.NET应用程序的启动配置做一些小修改，使得Web服务器（此例为Kestrel）能够监听，例如`0.0.0.0:3000`，从而能够在容器内运行并且能够从容器外部访问。打开`Program.cs`文件，并对`CreateWebHostBuilder`方法进行以下修改：
- en: '[PRE46]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: With the `UseUrls` method, we tell the web server to listen to the desired endpoints.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`UseUrls`方法，我们告诉Web服务器监听所需的端点。
- en: 'Now we''re ready to build the container image:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好构建容器镜像：
- en: 'To build the image use the following command:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建镜像，请使用以下命令：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Once the image is built, we can run a container from it:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦镜像构建完成，我们可以从中运行一个容器：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'We should see a similar output to that seen when running natively:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该看到与本地运行时类似的输出：
- en: '![](img/4b6f2740-1d2a-41ce-9da3-757f75512528.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4b6f2740-1d2a-41ce-9da3-757f75512528.png)'
- en: A .NET sample application running in a container
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个在容器中运行的.NET示例应用程序
- en: 'Let''s test the application with our friend `curl`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过我们的朋友`curl`来测试应用程序：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: No surprises here—it works as expected.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么意外的——它按预期工作。
- en: 'Now let''s do a code change in the controller and then save. Observe what''s
    happening in the terminal window. We should see an output similar to this:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在控制器中做个代码更改并保存。观察终端窗口发生了什么。我们应该看到类似这样的输出：
- en: '![](img/7f7041fc-6e7e-4f62-b663-1f828997d1fa.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f7041fc-6e7e-4f62-b663-1f828997d1fa.png)'
- en: Auto restart happening to the .NET sample application running inside the container
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: .NET示例应用程序在容器内自动重启
- en: Well, that's exactly what we expected. With this, we have removed most of the
    friction introduced by using containers when developing a .NET application.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，这正是我们预期的结果。这样一来，我们就消除了在开发.NET应用程序时使用容器带来的大部分摩擦。
- en: Line-by-line code debugging inside a container
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器内逐行代码调试
- en: Before we dive into this section about the line-by-line debugging of code running
    inside a container, let me make a disclaimer. What you will learn here should
    usually be your last resort, if nothing else works. Ideally, when following a
    test-driven approach when developing your application, the code is mostly guaranteed
    to work due to the fact that you have written unit and integration tests for it
    and run them against your code, which also runs in a container. Alternatively,
    if unit or integration tests don't provide you with enough insight and you really
    need to debug your code line by line, you can do so having your code running directly
    on your host, thus leveraging the support of development environments such as
    Visual Studio, Eclipse, or IntelliJ, to name just a few IDEs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入讲解如何逐行调试容器中运行的代码之前，先做个免责声明。你将在这里学到的内容通常应该是最后的手段，如果其他方法都无法解决问题。理想情况下，当你采用测试驱动开发方法来开发应用程序时，代码大部分是有保障的，因为你已经为它编写了单元测试和集成测试，并且将这些测试应用到你的代码上，而这些代码也运行在容器内。或者，如果单元测试或集成测试未能为你提供足够的洞察，并且你真的需要逐行调试代码，你可以让代码直接在主机上运行，从而利用像Visual
    Studio、Eclipse或IntelliJ等开发环境的支持，举几个IDE的例子。
- en: With all this preparation, you should rarely need to have to manually debug
    your code as it is running inside a container. That said, let's see how you can
    do it!
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 经过所有这些准备后，你应该很少需要手动调试运行在容器中的代码。话虽如此，我们来看一下你该如何操作！
- en: In this section, we are going to concentrate exclusively on how to debug when
    using Visual Studio Code. Other editors and IDEs may or may not offer similar
    capabilities.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于如何在使用Visual Studio Code时进行调试。其他编辑器和IDE可能提供或不提供类似的功能。
- en: Debugging a Node.js application
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试一个Node.js应用程序
- en: 'We''ll start with the easiest one—a Node.js application. We will use our sample
    application in folder `~/fod/ch06/node`, which we worked with earlier in this
    chapter:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从最简单的一个开始——Node.js应用程序。我们将使用本章之前在`~/fod/ch06/node`文件夹中的示例应用程序：
- en: 'Make sure that you navigate to this project folder and open VS Code from within
    it:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你进入该项目文件夹并从其中打开VS Code：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the terminal window, from within the project folder, run a container with
    our sample Node.js application:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，从项目文件夹内运行一个带有我们示例Node.js应用程序的容器：
- en: '[PRE51]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note how I map port `9229` to the host. This port is used by the debugger, and
    VS Studio will communicate with our Node application via this port. Thus it is
    important that you open this port—but only during a debugging session! Also note
    that we override the standard start command defined in the Dockerfile (`node index.js`)
    with `node --inspect=0.0.0.0 index.js`. `--inspect=0.0.0.0` tells Node to run
    in debug mode and listen on all IP4 addresses in the container.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我是如何将端口`9229`映射到主机的。这个端口是调试器使用的，VS Studio会通过这个端口与我们的Node应用程序通信。因此，打开此端口非常重要——但仅限于调试会话期间！还要注意，我们通过`node
    --inspect=0.0.0.0 index.js`覆盖了Dockerfile中定义的标准启动命令（`node index.js`）。`--inspect=0.0.0.0`告诉Node以调试模式运行，并监听容器内所有IP4地址。
- en: 'Now we are ready to define a VS Code launch task for the scenario at hand,
    that is, our code running inside a container:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备好为当前情境定义一个VS Code启动任务，也就是我们的代码运行在容器内的情景：
- en: To open the`launch.json` file, press *Ctrl*+*Shift*+*P*(or *Ctrl*+*Shift*+*P*
    on Windows) to open the command palette and look for `Debug:Open launch.json`
    and select it. The `launch.json` file should open in the editor.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要打开`launch.json`文件，按下*Ctrl*+*Shift*+*P*（在Windows上为*Ctrl*+*Shift*+*P*）以打开命令面板，搜索`Debug:Open
    launch.json`并选择它。`launch.json`文件应该在编辑器中打开。
- en: Click the blue Add Configuration... button to add the new configuration we need
    to debug inside the container.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击蓝色的**Add Configuration...**按钮，以添加我们在容器内调试所需的新配置。
- en: 'From the options, select `Docker: Attach to Node`. A new entry will be added
    to the configurations list in the `launch.json` file. It should look similar to
    this:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '从选项中选择`Docker: Attach to Node`。这将向`launch.json`文件的配置列表中添加一个新条目。它应该看起来像这样：'
- en: '[PRE52]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Since we have our code in the `/app` folder, inside the container, we need to
    change the value of `remoteRoot` accordingly. Change the `/usr/src/app` value
    to just `/app`. Do not forget to save your change. That's it, we are ready to
    roll.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们的代码位于容器中的`/app`文件夹，所以我们需要相应地更改`remoteRoot`的值。将`/usr/src/app`的值修改为`/app`。不要忘记保存您的更改。就这样，我们准备好开始了。
- en: Open the Debug view in VS Code by pressing c*ommand* + S*hift* + *D* (*Ctrl *+
    *Shift *+ *D* on Windows).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中按`command` + `Shift` + `D`（Windows系统为`Ctrl` + `Shift` + `D`）打开调试视图。
- en: 'Make sure you select the correct launch task in the dropdown right next to
    the green start button at the top of the view. Select `Docker: Attach to Node`
    as shown here:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '确保在视图顶部绿色启动按钮旁边的下拉菜单中选择正确的启动任务。选择`Docker: Attach to Node`，如下所示：'
- en: '![](img/b1ea1249-cad6-4c9a-86af-5fc24de37ce6.png)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1ea1249-cad6-4c9a-86af-5fc24de37ce6.png)'
- en: Selecting the correct launch task for debugging in VS Code
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中选择正确的启动任务以进行调试
- en: Next click on the green start button to attach VS Code to the Node application
    running in the container.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击绿色启动按钮，将 VS Code 附加到容器中运行的 Node 应用程序。
- en: 'Open `index.js` in the editor and put a breakpoint on the line that returns
    the message `"Sample Application: Hello World!"` when calling the endpoint `''/''`.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在编辑器中打开`index.js`，并在调用`''/''`端点时返回消息`"Sample Application: Hello World!"`的那一行设置断点。'
- en: 'In another terminal window, use `curl` to navigate to `localhost:3000/` and
    observe that the code execution stops at the breakpoint:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，使用`curl`访问`localhost:3000/`并观察代码执行在断点处停止：
- en: '![](img/65e22b06-430b-48ec-ab33-d522d29b3480.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65e22b06-430b-48ec-ab33-d522d29b3480.png)'
- en: The code execution stops at the breakpoint
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行在断点处停止
- en: In the preceding screenshot, we can see the yellow bar indicating that the code
    execution has stopped at the breakpoint. In the upper-right corner, we have a
    toolbar that allows us to navigate through the code, for example, step by step.
    On the left-hand side, we see the `VARIABLES`, `WATCH`, and `CALL STACK` windows,
    which we can use to observe the details of our running application. The fact that
    we are really debugging the code running inside the container can be verified
    by the fact that in the terminal windows where we started the container, we see
    the output `Debugger attached.`, which was generated the moment we started debugging
    inside VS Code.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在上面的截图中，我们可以看到黄色条表示代码执行在断点处停止。在右上角，我们有一个工具栏，可以让我们逐步导航代码。例如，逐步执行。在左侧，我们可以看到`VARIABLES`、`WATCH`和`CALL
    STACK`窗口，可以用来观察运行中的应用程序的详细信息。我们通过终端窗口可以验证我们正在调试的是运行在容器内部的代码，我们在启动容器时看到的输出`Debugger
    attached.`就是我们在 VS Code 中开始调试时生成的。
- en: 'Let''s look how we can further improve the debugging experience:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何进一步改善调试体验：
- en: 'To stop the container, enter the following command in the terminal:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止容器，请在终端中输入以下命令：
- en: '[PRE53]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'If we want to use `nodemon` for even more flexibility, then we have to change
    the `container run` command slightly:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们希望使用`nodemon`来获得更多灵活性，那么我们需要稍微修改`container run`命令：
- en: '[PRE54]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Note how we use the start command, `nodemon --inspect=0.0.0.0 index.js`. This
    will have the benefit that, upon any code changes, the application running inside
    the container will restart automatically, as we learned earlier in this chapter.
    You should see the following:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们如何使用启动命令，`nodemon --inspect=0.0.0.0 index.js`。这样做的好处是，当代码发生任何更改时，容器内运行的应用程序将自动重启，正如我们在本章中之前学习的那样。你应该看到如下内容：
- en: '![](img/8379cd11-64ae-4823-b772-f879d145b95a.png)'
  id: totrans-237
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8379cd11-64ae-4823-b772-f879d145b95a.png)'
- en: Starting the Node.js application with nodemon and debugging turned on
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 使用nodemon启动Node.js应用程序并开启调试
- en: 'Unfortunately, the consequence of an application restart is that the debugger
    loses the connection with VS Code. But no worries—we can mitigate this by adding
    `"restart": true` to our launch task in the `launch.json` file. Modify the task
    such that it looks like this:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '不幸的是，应用程序重启的后果是调试器与 VS Code 失去连接。但别担心——我们可以通过在`launch.json`文件中的启动任务中添加`"restart":
    true`来缓解这一问题。将任务修改如下：'
- en: '[PRE55]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After saving your changes, start the debugger in VS Code by clicking the green
    start button in the debug window. In the terminal, you should again see that the `Debugger
    attached.` message is output. In addition to that, VS Code shows an orange status
    bar at the bottom, indicating that the editor is in debug mode.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改后，在 VS Code 中通过点击调试窗口中的绿色启动按钮启动调试器。在终端中，你应该再次看到输出`Debugger attached.`信息。除此之外，VS
    Code 在底部显示了一个橙色状态栏，表示编辑器处于调试模式。
- en: In a different terminal window, use `curl` and try to navigate to `localhost:3000/`
    to test that line-by-line debugging still works. Make sure code execution stops
    at any breakpoint you have set in the code.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，使用`curl`尝试访问`localhost:3000/`，以测试逐行调试是否仍然有效。确保代码执行会在你设置的任何断点处停下来。
- en: 'Once you have verified that debugging still works, try to modify some code;
    for example, change the message `"Sample Application: Hello World!"` to `"Sample
    Application: Message from within container"` and save your changes. Observe how
    `nodemon` restarts the application and the debugger is automatically re-attached
    to the application running inside the container:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '一旦确认调试仍然有效，尝试修改一些代码；例如，将消息`"Sample Application: Hello World!"`改为`"Sample Application:
    Message from within container"`并保存更改。观察`nodemon`如何重新启动应用程序，并且调试器会自动重新附加到容器内运行的应用程序：'
- en: '![](img/2786f876-ec6c-47de-b54a-79dc3cde1e03.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2786f876-ec6c-47de-b54a-79dc3cde1e03.png)'
- en: nodemon restarting the application and the debugger automatically re-attaching
    to application
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: nodemon 重新启动应用程序，并且调试器会自动重新附加到应用程序上
- en: With that, we have everything assembled and can now work with code running inside
    a container as if the same code were running natively on the host. We have removed
    pretty much all of the friction that the introduction of containers brought into
    the development process. We can now just enjoy the benefits of deploying our code
    in containers.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已经完成了所有配置，现在可以像在主机上本地运行代码一样，操作在容器内运行的代码。我们已经去除了容器引入的几乎所有开发过程中的摩擦。现在，我们可以尽情享受将代码部署在容器中的好处。
- en: To clean up, stop the container by pressing *Ctrl* + *C*.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 要清理，按*Ctrl* + *C*停止容器。
- en: Debugging a .NET application
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试 .NET 应用程序
- en: Now we want to give a quick run-through on how you can debug a .NET application
    line-by-line. We will use the sample .NET application that we created earlier
    in this chapter.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想快速演示如何逐行调试一个 .NET 应用程序。我们将使用本章之前创建的示例 .NET 应用程序。
- en: 'Navigate to the project folder and open VS Code from within there:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目文件夹并从其中打开 VS Code：
- en: '[PRE56]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To work with the debugger, we need to first install the debugger in the container.
    Thus, let''s create a new `Dockerfile` in the project directory. Call it `Dockerfile-debug`
    and add the following content:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用调试器，我们需要先在容器中安装调试器。因此，我们将在项目目录中创建一个新的`Dockerfile`。命名为`Dockerfile-debug`并添加以下内容：
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Please note the second line of the `Dockerfile`, which uses `apt-get` to install
    the `unzip` tool and then uses `curl` to download and install the debugger.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`Dockerfile`的第二行，该行使用`apt-get`安装`unzip`工具，然后使用`curl`下载并安装调试器。
- en: 'We can build an image called `sample-app-dotnet-debug` from this `Dockerfile`
    as follows:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以从这个`Dockerfile`构建一个名为`sample-app-dotnet-debug`的镜像，具体操作如下：
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This command can take a moment to execute since, among other things, the debugger
    has to be downloaded and installed.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令执行可能需要一些时间，因为调试器需要被下载和安装等操作。
- en: 'Once this is done, we can run a container from this image interactively:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们可以交互式地从此镜像运行一个容器：
- en: '[PRE59]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We will see something like this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如下内容：
- en: '![](img/eecd50e0-5674-474a-b60d-600c956d815a.png)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eecd50e0-5674-474a-b60d-600c956d815a.png)'
- en: Sample .NET application started interactively inside the SDK container
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 示例 .NET 应用程序在 SDK 容器内交互式启动
- en: 'In VS Code, open the `launch.json` file and add the following launch task:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，打开`launch.json`文件并添加以下启动任务：
- en: '[PRE60]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Save your changes and switch to the debug window of VS Code (use *command*
    + *Shift* + *D* or *Ctrl* + *Shift* + *D *to open it). Make sure you have selected
    the correct debug launch task—its name is `.NET Core Docker Attach`:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存更改并切换到 VS Code 的调试窗口（使用*command* + *Shift* + *D* 或 *Ctrl* + *Shift* + *D*
    打开）。确保选择了正确的调试启动任务——它的名称是`.NET Core Docker Attach`：
- en: '![](img/f4744775-bcb8-4275-add7-0236bbcf96c1.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4744775-bcb8-4275-add7-0236bbcf96c1.png)'
- en: Select the correct debug launch task in VS Code
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 VS Code 中选择正确的调试启动任务
- en: 'Now click the green start button to start the debugger. As a consequence, the
    popup to select the process shows up with the list of potential processes to attach
    to. Select the process that looks like the one marked in the following screenshot:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击绿色的开始按钮启动调试器。结果，选择进程的弹窗会显示潜在进程的列表。选择看起来像下面屏幕截图中标记的进程：
- en: '![](img/d80edd11-6973-4b92-a886-569ddbd47bda.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d80edd11-6973-4b92-a886-569ddbd47bda.png)'
- en: Select the process to attach the debugger to
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 选择要附加调试器的进程
- en: 'Let''s put a breakpoint in the first `GET` request of the `ValuesController.cs` file
    and then execute a `curl` command:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在`ValuesController.cs`文件的第一个`GET`请求处设置断点，然后执行一个`curl`命令：
- en: '[PRE61]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The code execution should stop at the breakpoint, as shown here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 代码执行应该在断点处停止，如下所示：
- en: '![](img/86642156-418e-4b9a-a322-7638e3970993.png)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![](img/86642156-418e-4b9a-a322-7638e3970993.png)'
- en: Line-by-line debugging a .NET Core application running inside a container
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 逐行调试在容器中运行的.NET Core应用程序
- en: We can now step through the code, define watches, or analyze the call stack
    of the application, similar to what we did with the sample Node.js application.
    Hit the Continue button on the debug toolbar or press *F5* to continue the code
    execution.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以逐步执行代码、定义监视，或分析应用程序的调用栈，类似于我们在示例Node.js应用程序中所做的。在调试工具栏上点击继续按钮或按*F5*继续代码执行。
- en: Now change some code and save the changes. Observe in the terminal window how
    the application is automatically restarted.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更改一些代码并保存更改。观察终端窗口中，应用程序如何自动重启。
- en: Use `curl` again to test whether your changes are visible to the application.
    Indeed, the changes are available, but have you noticed something? Yes—the code
    execution did not start at the breakpoint. Unfortunately, restarting the application
    caused the debugger to disconnect. You have to re-attach the debugger afresh by
    clicking the start button in the debug view of VS Code and selecting the right
    process.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`curl`测试您的更改是否对应用程序可见。实际上，您的更改已经生效，但您注意到什么了吗？是的——代码执行并没有在断点处启动。不幸的是，重新启动应用程序导致调试器断开连接。您必须通过点击VS
    Code调试视图中的开始按钮，并选择正确的进程，重新附加调试器。
- en: To stop the application, press *Ctrl* + *C* in the terminal window where you
    started the container.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要停止应用程序，请在您启动容器的终端窗口中按*Ctrl* + *C*。
- en: Now that we know how to debug code running in a container line by line, it is
    time to instrument our code such that it produces meaningful logging information.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道如何逐行调试在容器中运行的代码，是时候对代码进行仪器化，以生成有意义的日志信息。
- en: Instrumenting your code to produce meaningful logging information
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对代码进行仪器化，以生成有意义的日志信息
- en: Once an application is running in production, it is impossible or strongly discouraged
    to interactively debug the application. Thus, we need to come up with other ways
    to find the root cause when the system is behaving unexpectedly or causing errors.
    The best way is to have the application generate detailed logging information
    that can then be used by the developers that need to track down any errors. Since
    logging is such a common task, all relevant programming languages or frameworks
    offer libraries that make the task of producing logging information inside an
    application straightforward.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序在生产环境中运行，就无法或强烈不建议以交互方式调试应用程序。因此，我们需要想出其他方法来查找系统异常行为或错误的根本原因。最好的方法是让应用程序生成详细的日志信息，然后由开发人员用来追踪错误。由于日志记录是一个非常常见的任务，所有相关的编程语言或框架都提供了库，使得在应用程序内部生成日志信息变得简单。
- en: 'It is common to categorize the information output by an application as logs
    into so-called severity levels. Here is the list of those severity levels with
    a short description of each:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 将应用程序输出的信息作为日志，通常会被分类为所谓的严重性级别。以下是这些严重性级别的列表，并附有每个级别的简短说明：
- en: '| **Security levels** | **Explanation** |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| **安全级别** | **说明** |'
- en: '| TRACE | Very fine-grained information. At this level, you are looking at
    capturing every detail possible about your application''s behavior. |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| TRACE | 非常细粒度的信息。在这个级别，您将捕获尽可能多的关于应用程序行为的每一个细节。 |'
- en: '| DEBUG | Relatively granular and mostly diagnostic information helping to
    pin down potential problems if they occur. |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| DEBUG | 相对细粒度的信息，主要是诊断信息，有助于找出潜在问题。 |'
- en: '| INFO | Normal application behavior or milestones. |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| INFO | 正常的应用程序行为或里程碑。 |'
- en: '| WARN | The application might have encountered a problem or you detected an
    unusual situation. |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| WARN | 应用程序可能遇到了问题，或者您检测到了异常情况。 |'
- en: '| ERROR | The application encountered a serious issue. This most probably represents
    the failure of an important application task. |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| ERROR | 应用程序遇到了严重问题。这很可能代表了一个重要应用任务的失败。 |'
- en: '| FATAL | The catastrophic failure of your application. The immediate shutdown
    of the application is advised. |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| FATAL | 应用程序的灾难性故障。建议立即关闭应用程序。 |'
- en: List of the severity levels used when generating logging information
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 生成日志信息时使用的严重性级别列表
- en: Logging libraries usually allow a developer to define different log sinks, that
    is, destinations for the logging information. Popular sinks are file sinks or
    a stream to the console. When working with containerized applications, it is strongly
    recommended to always direct logging output to the console or `STDOUT`. Docker
    will then make this information available to you via the `docker container logs`
    command. Other log collectors, such as Prometheus, can also be used to scrape
    this information.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录库通常允许开发人员定义不同的日志接收器，即日志信息的目的地。常见的接收器包括文件接收器或流式输出到控制台。在使用容器化应用程序时，强烈建议始终将日志输出定向到控制台或`STDOUT`。Docker随后将通过`docker
    container logs`命令提供这些信息。其他日志收集器，如Prometheus，也可以用来抓取这些信息。
- en: Instrumenting a Python application
  id: totrans-293
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对Python应用程序进行日志记录
- en: 'Let''s now try to instrument our existing Python sample application:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试为我们现有的Python示例应用程序添加日志记录：
- en: 'First, in your terminal, navigate to the project folder and open VS Code:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在终端中，导航到项目文件夹并打开VS Code：
- en: '[PRE62]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Open the `main.py` file and add the following code snippet to the top of it:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`main.py`文件，并将以下代码片段添加到文件顶部：
- en: '![](img/871e4924-7ec2-432a-a734-32236d84e6dd.png)'
  id: totrans-298
  prefs: []
  type: TYPE_IMG
  zh: '![](img/871e4924-7ec2-432a-a734-32236d84e6dd.png)'
- en: Defining a logger for our Python sample application
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的Python示例应用程序定义一个logger
- en: On line `1`, we import the standard `logging` library. We then define a `logger`
    for our sample application of line `3`. On line `4`, we define the filter for
    logging to be used. In this case, we set it to `WARN`. That means that all logging
    messages produced by the application with a severity equal to or higher than `WARN`
    will be output to the defined `logging` handlers or sinks as we called them at
    the beginning of this section. In our case, only log messages with a log level
    of `WARN`, `ERROR`, or `FATAL` will be output.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`1`行，我们导入了标准的`logging`库。然后在第`3`行我们为示例应用程序定义了一个`logger`。在第`4`行，我们定义了用于日志记录的过滤器。在这个例子中，我们将其设置为`WARN`。这意味着所有由应用程序生成的日志消息，如果其严重性等于或高于`WARN`，将输出到我们在本节开始时定义的`logging`处理程序或接收器。对于我们来说，只有日志级别为`WARN`、`ERROR`或`FATAL`的日志消息会被输出。
- en: On line `6`, we create a logging sink or handler. In our case, it is `StreamHandler`,
    which outputs to `STDOUT`. Then, on line `8`, we define how we want the `logger`
    to format the messages it outputs. Here, the format that we chose will output
    the time and date, the application (or `logger`) name, the log severity level,
    and finally, the actual message that we developers define in code. On line `9`,
    we add the formatter to the log handler, and, on line `10`, we add the handler
    to the `logger`. Note that we can define more than one handler per logger. Now
    we are ready to use the `logger`.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 在第`6`行，我们创建了一个日志接收器或处理程序。在我们的例子中，它是`StreamHandler`，它将输出到`STDOUT`。然后，在第`8`行，我们定义了我们希望`logger`格式化输出消息的方式。这里我们选择的格式将输出时间和日期、应用程序（或`logger`）名称、日志严重性级别，最后是我们开发人员在代码中定义的实际消息。在第`9`行，我们将格式化器添加到日志处理程序中，并在第`10`行将该处理程序添加到`logger`中。请注意，我们可以为每个logger定义多个处理程序。现在我们已经准备好使用`logger`了。
- en: 'Let''s instrument the `hello` function, which is called when we navigate to
    the endpoint `/`:'
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为`hello`函数添加日志记录，该函数在我们访问端点`/`时被调用：
- en: '![](img/fd0e1528-73d0-4dc2-9f33-1b788f7a9049.png)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fd0e1528-73d0-4dc2-9f33-1b788f7a9049.png)'
- en: Instrumenting a method with logging
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用日志记录为方法添加日志
- en: 'As you can see in the preceding screenshot, we have added line `17`, where
    we use the `logger` object to produce a logging message with log level `INFO`.
    The message is: `"Accessing endpoint ''/''"`.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 如你在前面的截图中看到的，我们添加了第`17`行，在该行中我们使用`logger`对象生成了一个日志级别为`INFO`的日志消息。消息内容是：“访问端点'/'”。
- en: 'Let''s instrument another function and output a message with the log level
    `WARN`:'
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们为另一个函数添加日志记录，并输出日志级别为`WARN`的消息：
- en: '![](img/2e8a0fd1-181f-42ac-9222-60b87d106f48.png)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2e8a0fd1-181f-42ac-9222-60b87d106f48.png)'
- en: Generating a warning
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 生成警告
- en: This time, we produce a message with the log level `WARN` on line `24` in the
    `colors` function. So far, so good—that wasn't hard!
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这一次，我们在第`24`行的`colors`函数中生成了一个日志级别为`WARN`的消息。到目前为止，一切顺利—这并不难！
- en: 'Let''s now run the application and see what output we get:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们运行应用程序，看看我们得到什么输出：
- en: '[PRE63]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Then, in your browser, navigate to `localhost:5000/` first and then to `localhost:5000/colors`.
    You should see an output similar to this:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在浏览器中，先访问 `localhost:5000/`，然后访问 `localhost:5000/colors`。你应该会看到类似以下的输出：
- en: '![](img/94cb7b3f-8a45-4b3d-a3ee-4888acffcac0.png)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94cb7b3f-8a45-4b3d-a3ee-4888acffcac0.png)'
- en: Running the instrumented sample Python application
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 运行已仪器化的示例 Python 应用程序
- en: As you can see, only the warning is output to the console; the `INFO` message
    is not. This is due to the filter we set when defining the logger. Also note how
    our logging message is formatted with the date and time at the beginning, then
    the name of the logger, the log level, and finally, our actual message defined
    on line `24` of our application. When done, please stop the application by pressing
    *Ctrl* + *C*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，只有警告被输出到控制台；`INFO` 消息没有被输出。这是由于我们在定义日志记录器时设置的过滤器。还要注意，日志消息的格式是以日期和时间开始，然后是日志记录器的名称、日志级别，最后是我们在应用程序第
    `24` 行定义的实际消息。完成后，请按 *Ctrl* + *C* 停止应用程序。
- en: Instrumenting a .NET C# application
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对 .NET C# 应用程序进行仪器化
- en: 'Let''s now instrument our sample C# application:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们对我们的示例 C# 应用程序进行仪器化：
- en: 'First, navigate to the project folder, from where you''ll open VS Code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导航到项目文件夹，从那里你将打开 VS Code：
- en: '[PRE64]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Next, we need to add a NuGet package containing the logging library to the
    project:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要向项目中添加包含日志记录库的 NuGet 包：
- en: '[PRE65]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This should add the following line to your `dotnet.csproj` project file:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会将以下行添加到你的 `dotnet.csproj` 项目文件中：
- en: '[PRE66]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Open the `Program.cs` class and notice that we call the `CreateDefaultBuilder(args)` method
    on line `21`:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 类，并注意我们在第 `21` 行调用了 `CreateDefaultBuilder(args)` 方法：
- en: '![](img/cc3af0cf-28b2-4e96-a70e-738c8e871f1b.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cc3af0cf-28b2-4e96-a70e-738c8e871f1b.png)'
- en: Configuring logging in ASP.NET Core 2.2
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 配置 ASP.NET Core 2.2 中的日志记录
- en: This method, by default, adds a few logging providers to the application, among
    them the console logging provider. This comes in very handy and frees us from
    having to do any complicated configuration first. You can, of course, override
    the default setting any time with your own settings.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，这个方法会向应用程序添加一些日志记录提供程序，其中包括控制台日志记录提供程序。这非常方便，免去了我们必须先进行复杂配置的麻烦。当然，你可以随时使用自己的设置覆盖默认设置。
- en: 'Next, open the `ValuesController.cs` file in the `Controllers` folder and add
    the following `using` statement to the top of the file:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 `Controllers` 文件夹中的 `ValuesController.cs` 文件，并在文件顶部添加以下 `using` 语句：
- en: '[PRE67]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Then, in the class body, add an instance variable, `_logger`, of type `ILogger`
    and add a constructor that has a parameter of type `ILogger<T>`. Assign this parameter
    to the instance variable `_logger`:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在类体中，添加一个类型为 `ILogger` 的实例变量 `_logger`，并添加一个接受 `ILogger<T>` 类型参数的构造函数。将该参数赋值给实例变量
    `_logger`：
- en: '![](img/114ba9e1-3443-46be-8da0-70cb5f48bde9.png)'
  id: totrans-331
  prefs: []
  type: TYPE_IMG
  zh: '![](img/114ba9e1-3443-46be-8da0-70cb5f48bde9.png)'
- en: Defining a logger for the Web API controller
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 为 Web API 控制器定义日志记录器
- en: 'Now we''re ready to use the logger in the controller methods. Let''s instrument
    the `Get` method with an `INFO` message:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以在控制器方法中使用日志记录器了。让我们在 `Get` 方法中添加一个 `INFO` 消息：
- en: '![](img/98f9a43a-89d6-4850-993c-3d1f0253e917.png)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![](img/98f9a43a-89d6-4850-993c-3d1f0253e917.png)'
- en: Logging an INFO message from the API controller
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 从 API 控制器记录 INFO 消息
- en: 'Let''s now instrument the `Get(int id)` method:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们对 `Get(int id)` 方法进行仪器化：
- en: '![](img/161ac8ba-ad9b-43a9-9cbe-b3151ddf2062.png)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![](img/161ac8ba-ad9b-43a9-9cbe-b3151ddf2062.png)'
- en: Logging messages with log levels WARN and ERROR
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 WARN 和 ERROR 日志级别记录消息
- en: On line `31`, we have the logger generate a `DEBUG` message and then we have
    some logic on line `32` to catch unexpected values for `id` and producing `ERROR`
    messages and returning an HTTP response status of `404` (not found).
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 `31` 行，我们让日志记录器生成一个 `DEBUG` 消息，然后在第 `32` 行我们有一些逻辑来捕获 `id` 的意外值，并生成 `ERROR`
    消息并返回 HTTP 响应状态 `404`（未找到）。
- en: 'Let''s run the application with the following:'
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用以下命令运行应用程序：
- en: '[PRE68]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We should see this when navigating to `localhost:3000/api/values`:'
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在访问 `localhost:3000/api/values` 时应该看到这个：
- en: '![](img/7b90f29e-efdc-4077-ba5e-40260a5a84ad.png)'
  id: totrans-343
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b90f29e-efdc-4077-ba5e-40260a5a84ad.png)'
- en: Log of our sample .NET application when accessing endpoint `/api/values`
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 访问端点 `/api/values` 时，我们示例 .NET 应用程序的日志
- en: We can see the output of our log message of type `INFO`. All the other log items
    have been produced by the ASP.NET Core library. You can see that there is a lot
    of helpful information available if you need to debug the application.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到类型为 `INFO` 的日志消息输出。所有其他日志项都是由 ASP.NET Core 库生成的。如果你需要调试应用程序，可以看到很多有用的信息。
- en: 'Now let''s try to access the endpoint `/api/values/{id}` with an invalid value
    for `{id}`. We should see something along the lines of this:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们尝试访问 `/api/values/{id}` 端点，并为 `{id}` 提供一个无效的值。我们应该会看到类似这样的内容：
- en: '![](img/872f1f7b-a2ac-4fd4-9fd1-f40e69862d30.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/872f1f7b-a2ac-4fd4-9fd1-f40e69862d30.png)'
- en: Debug and error log items generated by our .NET sample application
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 .NET 示例应用程序生成的调试和错误日志项
- en: We can clearly first see the log item with the level `DEBUG` and then the one
    with the level `ERROR`. The latter in the output is marked in red as `fail`.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以清楚地看到，首先是 `DEBUG` 级别的日志项，然后是 `ERROR` 级别的日志项。输出中的后者被标记为红色的 `fail`。
- en: When done, please end the application with *Ctrl +* C.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，请使用 *Ctrl +* C 结束应用程序。
- en: Now that we have learned about instrumenting, we will look at Jaeger in the
    next section.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了如何进行仪表化，接下来我们将在下一节中介绍 Jaeger。
- en: Using Jaeger to monitor and troubleshoot
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jaeger 进行监控和故障排除
- en: When we want to monitor and troubleshoot transactions in a complex distributed
    system, we need something a bit more powerful than what we have just learned.
    Of course, we can and should continue to instrument our code with meaningful logging
    messages, yet we need something more on top of that. This *more* is the capability
    to trace a single request or transaction end to end, as it flows through the system
    consisting of many application services. Ideally, we would also want to capture
    other interesting metrics such as the time spent on each component versus the
    total time that the request took.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要监控和故障排除一个复杂分布式系统中的事务时，我们需要一些比我们刚刚学到的东西更强大的工具。当然，我们可以并且应该继续用有意义的日志消息来仪表化我们的代码，但我们还需要一些更高层次的东西。这个
    *更高层次的东西* 就是能够追踪一个请求或事务从头到尾的能力，追踪它如何在由多个应用服务组成的系统中流动。理想情况下，我们还希望捕获其他有趣的指标，比如每个组件所花费的时间与请求总时间的对比。
- en: Luckily, we do not have to reinvent the wheel. There is battle-tested open source
    software out there that helps us to achieve exactly the aforementioned goals.
    One example of such an infrastructure component or software is Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)).
    When using Jaeger, you run a central Jaeger server component and each application
    component uses a Jaeger client that will forward debug and tracing information
    transparently to the Jaeger server component. There are Jaeger clients for all
    major programming languages and frameworks, such as Node.js, Python, Java, and
    .NET.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不必重新发明轮子。外面有经过实战验证的开源软件，可以帮助我们实现前面提到的目标。Jaeger（[https://www.jaegertracing.io/](https://www.jaegertracing.io/)）就是这样的一个基础设施组件或软件示例。使用
    Jaeger 时，我们运行一个中央的 Jaeger 服务器组件，而每个应用程序组件使用一个 Jaeger 客户端，透明地将调试和追踪信息转发到 Jaeger
    服务器组件。Jaeger 客户端适用于所有主流编程语言和框架，如 Node.js、Python、Java 和 .NET。
- en: 'We will not go into all the intimate details of how to use Jaeger in this book,
    but will give a high-level overview of how it works conceptually:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中我们不会深入探讨如何使用 Jaeger 的所有细节，而是会对其概念性工作原理进行高层次概述：
- en: First, we define a Jaeger `tracer` object. This object basically coordinates
    the whole process of tracing a request through our distributed application. We
    can use this `tracer` object and also create a `logger` object from it, which
    our application code can use to generate log items, similar to what we did in
    the previous Python and .NET examples.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义一个 Jaeger 的 `tracer` 对象。这个对象基本上协调了整个通过分布式应用程序追踪请求的过程。我们可以使用这个 `tracer`
    对象，还可以从中创建一个 `logger` 对象，我们的应用程序代码可以用它生成日志项，类似于我们在之前的 Python 和 .NET 示例中所做的。
- en: 'Next, we have to wrap each method in the code that we want to trace with what
    Jaeger calls a `span`. The `span` has a name and provides us with a `scope` object.
    Let''s look at some C# pseudo-code that illustrates that:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将每个我们想要追踪的方法用 Jaeger 所谓的 `span` 包裹起来。`span` 有一个名称，并为我们提供一个 `scope` 对象。让我们来看一下以下的
    C# 伪代码，它说明了这一点：
- en: '[PRE69]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you can see, we're instrumenting the `SayHello` method. With a `using` statement
    creating a span, we're wrapping the whole application code of this method. We
    call the span `"say-hello"`, and this will be the ID with which we can identify
    the method in the trace log produced by Jaeger.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在对 `SayHello` 方法进行仪表化。通过一个 `using` 语句创建一个 span，我们将该方法的整个应用程序代码包裹在其中。我们将
    span 命名为 `"say-hello"`，这将是我们在 Jaeger 生成的追踪日志中识别该方法的 ID。
- en: 'Note that the method calls another nested method, `FormatString`. This method
    will look quite similar in regard to the code needed for instrumenting it:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，方法调用了另一个嵌套方法 `FormatString`。这个方法在仪表化代码方面会非常相似：
- en: '[PRE70]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The span that our `tracer` object builds in this method will be a child span
    of the calling method. This child span here is called `"format-string"`. Also
    note that we are using the `logger` object in the preceding method to explicitly
    generate a log item of level `INFO`.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们的 `tracer` 对象构建的跨度将是调用方法的子跨度。这里的子跨度被称为 `"format-string"`。另请注意，我们在前面的方法中使用
    `logger` 对象显式生成了一个 `INFO` 级别的日志项。
- en: In the code included with this chapter, you can find a complete sample application
    written in C# consisting of a Jaeger server container and two application containers
    called client and library that use the Jaeger client library to instrument the
    code.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章包含的代码中，您可以找到一个完整的 C# 示例应用程序，其中包含一个 Jaeger 服务器容器和两个应用程序容器，分别名为 client 和 library，它们使用
    Jaeger 客户端库来对代码进行检测。
- en: 'Navigate to the project folder:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目文件夹：
- en: '[PRE71]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Next, start the Jaeger server container:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动 Jaeger 服务器容器：
- en: '[PRE72]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Next, we need to run the API, which is implemented as an ASP.NET Core 2.2 Web
    API component. Navigate to the `api` folder and start the component:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行 API，它作为 ASP.NET Core 2.2 Web API 组件实现。导航到 `api` 文件夹并启动该组件：
- en: '![](img/94b336c6-7649-43d3-8dc2-7687bf922446.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/94b336c6-7649-43d3-8dc2-7687bf922446.png)'
- en: Starting the API component of the Jaeger sample
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 启动 Jaeger 示例的 API 组件
- en: 'Now open a new terminal window and navigate into the `client` subfolder and
    then run the application:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开一个新的终端窗口，导航到 `client` 子文件夹，然后运行应用程序：
- en: '[PRE73]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Please note the two parameters I am passing—`Gabriel` and `Bonjour`—which correspond
    with `<name>` and `<greeting>`. You should see something along the lines of this:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我传递的两个参数——`Gabriel` 和 `Bonjour`——分别对应 `<name>` 和 `<greeting>`。您应该看到类似以下内容：
- en: '![](img/8eccae4c-eeaa-4704-9253-17e52bb39e7a.png)'
  id: totrans-374
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8eccae4c-eeaa-4704-9253-17e52bb39e7a.png)'
- en: Running the client component of the Jaeger sample application
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 Jaeger 示例应用程序的客户端组件
- en: 'In the preceding output, you can see the three spans marked with red arrows,
    starting from the innermost to the outermost span. We can also use the graphical
    UI of Jaeger to see more details:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的输出中，您可以看到三个用红色箭头标记的跨度，从最内部的跨度到最外部的跨度。我们还可以使用 Jaeger 的图形界面查看更多详细信息：
- en: In your browser, navigate to `http://localhost:16686` to access the Jaeger UI.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中，导航到 `http://localhost:16686` 以访问 Jaeger UI。
- en: 'In the Search panel, make sure the `hello-world` service is selected. Leave
    Operation as `all` and click the Find Traces button. You should see the following:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索面板中，确保选择了 `hello-world` 服务。将操作设置为 `all`，然后点击查找跟踪按钮。您应该会看到以下内容：
- en: '![](img/7824fa13-dd4b-4f0e-94aa-b0c6e6f15989.png)'
  id: totrans-379
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7824fa13-dd4b-4f0e-94aa-b0c6e6f15989.png)'
- en: The Search view of the Jaeger UI
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger UI 的搜索视图
- en: 'Now click on the (only) entry `hello-world: say-hello` to see the details of
    that request:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '现在点击（唯一的）条目 `hello-world: say-hello` 查看该请求的详细信息：'
- en: '![](img/4832a62b-7d0c-473f-b4a5-079070ae44f2.png)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4832a62b-7d0c-473f-b4a5-079070ae44f2.png)'
- en: Details of the request as reported by Jaeger
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Jaeger 报告的请求详细信息
- en: In the preceding screenshot, we can see how the request starts in the `hello-world` component
    in the `say-hello` method, then navigates to the `format-string` method in the
    same component, which, in turn, calls an endpoint in `Webservice`, whose logic
    is implemented in the `FormatController` controller. For each and every step,
    we see the exact timings as well as other interesting information. You can drill
    down in this view to see even more details.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到请求是如何从 `hello-world` 组件中的 `say-hello` 方法开始的，然后导航到同一组件中的 `format-string`
    方法，接着调用 `Webservice` 中的一个端点，其逻辑由 `FormatController` 控制器实现。在每个步骤中，我们都能看到精确的时间以及其他有趣的信息。您可以在此视图中深入查看，了解更多细节。
- en: Before you continue, you may want to take some time and browse through the code
    of the API and the `client` component that we just used for this demo.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您可能需要花点时间浏览一下我们刚刚用于此演示的 API 代码和 `client` 组件的代码。
- en: 'To clean up, stop the Jaeger server container:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了清理，停止 Jaeger 服务器容器：
- en: '[PRE74]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Also stop the API with *Ctrl* + *C*.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 同时停止 API，使用 *Ctrl* + *C*。
- en: Summary
  id: totrans-389
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we have learned how to debug Node.js, Python, Java, and .NET
    code running inside a container. We first started by mounting the source code
    from the host into the container to avoid a rebuild of the container image each
    time the code changes. Then, we smoothed out the development process further by
    enabling automatic application restart inside the container upon code changes.
    Next, we learned how to configure Visual Studio Code to enable the full interactive
    debugging of code running inside a container. Finally, we learned how we can instrument
    our applications such that they generate logging information that can help us
    to do root cause analysis on failures or misbehaving applications or application
    services running in production.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何调试在容器内运行的 Node.js、Python、Java 和 .NET 代码。我们首先通过将源代码从宿主机挂载到容器中，以避免每次代码更改时都重新构建容器镜像。接着，我们通过启用代码变更时容器内应用程序的自动重启，进一步优化了开发流程。然后，我们学习了如何配置
    Visual Studio Code，使其能够启用容器内代码的完整交互式调试。最后，我们学习了如何为我们的应用程序添加监控，使其生成日志信息，帮助我们在生产环境中进行故障排查和根因分析。
- en: In the next chapter, we are going to show how using Docker containers can super-charge
    your automation, from running a simple automation task in a container, to using
    containers to build up CI/CD pipelines.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将展示如何使用 Docker 容器来大幅提升你的自动化流程，从在容器中运行简单的自动化任务，到使用容器构建 CI/CD 管道。
- en: Questions
  id: totrans-392
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Please try to answer the following questions to assess your learning progress:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 请尝试回答以下问题，以评估你的学习进度：
- en: Name two methods that help to reduce the friction in the development process
    introduced by the use of containers.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请列举两种方法，它们可以帮助减少使用容器所引入的开发过程中的摩擦。
- en: How can you achieve a live update of code inside a container?
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如何实现容器内代码的实时更新？
- en: When and why would you use the line-by-line debugging of code running inside
    a container?
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你何时以及为什么会使用逐行调试容器内运行的代码？
- en: Why is instrumenting code with good debugging information paramount?
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么为代码添加良好的调试信息至关重要？
- en: Further reading
  id: totrans-398
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Live debugging with Docker: [https://www.docker.com/blog/live-debugging-docker/](https://www.docker.com/blog/live-debugging-docker/)
  id: totrans-399
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 进行实时调试：[https://www.docker.com/blog/live-debugging-docker/](https://www.docker.com/blog/live-debugging-docker/)
- en: Debug apps in a local Docker container:[https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019)
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地 Docker 容器中调试应用程序：[https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019)
- en: Debug your java applications in Docker using IntelliJ IDEA*: *[https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/](https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/)
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 IntelliJ IDEA 在 Docker 中调试 Java 应用程序：*[https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/](https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/)*
