- en: Debugging Code Running in Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to work with stateful containers, that
    is, containers that consume and produce data. We also learned how to configure
    our containers at runtime and at image build time using environment variables
    and config files.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we're going to introduce techniques commonly used to allow
    a developer to evolve, modify, debug, and test their code while running in a container.
    With these techniques at hand, you will enjoy a frictionless development process
    for applications running in a container, similar to what you experience when developing
    applications that run natively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of the topics we''re going to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Evolving and testing code running in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Auto restarting code upon changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Line-by-line code debugging inside a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instrumenting your code to produce meaningful logging information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Jaeger to monitor and troubleshoot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After finishing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Mount source code residing on the host in a running container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure an application running in a container to auto-restart after a code
    change
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configure Visual Studio Code to debug applications written in Java, Node.js,
    Python, or .NET running inside a container line by line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Log important events from your application code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, if you want to follow along with the code, you need Docker
    for Desktop on macOS or Windows and a code editor—preferably Visual Studio Code.
    The sample will also work on a Linux machine with Docker and VS Code installed.
  prefs: []
  type: TYPE_NORMAL
- en: Evolving and testing code running in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When developing code that will eventually be running in a container, it is
    often the best approach to run the code in the container from the very beginning,
    to make sure there will be no unexpected surprises. But, we have to do this in
    the right way in order not to introduce any unnecessary friction into our development
    process. Let''s first look at a naive way that we could run and test code in a
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new project folder and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s use `npm` to create a new Node.js project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Accept all the defaults. Notice that a `package.json` file is created with
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We want to use the Express.js library in our Node application; thus, use `npm`
    to install it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install the newest version of Express.js on our machine and, because
    of the `--save` parameter, add a reference to our `package.json` file that looks
    similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Start VS Code from within this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'In VS Code, create a new `index.js` file and add this code snippet to it. Do
    not forget to save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'From back within your terminal window, start the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this as the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This means that the application is running and ready to listen at `0.0.0.0:3000`.
    You may ask yourself what the meaning of the host address `0.0.0.0` is and why
    we have chosen it. We will come back to that later, when we run the application
    inside a container. For the moment, just know that `0.0.0.0` is a reserved IP
    address with a special meaning, similar to the loopback address `127.0.0.1`. The `0.0.0.0` address
    simply means *all IPv4 addresses on the local machine*. If a host has two IP addresses,
    say `52.11.32.13` and `10.11.0.1`, and a server running on the host listens on
    `0.0.0.0`, it will be reachable at both of those IPs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open a new tab in your favorite browser and navigate to `localhost:3000`.
    You should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/90516b3c-77d7-4443-9850-c5483270a0ea.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample Node.js app running in a browser
  prefs: []
  type: TYPE_NORMAL
- en: Great—our Node.js application is running on our developer machine. Stop the
    application by pressing *Ctrl* + *C* in the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we want to test the application we have developed so far by running it
    inside a container. To do this, we have to create a `Dockerfile` first, so that
    we can build a container image, from which we can then run a container. Let''s
    use VS Code again to add a file called `Dockerfile` to our project folder and
    give it the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use this `Dockerfile` to build an image called `sample-app` as
    follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After building, run the application in the container with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command runs a container with the name `my-sample-app` from the
    container image `sample-app` and maps the container port `3000` to the equivalent
    host port. The port mapping is necessary; otherwise, we could not access the application
    running inside the container from outside the container. We will learn more about
    port mapping in *[Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)*, *Single-Host
    Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to when we ran the application directly on our host, the output is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Refresh the browser tab from before (or open a new browser tab and navigate
    to `localhost:3000`, if you closed it). You should see that the application still
    runs and produces the same output as when running natively. This is good. We have
    just shown that our application not only runs on our host but also inside a container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop and remove the container by pressing *Ctrl* + *C* in the terminal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s modify our code and add some additional functionality. We will define
    another `HTTP GET` endpoint at `/hobbies`. Please add the following code snippet
    to your `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can first test the new functionality on our host by running the app with
    `node index.js` and navigating to `localhost:3000/hobbies` in the browser. We
    should see the expected output in the browser window. Don't forget to stop the
    application with *Ctrl* + *C* when done testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to test the code when it runs inside the container. Thus, first,
    we create a new version of the container image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we run a container from this new image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can navigate to `localhost:3000/hobbies` in our browser and confirm
    that the application works as expected inside the container too. Once again, don't
    forget to stop the container when done by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: We can repeat this sequence of tasks over and over again for each feature we
    add or any existing features we improve. It turns out that this is a lot of added
    friction compared to times when all the applications we developed always ran directly
    on the host.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can do better. In the next section, we will look at a technique
    that allows us to remove most of the friction.
  prefs: []
  type: TYPE_NORMAL
- en: Mounting evolving code into the running container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if, after a code change, we do not have to rebuild the container image
    and rerun a container? Wouldn't it be great if the changes would immediately,
    as we save them in an editor such as VS Code, be available inside the container
    too? Well, exactly that is possible with volume mapping. In the last chapter,
    we learned how to map an arbitrary host folder into an arbitrary location inside
    a container. We want to leverage exactly that in this section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We saw in [*Chapter 5*](f3a48b12-d541-467b-aeb3-df014e60da6b.xhtml), *Data
    Volumes and Configuration*, how we can map host folders as volumes in a container.
    If I want, for example, to mount a host folder, `/projects/sample-app`, into a
    container at `/app`, the syntax for this looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Notice the line `--volume <host-folder>:<container-folder>`. The path to the
    host folder needs to be an absolute path, as in the example, `/projects/sample-app`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we now want to run a container from our `sample-app` container image, and,
    if we do that from the project folder, then we can map the current folder into
    the `/app` folder of the container as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Please note the `$(pwd)` in place of the host folder path. `$(pwd)` evaluates
    to the absolute path of the current folder, which comes in very handy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we do mount the current folder into the container as described above,
    then whatever was in the `/app` folder of the `sample-app` container image will
    be overridden by the content of the mapped host folder, that is, in our case,
    the current folder. That's exactly what we want—we want the current source to
    be mapped from the host in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test whether it works:'
  prefs: []
  type: TYPE_NORMAL
- en: Stop the container if you have started it by pressing *Ctrl* + *C.*
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then add the following snippet to the end of the `index.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Do not forget to save.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then run the container again – this time without rebuilding the image first
    – to see what happens:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In your browser, navigate to `localhost:3000/status` and expect to see the `OK`
    output in the browser window. Alternatively, you could use `curl` in another terminal
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: For all those working on Windows and/or Docker for Windows, you can use the
    PowerShell command `Invoke-WebRequest` or `iwr` for short instead of `curl`. The
    equivalent to the preceding command would then be `iwr -Url localhost:3000/status`.
  prefs: []
  type: TYPE_NORMAL
- en: Leave the application in the container running for the moment and make yet another
    change. Instead of just returning `OK` when navigating to `/status`, we want the
    message `OK, all good` to be returned. Make your modification and save the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then execute the `curl` command again or, if you did use the browser, refresh
    the page. What do you see? Right—nothing happened. The change we made is not reflected
    in the running application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Well, let''s double-check whether the change has been propagated in the running
    container. To do this, let''s execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see something like this—I have shortened the output for readability:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Evidently, our changes have been propagated into the container as expected.
    Why, then, are the changes not reflected in the running application? Well, the
    answer is simple: for changes to be applied to the application, the application
    has to be restarted.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try that. Stop the container with the application running by pressing
    *Ctrl* + *C*. Then re-execute the preceding `docker container run` command and
    use `curl` to probe the endpoint `localhost:3000/status`. Now, the following new
    message should be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: So, we have achieved a significant reduction in the friction in the development
    process by mapping the source code in the running container. We can now add new
    or modify existing code and test it without having to build the container image
    first. Yet, there is still a bit of friction left in play. We have to manually
    restart the container every time we want to test some new or modified code. Can
    we automate this? The answer is yes! We will demonstrate exactly this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Auto restarting code upon changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Cool—in the last section, we showed how we can massively reduce friction by
    volume mapping the source code folder in the container, thus avoiding having to
    rebuild the container image and rerun the container over and over again.
  prefs: []
  type: TYPE_NORMAL
- en: Yet we still feel some remaining friction. The application running inside the
    container does not automatically restart when a code change happens. Thus, we
    have to manually stop and restart the container to pick up the new changes.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting for Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have been coding for a while, you will certainly have heard about helpful
    tools that can run your applications and restart them automatically whenever they
    discover a change in the code base. For Node.js applications, the most popular
    such tool is `nodemon`. We can install `nodemon` globally on our system with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, having `nodemon` available, instead of starting our application (for example,
    on the host) with `node index.js`, we can just execute `nodemon` and we should
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22d2758a-af1d-4dde-8ad2-130203229506.png)'
  prefs: []
  type: TYPE_IMG
- en: Using nodemon to run a Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: Evidently, `nodemon` has recognized, from parsing our `package.json` file, that
    it should use `node index.js` as the start command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try to change some code, for example, add the following code snippet at
    the end of `index.js` and then save the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the terminal window. Did you see something happening? You should see
    this additional output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'This clearly indicates that `nodemon` has recognized some changes and automatically
    restarted the application. Try it out with your browser by navigating to `localhost:3000/colors`.
    You should see the following expected output in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/83c6ee39-05cc-4c27-a7d2-c609feb6f425.png)'
  prefs: []
  type: TYPE_IMG
- en: Getting colors
  prefs: []
  type: TYPE_NORMAL
- en: 'This is cool—you got this result without having to manually restart the application.
    This makes us yet another bit more productive. Now, can we do the same within
    the container? Yes, we can. We won''t use the start command `node index.js`, as
    defined in the last line of our `Dockerfile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We will use `nodemon` instead.
  prefs: []
  type: TYPE_NORMAL
- en: Do we have to modify our `Dockerfile`? Or do we need two different `Dockerfiles`,
    one for development and one for production?
  prefs: []
  type: TYPE_NORMAL
- en: 'Our original `Dockerfile` creates an image that unfortunately does not contain
    `nodemon`. Thus, we need to create a new `Dockerfile`. Let''s call it `Dockerfile-dev`.
    It should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Comparing with our original Dockerfile, we have added line 2 where we install
    `nodemon`. We have also changed the last line and are now using `nodemon` as our
    start command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build our development image as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll run a container like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, while the application is running in the container, change some code, save,
    and notice that the application inside the container is automatically restarted.
    Thus, we have achieved the same reduction in friction running in a container as
    we did when running directly on the host.
  prefs: []
  type: TYPE_NORMAL
- en: You may ask, does this only apply to Node.js? No, fortunately many of the popular
    languages support similar concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting for Python
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at how the same thing works for Python:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new project folder for our sample Python application and navigate
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Open VS Code from within this folder with the command `code .`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will create a sample Python application that uses the popular Flask library.
    Thus, add a `requirements.txt` file with the `flask` content to this folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, add a `main.py` file and give it this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple **Hello World** type app that implements a single RESTful endpoint
    at `localhost:5000/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can run and test this application, we need to install the dependencies—Flask
    in our case. In the terminal, run the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This should install Flask on your host. We are now ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Python, we can also use `nodemon` to have our application auto restart
    upon any changes to the code. For example, assume that your command to start the
    Python application is `python main.py`. Then you would just use `nodemon` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ad1953cc-ef81-47b5-98a3-f1e499a79d2e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using `nodemon` to start and monitor a Python application, we can test the
    application by using `curl` and should see this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now modify the code by adding this snippet to `main.py`, right after
    the definition of the `/` endpoint, and save:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '`nodemon` will discover the changes and restart the Python app, as we can see
    in the output produced in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a5a9882-9ffa-4e7c-b3f4-96291e0a18a8.png)'
  prefs: []
  type: TYPE_IMG
- en: nodemon discovering a change in the Python code
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, believing is good, testing is better. Thus, let''s use our friend
    `curl` once again to probe the new endpoint and see what we get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Nice—it works! With that, we have covered Python. .NET is another popular platform.
    Let's see if we can do something similar to this when developing a C# application
    on .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Auto-restarting for .NET
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our next candidate is a .NET application written in C#. Let's look at how auto-restart
    works in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a new project folder for our sample C# application and navigate
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: If you have not done so before, please install .NET Core on your laptop or workstation.
    You can get it at [https://dotnet.microsoft.com/download/dotnet-core](https://dotnet.microsoft.com/download/dotnet-core).
    At the time of writing, version 2.2 is the current stable version. Once it's installed,
    check the version with `dotnet --version`. It is `2.2.401` for me.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the source folder for this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'From within this folder, use the `dotnet` tool to create a new Web API and
    have it placed in the `dotnet` subfolder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Navigate to this new project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Once again, use the `code .` command to open VS Code from within the `dotnet` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If this is the first time you have opened a .NET Core 2.2 project with VS Code,
    then the editor will start to download some C# dependencies. Wait until all dependencies
    have been downloaded. The editor may also display a popup asking you to add the
    missing dependencies for our `dotnet` project. Click the `Yes` button in this
    case.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the project explorer of VS Code, you should see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3bc6adf-1a8c-47a6-abaa-c82a45273bf6.png)'
  prefs: []
  type: TYPE_IMG
- en: DotNet Web API project in the VS Code Project Explorer
  prefs: []
  type: TYPE_NORMAL
- en: Please note the `Controllers` folder with the `ValuesController.cs` file in
    it. Open this file and analyze its content. It contains the definition for a `ValuesController` class,
    which implements a simple RESTful controller with `GET`, `PUT`, `POST`, and `DELETE`
    endpoints at `api/values`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From your terminal, run the application with `dotnet run`. You should see something
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ce9234ee-0777-4f2a-b923-096fa5eed231.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the .NET sample Web API on the host
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use `curl` to test the application as follows, for example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The application runs and returns the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the application is configured to redirect `http://localhost:5000`
    to `https://localhost:5001` by default. But, this is an insecure endpoint and
    to suppress the warning, we use the `--insecure` switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now try to modify the code in `ValuesController.cs` and return, say,
    three items instead of two from the first `GET` endpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Save your changes and rerun the `curl` command. Notice how the result does not
    contain the new added value. It is the same problem as we observed for Node.js
    and Python. To see the new updated return value, we need to (manually) restart
    the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Thus, in your terminal, stop the application with *Ctrl* + *C *and restart it
    with `dotnet run`. Try the `curl` command again. The result should now reflect
    your changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Luckily for us, the `dotnet` tool has the `watch` command. Stop the application
    by pressing *Ctrl* + *C* and execute `dotnet watch run`. You should see output
    resembling the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/301a815c-a80b-481b-9dc9-62e4c3c3b1c4.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the .NET sample application with the watch task
  prefs: []
  type: TYPE_NORMAL
- en: Notice the second line in the preceding output, which states that the running
    application is now watched for changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make another change in `ValuesController.cs`; for example, add a fourth item
    to the return value of the first `GET` endpoint and save. Observe the output in
    the terminal. It should look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/9fba6353-e07a-4a10-b126-527c6a8db185.png)'
  prefs: []
  type: TYPE_IMG
- en: Auto restarting the running sample .NET Core application
  prefs: []
  type: TYPE_NORMAL
- en: 'With that automatic restart of the application upon changes to the code, the
    result is immediately available to us and we can easily test it by running the `curl`
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have auto restart working on the host, we can author a Dockerfile
    that does the same for the application running inside a container. In VS Code,
    add a new file called `Dockerfile-dev` to the project and add the following content
    to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we can continue and build the container image, we need to add a slight
    modification to the startup configuration of the .NET application, such that the
    web server (Kestrel in this case) listens, for example, at `0.0.0.0:3000` and
    will thus be able to run inside a container and be accessible from outside of
    the container. Open the `Program.cs` file and make the following modification
    to the `CreateWebHostBuilder` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: With the `UseUrls` method, we tell the web server to listen to the desired endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re ready to build the container image:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To build the image use the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the image is built, we can run a container from it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see a similar output to that seen when running natively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4b6f2740-1d2a-41ce-9da3-757f75512528.png)'
  prefs: []
  type: TYPE_IMG
- en: A .NET sample application running in a container
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s test the application with our friend `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: No surprises here—it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s do a code change in the controller and then save. Observe what''s
    happening in the terminal window. We should see an output similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7f7041fc-6e7e-4f62-b663-1f828997d1fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Auto restart happening to the .NET sample application running inside the container
  prefs: []
  type: TYPE_NORMAL
- en: Well, that's exactly what we expected. With this, we have removed most of the
    friction introduced by using containers when developing a .NET application.
  prefs: []
  type: TYPE_NORMAL
- en: Line-by-line code debugging inside a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into this section about the line-by-line debugging of code running
    inside a container, let me make a disclaimer. What you will learn here should
    usually be your last resort, if nothing else works. Ideally, when following a
    test-driven approach when developing your application, the code is mostly guaranteed
    to work due to the fact that you have written unit and integration tests for it
    and run them against your code, which also runs in a container. Alternatively,
    if unit or integration tests don't provide you with enough insight and you really
    need to debug your code line by line, you can do so having your code running directly
    on your host, thus leveraging the support of development environments such as
    Visual Studio, Eclipse, or IntelliJ, to name just a few IDEs.
  prefs: []
  type: TYPE_NORMAL
- en: With all this preparation, you should rarely need to have to manually debug
    your code as it is running inside a container. That said, let's see how you can
    do it!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to concentrate exclusively on how to debug when
    using Visual Studio Code. Other editors and IDEs may or may not offer similar
    capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Node.js application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start with the easiest one—a Node.js application. We will use our sample
    application in folder `~/fod/ch06/node`, which we worked with earlier in this
    chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you navigate to this project folder and open VS Code from within
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In the terminal window, from within the project folder, run a container with
    our sample Node.js application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Note how I map port `9229` to the host. This port is used by the debugger, and
    VS Studio will communicate with our Node application via this port. Thus it is
    important that you open this port—but only during a debugging session! Also note
    that we override the standard start command defined in the Dockerfile (`node index.js`)
    with `node --inspect=0.0.0.0 index.js`. `--inspect=0.0.0.0` tells Node to run
    in debug mode and listen on all IP4 addresses in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we are ready to define a VS Code launch task for the scenario at hand,
    that is, our code running inside a container:'
  prefs: []
  type: TYPE_NORMAL
- en: To open the`launch.json` file, press *Ctrl*+*Shift*+*P*(or *Ctrl*+*Shift*+*P*
    on Windows) to open the command palette and look for `Debug:Open launch.json`
    and select it. The `launch.json` file should open in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the blue Add Configuration... button to add the new configuration we need
    to debug inside the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the options, select `Docker: Attach to Node`. A new entry will be added
    to the configurations list in the `launch.json` file. It should look similar to
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Since we have our code in the `/app` folder, inside the container, we need to
    change the value of `remoteRoot` accordingly. Change the `/usr/src/app` value
    to just `/app`. Do not forget to save your change. That's it, we are ready to
    roll.
  prefs: []
  type: TYPE_NORMAL
- en: Open the Debug view in VS Code by pressing c*ommand* + S*hift* + *D* (*Ctrl *+
    *Shift *+ *D* on Windows).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Make sure you select the correct launch task in the dropdown right next to
    the green start button at the top of the view. Select `Docker: Attach to Node`
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b1ea1249-cad6-4c9a-86af-5fc24de37ce6.png)'
  prefs: []
  type: TYPE_IMG
- en: Selecting the correct launch task for debugging in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: Next click on the green start button to attach VS Code to the Node application
    running in the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `index.js` in the editor and put a breakpoint on the line that returns
    the message `"Sample Application: Hello World!"` when calling the endpoint `''/''`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In another terminal window, use `curl` to navigate to `localhost:3000/` and
    observe that the code execution stops at the breakpoint:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/65e22b06-430b-48ec-ab33-d522d29b3480.png)'
  prefs: []
  type: TYPE_IMG
- en: The code execution stops at the breakpoint
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see the yellow bar indicating that the code
    execution has stopped at the breakpoint. In the upper-right corner, we have a
    toolbar that allows us to navigate through the code, for example, step by step.
    On the left-hand side, we see the `VARIABLES`, `WATCH`, and `CALL STACK` windows,
    which we can use to observe the details of our running application. The fact that
    we are really debugging the code running inside the container can be verified
    by the fact that in the terminal windows where we started the container, we see
    the output `Debugger attached.`, which was generated the moment we started debugging
    inside VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look how we can further improve the debugging experience:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop the container, enter the following command in the terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to use `nodemon` for even more flexibility, then we have to change
    the `container run` command slightly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how we use the start command, `nodemon --inspect=0.0.0.0 index.js`. This
    will have the benefit that, upon any code changes, the application running inside
    the container will restart automatically, as we learned earlier in this chapter.
    You should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8379cd11-64ae-4823-b772-f879d145b95a.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting the Node.js application with nodemon and debugging turned on
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the consequence of an application restart is that the debugger
    loses the connection with VS Code. But no worries—we can mitigate this by adding
    `"restart": true` to our launch task in the `launch.json` file. Modify the task
    such that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: After saving your changes, start the debugger in VS Code by clicking the green
    start button in the debug window. In the terminal, you should again see that the `Debugger
    attached.` message is output. In addition to that, VS Code shows an orange status
    bar at the bottom, indicating that the editor is in debug mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a different terminal window, use `curl` and try to navigate to `localhost:3000/`
    to test that line-by-line debugging still works. Make sure code execution stops
    at any breakpoint you have set in the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have verified that debugging still works, try to modify some code;
    for example, change the message `"Sample Application: Hello World!"` to `"Sample
    Application: Message from within container"` and save your changes. Observe how
    `nodemon` restarts the application and the debugger is automatically re-attached
    to the application running inside the container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2786f876-ec6c-47de-b54a-79dc3cde1e03.png)'
  prefs: []
  type: TYPE_IMG
- en: nodemon restarting the application and the debugger automatically re-attaching
    to application
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have everything assembled and can now work with code running inside
    a container as if the same code were running natively on the host. We have removed
    pretty much all of the friction that the introduction of containers brought into
    the development process. We can now just enjoy the benefits of deploying our code
    in containers.
  prefs: []
  type: TYPE_NORMAL
- en: To clean up, stop the container by pressing *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a .NET application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we want to give a quick run-through on how you can debug a .NET application
    line-by-line. We will use the sample .NET application that we created earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the project folder and open VS Code from within there:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To work with the debugger, we need to first install the debugger in the container.
    Thus, let''s create a new `Dockerfile` in the project directory. Call it `Dockerfile-debug`
    and add the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: Please note the second line of the `Dockerfile`, which uses `apt-get` to install
    the `unzip` tool and then uses `curl` to download and install the debugger.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build an image called `sample-app-dotnet-debug` from this `Dockerfile`
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This command can take a moment to execute since, among other things, the debugger
    has to be downloaded and installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, we can run a container from this image interactively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/eecd50e0-5674-474a-b60d-600c956d815a.png)'
  prefs: []
  type: TYPE_IMG
- en: Sample .NET application started interactively inside the SDK container
  prefs: []
  type: TYPE_NORMAL
- en: 'In VS Code, open the `launch.json` file and add the following launch task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Save your changes and switch to the debug window of VS Code (use *command*
    + *Shift* + *D* or *Ctrl* + *Shift* + *D *to open it). Make sure you have selected
    the correct debug launch task—its name is `.NET Core Docker Attach`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f4744775-bcb8-4275-add7-0236bbcf96c1.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the correct debug launch task in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click the green start button to start the debugger. As a consequence, the
    popup to select the process shows up with the list of potential processes to attach
    to. Select the process that looks like the one marked in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d80edd11-6973-4b92-a886-569ddbd47bda.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the process to attach the debugger to
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s put a breakpoint in the first `GET` request of the `ValuesController.cs` file
    and then execute a `curl` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The code execution should stop at the breakpoint, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86642156-418e-4b9a-a322-7638e3970993.png)'
  prefs: []
  type: TYPE_IMG
- en: Line-by-line debugging a .NET Core application running inside a container
  prefs: []
  type: TYPE_NORMAL
- en: We can now step through the code, define watches, or analyze the call stack
    of the application, similar to what we did with the sample Node.js application.
    Hit the Continue button on the debug toolbar or press *F5* to continue the code
    execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now change some code and save the changes. Observe in the terminal window how
    the application is automatically restarted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use `curl` again to test whether your changes are visible to the application.
    Indeed, the changes are available, but have you noticed something? Yes—the code
    execution did not start at the breakpoint. Unfortunately, restarting the application
    caused the debugger to disconnect. You have to re-attach the debugger afresh by
    clicking the start button in the debug view of VS Code and selecting the right
    process.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To stop the application, press *Ctrl* + *C* in the terminal window where you
    started the container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know how to debug code running in a container line by line, it is
    time to instrument our code such that it produces meaningful logging information.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting your code to produce meaningful logging information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once an application is running in production, it is impossible or strongly discouraged
    to interactively debug the application. Thus, we need to come up with other ways
    to find the root cause when the system is behaving unexpectedly or causing errors.
    The best way is to have the application generate detailed logging information
    that can then be used by the developers that need to track down any errors. Since
    logging is such a common task, all relevant programming languages or frameworks
    offer libraries that make the task of producing logging information inside an
    application straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common to categorize the information output by an application as logs
    into so-called severity levels. Here is the list of those severity levels with
    a short description of each:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Security levels** | **Explanation** |'
  prefs: []
  type: TYPE_TB
- en: '| TRACE | Very fine-grained information. At this level, you are looking at
    capturing every detail possible about your application''s behavior. |'
  prefs: []
  type: TYPE_TB
- en: '| DEBUG | Relatively granular and mostly diagnostic information helping to
    pin down potential problems if they occur. |'
  prefs: []
  type: TYPE_TB
- en: '| INFO | Normal application behavior or milestones. |'
  prefs: []
  type: TYPE_TB
- en: '| WARN | The application might have encountered a problem or you detected an
    unusual situation. |'
  prefs: []
  type: TYPE_TB
- en: '| ERROR | The application encountered a serious issue. This most probably represents
    the failure of an important application task. |'
  prefs: []
  type: TYPE_TB
- en: '| FATAL | The catastrophic failure of your application. The immediate shutdown
    of the application is advised. |'
  prefs: []
  type: TYPE_TB
- en: List of the severity levels used when generating logging information
  prefs: []
  type: TYPE_NORMAL
- en: Logging libraries usually allow a developer to define different log sinks, that
    is, destinations for the logging information. Popular sinks are file sinks or
    a stream to the console. When working with containerized applications, it is strongly
    recommended to always direct logging output to the console or `STDOUT`. Docker
    will then make this information available to you via the `docker container logs`
    command. Other log collectors, such as Prometheus, can also be used to scrape
    this information.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting a Python application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now try to instrument our existing Python sample application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, in your terminal, navigate to the project folder and open VS Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `main.py` file and add the following code snippet to the top of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/871e4924-7ec2-432a-a734-32236d84e6dd.png)'
  prefs: []
  type: TYPE_IMG
- en: Defining a logger for our Python sample application
  prefs: []
  type: TYPE_NORMAL
- en: On line `1`, we import the standard `logging` library. We then define a `logger`
    for our sample application of line `3`. On line `4`, we define the filter for
    logging to be used. In this case, we set it to `WARN`. That means that all logging
    messages produced by the application with a severity equal to or higher than `WARN`
    will be output to the defined `logging` handlers or sinks as we called them at
    the beginning of this section. In our case, only log messages with a log level
    of `WARN`, `ERROR`, or `FATAL` will be output.
  prefs: []
  type: TYPE_NORMAL
- en: On line `6`, we create a logging sink or handler. In our case, it is `StreamHandler`,
    which outputs to `STDOUT`. Then, on line `8`, we define how we want the `logger`
    to format the messages it outputs. Here, the format that we chose will output
    the time and date, the application (or `logger`) name, the log severity level,
    and finally, the actual message that we developers define in code. On line `9`,
    we add the formatter to the log handler, and, on line `10`, we add the handler
    to the `logger`. Note that we can define more than one handler per logger. Now
    we are ready to use the `logger`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s instrument the `hello` function, which is called when we navigate to
    the endpoint `/`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fd0e1528-73d0-4dc2-9f33-1b788f7a9049.png)'
  prefs: []
  type: TYPE_IMG
- en: Instrumenting a method with logging
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the preceding screenshot, we have added line `17`, where
    we use the `logger` object to produce a logging message with log level `INFO`.
    The message is: `"Accessing endpoint ''/''"`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s instrument another function and output a message with the log level
    `WARN`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2e8a0fd1-181f-42ac-9222-60b87d106f48.png)'
  prefs: []
  type: TYPE_IMG
- en: Generating a warning
  prefs: []
  type: TYPE_NORMAL
- en: This time, we produce a message with the log level `WARN` on line `24` in the
    `colors` function. So far, so good—that wasn't hard!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now run the application and see what output we get:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in your browser, navigate to `localhost:5000/` first and then to `localhost:5000/colors`.
    You should see an output similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94cb7b3f-8a45-4b3d-a3ee-4888acffcac0.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the instrumented sample Python application
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, only the warning is output to the console; the `INFO` message
    is not. This is due to the filter we set when defining the logger. Also note how
    our logging message is formatted with the date and time at the beginning, then
    the name of the logger, the log level, and finally, our actual message defined
    on line `24` of our application. When done, please stop the application by pressing
    *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Instrumenting a .NET C# application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s now instrument our sample C# application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, navigate to the project folder, from where you''ll open VS Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add a NuGet package containing the logging library to the
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This should add the following line to your `dotnet.csproj` project file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `Program.cs` class and notice that we call the `CreateDefaultBuilder(args)` method
    on line `21`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/cc3af0cf-28b2-4e96-a70e-738c8e871f1b.png)'
  prefs: []
  type: TYPE_IMG
- en: Configuring logging in ASP.NET Core 2.2
  prefs: []
  type: TYPE_NORMAL
- en: This method, by default, adds a few logging providers to the application, among
    them the console logging provider. This comes in very handy and frees us from
    having to do any complicated configuration first. You can, of course, override
    the default setting any time with your own settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, open the `ValuesController.cs` file in the `Controllers` folder and add
    the following `using` statement to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the class body, add an instance variable, `_logger`, of type `ILogger`
    and add a constructor that has a parameter of type `ILogger<T>`. Assign this parameter
    to the instance variable `_logger`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/114ba9e1-3443-46be-8da0-70cb5f48bde9.png)'
  prefs: []
  type: TYPE_IMG
- en: Defining a logger for the Web API controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we''re ready to use the logger in the controller methods. Let''s instrument
    the `Get` method with an `INFO` message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/98f9a43a-89d6-4850-993c-3d1f0253e917.png)'
  prefs: []
  type: TYPE_IMG
- en: Logging an INFO message from the API controller
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now instrument the `Get(int id)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/161ac8ba-ad9b-43a9-9cbe-b3151ddf2062.png)'
  prefs: []
  type: TYPE_IMG
- en: Logging messages with log levels WARN and ERROR
  prefs: []
  type: TYPE_NORMAL
- en: On line `31`, we have the logger generate a `DEBUG` message and then we have
    some logic on line `32` to catch unexpected values for `id` and producing `ERROR`
    messages and returning an HTTP response status of `404` (not found).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run the application with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We should see this when navigating to `localhost:3000/api/values`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7b90f29e-efdc-4077-ba5e-40260a5a84ad.png)'
  prefs: []
  type: TYPE_IMG
- en: Log of our sample .NET application when accessing endpoint `/api/values`
  prefs: []
  type: TYPE_NORMAL
- en: We can see the output of our log message of type `INFO`. All the other log items
    have been produced by the ASP.NET Core library. You can see that there is a lot
    of helpful information available if you need to debug the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s try to access the endpoint `/api/values/{id}` with an invalid value
    for `{id}`. We should see something along the lines of this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/872f1f7b-a2ac-4fd4-9fd1-f40e69862d30.png)'
  prefs: []
  type: TYPE_IMG
- en: Debug and error log items generated by our .NET sample application
  prefs: []
  type: TYPE_NORMAL
- en: We can clearly first see the log item with the level `DEBUG` and then the one
    with the level `ERROR`. The latter in the output is marked in red as `fail`.
  prefs: []
  type: TYPE_NORMAL
- en: When done, please end the application with *Ctrl +* C.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have learned about instrumenting, we will look at Jaeger in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jaeger to monitor and troubleshoot
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we want to monitor and troubleshoot transactions in a complex distributed
    system, we need something a bit more powerful than what we have just learned.
    Of course, we can and should continue to instrument our code with meaningful logging
    messages, yet we need something more on top of that. This *more* is the capability
    to trace a single request or transaction end to end, as it flows through the system
    consisting of many application services. Ideally, we would also want to capture
    other interesting metrics such as the time spent on each component versus the
    total time that the request took.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, we do not have to reinvent the wheel. There is battle-tested open source
    software out there that helps us to achieve exactly the aforementioned goals.
    One example of such an infrastructure component or software is Jaeger ([https://www.jaegertracing.io/](https://www.jaegertracing.io/)).
    When using Jaeger, you run a central Jaeger server component and each application
    component uses a Jaeger client that will forward debug and tracing information
    transparently to the Jaeger server component. There are Jaeger clients for all
    major programming languages and frameworks, such as Node.js, Python, Java, and
    .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not go into all the intimate details of how to use Jaeger in this book,
    but will give a high-level overview of how it works conceptually:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we define a Jaeger `tracer` object. This object basically coordinates
    the whole process of tracing a request through our distributed application. We
    can use this `tracer` object and also create a `logger` object from it, which
    our application code can use to generate log items, similar to what we did in
    the previous Python and .NET examples.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we have to wrap each method in the code that we want to trace with what
    Jaeger calls a `span`. The `span` has a name and provides us with a `scope` object.
    Let''s look at some C# pseudo-code that illustrates that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're instrumenting the `SayHello` method. With a `using` statement
    creating a span, we're wrapping the whole application code of this method. We
    call the span `"say-hello"`, and this will be the ID with which we can identify
    the method in the trace log produced by Jaeger.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the method calls another nested method, `FormatString`. This method
    will look quite similar in regard to the code needed for instrumenting it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The span that our `tracer` object builds in this method will be a child span
    of the calling method. This child span here is called `"format-string"`. Also
    note that we are using the `logger` object in the preceding method to explicitly
    generate a log item of level `INFO`.
  prefs: []
  type: TYPE_NORMAL
- en: In the code included with this chapter, you can find a complete sample application
    written in C# consisting of a Jaeger server container and two application containers
    called client and library that use the Jaeger client library to instrument the
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the project folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, start the Jaeger server container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to run the API, which is implemented as an ASP.NET Core 2.2 Web
    API component. Navigate to the `api` folder and start the component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/94b336c6-7649-43d3-8dc2-7687bf922446.png)'
  prefs: []
  type: TYPE_IMG
- en: Starting the API component of the Jaeger sample
  prefs: []
  type: TYPE_NORMAL
- en: 'Now open a new terminal window and navigate into the `client` subfolder and
    then run the application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the two parameters I am passing—`Gabriel` and `Bonjour`—which correspond
    with `<name>` and `<greeting>`. You should see something along the lines of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8eccae4c-eeaa-4704-9253-17e52bb39e7a.png)'
  prefs: []
  type: TYPE_IMG
- en: Running the client component of the Jaeger sample application
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding output, you can see the three spans marked with red arrows,
    starting from the innermost to the outermost span. We can also use the graphical
    UI of Jaeger to see more details:'
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, navigate to `http://localhost:16686` to access the Jaeger UI.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Search panel, make sure the `hello-world` service is selected. Leave
    Operation as `all` and click the Find Traces button. You should see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7824fa13-dd4b-4f0e-94aa-b0c6e6f15989.png)'
  prefs: []
  type: TYPE_IMG
- en: The Search view of the Jaeger UI
  prefs: []
  type: TYPE_NORMAL
- en: 'Now click on the (only) entry `hello-world: say-hello` to see the details of
    that request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4832a62b-7d0c-473f-b4a5-079070ae44f2.png)'
  prefs: []
  type: TYPE_IMG
- en: Details of the request as reported by Jaeger
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, we can see how the request starts in the `hello-world` component
    in the `say-hello` method, then navigates to the `format-string` method in the
    same component, which, in turn, calls an endpoint in `Webservice`, whose logic
    is implemented in the `FormatController` controller. For each and every step,
    we see the exact timings as well as other interesting information. You can drill
    down in this view to see even more details.
  prefs: []
  type: TYPE_NORMAL
- en: Before you continue, you may want to take some time and browse through the code
    of the API and the `client` component that we just used for this demo.
  prefs: []
  type: TYPE_NORMAL
- en: 'To clean up, stop the Jaeger server container:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Also stop the API with *Ctrl* + *C*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to debug Node.js, Python, Java, and .NET
    code running inside a container. We first started by mounting the source code
    from the host into the container to avoid a rebuild of the container image each
    time the code changes. Then, we smoothed out the development process further by
    enabling automatic application restart inside the container upon code changes.
    Next, we learned how to configure Visual Studio Code to enable the full interactive
    debugging of code running inside a container. Finally, we learned how we can instrument
    our applications such that they generate logging information that can help us
    to do root cause analysis on failures or misbehaving applications or application
    services running in production.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to show how using Docker containers can super-charge
    your automation, from running a simple automation task in a container, to using
    containers to build up CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Please try to answer the following questions to assess your learning progress:'
  prefs: []
  type: TYPE_NORMAL
- en: Name two methods that help to reduce the friction in the development process
    introduced by the use of containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you achieve a live update of code inside a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why would you use the line-by-line debugging of code running inside
    a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is instrumenting code with good debugging information paramount?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Live debugging with Docker: [https://www.docker.com/blog/live-debugging-docker/](https://www.docker.com/blog/live-debugging-docker/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug apps in a local Docker container:[https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/containers/edit-and-refresh?view=vs-2019)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug your java applications in Docker using IntelliJ IDEA*: *[https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/](https://blog.jetbrains.com/idea/2019/04/debug-your-java-applications-in-docker-using-intellij-idea/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
