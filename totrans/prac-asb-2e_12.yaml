- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Troubleshooting and Testing Strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a similar way to any other kind of code, Ansible code can contain issues
    and bugs. Ansible tries to make it as safe as possible by checking the task syntax
    before the task is executed. This check, however, only saves you from a small
    number of possible types of errors, such as incorrect task parameters, but it
    will not protect you from others.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also important to remember that, due to its nature, we describe the desired
    state in Ansible code rather than stating a sequence of steps to obtain the desired
    state. This difference means that the system is less prone to logical errors.
  prefs: []
  type: TYPE_NORMAL
- en: Nevertheless, a bug in a playbook could mean a potential misconfiguration on
    all your machines. This should be taken very seriously. It is even more critical
    when critical parts of the system are changed, such as SSH daemon or `sudo` configuration,
    since the risk is you locking yourself out of the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to prevent or mitigate a bug in Ansible playbooks. In this
    chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Digging into playbook execution problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using host facts to diagnose failures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with a playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using check mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Solving host connection issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing working variables via the CLI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the host’s execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Flushing the code cache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for bad syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started
    with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 2.9\. Although we will give specific
    examples of hostnames in this chapter, you are free to substitute them with your
    hostnames and/or IP addresses. Details of how to do this will be provided at the
    appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The examples in this chapter can be found in this book’s GitHub repository at
    [https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%2012](https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%2012).
  prefs: []
  type: TYPE_NORMAL
- en: Digging into playbook execution problems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are cases where an Ansible execution will interrupt. Many things can cause
    these situations.
  prefs: []
  type: TYPE_NORMAL
- en: The network is the most frequent cause of problems I’ve found while executing
    Ansible playbooks. Since the machine issuing the commands and the one performing
    them are usually linked through the network, a problem in the network will immediately
    show itself as an Ansible execution problem.
  prefs: []
  type: TYPE_NORMAL
- en: You can tell Ansible to repeat the execution of a task by registering a variable
    and using the `until` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, and this is particularly true for some modules, such as `ansible.builtin.shell`
    or `ansible.builtin.command`, the return code is non-zero, even though the execution
    was successful. In those cases, you can ignore the error by using the following
    line in your module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'For instance, if you run the `/bin/false` command, it will always return `1`.
    To execute this in a playbook so that you can avoid it blocking there, you can
    write something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen, `/bin/false` will always return `1` as the return code, but
    we still managed to proceed with the execution. Be aware that this is a particular
    case. Often, the best approach is to fix your application so that you follow UNIX
    standards and return `0` if the application runs appropriately instead of putting
    a workaround in your playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will talk more about the methods we can use to diagnose Ansible execution
    problems.
  prefs: []
  type: TYPE_NORMAL
- en: Using host facts to diagnose failures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Some execution failures derive from the state of the target machine. The most
    common problem of this kind is the case where Ansible expects a file or variable
    to be present, but it’s not there.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it can be enough to print the machine facts to find the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we need to create a simple playbook called `print_facts.yaml`, which
    contains the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This technique will give you a lot of information about the state of the target
    machine during Ansible execution.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with a playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most complex things in the IT field is not creating software and
    systems but debugging them when they have problems. Ansible is no exception. No
    matter how good you are at creating Ansible playbooks, sooner or later, you’ll
    find yourself debugging a playbook that is not behaving as you thought it would.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simplest way of performing basic tests is to print out the values of variables
    during execution. Let’s learn how to do this with Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we need a playbook called `debug.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will receive an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '---'
  prefs: []
  type: TYPE_NORMAL
- en: '- hosts: localhost'
  prefs: []
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '- ansible.builtin.shell: /usr/bin/uptime'
  prefs: []
  type: TYPE_NORMAL
- en: 'register: result'
  prefs: []
  type: TYPE_NORMAL
- en: '- ansible.builtin.debug:'
  prefs: []
  type: TYPE_NORMAL
- en: 'var: result'
  prefs: []
  type: TYPE_NORMAL
- en: 'verbosity: 2'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: TASK [debug] **************************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'skipping: [localhost]'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-playbook debug2.yaml -vv
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- hosts: localhost'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'tasks:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: Touch a file'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'ansible.builtin.file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'path: /tmp/myfile'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'state: touch'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ ansible-playbook check-mode.yaml --check
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: PLAY [localhost] **********************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: TASK [Gathering Facts] ****************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [localhost]'
  prefs: []
  type: TYPE_NORMAL
- en: TASK [Touch a file] *******************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [localhost]'
  prefs: []
  type: TYPE_NORMAL
- en: PLAY RECAP ****************************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: /tmp, you won’t find myfile.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible check mode is usually called a dry run. The idea is that the run won’t
    change the state of the machine and will only highlight the differences between
    the current status and the status declared in the Playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not all modules support check mode, but all major modules do, and more and
    more modules are being added at every release. In particular, note that the `ansible.builtin.command`
    and `ansible.builtin.shell` modules do not support it because the module can’t
    tell what commands will result in a change, and what won’t. Therefore, these modules
    will always return changed when they’re run outside of check mode because they
    assume a change has been made. It is possible to find out whether a specific module
    supports check mode by looking in the module’s documentation, in the *Attributes*
    section. A similar feature to check mode is the `--diff` flag. A big difference
    between those two options is that, while check mode will not make changes to the
    systems, `--diff` will perform the changes on the system! What the `--diff` flag
    allows us to do is track what exactly changed during an Ansible execution. So,
    let’s say we run the same playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the output says `changed`, which means that something was changed
    (more specifically, the file was created), and in the output, we can see a diff-like
    output that tells us that the state moved from `absent` to `touch`, which means
    the file was created. `mtime` and `atime` also changed, but this is probably due
    to how files are created and checked.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to use check mode, let’s learn how to solve host
    connection issues.
  prefs: []
  type: TYPE_NORMAL
- en: Solving host connection issues
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is often used to manage remote hosts or systems. To do this, Ansible
    will need to be able to connect to the remote host, and only after that will it
    be able to issue commands. Sometimes, the problem is that Ansible is unable to
    connect to the remote host. A typical example of this is when you try to manage
    a machine that hasn’t booted yet. Being able to quickly recognize these kinds
    of problems and fix them promptly will help you save a lot of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a playbook called `remote.yaml` with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  We can try to run the `remote.yaml` playbook against a non-existent FQDN,
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, the output will inform us that the SSH service did not reply
    in time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the host did reply, but we don’t have enough access to be able
    to SSH into it.
  prefs: []
  type: TYPE_NORMAL
- en: 'SSH connections usually fail for one of two reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The SSH client is unable to establish a connection with the SSH server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSH server refuses the credentials provided by the SSH client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Due to OpenSSH’s very high stability and backward compatibility, when the first
    issue occurs, it’s very probable that the IP address or the port is wrong, so
    the TCP connection isn’t feasible. Very rarely, this kind of error occurs in SSH-specific
    problems. Usually, double-checking the IP and the hostname (if it’s DNS, check
    that it resolves to the right IP) solves the problem. To investigate this further,
    you can try performing an SSH connection from the same machine to check whether
    there are problems. For instance, I would do this like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: I’ve taken the hostname from the error itself to ensure that I’m simulating
    exactly what Ansible is doing. I’m doing this to ensure that I can see all possible
    logging messages that SSH can give me to troubleshoot the problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second problem might be a little bit more complex to debug since it can
    happen for multiple reasons. One of those is that you are trying to connect to
    the wrong host and you don’t have the credentials for that machine. Another common
    case is that the username is wrong. To debug it, you can take the `user@host`
    address that is shown in the error (in my case, `fale@host.example.com`) and use
    the same command you used previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This should raise the same error that Ansible reported to you but with much
    more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to solve host connection issues, let’s learn how
    to pass working variables via the CLI.
  prefs: []
  type: TYPE_NORMAL
- en: Passing working variables via the CLI
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that can help during debugging, and definitely helps for code reusability,
    is passing variables to playbooks via the command line. Every time your application
    – either an Ansible playbook or any kind of application – receives input from
    a third party (a human, in this case), it should ensure that the value is reasonable.
    An example of this would be to check that the variable has been set and therefore
    is not an empty string. This is a security golden rule, but it should also be
    applied when the user is trusted since the user might mistype the variable’s name.
    The application should identify this and protect the whole system by protecting
    itself. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to have is a simple playbook that prints the content
    of a variable. Let’s create a playbook called `printvar.yaml` that contains the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Now that we have an Ansible playbook that allows us to see whether a variable
    has been set to what we were expecting, let’s run it with `variable`, which is
    declared in the execution statement:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By running this, we will receive an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Ansible allows variables to be set in various modes and with different priorities.
    More specifically, you can set them with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: System configuration settings in `/etc/ansible/ansible.cfg` (lowest priority)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User configuration settings in `~/.ansible.cfg`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project configuration in `ansible.cfg` in the current directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ANSIBLE_CONFIG` environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line options
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role defaults
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory files or the `vars` script group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `group_vars/all` inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `group_vars/all` playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `group_vars/*` inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `group_vars/*` playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory files or the `vars` script host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `host_vars/*` inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `host_vars/*` playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host facts/cached `set_facts`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play `vars`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play `vars_prompt`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Play `vars_files`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vars` role (defined in `role/vars/main.yml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vars` block (only for tasks in the block)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vars` task (only for the task)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include_vars`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`set_facts`/registered vars'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Role (and `include_role`) params
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include` params'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command-line extra `vars` (highest priority)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, the last option (and the highest priority of them all) is using
    `--extra-vars` (or `-e`) in the execution command.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to pass working variables via the CLI, let’s learn
    how to limit the host’s execution.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the host’s execution
  prefs: []
  type: TYPE_NORMAL
- en: 'While testing a playbook, it might make sense to test on a restricted number
    of machines; for instance, just one. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the limitation of target hosts on Ansible, we will need a playbook.
    Create a playbook called `helloworld.yaml` that contains the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  We also need to create an inventory with at least two hosts. In my case,
    I created a file called `inventory` that contains the following content:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s run the playbook in the usual way with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'By doing this, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: $ ansible-playbook -i inventory helloworld.yaml --limit=host3.example.com
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: PLAY [all] ****************************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: TASK [Gathering Facts] ****************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [host3.example.com]'
  prefs: []
  type: TYPE_NORMAL
- en: TASK [debug] **************************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: 'ok: [host3.example.com] => {'
  prefs: []
  type: TYPE_NORMAL
- en: '"msg": "Hello, World!"'
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: PLAY RECAP ****************************************************************************************
  prefs: []
  type: TYPE_NORMAL
- en: --limit keyword, we can force Ansible to ignore all the hosts that are outside
    what is specified in the limit parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to specify multiple hosts as a list or with patterns, so both
    of the following commands will execute the playbook against `host2.example.com`
    and `host3.example.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The limit will not override the inventory but will add restrictions to it.
    So, let’s say we limit to a host that is not part of the inventory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will receive the following error, and nothing will be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now that you have learned how to limit the host’s execution, let’s learn how
    to flush the code cache.
  prefs: []
  type: TYPE_NORMAL
- en: Flushing the code cache
  prefs: []
  type: TYPE_NORMAL
- en: Everywhere in IT, caches are used to speed up operations, and Ansible is no
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, caches are good, and for this reason, they are heavily used ubiquitously.
    However, they might create some problems if they cache a value that should not
    have been cached or if they are not flushed, even if the value has changed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Flushing caches in Ansible is very straightforward, and it’s enough to run
    `ansible-playbook`, which we are already running, with the addition of the `--flush-cache`
    option, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Ansible can use multiple cache plugins to save host variables, as well as execution
    variables. Sometimes, those variables might be left behind and influence the following
    executions. When Ansible finds a variable that should be set in the step it just
    started, Ansible might assume that the step has already been completed, and therefore
    pick up that old variable as if it has just been created. By using the `--flush-cache`
    option, we can avoid this since it will ensure that Ansible flushes the Ansible
    facts cache during its execution.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned how to flush the code cache, let’s learn how to check
    for bad syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for bad syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'Defining whether a file has the right syntax or not is fairly easy for a machine,
    but this might be more complex for humans. This does not mean that machines can
    fix the code for you, but they can quickly identify whether a problem is present
    or not. To use Ansible’s built-in syntax checker, we need a playbook with a syntax
    error. Let’s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a `syntaxcheck.yaml` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '2.  Now, we can use the `--``syntax-check` command:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'By doing this, we will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now proceed to fix the indentation problem on line 4:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we recheck the syntax, we will see that it now returns no errors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When the syntax check doesn’t find any errors, the output will resemble the
    previous one, where it listed the files that were analyzed without listing any
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ansible knows all the supported options in all the supported modules,
    it can quickly read your code and validate whether the YAML you provided contains
    all the required fields and that it does not contain any unsupported fields.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the various options that Ansible provides
    so that you can look for problems in your Ansible code. More specifically, you
    learned how to use host facts to diagnose failures, how to include testing within
    a playbook, how to use check mode, how to solve host connection issues, how to
    pass variables from the CLI, how to limit the execution to a subset of hosts,
    how to flush the code cache, and how to check for bad syntax.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to get started with Ansible Automation
    Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs: []
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'True or False: The `ansible.builtin.debug` module allows you to print the value
    of a variable or a fixed string during Ansible’s execution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword allows Ansible to force limit the host’s execution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--``limit`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--``max`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--``restrict`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--``force`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`--``except`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs: []
  type: TYPE_NORMAL
- en: Ansible’s official documentation about error handling can be found at [https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_error_handling.xhtml](https://docs.ansible.com/ansible/latest/playbook_guide/playbooks_error_handling.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
