<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Working with Docker Hub</h1></div></div></div><p>In this chapter, we will look at Docker Hub, what it is, how to sign up for an account, how to pull an image, how to push an image, and automated image builds. This will give us a good solid foundation for future topics when we need to work with official images.</p><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is Docker Hub?</li><li class="listitem" style="list-style-type: disc">Automated builds</li><li class="listitem" style="list-style-type: disc">Working with official images</li></ul></div><div><div><div><div><h1 class="title"><a id="ch02lvl1sec12"/>Working with Docker Hub</h1></div></div></div><p>In this section, we <a id="id26" class="indexterm"/>will discuss Docker Hub, what it is used for, what features does it provide, and lastly, how is it different from other repository sites, such as GitHub or Puppet Forge. We will then create an account and explore our account settings. After this, we will look at official images to get a solid foundation for the next topic.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec12"/>An overview of Docker Hub</h2></div></div></div><p>In the last chapter, we <a id="id27" class="indexterm"/>looked at the Puppet's repo service, The Forge as it is <a id="id28" class="indexterm"/>called by the community (<a class="ulink" href="https://forge.puppetlabs.com/">https://forge.puppetlabs.com/</a>). Now, let's look at Docker's repo service, Docker Hub. We can find <a id="id29" class="indexterm"/>Docker Hub at <a class="ulink" href="https://hub.docker.com/">https://hub.docker.com/</a>.</p><p>The following screenshot shows what the screen looks like:</p><div><img src="img/B05201_02_01.jpg" alt="An overview of Docker Hub"/></div><p>In Docker Hub, there are two <a id="id30" class="indexterm"/>type of images:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Official <a id="id31" class="indexterm"/>images</li><li class="listitem" style="list-style-type: disc">Images <a id="id32" class="indexterm"/>authored by developers</li></ul></div><p>First, we will talk about official images. On Docker Hub, you can get official images for just about any major operating system or application. So, the benefit for you as a developer is that the work to install the application is done for you, saving you the time and effort. This allows you to focus your time on developing. Let's look at an example—we will use golang.</p><p>First, we will search for golang in the search box at the top right-hand side of the front page, as shown in the following screenshot:</p><div><img src="img/B05201_02_02.jpg" alt="An overview of Docker Hub"/></div><p>Our search will <a id="id33" class="indexterm"/>return the following results:</p><div><img src="img/B05201_02_03.jpg" alt="An overview of Docker Hub"/></div><p>We will click on the official release of golang, as shown in the following screenshot:</p><div><img src="img/B05201_02_04.jpg" alt="An overview of Docker Hub"/></div><p>As we can see in the preceding screenshot, this repository gives us a lot of options. So, we can use multiple, different versions of golang, even on multiple different operating systems. So, to build a <a id="id34" class="indexterm"/>golang app, all we need to do is choose an image. We <a id="id35" class="indexterm"/>will use the following image in our Dockerfile:</p><div><img src="img/B05201_02_05.jpg" alt="An overview of Docker Hub"/></div><p>We will then use the <code class="literal">COPY</code> method in our Dockerfile to get our code into the container on build. Lastly, we will run the command shown in the following screenshot to build our container:</p><div><img src="img/B05201_02_06.jpg" alt="An overview of Docker Hub"/></div><p>So, as you can see, it was very easy to build our app, where almost all of our development time would be spent on the actual application. This will increase our productivity and bring the applications to production a lot faster. In this day and age, where agility is everything, you would have to be mad to not see the benefit.</p><p>The second type of image on Docker Hub is developed and open sourced by developers and is maintained by them individually. The easiest way to tell whether an image is official or has been developed by an individual is through the image's name. In our last example, we looked at the golang image. The name of that image is <code class="literal">golang</code>. Now, let's look at a container that I have open sourced. For this example, we will look at my <code class="literal">consul</code> image. If you want to use my image, you would call it <code class="literal">scottyc/consul</code>. As you can see, the name is different, as it calls the author name <code class="literal">scottyc</code> and then the image name, <code class="literal">consul</code>. Now, you can see the difference in the naming convention between an official image and an authored image.</p><p>Now that we have covered the different images hosted at Docker Hub, we can move on to how images get to Docker Hub. There are two different ways to get images to Docker Hub. Both ways, we need a Docker Hub account, which we will cover in the next section.</p><p>The first way is to build the <a id="id36" class="indexterm"/>image locally and simply use the <code class="literal">docker push</code> command. The second way is using automated builds, which is an awesome functionality that Docker has built into Docker Hub. We will cover this later in much more detail. At a <a id="id37" class="indexterm"/>high level, it is a <strong>CD</strong> (<strong>continuous delivery</strong>) process to build the image based on a Dockerfile that is stored in a GitHub or Bitbucket public repository.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec13"/>Creating a Docker Hub account</h2></div></div></div><p>In this topic, we will <a id="id38" class="indexterm"/>create a Docker Hub account and look at how to log in to the Docker daemon manually (we will cover how to do this with Puppet in the next chapter). So, let's <a id="id39" class="indexterm"/>start. First, we will need to go to Docker Hub (<a class="ulink" href="https://hub.docker.com/">https://hub.docker.com/</a>) and fill out the form on the right-hand side of the page. Just replace <strong>yourusername</strong> with your desired username, <strong>you@youremail.com</strong>, with your e-mail ID, and, of course, enter a secure password:</p><div><img src="img/B05201_02_07.jpg" alt="Creating a Docker Hub account"/></div><p>After that, go to your e-mail ID and confirm your account. This will then redirect you to the Docker login page. Log in and you should see the following web page:</p><div><img src="img/B05201_02_08.jpg" alt="Creating a Docker Hub account"/></div><p>Now that we have an <a id="id40" class="indexterm"/>account, let's log in to our daemon. So, let's use <code class="literal">vagrant ssh</code> back into our Docker vagrant box. We will change to root (<code class="literal">sudo –i</code>) and then enter the <code class="literal">docker login</code> command:</p><div><img src="img/B05201_02_09.jpg" alt="Creating a Docker Hub account"/></div><p>Enter the username that we just created:</p><div><img src="img/B05201_02_10.jpg" alt="Creating a Docker Hub account"/></div><p>Then, enter your password:</p><div><img src="img/B05201_02_11.jpg" alt="Creating a Docker Hub account"/></div><p>After this, enter your <a id="id41" class="indexterm"/>e-mail ID. Once this is done, you should see the following output:</p><div><img src="img/B05201_02_12.jpg" alt="Creating a Docker Hub account"/></div><p>You have now successfully logged in the Docker daemon.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec14"/>Exploring official images</h2></div></div></div><p>In this topic, we <a id="id42" class="indexterm"/>are going to provide a quick overview of how to search for images on Docker Hub. There are two ways to do this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Through the Docker Hub website</li><li class="listitem" style="list-style-type: disc">Through the command line</li></ul></div><p>Let's look at the website first. If you remember, in our golang example we already used the web interface to search for an image. Let's look at another example. In this example, we will look for bitbucket, Atlassian's git server. So, we will go back to Docker Hub (<a class="ulink" href="https://hub.docker.com/">https://hub.docker.com/</a>) and enter <code class="literal">bitbucket</code> in the search field:</p><div><img src="img/B05201_02_13.jpg" alt="Exploring official images"/></div><p>Our search will <a id="id43" class="indexterm"/>return the following output:</p><div><img src="img/B05201_02_14.jpg" alt="Exploring official images"/></div><p>As you can see from the preceding screenshot, we got 43 results. So what should we look for to choose the <a id="id44" class="indexterm"/>right image? We always look for three things, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We check the number of pulls. The more people using an image, the more likely it will run with no issues.</li><li class="listitem" style="list-style-type: disc">We also check Docker's official rating system: how many stars a repository has. Stars are awarded by other members of the community when they like the image, which is very similar to the star system on GitHub.</li><li class="listitem" style="list-style-type: disc">We check whether the repo has a Dockerfile. This gives you peace of mind about how the image is built. You can see all the commands that were run to complete the build.</li></ul></div><p>Using the three metrics, let's pick an image. Looking at the results, <strong>atlassian/bitbucket-server</strong> looks good, with 21 stars and 7.3k pulls. So, let's click on the repo and look for a Dockerfile:</p><div><img src="img/B05201_02_15.jpg" alt="Exploring official images"/></div><p>If we click on the <strong>Dockerfile</strong> tab under the main image title, it takes us to the Dockerfile page. Not every repository has a Dockerfile; however, this does not mean that it's a bad image. This just means <a id="id45" class="indexterm"/>that it will take more testing before you would be able use it in production. Some authors, such as <em>Jess (Jessie Frazelle)</em> from Docker, have their Dockerfiles on their GitHub page. She has awesome images on <a id="id46" class="indexterm"/>Docker Hub and the Dockerfiles can be found at <a class="ulink" href="https://github.com/jfrazelle/dockerfiles">https://github.com/jfrazelle/dockerfiles</a>. Alright, back to our example. As you can see in the following screenshot, there is a Dockerfile:</p><div><img src="img/B05201_02_16.jpg" alt="Exploring official images"/></div><p>So, I think this is the winner!!!!</p><p>Now, let's do the same <a id="id47" class="indexterm"/>search from the command line. In the command line, type <code class="literal">docker search bitbucket</code>, and the search will return the following output:</p><div><img src="img/B05201_02_17.jpg" alt="Exploring official images"/></div><p>As you can see, it <a id="id48" class="indexterm"/>has returned the same information, and the only thing missing is the number of pulls. Again, it looks like we will use <strong>atlassian/bitbucket-server</strong>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Automated builds in Docker Hub</h1></div></div></div><p>In this topic, we <a id="id49" class="indexterm"/>are going to look at how automated builds work at a <a id="id50" class="indexterm"/>high level, and how to publish an image via the push method on Docker Hub.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Automated builds</h2></div></div></div><p>In Docker Hub, we have <a id="id51" class="indexterm"/>two ways to publish images: via a simple push <a id="id52" class="indexterm"/>method or via an automated build. In this topic, we will cover automated builds. First, we will look at the flow of an automated build. In this example, we will be using GitHub, but you can also use Bitbucket. So, the first thing that we need to do is link our Docker Hub account to our GitHub account. This is done by navigating to <strong>Settings</strong> | <strong>Linked Accounts &amp; Services</strong>:</p><div><img src="img/B05201_02_28.jpg" alt="Automated builds"/></div><p>Just follow the prompts to link the accounts.</p><p>Once this is <a id="id53" class="indexterm"/>completed, let's go to our GitHub account and create a repo. I <a id="id54" class="indexterm"/>am going to use the one that I have already set up:</p><div><img src="img/B05201_02_29.jpg" alt="Automated builds"/></div><p>As you can see in the preceding screenshot, the repo contains a Dockerfile. Now, let's looks at the same repo <a id="id55" class="indexterm"/>except Docker Hub:</p><div><img src="img/B05201_02_30.jpg" alt="Automated builds"/></div><p>After this, we will <a id="id56" class="indexterm"/>look at the <strong>Build Details</strong> tab:</p><div><img src="img/B05201_02_31.jpg" alt="Automated builds"/></div><p>So, how does that build automate ? Well, it is quite simple. Every time we check in a change to the GitHub repo, it will trigger web hooks at Docker Hub. When Docker Hub receives the trigger, it <a id="id57" class="indexterm"/>will grab the Dockerfile and build the image. Docker Hub will <a id="id58" class="indexterm"/>take care of things such as version numbers for us with every build. So, at a high level, this is how automated builds work.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Pushing to Docker Hub</h2></div></div></div><p>This is a quite simple <a id="id59" class="indexterm"/>way to get an image to Docker Hub, but the downside is that there is no automated build process and the Dockerfile does not get placed <a id="id60" class="indexterm"/>in the Docker Hub repo automatically. So, in this example, we will assume that we have created an image called <code class="literal">scottyc/super_app</code>. To push this to Docker Hub, we simply type <code class="literal">docker push scottyc/super_app</code> in the terminal. Note that the Docker daemon needs to be logged in at the time of the push.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>Working with official images</h1></div></div></div><p>Now that we <a id="id61" class="indexterm"/>know how Docker Hub serves images to us, let's look at how to integrate them into our code via three methods. The first will be a Dockerfile, the second will be in the <code class="literal">docker-compose.yaml</code> file, and the last will be straight into a Puppet manifest.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Dockerfiles</h2></div></div></div><p>In this topic, we will <a id="id62" class="indexterm"/>look at using nginx in a basic Dockerfile. In a Dockerfile, we need to add a few things. The first is the image that we are basing our application <a id="id63" class="indexterm"/>on; for us it will be nginx. The second is a maintainer. It should look like as shown in the following screenshot:</p><div><img src="img/B05201_02_18.jpg" alt="Dockerfiles"/></div><p>As the base nginx image has already got port 80 and 443 exposed, we will not need that configuration for our Dockerfile. The next thing we will add is a simple <code class="literal">run</code> command to update the packages in the container. As its base OS is Debian, we will add the command shown on line <strong>5</strong> in the following screenshot:</p><div><img src="img/B05201_02_19.jpg" alt="Dockerfiles"/></div><p>As we are building a simple application, this is all that we are going to add to our Dockerfile. There are heaps of configurations that can be done with a Dockerfile.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p>If you would like to <a id="id64" class="indexterm"/>read about Dockerfiles, you can do so at <a class="ulink" href="https://docs.docker.com/engine/reference/builder/">https://docs.docker.com/engine/reference/builder/</a>.</p></div></div><p>Now, let's build our image. You will note that <code class="literal">server.yaml</code> in our Vagrant repo already has port <code class="literal">80</code> forwarding to port <code class="literal">8080</code>, so we won't need to make any changes there. Copy the Dockerfile that we created into the root of your Vagrant repo. Then, let's start our vagrant box with vagrant up from our terminal. Then, use <code class="literal">vagrant ssh</code> once the box is up. Let's change to root (<code class="literal">sudo -i</code>). Then, if we change directories to <code class="literal">/vagrant</code>, we should see our Dockerfile. Now, let's build our image with the command, <code class="literal">docker build -t YOUR AUTHOR NAME/nginx .</code> (note that <code class="literal">.</code> is part of the command). You will get the following output on your terminal:</p><div><img src="img/B05201_02_20.jpg" alt="Dockerfiles"/></div><p>Next, let's test our image <a id="id65" class="indexterm"/>and spin up a container with the following command:</p><div><pre class="programlisting">
<strong>docker run -d -p 80:80 --name=nginx YOUR AUTHOR NAME/nginx</strong>
</pre></div><p>If it was successful, we <a id="id66" class="indexterm"/>should get the nginx default page in your browser at <code class="literal">127.0.0.1:8080</code>, as follows:</p><div><img src="img/B05201_02_21.jpg" alt="Dockerfiles"/></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Docker Compose</h2></div></div></div><p>Now, we are going to <a id="id67" class="indexterm"/>deploy the same nginx image with Docker <a id="id68" class="indexterm"/>Compose. We are going to run Docker Compose at a high level in this topic just to get an understanding of the technology. We will look at it in depth in another chapter of this book. The first thing we need to do is install Docker Compose.</p><div><div><h3 class="title"><a id="tip02"/>Tip</h3><p>At the time of writing this book, my pull request is still open, so we will have to use my branch of Gareth's module.</p></div></div><p>To do this, let's modify our puppetfile in the Vagrant repo with the commands shown in the following screenshot:</p><div><img src="img/B05201_02_22.jpg" alt="Docker Compose"/></div><p>So, in the Puppetfile we added a new module dependency, <code class="literal">stankevich/python</code>, as Docker Compose is written in Python. We also updated our <code class="literal">epel</code> module to use the latest. Just to get a fresh working environment, we will run the command, <code class="literal">vagrant destroy &amp;&amp; vagrant up</code>, in our terminal. Once the box is up, we will use <code class="literal">vagrant ssh</code> and then change to root (<code class="literal">sudo -i</code>). We will then change the directory to <code class="literal">/vagrant</code> and type <code class="literal">docker-compose</code>.</p><p>If the build was <a id="id69" class="indexterm"/>successful, we will see the following <a id="id70" class="indexterm"/>screen:</p><div><img src="img/B05201_02_23.jpg" alt="Docker Compose"/></div><p>Now, let's create <code class="literal">docker-compose.yaml</code>:</p><div><img src="img/B05201_02_24.jpg" alt="Docker Compose"/></div><p>As you can see, we used the official image, gave the container a name <code class="literal">nginx</code>, and exposed ports <strong>80:80</strong> again to be able to hit the nginx page. So, if we copy our <code class="literal">docker-compose.yml</code> file to the root of the Vagrant directory, log in to our vagrant box, and change the <a id="id71" class="indexterm"/>directory to root (<code class="literal">vagrant ssh</code>, then <code class="literal">sudo -i</code>), we will be <a id="id72" class="indexterm"/>able to change the directory to <code class="literal">/vagrant</code> again. Now, run <code class="literal">docker-compose up -d</code>. We will get the following output after running it:</p><div><img src="img/B05201_02_25.jpg" alt="Docker Compose"/></div><p>We can then go to our web browser and visit the nginx page at <code class="literal">127.0.0.1:8080</code>:</p><div><img src="img/B05201_02_21.jpg" alt="Docker Compose"/></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>If you want to read <a id="id73" class="indexterm"/>more about Docker Compose, go to <a class="ulink" href="https://docs.docker.com/compose/">https://docs.docker.com/compose/</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Puppet manifest</h2></div></div></div><p>In this section, we are <a id="id74" class="indexterm"/>going to build the same ngnix container with a simple Puppet manifest. This is just a proof of concept. In the next chapter, we <a id="id75" class="indexterm"/>will write a full module. This is just to give us a foundation and understanding of how Puppet interacts with Docker. So, in our Vagrant repo, let's modify <code class="literal">manifest/default.pp</code>. The file should contain the following code:</p><div><img src="img/B05201_02_26.jpg" alt="Puppet manifest"/></div><p>We will then open our terminal at the root of our Vagrant repo and run <code class="literal">vagrant provision</code>. Note that you should have no other containers running at this time. You will see the following <a id="id76" class="indexterm"/>output, which shows that Puppet provisioned a Docker <a id="id77" class="indexterm"/>container called nginx:</p><div><img src="img/B05201_02_27.jpg" alt="Puppet manifest"/></div><p>We can then check our browser again at <code class="literal">127.0.0.1:8080</code>. We will get the nginx page again:</p><div><img src="img/B05201_02_21.jpg" alt="Puppet manifest"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>Summary</h1></div></div></div><p>In this chapter, we covered a lot about the Docker Hub ecosystem. We discussed what official images are, how automated builds work, and of course, how to work with images in three different ways. After working through this chapter, we now have the tools in our tool belt to build our first application with Puppet.</p><p>In the next chapter, we will write our first Puppet module to create a Docker container and we will look at writing rspec-puppet unit tests to make sure that our module does what it's meant to do.</p></div></body></html>