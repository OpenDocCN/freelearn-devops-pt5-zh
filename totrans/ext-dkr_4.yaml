- en: Chapter 4. Network Plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to be looking at the next type of plugin: networking.
    We will discuss how to make use of the new networking tools introduced with Docker
    1.9, along with third-party tools that add even more functionality to the already
    powerful built-in tools. The two main tools that we are going to look at are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Overlay Network**: [https://docs.docker.com/engine/userguide/networking/dockernetworks/](https://docs.docker.com/engine/userguide/networking/dockernetworks)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weave**: [https://weave.works/](https://weave.works)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This chapter assumes that you are using Docker 1.10+, some commands may not
    work in the previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: Docker networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to go into detail about Networking in Docker, I should mention
    that we have managed to make it to the fourth chapter in the book without having
    to really think about networking, this is because, by default, Docker creates
    a network bridge between the containers and your host machine's network interface.
    This is Docker networking at its most basic form.
  prefs: []
  type: TYPE_NORMAL
- en: Like basic storage, this limits you to bring up your containers on a single
    host even when using a clustering tool such as Docker Swarm, as you may have already
    noticed in [Chapter 2](ch02.html "Chapter 2. Introducing First-party Tools"),
    *Introducing First-party Tools*, when we were bringing up our WordPress installation,
    the web and database containers where launched on a single host within the cluster.
    If we were to try and bind each of the two containers to different host, they
    would not be able to talk to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, Docker has you covered and provides its own multi-host networking layer
    to use with Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-host networking with overlays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker released its production-ready multi-host overlay networking functionality
    in Docker 1.9\. Before this release, the functionality was classed as experimental.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An overlay network is a computer network that is built on top of another network.
    Nodes in the overlay network can be thought of as being connected by virtual or
    logical links, each of which corresponds to a path, perhaps through many physical
    links, in the underlying network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://en.wikipedia.org/wiki/Overlay_network](https://en.wikipedia.org/wiki/Overlay_ne)'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Docker terms, it allows containers on one Docker host to talk directly to
    containers on another Docker host as if they were on the same host, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Multi-host networking with overlays](img/B05468_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see from the preceding diagram, there are some prerequisites. Firstly,
    you must be running a Docker Swarm cluster. Here we have a Docker Swarm cluster
    made up of two nodes and a master, all of which have the overlay network configured.
    You will also need a Service Discovery service, where it can be accessed by the
    Docker Swarm cluster. For this, you can use the following applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Consul**: [https://www.consul.io/](https://www.consul.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Etcd**: [https://coreos.com/etcd/](https://coreos.com/etcd/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ZooKeeper**: [http://zookeeper.apache.org/](http://zookeeper.apache.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of this chapter, we will be using Consul by HashiCorp ([https://hashicorp.com/](https://hashicorp.com/))
    and we will also be launching our cluster using Docker Machine in DigitalOcean.
  prefs: []
  type: TYPE_NORMAL
- en: Launching Discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Back in [Chapter 2](ch02.html "Chapter 2. Introducing First-party Tools"), *Introducing
    First-party Tools*, we launched our Docker Swarm cluster using a one-off token
    from the Docker hub. One of the requirements of multi-host networking is a persistent
    key/value store so that we have permanent and accessible place to store values
    about our cluster, we will be using Consul to provide this in our example cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Consul is an open source tool written by HashiCorp for discovering and configuring
    services in an infrastructure. It provides several key features, including Service
    Discovery, health checking, and a key/value store, all while being multi-datacenter
    aware.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch the Docker host, which will run Consul, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You may notice that we have added an additional line to the `docker-machine`
    command, this launches the DigitalOcean Droplet with private networking enabled.
    Once the Docker host has launched, we can launch the Consul service by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will download a copy of my Consul container image, also now there is an
    official image that can be found at [https://hub.docker.com/_/consul/](https://hub.docker.com/_/consul/);
    however, this image as it is new may not work with the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this is the only command we need to run on this host, we are not configuring
    our local Docker client to use the host; instead, we are passing the configuration
    over at runtime using `$(docker-machine config service-discovery)`. To check whether
    everything is running as expected, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you should see a single container running something similar to the following
    terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching Discovery](img/B05468_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we progress further, it should be noted that launching Consul with the
    `-bootstrap-expect 1` flag should never be attempted in production. You should
    consider bringing multiple Consul hosts. For more information on a highly available
    Consul cluster, refer to the following URL for details on how to configure a full
    Consul cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.consul.io/docs/guides/bootstrapping.html](https://www.consul.io/docs/guides/bootstrapping.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also get an idea of what information Docker will be storing in Consul
    by opening the web interface, to do this type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an almost empty Consul view, as shown in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Launching Discovery](img/B05468_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will come back to the web interface once we have launched the Docker Swarm
    cluster. Now we have the service discover container running and accessible, it's
    time to start launching the rest of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Readying the Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start to launch the Docker Swarm cluster, first of all the Swarm master.
    We will call this `chapter04-00`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the command is very similar to the one used in [Chapter 2](ch02.html
    "Chapter 2. Introducing First-party Tools"), *Introducing First-party Tools*;
    however, we are supplying details of our Consul installation. We are doing this
    by passing in the IP address of the `service-discovery` host using the `docker-machine
    ip` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the Swarm master is booted, we are going to launch two Swarm nodes using
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'For the second node, we are going to use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our master and two nodes up and running, let''s switch to
    the environment and make sure that the cluster is showing the correct number of
    hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following screenshot when running `docker
    info`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Readying the Swarm](img/B05468_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, we now have our cluster launched, and everything is talking to each other.
    We will now be able to create our overlay network.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the overlay network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For testing purpose, we are going to be creating a very basic network and launching
    a very basic container. The following command will create the overlay network,
    and thanks to the service-discovery provided by Consul, the network settings will
    be distributed to each node within our Docker Swarm cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, there you have it, we have created an overlay network called `chapter04-overlay-network`
    with a subnet of `10.0.9.0/24` on our cluster. To make sure that everything is
    OK, you can run the following commands to list the networks configured within
    the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also check on the individual nodes by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '![Adding the overlay network](img/B05468_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, each node has its host and bridge networks available, meaning
    that you don't have to use the overlay network if you don't want to; however,
    we do so that its time to launch a container and configure it to use our newly
    added network.
  prefs: []
  type: TYPE_NORMAL
- en: Using the overlay network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start with, we will be launching a container that runs NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are configuring our container to use `chapter04-overlay-network`
    by passing the `--net` flag. We are also making sure that the container is launched
    on the `chapter04-01` node. Next up, let's see if we can view the content being
    served by our NGINX container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let''s launch a container on our second node, `chapter04-02`, and
    run `wget` to fetch the page being served by NGINX:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went as planned, you will see `Hello from NGINX` returned by
    the command. We can also ping the NGINX container from the second node by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see an IP address within the 10.0.9.0/24 subnet returned, as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the overlay network](img/B05468_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you want to take a look at the network that has been configured on the `chapter04-web`
    container, you can run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following terminal output returned:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the overlay network](img/B05468_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, you can access the container in your browser by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The page will look something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the overlay network](img/B05468_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: While the page itself isn't much to look at, there are actually some quite clever
    things going on in the background that you may not have noticed, the biggest of
    which is that we haven't had to link our containers together. In the previous
    chapters, we had used the link flag when launching multiple containers to link
    them together. Now we are launching our containers in the same Overlay Network,
    Docker assumes that all of the containers within this network will be able to
    talk each other, and it handles the linking of the containers automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Docker has also configured a gateway for the containers in order to be able
    to route traffic outside of our Overlay Network by default. If you wanted to create
    an internal only networking, then you could add the `--internal` flag.
  prefs: []
  type: TYPE_NORMAL
- en: Back to Consul
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Don''t forget that while we have been creating the networks and launching our
    containers, the service discovery container has been running in the background.
    Going back to the Consul web interface, you should notice that under the **Key/Value**
    option, you will see a list of the nodes within our Docker Swarm cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back to Consul](img/B05468_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Clicking around, you should also see other values, such as the networking ones,
    that are being shared within the Docker Swarm cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Back to Consul](img/B05468_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we tear down our Docker Swarm cluster, let's look at launching our WordPress
    stack using Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Composing multi-host networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in the previous chapters, we are going to launch our trusty WordPress installation.
    We are going to make it a little interesting by:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an external network called `wpoutside`. This network will be able to
    get external access, our webserver will be launched over here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an internal network called `wpinside`. This network will not be able
    to get any external access, on containers on the same network will be able to
    access, we will be adding both web server and database containers to this network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Launching our web server container one node and the database container on our
    second node.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we launch our containers, we should terminate the `chapter04-web` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create two overlay networks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are giving the networks different subnets, and for `wpinside`,
    we are passing the `--internal` flag, meaning that the network will not have an
    external gateway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at our `docker-compose.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I have highlighted the changes made in the file since the previous
    chapter. The interesting thing to note is that while it is possible to define
    your network within the `docker-compose.yml` file, you will get a lot more control
    by setting up the network using the `docker network create` command. To do this,
    we need to tell Docker Compose to use the externally defined networks for the
    project. We are also using labels to bind the containers to a host in our Docker
    Swarm cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the two overlay networks created, you can launch the WordPress
    stack by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You can check everything launched as expected by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that the containers have launched on different hosts, run the
    following command and check the last column:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To see what IP addresses are assigned to the containers, run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see two IP addresses for `my-wordpress-app` and a single for `my-wordpress-database`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing multi-host networks](img/B05468_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before we log in to WordPress, we can try some ping tests. First, we will run
    the tests on your `my-wordpress-app` container by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For the first command, you will see Google''s external IP address returned.
    For the second, you will get the IP of your `my-wordpress-database` container,
    which will be on the `10.0.11.0/24` subnet we defined for the `wpinside` overlay
    network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing multi-host networks](img/B05468_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Trying similar commands on `my-wordpress-database` should give you different
    results, try running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, pinging `my-wordpress-app` works fine; however, when you try
    and ping Google, you get an error saying something like `Network is unreachable`
    or some another error. This is exactly what we would expect to see as `my-wordpress-database`
    has no external network access and therefore it cannot route to `www.google.com`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Composing multi-host networks](img/B05468_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, if you would like to access WordPress, you can type in either of the
    following commands. First of all, we need to confirm which host the `my-wordpress-app`
    container is launched on. To confirm the host, run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, depending on which host, run one of the following three commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Your browser will open the now familiar WordPress installation page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on further, you should tear down your Docker Swarm cluster. To
    do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Summing up multi-host networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although overlay networks were classed as production-ready in Docker version
    1.9, with the advancements in Docker version 1.10 and the new Docker Compose v2
    file format, Docker networking has really come into its own.
  prefs: []
  type: TYPE_NORMAL
- en: While the overlay network functionality is built into Docker and Swarm, as you
    have seen in the examples we have worked through, it is extremely powerful. When
    used in conjunction with third-party volume plugins that we covered in [Chapter
    3](ch03.html "Chapter 3. Volume Plugins"), *Volume Plugins*, and Docker Swarm,
    we can start to build highly available deployments.
  prefs: []
  type: TYPE_NORMAL
- en: Weaving a network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next up, we are going to take a look at Weave Net and Scope by Weaveworks. This
    is one of the original Docker networking tools, and at its core, it is a mature
    software-defined networking service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Weave Net is described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Weave Net creates a container SDN that can run across any mixture of public
    and private cloud, virtual machines and bare metal. The container SDN can carry
    any layer 2 and layer 3 traffic, including multicast. If you can run it over Ethernet,
    you can run it on Weave Net."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'In fact, there are two drivers provided by Weave, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Weave Mesh is a local scope driver that operates without the need for a cluster
    store. It can be used to create networks that span non-clustered machines. With
    this, you get a single network called Weave, which spans all of the machines you
    have Weave launched on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Weave, like Docker's own overlay driver, is a global scope driver. This means
    that it can be used with Docker Swarm and Docker Compose, because of this, you
    will need to launch a cluster store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First of all, let's look at the Weave driver and how to use it with Docker Swarm
    and then we will take a look at using the Weavemesh driver.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a Cluster again
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like Docker multi-host networking, we will need to launch a service discovery
    instance and our Swarm cluster. Let''s launch the service discovery host with
    Docker Machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we don''t need to enable the Consul web interface, so run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now launch the Docker Swarm cluster, first the master:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will launch our first node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will launch the second node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'To check whether everything is working as expected, run the following commands
    to switch our local Docker client to connect to the Swarm cluster and also check
    whether the three nodes are visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Installing and configuring Weave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our cluster up and running, we can install and configure Weave.
    Installing Weave is simple, all you have to do is download the binary and give
    it the correct permissions. Let''s do this on the Swarm master using `docker-machine
    ssh` to connect to the host and run the `install` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we start Weave, again using `docker-machine ssh`, we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have notice that Weave deployed three containers from the Docker Hub,
    they are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: weaveworks/weaveexec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: weaveworks/weave
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: weaveworks/plugin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we are telling Weave to expect three peers to join the cluster by passing
    the `--init-peer-count 3` flag, that's pretty much all we have to do to configure
    Weave on our first cluster node.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to install Weave onto our other two cluster nodes, again using
    the `docker-machine ssh` command run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have Weave up and running on the node, we need to tell it to connect
    to the Weave installation running on the Swarm master. To do this, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then on our last cluster node, we will run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Once all three nodes in the Swarm cluster have Weave installed and configured,
    we will run the following command to ensure that all three nodes are talking to
    each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The command should return confirmation that there are three peers with six
    established connections along with other information about the installation, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and configuring Weave](img/B05468_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have confirmation that everything is working as expected, we will
    list the networks in Docker using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the following terminal session, you should see that there is a `weavemesh`
    network called `weave` on each of the nodes within the cluster; we will discuss
    more about that later:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Installing and configuring Weave](img/B05468_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Docker Compose and Weave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So, let''s launch our WordPress installation. The Docker Compose file looks
    a little different from the overlay network one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'I have highlighted a few changes from the Overlay Docker Compose file: first
    off, we will define a hostname and provide a DNS server and search domain. To
    get the right values for the `dns` and `dns_search` keys, you can run the following
    command to have Weave let you know what it has configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, in my case, it returned `172.17.0.1` and `weave.local`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Compose and Weave](img/B05468_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also, for the MySQL connection from the WordPress container to the Database
    one, we are using the internal DNS name as well.
  prefs: []
  type: TYPE_NORMAL
- en: We are also letting Docker Compose create a network for us using the Weave driver,
    this will add a single network named after the project. Docker Compose gets the
    project name from the folder our Docker Compose file is, in my case, it's a folder
    called `wordpress`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To launch your containers and check whether they are running as expected, run
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something similar to the following terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Compose and Weave](img/B05468_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you really want to, you can access your WordPress installation by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'There are some things happening in the background that Docker''s multi-host
    networking doesn''t give you, such as internal DNS. Weave has its own internal
    DNS system that you can register your containers with, as you saw in the Docker
    Compose file that we provided details for records for both containers. Run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'It will show you all the DNS records that Weave has configured. In my case,
    it looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Docker Compose and Weave](img/B05468_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Weave Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we have our three-node Swarm cluster up and running, let's quickly install
    Scope. Scope is a tool for visualizing your Containers and host. We will just
    be installing it to run locally, but Weave Works will be offering a cloud-based
    service, which can be found at [http://scope.weave.works/](http://scope.weave.works/)
    (at the time of writing this book, it was in private beta).
  prefs: []
  type: TYPE_NORMAL
- en: Similar to the way we installed Weave Net, we will be using the `docker-machine
    ssh` command to download the binary and launch and configure the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write the code on the Swarm master first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will write the code for remaining two nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see on the two remaining nodes, we are telling Scope to connect to
    the Scope instance running on the Swarm master.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Scope is installed, open it in your browser by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: When your browser opens, you will be presented with a visual representation
    of your Swarm cluster, and the containers that are running.
  prefs: []
  type: TYPE_NORMAL
- en: 'I am not going to go into any more detail on Scope here, as at the moment,
    it doesn''t have much to do with networking, have a look around to start seeing
    more information on your cluster and how it all hangs together. Mine looked similar
    to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Weave Scope](img/B05468_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Calling off the Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you can see, while Weave is quite a powerful SDN, it is straightforward to
    configure. However, replicating the multi-host networking Docker provides is only
    one of its tricks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s shut down our Swarm cluster and terminate the hosts before we start
    to look at the Weavemesh network driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Before you move on, log in to your DigitalOcean control panel and make sure
    that you don't have any machines labelled with `chapter04` running, remember that
    you will be charged per hour whether you are using them or not.
  prefs: []
  type: TYPE_NORMAL
- en: Weavemesh Driver
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have looked at how Weave Net can by used alongside a Docker Swarm cluster
    to create multi-host networking, now let's take a look at the second Weave network
    driver, Weavemesh. As you may recall, when we first installed Weave Net, a network
    called "weave" was automatically create using the "weavemesh" driver on each node
    within our cluster.
  prefs: []
  type: TYPE_NORMAL
- en: This time, let's bring up two independent Docker hosts DigitalOcean using Docker
    Machine. To make it interesting, we will launch one host in London and the other
    in New York City. As these are going to be acting as individual hosts, we do not
    need to launch a key/value store, or configure Docker Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, type the following command to launch a host in London host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Then, the following command is to launch another host is New York City.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our two Docker hosts up and running, let''s install and configure
    Weave:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this time we are telling Weave to launch with a password. This
    flag will enable encryption between the networking layer on our two hosts. Now
    that we have the London host configured, let''s do the one in New York City and
    then get it talking to the host in London:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have Weave configured on our two hosts, we can check the status
    of Weave by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following terminal output, encryption is enabled and
    we have two peers within our Weave network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Weavemesh Driver](img/B05468_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s take a look at Weave''s party trick. We will keep it basic to start
    with by launching our NGINX container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can check whether the container is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s also check whether it''s responding on port 80:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s do a ping test:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Your terminal session should look something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Weavemesh Driver](img/B05468_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the surface, this test doesn't look like much; however, if you look closely
    at the commands we used, you will see just how powerful the weavemesh driver is.
  prefs: []
  type: TYPE_NORMAL
- en: First of all, when we launched our NGINX container on the New York City Docker
    host, we did not publish any ports, meaning that port 80 was only available on
    the weave network that we attached it to.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, when we ran the check on port 80 and did the ping test, we did that
    from our Docker host in London. We temporally launched a basic container, attached
    it to the `weave` network and configured it use Weave DNS service so that it could
    resolve the `nginx.weave.local` domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do our tests again, but this time, using a local virtual machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, install Weave as we did on our other two Docker hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Then run the tests again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the ping test, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it worked!
  prefs: []
  type: TYPE_NORMAL
- en: '![Weavemesh Driver](img/B05468_04_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now have three Docker hosts in our Weavemesh network, all of which can talk
    to each other. To prove this, we are going to do one final test. Let's launch
    a container on our local Docker host and try the tests from the New York City
    host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a NGINX container called `vm.weave.local` on our local Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Then try connecting to port 80 and pinging the new container from the Docker
    host in New York City:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'My terminal session looked similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Weavemesh Driver](img/B05468_04_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we don't have the constants of the Docker Swarm cluster, we can also
    start to do some tasks that are only available outside of Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, you attach container to the Weave network after they have been
    launched, let''s launch an NGINX container called `lonely` on our London Docker
    host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s connect to the London Docker host and attached the container to
    the weave network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run the command, it will return an IP address. This will be the new
    IP address of our container; in my case, it is 10.40.0.0\. Let''s run our test
    from both the New York City and Local Docker hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Your terminal session should look similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Weavemesh Driver](img/B05468_04_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that we have our container on the network, we can manually add a DNS for
    the host by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we can now access port 80 using [http://lonely.weave.local](http://lonely.weave.local)
    from our New York City Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The only downside is that there is no easy way of adding the DNS resolution
    to the host we have attached to the "weave" network.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are finished with our Docker hosts, let''s terminate them so that
    we don''t incur unnecessary cost:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: Again, remember to check your DigitalOcean control panel to ensure that your
    hosts have been correctly terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing Weave
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have seen and I have already mentioned, Weave is an incredibly powerful
    software-defined network, which is really easy to configure. Speaking from experience,
    this is a difficult combination to pull off, as most SDN solutions are incredibly
    complex to install, configure, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: We have only touched on what is possible with "weave" and "weavemesh" drivers.
    For a full feature list, along with instructions on some most of the advanced
    use cases, refer to [http://docs.weave.works/weave/latest_release/features.html](http://docs.weave.works/weave/latest_release/features.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at three different network drivers, all three
    of which add quite powerful functionality to your basic Docker installation. These,
    along with the volume drivers, really extend Docker to the point where you can
    run large fault-tolerant clusters of containers.
  prefs: []
  type: TYPE_NORMAL
- en: Personally, when I first installed Weave and started to communicate with containers
    across different Docker hosts in different hosting providers so easily, I was
    absolutely blown away.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how you should approach to creating your
    own extension.
  prefs: []
  type: TYPE_NORMAL
