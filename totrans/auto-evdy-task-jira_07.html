<html><head></head><body>
		<div><h1 id="_idParaDest-116"><em class="italic"><a id="_idTextAnchor095"/>Chapter 5</em>: Working with External Systems</h1>
			<p>Applications rarely exist in isolation. They tend to specialize in doing one thing well, but to be truly useful, they need to co-exist with other applications within your organization.</p>
			<p>This is especially true for Jira, and this can be seen in the Atlassian Marketplace where, among the large number of available apps, hundreds of them exist solely to integrate Jira with other applications and systems.</p>
			<p>Even with the number of integrations with various applications available as plugins to Jira, there will often be occasions where the integration you need is not catered for, or where an existing integration does not quite meet your specific requirements.</p>
			<p>In recent years, many applications and systems have embraced JSON-based REST APIs to enable third-party systems to integrate with them, and automation rules in Jira provide us with the components necessary to take advantage of this.</p>
			<p>In this chapter, we will learn how we can send requests to external systems using automation rules and how to work with the data that is returned from these requests. In addition, we will explore how we can use automation rules to set up incoming webhooks that can listen for requests from external systems to trigger a rule.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li>How to send requests to external systems</li>
				<li>Working with data returned from requests</li>
				<li>How to receive requests using incoming webhooks</li>
				<li>Working with data in incoming webhooks</li>
			</ul>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor096"/>Technical requirements</h1>
			<p>The requirements for this chapter are as follows:</p>
			<ul>
				<li><strong class="bold">Jira Cloud environment</strong>: If you don't already have access to Jira, you can create a free Jira Cloud account at <a href="https://www.atlassian.com/software/jira/free">https://www.atlassian.com/software/jira/free</a> and ensure that you have both Jira Software and Jira Service Management selected.</li>
				<li><strong class="bold">Jira Server environment</strong>: If you are using Jira Server (available from <a href="https://www.atlassian.com/software/jira/download">https://www.atlassian.com/software/jira/download</a>), ensure you have licenses for both Jira Software and Jira Service Management. In addition, you will also need to ensure that you install the <em class="italic">Automation for Jira</em> app available from the Atlassian Marketplace.</li>
				<li><strong class="bold">Confluence Cloud environment</strong>: If you don't already have access to Confluence, you can use the application switcher menu in your Jira Cloud instance to set up a Confluence site in your cloud account. If you don't have a Jira Cloud account, you can set up a free Confluence Cloud account at <a href="https://www.atlassian.com/software/confluence/free">https://www.atlassian.com/software/confluence/free</a>.</li>
				<li><strong class="bold">Confluence Server environment</strong>: If you are using Jira Server, you can either download and install Confluence Server from <a href="https://www.atlassian.com/software/confluence/download">https://www.atlassian.com/software/confluence/download</a> or you can create and use a Confluence Cloud account.</li>
			</ul>
			<p>In both instances, you will need to have at least <strong class="bold">Project Administrator</strong> access to a Service Management project and a Scrum Software project to be able to follow the examples in this chapter. For the examples in this chapter, we have used the <em class="italic">IT Service Management project template</em> to create the Service Management project and the <em class="italic">Scrum Software project template</em> to create the Software project.</p>
			<p>You can download the latest code samples for this chapter from this book's official GitHub repository at <a href="https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira">https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira</a>. The Code in Action videos for this chapter are available at <a href="https://bit.ly/2LJAJvN">https://bit.ly/2LJAJvN</a>.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor097"/>How to send requests to external systems</h1>
			<p>The ability to <a id="_idIndexMarker234"/>send requests to external systems from your automation<a id="_idIndexMarker235"/> rules opens up a whole new realm of extremely powerful possibilities. This<a id="_idIndexMarker236"/> functionality can be used to send notifications, or issue data or any custom data to any application or system that accepts web requests over HTTP or HTTPS. For example, you could use this functionality to kick off a build process in a build tool such as Bamboo or Jenkins, or to initiate a password change in a centralized user directory <a id="_idIndexMarker237"/>system if it supports this.</p>
			<p>In this section, we will look at the <strong class="bold">Send web request</strong> component and how to use it in automation rules to <a id="_idIndexMarker238"/>send requests to external systems. We'll begin by taking a look at the various configuration options available in the action.</p>
			<p>In the following screenshot, we can <a id="_idIndexMarker239"/>see the configuration options for the <strong class="bold">Send web request</strong> action:</p>
			<div><div><img src="img/B16551_Figure_5.1.jpg" alt="Figure 5.1 – Configuring the Send web request action&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.1 – Configuring the Send web request action</p>
			<p>Let's<a id="_idIndexMarker240"/> take a look at <a id="_idIndexMarker241"/>each field in the configuration screen and<a id="_idIndexMarker242"/> how we can make use of it:</p>
			<ol>
				<li><code>urlEncode</code> to ensure the smart <a id="_idIndexMarker246"/>value is properly encoded. For example, you should insert the issue key in the field as <code>{{issue.key.urlEncode}}</code>.</p></li>
				<li>The <strong class="bold">Headers</strong> field is where you add any HTTP request headers required by the external system you're going to connect to, such as an <strong class="bold">Authorization</strong> header, which allows you to submit credentials or authorization tokens to the remote system, or the <strong class="bold">Content-Type</strong> header, which informs the remote system of the nature of the data you will be sending. We'll be making use of both of these headers in our example when we publish release notes to Confluence.<p class="callout-heading">Tip</p><p class="callout">Header names are generally case-insensitive. However, you should always ensure that you use the case defined in the official specifications to avoid any unexpected results. Wikipedia maintains a handy list of the standard request headers, complete with examples of accepted input for each header, at <a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>.</p><p>You can add as many HTTP request headers as you need by clicking on the <strong class="bold">Add</strong> link below the <strong class="bold">Name</strong> field. If you need to remove a header, you can do so by using the trash can icon to the right of the <strong class="bold">Value</strong> field.</p></li>
				<li>The <strong class="bold">HTTP method</strong> field allows you to select the correct method required by the external resource to perform the selected operation. The <strong class="bold">Send web request</strong> action supports the following standard HTTP methods:<p><strong class="bold">GET</strong>: Generally used to retrieve a resource from the external system.</p><p><strong class="bold">POST</strong>: Generally used to create a resource in the external system using the data located in the request body.</p><p><strong class="bold">PUT</strong>: Generally<a id="_idIndexMarker247"/> used to replace a resource or create it if it <a id="_idIndexMarker248"/>does not exist, with the resource data located in the request body.</p><p><strong class="bold">PATCH</strong>: Generally used to update a resource, with the updated data located in the request body.</p><p><strong class="bold">DELETE</strong>: Generally used to<a id="_idIndexMarker249"/> delete a resource from the external system.</p></li>
				<li><code>Get issue</code> at the following link: <a href="https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get">https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get</a>.</p><p><strong class="bold">Custom data</strong>: Selecting this option will cause the <strong class="bold">Custom data</strong> field (6) to be shown. This option is usually needed when using the <strong class="bold">POST</strong>, <strong class="bold">PUT</strong>, or <strong class="bold">PATCH</strong> methods and the external system is not expecting data in the Jira issue format.</p></li>
				<li>The <code>{{webhookResponse}}</code> smart value field. We will explore this in more detail in the next section, <em class="italic">Working with data returned from requests</em>.</li>
				<li><code>{{issue.description.abbreviate(255).jsonEncode}}</code> to ensure that the content of the description field is properly encoded.</p><p class="callout-heading">Tip</p><p class="callout">Always make sure when sending custom data that you use the <strong class="bold">Headers</strong> field to specify the correct content type of your data to the external system with the <em class="italic">Content-Type</em> header name. For example, if you're sending JSON data, set <em class="italic">Content-Type</em> to <em class="italic">application/json</em>, or to <em class="italic">application/xml</em> for XML data.</p></li>
				<li>Once you've configured your web request with the correct URL, headers, method, and optional data, you should always test that the request generated, and response received, are what you're expecting.<p>You can do this by expanding the <strong class="bold">Validate your webhook configuration</strong> disclosure and clicking the <strong class="bold">Validate</strong> link. Supplying an optional issue key will ensure that any smart values are substituted during the validation process.</p><p>When you click the <strong class="bold">Validate</strong> link, a request with your configured options and data will be generated and sent to the external system and the response received will be captured and presented back to you, similar to the following screenshot:</p></li>
			</ol>
			<div><div><img src="img/B16551_Figure_5.2.jpg" alt="Figure 5.2 – Validating a web request configuration&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.2 – Validating a web request configuration</p>
			<p>As you can see, validating<a id="_idIndexMarker253"/> the request will return the response received from the external system, as well as the request that was generated <a id="_idIndexMarker254"/>and sent to the external system. Expanding the <strong class="bold">Payload</strong> disclosures will reveal the actual data received <a id="_idIndexMarker255"/>and sent by the web request, allowing you to ensure that the data in both directions is what you expected to see.</p>
			<p>Now that we've learned about the various configuration options for sending a web request, let's look at using these in an automation rule.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor098"/>Creating a rule to publish release notes to Confluence</h2>
			<p>In <a href="B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 4</em></a>, <em class="italic">Sending Automated Notifications</em>, we <a id="_idIndexMarker256"/>showed you how to create a rule to send an email notification to various stakeholders when a software version is released in Jira.</p>
			<p>We are going to revisit that rule in this<a id="_idIndexMarker257"/> example. However, instead of sending an email notification when a version is released, we will instead publish a page to Confluence using the <strong class="bold">Send web request</strong> action.</p>
			<p>For this example, we have created a new Confluence space and a Releases page. Individual release notes pages will be created as children of the Releases page.</p>
			<p>To make things easier, we'll create a <strong class="bold">Release Notes Template</strong> page in Confluence, complete with all the relevant smart values populated. Once we have our template, we need to copy the page using its storage format so we can include it in the <strong class="bold">Send web request</strong> body in our automation rule. </p>
			<p>In the following screenshot, we can see the completed template and the option to view the storage format of the page:</p>
			<div><div><img src="img/B16551_Figure_5.3.jpg" alt="Figure 5.3 – Getting the Release Notes Template page source&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.3 – Getting the Release Notes Template page source</p>
			<p>Copy all the code in the storage format <a id="_idIndexMarker258"/>view into a text editor, and <a id="_idIndexMarker259"/>then we'll modify the <code>{{#lookupIssues}}</code> section as follows to ensure that the smart value substitutions work as expected:</p>
			<pre>&lt;ul&gt;
{{#lookupIssues}}
&lt;li&gt;&lt;p&gt;{{key}} - {{summary}} &lt;/p&gt;&lt;/li&gt;
{{/}}
&lt;/ul&gt;</pre>
			<p>Next, we will escape all the double quote characters in the code by prepending a backslash to them and then<a id="_idIndexMarker260"/> remove all the new lines so that the entire code is on a single line.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">We use the storage format when working with Confluence as this gives us access to the underlying HTML formatting of the page, including the XML used to define the various Confluence macros in the page, and allows us greater flexibility in making adjustments to the final content that will be displayed when the page is published.</p>
			<p>Finally, we need to<a id="_idIndexMarker261"/> ensure that you have a valid API token, which will be needed to authorize the web request later in the rule:</p>
			<ol>
				<li value="1">Navigate to <a href="https://id.atlassian.com/manage-profile/security/api-tokens">https://id.atlassian.com/manage-profile/security/api-tokens</a> and click on <strong class="bold">Create API token</strong>.<p class="callout-heading">Important note</p><p class="callout">You cannot use two-step authentication for the account that you use in an automation rule. Two-step verification is designed for human users who have access to a secondary device and is impossible to implement for an automated system.</p></li>
				<li>Give your token a label, for example, <code>Automation Rules</code>, and click <strong class="bold">Create</strong>.</li>
				<li>Copy the token somewhere safe, as you will not be able to retrieve it once you close the pop-up window.</li>
				<li>We now need to encode our credentials for use in our automation rule. You can use an online tool such as the one at <a href="https://www.base64encode.org">https://www.base64encode.org</a> to perform the encoding.<p>Enter your email address, followed immediately by a colon (:) and then your API token, click the <strong class="bold">Encode</strong> button, and then copy the resulting encoded value somewhere safe.</p><p class="callout-heading">Tip</p><p class="callout">If you're using Confluence Server, you need only the username and password of a user who can create pages in the Confluence space. To encode the credentials, replace the email address in the preceding <em class="italic">step 4</em> with the username, and the API token with the user's password.</p></li>
			</ol>
			<p>Now, let's move<a id="_idIndexMarker262"/> on to building the automation rule:</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the <strong class="bold">Project Settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <strong class="bold">Version released</strong> trigger and click <strong class="bold">Save</strong>.</li>
				<li>Next, select <code>fixVersion = "{{version.name}}"</code></p></li>
				<li>Then, select <code>https://&lt;your_site&gt;.atlassian.net/wiki/rest/api/content</code></p><p>First <code>Content-Type</code></p><p><code>application/json</code></p><p>Second <code>Authorization</code></p><p><code>Basic &lt;your base64-encoded credentials&gt;</code></p><p><code>POST</code></p><p><code>Custom data</code></p></li>
				<li>We need to <a id="_idIndexMarker264"/>retrieve the page ID of the Release Notes page as this will be the parent of our release pages. To do so, navigate to the Release Notes page in Confluence, and then click the <code>ancestors</code> item in the JSON.<p>You also need to <a id="_idIndexMarker265"/>ensure you use the correct Confluence space key. In our example, this is <strong class="bold">MA</strong>.</p><pre>{
    "type": "page",
    "title": "Version <strong class="bold">{{version.name.jsonEncode}}</strong>",
    "space": {
        "key": "MA"
    },
    "ancestors": [
        {
            "id": "33051"
        }
    ],
    "body": {
        "storage": {
            "value": "&lt;table data-layout=\"default\"&gt;&lt;colgroup&gt;&lt;col style=\"width: 212.0px;\" /&gt;&lt;col style=\"width: 416.0px;\" /&gt;&lt;/colgroup&gt;&lt;tbody&gt;&lt;tr&gt;&lt;th&gt;&lt;p&gt;&lt;strong&gt;Version&lt;/strong&gt;&lt;/p&gt;&lt;/th&gt;&lt;td&gt;&lt;p&gt;<strong class="bold">{{version.name.jsonEncode}}</strong>&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;&lt;p&gt;&lt;strong&gt;Release Date&lt;/strong&gt;&lt;/p&gt;&lt;/th&gt;&lt;td&gt;&lt;p&gt;<strong class="bold">{{version.releaseDate.jiraDate}}</strong>&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;tr&gt;&lt;th&gt;&lt;p&gt;&lt;strong&gt;Issues in this release&lt;/strong&gt;&lt;/p&gt;&lt;/th&gt;&lt;td&gt;&lt;p&gt;<strong class="bold">{{lookupIssues.size}}</strong>&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;h1&gt;Summary&lt;/h1&gt;&lt;p&gt;<strong class="bold">{{version.description.jsonEncode}}</strong>&lt;/p&gt;&lt;h1&gt;Issues&lt;/h1&gt;&lt;p&gt;This release contains the following updates and fixes:&lt;/p&gt;&lt;ul&gt;<strong class="bold">{{#lookupIssues}}</strong>&lt;li&gt;&lt;p<strong class="bold">&gt;{{key}} - {{summary.jsonEncode}}</strong>&lt;/p&gt;&lt;/li&gt;<strong class="bold">{{/}}</strong>&lt;/ul&gt;",
            "representation": "storage"
        }
    }
}</pre><p>If the JSON structure<a id="_idIndexMarker267"/> looks like the <a id="_idIndexMarker268"/>preceding code, copy the JSON into the <strong class="bold">Custom data</strong> field, after which your rule should look similar to the following screenshot:</p><div><img src="img/B16551_Figure_5.4.jpg" alt="Figure 5.4 – Configuring the Send web request&#13;&#10;"/></div><p class="figure-caption">Figure 5.4 – Configuring the Send web request</p></li>
				<li>Finally, click <code>Publish release notes to Confluence</code>, and click <strong class="bold">Turn it on</strong> to save and enable the rule.<p>When<a id="_idIndexMarker269"/> you release a version in your Jira Software <a id="_idIndexMarker270"/>project now, you should have a published page in Confluence under <strong class="bold">Release Notes</strong> that looks similar to the following screenshot:</p></li>
			</ol>
			<div><div><img src="img/B16551_Figure_5.5.jpg" alt="Figure 5.5 – The release notes published by the automation rule&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.5 – The release notes published by the automation rule</p>
			<p>We have<a id="_idIndexMarker271"/> now learned how to send a web request to an external system using automation rules. In the next section, we'll expand on this and see<a id="_idIndexMarker272"/> how we can incorporate the data returned from the external system in subsequent rule components.</p>
			<h1 id="_idParaDest-120"><a id="_idTextAnchor099"/>Working with data returned from requests</h1>
			<p>Many systems you will integrate<a id="_idIndexMarker273"/> with not only accept data you send, but also respond with additional data depending on the request. With automation rules, we are able to retrieve the response from a request and utilize this data in subsequent conditions and actions in our rules. This ability gives our rules even greater flexibility and power as we can now make decisions and perform actions based on the specific content returned from the external system.</p>
			<p>When configuring the <code>{{webhookResponse}}</code>, with the response from the external system.</p>
			<p>The <code>{{webhookResponse}}</code> smart value<a id="_idIndexMarker274"/> contains a number of fields that you can access in your subsequent rule components, and these are as follows:</p>
			<ul>
				<li><code>200</code> or <code>201</code> for successful requests, or in the range <code>300</code> to <code>599</code> for redirection and errors. You can find more about HTTP response codes at <a href="https://en.wikipedia.org/wiki/List_of_HTTP_status_codes">https://en.wikipedia.org/wiki/List_of_HTTP_status_codes</a>.</li>
				<li><code>{{webhookResponse.headers.Content-Type}}</code> will retrieve the <strong class="bold">Content-Type</strong> header returned by the external system.</li>
				<li><strong class="bold">{{webhookResponse.body}}</strong>: The body field will contain the body of the response from the external system. If the external system response is a JSON object, you can access any of the<a id="_idIndexMarker275"/> fields using <strong class="bold">dot notation</strong>.</li>
				<li><strong class="bold">{{webhookResponses}}</strong>: If you have multiple <strong class="bold">Send web request</strong> actions in your rule, each response, if present, will be added to this list and you can use the smart value list functions that we covered in <a href="B16551_03_Final_ASB_ePub.xhtml#_idTextAnchor065"><em class="italic">Chapter 3</em></a>, <em class="italic">Enhancing Rules with Smart Values</em>, to work with the list items.</li>
			</ul>
			<p>Let's now take a look at how we can incorporate the response from a web request into an automation rule.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor100"/>Creating a rule to add incident managers as watchers</h2>
			<p>In this example, we are going to<a id="_idIndexMarker276"/> add the members of the VIP group that we created in <a href="B16551_01_Final_ASB_ePub.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>,<em class="italic"> Key Concepts of Automation</em>, as watchers to<a id="_idIndexMarker277"/> issues whose priority is set to <strong class="bold">Highest</strong> when the issue is either created or updated.</p>
			<p>As Jira itself has a powerful REST API, we can treat it as an external system in our automation rules and retrieve data for use in our rules that we wouldn't ordinarily have access to.</p>
			<p>Let's take a look at the rule:</p>
			<ol>
				<li value="1">In your Jira Service Management project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the <strong class="bold">Project Settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <code>Issue Created</code> and <code>Issue Updated</code>. Then click <strong class="bold">Save</strong>.</li>
				<li>Now select <code>Issue Type</code></p><p><code>equals</code></p><p><code>Incident</code></p></li>
				<li>Then select <code>Priority</code></p><p><code>equals</code></p><p><code>Highest</code></p></li>
				<li>Next, select <code>https://&lt;your_site.domain.com&gt;/rest/api/3/group/member?groupname=VIP</code></p><p><code>Authorization</code></p><p><code>Basic &lt;your base64-encoded credentials&gt;</code></p><p><code>GET</code></p><p><code>Empty</code></p><p><strong class="bold">Wait for response</strong>: Select the checkbox</p><p>The response<a id="_idIndexMarker278"/> from this API call returns a list of users in the <strong class="bold">values</strong> array that belong to the <strong class="bold">groupname</strong> we specified in<a id="_idIndexMarker279"/> the query parameter, similar to the following:</p><pre>{
  "values": [
    {
      "self": "https://&lt;your-site&gt;.atlassian.net/rest/api/3/user?accountId=5b10a2844c20165700ede21g",
      "name": "Joe Soap",
      "key": "jsoap",
      "accountId": "5b10a2844c20165700ede21g",
      "emailAddress": "joe.soap@company.com",
      "avatarUrls": {},
      "displayName": "Joe Soap",
      "active": true,
      "timeZone": "Europe/London",
      "accountType": "atlassian"
    }
  ]
}</pre><p>You can find more information about this API call at <a href="https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get">https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get</a>.</p></li>
				<li>To complete the rule, select <code>{{webhookResponse.body.values.accountId}}</code></p><p>Your rule should look similar to the following screenshot:</p><div><img src="img/B16551_Figure_5.6.jpg" alt="Figure 5.6 – Using webhookResponse data in a rule&#13;&#10;"/></div><p class="figure-caption">Figure 5.6 – Using webhookResponse data in a rule</p></li>
				<li>Finally, click <code>Add</code> <code>watchers</code> <code>to</code> <code>Highest</code> <code>priority</code> <code>incidents</code>, and then click <strong class="bold">Turn it on</strong> to save and enable the rule.</li>
			</ol>
			<p>In this section, we have<a id="_idIndexMarker282"/> learned how to expose the response returned from an external system request and how we can use this data to create much <a id="_idIndexMarker283"/>more powerful automation rules.</p>
			<p>In the next section, we will learn how we can listen for web requests from external systems and how these can be used to trigger our automation rules.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor101"/>How to receive requests using incoming webhooks</h1>
			<p>In the previous two <a id="_idIndexMarker284"/>sections, we learned how to use automation rules to send notifications and data to external systems and how to work with the response data received from an external system.</p>
			<p>In addition to this, automation rules also<a id="_idIndexMarker285"/> allow us to receive notifications and data from external systems using the <strong class="bold">Incoming webhook</strong> trigger. This component will create a unique URL for each trigger that can then be called by an external system and will trigger the automation rule to run. These incoming webhooks can receive a list of issues on which to act as well as custom data in the form of JSON objects, which can be used in later rule components to make decisions using conditions or to create or update issues using the custom data provided.</p>
			<p>The following screenshot shows the configuration options for the <strong class="bold">Incoming webhook</strong> trigger:</p>
			<div><div><img src="img/B16551_Figure_5.7.jpg" alt="Figure 5.7 – Configuring the Incoming webhook trigger&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.7 – Configuring the Incoming webhook trigger</p>
			<p>Let's now take a<a id="_idIndexMarker286"/> look at how each of the configuration options works:</p>
			<ol>
				<li value="1">The <strong class="bold">Webhook URL</strong> is the unique URL that<a id="_idIndexMarker287"/> will cause the rule to run when an external system sends an HTTP <strong class="bold">POST</strong> request to it.<p>This URL is generated automatically and requires no authentication to use. If the URL is compromised, you can use the <strong class="bold">Regenerate</strong> link to generate a new URL for the webhook and update any external systems that use it.</p><p class="callout-heading">Important note</p><p class="callout">Incoming webhooks only support the HTTP <strong class="bold">POST</strong> method. They will not respond to HTTP <strong class="bold">GET</strong> or any other method. In addition, you need to ensure that the external system that sends a request to the webhook sets the <em class="italic">Content-Type</em> request header to <em class="italic">application/json</em>.</p></li>
				<li>The <code>issue</code>, for example, <code>https://automation.atlassian.com/pro/hooks/&lt;unique-webhook-token&gt;?issue=MAPP-1</code>. To specify multiple issues, you should include either the issue key or the issue ID in an <code>"issues"</code> list in the JSON-formatted request body as follows:</p><pre>{
    "issues": [
        "MAPP-1",
        "MAPP-2",
        "10123"
    ]
}</pre><p><strong class="bold">Issues provided by running the following JQL search</strong> will display the <strong class="bold">JQL</strong> field (3), which allows you to input a JQL query to search for the relevant issues.</p><p><strong class="bold">No issues from the webhook</strong> means the webhook is not expecting to operate on any existing issue. You could use this option if you needed to create issues as a result of the webhook being called, for example.</p></li>
				<li>As mentioned in <em class="italic">step 2</em> above, the <strong class="bold">JQL</strong> field is displayed when you use the <strong class="bold">Issues provided by running the following JQL search</strong> option and allows you to define a JQL query to<a id="_idIndexMarker290"/> return the issues that will be updated as a result of calling the webhook. You can use smart<a id="_idIndexMarker291"/> values and functions in the query. However, doing so means you cannot validate the query using the <strong class="bold">Validate query</strong> link.</li>
			</ol>
			<p>Let's now look at how we can use an incoming webhook to trigger an automation rule that we've seen in order to configure incoming webhooks.</p>
			<h2 id="_idParaDest-123"><a id="_idTextAnchor102"/>Creating a rule to resolve open issues using an automation webhook</h2>
			<p>Many software projects have <a id="_idIndexMarker292"/>some form of automated build and deploy tool that automates the building, testing, and deployment of code.</p>
			<p>In this example, we are going to assume that the developers will move their issues to the <em class="italic">Waiting for deploy</em> status once they have completed development. When our automated deployment starts, we want to automatically resolve all issues in the currently open sprint that are awaiting deployment by having our build and deploy tool an automation rule in Jira.</p>
			<p>In our example Jira Software project, we are using the <em class="italic">Software Simplified</em> workflow, so we will edit the workflow from the <strong class="bold">Project Settings</strong> screen and add a new <em class="italic">Waiting for deploy</em> status and allow all statuses to transition to it. In addition, add the <em class="italic">Resolve issue</em> screen to the <em class="italic">Done</em> transition to allow comments to be added when resolving issues.</p>
			<p>Now that we've adjusted our workflow to take this new status into account, let's create the automation rule:</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the project settings menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select the <code>Issues provided by running the following JQL search</code></p><p><code>sprint in openSprints() AND status = "Waiting for deploy"</code></p></li>
				<li>Now, select <code>Done</code> in the <strong class="bold">Destination status</strong> field.</li>
				<li>In addition, we want to add a comment to these issues to the effect that the issue was automatically resolved by the build system.<p>To do this, expand the <strong class="bold">More options</strong> disclosure, add the following JSON in the <strong class="bold">Additional fields</strong> editor, and then click <strong class="bold">Save</strong>:</p><pre>{
    "update": {
        "comment": [
            {
                "add": {
                    "body": "Issue automatically resolved by build system"
                }
            }
        ]
    }
}</pre><p>Your rule should<a id="_idIndexMarker294"/> now look similar to the following screenshot:</p><div><img src="img/B16551_Figure_5.8.jpg" alt="Figure 5.8 – Configuring a rule with an incoming webhook&#13;&#10;"/></div><p class="figure-caption">Figure 5.8 – Configuring a rule with an incoming webhook</p></li>
				<li>Finally, name your rule <code>Release</code> <code>issues</code> <code>waiting</code> <code>for</code> <code>deploy</code> and click <strong class="bold">Turn it on</strong> to save and enable the rule.</li>
			</ol>
			<p>In this section, we have learned how to create and use incoming webhooks to trigger automation rules. In the next section, we'll learn how we can also make use of data supplied by the external system to further enhance our automation rules.</p>
			<h1 id="_idParaDest-124"><a id="_idTextAnchor103"/>Working with data in incoming webhooks</h1>
			<p>Having the ability to trigger<a id="_idIndexMarker295"/> actions in Jira from external systems enables you to create really powerful integrations with automation rules.</p>
			<p>As we saw in the previous section, you can act on specific issues by including them in the incoming request body. However, with the <code>{{webhookData}}</code> smart value, where you can access any of the JSON object fields using dot notation.</p>
			<p>This powerful functionality will enable you to integrate with any external system that can send web requests and allow you to extract valuable data for use in your issues. For example, you could potentially set up your monitoring tools to send notifications to an automation rule when an incident occurs and use the data it provides to create a new incident and set affected components based on which asset caused the incident.</p>
			<p>Let's now take a look at how we can configure an automation rule that makes use of custom data from an incoming web request.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor104"/>Creating a rule to raise new issues using an automation webhook</h2>
			<p>Being able to collect<a id="_idIndexMarker296"/> information about your deployed software when something goes wrong is invaluable for many developers and many software applications allow users to submit feedback when an error occurs.</p>
			<p>In this example, we are going to create an automation rule using an incoming webhook to receive a bug report and automatically create a bug in our Jira project to track it.</p>
			<p>We are going to expect a JSON object with the following structure to process this incoming information:</p>
			<pre>{
    "summary": "some summary text",
    "bugDescription": "some descriptive text",
    "softwareVersion": "version string"
}</pre>
			<p>If you were including this in a product, you could probably add more relevant data, such as stack traces to the JSON structure to make the bug report more contextual.</p>
			<p>Let's now take a look at how to build this automation rule:</p>
			<ol>
				<li value="1">In your Jira Software project, navigate to <strong class="bold">Project settings</strong>, click on the <strong class="bold">Automation</strong> link in the <strong class="bold">Project Settings</strong> menu, and then click <strong class="bold">Create rule</strong>.</li>
				<li>Select <code>No issues from the webhook</code> as we're going to be using this rule to create an issue. Then click <strong class="bold">Save</strong>.</li>
				<li>Next, select <code>Same project</code></p><p><code>Bug</code></p><p><code>{{webhookData.summary}}</code></p><p><code>{{webhookData.bugDescription}}</code></p></li>
				<li>We also want to capture the software version that was deployed when this bug was submitted, and we'd like to add some labels to the issue to make it easier to find bugs<a id="_idIndexMarker298"/> raised from the in-product feedback collector.<p>To do this, expand the <strong class="bold">More options</strong> disclosure and then add the following JSON to the <strong class="bold">Additional fields</strong> editor:</p><pre>{
    "fields": {
        "versions": [
            { "name": "{{webhookData.softwareVersion}}" }
        ],
        "labels": [
            "bugfix",
            "feedback"
        ]
    }
}</pre><p>Your rule should now look similar to the following screenshot:</p><div><img src="img/B16551_Figure_5.9.jpg" alt="Figure 5.9 – Consuming incoming webhook data&#13;&#10;"/></div><p class="figure-caption">Figure 5.9 – Consuming incoming webhook data</p></li>
				<li>Click on <code>In-product</code> <code>bug</code> <code>collector</code>, and then click <strong class="bold">Turn it on</strong> to save and enable the rule.</li>
			</ol>
			<p>You have now learned<a id="_idIndexMarker299"/> how to consume request data from an external system in an incoming webhook.</p>
			<p>The ability to consume incoming data from external systems and use it to make decisions and effect changes to issues using automation rules gives you some extremely powerful options in terms of automating your projects in Jira.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor105"/>Summary</h1>
			<p>In this chapter, you have learned how you can integrate to external systems using automation rules by sending web requests and how you can include custom data in these requests using smart values and smart value functions.</p>
			<p>We have also learned how to ensure we can receive a response from a request to an external system and how we can extract the data for use in subsequent rule components.</p>
			<p>Next, we learned to set up an incoming webhook using automation rules to listen for requests coming from external systems and how to optionally process data sent in the request body and use this in subsequent rule components.</p>
			<p>As we have seen in this chapter, the ability to integrate with external systems using automation rules opens a world of possibilities to your Jira projects. For example, you could start a software build or deployment from your build tool when you release a version or complete a sprint in Jira Software. In Service Management, you could integrate with your user directory service to automatically provision new accounts based on service requests or reset passwords automatically, if supported.</p>
			<p>In the next chapter, we will look at how we can use the skills learned in this and previous chapters to help build automations in your Service Management instances.</p>
		</div>
	</body></html>