<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03" class="calibre1"/>Chapter 3. Automating Docker Deployments with Chef</h1></div></div></div><p class="calibre8">By this time, we already know the various aspects of the Docker ecosystem. The Docker host has several configuration parameters. However, manually configuring Docker hosts is a slow and error-prone process. We will have problems scaling our Docker deployments in production if we don't have an automation strategy in place.</p><p class="calibre8">In this chapter, we will learn the concept of configuration management to solve this problem. We will use Chef, a configuration management software, to manage Docker hosts in scale. This chapter will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">The importance of configuration management</li><li class="listitem">An introduction to Chef</li><li class="listitem">Automatically configuring Docker hosts</li><li class="listitem">Deploying Docker containers</li><li class="listitem">Alternative automation tools</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch03lvl1sec16" class="calibre1"/>An introduction to configuration management</h1></div></div></div><p class="calibre8">The Docker <a id="id94" class="calibre1"/>engine has several parameters to tune, such as cgroups, memory, CPU, filesystems, networking, and so on. Identifying which Docker containers run on which Docker hosts is another aspect of configuration. The Docker containers themselves need to be configured differently with cgroups settings, shared volumes, linked containers, public ports, and so on. Getting the combination of parameters to optimize our application will take time.</p><p class="calibre8">Replicating all the preceding configuration items to another Docker host is difficult to perform manually. We might not remember all the steps required to create a host, and it is an error-prone and slow process. Creating a "documentation" to get this process captured doesn't help either because such artifacts tend to get stale over time.</p><p class="calibre8">If we cannot provision new Docker hosts in a timely and reliable manner, we will have no space to scale out our Docker application. It is just as important to prepare and configure our Docker hosts in a consistent and fast manner. Otherwise, Docker's ability to create container packages for our application will become useless very fast.</p><p class="calibre8">Configuration management is a strategy to manage the changes happening in all aspects of our application, and it reports and audits the changes made to our system. This does not only apply when developing our application. For our case, it records all the changes to Docker hosts and the running of the Docker containers itself. Docker, in a sense, accomplishes the following aspects of configuration management for our application:</p><div><ul class="itemizedlist"><li class="listitem">Docker <a id="id95" class="calibre1"/>containers reproduce any environment for our application, from development to staging, testing, and production.</li><li class="listitem">Building Docker images is a simple way to make application changes and have them deployed to all environments.</li><li class="listitem">Docker enables all team members to get information about our application and make the needed changes to deliver the software efficiently to customers. By inspecting the <code class="literal">Dockerfile</code>, they can know which part of the application needs to be updated and what it needs in order to properly run.</li><li class="listitem">Docker tracks any change in our environment to a particular Docker image. Then, it traces it back to the corresponding version of the <code class="literal">Dockerfile</code>. It traces what the change is, who made it, and when it was made.</li></ul></div><p class="calibre8">However, what about the Docker host running our application? Just as how a <code class="literal">Dockerfile</code> allows us to manage our application's environment in version control, configuration management tools can describe our Docker hosts in code. It simplifies the process to create Docker hosts. In the case of scaling out our Docker application, we can recreate a new Docker host from scratch easily. When there is a hardware failure, we can bring up new Docker hosts somewhere else from their known configuration. If we want to deploy a new version of our Docker containers, we can just update the Docker host's configuration code to point to the new image. Configuration management enables us to manage our Docker deployments in scale.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec17" class="calibre1"/>Using Chef</h1></div></div></div><p class="calibre8">Chef is a configuration <a id="id96" class="calibre1"/>management tool that provides a domain-specific language to model the configuration of our infrastructure. Each configuration item in our infrastructure is modeled as a resource. A resource is basically a Ruby method that accepts several parameters in a block. The following example resource describes installing the <code class="literal">docker-engine</code> package:</p><div><pre class="programlisting">package 'docker-engine' do
  action :install
end</pre></div><p class="calibre8">These resources are then written together in Ruby source files called recipes. When running a recipe against a server (a Docker host in our case), all the defined resources are executed to reach its desired state configuration.</p><p class="calibre8">Some Chef recipes may depend on other supplemental items, such as configuration templates and other recipes. All this information is gathered in cookbooks together with the recipes. A cookbook is the fundamental unit of distributing configuration and policy to our servers.</p><p class="calibre8">We will write Chef recipes to <a id="id97" class="calibre1"/>represent the desired state configuration of our Docker hosts. Our recipes will be organized in Chef cookbooks to distribute them to our infrastructure. However, first, let's prepare our Chef environment so that we can start describing our Docker-based infrastructure in recipes. A Chef environment consists of three things:</p><div><ul class="itemizedlist"><li class="listitem">A Chef server</li><li class="listitem">A workstation</li><li class="listitem">A node</li></ul></div><p class="calibre8">The next few subsections will give you a detailed description of each component. Then, we will set them up to prepare our Chef environment to be able to manage our Docker host.</p><div><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">There are more details <a id="id98" class="calibre1"/>of setting up a Chef environment that are out of this chapter's scope. More information can be found at the Chef documentation website at <a class="calibre1" href="http://docs.chef.io">http://docs.chef.io</a>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch03lvl2sec20" class="calibre1"/>Signing up for a Chef server</h2></div></div></div><p class="calibre8">The Chef <a id="id99" class="calibre1"/>server is the central repository of cookbooks and other policy items governing our entire infrastructure. It contains metadata about the infrastructure that we are managing. In our case, the Chef server contains the cookbook, policy, and metadata on our Docker host.</p><p class="calibre8">To prepare a Chef server, we will simply sign up for a hosted Chef server. A free Chef server account allows us to manage up to five nodes in our infrastructure. Follow the next few steps to prepare a <a id="id100" class="calibre1"/>hosted Chef server account:</p><div><ol class="orderedlist"><li class="listitem" value="1">Go to <a class="calibre1" href="https://manage.chef.io/signup">https://manage.chef.io/signup</a> and fill out the form for our account details as shown in the following screenshot:<div><img src="img/00007.jpeg" alt="Signing up for a Chef server" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">After creating <a id="id101" class="calibre1"/>a user account, the hosted Chef server will now prompt us to create an organization. Organizations are simply used to manage role-based access control for our Chef server. Create an organization by providing the details on the form and click on the <strong class="calibre2">Create Organization</strong> button:<div><img src="img/00008.jpeg" alt="Signing up for a Chef server" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="3">We are now <a id="id102" class="calibre1"/>almost done getting our hosted Chef server account. Finally, click on <strong class="calibre2">Download Starter Kit</strong>. This will download a zip file containing our starter chef-repo. We will talk more about the chef-repo in the next section.<div><img src="img/00009.jpeg" alt="Signing up for a Chef server" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch03lvl2sec21" class="calibre1"/>Setting up our workstation</h2></div></div></div><p class="calibre8">The second <a id="id103" class="calibre1"/>part of our Chef environment is the workstation. The workstation is used to interact with the Chef server. This is where we will do most of the preparation work and create the code to send to the Chef server. In our workstation, we will prepare the configuration items of our infrastructure in a Chef repository.</p><p class="calibre8">The Chef repository contains all the information needed to interact and synchronize with the Chef server. It contains the private key and other configuration files needed to authenticate and interact with the Chef server. These files will be found in the <code class="literal">.chef</code> directory of our Chef repository. It also contains the cookbooks that we will write and synchronize later with the Chef server in the <code class="literal">cookbooks/</code> directory. There are other files and directories inside a Chef repository, such as data bags, roles, and environments as well. However, it is enough for now to know about the cookbooks and authentication files to be able to configure our Docker host.</p><p class="calibre8">Do you remember that starter kit we downloaded in the previous section? Unzip this file to extract our chef-repo. We should have the following files described in the directory tree:</p><div><img src="img/00010.jpeg" alt="Setting up our workstation" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Another important <a id="id104" class="calibre1"/>component in our workstation is the Chef development kit. It contains all the programs needed to read all the configuration in our chef-repo and interact with the Chef server. Convenient programs to create, develop, and test our cookbooks are also available in the Chef development kit. We will use various programs in the development kit throughout the rest of this chapter.</p><p class="calibre8">Now, let's download the Chef <a id="id105" class="calibre1"/>development kit from <a class="calibre1" href="https://downloads.chef.io/chef-dk">https://downloads.chef.io/chef-dk</a> according to our workstation's platform.</p><div><img src="img/00011.jpeg" alt="Setting up our workstation" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">Next, open the downloaded installer. Install the Chef development kit according to the prompts from our <a id="id106" class="calibre1"/>platform. Finally, confirm that the installation was successful with the following commands:</p><div><pre class="programlisting">
<strong class="calibre2">$ chef -v</strong>
<strong class="calibre2">Chef Development Kit Version: 0.6.2</strong>
<strong class="calibre2">chef-client version: 12.3.0</strong>
<strong class="calibre2">berks version: 3.2.4</strong>
<strong class="calibre2">kitchen version: 1.4.0</strong>
</pre></div><p class="calibre8">Now that we have set up our workstation, let's go to our <code class="literal">chef-repo/</code> directory to prepare the last component of our Chef environment.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch03lvl2sec22" class="calibre1"/>Bootstrap nodes</h2></div></div></div><p class="calibre8">The last part of our <a id="id107" class="calibre1"/>Chef environment is nodes. A node is any computer that is managed by Chef. It can be a physical machine, virtual machine, a server in the cloud, or a networking device. In our case, our Docker host is a node.</p><p class="calibre8">The central component for any node to be managed by Chef is the chef-client. It connects to the Chef server to download the necessary files to bring our node to its configuration state. When a chef-client is run on our node, it performs the following steps:</p><div><ol class="orderedlist"><li class="listitem" value="1">It registers and authenticates the node with the Chef server.</li><li class="listitem" value="2">It gathers system information in our node to create a node object.</li><li class="listitem" value="3">Then, it synchronizes the Chef cookbooks needed by our node.</li><li class="listitem" value="4">It compiles the resources by loading our node's needed recipes.</li><li class="listitem" value="5">Next, it executes all the resources and performs the corresponding actions to configure our node.</li><li class="listitem" value="6">Finally, it reports the result of the chef-client run back to the Chef server and other configured notification endpoints.</li></ol><div></div><p class="calibre8">Now, let's prepare our <a id="id108" class="calibre1"/>Docker host as a node by bootstrapping it from our workstation. The bootstrapping process installs and configures the chef-client. Run the following command to get this bootstrap process started:</p><div><pre class="programlisting">
<strong class="calibre2">$ knife bootstrap dockerhost</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">Connecting to dockerhost</strong>
<strong class="calibre2">dockerhost Installing Chef Client...</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">dockerhost trying wget...</strong>
<strong class="calibre2">dockerhost Comparing checksum with sha256sum...</strong>
<strong class="calibre2">dockerhost Installing Chef 12.3.0</strong>
<strong class="calibre2">dockerhost installing with dpkg...</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">dockerhost Thank you for installing Chef!</strong>
<strong class="calibre2">dockerhost Starting first Chef Client run...</strong>
<strong class="calibre2">dockerhost Starting Chef Client, version 12.3.0</strong>
<strong class="calibre2">dockerhost Creating a new client identity for dockerhost using the validator key.</strong>
<strong class="calibre2">dockerhost resolving cookbooks for run list: []</strong>
<strong class="calibre2">dockerhost Synchronizing Cookbooks:</strong>
<strong class="calibre2">dockerhost Compiling Cookbooks...</strong>
<strong class="calibre2">dockerhost ... WARN: Node dockerhost has an empty run list.</strong>
<strong class="calibre2">dockerhost Converging 0 resources</strong>
<strong class="calibre2">dockerhost </strong>
<strong class="calibre2">dockerhost Running handlers:</strong>
<strong class="calibre2">dockerhost Running handlers complete</strong>
<strong class="calibre2">dockerhost Chef Client finished, 0/0 resources updated in 12.78s</strong>
</pre></div><p class="calibre8">As we can note in the preceding command, the bootstrapping process did two things. First, it installed and configured the chef-client on our Docker host node. Next, it started the chef-client to synchronize its desired state with our Chef server. As we haven't assigned any designed state yet to our Docker host, it didn't do anything.</p><div><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">We can customize this bootstrap process according to our needs. More information on <a id="id109" class="calibre1"/>how to use <code class="literal">knife bootstrap</code> can be found at <a class="calibre1" href="http://docs.chef.io/knife_bootstrap.html">http://docs.chef.io/knife_bootstrap.html</a>.</p><p class="calibre8">In some cases, cloud providers have a deep Chef integration already out of the box. So, instead of <code class="literal">knife bootstrap</code>, we will just use the cloud provider's SDK. There, we just need to specify that we want to have Chef integrated. We will provide it with the information, such as the chef-client's <code class="literal">client.rb</code> configuration and validation keys' credentials.</p></div><p class="calibre8">Our Docker host is now <a id="id110" class="calibre1"/>properly registered to the Chef server, ready to grab its configuration. Go to <a class="calibre1" href="https://manage.chef.io/organizations/dockerorg/nodes/dockerhost">https://manage.chef.io/organizations/dockerorg/nodes/dockerhost</a> to check our Docker host as a node in our Chef environment, as shown in the following screenshot:</p><div><img src="img/00012.jpeg" alt="Bootstrap nodes" class="calibre10"/></div><p class="calibre11"> </p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec18" class="calibre1"/>Configuring the Docker host</h1></div></div></div><p class="calibre8">Now that we have all the <a id="id111" class="calibre1"/>components of our Chef environment properly set up, we can now start writing Chef recipes to actually describe what configuration our Docker host should have. In addition, we will leapfrog our productivity by taking advantage of existing Chef cookbooks in the Chef ecosystem. As Docker is a popular infrastructure stack to deploy, we can use cookbooks in the wild that allow us to configure our Docker hosts. Chef cookbooks provided by the community can be found in the Chef <a id="id112" class="calibre1"/>supermarket. We can go to <a class="calibre1" href="http://supermarket.chef.io">http://supermarket.chef.io</a> to discover other cookbooks that we can readily use.</p><p class="calibre8">In this section, you will <a id="id113" class="calibre1"/>learn how to write Chef recipes and apply it to our node. Follow the next few steps to write the recipe for our Docker host:</p><div><ol class="orderedlist"><li class="listitem" value="1">Use the Chef development kit's <code class="literal">chef generate cookbook</code> command to generate a boilerplate for our cookbook. After entering the cookbooks directory, issue the following command:<div><pre class="programlisting">
<strong class="calibre2">$ cd cookbooks</strong>
<strong class="calibre2">$ chef generate cookbook dockerhost</strong>
</pre></div><p class="calibre15">The boilerplate cookbook directory structure will look similar to the following screenshot:</p><div><img src="img/00013.jpeg" alt="Configuring the Docker host" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Next, we will prepare to edit our cookbook. Change our working directory to the cookbook we created earlier using the following command:<div><pre class="programlisting">
<strong class="calibre2">$ cd dockerhost</strong>
</pre></div></li><li class="listitem" value="3">Install the following <a id="id114" class="calibre1"/>cookbooks from the Chef supermarket as dependencies: <code class="literal">apt</code> and <code class="literal">docker</code>. These cookbooks provide additional resource definitions that can be used in our recipes. We will use them later as building blocks to set up our Docker host. To add the dependencies, update the <code class="literal">metadata.rb</code> file, as follows:<div><pre class="programlisting">name 'dockerhost'
maintainer 'The Authors'
maintainer_email 'you@example.com'
license 'all_rights'
description 'Installs/Configures dockerhost'
long_description 'Installs/Configures dockerhost'
version '0.1.0'

<strong class="calibre2">depends 'apt', '~&gt; 2.7.0'</strong>
<strong class="calibre2">depends 'docker', '~&gt; 0.40.3'</strong>
</pre></div><div><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">metadata.rb</code> file provides metadata about our Chef cookbooks. The information in the metadata provides hints to the Chef server so that the cookbook can be <a id="id115" class="calibre1"/>properly deployed to our nodes. For more information on how to configure metadata to our Chef cookbooks, visit <a class="calibre1" href="http://docs.chef.io/config_rb_metadata.html">http://docs.chef.io/config_rb_metadata.html</a>.</p></div></li><li class="listitem" value="4">Now that we have our dependencies declared, we can download them by issuing the <a id="id116" class="calibre1"/>following command:<div><pre class="programlisting">
<strong class="calibre2">$ berks install</strong>
<strong class="calibre2">Resolving cookbook dependencies...</strong>
<strong class="calibre2">Fetching 'dockerhost' from source at .</strong>
<strong class="calibre2">Fetching cookbook index from https://supermarket.chef.io...</strong>
<strong class="calibre2">Installing apt (2.7.0)</strong>
<strong class="calibre2">Installing docker (0.40.3)</strong>
<strong class="calibre2">Using dockerhost (0.1.0) from source at .</strong>
</pre></div></li><li class="listitem" value="5">Finally, we will <a id="id117" class="calibre1"/>write the Chef recipe equivalent to the installation instructions found at <a class="calibre1" href="http://blog.docker.com/2015/07/new-apt-and-yum-repos">http://blog.docker.com/2015/07/new-apt-and-yum-repos</a>. We will use the <code class="literal">apt_repository</code> resource provided by the <strong class="calibre2">apt</strong> dependency cookbook we added earlier. Then, add the following lines to <code class="literal">recipes/default.rb</code>:<div><pre class="programlisting">apt_repository 'docker' do
  uri 'http://apt.dockerproject.org/repo'
  components %w(debian-jessie main)
  keyserver 'p80.pool.sks-keyservers.net'
  key '58118E89F3A912897C070ADBF76221572C52609D'
  cache_rebuild true
end

package 'docker-engine'</pre></div></li></ol><div></div><p class="calibre8">Now, we are done preparing our <code class="literal">dockerhost/</code> Chef cookbook. The final step is to apply it to our Docker host so that it can pick its desired configuration. Follow the next remaining steps to perform this:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, upload the Chef cookbook to our Chef server. Note that in the output of the following command, the <code class="literal">apt</code> and <code class="literal">docker</code> cookbooks that we depend on will also be automatically uploaded:<div><pre class="programlisting">
<strong class="calibre2">$ berks upload</strong>
<strong class="calibre2">Uploaded apt (2.7.0) to: 'https://api.opscode.../dockerorg'</strong>
<strong class="calibre2">Uploaded docker (0.40.3) to: 'https://api.ops.../dockerorg'</strong>
<strong class="calibre2">Uploaded dockerhost (0.1.0) to: 'https://api.opscode.com:443/organizations/dockerorg'</strong>
</pre></div></li><li class="listitem" value="2">Next, apply the <a id="id118" class="calibre1"/><code class="literal">dockerhost</code> recipe we wrote earlier to the node (that is, the Docker host) by setting its <code class="literal">run_list</code> via the following command:<div><pre class="programlisting">
<strong class="calibre2">$ knife node run_list set dockerhost dockerhost</strong>
<strong class="calibre2">dockerhost:</strong>
<strong class="calibre2">  run_list: recipe[dockerhost]</strong>
</pre></div></li><li class="listitem" value="3">Finally, run the chef-client in <code class="literal">dockerhost</code>. The chef-client will fetch the Docker host's node object and apply the desired state configuration we applied in the previous steps, as follows:<div><pre class="programlisting">
<strong class="calibre2">$ ssh dockerhost</strong>
<strong class="calibre2">dockerhost$ sudo chef-client</strong>
<strong class="calibre2">Starting Chef Client, version 12.3.0</strong>
<strong class="calibre2">resolving cookbooks for run list: ["dockerhost"]</strong>
<strong class="calibre2">Synchronizing Cookbooks:</strong>
<strong class="calibre2">  - apt</strong>
<strong class="calibre2">  - dockerhost</strong>
<strong class="calibre2">  - docker</strong>
<strong class="calibre2">Compiling Cookbooks...</strong>
<strong class="calibre2">Converging 2 resources</strong>
<strong class="calibre2">Recipe: dockerhost::default</strong>
<strong class="calibre2">  * apt_repository[docker] action add</strong>
<strong class="calibre2">    * execute[install-key 58118E89F3A912897C...] action run</strong>
<strong class="calibre2">    ...</strong>
<strong class="calibre2">  * apt_package[docker-engine] action install</strong>
<strong class="calibre2">    - install version 1.7.1-0~j... of package docker-engine</strong>

<strong class="calibre2">Running handlers:</strong>
<strong class="calibre2">Running handlers complete</strong>
<strong class="calibre2">Chef Cl... finished, 6/7 resources updated in 24.69 seconds</strong>
</pre></div></li></ol><div></div><p class="calibre8">Now, we have Docker installed and configured in our Docker host using Chef. Whenever we need to add another Docker host, we can just create another server in our cloud provider and bootstrap it to have the <code class="literal">dockerhost</code> Chef recipe written earlier. When we want to update how the <a id="id119" class="calibre1"/>Docker daemons are configured in all our Docker hosts, we will just update the Chef cookbook and rerun the chef-client.</p><div><h3 class="title2"><a id="tip03" class="calibre1"/>Tip</h3><p class="calibre8">In a production environment, the goal of having configuration management software installed in our Docker host is to never have the need to log in to it just to perform configuration updates. Running the chef-client manually is only half the automation.</p><p class="calibre8">We will want to run the chef-client as a daemon process so that we don't have to run it every time we perform an update. The chef-client daemon will poll the Chef server to check whether there are any updates to the node it is managing. By default, this polling interval is set to 30 minutes.</p><p class="calibre8">For more information on how to configure the chef-client as a daemon, refer to the Chef documentation at <a class="calibre1" href="https://docs.chef.io/chef_client.html">https://docs.chef.io/chef_client.html</a>.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec19" class="calibre1"/>Deploying Docker containers</h1></div></div></div><p class="calibre8">The next step to <a id="id120" class="calibre1"/>manage Docker in scale is to deploy Docker containers to our pool of Docker hosts automatically. By now, we have built a few Docker applications already. We have a rough architectural sketch of how these containers communicate with and consume each other. Chef recipes can be used to represent this architectural topology in code, which is essential to managing our whole application and infrastructure in scale. We can identify which Docker containers need to run and know how each container connects with other containers. We can locate where our Docker containers should be deployed. Having the whole architecture in code allows us to place an orchestration strategy for our application.</p><p class="calibre8">In this section, we will create a Chef recipe to orchestrate the deployment of the Nginx Docker image to our Docker host. We will use the Chef resources provided by the <code class="literal">docker</code> cookbook we added in the previous section to configure our Docker host. Follow the next few steps to perform the deployment:</p><div><ol class="orderedlist"><li class="listitem" value="1">To begin, create the Chef recipe that we will work on. The following command will create the <code class="literal">recipes/containers.rb</code> recipe file in our <code class="literal">dockerhost/</code> cookbook:<div><pre class="programlisting">
<strong class="calibre2">$ chef generate recipe . containers</strong>
</pre></div></li><li class="listitem" value="2">Next, pull the official Nginx Docker image at <a class="calibre1" href="https://registry.hub.docker.com/_/nginx">https://registry.hub.docker.com/_/nginx</a> to our Docker host. Write the following code in <code class="literal">recipes/containers.rb</code>:<div><pre class="programlisting">docker_image 'nginx' do
  tag '1.9.3'
end</pre></div></li><li class="listitem" value="3">After <a id="id121" class="calibre1"/>downloading the Docker image, configure the Docker host to run the container. As of version 0.40.3 of the <code class="literal">docker</code> cookbook, we need to specify that our Debian Jessie Docker host deployment uses <code class="literal">systemd</code> as its <code class="literal">init</code> system. Add the following lines to the <code class="literal">recipes/containers.rb</code> as well:<div><pre class="programlisting">node.set['docker']['container_init_type'] = 'systemd'

directory '/usr/lib/systemd/system'

docker_container 'nginx' do
  tag '1.9.3'
  container_name 'webserver'
  detach true
  port '80:80'
end</pre></div><div><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">The <code class="literal">docker_container</code> and <code class="literal">docker_image</code> has several other options that we can tune to specify what we want to do with our container. The <code class="literal">docker</code> cookbook also has other resources to work with our Docker hosts. More information on options and further usage can be found on its project page at <a class="calibre1" href="https://github.com/bflad/chef-docker">https://github.com/bflad/chef-docker</a>.</p></div></li><li class="listitem" value="4">Next, we will prepare the new version of our cookbook for release. Bump the version information in <code class="literal">metadata.rb</code> to do this, as follows:<div><pre class="programlisting">name 'dockerhost'
maintainer 'The Authors'
maintainer_email 'you@example.com'
license 'all_rights'
description 'Installs/Configures dockerhost'
long_description 'Installs/Configures dockerhost'
<strong class="calibre2">version '0.2.0'</strong>

depends 'apt', '~&gt; 2.7.0'
depends 'docker', '~&gt; 0.40.3'</pre></div></li><li class="listitem" value="5">Update the <code class="literal">Berksfile.lock</code> file to pin the versions of all the cookbooks we will upload to the Chef server in the next step. Type the following command to perform the update:<div><pre class="programlisting">
<strong class="calibre2">$ berks install</strong>
<strong class="calibre2">Resolving cookbook dependencies...</strong>
<strong class="calibre2">Fetching 'dockerhost' from source at .</strong>
<strong class="calibre2">Fetching cookbook index from https://supermarket.chef.io...</strong>
<strong class="calibre2">Using dockerhost (0.2.0) from source at .</strong>
<strong class="calibre2">Using apt (2.7.0)</strong>
<strong class="calibre2">Using docker (0.40.3)</strong>
</pre></div></li><li class="listitem" value="6">Now that <a id="id122" class="calibre1"/>all the artifacts for our new cookbook are ready, we will type the following command to upload the updated cookbook to our Chef server. Note how the berks upload command automatically recognizes that only the <code class="literal">dockerhost</code> cookbook needs updating as it skips uploading the <code class="literal">apt</code> and <code class="literal">docker</code> cookbooks:<div><pre class="programlisting">
<strong class="calibre2">$ berks upload</strong>
<strong class="calibre2">Skipping apt (2.7.0) (frozen)</strong>

<strong class="calibre2">Skipping docker (0.40.3) (frozen)</strong>
<strong class="calibre2">Uploaded dockerhost (0.2.0) to: 'https://ap.../dockerorg'</strong>
</pre></div></li><li class="listitem" value="7">Next, add the <code class="literal">recipes/containers.rb</code> to the run list of our Docker host. Type the following command to update the node representing our Docker host:<div><pre class="programlisting">
<strong class="calibre2">$ knife node run_list add dockerhost dockerhost::containers</strong>
<strong class="calibre2">dockerhost:</strong>
<strong class="calibre2">  run_list:</strong>
<strong class="calibre2">    recipe[dockerhost]</strong>
<strong class="calibre2">    recipe[dockerhost::containers]</strong>
</pre></div></li><li class="listitem" value="8">Finally, rerun the chef-client to pick up the new configuration for our Docker host. We can also wait for the rerun of the chef-client if we configure the chef-client to run as a daemon process. Execute the following command:<div><pre class="programlisting">
<strong class="calibre2">$ ssh dockerhost</strong>
<strong class="calibre2">dockerhost$ sudo chef-client</strong>
<strong class="calibre2">Starting Chef Client, version 12.3.0</strong>
<strong class="calibre2">resolving cookbooks for run list: ["dockerhost", "dockerhost::containers"]</strong>
<strong class="calibre2">Synchronizing Cookbooks:</strong>
<strong class="calibre2">  - dockerhost</strong>
<strong class="calibre2">  - apt</strong>
<strong class="calibre2">  - docker</strong>
<strong class="calibre2">Compiling Cookbooks...</strong>
<strong class="calibre2">Converging 5 resources</strong>
<strong class="calibre2">Recipe: dockerhost::default</strong>
<strong class="calibre2">...</strong>
<strong class="calibre2">Recipe: dockerhost::containers</strong>
<strong class="calibre2">  * docker_image[nginx] action pull</strong>

<strong class="calibre2">  * directory[/usr/lib/systemd/system] action create</strong>
<strong class="calibre2">    - create new directory /usr/lib/systemd/system</strong>
<strong class="calibre2">  * docker_container[nginx] action run</strong>
<strong class="calibre2">    * template[/usr/lib/.../webserver.socket] action create</strong>
<strong class="calibre2">      ...</strong>
<strong class="calibre2">    * service[webserver] action enable (up to date)</strong>
<strong class="calibre2">    * service[webserver] action start</strong>
<strong class="calibre2">      - start service service[webserver]</strong>
<strong class="calibre2">  * template[webserver.socket] action nothing ...</strong>
<strong class="calibre2">  * template[webserver.service] action nothing ...</strong>
<strong class="calibre2">  * service[webserver] action nothing ...</strong>

<strong class="calibre2">Running handlers:</strong>
<strong class="calibre2">Running handlers complete</strong>
<strong class="calibre2">Chef Client finished, 6/10 resources updated in 42.83 seconds</strong>
</pre></div></li></ol><div></div><p class="calibre8">We now have our <a id="id123" class="calibre1"/>Docker host running the nginx Docker container. We can confirm that it is working by going to <code class="literal">http://dockerhost</code>. We should be able to get the following page in the screenshot:</p><div><img src="img/00014.jpeg" alt="Deploying Docker containers" class="calibre10"/></div><p class="calibre11"> </p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec20" class="calibre1"/>Alternative methods</h1></div></div></div><p class="calibre8">There are other general-purpose configuration management tools that allow us to configure our Docker host. The following is a short list of the other tools that we can use:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre2">Puppet</strong>: Refer <a id="id124" class="calibre1"/>to <a class="calibre1" href="http://puppetlabs.com">http://puppetlabs.com</a>.</li><li class="listitem"><strong class="calibre2">Ansible</strong>: This <a id="id125" class="calibre1"/>can be found at <a class="calibre1" href="http://ansible.com">http://ansible.com</a>.</li><li class="listitem"><strong class="calibre2">CFEngine</strong>: This <a id="id126" class="calibre1"/>is available at <a class="calibre1" href="http://cfengine.com">http://cfengine.com</a>.</li><li class="listitem"><strong class="calibre2">SaltStack</strong>: You can find <a id="id127" class="calibre1"/>more on this at <a class="calibre1" href="http://saltstack.com">http://saltstack.com</a>.</li><li class="listitem"><strong class="calibre2">The Docker machine</strong>: This is a very specific configuration management tool that allows us to <a id="id128" class="calibre1"/>provision and configure Docker hosts in our infrastructure. More information about Docker machine can be found on the Docker documentation page at <a class="calibre1" href="https://docs.docker.com/machine">https://docs.docker.com/machine</a>.</li></ul></div><p class="calibre8">If we do not want to manage our Docker host infrastructure at all, we can use Docker hosting services. Popular cloud providers started offering Docker hosts as a preprovisioned cloud image that we can use. Others offer a more comprehensive solution that allows us to interact with all the Docker hosts in the cloud as a single virtual Docker host. The following is a list of links of the popular cloud providers describing their integration with the Docker ecosystem:</p><div><ul class="itemizedlist"><li class="listitem">Google Container <a id="id129" class="calibre1"/>Engine (<a class="calibre1" href="https://cloud.google.com/container-engine">https://cloud.google.com/container-engine</a>)</li><li class="listitem">Amazon <a id="id130" class="calibre1"/>EC2 Container Service (<a class="calibre1" href="http://aws.amazon.com/documentation/ecs">http://aws.amazon.com/documentation/ecs</a>)</li><li class="listitem">Azure Docker <a id="id131" class="calibre1"/>VM Extension (<a class="calibre1" href="https://github.com/Azure/azure-docker-extension">https://github.com/Azure/azure-docker-extension</a>)</li><li class="listitem">Joyent Elastic <a id="id132" class="calibre1"/>Container Service (<a class="calibre1" href="https://www.joyent.com/public-cloud">https://www.joyent.com/public-cloud</a>)</li></ul></div><p class="calibre8">In terms of deploying Docker containers, there are several container tools that allow you to do this. They provide APIs to run and deploy our Docker containers. Some of the offered APIs are even compatible with the Docker engine itself. This allows us to interact with our pool of Docker hosts as if it is a single virtual Docker host. The following is a list of a few tools that allow us to orchestrate the deployment of our containers to a pool of Docker hosts:</p><div><ul class="itemizedlist"><li class="listitem">Docker <a id="id133" class="calibre1"/>Swarm (<a class="calibre1" href="https://www.docker.com/docker-swarm">https://www.docker.com/docker-swarm</a>)</li><li class="listitem">Google <a id="id134" class="calibre1"/>Kubernetes (<a class="calibre1" href="http://kubernetes.io">http://kubernetes.io</a>)</li><li class="listitem">CoreOS <a id="id135" class="calibre1"/>fleet (<a class="calibre1" href="https://coreos.com/fleet">https://coreos.com/fleet</a>)</li><li class="listitem">Mesophere <a id="id136" class="calibre1"/>Marathon (<a class="calibre1" href="https://mesosphere.github.io/marathon">https://mesosphere.github.io/marathon</a>)</li><li class="listitem">SmartDataCenter <a id="id137" class="calibre1"/>Docker Engine (<a class="calibre1" href="https://github.com/joyent/sdc-docker">https://github.com/joyent/sdc-docker</a>)</li></ul></div><p class="calibre8">However, we still need configuration management tools such as Chef to deploy and configure our orchestration systems at the top of our pool of Docker hosts.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch03lvl1sec21" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we learned how to automate the configuration of our Docker deployments. Using Chef allows us to configure and provision multiple Docker hosts in scale. It also enabled us to deploy and orchestrate Docker containers for our application to our pool of Docker hosts. From this point on, you can write Chef recipes to persist all the Docker optimization techniques you will learn in this book.</p><p class="calibre8">In the next chapter, we will introduce instrumentation to monitor our whole Docker infrastructure and application. This will give us further feedback on how to better optimize our Docker deployments for higher performance.</p></div></body></html>