- en: Chapter 10. Implementation of the Deployment Pipeline – The Late Stages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We had to make a break from the implementation of our deployment pipeline and
    explore service discovery and proxy services. Without a proxy service, our containers
    would not be accessible in an easy and reliable manner. To provide all the data
    proxy service needs, we spent some time exploring different options and came up
    with a few combinations that could serve as service discovery solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'With service discovery and proxy services in our tool-belt, we can continue
    where we left and finalize manual execution of the deployment pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Checkout the code – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run pre-deployment tests – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and/or package the code – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the container – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the container to the registry – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the container to the production server – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Integrate the container – Pending
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run post-deployment tests – Pending
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the tests container to the registry – Pending![Implementation of the Deployment
    Pipeline – The Late Stages](img/B05848_10_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10-1 – The intermediate stages of the deployment pipeline with Docker
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We are missing three steps in our deployment pipeline. We should integrate our
    container and, once that is done, run post-deployment tests. Finally, we should
    push our tests container to the registry so that everyone can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll start by bringing up the two nodes we''re using for our deployment pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll use the `prod2.y` `ml` Ansible playbook to provision the `prod` node.
    It contains service discovery and proxy roles that we already discussed in the
    previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Once run, our `prod` node will have Consul, Registrator, Consul Template and
    nginx up and running. They will allow us to proxy all requests to their destination
    services (at the moment only `books-ms`). Let us run the playbook from the `cd`
    node.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Starting the Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we proceed with the integration, we should run the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Since we provisioned this node with Consul and Registrator, IPs and ports from
    those two containers should be available in the registry. We can confirm this
    by visiting the Consul UI from a browser by opening `http://10.100.198.201:850`
    `0/ui`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we click on the **Nodes** button, we can see that the `prod` node is registered.
    Further on, clicking the `prod` node button should reveal that it contains two
    services; `consul` and `books-ms`. The `mongo` container that we started is not
    registered because it does not expose any ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting the Containers](img/B05848_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 10-2 – Consul screenshot with the prod node and services running on it
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the same information by sending a request to Consul:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The first command listed all services registered in Consul. The output is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The second command output all the information related to the `books-ms` services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: With the containers up and running and their information stored in the service
    registry, we can reconfigure nginx so that the `books-ms` service is accessible
    through the standard HTTP port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating the Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by confirming that nginx does not know about the existence of
    our service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'After sending the request, nginx responded with the `404 Not Found` message.
    Let''s change this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We already did most of those steps in the previous chapter so we'll go through
    them very briefly. We entered the `prod` node and downloaded the includes file
    and upstreams template from the code repository. Then we run `consul-template`
    that fetched data from Consul and applied them to the template. The result is
    the nginx upstreams configuration file. Please note that, this time, we added
    the third argument `docker kill -s HUP nginx`. Not only that `consul-template`
    created the configuration file from the template, but it also reloaded nginx.
    The reason that we did those command from the `prod` server instead of doing everything
    remotely like in the previous chapters lies in automation. The steps we just run
    are much closer to the way we'll automate this part of the process in the next
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can test whether our service is indeed accessible through the port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Running Post-Deployment Tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While we did confirm that the service is accessible from nginx by sending the
    request and observing the proper response, this way of verification is not reliable
    if we are trying to accomplish full automation of the process. Instead, we should
    repeat the execution of our integration tests but, this time, using port `80`
    (or no port at all since `80` is standard `HTTP` port):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the output shows that integration tests passed successfully. The
    truth is that we have only one test that makes the same request as the `curl`
    command we run earlier. However, in a `real world` situation, the number of tests
    would increase, and using proper testing frameworks is much more reliable than
    running `curl` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing the Tests Container to the Registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Truth be told, we already pushed this container to the registry to avoid building
    it every time we need it and, therefore, save you from waiting. However, this
    time, we should push it as part of the deployment pipeline process. We are trying
    to run tasks in order of their importance so that we get feedback as fast as possible.
    Pushing containers with tests is very low on our list of priorities, so we left
    it for the end. Now that everything else was run successfully, we can push the
    container and let others pull it from the registry and use it as they see fit.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The Checklist
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We managed to go through the whole deployment pipeline. It took us quite a
    lot of time since we had to take a few brakes and explore different ways to proceed.
    We could not deploy to production without exploring configuration management concepts
    and tools. Later on, we got stuck again and had to learn about service discovery
    and proxy before being able to integrate the service container:'
  prefs: []
  type: TYPE_NORMAL
- en: Checkout the code – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run pre-deployment tests – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and/or package the code – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the container – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the container to the registry – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the container to the production server – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run post-deployment tests – Done
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the tests container to the registry – Done![The Checklist](img/B05848_10_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Figure 10-3 – The late stages of the deployment pipeline with Docker
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now we are all set. We are capable of running the deployment procedure manually.
    The next step is to automate all those commands and start running the pipeline
    automatically from the beginning to the end. We''ll destroy the nodes we used
    so that we can start over fresh and confirm that the automated procedure indeed
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
