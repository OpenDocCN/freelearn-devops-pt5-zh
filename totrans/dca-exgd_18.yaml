- en: Summarizing Important Concepts
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn which topics are most important for the exam
    and you will get a good idea of the knowledge required to pass the **Docker Certified
    Associate** (**DCA**) exam.
  prefs: []
  type: TYPE_NORMAL
- en: We will recap all the topics we have learned regarding orchestration, image
    management, Docker platform component installation and configuration, networking
    implementations for standalone and cluster environments, and security features
    and data management strategies in container-based applications. All these concepts
    were already covered in different chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will summarize the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing orchestration concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief summary of Docker image concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of the Docker architecture, installation, and configuration topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A summary of the networking topics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding security concepts and related Docker features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Quickly summarizing Docker storage and volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be ready for some exam-like questions,
    which have been prepared for you in the next chapter. Before looking at some sample
    questions, let's start talking about the orchestration concepts we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing orchestration concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Orchestration is an important topic for the DCA exam. It represents 25% of the
    questions you have to pass to get this certification. In the second section of
    the book, we introduced orchestration and we covered Docker Swarm and Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration concepts were covered in [Chapter 7](3b13261c-9b4d-46e2-b115-fc323563f646.xhtml),
    *Introduction to Orchestration*, [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*, [Chapter 9](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml),
    *Orchestration Using Kubernetes*, [Chapter 10](3a2d6b8e-40d0-44f2-8a07-75969a28cc6b.xhtml),
    *Introduction to the Docker Enterprise Platform*, and [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a quick summary of the Docker Swarm features. We recommend you read
    this summary to remember the concepts we have learned:'
  prefs: []
  type: TYPE_NORMAL
- en: We started talking about multi-container applications before introducing orchestration
    because it is the first approach to container orchestration. They work locally,
    using Docker Compose (the `docker-compose` tool) and application components, and
    their interaction is described using `docker-compose.yml` YAML files. Multi-container
    applications run all of their components together on a Docker host, but we can
    scale their components up and down, as well as interacting with them and reviewing
    their logs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm orchestrates Docker services to provide them with resilience, internal
    discovery, and load balancing in cluster environments. Our applications' workloads
    will be distributed cluster-wide.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use two kinds of node roles within Docker Swarm—managers and workers—which
    can be modified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will deploy more than one manager and more than one worker to provide high
    availability to the cluster and workloads deployed on top of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the managers is also the leader of the cluster and will update all cluster
    resource changes in an internal database, synced between manager nodes. Docker
    Swarm uses the Raft algorithm to update changes, hence a quorum between managers
    is required before changes are committed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm has a management plane, a control plane, and a data plane. The
    management and control planes can be isolated from the data plane, and they work
    encrypted out of the box. The data plane can also be encrypted but not by default
    (we have to encrypt each custom network).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm issues and maintains an internal **Certificate Authority** (**CA**)
    and manages certificates for all cluster components. We can lock this information
    to keep it safe.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A minimum of (*number of managers / 2 + 1*) healthy manager nodes is required
    to maintain the cluster health. If we have less than the required number, no changes
    can be made within the cluster but application workloads will continue working.
    If a service fails, it will not be recovered if the cluster is unhealthy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm uses the Raft log to maintain internal key-value store synchronization
    between nodes. Therefore, an odd number of managers is required to keep a quorum.
    This also applies to Kubernetes, but it uses `etcd` as a key-value store.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All nodes can run application workloads, but we can change this behavior whenever
    we need draining nodes or to disallow new workloads without interrupting already-running
    ones.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cluster workloads are declared as services, with a required number of instances
    or replicas to be healthy. These resources are tasks and they will run one container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm does not manage containers; it only manages services. Therefore,
    we deploy applications based on services. We do not deploy standalone containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services receive one virtual IP address by default and this address does not
    change during their lifetime. Tasks run only one container; they do not have an
    associated IP address, and they always keep their names. If a task's container
    dies or needs to be modified with some updates, a new task will be created with
    the original name. The container will receive a new IP, but the internal load
    balancer will associate it as a backend endpoint for the service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can scale up or down the number of tasks required for a service whenever
    we need to. However, Docker will not manage our application behavior under these
    circumstances.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks are scheduled automatically on healthy nodes if they have enough resources
    to run associated services' tasks, but we can force a task location on specific
    nodes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker provides some template tools to help us format, filter, and create unique
    resources using Docker Swarm variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking in Docker Swarm uses bridged interfaces, as we also learned with
    Docker containers. We deploy overlay networks distributed cluster-wide using VXLAN
    technology to provide communication between containers running on different hosts
    and other network features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm provides a router mesh as a default strategy to publish cluster
    services for users and other applications. By default, services' ports will be
    published on all cluster nodes even if they do not run any services' tasks. Internal
    routing guides service requests to appropriate backend containers. We can change
    these behaviors with common Docker Swarm command options.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we learned with Docker Engine, services are not published to be consumed
    by default. We need to manually publish service ports and processes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing applications to the world can be done using the router mesh on Docker
    Swarm, or Interlock in Docker Enterprise. Interlock provides an integrated and
    automated reverse-proxy solution to secure your application's backends. We just
    publish the `interlock-proxy` component while the Docker Swarm services receive
    requests internally. Hence, no additional publishing is required for services;
    just configure a few labels to inform Interlock about the required forwarding
    for an application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can create as many overlay networks as required and they will be isolated
    from each other, as we also learned with custom bridge networks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Orchestration introduced some new concepts, such as secrets and configurations,
    to provide stored information that is distributed cluster-wide. Secrets are secured
    and encrypted by Docker Swarm and we use them to configure passwords, certificates,
    or tokens using on-memory filesystems. Configuration objects help us to distribute
    configurations on containers running on different hosts without having to sync
    files between nodes manually.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Docker Swarm, we deploy an application using Docker stacks. These resources
    allow us to deploy multi-service applications that are distributed cluster-wide.
    We will define all the required application resources (services, secrets, networks,
    configurations, volumes, and so on) in a `docker-compose`-like file and we will
    use these files to deploy the complete application. All changes or updates in
    application components should be written in these files because it allows us to
    manage the application's deployments as code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application component updates are managed using rolling updates. We can deploy
    changes manually or using Docker stacks. In both cases, we can deploy changes
    smoothly, avoiding service interruption and user impact. If an update goes bad,
    we can easily execute a rollback to run the previous service configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also reviewed the Kubernetes orchestrator because it is included in Docker
    Enterprise. This orchestrator has many differences from Docker Swarm, although
    both manage containers at the end. We learned all about Kubernetes components
    and their interactions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Enterprise deploys full vanilla (non-customized) Kubernetes for us out
    of the box, including Calico as a **Container Network Interface** (**CNI**) by
    default. All worker nodes (DTR requires dedicated workers) can be set to run either
    Docker Swarm, Kubernetes workloads, or even both orchestrator workloads.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pods are the smallest scheduling unit in Kubernetes but they do not provide
    resilience. We need to integrate them on orchestrated templated resources, such
    as ReplicaSets, DaemonSets, or deployments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes provides a flat network. This means that all pods that are deployed
    will see each other. Service-to-service communications are always allowed by default.
    To ensure security in this situation, we need to deploy NetworkPolicy resources
    to allow only specific component communications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although Docker stacks and multi-container applications using `docker-compose`
    use the same type of YAML files, some keys are only valid for one of them. For
    example, keys such as `depends_on`, `build`, or `volumes_from` are only available
    for Docker Compose multi-container applications; therefore, we will receive a
    warning message indicating this issue when we try to use them for Docker stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review the required topics for the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Required knowledge for the exam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exam will verify our knowledge of the following topics, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Completing the setup of a Swarm mode cluster, with managers and worker nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to extend the instructions to run individual
    containers into running services under Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the importance of a quorum in a Swarm cluster
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the difference between running a container and running a service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interpreting the output of the `docker inspect` commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Converting an application deployment into a stack file using a YAML compose
    file with `docker stack deploy`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating a running stack of services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating orchestration activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the number of replicas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding networks and publishing ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mounting volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to run replicated and global services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying node labels to demonstrate the placement of tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to use templates with `docker service create`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the steps needed to troubleshoot a service that is not deploying
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing how a Dockerized application communicates with legacy systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing how to deploy containerized workloads as Kubernetes pods and deployments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing how to provide configuration for Kubernetes pods using ConfigMap
    and secret resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics are extracted from Docker's official study guide, which can be
    found at [https://success.docker.com/certification](https://success.docker.com/certification).
  prefs: []
  type: TYPE_NORMAL
- en: A brief summary of Docker image concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Images are fundamental to creating containers, and this topic represents around
    20% of the DCA exam questions. We covered Docker images in depth in [Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    *Building Docker Images*, but we also talked about them in [Chapter 3](c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml),
    *Running Docker Containers*, [Chapter 6](e9fd3807-5bbd-4ea8-84f7-ee02d288643d.xhtml),
    *Introduction to Docker Content Trust*, and *[Chapter 13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml),
    Implementing an Enterprise-Grade Registry with DTR*. In this chapter, we will
    quickly review all of the concepts seen in those chapters as a summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review the most important concepts, features, and actions associated
    with Docker images before getting into the required knowledge section:'
  prefs: []
  type: TYPE_NORMAL
- en: Images are based on copy-on-write filesystem strategies. They are based on different
    overlapping layers, applied using different union filesystems and storage drivers.
    Currently, the most used filesystem driver for containers is `overlay2`. Docker
    Engine chooses the most adequate graph driver for our system, although we can
    change it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers are just isolated processes running on Docker hosts. We use images
    as templates to provide a root filesystem and meta-information to control processes'
    behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are three methods for creating images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using a Dockerfile**: This file contains all the steps required to install
    our application with all its dependencies, as well as how it should be started.
    We also provide which ports and protocols should be used to communicate with the
    container''s processes. This method is reproducible and it provides infrastructure-as-code
    behavior.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Running containers and committing**: In this case, we run a container, and
    inside, we run commands to install and configure our applications. When all the
    changes are made in the container''s filesystem, we commit those changes to make
    an image. This method is not reproducible. We usually use this workflow when application
    installation cannot be automated, for example.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Images from scratch**: In this case, images are lightweight because they
    just include an empty root filesystem with application binaries and dependencies.
    This root filesystem does not include any non-required operating system files.
    We add our binaries using Dockerfile copy keys.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-stage building can also be included as an alternative method for creating
    images. In this case, we declare different build processes in just one Dockerfile.
    We define a descriptive name for each one and we define a workflow, copying files
    from different builds. This allows us to define a phase to compile an application
    using the required compilers, headers, or libraries on an application-development
    image and just copy the final development product to another phase, with a runtime
    environment. As a result, the runtime image is much smaller than the development
    one.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dockerfiles create images by executing containers. Each container makes changes
    in its root filesystem and these changes will be committed (stored) for subsequent
    containers, using the previous container's layers for execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smaller images are more secure because having non-required binaries, libraries,
    and configurations inside images is risky. Images should only contain the required
    content for our application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are a few important practices to follow to build better images:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Never add debugging tools or compilers to production images.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Declare all required resources on your images, such as exposed ports, the user
    required for the main process execution, and the directories that will be used
    as volumes. These will help other users to easily understand how your application
    works and should be used.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Do not use root on your application's images unless it is strictly required
    by processes to work.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Build your images to run just one process per container. With many processes
    per container, it is hard to maintain and verify their health.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We always have to choose between the portability of layers between images and
    the images' sizes. There are cases where it is better to have fewer layers, while
    at other times it is better to have more layers because others will reuse them.
    Image layer caching is key to speeding up the image building process.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Always add health checks inside your Dockerfiles to help Docker Engine verify
    the container's health.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker provides all of the required commands for building and shipping Docker
    images. We can also inspect their content or build history to help us debug their
    processes or create new images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is key to understand that dangling images, unreferenced layers from previous
    builds, will stay in your Docker hosts until you remove them. Administrators should
    keep the Docker platform clean to avoid hosts degrading due to disk space being
    lost.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good image tagging is fundamental on container platforms. We can also use labels
    on Dockerfiles to add meta-information to Docker images. You should try to uniquely
    identify images by their tags, but remember that only an image's ID will really
    identify an image uniquely. An image can have many names and tags, but only one
    ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can include variables inside Dockerfiles. This will help us to build images
    with special features for different stages. We can deliver a production-ready
    image into production systems while having debugging and instrumentation tools
    on testing images. They will still have common application binaries but we will
    use a debugging version to review some specific problems. Variables can also be
    modified as arguments for the `docker build` command line.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get an idea of the topics required for the exam.
  prefs: []
  type: TYPE_NORMAL
- en: Required image management knowledge for the exam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exam will verify our knowledge of the following topics, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing the use of a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing options, such as `add`, `copy`, `volumes`, `expose`, and `entrypoint`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying and displaying the main parts of a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to create an efficient image via a Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to use CLI commands to manage images, such
    as `list`, `delete`, `prune`, and `rmi`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to inspect images and report specific attributes
    using `filter` and `format`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to tag an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to apply a file to create a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to display the layers of a Docker image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to modify an image to a single layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating registry functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging into a registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Utilizing search in a registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pushing an image to a registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing an image in a registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pulling and deleting images from a registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics are extracted from Docker's official study guide, which can be
    found at [https://success.docker.com/certification](https://success.docker.com/certification).
  prefs: []
  type: TYPE_NORMAL
- en: A summary of the Docker architecture, installation, and configuration topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The installation and configuration of the Docker platform are key to every Docker
    Enterprise administrator. These topics represent 15% of the exam content. They
    were covered in multiple chapters for standalone and cluster environments. We
    learned about these concepts in [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml),
    *Modern Infrastructures and Applications with Docker*, [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*, [Chapter 10](3a2d6b8e-40d0-44f2-8a07-75969a28cc6b.xhtml),
    *The Docker Enterprise Platform*, [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*, and [Chapter 13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml),
    *Implementing an Enterprise-Grade Registry with DTR*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a quick summary of special characteristics and tips for the installation
    and configuration of the Docker platform. We recommend that you read this summary
    to ensure you remember the concepts learned:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker components on standalone and cluster environments**: We should have
    a good idea of Docker Enterprise component distribution and features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The installation processes for each component on different platforms**: We
    have seen that installation is easy in both the Docker Community and Docker Enterprise
    environments. Review the installation processes for the different platforms and
    ensure that you have a good idea of the configuration file locations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You must know all the components' requirements and the steps required to deploy
    a **Container-as-a-Service** (**CaaS**) enterprise-ready solution, with high availability
    on core components.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*, showed many configuration procedures for Docker
    Engine. By default, Docker will choose the best storage driver for your Docker
    layers. Remember that we used `overlay2` because we should be able to change it
    if our installation has different requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that you have a good understanding of what files are under the `/var/lib/docker`
    directory (or the one configured) and what should be stored in your Docker Engine's
    backups. You also learned about the procedures to create **Universal Control Plane**
    (**UCP**) and **Docker Trusted Registry** (**DTR**) backups and the steps and
    cases where restoration is required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only Docker Enterprise and Kubernetes provide role-based access. We covered
    basic Docker Enterprise permissions and configurations for UCP and DTR in [Chapter
    11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal Control Plane*, and
    [Chapter 13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml), *Implementing an Enterprise-Grade
    Registry with DTR*, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Review how we configured TLS communications for client authentication when we
    do not need different levels of authorization. This was covered in [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml),
    *Modern Infrastructures and Applications with Docker*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cgroups and kernel namespaces provide container isolation. These are key to
    ensuring processes have enough resources without any non-authorized communication
    with other processes running on the same host.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now review which topics should be known about for the exam.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge required about the Docker platform for the exam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exam will verify our knowledge of the following topics, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing sizing requirements for installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating the setup of a repo, the selection of a storage
    driver, and the installation of the Docker engine on multiple platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating the configuration of logging drivers (`splunk`,
    `journald`, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to set up Swarm, configure managers, add nodes,
    and set up the backup schedule
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to create and manage users and teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to configure the Docker daemon to start on
    boot
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to use certificate-based client-server authentication
    to ensure a Docker daemon has the right to access images on a registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the use of namespaces, cgroups, and certificate configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and interpreting errors to troubleshoot installation issues without
    assistance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating the steps to deploy Docker Engine, UCP, and DTR
    on **Amazon Web Services** (**AWS**) and on-premises with high availability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to configure backups for UCP and DTR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics are extracted from Docker's official study guide, which can be
    found at [https://success.docker.com/certification](https://success.docker.com/certification).
  prefs: []
  type: TYPE_NORMAL
- en: A summary of the networking topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Networking is one of the core components of microservice application architecture.
    Faster networks allowed the evolution of distributed architectures. High availability
    and resilience can be provided using modern infrastructures, even on cloud or
    cloud-hybrid architectures. Containers work like small virtual nodes and they
    get virtual interfaces. We learned that network namespaces allow us to isolate
    processes on the same host, even if they use the same bridge interface to communicate
    with the real network, out of the host's network namespaces. Distributed networking
    on clusters is also simple because Docker Swarm manages all the internal infrastructures
    and processes required to allow communication between containers on different
    hosts. Overlay networks in Docker Swarm, distributed cluster-wide, use VXLAN to
    encapsulate traffic and can even be encrypted. By default, the Docker Swarm control
    plane's components are secured using **Mutual TLS** (**MTLS**) communication and
    we can isolate application data from network management.
  prefs: []
  type: TYPE_NORMAL
- en: All of these topics were covered in multiple chapters on Docker Engine, Docker
    Swarm, and Kubernetes. We learned about these topics in [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*, [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*, [Chapter 9](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml),
    *Orchestration Using Kubernetes*, [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*, and [Chapter 12](ab131f1f-ca6e-4815-9a3a-8c92c93c9dbc.xhtml),
    *Publishing Applications in Docker Enterprise.*
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 9](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml), *Orchestration Using
    Kubernetes*, we learned how Kubernetes implements network features cluster-wide.
    We also reviewed these features side by side against Docker Swarm implementations
    to have a good idea of how we can use both or make container workloads that can
    run on any of them.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that containers can expose their application processes internally.
    Other containers can consume their services but we need to publish their ports
    for external users and applications. This is very important because security is
    ensured in Docker Swarm for containers working in the same network. They are isolated,
    hence we can publish only frontend applications' components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some network topics as a summary:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine networking is based on bridge networking, although we can use
    MacVLAN interfaces (with real IP addresses), underlying the host's networking
    (using its network namespace), and can even extend default behavior using plugins.
    We can use default or custom bridge networking. Custom networks also deploy internal
    DNS facilities, hence, containers running on these networks will know each other
    by their names. In some special cases, it is useful to deploy containers without
    networking features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Networking in Docker Swarm is easy because Docker creates new virtual networks
    (overlay networks) and deploys VXLAN tunnels to encapsulate all hosts' traffic.
    Containers deployed for services' tasks can see each other if they are working
    on the same overlay network.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Kubernetes network model is even easier. It is based on a flat network where
    services and pods are always reachable by default. For this to work, we need to
    integrate a CNI. Each CNI has its own implementation of this flat network model
    and Docker Enterprise deploys Calico ([https://www.projectcalico.org/](https://www.projectcalico.org/))
    by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A flat network is unsecured by default because applications' components are
    not isolated. We will use network policies to isolate applications, grouping them
    by namespaces, labels, and so on. NetworkPolicy resources manage connection rules
    to allow or disallow specific pods' connections and hence their traffic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm nodes use encrypted TLS communications by default (mutual TLS).
    Docker manages all of the required certificates. Users' communications with the
    cluster are not secure, but we can also create secure communications manually
    (we have a complete example explaining all of the required steps in [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*) or use UCP-integrated **Role-Based Access
    Control** (**RBAC**). UCP provides users with bundles, containing all the required
    files to create secure TLS tunnels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes also encrypts its control plane. Docker Enterprise does all the deployment
    work for us and a fully functional Kubernetes cluster will be up and running after
    its installation. Certificates will be used to deploy TLS tunnels between Kubernetes
    components and users by default.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal DNS is deployed for local custom bridge and overlay networks. Therefore,
    containers and services can be discovered by their names. Containers use an internal
    DNS and an external resolution will be forwarded to a specific external DNS. By
    default, containers receive the host's DNS configuration, but we can change this
    behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes also integrates an internal DNS. In this case, the `kube-dns` component
    will manage all service entries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internal load balancing is also deployed in overlay networks. Remember that
    services can be replicated or global. In both cases, `vip` mode is used by default,
    and services get an IP address in the special ingress network. This IP address
    is registered and the internal load balancer will route requests to all available
    services' replicas. We can avoid this behavior using the `dns-round-robin` mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes' internal load balancing has similar behavior. All services will
    receive an internal virtual IP address by default (a ClusterIP). Services in Kubernetes
    are logical groups of pods and services' requests will be forwarded by default
    to all associated pods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned before, an application deployed within containers will not publish
    their ports unless we declare this behavior. Publishing ports on Docker Engine
    is easy and we can ensure that only specific IP addresses will listen on a published
    port on multi-homed nodes. Bridge networking uses NAT for publishing an application's
    ports. Docker creates all of the required hosts' firewall rules to allow and route
    this traffic. If we use the host's networking, all container-exposed ports will
    be published and applications will be directly accessible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also learned that services in Docker Swarm will be published by default in
    all nodes, even if they do not run any services' tasks. This feature is known
    as a router mesh and application ports will be available in all of the clusters'
    hosts. Internal load balancing will also be applied using an ingress overlay network
    and instances in different hosts will be reachable. This can be insecure because
    all application ports will be accessible on all hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes' `NodePort` services have equivalent behavior to Docker Swarm's router
    mesh. Services declared as `NodePort` will publish their ports on all cluster
    nodes. However, Kubernetes also has the `LoadBalancer` service type. These services
    will be published directly using infrastructure load balancers. This integration
    only works on some cloud providers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UCP provides Interlock as a solution to avoid unsecured router mesh publishing.
    We have learned about Interlock's components and deployment and how we publish
    applications using this tool. Interlock's ports must be published, but all other
    applications' services can be accessed through Interlock. Therefore, we do not
    need to publish applications' ports. This improves security because Interlock
    acts as a reverse proxy, providing TLS security, host- and content-based services
    routing, and sticky sessions, among others. The Interlock proxy component will
    be updated using services' labels; therefore, only services with specific labels
    will be published. We have learned about these required labels and reviewed a
    few examples of their usage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes can integrate ingress controllers to avoid `NodePort` cluster-wide
    application publishing. Ingress controllers deploy reverse-like proxy features
    to route requests to appropriate services matching specific headers or content
    rules. This improves security because services should not be published. We just
    publish ingress controllers (using service strategies, for example), and ingress
    resources manage the necessary rules for reaching out to the desired services,
    although they are not externally published.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, networking is critical in cluster environments. Let's review some
    of the topics required to pass the exam.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker networking knowledge required for the exam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exam will verify our knowledge of the following topics, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing the container network model and how it interfaces with Docker Engine
    and network and IPAM drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the different types and use cases for built-in network drivers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the types of traffic that flow between Docker Engine, registry, and
    UCP controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to create a Docker bridge network for developers
    to use for their containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to publish a port so that an application is
    accessible externally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying which IP and port a container is externally accessible on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing and contrasting host and ingress publishing modes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to configure Docker to use an external DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to use Docker to load balance HTTP/HTTPS traffic
    to an application (configuring L7 load balancing with Docker EE).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding and describing the types of traffic that flow between Docker Engine,
    registry, and UCP controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to deploy a service on a Docker overlay network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to troubleshoot container and engine logs to
    resolve connectivity issues between containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing how to route traffic to Kubernetes pods using the ClusterIP and NodePort
    services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the Kubernetes container network model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics are extracted from Docker's official study guide, which can be
    found at [https://success.docker.com/certification](https://success.docker.com/certification).
  prefs: []
  type: TYPE_NORMAL
- en: The next section will help you by presenting the required knowledge in relation
    to security on the Docker platform.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding security concepts and related Docker features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is crucial when you are running applications in production. We have
    learned about many security features provided by Docker and its components. We
    started by reviewing how containers are isolated from other host processes and
    we also learned how we can ensure security in Docker Engine. Then, we moved on
    to Docker Swarm, where security must be applied cluster-wide. Users' access must
    also be managed and we need to provide authentication and authorization mechanisms.
    Docker Enterprise provides a higher level of security. It includes a complete
    RBAC environment, which allows us to manage fine-grained permissions to objects
    and cluster resources.
  prefs: []
  type: TYPE_NORMAL
- en: All of these topics were covered in multiple chapters on Docker Engine, Docker
    Swarm, Kubernetes, and the Docker Enterprise platform. We learned about security
    in [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml), *Modern Infrastructures
    and Applications with Docker*, [Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    *Building Docker Images*, [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*, [Chapter 6](e9fd3807-5bbd-4ea8-84f7-ee02d288643d.xhtml),
    *Introduction to Docker Content Trust*, [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*, [Chapter 9](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml),
    *Orchestration Using Kubernetes*, [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*, [Chapter 12](ab131f1f-ca6e-4815-9a3a-8c92c93c9dbc.xhtml),
    *Publishing Applications in Docker Enterprise*, and [Chapter 13,](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml)
    [](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml) *Implementing an Enterprise-Grade
    Registry with DTR**.*
  prefs: []
  type: TYPE_NORMAL
- en: We have to remember that containers are created using images, so securing images
    is also critical. Following good practices is key to developing safe images. Docker
    Enterprise provides several strategies to validate image precedence, immutability,
    and content security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s review some of these security topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a client-server application. The server will publish its API on local
    (by default) and remotely accessible sockets. We can limit Docker Engine access
    by limiting access to these sockets. Locally, only users with filesystem permissions
    to a defined socket file will be allowed to run Docker commands on the local Docker
    engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Engine can be integrated with operating system-provided security modules,
    such as SELinux or AppArmor. Docker provides integration and default profiles
    to use with our containers. Docker also integrates with the Linux kernel to allow
    the adding or removing of specific system calls using capabilities. There are
    also simpler security tips, such as using read-only root filesystems and non-root
    users within containers, that will also help us to provide secure applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images should be secure to create secure containers. Images should only contain
    the required binaries, libraries, and configurations for our processes. Everything
    irrelevant to the application should be avoided. Docker Enterprise provides an
    image's content security scanner. It compares relevant content file hashes against
    a database of well-known published vulnerabilities and exploits (internet **Common
    Vulnerabilities and Exposures** (**CVE**)). We learned how this process works
    and how we can integrate tag promotions to ensure that only allowed users get
    the appropriate access to their images. These are some of the DTR features.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also sign images. This process ensures image content immutability and
    ownership. If we integrate image building into our continuous integration and
    continuous deployment, we can ensure that images were created using an appropriate
    workflow. We can also improve our CaaS security, allowing only containers based
    on images signed by specific teams or users within your organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned about all the automatic steps to be followed to sign an image and
    all the keys integrated into the process. Image signing is based on Content Trust
    logic, and we learned how it is integrated in Docker in [Chapter 6](e9fd3807-5bbd-4ea8-84f7-ee02d288643d.xhtml),
    *Introduction to Docker Content Trust*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We mentioned some simple practices that increase security in our workloads,
    such as running read-only root filesystems or using non-root users for applications
    (or user namespaces). We should review an image's specifications using `docker
    image inspect` to have a good idea of exposed ports, applications' users, and
    commands that will be executed inside containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned in this chapter, neither Docker Engine nor Docker Swarm have any
    RBAC integration. On the other hand, Docker Enterprise components have integrated
    role-based access. UCP provides different accesses to Docker Swarm resources based
    on roles, grants, and collections. We can configure fine-grained access to volumes,
    secrets, configs, networks, and so on, so users will only be able to execute allowed
    actions on their resources. Users will connect to the cluster to execute, review,
    and modify their resources by using either the provided web UI or their Docker
    command line, using their Docker client software and their UCP's bundle. This
    compressed file contains user certificates and environment scripts prepared to
    help users connect easily to the cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DTR has its own RBAC environment, isolated from that of UCP. DTR is a registry,
    therefore its RBAC environment is dedicated to managing access to the images stored
    within your CaaS. We have fine-grained permissions to allow a group of users to
    use or modify images, while other images are public within teams or the full organization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DTR and UCP are integrated by default in a single sign-on solution, although
    we can change this behavior. We can also integrate them into our organization
    user management solution, Active Directory, or any compatible **Lightweight Directory
    Access Protocol** (**LDAP**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to deploy Docker Enterprise components and how to manage users,
    roles, and different levels of access to resources and images. They will be deployed
    with high availability using an odd number of software nodes and we will require
    an external load balancer to provide users' access. We can integrate our corporate
    certificates, but we can also use autogenerated ones. In this case, we will need
    to integrate DTR's CA in our organization server and client hosts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although Docker Swarm requires UCP to integrate user management, Kubernetes
    implements its own RBAC system. We will be allowed to authenticate and authorize
    users using tokens and certificates. Kubernetes RBAC will work for applications
    and users and it is integrated into Docker Enterprise.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Swarm and Kubernetes provide secure storage for certificates, passwords,
    tokens, and so on. Both provide secret resources to manage any file (or variable)
    that should be protected from suspicious users. But while secrets are encrypted
    in Docker Swarm, they are not encrypted in Kubernetes by default. Secret resources
    are encoded using Base64 in Kubernetes, and additional configuration must be performed
    to encrypt them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes has advanced features regarding security, such as PodSecurityPolicy
    resources, which allow us to force security on pods, allowing or disallowing specific
    behaviors (root processes and read-only filesystems). Admission controllers can
    also be implemented (there are a few already configured by default in UCP's Kubernetes
    deployment) to force pod security policies and other security features by default
    to any workload deployed in our Kubernetes cluster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will use RBAC for either UCP and DTR user accesses. First, we will ensure
    only authorized users will be able to manage and use cluster resources for their
    applications. DTR's RBAC will protect images, allowing only authorized users to
    manipulate and update their content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next section will highlight the knowledge required to pass the exam.
  prefs: []
  type: TYPE_NORMAL
- en: The knowledge of Docker security required for the exam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exam will verify our knowledge of the following topics, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Describing security administration and tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the process of signing an image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing default engine security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing Swarm default security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing MTLS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing identity roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing and contrasting UCP workers and managers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the process of using external certificates with UCP and DTR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how an image passes a security scan
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to enable Docker Content Trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to configure RBAC with UCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to integrate UCP with LDAP/AD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to create UCP client bundles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These topics are extracted from Docker's official study guide, which can be
    found at [https://success.docker.com/certification](https://success.docker.com/certification).
  prefs: []
  type: TYPE_NORMAL
- en: Quickly summarizing Docker storage and volumes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Docker containers requires different storage solutions, as we have learned
    through this book. Images and containers are created using multiple-layer filesystem
    strategies. However, we also have to manage persistence in our container-based
    applications. This persistence can be associated with application data, but we
    also have to be able to manage configurations and states cluster-wide.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about security in [Chapter 1](c5ecd7bc-b7ed-4303-89a8-e487c6a220ed.xhtml),
    *Modern Infrastructures and Applications with Docker*, [Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    *Building Docker Images*, [Chapter 4](e7804d8c-ed8c-4013-8449-b746ee654210.xhtml),
    *Container Persistency and Networking*, and [Chapter 13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml),
    *Implementing an Enterprise-Grade Registry with DTR.*
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a quick summary of the topics looked at in this book regarding storage
    and volume management within containers. We recommend you read through this summary
    to ensure you remember the concepts learned:'
  prefs: []
  type: TYPE_NORMAL
- en: We learned that containers are based on different filesystems and solutions
    with a common feature – copy-on-write. This allows us to create multiple immutable
    layers to group files. Each layer is the base for another, and file modifications
    will be stored in the last layer where they were changed. All immutable layers
    are considered as the image for the creation of new containers. We will add a
    new read-and-write layer for the container. These layers rely on host storage.
    This storage is known as graph storage and we will use different strategies to
    manage it, depending on the host operating system. Docker will choose the best
    driver for your host according to your kernel features and installed drivers.
    The most popular and most widely used today is `overlay2`, which is the default
    graph driver for many Linux distributions. `docker info` provides information
    about the driver used.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have also learned that images are stored locally for fast usage on your host.
    When these images must be shared with cluster nodes, things get difficult, although
    we can export and import image layers. We will use image registries to store images
    and share their content with hosts and users. We learned how to deploy Docker
    Registry (Community Edition) as well as DTR, which is recommended for enterprise
    environments. We can use different storage solutions for registry volumes, depending
    on whether we are using cloud environments or on-premises installations. As reviewed
    in [Chapter 13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml), *Implementing an
    Enterprise-Grade Registry with DTR*, object storage is quite good for storing
    images based on big layers, which is the most common way of creating images.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images can occupy a lot of space in your host. We should take care of this and
    review dead containers and unused images that are consuming space with `docker
    system df`. We should remove dangling images not used as a layer within any other
    images. We also have to take care of the space on our registries. Only keep required
    images, but remember to verify which containers or applications will use different
    old image versions. We learned how to filter this information in [Chapter 2](3952ec16-ca49-4bc2-b7e6-d6f17fec3fab.xhtml),
    *Building Docker Images*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumes, on the other hand, are different from image and container storage.
    They are used to bypass container storage. These help us to improve performance
    when a lot of disk I/O is required, and also allow us to store persistent data.
    By default, we can use on-memory filesystems, a host's local directories (bind
    mounts), NFS, and Docker volumes for storage. Docker volumes are associated with
    a container's life cycle when they are created during their execution.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As mentioned, Docker provides some volume solutions by default. We can extend
    them using plugins and third-party integrations. Using distributed storage with
    Docker Swarm and UCP is critical if we need to provide high availability to our
    applications using resilience. If one cluster host dies, another will take its
    workloads by default, but storage must follow this behavior.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes has a different approach to persistent data. We talked about volumes
    and persistent volumes (`persistentVolumes`). The former are used to share and
    manage data associated with pods' containers. On the other hand, persistent volumes
    are used to manage and persist data cluster-wide. There are different retention
    policies to manage their recycling cycles. Persistent volume claims (`persistentVolumeClaims`)
    are used to link pods with volumes using labels and required space among other
    parameters. Therefore, instead of using persistent volumes directly attached to
    pods, we will use `persistentVolumeClaims` inside pods' configurations as volumes.
    Administrators should create these resources, but they can avoid this behavior
    by using `storageClass` resources. They will just configure `storageClass` resources
    using labels, storage providers, and other advanced profiles to allow dynamic
    storage allocation for persistent volumes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned that Docker provides `Config` and `Secret` objects to allow us to
    manage information in cluster nodes. These help us to configure applications and
    ensure that applications' containers receive appropriate configurations, passwords,
    certificates, and so on. Kubernetes has its own configuration and secret resources.
    To manage configurations, we will use ConfigMaps for storing an application's
    configuration files and managing environment variables. Secret resources are used
    to store secured data, but they are not encrypted by default in Kubernetes. They
    are stored using the Base64 format and can be used for either storing keys and
    values or files.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing data and states is quite important and is part of the exam. Let's review
    what concepts you are required to understand to pass the exam.
  prefs: []
  type: TYPE_NORMAL
- en: The storage and volume knowledge required for the exam
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The exam will verify our knowledge of the following topics, among others:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying the correct graph drivers to use with various operating systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how to configure a device mapper
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparing and contrasting object and block storage and when they should be used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing how an application is composed of layers and where those layers reside
    on the filesystem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the use of volumes with Docker for persistent storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identifying the steps to take to clean up unused images on a filesystem and
    DTR
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing and demonstrating how storage can be used across cluster nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing how to provision persistent storage to a Kubernetes pod using `persistentVolume`
    resources.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Describing the relationship between container storage interface drivers, `storageClass`,
    `persistentVolumeClaim`, and `volume` objects in Kubernetes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will look at some final notes and sample exam questions to help us prepare
    for the DCA exam in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a summary of the topics required to pass the exam. We reviewed
    the topic distribution and their approximate value in the exam. This should give
    you a good idea of what sections are more important than others. We recommend
    that you review this chapter before reading all the exam-like questions set out
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We covered a brief summary of orchestration's most important topics. We also
    reviewed some of the installation and configuration tips required for Docker Engine,
    Docker Swarm, and Enterprise components. We looked at a summary of the features
    and processes involved in the creation of images. Security is always critical
    and we looked at a summary of the features provided by different Docker components
    that help us to provide a CaaS platform in production. Container networking and
    the different storage implementations for containers and images and for data management
    were also reviewed. It is recommended that you review any chapters that were not
    clear in these summaries and review the labs provided in this book to reinforce
    your knowledge of all the exam topics.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter provides some exam-like questions that will prepare you for
    the exam.
  prefs: []
  type: TYPE_NORMAL
