<html><head></head><body>
<div><div><div><h1 id="_idParaDest-16" class="chapter-number"><a id="_idTextAnchor023"/>1</h1>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor024"/>Choosing the Right Approach – <a id="_idTextAnchor025"/>Declarative or Imperative</h1>
			<p>Welcome to the first chapter of <em class="italic">Infrastructure as Code for Beginners</em>. In this book, we will be going on a journey that will take you through your first Infrastructure-as-Code deployment, and it is an <a id="_idTextAnchor026"/>honor to be accompanying you.</p>
			<p>Before we dive into the tools we will be using throughout the book, we are first going to discuss some of the key concepts to try and get an understanding of the problems that you could try to solve by introducing Infrastructure as Code into your deployments.</p>
			<p>We will be covering the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor027"/>The challenges of managing infrastructure manually</li>
				<li><a id="_idTextAnchor028"/>What is meant by declarative and imperative?</li>
				<li><a id="_idTextAnchor029"/>Pets versus cattle</li>
				<li><a id="_idTextAnchor030"/>What does all this mean for our Infrastructure-as-Code deployments?</li>
			</ul>
			<h1 id="_idParaDest-18"><a id="_idTextAnchor031"/>The challenges of managing infrastructure manually</h1>
			<p>Before we look at some<a id="_idIndexMarker000"/> of the challenges you may be facing, I quickly wanted to take you through my journey with<a id="_idTextAnchor032"/> Infrastructure as Code before it was really what we now know as Infrastructure as Code.</p>
			<p>When I talk about Infrastructure as Code, I mean the following:</p>
			<p><em class="italic">Infrastructure as Code is an approach to infrastructure management where it is provisioned and managed using code and automation tools rather than manually configuring resources through a </em><em class="italic">user interface.</em></p>
			<p><em class="italic">This allows you to version control, track, and manage your infrastructure in the same way you do with application code and, in many cases, use the same tooling, processes, and procedures you already have </em><em class="italic">in place.</em></p>
			<p><em class="italic">Infrastructure as Code can help improve your infrastructure operations’ efficiency, reliability, and reproducibility by introducing consistency across your deployments and reducing deployment times versus more traditional </em><em class="italic">manual deployments.</em></p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor033"/>My own journey</h2>
			<p>I have been working<a id="_idIndexMarker001"/> with servers of all types for longer than I care to remember; back when I first started working with servers, it was all very much a manual process to do pretty much anything.</p>
			<h3>The bare-metal days</h3>
			<p>Before <em class="italic">virtualization</em> became a common practice, I remember<a id="_idIndexMarker002"/> having to block out a whole day to build a customer’s server. This process would generally start with ensuring that the hardware I was given to work with was of the correct specification – if for some reason it wasn’t, which was quite common, then I would typically have to replace RAM and hard drives, and so on.</p>
			<p>This was to ensure that I didn’t get too far into configuring the server, only to find that I had to tear it down and start from scratch; once the hardware was confirmed as being correct, it was time to start on the build itself.</p>
			<p>Typically, to build the server, I sat in a tiny, hot, and noisy build room surrounded by equipment, bits of computer, and what felt like reams of paper, which contained not only instructions on how to manually install the various operating systems we supported but also build sheets containing configuration and information on the customer’s required software stack I was deploying.</p>
			<p>Once built, the server was packed back into its box, put in the back of someone’s car, and taken to a data center. From there the server was racked and cabled for both power and networking and then powered the server on – if everything was configured correctly, it would spring into life and be available on the network.</p>
			<p>After some quick testing, it was back to the comfort of the office to complete the build steps and, finally, hand the server over to the customer for them to deploy their software on.</p>
			<p>While this process was fine when there was one or two of these deployments, once in a blue moon, as things got busier, it quickly became unmanageable.</p>
			<p>The next logical step was to have a build server that contained drive images for all the supported operating systems and base software stack configurations, with some custom scripts that ran when the server first booted to customize the base configuration and get it onto the network when<a id="_idIndexMarker003"/> the server was racked in the data center.</p>
			<h3>Enter virtualization</h3>
			<p>Once we started to move from<a id="_idIndexMarker004"/> provisioning bare metal servers for customers to virtualized servers, things got a lot easier – for a start, as you didn’t have to physically connect RAM, CPUs, or hard drives to the servers, assuming the cluster you were building the server in had the resource available, it made quite a dramatic change to the deployment time and also resulted in less time in the build room and data center.</p>
			<p>At this point, we had built up a collection of custom scripts that connected to both the virtualization hypervisors and virtual machines – these were shared between the team members in our subversion repository and documented in our internal wiki.</p>
			<p>This was my first, extremely basic by today’s standards, introduction to Infrastructure as C<a id="_idTextAnchor034"/>ode.</p>
			<h3>Virtual machine configuration</h3>
			<p>The next logical steps were<a id="_idIndexMarker005"/> to add a remote configuration<a id="_idIndexMarker006"/> into the mix by using a tool, such as<a id="_idTextAnchor035"/> <strong class="bold">Puppet</strong> or <strong class="bold">Chef</strong>; we could deploy our virtual machines using our custom scripts and then have the servers<a id="_idIndexMarker007"/> call back to our main management server, and then bootstrap itself as per the customer’s desired configuration state.</p>
			<h3>Putting it all t<a id="_idTextAnchor036"/>ogether</h3>
			<p>This was the final piece<a id="_idIndexMarker008"/> of the puzzle, which took our deployments from taking a few days per server to an hour or so, with the bulk of that time waiting for automated tasks to complete – though, as a lot of the initial stages of the deployments were initiated by our in-house DIY scripts, we still had to keep a careful eye on the progress.</p>
			<p>This was because there wasn’t much logic built in to handle errors or other unexpected hiccups during the deployment, which, in some cases, resulted in some challenging post-deployment problems – but the least<a id="_idIndexMarker009"/> said about those, the better.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor037"/>Today’s challenges</h2>
			<p>So, how do today’s challenges<a id="_idIndexMarker010"/> differ from my own experiences? During my day job, I get to work with a lot of internal and external teams who are nearly all technical and are very hands-on with the day-to-day management and development of their own applications.</p>
			<h3>It’s all documented</h3>
			<p>When discussing Infrastructure as Code<a id="_idIndexMarker011"/> with teams, one of the most common answers I get is as follows:</p>
			<p>“<em class="italic">We have the process to deploy our infrastructure documented, and anyone in the team can work through it to quickly deploy </em><em class="italic">a resource.</em>”</p>
			<p>While it is great that there is documentation and that it is accessible by all of the members of the team, you would be surprised, even with the presence of comprehensive and easy-to-follow documentation, at just how much variance there is when people come to actually implement it. They don’t fully understand it because it is simply a set of tasks that lack any context as to why the tasks are being actioned.</p>
			<p>Another potential issue is that the process is followed so often by a member of the team that they simply just get on with it, missing any updates or steps that have been added to the documentation.</p>
			<p>Worst still – and this is more common than you may think – giving three technical people the same set of tasks to do can sometimes result in three very different outputs, as everyone has different experiences, which normally feeds into how we do things – for example, <em class="italic">last time I tried to A, B, and C, X happened, so now I do it C, B, and A</em> or <em class="italic">I think it would better to do it B, A, and then C – but don’t have time at the moment to update </em><em class="italic">the documentation</em>.</p>
			<p>All of these can introduce inconsistencies in your deployments, which may go unnoticed as everyone thinks they are doing it correctly<a id="_idIndexMarker012"/> because they are all following the same set of documentation.</p>
			<h3>Next, next, next</h3>
			<p>The <em class="italic">next</em> (pun very much intended) answer I normally get is this:</p>
			<p>“<em class="italic">We don’t need to do it very often, and when we do, it’s just clicking ‘next, next, next’ in an interface – anyone can </em><em class="italic">do it</em>.”</p>
			<p>When I get this answer, what I actually hear is, <em class="italic">The process to deploy the resource is so easy that we didn’t bother to document it</em>. While this might be the case for some members of the team, not everyone may have the experience or confidence to simply click <em class="italic">next, next, next</em> to deploy and configure the resources without a guide.</p>
			<p>As I am sure you can imagine, if it is possible for inconsistencies to be present when everyone is following the same<a id="_idIndexMarker013"/> set of documentation, then doing the deployment without any of the guardrails that the documentation puts in place is going to introduce even more potential issues further down the line.</p>
			<p>Just because a resource has been deployed without error and works does not mean that it has been deployed securely and in such a way that could support your production workloads.</p>
			<h3>We have everything we need</h3>
			<p>The final most common answer when discussing Infrastructure as Code is as follows:</p>
			<p>“<em class="italic">We have deployed everything we need and don’t need any </em><em class="italic">further resources.</em>”</p>
			<p>Again, when I get this answer, I normally hear something slightly different – in my experience, this normally means that, a while ago, someone deployed something that is more than capable of the task and has now moved on, either going on to another project or department or has left the company altogether.</p>
			<p>While it is great that the resources are running fine, this approach can cause issues if you ever need to redeploy or, worse still, firefight an issue with production, as a lot of knowledge of the underlying configuration is missing.</p>
			<p>So, while you know <em class="italic">what’s there</em>, you may not necessarily know <em class="italic">why</em>.</p>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor038"/>Conclusion</h2>
			<p>There are many more <a id="_idIndexMarker014"/>examples, but the previous ones are the most common ones I see when working with teams who may not have considered Infrastructure as Code to be a foundation of their deployment pipelines, and if you are reading this, then you may have already come across some of the examples and want to move onto the next step.</p>
			<p>So why would you take an Infrastructure-as-Code approach to your deployments? Well, there are several reasons, which include the following:</p>
			<ul>
				<li><strong class="bold">Documentation</strong>: While we have already mentioned<a id="_idIndexMarker015"/> documentation, it’s important to note that if you employ Infrastructure as Code, your deployment is documented as part of your code as it defines the desired state of your infrastructure in a human-readable format.</li>
				<li><strong class="bold">Repeatable and consistent</strong>: You should be able to pick up your code and deploy it repeatedly – sure, you may make some changes to things such as resource SKUs and names, but that should just be a case of updating some variables that are read at the time of execution rather than rewriting your entire code base.</li>
				<li><strong class="bold">Time-saving</strong>: As I mentioned, in my own experience, it sometimes took days to deploy resources – eventually, that got down to hours and, with more modern cloud-based resources, minutes.</li>
				<li><strong class="bold">Secure</strong>: Because you have your infrastructure defined in code, you know that you will have a well-documented end-to-end configuration ready to review as needed. Because it is easily deployable, you can quickly spin up an environment to review or deploy your latest fixes into, safe in the knowledge that it is consistent with your production configuration, as you are not relying on someone manually working through a step-by-step document where something may get missed or misinterpreted.</li>
				<li><strong class="bold">Cost savings</strong>: I think you should never approach an Infrastructure-as-Code deployment with cost savings being at the top of the list of things you would like to achieve – but it is a most welcome nice-to-have. Depending on your approach, cost savings can be a byproduct of the preceding points. For example, do you need to run your development or testing infrastructure 24/7 when your developers may only need it for a few days a week at most?</li>
			</ul>
			<p>Well, that infrastructure can be deployed as part of your build pipeline with next to no or little effort. In that case, you<a id="_idIndexMarker016"/> may find yourself in the enviable position of only paying for the resources when you need them rather than paying for them to be available 24/7.</p>
			<p>So, now that we have discussed my personal journey with Infrastructure as Code and also gotten an idea of the different scenarios where Infrastructure as Code may come in useful and the potential reasons<a id="_idIndexMarker017"/> why you would want to incorporate it into your day-to-day workflows, let’s now discuss some of the basic concepts you need to know about before we start to talk about the tools we are going to look at for the remaind<a id="_idTextAnchor039"/>er of the book.</p>
			<h1 id="_idParaDest-22">What is meant b<a id="_idTextAnchor040"/>y declarative and imperative?</h1>
			<p>In programming, there are different ways to give instructions to a computer to achieve the programmer’s desired result. These<a id="_idIndexMarker018"/> ways of telling the computer what to do are known as <strong class="bold">programming paradigms</strong>.</p>
			<p>In general, they refer to how we build programs from logical ideas such as <code>if</code> statements or loops. There are other classifications as well: functional, structured, object-oriented, and so on. Each of these describes a different kind of task that programmers might perform when writing code or thinking about code.</p>
			<p><strong class="bold">Imperative</strong> and <strong class="bold">declarative</strong> programming is the most fundamental way<a id="_idIndexMarker019"/> in which programmers<a id="_idIndexMarker020"/> think about defining their tasks and the two main ways in which we need to think about how we write and structure our Infrastructure as Code.</p>
			<p>Before we discuss each way, let us define a quick Infrastruct<a id="_idTextAnchor041"/>ure-as-Code project.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor042"/>Basic Infrastructure-as-Code project</h2>
			<p>The following diagram<a id="_idIndexMarker021"/> shows the basic infrastructure for deploying a single virtual machine i<a id="_idTextAnchor043"/><a id="_idTextAnchor044"/><a id="_idTextAnchor045"/>n Microsoft Azure:</p>
			<div><div><img src="img/Figure_1.01_B19537.jpg" alt="Figure 1.1 – The basic Infrastructure-as-Code project diagram" width="1465" height="484"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fi<a id="_idTextAnchor046"/>gure 1.1 – The basic Infrastructure-as-Code project diagram</p>
			<p>As you can see, the project<a id="_idIndexMarker022"/> is made up of the <a id="_idTextAnchor047"/>following compo<a id="_idTextAnchor048"/>nents:</p>
			<ul>
				<li><code>rg-iac-example-uks-001</code>) – This is a logical container in Azure<a id="_idIndexMarker023"/> t<a id="_idTextAnchor049"/>o store the reso<a id="_idTextAnchor050"/>urces.</li>
				<li><code>vnet-iac-example-uks-001</code>) – This is a virtual network that<a id="_idIndexMarker024"/> will host our example virtual machine.</li>
				<li><code>snet-iac-example-uks-001</code>) – This is not shown in the diagram, but the virtual network <a id="_idIndexMarker025"/>c<a id="_idTextAnchor051"/>ontains a single subnet.</li>
				<li><code>nsg-iac-example-uks-001</code>) – As we don’t want management ports such as <code>3389</code> (RDP) or <code>22</code> (SSH) open to anyone on the internet, this will add <a id="_idIndexMarker026"/>some basic rules to only accept traffic on these ports from trusted sources. This will be attached to the subnet, so the rules apply to all <a id="_idTextAnchor052"/>resources deployed there.</li>
				<li><code>vm-iac-example-uks-001</code>) – This, as you may have guessed, is th<a id="_idTextAnchor053"/>e virtual machine<a id="_idIndexMarker027"/> itself.</li>
				<li><code>nic-iac-example-uks-001</code>) – Here, we have the network interface, which will be attached to the virtual<a id="_idIndexMarker028"/> machine and the subnet within the virtual network.</li>
				<li><code>pip-iac-example-uks-001</code>) – Finally, we have the public IP address; this is going to be attached<a id="_idIndexMarker029"/> to the network interface, which will allow us to route to the virtual machine from the trusted locations defined in the network<a id="_idIndexMarker030"/> security<a id="_idTextAnchor054"/> group.</li>
			</ul>
			<p>While this is a basic infrastructure example, there are quite a few different resources involved in the deployment. Also, as we are going to be talking at a very high level about how this could be deployed, we won’t be going into too much detail on Azure itself just yet, as this will be covered in <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <a id="_idTextAnchor055"/><a id="_idTextAnchor056"/><em class="italic">Deploying to </em><em class="italic">Microsoft Azure</em>.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor057"/>Declarative approach</h2>
			<p>When talking about<a id="_idIndexMarker031"/> my own experiences, I mentioned that I used a configuration tool; in my case, this was Puppet. Puppet uses declarative language to define the target configuration – be it a software stack or infrastructure – but what does that mean?</p>
			<p>Rather than try and give an explanation, let’s jump straight in and describe how a declarative tool would deploy our infrastructure.</p>
			<p>In its most basic configuration, a declarative tool only cares about the end state and not necessarily how it gets to that point. This means the tool, unless it is told to be, isn’t resource-aware, meaning<a id="_idIndexMarker032"/> that when the tool is executed, it decides the order in which the resources are going to be deployed.</p>
			<p>For our example, let us assume that the tool uses the following<a id="_idTextAnchor058"/> order to deploy our resources:</p>
			<ul>
				<li>Virtual network</li>
				<li>Resource group</li>
				<li>Network security group</li>
				<li>Subnet</li>
				<li>Public IP address</li>
				<li>Virtual machine</li>
				<li>Network interface</li>
			</ul>
			<p>On the face of it, that doesn’t look too bad; let us explore how this ordering affects the deployment of our resources in Azure.</p>
			<p>The following figure shows the<a id="_idTextAnchor059"/> results of the deployments:</p>
			<div><div><img src="img/Figure_1.02_B19537.jpg" alt="Figure 1.2 – The results of deploying our infrastructure using a declarative tool" width="964" height="1082"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – The results of deploying our infrastructure using a declarative tool</p>
			<p>As you can see, it took three<a id="_idIndexMarker033"/> deployments for all the resources to be successfully deployed, so why was that?</p>
			<ul>
				<li><strong class="bold">Deployment 1</strong>: The virtual network failed to be deployed as <a id="_idTextAnchor060"/>it needed to be placed with the resource group, which wasn’t deployed yet. As all the remaining resources had a dependency on the virtual network, they also failed, meaning the only successful resource to be deployed during the first execution was the resource group, as that had no dependencies.</li>
				<li><strong class="bold">Deployment 2</strong>: As we had the resource group in place from <strong class="bold">Deployment 1</strong>, then this time around, the virtual network and subnet both deployed; how<a id="_idTextAnchor061"/>ever, because the deployment of the network security group was attempted before the subnet was successfully deployed, that failed. <a id="_idTextAnchor062"/>The remaining failed resources – the public IP address and virtual machine – both failed because the network interface hadn’t been created yet.</li>
				<li><strong class="bold">Deployment 3</strong>: With the final set of dependencies in place from <strong class="bold">Deployment 2</strong>, the remaining resources – the network security group, public IP address, and virtual machine – all launched successfully, which finally left us with our desired end state.</li>
			</ul>
			<p>The term for this is <strong class="bold">eventual consistency</strong>, as our desired end state is eventually deployed <a id="_idIndexMarker034"/>after several executions.</p>
			<p>In some cases, the failures during the initial deployment of the resources don’t really matter too much as our desired<a id="_idIndexMarker035"/> end state is eventually reached – however, with infrastructure, and depending on your target cloud environment, that may not always be true.</p>
			<p>In the early days of Infrastructure as Code, this was quite a large issue as you had to build logic to consider dependencies for the resources you were deploying – which not only meant that you had to know what the dependencies were but the bigger your deployment, the more inefficient it became.</p>
			<p>This is because the more logic you start adding to the code, the more you start working against the declarative nature of the tool, which also carries the risk of introducing race conditions when the code is executed. For example, if you have one resource that takes five minutes to deploy – how do you know it’s ready? This would mean even more logic, which, if you got it wrong or something unexpected happened, you could be sat waiting for the execution to eventually time out.</p>
			<p>Fear not; things have most definitely improved as the development of the tools has matured, and the tools have become more resource-aware. A lot of the manual logic you had to employ <a id="_idIndexMarker036"/>is now unnecessary, but there are still some considerations t<a id="_idTextAnchor063"/>ha<a id="_idTextAnchor064"/>t we will go into in more detail in <a href="B19537_02.xhtml#_idTextAnchor085"><em class="italic">Chapter 2</em></a>, <em class="italic">Ansible and T<a id="_idTextAnchor065"/>erraform beyond </em><em class="italic">the Documentation</em>.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor066"/>Imperative approach</h2>
			<p>As you may have already <a id="_idIndexMarker037"/>guessed, when using an imperative approach, the tasks execute in the order you define them – and we know the order in which we need to run the tasks to deploy our resources, which is as follows:</p>
			<ul>
				<li>Resource group</li>
				<li>Virtual network</li>
				<li>Subnet</li>
				<li>Network security group</li>
				<li>Network interface</li>
				<li>Public IP address</li>
				<li>Virtual machine</li>
			</ul>
			<p>It means that the result of running our first deployment will look like the following:</p>
			<div><div><img src="img/Figure_1.03_B19537.jpg" alt="Figure 1.3 – The results of deploying our infrastructure using an imperative tool" width="964" height="702"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – The results of deploying our infrastructure using an imperative tool</p>
			<p>Great, you may be thinking to yourself, it works the first time! Well, sort of; there is a big assumption that you know the order in which your resources need to be deployed, and you need to structure the code in such a way that takes that into account.</p>
			<p>So, while this way would typically work first when executed, there could potentially be a little more upfront work to get the scripts in the right order using a little trial and error – however, once they are in the correct order, you can be confident that each time you execute them, they will work the first time.</p>
			<p>Now that we have discussed<a id="_idIndexMarker038"/> the key differences between declarative and imperative when it comes to Infrastructure as Code, let’s now talk about the differences between another deploym<a id="_idTextAnchor067"/>ent approach, pets versus cattle.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor068"/>Pets versus cattle</h1>
			<p>Traditionally, <em class="italic">pets or cattle</em> has been a way of defining<a id="_idIndexMarker039"/> your data center resources. It’s an analogy<a id="_idIndexMarker040"/> that describes a collection<a id="_idIndexMarker041"/> of hardware or virtualized resources as either pets or cattle.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor069"/>Pets</h2>
			<p>Pets are resources that<a id="_idIndexMarker042"/> are owned by individual users/teams or managed on an individual basis.</p>
			<p>Normally, they are seen as import<a id="_idTextAnchor070"/>ant fixed points within any application architecture and,<a id="_idTextAnchor071"/> like with a pet, you do the following:</p>
			<ul>
				<li><code>backendapplication.server.domain.com</code>, so it is easily identifiable.</li>
				<li><strong class="bold">You feed and water them</strong>: For example, you take and keep backups that you review regularly. You keep a close eye on resource utilization and add more RAM and drive space as required.</li>
				<li><strong class="bold">If they get ill, you care for them</strong>: They have monitoring agents installed, meaning you are alerted if there is a problem – sometimes 24/7 – and if there is an issue, you do everything you can to restore service by having troubleshooting procedures in place.</li>
				<li><strong class="bold">You expect them to live for a long time</strong>: Given their importance within your application architecture and that you are caring for them, you expect them to be around for quite a while.</li>
			</ul>
			<p>Resources that are now considered pets have typically been around for some time, and their configuration has organically evolved over that time based on their utilization, making them each a unique deployment, which is why you care for them, just like having a real pet – a good example of this is a long-running server.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor072"/>Cattle</h2>
			<p>With resources that<a id="_idIndexMarker043"/> have been deployed to be treated as cattle, you only care about the health of the herd and not an individual resource:</p>
			<ul>
				<li><code>beapp001.server.domain.com</code> to <code>beapp015.server.domain.com</code>; you just keep incrementing the number rather than assigning a unique name that makes them easily identifiable.</li>
				<li><strong class="bold">You watch them from afar</strong>: Given the number of resources, you only really care about the availability of the herd, meaning you probably only just ship performance stats and logs from the resources, and you do not need to back them up as it would be quick to replace them.</li>
				<li><strong class="bold">If they get ill, you replace them</strong>: As already mentioned, if there is an issue with a resource, rather than troubleshoot the problem, you terminate it and replace it with another resource ASAP. Typically, this process is automated so that a resource is quickly taken out of service and another one put in place.</li>
				<li><strong class="bold">You don’t expect them to live for a long time</strong>: Given their numbers, they can be quite short-lived – in some cases, resources may only exist for a short amount of time to handle an increase in the workload. Once the demand for additional resources has ceased, some of the resources are terminated.</li>
			</ul>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor074"/>Conclusion</h2>
			<p><em class="italic">Pets versus cattle</em> mainly applies to application deployment<a id="_idIndexMarker044"/> strategies rather than purely just the underlying infrastructure. After all, let’s say your application, for whatever reason, needs to run as a single fixed point – for example, your application does the following:</p>
			<ul>
				<li>Writes essential files to the local disc, which can’t be lost if an instance is terminated</li>
				<li>Has manual steps for bringing an application instance online after it has been deployed</li>
				<li>Is licensed to a MAC address or CPU ID of a host</li>
			</ul>
			<p>In this case, you may not be able to treat your deployments as cattle, but you can write your Infrastructure as Code so that the bulk of your deployment is as automated as possible.</p>
			<p>These are technical reasons, but there are some considerations from a business point of view as well.</p>
			<p>The one that will get most businesses’ attention is cost efficiency. Your choice of either a pets or cattle approach could have a significant impact on your hosting costs.</p>
			<p>The cattle approach, which treats servers as ephemeral resources, allows for better resource utilization and automated scaling, potentially reducing costs. On the other hand, deploying pets, which emphasizes individual server care, may result in higher maintenance and management costs but could be justified for mission-critical applications that demand special attention.</p>
			<p>Taking a cattle approach enables faster deployment and scaling of your workloads; this allows businesses to respond more quickly to market changes and customer needs. Deploying pets might lead to longer deployment times, potentially impacting a company’s competitiveness.</p>
			<p>Regulatory and security requirements could also influence the choice between pet and cattle deployments. The pets approach, focusing on managing individual resources, may be more appropriate for businesses with strict regulatory or security requirements, as it allows for more fine-grained control and auditing of server configurations. However, the cattle approach, emphasizing automation and rapid scaling, might not provide the same level of control and may require additional efforts to ensure compliance and security.</p>
			<p>Now that we have a good <a id="_idIndexMarker045"/>idea of the type of deployments you could be dealing with, let’s now talk about what this means for an Infrastructure-as-Code deployment.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor075"/>What does all this mean for our Infrastructure-as-Code deployments?</h1>
			<p>So far, we have spoken <a id="_idIndexMarker046"/>a lot about some of the approaches and journeys people take to get to the point where they are considering using Infrastructure as Code, so before we look at some of the toolings in <em class="italic">Chapter 2</em>, <em class="italic">Ansible and Terraform beyond the Documentation</em>, let’s talk about some of the actual use cases.</p>
			<p>In my opinion, the most significant<a id="_idIndexMarker047"/> <a id="_idTextAnchor076"/>advantage of using Infrastructure as Code is <strong class="bold">consistency</strong> – if you need to repeat a process or deployment more than once, then define your deployment as Infrastructure as Code.</p>
			<p>This will make sure that resources are deployed the same every time, no matter who is deploying them; if everyone is using the same set of code, then it stands to reason that the outputs will be the same (apart from variables you allow to override the values on such as SKUs, resource names, etc.).</p>
			<p>An Infrastructure-as-Code approach not only gives you consistency between team members deploying the code but also between environments. Before I started defining my deployments as Infrastructure as Code, configuration drift between environments was quite a significant issue – environments were online for so long that <em class="italic">tweaks</em> were being applied and not carried through, so when code moved between my development, test, and finally, production environments, unexpected things would start to happen.</p>
			<p>Next up is <strong class="bold">collaboration</strong>; as your infrastructure is defined in code, you can<a id="_idIndexMarker048"/> use the same development workflows you use for your applications. I am sure that most of you use a version control system for your code, more than likely Git via hosted services such as GitHub, GitLab, BitBucket, or Azure DevOps – if so, you have everything in place to track changes and collaborate on your infrastructure configuration.</p>
			<p>You can also extend this further by introducing branching and pull requests based on your existing procedures to encourage change and testing, making the ongoing maintenance and development of your Infrastructure-as-Code projects genuinely <strong class="bold">collaborative</strong>.</p>
			<p>Once you have your Infrastructure as Code hosted in version control, you can also take advantage of <strong class="bold">automation</strong>, again using the same processes and pipelines you use to build your application – using services such as GitHub Actions or Azure DevOps Pipelines.</p>
			<p>Using services such as these gives you the ability to execute tasks from a single location that is covered by the service’s role-based access control, rather than being reliant on each member of the team downloading and running the Infrastructure-as-Code deployments locally.</p>
			<p>If a team member would be running it locally, then that would mean that each team member who needs access to deploy would also need quite a high level of access to target resources – such as the public cloud you are deploying to.</p>
			<p>Using <strong class="bold">automation</strong> solutions such as the ones mentioned previously<a id="_idIndexMarker049"/> means that you can allow people to use credentials in their pipelines without them having to know what the credentials are. This means you can grant the individuals a lower level of access to your resources – such as <em class="italic">read-only</em> – as they only need to view resources rather than manage them.</p>
			<p>One significant side effect of this approach is that because people don’t have a level of access outside of the automation, they won’t be tempted to <em class="italic">quickly jump into the portal and make a change to fix something manually</em> and instead will need to update the code and do a deployment, meaning that the change is tracked and the execution logged, so you know who did what, when, and why.</p>
			<p>Finally, something<a id="_idIndexMarker050"/> that we have already mentioned – <strong class="bold">cost savings</strong>. If you have your Infrastructure-as-Code deployments in version control and automated, then it’s not a stretch to deploy your infrastructure as needed rather than running it 24/7.</p>
			<p>For example, if you have a pipeline<a id="_idIndexMarker051"/> to build your application, once that pipeline has successfully executed, then it can trigger, which builds the infrastructure – once built, that in turn triggers a deployment, and from there, your tests can run against the deployment and freshly deployed resources. The results of the test can be stored, and the infrastructure is then torn down as it is no longer needed.</p>
			<p>This end-to-end process may take half an hour – but that’s that half an hour’s worth of resource cost versus paying for 24/7 resource costs – which I am sure you will agree is quite a saving.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor077"/>Summary</h1>
			<p>In this chapter, we discussed and covered some of the core concepts we will be following throughout the remainder of the book. We talked about my own journey with Infrastructure as Code, which we will be picking up in further chapters.</p>
			<p>We discussed some of the common questions that get raised when discussing Infrastructure-as-Code projects, along with some of the positive and negative feedback you may get. Then we went on to talk about the differences between the two deployment approaches.</p>
			<p>The first is <strong class="bold">declarative</strong> and <strong class="bold">imperative</strong>, which is how your deployment code is executed and in which order.</p>
			<p>The second approach we discussed, pets versus cattle, while not strictly an Infrastructure-as-Code method, does have relevance to the approach you would take to writing your Infrastructure-as-Code scripts.</p>
			<p>As we get more hands-on, I will share some of my own challenges and successes with Infrastructure as Code.</p>
			<p>Speaking of getting more hands-on, in our next chapter, <a href="B19537_02.xhtml#_idTextAnchor085"><em class="italic">Chapter 2</em></a>, <em class="italic">Ansible and Terraform beyond the Documentation</em>, we are going to look at two of the most common Infrastructure-as-Code tools and start looking at some actual Infrastructure-as-Code examp<a id="_idTextAnchor078"/>les, as well as get an idea of how concepts such as <strong class="bold">declarative</strong> and <strong class="bold">imperative</strong> apply to them. Plus, we will be covering some tips and tricks based on my own experience with the two tools.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor079"/>Further reading</h1>
			<p>Here are links to more information on some of the topics, tools, and services that we have covered in this chapter:</p>
			<ul>
				<li>Puppet: <a href="https://www.puppet.com/">https://www.puppet.com/</a></li>
				<li>Chef: <a href="https://www.chef.io/">https://www.chef.io/</a></li>
				<li>Microsoft Azure: <a href="https://azure.microsoft.com/">https://azure.microsoft.com/</a></li>
				<li>GitHub: <a href="https://github.com/about">https://github.com/about</a></li>
				<li>GitLab: <a href="https://about.gitlab.com">https://about.gitlab.com</a></li>
				<li>BitBucket: <a href="https://bitbucket.org/product">https://bitbucket.org/product</a></li>
				<li>Azure DevOps Repos: <a href="https://azure.microsoft.com/en-us/products/devops/repos/">https://azure.microsoft.com/en-us/products/devops/repos/</a></li>
				<li>GitH<a id="_idTextAnchor084"/>ub Actions: <a href="https://github.com/features/actions">https://github.com/features/actions</a></li>
				<li>Azure DevOps Pipelines: <a href="https://protect-eu.mimecast.com/s/8fwmCjvkghnR9PJIRuMq_?domain=azure.microsoft.com/">https://protect-eu.mimecast.com/s/8fwmCjvkghnR9PJIRuMq_?domain=azure.microsoft.com/</a></li>
			</ul>
		</div>
	</div>
</div>
</body></html>