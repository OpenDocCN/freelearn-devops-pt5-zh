- en: Orchestrating Containers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器编排
- en: In the earlier chapters, we laid down a strong foundation on the need for container
    networking, how to run a service inside a Docker container, and how to expose
    this service to the outside world by opening up network ports and other prerequisites.
    However, recently, there are advanced mechanisms being made available and a few
    third-party orchestration platforms hitting the market for sagaciously establishing
    dynamic and decisive linkages between distributed and differently-enabled containers
    in order to compose powerful containers for comprehensively, yet compactly containing
    process-centric, multi-tiered, and enterprise-class distributed applications.
    In the extremely diversified yet connected world, the concept of orchestration
    cannot be kept away from the deserved prominence for long. This chapter is precisely
    allocated for explaining the nitty-gritty of container orchestration, and its
    direct role is in picking up discrete containers to systematically compose sophisticated
    containers that are more directly aligned with the varying business expectations
    and expediencies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经为容器网络的需求打下了坚实的基础，讨论了如何在Docker容器中运行服务，以及如何通过开放网络端口和其他前提条件将该服务暴露给外部世界。然而，最近，出现了一些先进的机制，并且一些第三方编排平台也进入了市场，旨在巧妙地建立分布式且功能各异的容器之间的动态和决定性连接，以便为处理中心、分层和企业级分布式应用程序组合出强大的容器。在这个高度多样化但又紧密相连的世界里，容器编排的概念不可能长期被忽视。本章正是为了详细解释容器编排的细节，其直接作用是从一组离散的容器中系统地组合出更符合不同业务需求和期望的复杂容器。
- en: 'In this chapter, we will discuss the following topics in detail:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将详细讨论以下主题：
- en: Linking containers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接容器
- en: Orchestrating containers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器编排
- en: Orchestrating containers using the `docker-compose` tool
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker-compose`工具编排容器
- en: As mission-critical applications are overwhelmingly being built through loosely
    coupled, yet highly cohesive components/services destined to run on geographically-distributed
    IT infrastructures and platforms, the concept of composition is getting a lot
    of attention and attraction. For sustaining the well-begun containerization journey,
    the orchestration of containers is being prescribed as one of the most critical
    and crucial requirements in the ensuing, instant-on, adaptive, and smart IT era.
    There are a few proven and promising methods and standards-compliant tools for
    enabling the enigmatic orchestration goals.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 随着关键任务应用程序越来越多地通过松散耦合、但高度凝聚的组件/服务构建，并且这些组件/服务将在地理分布的IT基础设施和平台上运行，组合的概念受到了越来越多的关注和重视。为了保持容器化进程的顺利推进，容器编排被视为在随之而来的即时启动、适应性强且智能的IT时代中的关键要求之一。现在有一些经过验证的、有前景的方法和符合标准的工具，用于实现这个神秘的编排目标。
- en: Docker inbuilt service discovery
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker内置的服务发现
- en: The Docker platform inherently supports the service discovery for the containers
    that are attached to any user-defined network using an embedded **Domain Name
    Service** (**DNS**). This functionality has been added to Docker since the version
    `1.10`. The embedded DNS feature enables the Docker containers to discover each
    other using their names or aliases within the user-defined network. In other words,
    the name resolution request from the container is first sent to the embedded DNS.
    The user-defined network then uses a special `127.0.0.11` IP address for the embedded
    DNS, which is also listed in `/etc/resolv.conf`.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Docker平台本身支持通过嵌入式**域名服务**（**DNS**）为附加到任何用户定义网络的容器提供服务发现功能。自`1.10`版本以来，Docker就加入了此功能。嵌入式DNS功能使得Docker容器能够通过它们的名称或别名在用户定义的网络中互相发现。换句话说，容器的名称解析请求首先发送到嵌入式DNS。用户定义的网络随后使用一个特殊的`127.0.0.11`
    IP地址为嵌入式DNS提供服务，这个地址也列在`/etc/resolv.conf`中。
- en: 'The following example will help to gain a better understanding of Docker''s
    built-in service discovery capability:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将帮助更好地理解Docker内置的服务发现功能：
- en: 'Let''s begin by creating a user-defined bridge network, `mybridge`, using the
    following command:'
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先通过以下命令创建一个用户定义的桥接网络`mybridge`：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inspect the newly created network to understand the subnet range and gateway
    IP:'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查新创建的网络以了解子网范围和网关IP：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, the subnet assigned to the `mybridge` network is `172.18.0.0/16` and the
    gateway is `172.18.0.1`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`mybridge`网络分配的子网是`172.18.0.0/16`，网关是`172.18.0.1`。
- en: 'Now, let''s create a container by attaching it to the `mybridge` network, as
    shown here:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个容器并将其连接到 `mybridge` 网络，如下所示：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Continue to list the IP address assigned to the container, as illustrated here:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续列出分配给容器的IP地址，如下所示：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Evidently, the `testdns` container is assigned a `172.18.0.2` IP address. The `172.18.0.2` IP
    address is from the subnet of the `mybridge` network (that is, `172.18.0.0/16`).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`testdns` 容器被分配了一个`172.18.0.2`的IP地址。这个`172.18.0.2` IP 地址来自 `mybridge` 网络的子网（即`172.18.0.0/16`）。
- en: 'Having got the IP address of the container, let''s look into the content of
    the `/etc/resolv.conf`  file of the container using the `docker container exec`
    subcommand, as shown here:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获得容器的IP地址后，让我们使用 `docker container exec` 子命令查看容器的 `/etc/resolv.conf` 文件内容，如下所示：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here the `nameserver` is configured as `127.0.0.11`, which is the IP address
    of the embedded DNS.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`nameserver` 配置为 `127.0.0.11`，这是嵌入式DNS的IP地址。
- en: 'As a final step, let''s ping the `testdns` container using the `busybox` image.
    We picked the `busybox` image here because the `ubuntu` image is shipped without
    the `ping` command:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，让我们使用 `busybox` 镜像来 ping `testdns` 容器。我们选择 `busybox` 镜像，因为 `ubuntu` 镜像不包含
    `ping` 命令：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Awesome, isn't it! The folks behind Docker have made it so simple that with
    no effort we are able to discover the containers in the same network.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了，不是吗！Docker背后的开发团队将其做得如此简单，以至于我们几乎无需任何努力，就能发现同一网络中的容器。
- en: Linking containers
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接容器
- en: Before the introduction of the concept of the user-defined network, container
    linking was predominantly used for inter-container discovery and communication.
    That is, cooperating containers can be linked together to offer complex and business-aware
    services. The linked containers have a kind of source-recipient relationship,
    wherein the source container gets linked to the recipient container, and the recipient
    securely receives a variety of information from the source container. However,
    the source container will know nothing about the recipients to which it is linked.
    Another noteworthy feature of linking containers in a secured setup is that the
    linked containers can communicate using secure tunnels without exposing the ports
    used for the setup to the external world. Though you will find lots of deployments
    that use container-linking techniques, they are cumbersome and time-consuming
    to configure. Also, they are error-prone. So the new method of embedded DNS is
    highly preferred over the traditional container-linking techniques.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在引入用户定义网络的概念之前，容器链接主要用于容器间的发现和通信。也就是说，协作容器可以相互链接，提供复杂且具业务意识的服务。链接的容器之间具有某种源-目标关系，其中源容器会链接到目标容器，而目标容器会安全地接收来自源容器的各种信息。然而，源容器对其链接的目标容器一无所知。另一个值得注意的特点是，在安全设置下，链接容器可以通过安全隧道进行通信，而不暴露设置所使用的端口给外部世界。虽然你会发现许多部署使用容器链接技术，但它们配置繁琐且耗时，同时也容易出错。因此，嵌入式DNS的新方法被高度偏好，胜过传统的容器链接技术。
- en: The Docker Engine provides the `--link` option in the `docker run` subcommand
    to link a source container to a recipient container.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 引擎在 `docker run` 子命令中提供了 `--link` 选项，用于将源容器与目标容器连接起来。
- en: 'The format of the `--link` option is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`--link` 选项的格式如下：'
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `<container>` is the name of the source container and `<alias>` is the
    name seen by the recipient container. The name of the container must be unique
    in a Docker host, whereas alias is very specific and local to the recipient container,
    and hence, the alias need not be unique in the Docker host. This gives a lot of
    flexibility to implement and incorporate functionalities with a fixed source alias
    name inside the recipient container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<container>` 是源容器的名称，`<alias>` 是目标容器看到的名称。容器的名称在 Docker 主机中必须是唯一的，而别名非常具体并且局限于目标容器，因此别名在
    Docker 主机中不必唯一。这为在目标容器中实现和集成功能提供了很大的灵活性，可以使用固定的源别名名称。
- en: 'When two containers are linked together, the Docker Engine automatically exports
    a few environment variables to the recipient container. These environment variables
    have a well-defined naming convention, where the variables are always prefixed
    with the capitalized form of the alias name. For instance, if `src` is the alias
    name given to the source container, then the exported environment variables will
    begin with `SRC_`. Docker exports three categories of environment variables, as
    enumerated here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个容器被链接在一起时，Docker引擎会自动将一些环境变量导出到目标容器。这些环境变量有明确的命名规则，变量名称总是以别名的大写形式作为前缀。例如，如果`src`是源容器的别名，那么导出的环境变量将以`SRC_`开头。Docker导出三类环境变量，如下所示：
- en: '`NAME`: This is the first category of environment variables. These variables
    take the form of `<ALIAS>_NAME`, and they carry the recipient container''s hierarchical
    name as their value. For instance, if the source container''s alias is `src` and
    the recipient container''s name is `rec`, then the environment variable and its
    value will be `SRC_NAME=/rec/src`.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NAME`：这是第一类环境变量。这些变量的形式为`<ALIAS>_NAME`，其值为目标容器的层次名称。例如，如果源容器的别名是`src`，目标容器的名称是`rec`，则环境变量及其值为`SRC_NAME=/rec/src`。'
- en: '`ENV`: This is the second category of environment variables used to export
    the environment variables configured in the source container by the `-e` option
    of the `docker run` subcommand or the `ENV` instruction of the `Dockerfile`. This
    type of an environment variable takes the form of `<ALIAS>_ENV_<VAR_NAME>`. For
    instance, if the source container''s alias is `src` and the variable name is `SAMPLE`,
    then the environment variable will be `SRC_ENV_SAMPLE`.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ENV`：这是第二类环境变量，用于导出源容器中通过`docker run`子命令的`-e`选项或`Dockerfile`的`ENV`指令配置的环境变量。这类环境变量的形式为`<ALIAS>_ENV_<VAR_NAME>`。例如，如果源容器的别名是`src`，变量名是`SAMPLE`，则环境变量为`SRC_ENV_SAMPLE`。'
- en: '`PORT`: This is the final and third category of environment variables that
    is used to export the connectivity details of the source container to the recipient.
    Docker creates a bunch of variables for each port exposed by the source container
    through the `-p` option of the `docker run` subcommand or the `EXPOSE` instruction
    of the `Dockerfile`.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PORT`：这是第三类也是最后一类环境变量，用于导出源容器的连接详细信息到目标容器。Docker会为源容器通过`docker run`子命令的`-p`选项或`Dockerfile`的`EXPOSE`指令暴露的每个端口创建一组变量。'
- en: 'These variables take the `<ALIAS>_PORT_<port>_<protocol>` form. This form is
    used to share the source''s IP address, port, and protocol as a URL. For example,
    if the source container''s alias is `src`, the exposed port is `8080`, the protocol
    is `tcp`, and the IP address is `172.17.0.2`, then the environment variable and
    its value will be `SRC_PORT_8080_TCP=tcp://172.17.0.2:8080`. This URL further
    splits into the following three environment variables:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量采用`<ALIAS>_PORT_<port>_<protocol>`的形式。该形式用于将源容器的IP地址、端口和协议作为URL共享。例如，如果源容器的别名是`src`，暴露的端口是`8080`，协议是`tcp`，IP地址是`172.17.0.2`，那么环境变量及其值将是`SRC_PORT_8080_TCP=tcp://172.17.0.2:8080`。这个URL进一步分解为以下三个环境变量：
- en: '`<ALIAS>_PORT_<port>_<protocol>_ADDR`: This form carries the IP address part
    of the URL (for example, `SRC_PORT_8080_TCP_ADDR= 172.17.0.2`)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ALIAS>_PORT_<port>_<protocol>_ADDR`：这种形式携带URL中的IP地址部分（例如，`SRC_PORT_8080_TCP_ADDR=172.17.0.2`）。'
- en: '`<ALIAS>_PORT_<port>_<protocol>_PORT`: This form carries the port part of the
    URL (for example, `SRC_PORT_8080_TCP_PORT=8080`)'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ALIAS>_PORT_<port>_<protocol>_PORT`：这种形式携带URL中的端口部分（例如，`SRC_PORT_8080_TCP_PORT=8080`）。'
- en: '`<ALIAS>_PORT_<port>_<protocol>_PROTO`: This form carries the protocol part
    of the URL (for example, `SRC_PORT_8080_TCP_PROTO=tcp`)'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ALIAS>_PORT_<port>_<protocol>_PROTO`：这种形式携带URL中的协议部分（例如，`SRC_PORT_8080_TCP_PROTO=tcp`）。'
- en: In addition to the preceding environment variables, the Docker Engine exports
    one more variable in this category, that is, of the `<ALIAS>_PORT` form, and its
    value will be the URL of the lowest number of all the exposed ports of the source
    container. For instance, if the source container's alias is `src`, the exposed
    port numbers are `7070`, `8080`, and `80`, the protocol is `tcp`, and the IP address
    is `172.17.0.2`, then the environment variable and its value will be `SRC_PORT=tcp://172.17.0.2:80`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前面的环境变量之外，Docker Engine还会导出一个以`<ALIAS>_PORT`形式的环境变量，其值将是源容器所有暴露端口中最低编号端口的URL。例如，如果源容器的别名是`src`，暴露的端口号是`7070`、`8080`和`80`，协议是`tcp`，IP地址是`172.17.0.2`，那么环境变量及其值将是`SRC_PORT=tcp://172.17.0.2:80`。
- en: Docker exports these autogenerated environment variables in a well-structured
    format so that they can be easily discovered programmatically. Thus, it becomes
    very easy for the recipient container to discover the information about the source
    container. In addition, Docker automatically updates the source IP address and
    its alias as an entry in the `/etc/hosts` file of the recipient.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker以结构化的格式导出这些自动生成的环境变量，使得它们可以轻松地通过程序进行发现。因此，接收容器可以非常容易地发现关于源容器的信息。此外，Docker会自动更新源IP地址及其别名，并将其作为条目添加到接收容器的`/etc/hosts`文件中。
- en: In this chapter, we will dive deep into the mentioned features provided by the
    Docker Engine for container linkage through a bevy of pragmatic examples.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨Docker Engine为容器链接提供的功能，并通过一系列实际示例进行说明。
- en: 'To start with, let''s choose a simple container linking example. Here, we will
    show you how to establish a linkage between two containers, and transfer some
    basic information from the source container to the recipient container, as illustrated
    in the following steps:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们选择一个简单的容器链接示例。在这里，我们将向您展示如何在两个容器之间建立链接，并将一些基本信息从源容器传输到接收容器，具体步骤如下所示：
- en: 'We begin with launching an interactive container that can be used as a source
    container for linking, using the following command:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从启动一个可用于链接的交互式容器开始，使用以下命令：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The container is named `example` using the `--name` option. In addition, the
    `--rm` option is used to clean up the container as soon as you exit from the container.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 容器使用`--name`选项命名为`example`。此外，使用`--rm`选项可以在退出容器后立即清理容器。
- en: 'Display the `/etc/hosts` entry of the source container using the `cat` command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令显示源容器的`/etc/hosts`条目：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, the first entry in the `/etc/hosts` file is the source container's IP
    address (`172.17.0.3`) and its hostname (`a02895551686`).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`/etc/hosts`文件中的第一条条目是源容器的IP地址（`172.17.0.3`）及其主机名（`a02895551686`）。
- en: 'We will continue to display the environment variables of the source container
    using the `env` command:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用`env`命令显示源容器的环境变量：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We have now launched the source container. From another Terminal of the same
    Docker host, let''s launch the interactive recipient container by linking it to
    our source container using the `--link` option of the `docker run` subcommand,
    as shown here:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在已经启动了源容器。在同一Docker主机的另一个终端中，我们将启动交互式接收容器，并通过`docker run`子命令的`--link`选项将其与我们的源容器链接，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, the source container named `example` is linked to the recipient container
    with `ex` as its alias.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，名为`example`的源容器通过`ex`作为别名与接收容器链接。
- en: 'Let''s display the content of the `/etc/hosts` file of the recipient container
    using the `cat` command:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`cat`命令显示接收容器的`/etc/hosts`文件内容：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Of course, as always, the first entry in the `/etc/hosts` file is the IP address
    of the container and its hostname. However, the noteworthy entry in the `/etc/hosts`
    file is the last entry, where the IP address (`172.17.0.3`) of the source container
    and its alias (`ex`) are added automatically.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，与往常一样，`/etc/hosts`文件中的第一条条目是容器的IP地址及其主机名。然而，`/etc/hosts`文件中值得注意的条目是最后一条，其中源容器的IP地址（`172.17.0.3`）及其别名（`ex`）会自动添加。
- en: 'We will continue to display the recipient container''s environment variable
    using the `env` command:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将继续使用`env`命令显示接收容器的环境变量：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Apparently, a new `EX_NAME` environment variable is added automatically to `/berserk_mcclintock/ex`,
    as its value. Here `EX` is the capitalized form of the alias `ex` and `berserk_mcclintock`
    is the autogenerated name of the recipient container.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，一个新的`EX_NAME`环境变量自动添加到`/berserk_mcclintock/ex`中，作为其值。这里，`EX`是别名`ex`的大写形式，`berserk_mcclintock`是接收容器的自动生成名称。
- en: 'As a final step, ping the source container using the widely used `ping` command
    for two counts and use the alias name as the ping address:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，使用广泛使用的`ping`命令对源容器进行ping操作，发送两次请求，并使用别名作为ping地址：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Evidently, the alias `ex` of the source container is resolved to the `172.17.0.3`
    IP address, and the recipient container is able to successfully reach the source.
    In the case of secured container communication, pinging between containers is
    not allowed. We will see more details on the aspect of securing containers in
    [Chapter 11](../Text/Ch11.xhtml), *Securing Docker Containers*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，源容器的别名`ex`解析为`172.17.0.3` IP地址，并且接收容器能够成功地访问源容器。如果启用了安全容器通信，容器之间的ping操作将被禁止。关于容器安全的更多细节，请参见[第11章](../Text/Ch11.xhtml)，*Docker容器安全性*。
- en: In the preceding example, we can link two containers together, and also, observe
    how elegantly networking is enabled between the containers by updating the IP
    address of the source container in the `/etc/hosts` file of the recipient container.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们可以将两个容器连接在一起，还可以观察到通过更新接收容器`/etc/hosts`文件中源容器的IP地址，容器之间的网络连接是如何优雅地启用的。
- en: 'The next example is to demonstrate how container linking exports the environment
    variables of the source container, which are configured using the `-e` option
    of the `docker run` subcommand or the `ENV` instruction of `Dockerfile`, to the
    recipient container. For this purpose, we are going to craft a file named `Dockerfile`
    with the `ENV` instruction, build an image, launch a source container using this
    image, and then launch a recipient container by linking it to the source container:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个示例演示如何通过容器链接将源容器的环境变量导出到接收容器，这些变量通过`docker run`子命令的`-e`选项或`Dockerfile`的`ENV`指令进行配置。为此，我们将编写一个名为`Dockerfile`的文件，使用`ENV`指令，构建一个镜像，使用该镜像启动源容器，然后通过链接将接收容器启动并与源容器连接：
- en: 'We begin with composing a `Dockerfile` with the `ENV` instruction, as shown
    here:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们从编写一个带有`ENV`指令的`Dockerfile`开始，如下所示：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we are setting up two environment variables, `BOOK` and `CHAPTER`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了两个环境变量，`BOOK`和`CHAPTER`。
- en: 'Proceed to build a Docker image `envex` using the `docker build` subcommand
    from the preceding `Dockerfile`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用前面的`Dockerfile`，通过`docker build`子命令构建一个Docker镜像`envex`：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s launch an interactive source container with the `example` name
    using the `envex` image we just built:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用刚刚构建的`envex`镜像，启动一个名为`example`的交互式源容器：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'From the source container prompt, display all the environment variables by
    invoking the `env` command:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源容器的提示符下，通过调用`env`命令显示所有环境变量：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In all the preceding environment variables, both the `BOOK` and the `CHAPTER`
    variables are configured with the `ENV` instruction of the `Dockerfile`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有前面的环境变量中，`BOOK`和`CHAPTER`变量都是通过`Dockerfile`中的`ENV`指令进行配置的。
- en: 'As a final step, to illustrate the `ENV` category of environment variables,
    launch the recipient container with the `env` command, as shown here:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步，为了说明`ENV`类别的环境变量，使用`env`命令启动接收容器，如下所示：
- en: '[PRE18]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This example is also available on GitHub at [https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也可以在GitHub上找到：[https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Env)。
- en: Strikingly, in the preceding output, the variables that are prefixed with `EX_` are
    the outcome of container linking. The environment variables of our interest are
    `EX_ENV_BOOK` and `EX_ENV_CHAPTER`, which were originally set through the `Dockerfile`
    as `BOOK` and `CHAPTER` but modified to `EX_ENV_BOOK` and `EX_ENV_CHAPTER`, as
    an effect of container linking. Though the environment variable names get translated,
    the values stored in these environment variables are preserved as is. We already
    discussed the `EX_NAME` variable name in the previous example.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在前面的输出中，带有`EX_`前缀的变量是容器链接的结果。我们关注的环境变量是`EX_ENV_BOOK`和`EX_ENV_CHAPTER`，它们最初通过`Dockerfile`设置为`BOOK`和`CHAPTER`，但由于容器链接的效果，它们被修改为`EX_ENV_BOOK`和`EX_ENV_CHAPTER`。尽管环境变量的名称发生了转换，但存储在这些环境变量中的值保持不变。我们在前面的示例中已经讨论过`EX_NAME`变量名。
- en: In the preceding example, we experienced how elegantly and effortlessly Docker
    exports the `ENV` category variables from the source container to the recipient
    container. These environment variables are completely decoupled from the source
    and the recipient, thus a change in the value of these environment variables in
    one container does not impact the other. To be even more precise, the values the
    recipient container receives are the values set during the launch of the source
    container. Any changes made to the value of these environment variables in the
    source container after its launch have no effect on the recipient container. It
    does not matter when the recipient container is launched because the values are
    being read from the JSON file.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们体验了Docker如何优雅且轻松地将`ENV`类别的变量从源容器导出到接收容器。这些环境变量与源容器和接收容器完全解耦，因此在一个容器中这些环境变量的值发生变化不会影响另一个容器。更准确地说，接收容器所接收的值是源容器启动时设置的值。源容器启动后，所做的任何对这些环境变量值的更改都不会影响接收容器。接收容器的启动时间无关紧要，因为这些值是从JSON文件中读取的。
- en: 'In our final illustration of linking containers, we are going to show you how
    to take advantage of the Docker feature to share the connectivity details between
    two containers. In order to share the connectivity details between containers,
    Docker uses the `PORT` category of environment variables. The following are the
    steps used to craft two containers and share the connectivity details between
    them:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们最终的容器链接示例中，我们将向您展示如何利用Docker的功能在两个容器之间共享连接信息。为了在容器之间共享连接信息，Docker使用`PORT`类别的环境变量。以下是创建两个容器并在它们之间共享连接信息的步骤：
- en: 'Craft a `Dockerfile` to expose port `80` and `8080` using the `EXPOSE` instruction,
    as shown here:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`Dockerfile`，使用`EXPOSE`指令暴露`80`和`8080`端口，如下所示：
- en: '[PRE19]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Proceed to build a `portex` Docker image using the `docker build` subcommand
    from the `Dockerfile`, we created just now, by running the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用刚才创建的`Dockerfile`，通过运行以下命令构建一个`portex` Docker镜像：
- en: '[PRE20]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, let''s launch an interactive source container with the `example` name
    using the earlier built `portex` image:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使用之前构建的`portex`镜像启动一个名为`example`的交互式源容器：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now that we have launched the source container, let''s continue to create a
    recipient container on another Terminal by linking it to the source container,
    and invoke the `env` command to display all the environment variables, as shown
    here:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经启动了源容器，让我们继续在另一个终端中创建一个接收容器，并将其链接到源容器，然后调用`env`命令以显示所有环境变量，如下所示：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This example is also available on GitHub at [https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也可以在GitHub上找到，链接为：[https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose](https://github.com/thedocker/learning-docker/blob/master/chap08/Dockerfile-Expose)。
- en: From the preceding output of the `env` command, it is quite evident that the
    Docker Engine exported a bunch of four `PORT` category environment variables for
    each port that was exposed using the `EXPOSE` instruction in the `Dockerfile`.
    In addition, Docker also exported another `PORT` category variable `EX_PORT`.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 从`env`命令的前述输出中，可以明显看出，Docker引擎为每个使用`EXPOSE`指令暴露的端口导出了四个`PORT`类别的环境变量。此外，Docker还导出了另一个`PORT`类别变量`EX_PORT`。
- en: Orchestration of containers
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 容器编排
- en: The pioneering concept of orchestration in the IT domain has been there for
    a long time now. For instance, in the **Service Computing** (**SC**) arena, the
    idea of service orchestration has been thriving in an unprecedented manner in
    order to produce and sustain highly robust and resilient services. Discrete or
    atomic services do not serve any substantial purpose unless they are composed
    together in a particular sequence to derive process-aware composite services.
    As orchestrated services are more strategically advantageous for businesses in
    expressing and exposing their unique capabilities in the form of identifiable/discoverable,
    interoperable, usable, and composable services to the outside world, corporates
    are showing exemplary interest in having an easily searchable repository of services
    (atomic as well as composite). This repository, in turn, enables businesses in
    realizing large-scale data as well as process-intensive applications. It is clear
    that the multiplicity of services is very pivotal for organizations to grow and
    glow. This increasingly mandated requirement gets solved using the proven and
    promising orchestration capabilities cognitively.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IT 领域，编排这一先锋概念已经存在很长时间了。例如，在**服务计算**（**SC**）领域，服务编排的理念以空前的方式蓬勃发展，旨在生成并维持高度稳健和弹性的服务。离散的或原子服务本身并没有实际意义，除非它们按照特定的顺序组合起来，从而得出过程感知的复合服务。由于编排服务在企业中表达和展示其独特能力的方式——即通过可识别/可发现、可互操作、可用和可组合的服务形式——在战略上对企业有着更大的优势，因此企业对拥有一个易于搜索的服务库（包括原子服务和复合服务）表现出了极大的兴趣。反过来，这个服务库能够帮助企业实现大规模的数据和过程密集型应用。显然，服务的多样性对于组织的增长和繁荣至关重要。这一日益增长的需求通过使用认知编排能力得到了有效解决。
- en: Now, as we are fast tending toward containerized IT environments, application
    and data containers ought to be smartly composed to realize a host of new generation
    software services.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，随着我们快速迈向容器化的 IT 环境，应用和数据容器应当智能地组合，以实现一系列新一代的软件服务。
- en: However, for producing highly competent orchestrated containers, both purpose-specific
    as well as agnostic containers need to be meticulously selected and launched in
    the right sequence in order to create orchestrated containers. The sequence can
    come from the process (control as well as data) flow diagrams. Doing this complicated
    and daunting activity manually evokes a series of cynicisms and criticisms. Fortunately,
    there are orchestration tools in the Docker space that come in handy to build,
    run, and manage multiple containers to build enterprise-class services. The Docker
    firm, which has been in charge of producing and promoting the generation and assembly
    of Docker-inspired containers, has come out with a standardized and simplified
    orchestration tool (named as `docker-compose`) in order to reduce the workloads
    of developers as well as system administrators.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，为了生成高效的编排容器，既需要精确选择和启动特定用途的容器，也需要选择与用途无关的容器，并且按正确的顺序进行启动，以便创建编排容器。这个顺序可以来自流程（控制流和数据流）图。手动进行这一复杂且令人畏惧的活动，往往会引发一系列的冷嘲热讽和批评。幸运的是，Docker
    领域中有许多编排工具可以帮助构建、运行和管理多个容器，以构建企业级服务。负责生成和推广 Docker 灵感的容器生成与组装的 Docker 公司，推出了一款标准化且简化的编排工具（命名为
    `docker-compose`），旨在减轻开发人员和系统管理员的工作负担。
- en: The proven composition technique of the SC paradigm is being replicated here
    in the raging containerization paradigm in order to reap the originally envisaged
    benefits of containerization, especially in building powerful application-aware
    containers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: SC 范式的成熟组合技术在这里被复制应用于快速发展的容器化范式中，以期收获容器化原本预期的益处，特别是在构建强大的应用感知容器方面。
- en: The **Microservice Architecture** (**MSA**) is an architectural concept that
    aims to decouple a software solution by decomposing its functionality in a pool
    of discrete services. This is done by applying an architectural level to many
    of the principles. The MSA is slowly emerging as a championed way to design and
    build large-scale IT and business systems. It not only facilitates loose and light
    coupling and software modularity but it is also a boon to continuous integration
    and deployment for the agile world. Any changes being made to one part of the
    application mandates massive changes that are made to the application as a whole.
    This has been a bane and barrier to the aspect of continuous deployment. Microservices
    aim to resolve this situation, and hence, the MSA needs light-weight mechanisms,
    small, independently deployable services, and to ensure scalability and portability.
    These requirements can be met using Docker-sponsored containers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**微服务架构**（**MSA**）是一种架构概念，旨在通过将软件功能分解成一组离散的服务来解耦软件解决方案。这是通过在多个原则上应用架构级别来实现的。MSA
    正在逐渐成为设计和构建大规模 IT 和商业系统的主流方式。它不仅促进了松散和轻量级的耦合及软件模块化，还为敏捷开发世界中的持续集成和部署提供了巨大帮助。对应用程序的任何更改都需要对整个应用程序进行大规模修改。这一直是持续部署方面的一个障碍和难题。微服务旨在解决这种情况，因此，MSA
    需要轻量级机制、小型、可独立部署的服务，并确保可扩展性和可移植性。这些要求可以通过使用 Docker 支持的容器来满足。'
- en: Microservices are being built around business capabilities and can be independently
    deployed by fully automated deployment machinery. Each microservice can be deployed
    without interrupting the other microservices, and containers provide an ideal
    deployment and execution environment for services along with other noteworthy
    facilities, such as the reduced time to deployment, isolation management, and
    a simple life cycle. It is easy to quickly deploy new versions of services inside
    containers. All of these factors led to the explosion of microservices using the
    features that Docker had to offer.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务是围绕业务能力构建的，并且可以通过完全自动化的部署机制独立部署。每个微服务可以在不影响其他微服务的情况下部署，而容器为服务提供了理想的部署和执行环境，并且提供了其他显著的优势，例如减少部署时间、隔离管理和简单的生命周期管理。新版本的服务可以轻松地在容器中快速部署。所有这些因素导致了使用
    Docker 提供的功能的微服务爆炸式增长。
- en: As explained, Docker is being positioned as the next-generation containerization
    technology, which provides a proven and potentially sound mechanism to distribute
    applications in a highly efficient and distributed fashion. The beauty is that
    developers can tweak the application pieces within the container while maintaining
    the overall integrity of the container. This has a bigger impact as the brewing
    trend is that instead of large monolithic applications distributed on a single
    physical or virtual server, companies are building smaller, self-defined and contained,
    easily manageable, and discrete services to be contained inside standardized and
    automated containers. In short, the raging containerization technology from Docker
    has come as a boon for the ensuing era of microservices.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Docker 被定位为下一代容器化技术，提供了一种经过验证并且潜力巨大的机制，用于高效、分布式地分发应用程序。其优势在于，开发人员可以在容器内调整应用程序组件，同时保持容器的整体完整性。这带来了更大的影响，因为现在的趋势是，企业不再将大型单体应用程序部署在单个物理或虚拟服务器上，而是构建较小、自定义、易于管理和独立的服务，将它们容器化并标准化自动化。简而言之，Docker
    的容器化技术为微服务时代的到来提供了巨大的助力。
- en: Docker was built and sustained to fulfill the elusive goal of *run it once and
    run it everywhere*. Docker containers are generally isolated at the process level,
    portable across IT environments, and easily repeatable. A single physical host
    can host multiple containers, and hence, every IT environment is generally stuffed
    with a variety of Docker containers. The unprecedented growth of containers is
    to spell out troubles for effective container management. The multiplicity and
    the associated heterogeneity of containers are used to sharply increase the management
    complexities of containers. Hence, the technique of orchestration and the flourishing
    orchestration tools have come as a strategic solace for accelerating the containerization
    journey in safe waters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Docker的构建和发展旨在实现*一次运行，到处运行*的理想目标。Docker容器通常在进程级别进行隔离，具有跨IT环境的可移植性，并且容易重复。单个物理主机可以承载多个容器，因此，每个IT环境通常都充斥着各种Docker容器。容器的前所未有的增长意味着容器管理将面临挑战。容器的多样性及其异质性大大增加了容器管理的复杂性。因此，容器编排技术及其蓬勃发展的编排工具为加速容器化进程提供了战略性支持，帮助在安全的环境中推进这一进程。
- en: Orchestrating applications that span multiple containers containing microservices
    has become a major part of the Docker world, via projects, such as Google's Kubernetes
    or Flocker. Decking is another option used to facilitate the orchestration of
    Docker containers. Docker's new offering in this area is a set of three orchestration
    services designed to cover all aspects of the dynamic life cycle of distributed
    applications from application development to deployment and maintenance. Helios
    is another Docker orchestration platform used to deploy and manage containers
    across an entire fleet. In the beginning, `fig` was the most preferred tool for
    container orchestration. However, in the recent past, the company at the forefront
    of elevating the Docker technology has come out with an advanced container orchestration
    tool (`docker-compose`) to make life easier for developers working with Docker
    containers as they move through the container life cycle.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 跨多个容器编排包含微服务的应用程序，已经成为Docker世界的一个重要组成部分，通过Google的Kubernetes或Flocker等项目得以实现。Decking是另一个用于促进Docker容器编排的选项。Docker在这一领域的最新产品是一组三种编排服务，旨在涵盖分布式应用程序动态生命周期的各个方面，从应用程序开发到部署和维护。Helios是另一个Docker编排平台，用于跨整个集群部署和管理容器。一开始，`fig`是最受欢迎的容器编排工具。然而，在最近，领先的Docker技术推广公司推出了一个先进的容器编排工具（`docker-compose`），旨在使开发人员在处理Docker容器并经历容器生命周期的过程中更加轻松。
- en: Having realized the significance of having the capability of container orchestration
    for the next generation, business-critical, and containerized workloads, the Docker
    company purchased the company that originally conceived and concretized the `fig`
    tool. Then, the Docker company appropriately renamed the tool as `docker-compose`
    and brought in a good number of enhancements to make the tool more tuned to the
    varying expectations of the containers' developers and operation teams.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 意识到为下一代、业务关键且容器化的工作负载提供容器编排能力的重要性后，Docker 公司收购了最早构思并实现`fig`工具的公司。然后，Docker 公司适当地将该工具重命名为`docker-compose`，并进行了大量增强，使其更加符合容器开发人员和运维团队的各种期望。
- en: Here is a gist of `docker-compose`, which is being positioned as a futuristic
    and flexible tool used for defining and running complex applications with Docker.
    With `docker-compose`, you define your application's components (their containers,
    configuration, links, volumes, and so on) in a single file, and then, you can
    spin everything up with a single command, which does everything to get it up and
    running.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`docker-compose`的概述，它被定位为一种未来主义的、灵活的工具，用于定义和运行复杂的Docker应用程序。使用`docker-compose`，你可以在一个文件中定义应用程序的各个组件（它们的容器、配置、链接、卷等），然后只需一个命令就可以启动所有内容，完成一切工作，确保应用程序顺利运行。
- en: This tool simplifies container management by providing a set of built-in tools
    to do a number of jobs that are being performed manually at this point in time.
    In this section, we supplied all the details of using `docker-compose` to perform
    orchestration of containers in order to have a stream of next-generation distributed
    applications.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 该工具通过提供一套内置工具，简化了容器管理，完成许多目前仍需手动操作的任务。在本节中，我们提供了所有使用`docker-compose`进行容器编排的详细信息，旨在支持下一代分布式应用程序的流畅运行。
- en: Orchestrating containers using docker-compose
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用docker-compose进行容器编排
- en: In this section, we will discuss the widely used container orchestration tool
    `docker-compose`. The `docker-compose` tool is a very simple, yet power tool and
    has been conceived and concretized to facilitate the running of a group of Docker
    containers. In other words, `docker-compose` is an orchestration framework that
    lets you define and control a multi-container service. It enables you to create
    a fast and isolated development environment as well as orchestrating multiple
    Docker containers in production. The `docker-compose` tool internally leverages
    the Docker Engine for pulling images, building the images, starting the containers
    in the correct sequence, and making the right connectivity/linking among the containers/services
    based on the definition given in the `docker-compose.yml` file.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将讨论广泛使用的容器编排工具`docker-compose`。`docker-compose`是一个非常简单但强大的工具，旨在方便地运行一组Docker容器。换句话说，`docker-compose`是一个编排框架，让您能够定义并控制一个多容器服务。它使您能够创建一个快速且隔离的开发环境，同时在生产中编排多个Docker容器。`docker-compose`工具在内部利用Docker引擎拉取镜像、构建镜像、按正确顺序启动容器，并根据`docker-compose.yml`文件中的定义，在容器/服务之间建立正确的连接/链接。
- en: Installing docker-compose
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装docker-compose
- en: At the time of writing this book, the latest release of `docker-compose` is
    1.11.2, and it is recommended that you use it with the Docker release 1.9.1 or
    above. You can find the latest official release of `docker-compose` at the GitHub
    location ([https://github.com/docker/compose/releases/latest](https://github.com/docker/compose/releases/latest)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在写这本书时，`docker-compose`的最新版本是1.11.2，建议您与Docker版本1.9.1或更高版本一起使用。您可以在GitHub的官方发布页面找到`docker-compose`的最新版本（[https://github.com/docker/compose/releases/latest](https://github.com/docker/compose/releases/latest)）。
- en: 'We have automated the installation process of `docker-compose` and also made
    it available for public consumption at [http://sjeeva.github.io/getcompose](http://sjeeva.github.io/getcompose).
    These automated scripts precisely identify the latest version of `docker-compose`,
    download it, and install it at `/usr/local/bin/docker-compose`:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经自动化了`docker-compose`的安装过程，并将其公开提供，地址为[http://sjeeva.github.io/getcompose](http://sjeeva.github.io/getcompose)。这些自动化脚本可以准确识别`docker-compose`的最新版本，下载并将其安装到`/usr/local/bin/docker-compose`位置：
- en: 'Use the `wget` tool like this:'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`wget`工具，如下所示：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Use the `curl` tool like this:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`curl`工具，如下所示：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Alternatively, you may choose to install a particular version of `docker-compose`
    directly from the GitHub software repository. Here, you can find the ways and
    means of downloading and installing the `docker-compose` version `1.11.2`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以选择直接从GitHub软件仓库安装特定版本的`docker-compose`。在这里，您可以找到下载和安装`docker-compose`版本`1.11.2`的方法：
- en: 'Use the `wget` tool like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`wget`工具，如下所示：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Use the `curl` tool like this:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`curl`工具，如下所示：
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `docker-compose` tool is also available as a Python package, which you
    can install using the `pip` installer, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose`工具也可以作为Python包安装，您可以使用`pip`安装器进行安装，方法如下：'
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If `pip` is not installed on the system, install the `pip` package before the
    `docker-compose` installation.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统上未安装`pip`，请先安装`pip`包，再进行`docker-compose`的安装。
- en: 'Having successfully installed `docker-compose`, you can now check the `docker-compose`
    version:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 成功安装`docker-compose`后，您现在可以检查`docker-compose`的版本：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The docker-compose file
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: docker-compose 文件
- en: 'The `docker-compose` tool orchestrates containers using **YAML**, which is
    a **Yet Another Markup Language** called the `docker-compose` file. YAML is a
    human-friendly data serialization format. Docker began its journey as a container
    enablement tool, and it is growing by leaps and bounds as an ecosystem to automate
    and accelerate most of the tasks such as container provisioning, networking, storage,
    management, orchestration, security, governance, and persistence. Consequently,
    the `docker-compose` file format and its version are revised multiple times to
    keep up with the Docker platform. At the time of writing this edition, the latest
    version of the `docker-compose` file is version 3\. The following table lists
    the `docker-compose` file and the Docker Engine version compatibility matrix:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 工具使用 **YAML**（一种叫做 **Yet Another Markup Language** 的语言）来编排容器，这就是
    `docker-compose` 文件的格式。YAML 是一种人类友好的数据序列化格式。Docker 最初作为一个容器工具出现，现如今作为一个自动化和加速大部分任务（如容器配置、网络、存储、管理、编排、安全、治理和持久性等）的生态系统，发展迅猛。因此，`docker-compose`
    文件格式及其版本被多次修订，以跟上 Docker 平台的变化。在撰写本版本时，`docker-compose` 文件的最新版本为 3。以下表格列出了 `docker-compose`
    文件与 Docker 引擎版本的兼容性矩阵：'
- en: '| **Docker Compose file format** | **Docker Engine** | **Remarks** |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| **Docker Compose 文件格式** | **Docker 引擎** | **备注** |'
- en: '| 3, 3.1 | 1.13.0+ | Provides support for `docker stack deploy` and `docker
    secrets` |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| 3, 3.1 | 1.13.0+ | 提供对 `docker stack deploy` 和 `docker secrets` 的支持 |'
- en: '| 2.1 | 1.12.0+ | Introduced a few new parameters |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| 2.1 | 1.12.0+ | 引入了一些新参数 |'
- en: '| 2 | 1.10.0+ | Introduced support for named volumes and networks |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 1.10.0+ | 引入对命名卷和网络的支持 |'
- en: '| 1 | 1.9.0+ | Will be deprecated in the future compose releases |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 1.9.0+ | 将在未来的 Compose 版本中弃用 |'
- en: 'The `docker-compose` tool by default uses a file named as `docker-compose.yml`
    or `docker-compose.yaml` to orchestrate containers. This default file can be modified
    using the `-f` option of the `docker-compose` tool. The following is the format
    of the `docker-compose` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 工具默认使用名为 `docker-compose.yml` 或 `docker-compose.yaml` 的文件来编排容器。可以使用
    `docker-compose` 工具的 `-f` 选项修改此默认文件。以下是 `docker-compose` 文件的格式：'
- en: '[PRE29]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, the options used are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用的选项如下：
- en: '`<version>`: This is the version of the `docker-compose` file. Refer to the
    preceding version table.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<version>`：这是 `docker-compose` 文件的版本。请参阅前面的版本表。'
- en: '`<service>`: This is the name of the service. You can have more than one service
    definition in a single `docker-compose` file. The service name should be followed
    by one or more keys. However, all the services must either have an `image` or
    a `build` key, followed by any number of optional keys. Except for the `image`
    and `build` keys, the rest of the keys can be directly mapped to the options in
    the `docker run` subcommand. The value can be either a single value or multiple
    values. All the `<service>` definitions must be grouped under the top-level `services`
    key.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<service>`：这是服务的名称。你可以在一个 `docker-compose` 文件中定义多个服务。服务名称后面可以跟一个或多个键。不过，所有服务必须至少有一个
    `image` 或 `build` 键，后面可以跟任意数量的可选键。除了 `image` 和 `build` 键，其他键可以直接映射到 `docker run`
    子命令中的选项。值可以是单一值，也可以是多个值。所有 `<service>` 定义必须归类在顶级 `services` 键下。'
- en: '`<network>`: This is the name of the networks that are used by the services.
    All the `<network>` definitions must be grouped under the top-level `networks`
    key.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<network>`：这是服务使用的网络的名称。所有 `<network>` 定义必须归类在顶级 `networks` 键下。'
- en: '`<volume>`: This is the name of the volume that is used by the services. All
    the `<volume>` definitions must be grouped under the top-level `volume` key.'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<volume>`：这是服务使用的卷的名称。所有 `<volume>` 定义必须归类在顶级 `volume` 键下。'
- en: Here, we are listing a few keys supported in the `docker-compose` file version
    3\. Refer to [https://docs.docker.com/compose/compose-file](https://docs.docker.com/compose/compose-file)
    for all the keys supported by `docker-compose`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们列出了 `docker-compose` 文件版本 3 支持的几个键。有关 `docker-compose` 支持的所有键，请参考 [https://docs.docker.com/compose/compose-file](https://docs.docker.com/compose/compose-file)。
- en: '`image`: This is the tag or image ID.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image`：这是标签或镜像 ID。'
- en: '`build`: This is the path to a directory containing a `Dockerfile`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：这是包含 `Dockerfile` 的目录路径。'
- en: '`command`: This key overrides the default command.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`command`：此键覆盖默认命令。'
- en: '`deploy`: This key has many subkeys and is used to specify deployment configuration.
    This is used only in the `docker swarm` mode.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deploy`：此键有许多子键，用于指定部署配置。仅在 `docker swarm` 模式下使用。'
- en: '`depends_on`: This is used to specify the dependencies between services. It
    can be further extended to chain services based on their conditions.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`depends_on`：此选项用于指定服务之间的依赖关系，可以进一步扩展，以根据服务的条件链接服务。'
- en: '`cap_add`: This adds a capability to the container.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cap_add`：此选项向容器添加功能。'
- en: '`cap_drop`: This drops a capability of the container.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cap_drop`：此选项删除容器的某项功能。'
- en: '`dns`: This sets custom DNS servers.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns`：此选项设置自定义 DNS 服务器。'
- en: '`dns_search`: This sets custom DNS search servers.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dns_search`：此选项设置自定义 DNS 搜索服务器。'
- en: '`entrypoint`: This key overrides the default entrypoint.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`entrypoint`：此关键字覆盖默认的入口点。'
- en: '`env_file`: This key lets you add environment variables through files.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`env_file`：此关键字允许您通过文件添加环境变量。'
- en: '`environment`: This adds environment variables and uses either an array or
    a dictionary.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`environment`：此选项用于添加环境变量，可以使用数组或字典的形式。'
- en: '`expose`: This key exposes ports without publishing them to the host machine.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expose`：此关键字暴露端口，但不会将它们发布到主机机器。'
- en: '`extends`: This extends another service defined in the same or a different
    configuration file.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extends`：此选项扩展同一或不同配置文件中定义的其他服务。'
- en: '`extra_hosts`: This enables you to add additional hosts to `/etc/hosts` inside
    the container.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`extra_hosts`：此选项使您能够向容器内的 `/etc/hosts` 添加额外的主机。'
- en: '`healthcheck`: This allows us to configure the service health check.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`healthcheck`：此命令允许我们配置服务健康检查。'
- en: '`labels`: This key lets you add metadata to your container.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`labels`：此关键字允许您为容器添加元数据。'
- en: '`links`: This key links to containers in another service. Usage of links is
    strongly discouraged.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`links`：此关键字用于连接到另一个服务中的容器。强烈不推荐使用链接。'
- en: '`logging`: This is used to configure the logging for the service.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logging`：用于配置服务的日志记录。'
- en: '`network`: This is used to join the service to the network defined in the top-level
    `networks` key.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`network`：此选项用于将服务加入到顶层 `networks` 关键字定义的网络中。'
- en: '`pid`: This enables the PID space sharing between the host and the containers.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pid`：此选项启用主机和容器之间的 PID 空间共享。'
- en: '`ports`: This key exposes ports and specifies both the `HOST_port:CONTAINER_port`
    ports.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ports`：此关键字用于暴露端口并指定 `HOST_port:CONTAINER_port` 的端口映射。'
- en: '`volumes`: This key mounts path or named volumes. The named volumes need to
    be defined in the top-level `volumes` key.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`volumes`：此关键字用于挂载路径或命名卷。命名卷需要在顶层的 `volumes` 关键字中定义。'
- en: The docker-compose command
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`docker-compose` 命令'
- en: 'The `docker-compose` tool provides sophisticated orchestration functionality
    with a handful of commands. In this section, we will list out the `docker-compose`
    options and commands:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 工具提供了复杂的 orchestration 功能，支持一组命令。在本节中，我们将列出 `docker-compose`
    的选项和命令：'
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `docker-compose` tool supports the following options:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 工具支持以下选项：'
- en: '`-f`, `--file <file>`: This specifies an alternate file for `docker-compose`
    (default is the `docker-compose.yml` file)'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-f`、`--file <file>`：此选项指定 `docker-compose` 使用的替代文件（默认是 `docker-compose.yml`
    文件）。'
- en: '`-p`, `--project-name <name>`: This specifies an alternate project name (default
    is the directory name)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-p`、`--project-name <name>`：此选项指定一个替代的项目名称（默认是目录名称）。'
- en: '`--verbose`: This shows more output'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--verbose`：显示更多的输出。'
- en: '`-v`, `--version`: This prints the version and exits'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-v`、`--version`：此选项打印版本并退出。'
- en: '`-H`, `--host <host>`: This is to specify the daemon socket to connect to'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-H`、`--host <host>`：用于指定要连接的守护进程套接字。'
- en: '`-tls`, `--tlscacert`, `--tlskey`, and `--skip-hostname-check`: The `docker-compose`
    tool also supports these flags for **Transport Layer Security** (**TLS**)'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`-tls`、`--tlscacert`、`--tlskey` 和 `--skip-hostname-check`：`docker-compose`
    工具还支持这些标志来启用**传输层安全性**（**TLS**）。'
- en: 'The `docker-compose` tool supports the following commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose` 工具支持以下命令：'
- en: '`build`: This command builds or rebuilds services.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build`：此命令用于构建或重建服务。'
- en: '`bundle`: This is used to create a Docker bundle from the compose file, this
    is still an experimental feature on Docker 1.13.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`bundle`：此命令用于从 compose 文件创建 Docker bundle，这是 Docker 1.13 中的实验性功能。'
- en: '`config`: This is a command to validate and display the compose file.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`：此命令用于验证和显示 compose 文件。'
- en: '`create`: This creates the services defined in the compose file.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`create`：此命令用于创建 compose 文件中定义的服务。'
- en: '`down`: This command is used to stop and remove containers and networks.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`down`：此命令用于停止并删除容器和网络。'
- en: '`events`: This can be used to view the real-time container life cycle events.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`events`：此命令可用于查看实时的容器生命周期事件。'
- en: '`exec`: This enables you to run a command in a running container. It is used
    predominantly for debugging purposes.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`：此命令使您能够在运行中的容器中执行命令，主要用于调试目的。'
- en: '`kill`: This command kills running containers.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`kill`：此命令用于终止运行中的容器。'
- en: '`logs`: This displays the output from the containers.'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`：此命令显示来自容器的输出。'
- en: '`pause`: This command is used to pause services.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pause`：此命令用于暂停服务。'
- en: '`port`: This prints the public port for a port binding.'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`port`：此命令打印端口绑定的公共端口。'
- en: '`ps`: This lists the containers.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`：此命令列出容器。'
- en: '`pull`: This command pulls the images from the repository.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pull`：此命令从仓库拉取镜像。'
- en: '`push`: This command pushes the images to the repository.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`push`：此命令将镜像推送到仓库。'
- en: '`restart`: This is used to restart the services defined in the compose file.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`restart`：此命令用于重启在 compose 文件中定义的服务。'
- en: '`rm`: This removes the stopped containers.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：此命令移除已停止的容器。'
- en: '`run`: This runs a one-off command.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`run`：此命令运行一次性命令。'
- en: '`scale`: This sets a number of containers for a service.'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scale`：此命令用于为服务设置容器数量。'
- en: '`start`: This command starts services defined in the compose file.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`start`：此命令启动 compose 文件中定义的服务。'
- en: '`stop`: This stops services.'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stop`：此命令停止服务。'
- en: '`unpause`: This command is used to unpause services.'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`unpause`：此命令用于恢复暂停的服务。'
- en: '`up`: This creates and starts containers.'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`up`：此命令用于创建并启动容器。'
- en: '`version`: This prints the version of Docker Compose.'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`：此命令打印 Docker Compose 的版本。'
- en: Common usage
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 常见用法
- en: 'In this section, we are going to experience the power of the orchestration
    feature provided by the Docker Compose framework with the help of an example.
    For this purpose, we are going to build a two-tiered web application that will
    receive your inputs through a URL and respond with the associated response text.
    This application is built using the following two services, as enumerated here:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分中，我们将通过一个示例来体验 Docker Compose 框架提供的编排功能。为此，我们将构建一个二层 Web 应用程序，它通过 URL 接收输入并返回相应的响应文本。这个应用程序使用以下两个服务构建，具体如下：
- en: '**Redis**: This is a key-value database used to store a key and its associated
    value'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Redis**：这是一个键值数据库，用于存储键及其相关联的值。'
- en: '**Node.js**: This is a JavaScript runtime environment used to implement the
    web server functionality as well the application logic'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Node.js**：这是一个 JavaScript 运行时环境，用于实现 Web 服务器功能以及应用程序逻辑。'
- en: 'Each of these services is packed inside two different containers that are stitched
    together using the `docker-compose` tool. The following is the architectural representation
    of the services:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务都被打包在两个不同的容器中，并通过 `docker-compose` 工具将它们连接在一起。以下是服务的架构表示：
- en: '![](img/image_08_001.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_08_001.png)'
- en: Here, in this example, we begin with implementing the `example.js` module, a
    Node.js file to realize the web server, and the key lookup functionality. Further,
    we will craft the `Dockerfile` on the same directory as `example.js` to package
    the Node.js runtime environment, and then, define the service orchestration using
    a `docker-compose.yml` file in the same directory as `example.js`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们首先实现 `example.js` 模块，这是一个 Node.js 文件，用于实现 Web 服务器和关键字查找功能。接下来，我们将在与
    `example.js` 文件相同的目录中编写 `Dockerfile`，用于打包 Node.js 运行时环境，并定义使用 `docker-compose.yml`
    文件进行服务编排，文件与 `example.js` 位于同一目录。
- en: 'The following is the `example.js` file, which is a Node.js implementation of
    the simple request/response web application. For demonstration, in this sample
    code, we restrict the request and response for just two `docker-compose` commands
    (`build` and `kill`). For the code to be self-explanatory, we added comments in
    the code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是 `example.js` 文件，这是一个 Node.js 实现的简单请求/响应 Web 应用程序。为了演示，在这个示例代码中，我们将请求和响应限制为两个
    `docker-compose` 命令（`build` 和 `kill`）。为了让代码更加易于理解，我们在代码中添加了注释：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This example is also available at [https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也可以在[https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose)查看。
- en: 'The following text is the content of `Dockerfile` that packs the Node.js image,
    the `redis` driver for Node.js, and the `example.js` file, as defined earlier:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是打包 Node.js 镜像、Node.js 用的 `redis` 驱动和前面定义的 `example.js` 文件的 `Dockerfile` 内容：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This code is also available at [https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码也可以在[https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose)查看。
- en: 'The following text is from the `docker-compose.yml` file that defines the services
    that the Docker Compose tool orchestrates:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文本来自`docker-compose.yml`文件，该文件定义了Docker Compose工具管理的服务：
- en: '[PRE33]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This example is also available at [https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例也可以在[https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose](https://github.com/thedocker/learning-docker/tree/master/chap08/orchestrate-using-compose)找到。
- en: 'We defined two services in this `docker-compose.yml` file, wherein these services
    serve the following purposes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这个`docker-compose.yml`文件中定义了两个服务，这些服务分别执行以下任务：
- en: The service named `web` is built using the `Dockerfile` in the current directory.
    Also, it is instructed that you launch the container by running the `node` (the
    Node.js runtime) with `/myapp/example.js` (web application implementation), as
    its argument. Since this Node.js application uses the `redis` database, the `web`
    service is forced to start after the `redis` service using the `depends_on` instruction.
    Besides, the `80` container port is mapped to the `8080` Docker host's port.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名为`web`的服务是使用当前目录中的`Dockerfile`构建的。此外，指示启动容器时需要运行`node`（Node.js运行时）并传入`/myapp/example.js`（Web应用实现）作为其参数。由于此Node.js应用使用了`redis`数据库，因此`web`服务必须在`redis`服务启动后启动，使用`depends_on`指令来实现。此外，`80`容器端口映射到`8080`的Docker主机端口。
- en: The service named `redis` is instructed to launch a container with the `redis:latest`
    image. If the image is not present in the Docker host, the Docker Engine will
    pull it from the central repository or the private repository.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名为`redis`的服务被指示使用`redis:latest`镜像启动容器。如果该镜像不存在于Docker主机中，Docker引擎将从中央仓库或私有仓库中拉取它。
- en: 'Now, let''s continue with our example by building the Docker images using the
    `docker-compose build` command, launch the containers using the `docker-compose
    up` command, and connect with a browser to verify the request/response functionality,
    as explained step by step here:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续执行示例，通过使用`docker-compose build`命令构建Docker镜像，使用`docker-compose up`命令启动容器，并通过浏览器连接以验证请求/响应功能，如此处逐步解释的那样：
- en: 'The `docker-compose` commands must be executed from the directory in which
    the `docker-compose.yml` file is stored. Besides, `docker-compose` considers each
    `docker-compose.yml` file as a project, and it assumes the project name from the
    `docker-compose.yml` file''s directory. Of course, this can be overridden using
    the `-p` option. So, as a first step, let''s change the directory, wherein the
    `docker-compose.yml` file is stored:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`docker-compose`命令必须在存储`docker-compose.yml`文件的目录中执行。此外，`docker-compose`将每个`docker-compose.yml`文件视为一个项目，并从该文件所在的目录假定项目名称。当然，可以使用`-p`选项覆盖此设置。因此，作为第一步，让我们切换到存储`docker-compose.yml`文件的目录：'
- en: '[PRE34]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Build the services using the `docker-compose build` command:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-compose build`命令构建服务：
- en: '[PRE35]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Pull the images from the repository using the `docker-compose pull` command:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-compose pull`命令从仓库中拉取镜像：
- en: '[PRE36]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Proceed to bring up the services as indicated in the `docker-compose.yml` file
    using the `docker-compose up` command:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`docker-compose up`命令根据`docker-compose.yml`文件中的指示启动服务：
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Since the directory name is `example`, the `docker-compose` tool has assumed
    that the project name is `example`. If you pay attention to the first line of
    the output, you will notice the `example_default` network being created. The Docker
    Compose tool creates this bridge network by default and this network is used by
    the service for IP address resolution. Thus the services can reach the other services
    by just using the service names defined in the compose file.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目录名是`example`，`docker-compose`工具已假定项目名称为`example`。如果您注意输出的第一行，您会看到创建了`example_default`网络。Docker
    Compose工具默认创建此桥接网络，并且此网络由服务用于IP地址解析。因此，服务可以通过使用在Compose文件中定义的服务名称相互访问。
- en: 'Having successfully orchestrated the services using the `docker-compose` tool,
    let''s invoke the `docker-compose ps` command from a different Terminal to list
    the containers associated with the example `docker-compose` project:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 成功使用`docker-compose`工具编排服务后，让我们从另一个终端调用`docker-compose ps`命令，列出与示例`docker-compose`项目相关的容器：
- en: '[PRE38]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Evidently, the two `example_redis_1` and `example_web_1` containers are up and
    running. The container name is prefixed with `example_`, which is the `docker-compose`
    project name.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，`example_redis_1`和`example_web_1`这两个容器已经启动并正在运行。容器名称以`example_`为前缀，这是`docker-compose`项目的名称。
- en: 'Explore the functionality of our own request/response web application on a
    different Terminal of the Docker host, as illustrated here:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Docker主机的另一个终端上探索我们自己的请求/响应Web应用程序的功能，如下所示：
- en: '[PRE39]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are directly connecting to the `web` service using `http://localhost:8080`
    because the `web` service is bound to the Docker host on port `8080`. You can
    also access the service externally using the Docker host IP address and port `8080`
    (`https://<docker host ip>:8080`), provided the IP address and the port is reachable
    from the external system.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们直接通过`http://localhost:8080`连接到`web`服务，因为`web`服务绑定到Docker主机的`8080`端口。你也可以通过Docker主机的IP地址和端口`8080`外部访问该服务（`https://<docker
    host ip>:8080`），前提是IP地址和端口可以从外部系统访问。
- en: Cool, isn't it? With very minimal effort and with the help of the `docker-compose.yml`
    file, we are able to compose two different services together and offer a composite
    service.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 很酷，不是吗？只需极少的努力，再加上`docker-compose.yml`文件的帮助，我们就能够将两个不同的服务组合在一起，提供一个复合服务。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter was incorporated into this book in order to provide you with all
    the probing and prescribing details on seamlessly orchestrating multiple containers.
    We extensively discussed the need for container orchestration and the enabling
    tools to simplify and streamline the increasingly complicated process of container
    orchestration. In order to substantiate how orchestration is handy and helpful
    in crafting enterprise-class containers and to illustrate the orchestration process,
    we took the widely followed way of explaining the whole gamut through a simple
    example. We developed a web application and contained it within a standard container.
    Similarly, we took a database container, which is a backend for the frontend web
    application. The database gets executed inside another container. We saw how to
    make the web application container aware of the database, using different technologies
    through the container-linkage feature of the Docker Engine. We used an open-source
    tool (`docker-compose`) for this purpose.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 本章被纳入本书的目的是为了提供所有关于无缝编排多个容器的详细探讨和建议。我们广泛讨论了容器编排的必要性以及简化和流畅化越来越复杂的容器编排过程的工具。为了证明容器编排在构建企业级容器中的便捷性和帮助，并展示编排过程，我们采用了一种广受欢迎的方式，通过一个简单的示例来讲解整个过程。我们开发了一个Web应用，并将其封装在一个标准容器中。同样，我们还使用了一个数据库容器，它是前端Web应用的后端。数据库在另一个容器内执行。我们看到了如何通过Docker引擎的容器链接特性，使Web应用容器能够感知数据库，并使用不同的技术实现这一点。我们使用了一个开源工具（`docker-compose`）来实现这一目标。
- en: In the next chapter, we will discuss how Docker facilitates software testing,
    especially integration testing with a few pragmatic examples.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将讨论Docker如何促进软件测试，特别是集成测试，并提供一些实用的示例。
