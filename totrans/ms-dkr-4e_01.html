<html><head></head><body><div><div><p id="_idParaDest-18" class="chapter-number"><a id="_idTextAnchor046"/><em class="italic">Chapter 1</em></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor047"/>Docker Overview</h1>
			<p>Welcome to <em class="italic">Mastering Docker, Fourth Edition</em>! This first chapter will cover the <strong class="bold">Docker</strong> basics that you should already have a pretty good handle on. But if you don't already have the required knowledge at this point, this chapter will help you get up to speed, so that subsequent chapters don't feel as heavy. </p>
			<p>By the end of the book, you will be a Docker master able to implement Docker in your environments, building and supporting applications on top of them.</p>
			<p>In this chapter, we're going to review the following:</p>
			<ul>
				<li>Understanding Docker</li>
				<li>The differences between dedicated hosts, virtual machines, and Docker installers/installation</li>
				<li>The Docker command</li>
				<li>The Docker and container ecosystem</li>
			</ul>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor048"/>Technical requirements</h1>
			<p>In this chapter, we are going to discuss how to install Docker locally. To do this, you will need a host running one of the three following operating systems:</p>
			<ul>
				<li>macOS High Sierra and above</li>
				<li>Windows 10 Professional</li>
				<li>Ubuntu 18.04 and above </li>
				<li>Check out the following video to see the Code in Action: <a href="https://bit.ly/35fytE3">https://bit.ly/35fytE3</a></li>
			</ul>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor049"/>Understanding Docker</h1>
			<p>Before we look at<a id="_idIndexMarker000"/> installing Docker, let's begin by getting an understanding of the problems that the Docker technology aims to solve.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor050"/>Developers</h2>
			<p>The company behind<a id="_idIndexMarker001"/> Docker, also called Docker, has always described the program as fixing the '<em class="italic">it works on my machine</em>' problem. This problem is best summed up by an image, based on the Disaster Girl meme, which simply had the tagline '<em class="italic">Worked fine in dev, ops problem now</em>', that started popping up in presentations, forums, and Slack channels a few years ago. While it is funny, it is, unfortunately, an all-too-real problem and one I have personally been on the receiving end of, let's take a look at an example of what is meant by this.</p>
			<h3>The problem</h3>
			<p>Even in a world <a id="_idIndexMarker002"/>where <strong class="bold">DevOps</strong> best practices are followed, it is still all too easy for a developer's working environment to not match the final production environment.</p>
			<p>For example, a developer using the <strong class="bold">macOS</strong> version of, say, <strong class="bold">PHP</strong> will probably not be running the same version as the <strong class="bold">Linux server</strong> that hosts the production code. Even if the versions match, you then have to deal with differences in the configuration and overall environment on which the version of PHP is running, such as differences in the way file permissions are handled between different operating system versions, to name just one potential problem.</p>
			<p>All of this comes to a head when it is time for a developer to deploy their code to the host, and it doesn't work. So, should the production environment be configured to match the developer's machine, or should developers only do their work in environments that match those used in production?</p>
			<p>In an ideal world, everything should be consistent, from the developer's laptop all the way through to your production servers; however, this utopia has traditionally been challenging to achieve. Everyone has their way of working and their own personal preferences—enforcing consistency across multiple platforms is difficult enough when a single engineer is working on the systems, let alone a team of engineers working with a team of potentially hundreds of developers.</p>
			<p>The Docker solution</p>
			<p>Using Docker for<a id="_idIndexMarker003"/> Mac or Docker for Windows, a developer can quickly wrap their code in a container that they have either defined themselves or created as a <strong class="bold">Dockerfile</strong> while working alongside a sysadmin or operations team. We will be covering this in <a href="B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Container Images</em>, as well as <strong class="bold">Docker Compose</strong> files, which<a id="_idIndexMarker004"/> we will go into more detail about in <a href="B15659_05_Final_JM_ePub.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Docker Compose</em>.</p>
			<p>Programmers can continue to use their chosen <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>) and <a id="_idIndexMarker005"/>maintain their workflows when working with the code. As we will see in the upcoming sections of this chapter, installing and using Docker is not difficult; considering how much of a chore it was to maintain consistent environments in the past, even with automation, Docker feels a little too easy – almost like cheating.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor051"/>Operators</h2>
			<p>I have been working <a id="_idIndexMarker006"/>in operations for more years than I would like to admit, and the following problem has cropped regularly.</p>
			<h3>The problem</h3>
			<p>Let's say you are looking <a id="_idIndexMarker007"/>after five servers: three load-balanced web servers and two database servers that are in a master or slave configuration dedicated to running Application 1. You are using a tool, such as <strong class="bold">Puppet</strong> or <strong class="bold">Chef</strong>, to automatically manage the software stack and configuration across your five servers.</p>
			<p>Everything is going great until you are told that we need to deploy Application 2 on the same servers that are running Application 1. On the face of it, this is not a problem – you can tweak your Puppet or Chef configuration to add new users, add virtual hosts, pull the latest code down, and so on. However, you notice that Application 2 requires a newer version of the software than the one you are running for Application 1.</p>
			<p>To make matters worse, you already know that Application 1 flat out refuses to work with the new software stack and that Application 2 is not backward compatible.</p>
			<p>Traditionally, this leaves you with a few choices, all of which just add to the problem in one way or another:</p>
			<ul>
				<li>Ask for more servers? While this tradition is probably the safest technical solution, it does not automatically mean that there will be the budget for additional resources.</li>
				<li>Re-architect the solution? Taking one of the web and database servers out of the load balancer or replication and redeploying them with the software stack for Application 2 may seem like the next easiest option from a technical point of view. However, you are introducing single points of failure for Application 2 and reducing the redundancy for Application 1 as well: there was probably a reason why you were running three web and two database servers in the first place.</li>
				<li>Attempt to install the new software stack side-by-side on your servers? Well, this certainly is<a id="_idIndexMarker008"/> possible and may seem like a good short-term plan to get the project out of the door, but it could leave you with a house of cards that could come tumbling down when the first critical security patch is needed for either software stack.</li>
			</ul>
			<h3>The Docker solution</h3>
			<p>This is where Docker <a id="_idIndexMarker009"/>starts to come into its own. If you have Application 1 running across your three web servers in containers, you may be running more than three containers; in fact, you could already be running six, doubling up on the containers, allowing you to run rolling deployments of your application without reducing the availability of Application 1.</p>
			<p>Deploying Application 2 in this environment is as easy as merely launching more containers across your three hosts and then routing to the newly deployed application using your load balancer. As you are just deploying containers, you do not need to worry about the logistics of deploying, configuring, and managing two versions of the same software stack on the same server.</p>
			<p>We will work through an example of this exact scenario in <a href="B15659_05_Final_JM_ePub.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>,<em class="italic"> Docker Compose</em>.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor052"/>Enterprise</h2>
			<p>Enterprises suffer <a id="_idIndexMarker010"/>from the same problems faced by developers and operators, as they employ both types of profession; however, they have both of these entities on a much larger scale, and there is also a lot more risk involved.</p>
			<h3>The problem</h3>
			<p>Because of the risk as well as the fact that any downtime could cost sales or impact reputation, enterprises need to test every deployment before it is released. This means that new features and <a id="_idIndexMarker011"/>fixes are stuck in a holding pattern while the following takes place:</p>
			<ul>
				<li>Test environments are spun up and configured.</li>
				<li>Applications are deployed across the newly launched environments.</li>
				<li>Test plans are executed, and the application and configuration are tweaked until the tests pass.</li>
				<li>Requests for change are written, submitted, and discussed to get the updated application deployed to production.</li>
			</ul>
			<p>This process can take anywhere from a few days to a few weeks, or even months, depending on the complexity of the application and the risk the change introduces. While the process is required to ensure continuity and availability for the enterprise at a technological level, it does potentially add risk at the business level. What if you have a new feature stuck in this holding pattern and a competitor releases a similar—or worse still—the same functionality, ahead of you?</p>
			<p>This scenario could be just as damaging to sales and reputation as the downtime that the process was put in place to protect you against in the first place.</p>
			<h3>The Docker solution</h3>
			<p>Docker does not<a id="_idIndexMarker012"/> remove the need for a process, such as the one just described, to exist or be followed. However, as we have already touched upon, it does make things a lot easier as you are already working consistently. It means that your developers have been working with the same container configuration that is running in production. This means that it is not much of a step for the methodology to be applied to your testing.</p>
			<p>For example, when a developer checks their code that they know works on their local development environment (as that is where they have been doing all of their work), your testing tool can launch the same containers to run your automated tests against. Once the containers have been used, they can be removed to free up resources for the next lot of tests. This means that suddenly, your testing process and procedures are a lot more flexible, and you can continue to reuse the same environment, rather than redeploying or re-imaging servers for the next set of testing.</p>
			<p>This streamlining of the process can be taken as far as having your new application containers push through to production.</p>
			<p>The quicker this <a id="_idIndexMarker013"/>process can be completed, the faster you can confidently launch new features or fixes and keep ahead of the curve.</p>
			<p>So, we know what problems Docker was developed to solve. We now need to discuss what exactly Docker is and what it does.</p>
			<p>The differences between dedicated hosts, virtual machines, and Docker</p>
			<p>Docker is a <a id="_idIndexMarker014"/>container <a id="_idIndexMarker015"/>management <a id="_idIndexMarker016"/>system that<a id="_idIndexMarker017"/> helps us<a id="_idIndexMarker018"/> efficiently <a id="_idIndexMarker019"/>manage <strong class="bold">Linux Containers</strong> (<strong class="bold">LXC</strong>) more<a id="_idIndexMarker020"/> easily and universally. This lets you create images in virtual environments on your laptop and run commands against them. The actions you perform to the containers, running in these environments locally on your machine, will be the same commands or operations that you run against them when they are running in your production environment.</p>
			<p>This helps us in that you don't have to do things differently when you go from a development environment, such as the one on your local machine, to a production environment on your server. Now, let's take a look at the differences between Docker containers and typical virtual machine environments:</p>
			<div><div><img src="img/image001.jpg" alt="Figure 1.1 – Applications running on virtual machine environments&#13;&#10;" width="1030" height="586"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.1 – Applications running on virtual machine environments</p>
			<p>As you <a id="_idIndexMarker021"/>can <a id="_idIndexMarker022"/>see, for<a id="_idIndexMarker023"/> a<a id="_idIndexMarker024"/> dedicated <a id="_idIndexMarker025"/>machine, we have three<a id="_idIndexMarker026"/> applications, all sharing the same orange software stack. Running virtual machines allows us to run three applications, running two completely different software stacks. The following diagram shows the same three applications running in containers using Docker:</p>
			<div><div><img src="img/image002.jpg" alt="Figure 1.2 – Applications running on top of Docker&#13;&#10;" width="1012" height="598"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Applications running on top of Docker</p>
			<p>This diagram <a id="_idIndexMarker027"/>gives <a id="_idIndexMarker028"/>us a lot of insight into the most <a id="_idIndexMarker029"/>significant<a id="_idIndexMarker030"/> key benefit of Docker, that <a id="_idIndexMarker031"/>is, there<a id="_idIndexMarker032"/> is no need for a complete operating system every time we need to bring up a new container, which cuts down on the overall size of containers. Since almost all the versions of Linux use the standard kernel models, Docker relies on using the host operating system's Linux kernel for the operating system it was built upon, such as Red Hat, CentOS, and Ubuntu.</p>
			<p>For this reason, you can have almost any Linux operating system as your host operating system and be able to layer other Linux-based operating systems on top of the host. Well, that is, your applications are led to believe that a full operating system is actually installed—but in reality, we only install the binaries, such as a package manager and, for example, Apache/PHP and the libraries required to get just enough of an operating system for your applications to run.</p>
			<p>For example, in the earlier diagram, we could have Red Hat running for the orange application, and Debian running for the green application, but there would never be a need actually to install Red Hat or Debian on the host. Thus, another benefit of Docker is the size of images when they are created. They are built without the most significant piece: the kernel or the operating system. This makes them incredibly small, compact, and easy to ship.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor053"/>Docker installation</h1>
			<p>Installers are one<a id="_idIndexMarker033"/> of the first pieces of software you need to get up and running with Docker on both your local machine and your server environments. Let's first take a look at which environments you can install Docker in:</p>
			<ul>
				<li>Linux (various Linux flavors) </li>
				<li>macOS</li>
				<li>Windows 10 Professional</li>
			</ul>
			<p>Besides, you can run them on public clouds, such as Amazon Web Services, Microsoft Azure, and DigitalOcean, to name a few. With each of these installers listed previously, Docker actually operates in different ways on the operating system. For example, Docker runs natively on Linux. However, if you are using macOS or Windows 10, then it operates a little differently since it relies on using Linux.</p>
			<p>Let's look at quickly installing Docker on a Linux desktop running Ubuntu 18.04, and then on macOS and Windows 10.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor054"/>Installing Docker on Linux </h2>
			<p>As already <a id="_idIndexMarker034"/>mentioned, this is the most straightforward installation out of the<a id="_idIndexMarker035"/> three systems we will be looking at. We'll be installing Docker on Ubuntu 18.04; however, there are various flavors of Linux with their own package managers, which will handle this slightly differently. See the <em class="italic">Further reading</em> section for details on install on other Linux distributions. To install Docker, simply run the following command from a Terminal session:</p>
			<pre>$ curl -sSL https://get.docker.com/ | sh
$ sudo systemctl start docker</pre>
			<p>You will also be asked to add your current user to the Docker group. To do this, run the following command, making sure you replace the username with your own:</p>
			<pre>$ sudo usermod -aG docker username</pre>
			<p>These commands will download, install, and configure the latest version of Docker from Docker themselves. At the time of writing, the Linux operating system version installed by the official install script is 19.03.</p>
			<p>Running the following command should confirm that Docker is installed and running:</p>
			<pre> $ docker version</pre>
			<p>You should <a id="_idIndexMarker036"/>see<a id="_idIndexMarker037"/> something similar to the following output:</p>
			<div><div><img src="img/image003.jpg" alt="Figure 1.3 – Output of the docker version command showing the version of Docker installed on the system" width="1255" height="1328"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Output of the docker version command showing the version of Docker installed on the system</p>
			<p>There is a supporting tool that we are going to use in future chapters, which are installed as part of the Docker for macOS or Windows 10 installers.</p>
			<p>To ensure that we are ready to use the tool in later chapters, we should install it now. The tool is called <code>1.25.4</code> – update the version number in the commands in the following code block with whatever the latest version is when you install it:</p>
			<pre>$ COMPOSEVERSION=1.25.4
$ curl -L https://github.com/docker/compose/releases/
download/$COMPOSEVERSION/docker-compose-`uname -s`-`uname -m` 
&gt;/tmp/docker-compose
$ chmod +x /tmp/docker-compose
$ sudo mv /tmp/docker-compose /usr/local/bin/docker-compose</pre>
			<p>Once it's <a id="_idIndexMarker039"/>installed, you should be able to run the following two <a id="_idIndexMarker040"/>commands to confirm the version of the software is correct:</p>
			<pre>$ docker-compose version</pre>
			<p>Now that we know how to install it on Linux, let's look at how we can install it on macOS.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor055"/>Installing Docker on macOS</h2>
			<p>Unlike the <a id="_idIndexMarker041"/>command-line<a id="_idIndexMarker042"/> Linux installation, Docker for Mac has a graphical installer.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">Before downloading, you should make sure that you are running at least Apple macOS X Yosemite 10.10.3 as this is minimum OS requirement to run the version of Docker we will be discussing in this title. If you are running an older version, all is not lost; you can still run Docker. Refer to the <em class="italic">Older operating systems</em> section of this chapter.</p>
			<p>Let's install Docker on macOS: </p>
			<ol>
				<li>Go to the Docker store at <a href="https://hub.docker.com/editions/community/docker-ce-desktop-mac">https://hub.docker.com/editions/community/docker-ce-desktop-mac</a>.</li>
				<li>Click on the <strong class="bold">Get Docker</strong> link. </li>
				<li>Once it's downloaded, you should have a <code>DMG</code> file. Double-clicking on it will mount the image, and opening the image mounted on your desktop should present<a id="_idIndexMarker043"/> you<a id="_idIndexMarker044"/> with something like this:<div><img src="img/image004.jpg" alt="Figure 1.4 – The drag and drop screen for the Docker installer for macOS&#13;&#10;" width="1415" height="655"/></div><p class="figure-caption">Figure 1.4 – The drag and drop screen for the Docker installer for macOS</p></li>
				<li>Once you have dragged the <strong class="bold">Docker</strong> icon to your <strong class="bold">Applications</strong> folder, double-click on it and you will be asked whether you want to open the application you have downloaded. </li>
				<li>Clicking <strong class="bold">Yes</strong> will open the Docker installer, showing the following prompt:<div><img src="img/image005.jpg" alt="Figure 1.5 – Prompt for the Docker installer&#13;&#10;" width="938" height="354"/></div><p class="figure-caption">Figure 1.5 – Prompt for the Docker installer</p></li>
				<li>Clicking on <strong class="bold">OK</strong> will bring up a dialogue that asks for your password. Once the password<a id="_idIndexMarker045"/> is entered, you should see a Docker icon in<a id="_idIndexMarker046"/> the top-left icon bar on your screen. </li>
				<li>Clicking on the icon and selecting <strong class="bold">About Docker</strong> should show you something similar to the following:<div><img src="img/image006.jpg" alt="Figure 1.6 – The About Docker screen&#13;&#10;" width="1422" height="877"/></div><p class="figure-caption">Figure 1.6 – The About Docker screen</p></li>
				<li>You can also run the following commands to check the version of Docker Compose<a id="_idIndexMarker047"/> that were installed alongside Docker Engine on<a id="_idIndexMarker048"/> the command line:<pre><strong class="bold">$ docker-compose version</strong></pre></li>
			</ol>
			<p>Now that we know how to install Docker on macOS, let's move on to our final operating system, Windows 10 Professional.</p>
			<h2 id="_idParaDest-28"><a id="_idTextAnchor056"/>Installing Docker on Windows 10 Professional</h2>
			<p>Like Docker <a id="_idIndexMarker049"/>for Mac, Docker for Windows<a id="_idIndexMarker050"/> uses a graphical installer.</p>
			<p class="callout-heading">Important Note</p>
			<p class="callout">Before downloading, you should make sure that you are running Microsoft Windows 10 Professional or Enterprise 64-bit. If you are running an older version or an unsupported edition of Windows 10, you can still run Docker; refer to the <em class="italic">Older operating systems</em> section of this chapter for more information. Docker for Windows has this requirement due to its reliance on Hyper-V. Hyper-V is Windows' native hypervisor and allows you to run x86-64 guests on your Windows machine, be it Windows 10 Professional or Windows Server. It even forms part of the Xbox One operating system.</p>
			<p>Let's install Docker for Windows:</p>
			<ol>
				<li value="1">Download the Docker for Windows installer from the Docker store at <a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows">https://hub.docker.com/editions/community/docker-ce-desktop-windows</a>. </li>
				<li>Click on the <strong class="bold">Get Docker</strong> button to download the installer. </li>
				<li>Once it's <a id="_idIndexMarker051"/>downloaded, run the installer<a id="_idIndexMarker052"/> package, and you will be greeted with the following:<div><img src="img/image007.jpg" alt="Figure 1.7 – Configuration screen of the Docker for Windows installer&#13;&#10;" width="937" height="367"/></div><p class="figure-caption">Figure 1.7 – Configuration screen of the Docker for Windows installer</p></li>
				<li>Leave the configuration at the default values and then click on <strong class="bold">OK</strong>. This will trigger an installation of all of the components needed to run Docker on Windows:<div><img src="img/image008.jpg" alt="Figure 1.8 – Docker installation in progress&#13;&#10;" width="627" height="507"/></div><p class="figure-caption">Figure 1.8 – Docker installation in progress</p></li>
				<li>Once it's<a id="_idIndexMarker053"/> installed, you will be prompted to<a id="_idIndexMarker054"/> restart. To do this, simply click on the <strong class="bold">Close and restart</strong> button:<div><img src="img/image009.jpg" alt="Figure 1.9 – Docker installation complete confirmation screen&#13;&#10;" width="538" height="340"/></div><p class="figure-caption">Figure 1.9 – Docker installation complete confirmation screen</p></li>
				<li>Once your machine has restarted, you should see a Docker icon in the icon tray in the bottom right of your screen. Clicking on it and selecting <strong class="bold">About Docker</strong> from the<a id="_idIndexMarker055"/> menu will show the<a id="_idIndexMarker056"/> following:<div><img src="img/image010.jpg" alt="Figure 1.10 – Docker About Me page&#13;&#10;" width="935" height="605"/></div><p class="figure-caption">Figure 1.10 – Docker About Me page</p></li>
				<li>Open a PowerShell window and type the following command:<pre><strong class="bold">$ docker version</strong></pre><p>This should also show you similar output to the Mac and Linux versions:</p></li>
			</ol>
			<div><div><img src="img/image011.jpg" alt="Figure 1.11 – Output of the docker version command&#13;&#10;" width="835" height="974"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Output of the docker version command</p>
			<p>Again, you<a id="_idIndexMarker057"/> can also run the following <a id="_idIndexMarker058"/>commands to check the versions of Docker Compose and Docker Machine that were installed alongside Docker Engine:</p>
			<pre>$ docker-compose version</pre>
			<p>You should see a similar output to the macOS and Linux versions. As you may have started to gather, once the packages are installed, their usage is going to be pretty similar. You will be able to see this when we get to the <em class="italic">Using Docker commands</em> section of this chapter.</p>
			<h2 id="_idParaDest-29"><a id="_idTextAnchor057"/>Older operating systems</h2>
			<p>If you are not<a id="_idIndexMarker059"/> running a sufficiently new operating system on Mac or Windows, then you will need to use Docker Toolbox. Consider the output printed from running the following command:</p>
			<pre>$ docker version</pre>
			<p>On all three of the installations we have performed so far, it shows two different versions, a client and a server. Predictably, the Linux version shows that the architecture for the client and server are both Linux; however, you may notice that the Mac version shows the client is running on Darwin, which is Apple's Unix-like kernel, and the Windows version shows Windows. Yet both of the servers show the architecture as being Linux, so what gives?</p>
			<p>That is because both the Mac and Windows versions of Docker download and run a virtual machine in the background, and this virtual machine runs a small, lightweight operating system based on Alpine Linux. The virtual machine runs using Docker's libraries, which connect to the built-in hypervisor for your chosen environment.</p>
			<p>For macOS, this is the built-in <strong class="bold">Hypervisor.framework</strong>, and for Windows, as we have already mentioned, it is <strong class="bold">Hyper-V</strong>.</p>
			<p>To ensure that no one misses out on the Docker experience, a version of Docker that does not use these built-in hypervisors is available for older versions of macOS and unsupported Windows versions. These versions utilize <strong class="bold">VirtualBox</strong> as the hypervisor to run the Linux server for your local client to connect to.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">VirtualBox is an open source x86 and AMD64/Intel64 virtualization product developed by Oracle. It runs on Windows, Linux, Macintosh, and Solaris hosts, with support for many Linux, Unix, and Windows guest operating systems.</p>
			<p>For more information on Docker Toolbox, see the project's website at <a href="https://github.com/docker/toolbox/">https://github.com/docker/toolbox/</a>, where you can also download the macOS and Windows installers from the releases page.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">This book assumes that you have installed the latest Docker version on Linux or have used Docker for Mac or Docker for Windows. While Docker installations using Docker Toolbox should be able to support the commands in this book, you may run into issues around file permissions and ownership when mounting data from your local machine to your containers.</p>
			<p>Now that you have Docker up and running on the system of your choice, let's start exploring the <a id="_idIndexMarker060"/>comm<a id="_idTextAnchor058"/>a<a id="_idTextAnchor059"/>nds that we need in order to use it effectively.</p>
			<h1 id="_idParaDest-30"><a id="_idTextAnchor060"/>Using Docker commands</h1>
			<p>You should already<a id="_idIndexMarker061"/> be familiar with these Docker commands. However, it's worth going through them to ensure you know all. We will start with some common commands and then take a peek at the commands that are used for the Docker images. We will then take a dive into the commands that are used for the containers.</p>
			<p class="callout-heading">Tip </p>
			<p class="callout">A while ago, Docker restructured their command-line client into more logical groupings of commands, as the number of features provided by the client multiplies and commands start to cross over each other. Throughout this book, we will be using this structure rather than some of the shorthand that still exists within the client.</p>
			<p>The first command we will be taking a look at is one of the most useful commands, not only in Docker but in any command-line utility you use – the <code>help</code> command. It is run simply like this:</p>
			<pre>$ docker help</pre>
			<p>This command will give you a full list of all of the Docker commands at your disposal, along with a brief description of what each command does. We will be looking at this in more detail in <a href="B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 4</em></a><em class="italic">, Managing Containers</em>. For further help with a particular command, you can run the following:</p>
			<pre>$ docker &lt;COMMAND&gt; --help</pre>
			<p>Next, let's run the <code>hello-world</code> container. To do this, simply run the following command:</p>
			<pre>$ docker container run hello-world</pre>
			<p>It doesn't matter what host you are running Docker on, the same thing will happen on Linux, macOS, and Windows. Docker will download the <code>hello-world</code> container image and then execute it, and once it's executed, the container will be stopped.</p>
			<p>Your Terminal <a id="_idIndexMarker062"/>session should look like the following:</p>
			<div><div><img src="img/image012.jpg" alt="Figure 1.12 – Output for docker container run hello-world&#13;&#10;" width="1271" height="1013"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Output for docker container run hello-world</p>
			<p>Let's try something a little more adventurous – let's download and run an NGINX container by running the following two commands:</p>
			<pre>$ docker image pull nginx
$ docker container run -d --name nginx-test -p 8080:80 nginx</pre>
			<p class="callout-heading">Important note </p>
			<p class="callout">NGINX is an open source web server that can be used as a load balancer, mail proxy, reverse proxy, and even an HTTP cache.</p>
			<p>The first of the two commands downloads the NGINX container image, and the second command launches a container in the background called <code>nginx-test</code>, using the <code>nginx</code> image we pulled. It also maps port <code>8080</code> on our host machine to port <code>80</code> on the container, making it accessible to our local browser at <a href="http://localhost:8080/">http://localhost:8080/</a>.</p>
			<p>As you can see from the following screenshots, the command and results are exactly the same on all three OS<a id="_idIndexMarker063"/> types. Here we have Linux:</p>
			<div><div><img src="img/image013.jpg" alt="Figure 1.13 – Output of docker image pull nginx on Linux&#13;&#10;" width="1595" height="1045"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Output of docker image pull nginx on Linux</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You may notice that the Linux and macOS screens at first glance look similar. That is because I am using a remote Linux server, and we will look more at how to do this in a later chapter.</p>
			<p>This is the result on macOS:</p>
			<div><div><img src="img/image014.jpg" alt="Figure 1.14 – Output of docker image pull nginx on macOS&#13;&#10;" width="1627" height="1029"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – Output of docker image pull nginx on macOS</p>
			<p>And this is<a id="_idIndexMarker064"/> how it looks on Windows:</p>
			<div><div><img src="img/image015.jpg" alt="Figure 1.15 – Output of docker image pull nginx on Windows&#13;&#10;" width="1085" height="857"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15 – Output of docker image pull nginx on Windows</p>
			<p>In the following<a id="_idIndexMarker065"/> three chapters, we will look at using the Docker command-line client in more detail. For now, let's stop and remove our <code>nginx-test</code> container by running the following:</p>
			<pre>$ docker container stop nginx-test
$ docker container rm nginx-test</pre>
			<p>As you can see, the experience of running a simple NGINX container on all three of the hosts on which we have installed Docker is exactly the same. As am I sure you can imagine, trying to achieve this without something like Docker across all three platforms is a challenge, and a very different experience on each platform too. Traditionally, this has been one of the reasons for the difference in local development environments as people would need to download a platform-specific installer and configure the service for the platform they are running. Also, in some cases there could be feature differences between the platforms.</p>
			<p>Now that we have a foundation in Docker commands, let's cast a wider net and look at its container <a id="_idIndexMarker066"/>ecosystem.</p>
			<h1 id="_idParaDest-31"><a id="_idTextAnchor061"/>Docker and the container ecosystem</h1>
			<p>If you have been<a id="_idIndexMarker067"/> following<a id="_idIndexMarker068"/> the rise of Docker and containers, you will have noticed that, throughout the last few years, the messaging on the Docker website has been slowly changing from headlines about what containers are to more of a focus on the services provided by Docker as a company.</p>
			<p>One of the core drivers for this is that everything has traditionally been lumped into being known just as 'Docker,' which can get confusing. Now that people did not need educating as much on what a container is or the problems they can solve with Docker, the company needed to try and start to differentiate themselves from competitors that sprung up to support all sorts of container technologies.</p>
			<p>So, let's try and unpack everything that is Docker, which involves the following:</p>
			<ul>
				<li><strong class="bold">Open source projects</strong>: There are several open source projects started by Docker, which are now maintained by a large community of developers.</li>
				<li><strong class="bold">Docker, Inc</strong>.: This is the company founded to support and develop the core Docker tools.</li>
				<li><strong class="bold">Docker CE and Docker EE</strong>: This is the core collection of Docker tools built on top of the open source components.</li>
			</ul>
			<p>We will also be looking at some third-party services in later chapters. In the meantime, let's go into more detail on each of these, starting with the open source projects.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor062"/>Open source projects</h2>
			<p>Docker, Inc. has<a id="_idIndexMarker069"/> spent the last few years open sourcing and donating a lot of its core projects to various open source foundations and communities. These projects include the following:</p>
			<ul>
				<li><strong class="bold">Moby Project</strong> is the upstream project upon which the Docker Engine is based. It provides all of the components needed to assemble a fully functional container system.</li>
				<li><strong class="bold">Runc</strong> is a command-line interface for creating and configuring containers and has been built to the OCI specification.</li>
				<li><strong class="bold">Containerd</strong> is an easily embeddable container runtime. It is also a core component of the Moby Project.</li>
				<li><strong class="bold">LibNetwork</strong> is a Go library that provides networking for containers. Notary is a client and server that aims to provide a trust system for signed container images.</li>
				<li><strong class="bold">HyperKit</strong> is a toolkit that allows you to embed hypervisor capabilities into your own applications; presently, it<a id="_idIndexMarker070"/> only supports the macOS and the Hypervisor framework.</li>
				<li><strong class="bold">VPNKit</strong> provides VPN functionality to HyperKit.</li>
				<li><strong class="bold">DataKit</strong> allows you to orchestrate application data using a Git-like workflow.</li>
				<li><strong class="bold">SwarmKit</strong> is a toolkit that enables you to build distributed systems using the same raft consensus algorithm as Docker Swarm.</li>
				<li><strong class="bold">LinuxKit</strong> is a framework that allows you to develop and compile a small portable Linux operating system for running containers.</li>
				<li><strong class="bold">InfraKit</strong> is a collection of tools that you can use to define the infrastructure to run your <strong class="bold">LinuxKit</strong> generated distributions on.</li>
			</ul>
			<p>On their own, you will probably never use the individual components; however, each of the projects mentioned is a component of the tools that are maintained by Docker, Inc. We will go a little more into these projects in our final chapter.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor063"/>Docker, Inc.</h2>
			<p>Docker, Inc. is<a id="_idIndexMarker071"/> the<a id="_idIndexMarker072"/> company formed to initially develop <strong class="bold">Docker Community Edition</strong> (<strong class="bold">Docker CE</strong>) and <strong class="bold">Docker Enterprise Edition</strong> (<strong class="bold">Docker EE</strong>). It also used to provide an SLA-based support <a id="_idIndexMarker073"/>service for Docker EE as well as offering consulting services to companies who wish to take their existing applications and containerize <a id="_idIndexMarker074"/>them as part of Docker's <strong class="bold">Modernise Traditional Apps</strong> (<strong class="bold">MTA</strong>) program.</p>
			<p>You will notice that I referred to a lot of the things in the previous sentence in the past tense. This is because in November 2019 Docker, Inc. restructured and sold its platform business to a company<a id="_idIndexMarker075"/> called Mirantis Inc. They<a id="_idIndexMarker076"/> acquired the following assets from Docker, Inc.:</p>
			<ul>
				<li><strong class="bold">Docker Enterprise</strong>, including Docker EE</li>
				<li><strong class="bold">Docker Trusted Registry</strong></li>
				<li><strong class="bold">Docker Unified Control Plane</strong></li>
				<li><strong class="bold">Docker CLI</strong></li>
			</ul>
			<p>Mirantis Inc. is a California-based company that focuses on the development and support of <strong class="bold">OpenStack-</strong> and <strong class="bold">Kubernetes-based</strong> solutions. It was one of the founders of the non-profit <a id="_idIndexMarker077"/>corporate entity OpenStack Foundation and had a vast amount of experience of providing enterprise-level support.</p>
			<p>Former Docker, Inc. CEO Rob Bearden, who stepped down shortly after the announcement, was quoted as saying:</p>
			<p class="author-quote">'After conducting thorough analysis with the management team and the Board of Directors, we determined that Docker had two very distinct and different businesses: one an active developer business, and the other a growing enterprise business. We also found that the product and the financial models were vastly different. This led to the decision to restructure the company and separate the two businesses, which is the best thing for customers and to enable Docker's industry-leading technology to thrive.'</p>
			<p>With the Enterprise business now with Mirantis Inc., Docker, Inc. is focusing on providing better developer workflows with Docker Desktop and Docker Hub, which allows users to avoid the threat of vendor lock-in.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor064"/>Docker CE and Docker EE</h2>
			<p>There are a lot<a id="_idIndexMarker078"/> of tools supplied and <a id="_idIndexMarker079"/>supported by Docker, Inc. Some we have already mentioned, and others we will cover in later chapters. Before we finish this, our first chapter, we should get an idea of the tools we are going to be using. The most of important of them is the core Docker Engine.</p>
			<p>This is the core of Docker, and all of the other tools that we will be covering use it. We have already been using it as we installed it in the Docker installation and Docker commands sections of this chapter. There are currently two versions of Docker Engine; there is Docker EE, which is now maintained by Mirantis Inc., and Docker CE. We will be using Docker CE throughout this book.</p>
			<p>As well as the stable version of Docker CE, Docker will be providing nightly builds of the Docker Engine via a nightly repository (formally Docker CE Edge), and monthly builds of Docker for Mac and Docker for Windows via the Edge channel.</p>
			<p>There are also the following tools:</p>
			<ul>
				<li><strong class="bold">Docker Compose</strong>: A tool<a id="_idIndexMarker080"/> that allows you to define and share multi-container definitions; it is detailed in <a href="B15659_05_Final_JM_ePub.xhtml#_idTextAnchor157"><em class="italic">Chapter 5</em></a>, <em class="italic">Docker Compose</em>.</li>
				<li><strong class="bold">Docker Machine</strong>: A tool<a id="_idIndexMarker081"/> to launch Docker hosts on multiple platforms; we will cover this in <a href="B15659_06_Final_JM_ePub.xhtml#_idTextAnchor187"><em class="italic">Chapter 6</em></a>, <em class="italic">Managing Containers</em>.</li>
				<li><strong class="bold">Docker Hub</strong>: A repository<a id="_idIndexMarker082"/> for your Docker images, covered in the next three chapters.</li>
				<li><strong class="bold">Docker Desktop (Mac)</strong>: We <a id="_idIndexMarker083"/>have covered Docker for Mac in this chapter.</li>
				<li><strong class="bold">Docker Desk/top (Windows)</strong>: We<a id="_idIndexMarker084"/> have covered Docker for Windows in this chapter.</li>
				<li><strong class="bold">Docker Swarm</strong>: A multi-host-aware<a id="_idIndexMarker085"/> orchestration tool, covered in detail in <a href="B15659_08_Final_JM_ePub.xhtml#_idTextAnchor230"><em class="italic">Chapter 8</em></a>, <em class="italic">Docker Swarm</em>. Mirantis Inc now maintains this.</li>
			</ul>
			<h1 id="_idParaDest-35"><a id="_idTextAnchor065"/>Summary</h1>
			<p>In this chapter, we covered some basic information that you should already know (or now know) for the chapters ahead. We went over the basics of what Docker is, and how it fares compared to other host types. We went over the installers, how they operate on different operating systems, and how to control them through the command line. Be sure to remember to look at the requirements for the installers to ensure you use the correct one for your operating system.</p>
			<p>Then, we took a small dive into using Docker and issued a few basic commands to get you started. We will be looking at all of the management commands in future chapters to get a more in-depth understanding of what they are, as well as how and when to use them. Finally, we discussed the Docker ecosystem and the responsibilities of each of the different tools.</p>
			<p>In the next chapter, we will be taking a look at how to build base containers, and we will also look in depth at Dockerfiles and places to store your images, as well as using environmental variables and Docker volumes.</p>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor066"/>Questions</h1>
			<ol>
				<li value="1">Where can you download Docker Desktop (Mac) and Docker Desktop (Windows) from?</li>
				<li>What command did we use to download the NGINX image?</li>
				<li>Which open source project is upstream for the core Docker Engine?</li>
				<li>Which company now maintains Docker Enterprise?</li>
				<li>Which command would you run to find out more information on the Docker container subset of commands?</li>
			</ol>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor067"/>Further reading</h1>
			<p>These are the companies involved in maintaining Docker:</p>
			<ul>
				<li>Docker, Inc.: <a href="http://docker.com">http://docker.com</a></li>
				<li>Mirantis Inc.: <a href="https://www.mirantis.com">https://www.mirantis.com</a></li>
				<li>Docker restructure:  <a href="https://www.computerweekly.com/news/252473956/Docker-restructure-sees-enterprise-platform-business-sold-to-open-source-cloud-firm-Mirantis">https://www.computerweekly.com/news/252473956/Docker-restructure-sees-enterprise-platform-business-sold-to-open-source-cloud-firm-Mirantis</a> </li>
			</ul>
			<p>In this chapter, we have mentioned the following hypervisors:</p>
			<ul>
				<li>macOS Hypervisor framework: <a href="https://developer.apple.com/documentation/hypervisor">https://developer.apple.com/documentation/hypervisor</a></li>
				<li>Hyper-V: <a href="https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v">https://docs.microsoft.com/en-us/virtualization/hyper-v-on-windows/quick-start/enable-hyper-v</a></li>
			</ul>
			<p>For details on how to install on other Linux distributions, take a look at the Install Docker Engine page of the Docker docs: <a href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a>.</p>
			<p>We referenced the following blog posts from Docker:</p>
			<ul>
				<li>Docker CLI restructure blog post: <a href="https://www.docker.com/blog/whats-new-in-docker-1-13/">https://www.docker.com/blog/whats-new-in-docker-1-13/</a></li>
				<li>Docker Extended Support Announcement: <a href="https://www.docker.com/blog/extending-support-cycle-docker-community-edition/">https://www.docker.com/blog/extending-support-cycle-docker-community-edition/</a></li>
			</ul>
			<p>Next up, we discussed the following open source projects:</p>
			<ul>
				<li>Moby Project: <a href="https://mobyproject.org">https://mobyproject.org</a></li>
				<li>Runc: <a href="https://github.com/opencontainers/runc">https://github.com/opencontainers/runc</a></li>
				<li>Containerd: <a href="https://containerd.io">https://containerd.io</a> </li>
				<li>LibNetwork: <a href="https://github.com/moby/libnetwork">https://github.com/moby/libnetwork</a></li>
				<li>Notary: <a href="https://github.com/theupdateframework/notary">https://github.com/theupdateframework/notary</a></li>
				<li>HyperKit: <a href="https://github.com/moby/hyperkit">https://github.com/moby/hyperkit</a></li>
				<li>VPNKit: <a href="https://github.com/moby/vpnkit">https://github.com/moby/vpnkit</a></li>
				<li>DataKit: <a href="https://github.com/moby/datakit">https://github.com/moby/datakit</a></li>
			</ul>
		</div>
	</div>



  </body></html>