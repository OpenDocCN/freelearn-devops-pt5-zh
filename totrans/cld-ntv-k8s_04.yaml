- en: '*Chapter 3*: Running Application Containers on Kubernetes'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains a comprehensive overview of the smallest Lego block that
    Kubernetes provides – the Pod. Included is an explanation of the PodSpec YAML
    format and possible configurations, and a quick discussion of how Kubernetes handles
    and schedules Pods. The Pod is the most basic way to run applications on Kubernetes
    and is used in all higher-order application controllers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Pod?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pod life cycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Pod resource spec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pod scheduling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool, along with a working Kubernetes
    cluster. See [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016), *Communicating
    with Kubernetes*, for several methods for getting up and running with Kubernetes
    quickly, and for instructions on how to install the `kubectl` tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code used in this chapter can be found in the book''s GitHub repository
    at the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter3)'
  prefs: []
  type: TYPE_NORMAL
- en: What is a Pod?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Pod is the simplest compute resource in Kubernetes. It specifies one or
    more containers to be started and run by the Kubernetes scheduler on a node. Pods
    have many potential configurations and extensions but remain the most basic way
    to run applications on Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: A Pod by itself is not a very good way to run applications on Kubernetes. Pods
    should be treated like fdisposable things in order to take advantage of the true
    capabilities of a container orchestrator like Kubernetes. This means treating
    containers (and therefore Pods) like cattle, not pets. To really make use of containers
    and Kubernetes, applications should be run in self-healing, scalable groups. The
    Pod is the building block of these groups, and we'll get into how to configure
    applications this way in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pods are implemented using Linux isolation tenets such as groups and namespaces,
    and generally can be thought of as a logical host machine. Pods run one or more
    containers (which can be based on Docker, CRI-O, or other runtimes) and these
    containers can communicate with each other in the same ways that different processes
    on a VM can communicate.
  prefs: []
  type: TYPE_NORMAL
- en: In order for containers within two different Pods to communicate, they need
    to access the other Pod (and container) via its IP. By default, only containers
    running on the same Pod can use lower-level methods of communication, though it
    is possible to configure different Pods with the availability to talk to each
    other via host IPC.
  prefs: []
  type: TYPE_NORMAL
- en: Pod paradigms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At the most basic level, there are two types of Pods:'
  prefs: []
  type: TYPE_NORMAL
- en: Single-container Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multi-container Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is generally a best practice to include a single container per Pod. This
    approach allows you to scale the different parts of your application separately,
    and generally keeps things simple when it comes to creating a Pod that starts
    and runs without issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Multi-container Pods, on the other hand, are more complex but can be useful
    in various circumstances:'
  prefs: []
  type: TYPE_NORMAL
- en: If there are multiple parts of your application that run in separate containers
    but are tightly coupled, you can run them both inside the same Pod to make communication
    and filesystem access seamless.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When implementing the *sidecar* pattern, where utility containers are injected
    alongside your main application to handle logging, metrics, networking, or advanced
    functionality such as a Service Mesh (more on this in [*Chapter 14*](B14790_14_Final_PG_ePub.xhtml#_idTextAnchor307),
    *Service Meshes and Serverless*).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram shows a common sidecar implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Common sidebar implementation](img/B14790_03_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Common sidebar implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we have a single Pod with two containers: our application
    container running a web server, and a logging application that pulls logs from
    our server Pod and forwards them to our logging infrastructure. This is a very
    applicable use of the sidecar pattern, though many log collectors work at the
    node level, not at the Pod level, so this is not a universal way of collecting
    logs from our app containers in Kubernetes.'
  prefs: []
  type: TYPE_NORMAL
- en: Pod networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we just mentioned, Pods have their own IP addresses that can be used in inter-pod
    communication. Each Pod has an IP address as well as ports, which are shared among
    the containers running in a Pod if there is more than one container.
  prefs: []
  type: TYPE_NORMAL
- en: Within a Pod, as we mentioned before, containers can communicate without calling
    the wrapping Pod's IP – instead they can simply use localhost. This is because
    containers within a Pod share a network namespace – in essence, they communicate
    via the same *bridge*, which is implemented using a virtual network interface.
  prefs: []
  type: TYPE_NORMAL
- en: Pod storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Storage in Kubernetes is a large topic on its own, and we will review it in
    depth in [*Chapter 7*](B14790_07_Final_PG_ePub.xhtml#_idTextAnchor166), *Storage
    on Kubernetes* – but for now, you can think of Pod storage as either persistent
    or non-persistent volumes attached to a Pod. Non-persistent volumes can be used
    by a Pod to store data or files depending on the type, but they are deleted when
    the Pod shuts down. Persistent-type volumes will remain past Pod shutdown and
    can even be used to share data between multiple Pods or applications.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can continue with our discussion of Pods, we will take a quick moment
    to discuss namespaces. Since we'll be working with `kubectl` commands during our
    work with Pods, it's important to know how namespaces tie into Kubernetes and
    `kubectl`, since it can be a big "gotcha."
  prefs: []
  type: TYPE_NORMAL
- en: Namespaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We talked briefly about namespaces in the section on authorization in *Chapter
    1*, *Communicating with Kubernetes*, but we will reiterate and expand on their
    purpose here. Namespaces are a way to logically separate different areas within
    your cluster. A common use case is having a namespace per environment – one for
    dev, one for staging, one for production – all living inside the same cluster.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned in the *Authorization* section, it is possible to specify user
    permissions on a per-namespace basis – for instance, letting a user deploy new
    applications and resources to the `dev` namespace but not to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your running cluster, you can see what namespaces exist by running `kubectl
    get namespaces` or `kubectl get ns`, which should result in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To create a namespace imperatively, you can simply run `kubectl create namespace
    staging`, or run `kubectl apply -f /path/to/file.yaml` with the following YAML
    resource spec:'
  prefs: []
  type: TYPE_NORMAL
- en: Staging-ns.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, a `Namespace` spec is very simple. Let's move on to something
    more complex – the PodSpec itself.
  prefs: []
  type: TYPE_NORMAL
- en: The Pod life cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To quickly see which Pods are running in your cluster, you can run `kubectl
    get pods` or `kubectl get pods --all-namespaces` to get Pods in either the current
    namespace (defined by your `kubectl` context, or the default namespace if none
    is specified) or all namespaces, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of `kubectl get pods` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Pods have a `STATUS` value that tells us in which state the
    Pod currently is.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values for Pod state are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Running` status, a Pod has successfully spun up its container(s) without any
    issues. If the Pod has a single container, and it''s in `Running` status, then
    the container has not completed or exited its process. It could also currently
    be restarting, which you can tell by checking the `READY` column. If, for instance,
    the `READY` value is `0/1`, that means that the container in the Pod is currently
    not passing health checks. This could be for a variety of reasons: the container
    could still be spinning up, a database connection could be non-functional, or
    some important configuration could be preventing the application process from
    starting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Succeeded` state if those containers have completed their process command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pending` statuses designate that at least one container in the Pod is waiting
    for its image. This is likely because the container image is still being fetched
    from an external repository, or because the Pod itself is waiting to be scheduled
    by `kube-scheduler`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unknown` status means that Kubernetes cannot tell what state the Pod is actually
    in. This usually means that the node that the Pod lives on is experiencing some
    form of error. It may be out of disk space, disconnected from the rest of the
    cluster, or otherwise be encountering problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failed` status, one or more of the containers in the Pod has terminated with
    a failure status. Additionally, the other containers in the Pod must have terminated
    in either success or failure. This can happen for a variety of reasons due to
    the cluster removing Pods or something inside the container application breaking
    the process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the Pod resource spec
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the Pod resource spec is the first one we've really dug into, we will
    spend our time detailing the various parts of the YAML file and how they fit together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start things off with a fully spec''d-out Pod file, which we can then
    pick apart and review:'
  prefs: []
  type: TYPE_NORMAL
- en: Simple-pod.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This Pod YAML file is somewhat more complicated than the one that we looked
    at in the first chapter. It exposes some new Pod functionality that we will review
    shortly.
  prefs: []
  type: TYPE_NORMAL
- en: API version
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s start at line 1: `apiVersion`. As we mentioned in [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016),
    *Communicating with Kubernetes*, `apiVersion` tells Kubernetes which version of
    the API to look at when creating and configuring your resource. Pods have been
    around for a long time in Kubernetes, so the PodSpec is solidified into API version
    `v1`. Other resource types may contain group names in addition to version names
    – for instance, a CronJob resource in Kubernetes uses `batch/v1beta1` `apiVersion`,
    while the Job resource uses the `batch/v1` `apiVersion`. In both of these, `batch`
    corresponds to the API group name.'
  prefs: []
  type: TYPE_NORMAL
- en: Kind
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `kind` value corresponds to the actual name of the resource type in Kubernetes.
    In this case, we're trying to spec out a Pod, so that's what we put. The `kind`
    value is always in camel case, such as `Pod`, `ConfigMap`, `CronJob`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of `kind` values, check the official Kubernetes documentation
    at [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/). New Kubernetes
    `kind` values are added in new releases so the ones reviewed in this book may
    not be an exhaustive list.
  prefs: []
  type: TYPE_NORMAL
- en: Metadata
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Metadata is a top-level key that can have several different values underneath.
    First of all, `name` is the resource name, which is what the resource will display
    as via `kubectl` and what it is stored as in `etcd`. `namespace` corresponds to
    the namespace that the resource should be created in. If no namespace is specified
    in the YAML spec, the resource will be created in the `default` namespace – unless
    a namespace is specified in the `apply` or `create` commands.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `labels` are key-value pairs that are used to add metadata to a resource.
    `labels` are special compared to other metadata because they are used by default
    in Kubernetes native `selectors` to filter and select resources – but they can
    also be used for custom functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the `metadata` block can play host to multiple `annotations` which,
    like `labels`, can be used by controllers and custom Kubernetes functionality
    to provide additional configuration and feature-specific data. In this PodSpec,
    we have several annotations specified in our metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-annotations.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Generally, it is better to use `labels` for Kubernetes-specific functionality
    and selectors while using `annotations` for adding data or extension functionality
    – this is just a convention.
  prefs: []
  type: TYPE_NORMAL
- en: Spec
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`spec` is the top-level key that contains the resource-specific configuration.
    In this case, since our `kind` value is `Pod`, we''ll add some configuration that
    is specific to our Pod. All further keys will be indented under this `spec` key
    and will represent our Pod configuration.'
  prefs: []
  type: TYPE_NORMAL
- en: Containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `containers` key expects a list of one or more containers that will run
    within a Pod. Each container spec will expose its own configuration values, which
    are indented under the container list item in your resource YAML. We will review
    some of these configurations here, but for a full list, check the Kubernetes documentation
    ([https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)).
  prefs: []
  type: TYPE_NORMAL
- en: Name
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inside a container spec, `name` pertains to what the container will be named
    within a Pod. Container names can be used to specifically access the logs of a
    particular container using the `kubectl logs` command, but we'll get to that later.
    For now, ensure you choose a clear name for each container in your Pod to make
    things easier when it comes to debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Image
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For each container, `image` is used to specify the name of the Docker (or other
    runtime) image that should be started within the Pod. Images will be pulled from
    the configured repository, which is the public Docker Hub by default, but can
    be a private repository as well.
  prefs: []
  type: TYPE_NORMAL
- en: And that's it – that's all you need to specify a Pod and run it in Kubernetes.
    Everything from this point on in the `Pod` section falls under the *additional
    configuration* umbrella.
  prefs: []
  type: TYPE_NORMAL
- en: Pod resource specifications
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Pods can be configured to have specific amounts of memory and compute allocated
    to them. This prevents particularly hungry applications from impacting cluster
    performance and can also help prevent memory leaks. There are two possible resources
    that can be specified – `cpu` and `memory`. For each of these, there are two different
    types of specifications, `Requests` and `Limits`, for a total of four possible
    resource specification keys.
  prefs: []
  type: TYPE_NORMAL
- en: Memory requests and limits can be configured with any typical memory number
    suffix, or its power-of-two equivalent – for instance, 50 Mi (mebibytes), 50 MB
    (megabytes), or 1 Gi (gibibytes).
  prefs: []
  type: TYPE_NORMAL
- en: 'CPU requests and limits can be configured either by using `m` which corresponds
    to 1 milli-CPU, or by just using a decimal number. So `200m` is equivalent to
    `0.2`, which equals 20% or one fifth of a logical CPU. This quantity will be the
    same amount of compute power regardless of the number of cores. 1 CPU equals a
    virtual core in AWS or a core in GCP. Let''s look at how these resource requests
    and limits look in our YAML file:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-resource-limits.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this `Pod`, we have a container running a Docker image that is specified
    with both requests and limits on `cpu` and `memory`. In this case, our container
    image name, `mydockername`, is a placeholder - but if you want to test the Pod
    resource limits in this example, you can use the busybox image.
  prefs: []
  type: TYPE_NORMAL
- en: Container start commands
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When a container starts in a Kubernetes Pod, it runs the default start script
    for the container – for instance, the script specified in the Docker container
    spec. In order to override this functionality with different commands or additional
    arguments, you can provide the `command` and `args` keys. Let''s look at a container
    configured with a `start` command and some arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-start-command.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we specify a command as well as a list of arguments as an array
    of strings, separated with commas where spaces would be.
  prefs: []
  type: TYPE_NORMAL
- en: Init containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`init` containers are special containers within a Pod that start, run, and
    shut down before the normal Pod container(s) start.'
  prefs: []
  type: TYPE_NORMAL
- en: '`init` containers can be used for many different use cases, such as initializing
    files before an application starts or ensuring that other applications or services
    are running before starting a Pod.'
  prefs: []
  type: TYPE_NORMAL
- en: If multiple `init` containers are specified, they will run in order until all
    `init` containers have shut down. For this reason, `init` containers must run
    a script that completes and has an endpoint. If your `init` container script or
    application keeps running, the normal container(s) in your Pod will not start.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following Pod, the `init` container is running a loop to check that
    our `config-service` exists via `nslookup`. Once it sees that `config-service`
    is up, the script ends, which triggers our `my-app` app container to start:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-init-container.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When an `init` container fails, Kubernetes will automatically restart the Pod,
    similar to the usual Pod startup functionality. This functionality can be changed
    by changing `restartPolicy` at the Pod level.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a diagram showing the typical Pod startup flow in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Init container flowchart](img/B14790_03_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Init container flowchart
  prefs: []
  type: TYPE_NORMAL
- en: 'If a Pod has more than one `initContainer`, they will be invoked sequentially.
    This is valuable for times where you set up `initContainers` with modular steps
    that must be executed in order. The following YAML shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-multiple-init-containers.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: For instance, in this `Pod` YAML file, the `step-1 init` container needs to
    succeed before `init-step-2` is invoked, and both need to show success before
    the `my-app` container will be started.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing different types of probes in Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to know when a container (and therefore a Pod) has failed, Kubernetes
    needs to know how to test that the container is functioning. We do this by defining
    `probes`, which Kubernetes can run at a specified interval to determine whether
    the container is working.
  prefs: []
  type: TYPE_NORMAL
- en: There are three types of probes that Kubernetes lets us configure – readiness,
    liveness, and startup.
  prefs: []
  type: TYPE_NORMAL
- en: Readiness probes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First off, readiness probes can be used to determine whether a container is
    ready to perform a function such as accepting traffic via HTTP. These probes are
    helpful in the beginning stages of a running application, where it may still be
    fetching the configuration, for instance, and not yet be ready to accept connections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at what a Pod with a readiness probe configured looks like.
    What follows is a PodSpec with a readiness probe attached:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-readiness-probe.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: For starters, as you can see, probes are defined per container, not per Pod.
    Kubernetes will run all probes per container and use that to determine the total
    health of the Pod.
  prefs: []
  type: TYPE_NORMAL
- en: Liveness probes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Liveness probes can be used to determine whether an application has failed
    for some reason (for instance, due to a memory error). For application containers
    that run a long time, liveness probes can come in handy as a method to help Kubernetes
    recycle old and broken Pods for new ones. Though probes in and of themselves won''t
    cause a container to restart, other Kubernetes resources and controllers will
    check the probe status and use it to restart Pods when necessary. Here is a PodSpec
    with a liveness probe definition attached to it:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-liveness-probe.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our liveness probe is specified in the same way as our readiness
    probe, with one addition – `failureThreshold`.
  prefs: []
  type: TYPE_NORMAL
- en: The `failureThreshold` value will determine how many times Kubernetes will attempt
    the probe before taking action. For liveness probes, Kubernetes will restart the
    Pod once the `failureThreshold` is crossed. For readiness probes, Kubernetes will
    simply mark the Pod as `Not Ready`. The default value for this threshold is `3`,
    but it can be changed to any value greater than or equal to `1`.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we are using the `exec` mechanism with our probe. We will review
    the various probe mechanisms available shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Startup probes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, startup probes are a special type of probe that will only run once,
    on container startup. Some (often older) applications will take a long time to
    start up in a container, so by providing some extra leeway when a container starts
    up the first time, you can prevent the liveness or readiness probes failing and
    causing a restart. Here''s a startup probe configured with our Pod:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-startup-probe.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Startup probes provide a benefit greater than simply extending the time between
    liveness or readiness probes – they allow Kubernetes to maintain a quick reaction
    time when addressing problems that happen after startup and (more importantly)
    to prevent slow-starting applications from restarting constantly. If your application
    takes many seconds or even a minute or two to start up, you will have a much easier
    time implementing a startup probe.
  prefs: []
  type: TYPE_NORMAL
- en: '`successThreshold` is just what it seems, the opposite side of the coin to
    `failureThreshold`. It specifies how many successes in a row are required before
    a container is marked `Ready`. For applications that can go up and down on startup
    before stabilizing (like some self-clustering applications), changing this value
    can be useful. The default is `1`, and for liveness probes the only possible value
    is `1`, but we can change the value for readiness and startup probes.'
  prefs: []
  type: TYPE_NORMAL
- en: Probe mechanism configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There are multiple mechanisms to specify any of the three probes: `exec`, `httpGet`,
    and `tcpSocket`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `exec` method allows you to specify a command that will be run inside the
    container. A successfully executed command will result in a passed probe, while
    a command that fails will result in a fail on the probe. All the probes we've
    configured so far have used the `exec` method, so configuration should be self-evident.
    If the chosen command (with any arguments specified in comma-separated list form)
    fails, the probe will fail.
  prefs: []
  type: TYPE_NORMAL
- en: The `httpGet` method for probes allows you to specify a URL on the container
    that will be hit with an HTTP `GET` request. If the HTTP request returns a code
    anywhere between `200` to `400`, it will result in a success on the probe. Any
    other HTTP code will result in a failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for `httpGet` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-get-probe.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the `tcpSocket` method will try to open the specified socket on the
    container and will use the result to dictate a success or failure. The `tcpSocket`
    configuration looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: pod-with-tcp-probe.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this type of probe takes in a port, which will be pinged every
    time the check occurs.
  prefs: []
  type: TYPE_NORMAL
- en: Common Pod transitions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Failing Pods in Kubernetes tend to transition between statuses quite a bit.
    For a first-time user, this can be intimidating, so it is valuable to break down
    how the Pod statuses we listed earlier interact with probe functionality. Just
    to reiterate, here are our statuses:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Running`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Succeeded`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pending`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unknown`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Failed`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common flow is to run `kubectl get pods -w` (the `-w` flag adds a watch to
    the command) and see offending Pods transitioning between `Pending` and `Failed`.
    Typically, what is occurring is that the Pods (and their containers) are spinning
    up and pulling images – which is the `Pending` state since the health checks have
    not yet started.
  prefs: []
  type: TYPE_NORMAL
- en: Once the initial probe timeout (which as we saw in the previous section is configurable)
    elapses, the first probe fails. This can continue for seconds or even minutes
    depending on how high the failure threshold is, with the status still pinned at
    `Pending`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our failure threshold is reached, and our Pod status transitions to
    `Failed`. At this point, one of two things can happen, and the decision is based
    purely on the `RestartPolicy` on the PodSpec, which can either be `Always`, `Never`,
    or `OnFailure`. If a Pod fails and the `restartPolicy` is `Never`, the Pod will
    stay in the failed status. If it is one of the other two options, the Pod will
    restart automatically, and go back to `Pending`, which is the root cause of our
    never-ending transition cycle.
  prefs: []
  type: TYPE_NORMAL
- en: For a different example, you may see Pods stuck forever in the `Pending` status.
    This can be due to the Pod failing to be scheduled on any node. This could be
    due to resource request constraints (which we will cover in depth later in this
    book, in [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186), *Pod Placement
    Controls*), or other issues such as nodes being unreachable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with `Unknown`, typically the node that the Pod is scheduled on is
    unreachable for some reason – the node might have shut down, for instance, or
    is unreachable via the network.
  prefs: []
  type: TYPE_NORMAL
- en: Pod scheduling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complexities of Pod scheduling and the ways the Kubernetes lets you influence
    and control it will be saved for our [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls* – but for now we will review the basics.
  prefs: []
  type: TYPE_NORMAL
- en: When deciding where to schedule a Pod, Kubernetes takes many factors into account,
    but the most important to consider (when not delving into the more complex controls
    that Kubernetes lets us use) are Pod priority, node availability, and resource
    availability.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes scheduler operates a constant control loop that monitors the
    cluster for unbound (unscheduled) Pods. If one or more unbound Pods is found,
    the scheduler will use the Pod priority to decide which one to schedule first.
  prefs: []
  type: TYPE_NORMAL
- en: Once the scheduler has decided on a Pod to schedule, it will perform several
    rounds and types of checks in order to find the local optima of a node for where
    to schedule the Pod. The latter rounds of checks are dictated by granular scheduling
    controls, which we'll get into in the [*Chapter 8*](B14790_08_Final_PG_ePub.xhtml#_idTextAnchor186),
    *Pod Placement Controls*. We'll worry about the first couple of checks for now.
  prefs: []
  type: TYPE_NORMAL
- en: First, Kubernetes checks to see which nodes are even schedulable at the current
    moment. Nodes may be non-functioning or otherwise encountering issues that would
    prevent new Pods from being scheduled.
  prefs: []
  type: TYPE_NORMAL
- en: Secondly, Kubernetes filters schedulable nodes by checking to see which of those
    nodes match the minimum resource requirement stated in the PodSpec.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, in the absence of any other placement controls, the scheduler
    will make its decision and assign our new Pod to a node. When the `kubelet` on
    that node sees that it has a new Pod assigned to it, the Pod will be spun up.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that Pods are the most basic building block we have
    to work with in Kubernetes. It's important to have a strong understanding of Pods
    and all their subtleties because all compute on Kubernetes uses Pods as a building
    block. It's probably pretty obvious by now, but Pods are very small, individual
    things that are not very sturdy. Running an application as a single Pod on Kubernetes
    with no controller is a bad decision, and any issue with your Pod will result
    in downtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll see how to prevent this by using Pod controllers
    to run multiple replicas of an application at once.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How could you use namespaces to separate application environments?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a possible reason for a Pod status to be listed as `Unknown`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What could be a reason for constraining Pod memory resources?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If an application running on Kubernetes often does not start in time before
    a failed probe restarts the Pod, which probe type should you tune? Readiness,
    liveness, or startup?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official Kubernetes documentation: [https://kubernetes.io/docs/home/](https://kubernetes.io/docs/home/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Kubernetes The Hard Way*: [https://github.com/kelseyhightower/kubernetes-the-hard-way](https://github.com/kelseyhightower/kubernetes-the-hard-way)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
