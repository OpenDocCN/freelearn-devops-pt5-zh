- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying a LAMP Stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will look at deploying a complete LAMP stack using the various
    core modules that ship with Ansible. We will target the local Multipass virtual
    machine we first used in [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017), *Installing
    and* *Running Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The playbook layout – how our playbook is going to be structured
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux – preparing the Linux server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apache – installing and configuring Apache
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MariaDB – installing and configuring MariaDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP – installing and configuring PHP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The playbook structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LAMP stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The LAMP playbook
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we start writing the playbook, we will discuss the structure we will
    use after we briefly discuss what we need for the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will again use the local Multipass virtual machine we launched in the previous
    chapters. As we will be installing all the elements of a LAMP stack on the virtual
    machine, your Multipass virtual machine will need to be able to download packages
    from the internet; in all, there is around 500 MB of packages and configuration
    to download.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete copy of the playbook in the repository accompanying
    this book at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: The playbook structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017), *Installing and Running
    Ansible*, the playbooks we ran were as basic as possible. They have been in a
    single file, accompanied by a host inventory file, and, if required, a template
    file. Then, in [*Chapter 2*](B21620_02.xhtml#_idTextAnchor080), *Exploring Ansible
    Galaxy*, we extended our playbook files to include roles rather than putting all
    our tasks, handlers, and variables into one file.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the following layout, there are several folders and files:'
  prefs: []
  type: TYPE_NORMAL
- en: "![\uFEFFFigure 4.1 – The folder structure we will use for our playbook](img/B21620_04_1.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The folder structure we will use for our playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'While there is a copy of the structure in the repository, let’s work on creating
    the structure and discuss each item as we create it. The first folder we need
    to create is our top-level folder. This is the folder that will contain our playbook
    folders and files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The next folder we are going to create is one called `group_vars`. This will
    contain the variable files used in our playbook. For now, we are going to create
    a single variable file called `common.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to create two files – our host inventory file, which we
    will name `hosts`, and our master playbook, which is typically called `site.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The final folder we are going to create manually is called `roles`. Here, we
    are going to use the `ansible-galaxy` command, which we learned about in [*Chapter
    2*](B21620_02.xhtml#_idTextAnchor080), *Exploring Ansible Galaxy*, to create a
    role called `common`. To do this, we use the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This should create all the files needed to start writing the `common` role.
  prefs: []
  type: TYPE_NORMAL
- en: The `cloud-init.yaml`, `example_key`, `example_key.pub`, and `hosts.example`
    files are all lifted straight from [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017),
    *Installing and Running Ansible*, and [*Chapter 2*](B21620_02.xhtml#_idTextAnchor080),
    *Exploring Ansible Galaxy*, so we will not cover them again in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While we will work through each of the files individually in this and the following
    sections, a complete copy of the playbook is available in the accompanying GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each of the four roles in our playbook and install and configure
    our LAMP stack.
  prefs: []
  type: TYPE_NORMAL
- en: The LAMP stack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The LAMP stack is the term used to describe an all-in-one web and database
    server. Typically, the components are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux** is the underlying operating system; in our case, we will use Ubuntu
    22.04'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Apache** is the web server element of the stack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MariaDB** is what we will use as the database component of the stack; typically,
    it is based on **MySQL**, which could also be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PHP** is the dynamic language used by the web server to generate content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A common variation of the **LAMP** stack is called **LEMP**; this replaces **Apache**
    with **NGINX**, which is pronounced *engine-x*, hence the *E* rather than the
    *N*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to look at creating roles to deal with these components; these
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`common`: This role will prepare our Ubuntu server, installing any supporting
    packages and services we need'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apache`: This role will install the Apache web server and configure a default
    virtual host'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mariadb`: This role will not only install MariaDB but also secure the installation
    and create a default database and user, as well as optionally download and import
    a database to use'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`php`: This role will install PHP and configure a set of common PHP modules,
    and if we set the option to a database admin tool written in PHP, we can interact
    with our test database via the browser'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let us begin by looking at the `common` role.
  prefs: []
  type: TYPE_NORMAL
- en: The common role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section of this chapter, we used the `ansible-galaxy role init`
    command to create the `common` role. This creates several folders and files; as
    discussed in [*Chapter 2*](B21620_02.xhtml#_idTextAnchor080), *Exploring Ansible
    Galaxy*, we will not go into any detail here but instead dive straight into the
    role itself.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s make a start by adding some tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Updating installed packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First of all, let’s update our server by adding the following to the beginning
    of the `roles/common/tasks/main.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: You will notice a difference from when we last used the `ansible.builtin.apt
    module` to update all the installed packages.
  prefs: []
  type: TYPE_NORMAL
- en: We now start the task using the `name` key; this will print out the content
    of the value we assigned to the `name` key when the playbook runs, which will
    give us a better idea of what is going on during the playbook run, rather than
    just printing the name of the module that is executed.
  prefs: []
  type: TYPE_NORMAL
- en: Installing common packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have updated the installed packages, let’s install the packages
    we want to install on all the Linux servers we will target with the Playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we again use the `ansible.builtin.apt` module, and we have
    added a descriptive name for the task. Rather than providing a list of packages
    in the task, we use a variable called `common_packages`, which is defined in the
    `roles/common/defaults/main.yml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we install `ntp`, `sntp`, and `ntp-doc`; we will configure `ntp`
    shortly. Next, we install `vim`, `git`, and `unzip`, as they are always helpful
    to have installed on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Another thing that you may have noticed is that we pass a list of packages using
    `{{ common_packages }}` to the `pkg` key in the `ansible.builtin.apt` module,
    resulting in the module looping through the list of packages we pass in and installing
    them all in one go, rather than having to call the module to install each package
    individually.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Network Time Protocol (NTP)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Next, we copy the `ntp.conf` file from the `templates` folder, adding the list
    of NTP servers as we have done in the previous chapters, and then informing Ansible
    to restart NTP whenever the configuration file changes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a key, group, and user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the `roles/common/defaults/main.yml` file, the following variable is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is slightly different from the variables we have used so far, as it is
    a single variable called `users`, which is made up of a single item, and that
    item contains the `name`, `group`, `state`, and `key` key-value pairs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we are using items, we need to change our approach to how we use the
    variables within the task, the first of which in `roles/common/tasks/main.yml`
    creates an OpenSSH key pair; if one doesn’t already exist, we need to save it
    at the path that is defined in the `key` key-value pair:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Working through the task, you can see that we use the `community.crypto.openssh_keypair`
    module, in which we pass just one value, which is the path to the file where we
    would like our OpenSSH key stored.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we use the `{{ item.key }}` variable to enter the path, but
    we do not define that the variable is called `users` here; instead, we use the
    `with_items` option and pass in the `{{ users }}` variable here.
  prefs: []
  type: TYPE_NORMAL
- en: 'While we only pass one item in this example, you could take this approach to
    execute a single task multiple times – for example, if our variable looked like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Then, when the task is executed, it would create two OpenSSH keys, and the subsequent
    tasks, which we will get into in a moment, would create a single group called
    `lamp` and then two users, `lamp` and `user2`.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the task at hand – you will notice that we have defined two other options,
    `delegate_to` and `become`.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to run the `community.crypto.openssh_keypair` module without defining
    `delegate_to`, then the module will be executed on the remote host, which is not
    what we want to happen in this case, as we want a copy of the private and public
    portions of the OpenSSH key on our local machine. Therefore, by using `localhost`
    as the value in the `delegate_to` option, we tell Ansible to run this task locally.
  prefs: []
  type: TYPE_NORMAL
- en: The next option, `become`, tells Ansible not to become an escalated user using
    the `sudo` command, which is the default action for all the hosts we have defined
    at the top of our main `site.yml` playbook file – this is because we want the
    `community.crypto.openssh_keypair` module to run as the user you are logged in
    as, rather than your local machine’s root user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logic for this task, minus the `delegate_to` and `become` options, as we
    want the remainder of the tasks to be executed against the target machine, is
    followed through to the remaining tasks in the role, starting with creating the
    group by executing the `ansible.` `builtin.group` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the group has been created, we can then add the user using `ansible.builtin.user`,
    or users if we have defined more than one item in the `users` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The final task in the role takes the public portion of the OpenSSH key, which
    we generated earlier, and adds the contents to the user(s) created during the
    previous task, using the `ansible.builtin.authorized_key` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the value we pass for the `key` option is new to us;
    this uses the `lookup` plugin to read the file’s contents at the `item.key` path
    with `.pub` appended to the end, meaning, in our case, it reads the contents of
    the file at `/tmp/id_ssh_lamp_rsa.pub`. This file is the public portion of the
    OpenSSH key-pair, which was created when we executed the `"generate a ssh keypair"`
    task earlier in the role.
  prefs: []
  type: TYPE_NORMAL
- en: The `lookup` plugin is designed to be executed locally, so in this case, we
    do not need to use the `delegate_to` and `become` options, as we want the task
    to be executed on the target host because that is where our user has been created,
    but we want to populate the `/home/lamp/.ssh/authorized_key` file on the remote
    host with the contents of the `/tmp/id_ssh_lamp_rsa.pub` file that we have on
    our local host.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the tasks in the `common` role; before we move on to the next
    role, which will install and configure `apache`, you should know one more thing.
  prefs: []
  type: TYPE_NORMAL
- en: The `"generate a ssh keypair"` task will not overwrite any existing key-pairs
    when executed, meaning the first time you run the role and no files exist at `/tmp/id_ssh_lamp_rsa`
    and `/tmp/id_ssh_lamp_rsa.pub`, the key-pair will be created, and on subsequent
    Playbook runs, as the files now exist, the task will return an `community.crypto.openssh_keypair`
    module to create the key-pair.
  prefs: []
  type: TYPE_NORMAL
- en: The Apache role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the `common` role has finished running our remote host, we will be ready
    to install and configure the Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Apache packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first task in `roles/apache/tasks/main.yml` installs the packages we need
    to run the Apache web server; it uses the `ansible.builtin.apt` module and looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it calls a variable called `{{ apache_packages }}`, which is
    defined in `roles/apache/defaults/main.yml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As we learned when we walked through the `common` role, this will install the
    four packages defined in the variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once Apache has been installed, which is a single task, we can now progress
    to configuring our Apache installation.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Apache
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first task when configuring Apache is to take the user that was created
    when the `common` role was run and add them to the Apache group; to do this, we
    run the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This takes the `{{ users }}` variable from the previous role and loops over
    the items defined in the variable, adding the user to the group defined under
    the `{{ apache_group }}` variable in the `roles/apache/defaults/main.yml` file.
    A full list of the variables defined to configure Apache, which we will use throughout
    the next few tasks, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed that the value of the `document_root` variable is a little
    different from the ones we have used so far; there’ll be more on that in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task creates a folder within the users directly, which we will use
    to store the files served via Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we use `{{ users.0.name }}` as we did for the `document_root`
    variable value; why is this?
  prefs: []
  type: TYPE_NORMAL
- en: As we know, the `common` role only creates a single user; we can’t simply use
    `{{ users.name }}`, as the `name` key exists within an item within the variable,
    so using `{{ users.name }}` would result in an error, stating that the variable
    can’t be found.
  prefs: []
  type: TYPE_NORMAL
- en: Because of this, we can reference the first item in the list of items by using
    its position within the list, which, because Ansible counts from zero, will be
    `0` rather than `1`.
  prefs: []
  type: TYPE_NORMAL
- en: Using the values that we have defined in the defaults for the `common` and `apache`
    roles, this task will create a folder at `/home/lamp/web/`; the `lamp` user would
    own the folder and would be assigned to the `www-data` group, which is the group
    the Apache process will run as.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task will ensure the correct read, write, and execute permissions
    are set on the `/``home/lamp/` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: That task concludes configuring the folder structure needed to serve our web
    pages; now, it is time to configure Apache itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is remove the default virtual host configuration
    file; to do this, we will execute the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `ansible.builtin.file` module to set the state of the file defined
    by `{{ vhost_default_file }}` in the `{{ vhost_path }}` folder to `absent`, which
    means, if the file exists, remove it.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also uses `notify` to call the `"Restart apache2"` handler, which is defined
    as the following task in the `roles/apache/handlers/main.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once the default file has been removed, we can add our virtual host configuration
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template for this virtual host configuration file can be found at `roles/apache/templates/vhost.conf.j2`,
    and it contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: When loaded, this configuration file serves the contents of the `{{ document_root
    }}` folder when someone visits the site’s URL in their browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task to deploy this template file to the remote host looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this also calls the `"Restart apache2"` handler if there are
    any changes to the file.
  prefs: []
  type: TYPE_NORMAL
- en: With Apache now configured, there is one final task.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally copying an index.html file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The final task in this role uses the following `variables` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it contains a heading and some HTML code for the body; these
    variables are used by the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This uses a template that can be found at `roles/apache/templates/index.html.j2`
    and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the task is only called if the `html_deploy` variable is set to `true`;
    this is managed by the following statement at the end of the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So, if, for any reason, the `html_deploy` variable is not equal to `true`, then
    the task will be skipped when the playbook is executed.
  prefs: []
  type: TYPE_NORMAL
- en: That’s all we need to do to install and configure Apache; let us now look at
    installing the M in LAMP and review the role to install and configure MariaDB.
  prefs: []
  type: TYPE_NORMAL
- en: The MariaDB role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Of the four roles we cover in this chapter, this, the MariaDB one, is the most
    complicated, as it installs MariaDB, configures it, and optionally downloads and
    imports a sample database.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by covering the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Installing MariaDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have started to spot a trend in the roles; the tasks always start with
    installing a few packages, and MariaDB is no different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task from `roles/mariadb/tasks/main.yml` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `mariadb_packages` variable in `roles/mariadb/defaults/main.yml` looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we installed the MariaDB client and server. Also, we installed
    the `python3-pymysql` package; this is required for the tasks that need to interact
    with MariaDB once it is installed to function. Without it, Ansible cannot establish
    a connection to and interact with our MariaDB server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the packages have been installed, we need to start the MariaDB server
    by using the following task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You might be thinking, why aren’t we using a handler as we have done for previous
    tasks? Well, handlers are only called once the playbook execution has been completed
    and Ansible knows all the services that need to be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this case, we need to interact with the MariaDB service to be able
    to configure it as part of the playbook run, so rather than using a handler, we
    just start the service as a task using the same block we would use as the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Now that MariaDB is installed and started, we can start the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring MariaDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before we dive into the tasks, quickly look at the variables in `roles/mariadb/defaults/main.yml`,
    which will be used to configure our MariaDB server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know what variables we will use, it’s time to work through the configuration,
    which is a little complex due to the default way that MariaDB is configured when
    it starts immediately after installation.
  prefs: []
  type: TYPE_NORMAL
- en: By default, MariaDB starts with no password in place, meaning that anyone can
    connect to the database as the root user, which is not ideal, so the first thing
    we need to do is to secure our installation by setting the root password.
  prefs: []
  type: TYPE_NORMAL
- en: That sounds easy enough, you might be thinking to yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, it is; however, if the playbook were to be run a second time, meaning
    that there is now a password set, then the task we are about to define, which
    sets the initial password, will error, as we need to configure the task not to
    use a password. Once the password has been set, the server will only accept a
    connection using the already set password.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to consider that once a password has been configured, we need to
    use that password each time we need to connect to the MariaDB server – so we need
    an easy way to ensure we can connect smoothly once the password has been set.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, there is a function built into MariaDB and MySQL that allows you to
    put your credentials into a file on the server; the file should be placed in the
    home directory of the user you are logged in as. Once in place, each time you
    attempt to connect to the database server using that user, the database client
    will read the file and connect you, without you having to type the credentials
    – this file should be called `~/.my.cnf` (the `~/` part is a shortcut for the
    user’s home folder).
  prefs: []
  type: TYPE_NORMAL
- en: For our scenario, this works because we can check for the presence of the `~/.my.cnf`
    file, and if it is not there, then it will be safe to assume that the password
    has not been configured yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'The task that checks for the presence of the file is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This uses the `ansible.builtin.stat` module to check for the file and then uses
    the `register` option to register a runtime variable, called `mycnf`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a dynamically registered variable that contains details on
    whether the `~/.my.cnf` file exists on the remote host’s filesystem or not, we
    can now proceed with changing the password or skip the task if the `~/.my.cnf`
    file is present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible has several built-in modules to interact with MySQL and MariaDB; the
    one we will use here is `ansible.builtin.mysql_user`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: In the task, we instruct Ansible to set the password for the user defined in
    the `{{ mariadb_root_username }}` variable to the password stored in the `{{ mariadb_root_password
    }}` variable, giving the user full admin access to all the databases across all
    possible host combinations, which are defined in the `{{ mariadb_hosts }}`, which
    we loop over using the `with_items` function.
  prefs: []
  type: TYPE_NORMAL
- en: When logging in to do this, Ansible should use the `{{ mariadb_root_username
    }}` username and connect over a Unix socket, which can be found at `/var/run/mysqld/mysqld.sock`;
    this means we don’t have to establish a network connection to interact with the
    database because, if we did, Ansible wouldn’t be able to connect, as it can’t
    send a blank password.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, only run this task when the `mycnf.stat.exists` variable is equal to
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have set the actual password and secured the MariaDB installation,
    we need to create the `~/.my.cnf` file to carry on with the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will again use a template, which can be found at `roles/mariadb/templates/my.cnf.j2`.
    This template looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it contains the username and password needed to connect to the
    database server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the file contains credentials, when the task creates the file on the
    server, we need to ensure that the file can only be read and written to by the
    root user, by setting the read, write, and execute permissions of the file as
    it is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have the `~/.my.cnf` file on the remote host, we can progress with
    securing our MariaDB installation; the subsequent task removes the `anonymous`
    user, again looping through the hosts that user could be associated with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The final task that deals with securing our MariaDB installation removes the
    default `test` database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The remainder of the tasks in the role, such as copying the `index.html` file
    in the `apache` role, are optional, so let’s review those tasks now.
  prefs: []
  type: TYPE_NORMAL
- en: Downloading and importing the example database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is one more block of variables in `roles/mariadb/defaults/main.yml`;
    these deal with downloading and importing an example database. There are a lot
    of keys in the `mariadb_sample_database` variable, starting with the flag to enable
    the option, the URL of the file to download, and the path to save it to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have the name of the example database being created as well as the
    username and password to use for the new database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, there is a list of the files that need to be imported. The first two
    files contain the schema:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The remaining files contain the actual data to be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know what variables are defined, we can work through the remaining
    tasks, the first of which downloads and unarchives the ZIP file that contains
    the example database files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `ansible.builtin.unarchive` module allows you to download
    and unarchive the file, meaning we can do everything we need in a single task.
    Also, we only run the `when` task when the `mariadb_sample_database.create_database`
    equals `true`. We will do this for the remainder of the tasks and even expand
    upon the `when` statement toward the end of the role.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task creates the example database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the database has been created, we can run a task that creates the user
    and assigns permissions to the newly created user to access the database we just
    added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: We are now down to the final two tasks, and here is where we need to add a little
    more logic to our playbook to ensure that we only import the example data once;
    if we don’t have the logic in place, we can run into all sorts of problems if
    the playbook is rerun and could risk data being overwritten or duplicate data
    being inserted if the import task is allowed to run again.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the databases are stored on the host’s filesystem, we can use the same logic
    that we used to check for the presence of the `~/.my.cnf` file, but this time,
    we check for a database file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We register a variable called `db_imported`, which we will use with the `when`
    condition of the next and final task; this is the one that loops through `mariadb_sample_database.dump_files`
    and imports the databases:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We have changed the `when` condition slightly here; rather than referencing
    `mariadb_sample_database.create_database`, we only use `db_imported`.
  prefs: []
  type: TYPE_NORMAL
- en: The first part ensures that the playbook doesn’t error if we decide not to import
    the database by setting `mariadb_sample_database.create_database` to `false`,
    as `db_imported` can only be defined if `mariadb_sample_database.create_database`
    is set to `true`, as the task that sets the `db_imported` variable is only ever
    executed when that condition is met.
  prefs: []
  type: TYPE_NORMAL
- en: As you can also see, we use `and`, thus adding a second condition to the `when`
    statement; this means that the task will only be executed if `db_imported is defined`
    and `not db_imported.stat.exists` are both met.
  prefs: []
  type: TYPE_NORMAL
- en: That final task brings us to the end of the MariaDB role and leaves us with
    one role to work through – the PHP role.
  prefs: []
  type: TYPE_NORMAL
- en: The PHP role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This, our final role, installs PHP, optionally copies a PHP Info file along
    with it, and installs a database management interface written in PHP, called Adminer,
    so that we can access the database server we used in the previous role.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the PHP packages
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It should come as no surprise to you that the first task executed in the PHP
    role installs the packages needed for us to run PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full list of packages is defined in the `roles/php/default/main.yml` file,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The task itself looks familiar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The thing to note is that we restart Apache once PHP is installed because we
    run PHP as an Apache module. So, once installed, Apache needs to be restarted
    to load in the module and enable PHP on our Apache web server.
  prefs: []
  type: TYPE_NORMAL
- en: That’s it. PHP is installed, and Apache asks to be restarted; everything from
    here is optional.
  prefs: []
  type: TYPE_NORMAL
- en: Copying the PHP Info file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next task is a simple one that copies `roles/php/files/info.php` to the
    web root of the server if the `php_info` variable is set to `true`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that we copy the file from our local host to the remote
    one with this task – we do not use the `ansible.builtin.template` module this
    time but instead, the `ansible.builtin.copy` one. This is because `info.php` is
    made up of three lines of code, none of which we need to update based on the environment
    or any variables we set.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and configuring Adminer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The variables for the remaining tasks in the `roles/php/default/main.yml` file
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'They define where to download the file from and where on the remote to download
    it to, which is where the first of the three tasks comes in, as this creates the
    folder on the remote virtual machines filesystem for us to download Adminer to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the download target folder created, we can download Adminer itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: As you may have spotted from the download URL and destination, Adminer is a
    single PHP file that we save as `index.php`. So, how will we access Adminer via
    our Apache web server?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, to do that, we need to copy across another virtual host configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this renders and copies across `roles/php/templates/adminer.conf.j2`
    to `adminer.conf`, the site-enabled folder on our remote host, and instructs the
    Apache service to restart to load the newly added configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `adminer.conf.j2` file contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This tells Apache that whenever someone visits `http://someurl/adminer/`, the
    Adminer `index.php` file should be served.
  prefs: []
  type: TYPE_NORMAL
- en: With that task covered, we have completed the walk-through of the four roles
    that go into installing and configuring our LAMP stack, and now it is time to
    review and execute the playbook itself.
  prefs: []
  type: TYPE_NORMAL
- en: The LAMP playbook
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned at the start of this chapter when we discussed the playbook structure,
    the main playbook file is called `site.yml`, which contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it calls the four roles we have already walked through and
    also loads a `variables` file from `group_vars/common.yml`; this file contains
    an override for `html_body`, which is configured in `roles/apache/defaults/main.yml`
    and looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This means that when we run the playbook, the `index.hml` page will have links
    to `info.php` and the `/adminer` URL to access the additional content easily.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Chapter04` folder in the GitHub repo that accompanies this title contains
    the example hosts file and keys to launch a local virtual machine using Multipass.
    If you are following along, refer to the instructions in [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017),
    *Installing and Running Ansible*, for how to launch the virtual machine and prepare
    your own `hosts` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, without further ado, let’s run the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first run, this should give us some output that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the Playbook has made 26 changes to the target virtual machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s run the playbook a second time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the play recap, you should see that some tasks were skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, one of those tasks was updating the root password for the database
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The second task that is skipped is importing the database files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: Both are to be expected, as that is how we configured the tasks to respond on
    subsequent Playbook runs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you open your browser and enter `http://` and then the name of your
    Ansible host (for me, this was [http://192.168.64.20.nip.io](http://192.168.64.20.nip.io);
    I suspect yours will be different, so the link will likely not work), then you
    should be greeted by the `index.html` page that Ansible generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Success !!! – viewing the index.html page](img/B21620_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Success !!! – viewing the index.html page
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the link for the PHP Info file should take you to something like
    [http://192.168.64.20.nip.io/info.php](http://192.168.64.20.nip.io/info.php),
    which will display information on your PHP installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Viewing the PHP Info page](img/B21620_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Viewing the PHP Info page
  prefs: []
  type: TYPE_NORMAL
- en: 'The final link to click is the one for Adminer; clicking it will take you to
    [http://192.168.64.20.nip.io/adminer/](http://192.168.64.20.nip.io/adminer/),
    which will prompt you to log in:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – The Adminer login page](img/B21620_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – The Adminer login page
  prefs: []
  type: TYPE_NORMAL
- en: 'To log in, use the following credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '`root`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pa55W0rd123`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`employees`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once logged in, you will be taken straight to an overview of the **employees**
    database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – The employees database overview](img/B21620_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – The employees database overview
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to click around, and once you have finished, ensure that you terminate
    the Multipass virtual machine; instructions on how to do this can be found at
    the end of [*Chapter 1*](B21620_01.xhtml#_idTextAnchor017), *Installing and* *Running
    Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we worked through writing a playbook that installs a LAMP stack
    on our Multipass virtual machine. We created four roles, one for each element
    of the stack, and within each of the roles, we built in a bit of logic that can
    be overridden to deploy additional elements, such as test HTML and PHP pages,
    and we also built in the option to create a test database that contains over 40,000
    records.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we installed some basic packages. In the next chapter, we will write
    a playbook that installs, configures, and maintains a WordPress installation.
  prefs: []
  type: TYPE_NORMAL
- en: This updated playbook will reuse some of the elements from the roles we covered
    in this chapter and make some improvements, as some of the elements we covered
    in this chapter were a little too simplistic. The biggest change is that we will
    not use a hardcoded password for the database instance moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the project pages for the third-party tools covered throughout
    the chapter at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Apache**: [https://httpd.apache.org/](https://httpd.apache.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MariaDB**: [https://mariadb.org/](https://mariadb.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Datacharmer test** **database**: [https://github.com/datacharmer/test_db](https://github.com/datacharmer/test_db)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PHP**: [https://php.net/](https://php.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adminer**: [https://www.adminer.org](https://www.adminer.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**NGINX**: [https://nginx.org](https://nginx.org)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
