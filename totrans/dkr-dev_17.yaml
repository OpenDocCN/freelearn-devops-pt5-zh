- en: '*Chapter 14*: Advanced Docker Security â€“ Secrets, Secret Commands, Tagging,
    and Labels'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've seen several examples so far of the need to use files that contain secrets.
    We can think of secrets as a generic term for the types of sensitive data that
    would typically be stored in config and ENV files, such as database access credentials
    or API tokens. Docker provides a handy method for securing this type of data and
    sharing it. For legacy systems using swarm mode instead of Kubernetes, having
    an understanding of how to apply security to these environments is important,
    as you may have to retroactively fix environments in your career.
  prefs: []
  type: TYPE_NORMAL
- en: Along with managing secret data, we can also use labels and tags to help ensure
    we are working with security in mind. You've seen tags already in the previous
    chapter and we will explore these further later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we will explore how metadata labels can be used to provide extra
    information about a container and how to use the `security.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to securely storing secrets in Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What secrets are and why we need them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A walk through the Raft log file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding, editing, and removing secrets from a swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using tags more effectively to ensure we use secure images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing metadata labels and the secrets.txt file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started by looking at what Docker secrets are and why they are beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will need to have access to a Linux machine running Docker.
    We recommend that you use the setup you have been using so far in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, you will need an account on Docker Hub in order to access
    images located there. If you have not already set one up, you can do so via the
    following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://hub.docker.com](https://hub.docker.com)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, in order to explore using Docker secrets, you will need to set up
    at least two containers and use Docker''s swarm feature. You can read more about
    swarm mode here: [https://docs.docker.com/engine/swarm/](https://docs.docker.com/engine/swarm/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3iDsjkA](https://bit.ly/3iDsjkA)'
  prefs: []
  type: TYPE_NORMAL
- en: Securely storing secrets in Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An inevitable part of working with complex, networked software projects is having
    to deal with secret data. This can be a range of things such as private keys for
    SSH access, SSL certificates, passwords, and API keys.
  prefs: []
  type: TYPE_NORMAL
- en: In order to share secrets securely with multiple containers, you will, of course,
    need to avoid attempts to store the secret in the container itself in a fashion
    that allows a potential attacker to access it. This layer of abstraction is not
    only useful for managing different sets of credentials based upon the environment,
    but also provides an extra layer of security should the container be compromised
    in some fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, Docker comes with a useful feature for achieving this goal. It is
    simply called Docker secrets. In order to use this feature or the Kubernetes equivalent,
    you will need to implement swarm services or Kubernetes itself. As we have recommended
    elsewhere in this book, you may wish to avoid swarm services if possible, in favor
    of Kubernetes. However, you may have to work with legacy systems where they are
    in use, so understanding secrets in this case is important. With this in mind,
    containers should, therefore, run as a service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mirantis, having purchased Docker, has pledged open-ended support for Docker
    Swarm as of February 2020 ([https://www.mirantis.com/blog/mirantis-will-continue-to-support-and-develop-docker-swarm/](https://www.mirantis.com/blog/mirantis-will-continue-to-support-and-develop-docker-swarm/)).
    You may be familiar with this concept from [*Chapter 5*](B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080),
    *Alternatives for Deploying and Running Containers in Production*; however, if
    you need a refresher you can follow the steps provided on the Docker website for
    getting started with swarm mode as an alternative to Kubernetes if you wish:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/swarm/swarm-tutorial/](https://docs.docker.com/engine/swarm/swarm-tutorial/)'
  prefs: []
  type: TYPE_NORMAL
- en: The secrets feature in both swarms and Kubernetes allows you to manage data
    such as passwords and API keys centrally and then securely share it with the containers
    of your choice. This avoids having to hardcode values in an insecure fashion within
    the container, or having to allow all containers access to the sensitive data.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, secrets, when shared with other containers in a swarm by Docker
    secrets, for example, are transferred over a secure connection encrypted via SSL/TLS.
    Let's now take a deeper look at how Docker secrets work at a fundamental level,
    including an important feature called the Raft log.
  prefs: []
  type: TYPE_NORMAL
- en: The Raft log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to share content between swarm nodes, we need to ensure there is both
    consensus and fault tolerance. In short, this means that all nodes in the network
    agree on some set of values to maintain a consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: 'The algorithm that Docker Swarm uses is called Raft. You can read more about
    the technical details in the paper *In Search of an Understandable Consensus Algorithm*,
    available at the Raft GitHub account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://raft.github.io/raft.pdf](https://raft.github.io/raft.pdf)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Swarm uses a file known as the Raft log file as part of its implementation
    of the algorithm. The benefit of this file is that it can be used for storing
    secrets, which subsequently have to be shared across 1 to *n* nodes. When a secret
    is added via the `docker secret` command, a value is added to the Raft log file
    and is then made available via a temporary filesystem, as seen in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And this in essence is how a secret can be shared between multiple Docker containers
    in a swarm. Reading the secret in an application will depend on what language
    you are using. For example, if you were modifying the ShipIt Clicker application
    you would be using JavaScript. If we had a secret such as an API key file, we
    could access it directly in the JavaScript source code using the `fs` module,
    as the following example demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is a fairly simple approach.
  prefs: []
  type: TYPE_NORMAL
- en: Although this file is encrypted, we can also add an extra layer of security
    through locking.
  prefs: []
  type: TYPE_NORMAL
- en: Swarms can be locked using the `--autolock` flag in order to prevent an attacker
    from decrypting the Raft log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the Docker documentation for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.docker.com/engine/swarm/swarm_manager_locking/](https://docs.docker.com/engine/swarm/swarm_manager_locking/)'
  prefs: []
  type: TYPE_NORMAL
- en: Now you have a basic understanding of how the Docker secrets feature works,
    let's look at how we use it.
  prefs: []
  type: TYPE_NORMAL
- en: Adding, inspecting, and removing secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now begin exploring the various commands associated with secrets.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to also substitute the commands in this section with their Kubernetes
    equivalent if you wish to try those instead. You can find the list of `kubectl`
    commands at [https://kubernetes.io/docs/concepts/configuration/secret/](https://kubernetes.io/docs/concepts/configuration/secret/).
  prefs: []
  type: TYPE_NORMAL
- en: Or you can refer back to [*Chapter 8*](B11641_08_Final_AM_ePub.xhtml#_idTextAnchor157),
    *Deploying Docker Apps to Kubernetes*, where we created, described, retrieved,
    and edited secrets via `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: In relation to Docker, we will start by creating secrets first.
  prefs: []
  type: TYPE_NORMAL
- en: Creating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `create` command is how we add a new secret to the Raft log file. Its basic
    format is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You may notice this is similar to the command in `kubectl`, which is `kubectl
    create secret`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When creating a secret, we can use the `-l` flag to add a label to the secret,
    such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to label values, so we know which environment they are destined
    for. For example, we can add a key value for the environment such as **Quality
    Assurance** (**QA**), **Development** (**DEV**), and **Production** (**PROD**).
  prefs: []
  type: TYPE_NORMAL
- en: 'A secret can also be a file. For example, if we want to add a private key,
    we might do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to add/update a secret to a running service, you will need to use
    the `--secret-add` flag on the `update` command. See the following, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Having added a secret, let's explore how we can now review it.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are a number of techniques we can use to examine Docker secrets. To list
    any secrets that have been added to the Raft log file, we can use the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'On running this command, the current secrets will be displayed, as shown in
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We can gather more information about this secret using the `inspect` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format for this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'So, using the preceding example, we could run the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This will then return a JSON object containing the ID, version created and
    updated dates, and the `spec` object containing the labels and name. An example
    of this output is now provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We've added and inspected secrets, so now we shall explore how to delete them
    when we no longer need them.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Removing a secret is as easy as adding one, and uses the same syntax as its
    Linux equivalent for removing files, that being `rm`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The format of the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In Kubernetes, the equivalent would be `kubectl delete secret`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove our example secret from earlier, we would run the command as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to remove a secret being used by a current service, you will need
    to use the `--secret-rm` flag with the `update` command, such as in the following
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, adding, removing, and inspecting secrets is simple. Let's now
    try the preceding commands out using the SSH file from [*Chapter 13*](B11641_13_Final_NM_ePub.xhtml#_idTextAnchor299),
    *Docker Security Fundamentals and Best Practices*.
  prefs: []
  type: TYPE_NORMAL
- en: Secrets in action â€“ examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s now time to try out the commands we just reviewed (`create`/`inspect`/`ls`/`rm`).
    Make sure your setup is configured to use swarms. You can also re-use the image
    from the previous chapter for this section. This can be obtained using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you can use the `docker swarm init` command to initialize the swarm.
    Use the `--advertise-addr` flag with the IP address of your initial container
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Previously, we used the following command to add an SSH private key for use
    with SCP to a single container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To add this key to our swarm, we would use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have created a new secret with the same name as the build argument
    we used previously, and we output the content of our private key to it. We also
    included a label, which has a `key=val` pair denoting the environment we are working
    in. In this case, it is the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now check that we have added it correctly. We can do this by running
    the `ls` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we see the ID of the secret and the name. This looks good! Now let''s
    execute the `inspect` command on the key using the `NAME` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You should now see a JSON object displayed, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If you have multiple containers in your swarm, then you can grant them access
    to this secret. The following example demonstrates how we can send the secret
    we just created to a new container that uses our example image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `--secret source` value is set to the name of the Docker secret we
    created. We are then going to store it in the variable defined in the target value.
    For clarity, we have called this `second_ssh_prv_key`.Â Â The mode has been set
    to `0400` to make the secret accessible and then chosen our tagged image as the
    source image for the `create` command.
  prefs: []
  type: TYPE_NORMAL
- en: To confirm the secret is available, we can check the temporary filesystem we
    discussed earlier. For this, you will need to grab the container ID of the new
    container. You can use the `docker ps` command for this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, use the container ID as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: You should see that the contents of the secret are the same as those you passed
    into the first container, namely the private SSH key we have been testing with
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: Other options
  prefs: []
  type: TYPE_NORMAL
- en: In addition to using native Docker and Kubernetes tools, a variety of other
    options exist for storing secrets in cloud-based systems. AWS, GCP, and Azure
    offer native support, and HashiCorp provides a comprehensive cloud-agnostic secrets-managing
    mechanism in the form of HashiCorp Vault, at [https://www.vaultproject.io/](https://www.vaultproject.io/).
  prefs: []
  type: TYPE_NORMAL
- en: We are now going to build upon our knowledge of Docker secrets by understanding
    how tags can be used.
  prefs: []
  type: TYPE_NORMAL
- en: Docker tags for security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just seen how we can make sure we are sharing secrets securely between
    containers in a swarm. In [*Chapter 12*](B11641_12_Final_NM_ePub.xhtml#_idTextAnchor278),
    *Introduction to Container Security*, we gained an appreciation for how to use
    tags combined with other security features, to ensure we use the correct image.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we'll see how these two worlds can intersect by using tags with secrets
    and labels so we can annotate which environment a given secret and tag are used
    in.
  prefs: []
  type: TYPE_NORMAL
- en: As a good security practice, we should always use different secrets for different
    environments. For example, the passwords for database access in your development,
    staging, and production instances should not be the same. Typically, as part of
    your development process, you will likely be using newer versions of containers
    in research, development, and QA environments compared to production.
  prefs: []
  type: TYPE_NORMAL
- en: We can use Docker tags to help ensure that once we have credentials/secrets
    set up for a development environment, we are also pulling in the right image as
    well; that is, the one we intended to use for development purposes with the development
    credentials we created. Using fixed tags provides a layer of security through
    immutability and prevents an experimental image that may contain security flaws
    from accidentally being used outside of the development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, a methodology such as semantic versioning ([https://semver.org/](https://semver.org/))
    should be in place. This will result in tags using a format that communicates
    the level of change you should expect when using the release. Major version numbers
    indicate a backward-incompatible set of changes. A minor release is usually a
    new feature to an existing release. Finally, we have a patch release, which could
    be a small security fix or similar. A typical format might be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: When choosing the tag, in line with your versioning system, choose the one that
    most closely matches the environment you want to deploy in. For example, choose
    `:1.1.2-dev` over `:1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this instance, you know you will be pulling the patch release. You can then
    deploy credentials via `docker secret`, specifically for this build and for the
    environment you are deploying it to. One useful method is to pair up the secret
    label with the tag version you are using, as in the following code, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this example, a secret has been created (an SSH key) and we know it should
    be used with tag version `1.1.2` and that this is a development environment. Here,
    the labels provide annotations to give us the context of the secret. Simple techniques
    like this can help to provide more information to an engineering team and avoid
    a production credential from accidentally being used with an experimental development
    container or in the wrong environment.
  prefs: []
  type: TYPE_NORMAL
- en: We've seen how we can combine tags, secrets, and labels. Let's now look at other
    labeling options.
  prefs: []
  type: TYPE_NORMAL
- en: Using labels for metadata application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metadata labels are a way of annotating your containers with extra information
    to provide development teams with useful facts. This can be useful for other developers
    on your team when they need to understand key features of the image, such as its
    version and a description.
  prefs: []
  type: TYPE_NORMAL
- en: We saw with the `docker secrets` command how we could add labels via the command
    line. With metadata labels, we can also add labels to the Dockerfile so that when
    we build out a new container, this information is baked in.
  prefs: []
  type: TYPE_NORMAL
- en: 'A label takes the following format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Building upon our preceding example, we can set the version inside of our container
    via the Dockerfile as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you''ve built out a container, you can view any of the metadata you have
    added using the `docker inspect` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When releasing software for public consumption, you should consider also linking
    to a `security.txt` file. Like a code of conduct or contributors' guide, this
    provides a mechanism to alert security researchers on how to responsibly disclose
    any security issues they may find with your software.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can automatically generate a `security.txt` file from the following website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://securitytxt.org/](https://securitytxt.org/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save this file to your code repository, and then link it via `LABEL` in your
    Dockerfile as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That wraps up our guide to secrets, tags, and labels. Let's recap what we have
    learned so far.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned all about Docker secrets, the counterpart to Kubernetes
    secrets. We saw how this feature can be used to securely share sensitive data
    between containers in a swarm if you need to work with this technology instead
    of Kubernetes. We also learned this can be useful for segmenting sets of credentials
    based upon the environment you are working in. Finally, we walked through how
    we can create, inspect, and delete them.
  prefs: []
  type: TYPE_NORMAL
- en: Following this, we looked at tags once again and discussed how these can be
    used to ensure the right image is being pulled from the right environment. A combination
    of environment-based secrets and tags were shown to help you secure your development
    processes further.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed how containers can be annotated with metadata labels.
    This also included using the `security.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how third-party tools can be used to help
    secure our containers and enforce some of the practices we have learned so far.
  prefs: []
  type: TYPE_NORMAL
