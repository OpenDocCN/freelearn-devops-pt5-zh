<html><head></head><body>
<div><div><div><h1 id="_idParaDest-120" class="chapter-number"><a id="_idTextAnchor509"/>8</h1>
			<h1 id="_idParaDest-121"><a id="_idTextAnchor510"/>Common Troubleshooting Tips and Best Practices</h1>
			<p><a id="_idTextAnchor511"/>So far in the book, we have primarily discussed code samples that have been pre-written and shared through the GitHub repository accompanying this book. As you progress in your journey with <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>), it’s essential to understand that writing and planning your IaC projects will involve a learning curve and some inevitable debugging.</p>
			<p>In this chapter, the second-to-last one, we’ll look at some essential aspects to help you better plan, write, and troubleshoot your IaC projects.</p>
			<p>We’ll cover three key areas to ensure you’re well equipped to handle any challenges that may arise during the process:</p>
			<ul>
				<li><a id="_idTextAnchor512"/>Infrastructure as Code – best practices<a id="_idTextAnchor513"/> and troubleshooting</li>
				<li><a id="_idTextAnchor514"/>Terraform – best practices and troubleshooting</li>
				<li><a id="_idTextAnchor515"/>Ansible – best practices and troubleshooting</li>
			</ul>
			<p>Throughout this chapter, you’ll notice some common themes and advice that apply to both Terraform and Ansible, as they are both IaC tools. However, each tool uniquely interacts with your resources, resulting in some differences in the approaches and techniques you’ll use when troubleshooting.</p>
			<p>By the end of this chapter, you’ll be well prepared to tackle the challenges of implementing IaC projects using these powerful tools.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor516"/>Technical requirements</h1>
			<p>The source code for this chapter is available here:</p>
			<p><a href="https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08">https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter08</a></p>
			<h1 id="_idParaDest-123">Infrastructure as Code – <a id="_idTextAnchor517"/>best practices and troubleshooting</h1>
			<p>Let us start by discussing some general IaC best practices that can apply to various tools and platforms.</p>
			<h2 id="_idParaDest-124"><a id="_idTextAnchor518"/><a id="_idTextAnchor519"/>General IaC best practices</h2>
			<p>There are some common<a id="_idIndexMarker438"/> threads that we have already touched upon here, but it is essential to bring them up again as they are important:</p>
			<ul>
				<li><strong class="bold">Version control</strong>: Make sure you use a version control system such as Git or one of the other available systems such as Mercurial, Subversion, or Azure DevOps Server, which was previously known as <strong class="bold">Team Foundation Server </strong>(<strong class="bold">TFS</strong>), to name a few of the more common<a id="_idIndexMarker439"/> ones, to store and manage your infrastructure code.</li>
			</ul>
			<p>The odds of you, either personally or within the business, already using version control for your other projects is extremely high if you are taking steps to both define and deploy your infrastructure in and as code. This means that you have experience with version control and access to the tools, processes, and procedures to maintain code using version control.</p>
			<p>Employing version control enables collaboration, change tracking, and easy rollback to previous versions if needed.</p>
			<ul>
				<li><strong class="bold">Documentation</strong>: You can approach documentation in several ways, and it doesn’t matter how you do it, just as long as you do it!</li>
			</ul>
			<p>My personal approach to documenting my IaC deployments is to try and keep as much of the documentation within the code as possible using both in-comments and making sure that sections, tasks, functions, or variables are as clearly named and descriptive as possible while keeping within any of the constraints of the tool I am using.</p>
			<p>Also, depending on the complexity, I will summarise what the code does, attach it as a <code>README</code> file, and commit it to version control.</p>
			<p>The reason I do this is that while it is easy to keep track of what is going on while you are working on the project, when it comes to someone else picking it up – or even you revisiting it yourself after a few months of being away from the project – it can sometimes take them a little time to get their bearings.</p>
			<p>Your approach may differ, which leads nicely into the next piece of best practice.</p>
			<ul>
				<li><strong class="bold">Code reviews</strong>: I recommend conducting regular code reviews to maintain code quality, ensure compliance with best practices, and share knowledge among team members.</li>
			</ul>
			<p>You may already have processes<a id="_idIndexMarker440"/> to enforce this across other types of development within the business, such as your applications. It is just as crucial that the same principles govern your IaC projects as you may be asked to demonstrate that your code adheres to any guidelines that your application has to follow for compliance reasons. After all, your IaC project will be deploying and maintaining the resources your application will run upon.</p>
			<ul>
				<li><strong class="bold">Modularity</strong>: When you write your infrastructure code, do it in smaller, reusable modules. This promotes reusability, maintainability, and better organization of your code base. We covered this <a id="_idTextAnchor520"/>in <a href="B19537_06.xhtml#_idTextAnchor350"><em class="italic">Chapter 6</em></a>, <em class="italic">Building upon </em><em class="italic">the Foundation<a id="_idTextAnchor521"/>s</em>.</li>
				<li><strong class="bold">Continuous Integration and Continuous Deploymen<a id="_idTextAnchor522"/>t</strong> (<strong class="bold">CI/CD</strong>): We discussed this at length<a id="_idIndexMarker441"/> in the previous cha<a id="_idTextAnchor523"/>pter, <a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a>, <em class="italic">Leveraging CI/CD in the Cloud</em>. Even for development purposes, if you have your code in source control, you should ideally be leveraging CI/CD.</li>
				<li><strong class="bold">Testing</strong>: In the perfect world, you should implement automated testing for your infrastructure code to validate its correctness, identify issues early, and increase its overall reliability. If you are using version control and CI/CD, you already have most of the tools to make this process easy. For examp<a id="_idTextAnchor524"/>le, in <a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a>, <em class="italic">Leveraging CI/CD in the Cloud</em>, we had some break-points when running Terraform plan to catch potential issues.</li>
				<li><strong class="bold">Monitoring and logging</strong>: Implement monitoring and logging solutions to track executions and detect issues allowing you to troubleshoot problems promptly. In <a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a>, <em class="italic">Leveraging CI/CD in the Cloud</em>, our CI/CD pipelines kept a log of everything that happened during the execution. In Terraform’s case, we generated and attached a snapshot of the plan file – this level of information can be very valuable when trying to figure out what would happen if something unexpected happened.</li>
				<li><strong class="bold">The principle of least privilege</strong>: Limit access to resources and creation by granting the minimum<a id="_idIndexMarker442"/> necessary permissions for your infrastructure code executions to interact with the components they are working with.</li>
			</ul>
			<p>Depending on your target infrastructure, this may only sometimes be possible, but most cloud providers allow you to be very granular with the permissions. Also, depending on what you are deploying, this could take a little trial and error – but in the long run, it is worth investing the time in looking at it from a security point of v<a id="_idTextAnchor525"/>iew.</p>
			<ul>
				<li><strong class="bold">Immutable infrastructure</strong>: Rather than updating existing infrastructure, create new infrastructure to replace the old one and reroute requests to it. This reduces the risk of errors due to configuration drift and forces deployments to be more predictable.</li>
			</ul>
			<p>This approach depends on your application, and it may only sometimes be practical for you to fully implement this approach. Still, the more your infrastructure components you can make immutable, the easier it will be for you to scale out and back down.</p>
			<ul>
				<li><strong class="bold">Secure by Design (SBD)</strong>: As you write your infrastructure code, incorporate security best practices<a id="_idIndexMarker443"/> and tools from the beginning, such as encryption, identity management, and network segmentation if possible, and as already mentioned, focus on making these parts of your code as modular as possible so that you can easily reuse them across<a id="_idIndexMarker444"/> your projects.</li>
			</ul>
			<p>Now that we have established some general best practices, let us move on and discuss some general troubleshooting<a id="_idTextAnchor526"/> tips.</p>
			<h2 id="_idParaDest-125"><a id="_idTextAnchor527"/>General IaC troubleshooting tips</h2>
			<p>The following are some general<a id="_idIndexMarker445"/> troubleshooting tips, tricks, and approaches. As we are talking about general IaC tips, many of them are more preventive than tasks you would do to debug an issue:</p>
			<ul>
				<li><strong class="bold">Avoid hardcoding sensitive information</strong>: Use secret management tools such as Azure Key Vault, HashiCorp Vault, or AWS Secrets Manager to securely store and retrieve sensitive information at runtime or use your infrastructure code to configure your resources to use the secret management tools directly.</li>
			</ul>
			<p>While it goes without saying that you shouldn’t hardcode sensitive information such as passwords, private information, or secrets directly within your code (Ansible could be an exception, but more on that in the <em class="italic">Ansible – best practices and troubleshooting</em> section), there are advantages to using secret management tools – the biggest one is for things such as certificate management.</p>
			<p>Imagine it’s a day or two before your SSL certificate expires, and you are rushing to get all resources that reference it updated. Using your target platform’s secret store may mean that you only have to update the certificate; then all resources that use the certificate are automatically update<a id="_idTextAnchor528"/>d.</p>
			<ul>
				<li><strong class="bold">Keep dependencies up-to-date</strong>: Throughout <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Microsoft Azure</em>, and <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon Web Services</em>, you will have noticed that our infrastructure code utilized a lot of different tasks and modules.</li>
			</ul>
			<p>Regularly updating your dependencies will help you avoid security vulnerabilities and compatibility issues. As your target cloud APIs are updated, you may find that your code has issues or no longer works.</p>
			<ul>
				<li><strong class="bold">Don’t overcomplicate your infrastructure code</strong>: Keep your infrastructure code as simple as possible and avoid unnecessary complexity that may be difficult to maintain and troubleshoot should there be issues.</li>
			</ul>
			<p>It may look “cool” to build lots of logic<a id="_idIndexMarker446"/> or loops into your IaC. Still, it only takes a slight change as part of a tool or dependency update for it to come tumbling down – the more effort and time needed to code something, the more effort you are likely to put into debugging and refactoring it if and when there are problems.</p>
			<p>Trust me, from experience, your future self will thank you for this.</p>
			<ul>
				<li><strong class="bold">Maintain a clean, well-organized code base</strong>: Consistently use naming conventions, follow a directory structure, and remove obsolete code.</li>
			</ul>
			<p>Anyone within your team needs to be able to pick up your code and know what is going on without having seen it; you will not always be the only one who looks into any problems with your code.</p>
			<p>You want to avoid creating more work for whoever picks it up, as they will likely already be under pressure because someone has reported a problem.</p>
			<ul>
				<li><strong class="bold">Don’t ignore error or warning messages</strong>: Address any messages, especially non-breaking warning messages in your infrastructure code, promptly to prevent future issues.</li>
			</ul>
			<p>Most tools will stop execution when there are errors. However, most will also print warnings – these could be just be small things such as letting you know that functionality you are using will be deprecated or changed in future releases, and warnings will not stop execution. Still, they need to be addressed just like any errors you receive; it isn’t every day you get the chance to avoid future errors, so take it.</p>
			<p>Finally, and this goes without saying, <strong class="bold">communicate with your team</strong>. Regularly communicate with your team about infrastructure changes, potential issues, and best practices to ensure everyone is on the same page when it comes to your IaC. You do not want to be a single point of failure, nor do you want to set your team<a id="_idIndexMarker447"/> up for failure should there be any problems.</p>
			<p>Now that we have worked through the general best practices and troubleshooting tips, let us look at some of the things you should consider when using the two tools we have discussed in the book, starting with Terraform.</p>
			<h1 id="_idParaDest-126"><a id="_idTextAnchor529"/>Terraform – best practices and troubleshooting</h1>
			<p>We will cover some of the recommendations we have already touched upon in the <em class="italic">General IaC best practices</em> section. Still, as mentioned at the start of the chapter, we will go into more detail about how they apply to just T<a id="_idTextAnchor530"/><a id="_idTextAnchor531"/>erraform.</p>
			<h2 id="_idParaDest-127"><a id="_idTextAnchor532"/>Terraform – best practices</h2>
			<p>Here are some best practices<a id="_idIndexMarker448"/> for approaching your Terraform deployment:</p>
			<ul>
				<li><strong class="bold">Use a modular approach</strong>: Break down infrastructure into reusable modules, simplifying code maintenance and enabling reusability across different environments.</li>
			</ul>
			<p>As we discussed in <a href="B19537_06.xhtml#_idTextAnchor350"><em class="italic">Chapter 6</em></a>, <em class="italic">Building upon the Foundations</em>, Terraform modules can be hosted in the Terraform Registry or, which I have not mentioned, privately in yo<a id="_idTextAnchor533"/>ur own Git<a id="_idIndexMarker449"/> repository. The following example code downloads the module from GitHub using <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>):</p>
			<pre class="source-code">
module "somefunction" {
  source = "git@github.com:someuser/tfmodule.git"
}</pre>
			<p>Assuming you are executing your Terraform code from somewhere that has access to the repository, it will download and use it.</p>
			<p>This allows you to build a library of reusable modules for use across all of your projects, and it also allows you to share modules with the rest of your teams.</p>
			<ul>
				<li><strong class="bold">Keep a consistent naming convention</strong>: Using a consistent naming convention for resources and modules improves readability and maintainability.</li>
			</ul>
			<p>Depending<a id="_idIndexMarker450"/> on the size of the team wor<a id="_idTextAnchor534"/>king on your infrastructure code, you should establish a style guide and guidelines for developing and maintaining your Terraform infrastructure code.</p>
			<ul>
				<li><strong class="bold">Manage state files securely</strong>: We have already discussed storing your state files remotely<a id="_idIndexMarker451"/> in a backend such as an Azure storage account or AWS <strong class="bold">Simple Storage Service</strong> (<strong class="bold">S3</strong>) in <a href="B19537_07.xhtml#_idTextAnchor431"><em class="italic">Chapter 7</em></a>, <em class="italic">Leveraging CI/CD in </em><em class="italic">the Cloud</em>.</li>
			</ul>
			<p>Most of the supported backend services allow you to enable versioning and force encryption to ensure data integrity and security – make sure that this is enabled. Most services do it by default, but it is best to double-check.</p>
			<p>Also, there is another service that should have been mentioned: Terraform Cloud. HashiCorp (the makers of Terraform), has a cloud service that can store your state files securely and also act as a remote execution environment for your Terraform run. There are both free and paid options, and if you can use them, I recommend taking a look.</p>
			<ul>
				<li><code>terraform plan</code> command to visualize the potential impact of the code run. Use code reviews and automated testing to validate changes and minimize the risk of errors or something unexpected.</li>
				<li><strong class="bold">Use provider and resource version pinning</strong>: While Terraform development rates differ from provider to provider, you may find that breaking changes are introduced.</li>
			</ul>
			<p>You should lock the versions of providers within your infrastructure code and define an explicit version number when registering the providers used to ensure a consistent and stable infrastructure.</p>
			<ul>
				<li><code>lookup</code>, <code>count</code>, and <code>for_each</code> to reduce complexity and improve flexibility. There are also functions, as we discussed in <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Microsoft Azure</em>, and <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon Web Services</em>, where you work out <strong class="bold">Classless Inter-Domain Routing</strong> (<strong class="bold">CIDR</strong>) ranges and perform transformations on input<a id="_idIndexMarker452"/> and output variables – all of which can help reduce the number of variables <a id="_idIndexMarker453"/>you <a id="_idTextAnchor535"/>have to define.</li>
			</ul>
			<h2 id="_idParaDest-128"><a id="_idTextAnchor536"/>Terraform – troubleshooting</h2>
			<p>Here are some of the best practices<a id="_idIndexMarker454"/> for approaching your Terraform deployment:</p>
			<ul>
				<li><strong class="bold">Avoid hardcoding sensitive information</strong>: As you may have already guessed, this is a common but significant recurring theme; <em class="italic">please do not do it!</em> Instead, with Terraform, you can use environment variables or secret management tools to avoid exposing sensitive data in your code.</li>
				<li><code>depends_on</code> parameter when necessary to avoid issues related to resource ordering.</li>
			</ul>
			<p>We discussed this in <a href="B19537_02.xhtml#_idTextAnchor085"><em class="italic">Chapter 2</em></a>, <em class="italic">Ansible and Terraform beyond the Documentation</em>, in the <em class="italic">Fixing the error</em> section.</p>
			<ul>
				<li><code>prevent_destroy</code> and ensure proper access controls.</li>
			</ul>
			<p>The following is an example of how you would use <code>prevent_destroy</code> to protect against the accidental deletion of an Azure storage account:</p>
			<pre class="source-code">
resource "azurerm_storage_account" "example" {
  name                     = "saiacforbeg2022111534"
  resource_group_name      = azurerm_resource_group.example.name
  location                 = azurerm_resource_group.example.location
  account_tier             = "Standard"
  account_replication_type = "GRS"
  lifecycle {
   prevent_destroy = true
 }
}</pre>
			<p>You would receive an error if you attempted to run <code>terraform</code> <code>destroy</code> against the resource, which is much better than unexpectedly deleting the resource.</p>
			<p>Please note that this is not a resource<a id="_idIndexMarker455"/> lock at the cloud-provider level; you are just instructing Terraform that it can’t destroy the resource on execution.</p>
			<ul>
				<li><strong class="bold">Monitor resource limits</strong>: Be aware of provider-specific limits and quotas, which could lead to resource provisioning failures if they are hit.</li>
			</ul>
			<p>Errors while provisioning resources due to limits or quotas could result in a corrupted state file, which may not be easily recoverable depending on the resource you are targeting.</p>
			<ul>
				<li><code>terraform refresh</code> and <code>terraform plan</code>. You could do this using CI/CD and have it alert depending on the output.</li>
				<li><strong class="bold">Watch for state file conflicts</strong>: If multiple team members work on the same infrastructure, use remote state backends with locking mechanisms to prevent conflicting changes. Most backends support this by default, but to avoid state file corruption for production resources, I recommend triple-checking.</li>
				<li><strong class="bold">If possible, avoid using multiple provisioning tools</strong>: Mixing Terraform with other provisioning tools (for example, CloudFormation or <strong class="bold">Azure Resource Manager</strong> (<strong class="bold">ARM</strong>) templates) can cause conflicts and unexpected behavior on subsequent<a id="_idIndexMarker456"/> executions. Stick to one provisioning tool for consistency and predictability, and if possible, attempt to find a workaround for your reason to deploy using the multiple tools in this place. This is a slightly different use case than what we discussed in <a href="B19537_06.xhtml#_idTextAnchor350"><em class="italic">Chapter 6</em></a>, <em class="italic">Building upon the Foundations</em>, where we used Ansible to trigger Terraform; this is using Terraform to run other IaC tools – which some providers support.</li>
			</ul>
			<p>As this functionality is built into each provider, and each provider is a separate project away from the core Terraform development, you may see that functionality between different providers is very different.</p>
			<p>If you have to take this route, please consult your provider’s documentation and, where necessary, examine the issues logged in its GitHub repo to see whether any problems have been reported with the<a id="_idIndexMarker457"/> functionality.</p>
			<p>As you have seen in this section, much of the advice is similar to the general advice we covered at the start of the chapter. Let us see if this trend continues for Ansible.</p>
			<h1 id="_idParaDest-129"><a id="_idTextAnchor539"/>Ansible – best practices and troubleshooting</h1>
			<p>At this point in the chapter, you know the drill by now: we are going start by discussing best practices, but this time putting an Ansible spin on them.</p>
			<h2 id="_idParaDest-130"><a id="_idTextAnchor540"/>Ansible – best practices</h2>
			<p>Here are some of the best practices<a id="_idIndexMarker458"/> for approaching your Ansible playbooks:</p>
			<ul>
				<li><strong class="bold">Organize your playbooks with roles</strong>: Use roles to group related tasks, variables, files, and templates, making your playbooks easier to understand and maintain.</li>
			</ul>
			<p>For more information on this, see <a href="B19537_06.xhtml#_idTextAnchor350"><em class="italic">Chapter 6</em></a>, <em class="italic">Building upon the Foundations</em>, where we discussed roles and Ansible Galaxy in more detail – this also leads into our next bit of advice.</p>
			<ul>
				<li><strong class="bold">Keep playbooks modular and reusable</strong>: Write modular playbooks and tasks that can be reused in different scenarios to minimize duplication and improve maintainability.</li>
			</ul>
			<p>This is where we<a id="_idIndexMarker459"/> start to differ slightly from Terraform, as Ansible can also be used to access both Linux or Windows hosts and execute commands on them, so reusable<a id="_idIndexMarker460"/> code for everyday tasks such as installing Apache, enabling <strong class="bold">Internet Information Services </strong>(<strong class="bold">IIS</strong>), or even just patching the operating systems you are targetting will be useful.</p>
			<ul>
				<li><strong class="bold">Use version control</strong>: Keep your Ansible playbook and configurations in a version control system such as Git to track changes and encourage/enable collaboration amongst your team members.</li>
				<li><strong class="bold">Employ a consistent naming convention</strong>: Adopt a clear and consistent naming convention for tasks, files, templates, and especially variables to make it easier for other team members to pick up and follow your p<a id="_idTextAnchor541"/>laybook quickly.</li>
				<li><strong class="bold">Use a dynamic inventory</strong>: This is not something we have touched upon so far, but when Ansible targets a host’s operating system, it uses an inventory file, which is a list of hosts to interact with.</li>
			</ul>
			<p>Instead of hardcoding host details in an inventory file, you can use a dynamic inventory script to discover and manage resources in your environment automatically. There are scripts for most providers that typically work on tags to discover what to target.</p>
			<p>Let’s imagine your Ansible playbook launches half a dozen virtual machines in your chosen cloud. If you were to tag them with <code>Role:Web</code>, then you could use a dynamic inventory script to search the cloud provider for all virtual machines tagged with <code>Role</code> of <code>Web</code> and build up a list of IP addresses to run your playbook against.</p>
			<ul>
				<li><strong class="bold">Implement idempotence</strong>: Ensure your tasks are idempotent, which means they can be executed multiple times without producing unexpected results or side effects.</li>
			</ul>
			<p>If your Ansible playbook deals exclusively with just infrastructure code, then this should be straightforward, as much of this logic is handled by the APIs with which the modules will interact.</p>
			<p>However, if you are targeting<a id="_idIndexMarker461"/> operating systems, this becomes important, as you want to avoid anything unexpected happening across potentially several hosts.</p>
			<ul>
				<li><strong class="bold">Secure sensitive data with Ansible Vault</strong>: I have left this one until the end. Ansible<a id="_idIndexMarker462"/> has a built-in secrets management system called Ansible Vault, which allows you to encrypt sensitive data, such as passwords and API keys, to protect them from unauthorized access.</li>
			</ul>
			<p>As well as commands such as <code>ansible-playbook</code> and <code>ansible-galaxy</code>, Ansible also ships with <code>ansible-vault</code>.</p>
			<p>This command can encrypt and decrypt both entire files and simple strings. In the following example, we will look at encrypting a string:</p>
			<pre class="source-code">
<strong class="bold">$ ansible-vault encrypt_string --vault-id @prompt HelloWorld</strong></pre>
			<p>Running the command will prompt for a new password and confirmation of the password. Once entered, it will encrypt the specified text, which is super-secret <code>HelloWorld</code>, and give you something that looks like the following:</p>
			<pre class="source-code">
New vault password (default):
Confirm new vault password (default):
Encryption successful
!vault |
$ANSIBLE_VAULT;1.1;AES256
35373665396163313561373336306261346264323638616664383766316464643964353266656632
6365373333383734376137656339623165663537633965630a396133336536353036346133393437
37383534653362306438653034383266383132393966383063666330313964396338326462373532
3332653564633839390a636538626261393630323733643135643339303333346638353039396439
3736</pre>
			<p>Now that you have the encrypted<a id="_idIndexMarker463"/> string, you can use it in your playbook file as in the following example (pease note that the spacing has been removed to make it easier to read):</p>
			<pre class="source-code">
---
- name: Ansible Vault Example
  hosts: localhost
  gather_facts: false
  vars:
    some_secret: !vault |
          $ANSIBLE_VAULT;1.1;AES256
64346261636562356365326638303365316335343031666439616236663336316361336466353461
6239333166326634636337333133303939306465373130390a626563373834326163313133313039
37353763613539363837636237343631393365323763393235626334323561373434303531653831
3464393938653831370a666565626265666432353039363334623562613363626532623666333565
3062
  tasks:
    - name: print the secure variable
      debug:
        var: some_secret</pre>
			<p>There is a copy of the preceding<a id="_idIndexMarker464"/> code in the GitHub repository that accompanies this title. To run the playbook, we need to tweak our <code>ansible-playbook</code> command slightly:</p>
			<pre class="source-code">
<strong class="bold">$ ansible-playbook --vault-id @prompt site.yml</strong></pre>
			<p>Assuming you enter the correct password for the vault, this should give you something like the following output:</p>
			<div><div><img src="img/Figure_8.01_B19537.jpg" alt="Figure 8.1 – Running the playbook and viewing the secret" width="1634" height="932"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Running the playbook and viewing the secret</p>
			<p>If you promise not to tell anyone, the password for the playbook is <code>password</code>, so you can run the playbook in the repo yourself.</p>
			<p>Ansible Vault can also encrypt<a id="_idIndexMarker465"/> entire files, meaning<a id="_idIndexMarker466"/> you can include files such as a private key for <code>base64</code> to encode a binary file as text and then use a vault to encrypt the encoded context, as Ansible has built-in functions for decoding <code>base64</code>.</p>
			<p>So how is this any better than using a secret management tool? Well, it could be less complicated – you could use your secret management tool to store the password for Ansible Vault and then embed the rest of your secrets in your repo.</p>
			<p>Now that we have covered some best practices, let’s talk about troubleshooting.</p>
			<h2 id="_idParaDest-131"><a id="_idTextAnchor542"/>Ansible – troubleshooting</h2>
			<p>What follows are some troubleshooting tips<a id="_idIndexMarker467"/> for Ansible, and a lot of the general ones also apply:</p>
			<ul>
				<li><code>debug</code> module to display variables, messages, or task output, helping you identify issues in your code.</li>
			</ul>
			<p>This is extremely helpful when trying to find out the contents of a variable or the output of a task; the following example playbook uses the <code>debug</code> module to output the contents of the <code>ansible_facts</code> variable:</p>
			<pre class="source-code">
---
- hosts: localhost
  gather_facts: yes
  tasks:
    - name: Print all the fac<a id="_idTextAnchor543"/>ts
      debug:
        var: ansible_facts</pre>
			<p>Running the playbook using <code>ansible-playbook site.yml</code> should show you information about your host.</p>
			<ul>
				<li><code>ansible-playbook</code>; you can add the <code>-v</code>, <code>-vv</code>, or <code>-vvv</code> options to increase the verbosity of the output, providing more insight into what’s happening during execution.</li>
				<li><strong class="bold">Check your YAML syntax</strong>: I have lost countless hours looking at a problem only to find I haven’t formatted the YAML in my playbook correctly. Save yourself some time and validate your YAML files with a linter or online validator to catch any formatting or syntax errors.</li>
				<li><strong class="bold">Review the failed and skipped task summaries</strong>: Examine the <em class="italic">failed</em> and <em class="italic">skipped</em> task summaries at the end of a playbook run to identify tasks that did not execute as expected; Ansible may not completely stop execution on a failed task, so ensure that you pay attention to your playbook runs as you may have problems and not immediately realize it.</li>
				<li><strong class="bold">Verify file and directory permissions</strong>: Ensure that the appropriate file and directory permissions are set for your Ansible files and target hosts, allowing the required access for execution.</li>
			</ul>
			<p>For example, if you are using SSH to access a host after it has been launched, ensure that the permissions on your local machine for things such as your SSH key are correct, or your Ansible playbook<a id="_idIndexMarker468"/> run may fail.</p>
			<p>As you can see, with the addition of managing workloads within the target hosts rather than just the infrastructure, there are a few more considerations with Ansible than with a tool such as Terraform.</p>
			<h1 id="_idParaDest-132"><a id="_idTextAnchor544"/>Summary</h1>
			<p>We have discussed a lot in this chapter; we have talked about several similar concepts but have taken slightly different approaches depending on the tool we chose.</p>
			<p>For me, the biggest takeaways from this chapter are as follows:</p>
			<ul>
				<li><strong class="bold">Version control</strong>: Use version control to track changes and collaborate with your team and colleagues easily.</li>
				<li><strong class="bold">Documentation and consistency</strong>: Ensure that your infrastructure code is well documented and has been written in line with your style guides or other IaC projects – no one wants to pick up messy or undocumented code during a crisis.</li>
				<li><strong class="bold">Keep an eye on the content</strong>: Ensure you do not expose passwords, keys, or other sensitive content by checking it into your version control system. A lot of the IaC we have spoken about is designed to be human-readable, and that is the last thing you want for sensitive information.</li>
				<li><strong class="bold">Please keep it simple</strong>: Believe me, it is very easy to go down a rabbit hole and create some very complex, and some would say overkill, IaC projects. From experience, these types of projects always end up causing more problems than they solve. They are challenging to maintain and for other team members to pick up and work with if they end up inheriting them – keep things simple and follow the previously listed takeaways.</li>
			</ul>
			<p>In our next and final chapter, we are going to take a look at three other IaC tools, including two native tools from the cloud providers Microsoft Azure and Amazon Web Services, before then discussing what your next steps with IaC could be.</p>
		</div>
	</div>
</div>
</body></html>