- en: Chapter 4.  Handling Complex Deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You must be wondering why the chapter is named the way it is. The reason for
    this is so far, we've not yet reached a stage where you can deploy the playbooks
    in production, especially in complex situations. Complex situations include those
    where you have to interact with several (hundred or thousand) machines where each
    group of machines is dependent on another group or groups of machines. These groups
    may be dependent on each other for all or some transactions, to perform secure
    complex data backups and replications with master and slaves. In addition, there
    are several interesting and rather compelling features of Ansible that we've not
    yet looked at. In this chapter, we will cover all of them with examples. Our aim
    is that, by the end of this chapter, you should have a clear idea of how to write
    playbooks that can be deployed in production from a configuration management perspective.
    The following chapters will add to what we've learned to enhance the experience
    of using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do so, we''ll start with a feature that can come in handy for some occasions:
    the `local_action`.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with the local_action feature
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `local_action` feature of Ansible is a powerful one, especially when we
    think of Orchestration. This feature allows you to run certain tasks locally on
    the machine that runs Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Spawning a new machine or creating a JIRA ticket
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing your command center(s) in terms of installing packages and setting
    up configurations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calling a load balancer API to disable a certain web server entry from the load
    balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are tasks that can be run on the same machine that runs the `ansible-playbook`
    command rather than logging in to a remote box and running these commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. Suppose you want to run a shell module on your local
    system where you are running your Ansible playbook. The `local_action` option
    comes into the picture in such situations. If you pass the module name and the
    module argument to `local_action`, it will run that module locally. Let''s see
    how this option works with the `shell` module. Consider the following code that
    shows the output of the `local_action` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now save it as `local_action.yaml` and run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We receive the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the two commands provided us different numbers since they have
    been executed on different hosts. You can run any module with `local_action`,
    and Ansible will make sure that the module is run locally on the box where the
    `ansible-playbook` command is run. Another simple example you can (and should!)
    try is running two tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`uname` on the remote machine (`db01` in the preceding case)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uname` on the local machine but with local_action enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will crystallize the idea of `local_action` further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible provides another method to delegate certain actions to a specific (or
    different) machine: the `delegate_to` system.'
  prefs: []
  type: TYPE_NORMAL
- en: Delegating a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you want to execute an action on a different system. This could be,
    for instance, a database node while you are deploying something on an application
    server node or to the local host. To do so, you can just add the ''`delegate_to:
    HOST`'' property to your task and it will be run on the proper node. Let''s rework
    the previous example to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Saving it as `delegate_to.yaml`, we can run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the same output as the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Working with conditionals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have only seen how playbooks work and how tasks are executed.
    We also saw that Ansible executes all these tasks sequentially. However, this
    would not help you while writing an advanced playbook that contains tens of tasks
    and have to execute only a subset of these tasks. For example, let's say you have
    a playbook that will install Apache HTTPd server on the remote host. Now, the
    Apache HTTPd server has a different package name for a Debian-based operating
    system, and it's called `apache2`; for a Red-Hat-based operating system, it's
    called `httpd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having two tasks, one for the `httpd` package (for Red-Hat-based systems) and
    the other for the `apache2` package (for Debian-based systems) in a playbook,
    will make Ansible install both packages, and this execution will fail, as `apache2`
    will not be available if you''re installing on a Red-Hat-based operating system.
    To overcome such problems, Ansible provides conditional statements that help run
    a task only when a specified condition is met. In this case, we do something similar
    to the following pseudocode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'While installing `httpd` on a Red-Hat-based operating system, we first check
    whether the remote system is running a Red-Hat-based operating system, and if
    it is, we then install the `httpd` package; otherwise, we skip the task. Without
    wasting your time, let''s dive into an example playbook called `conditional_httpd.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I've created a new server (`ws03`) for this example that is
    Debian-based. As expected, the installation of the `httpd` package was performed
    on the two CentOS nodes, while the installation of the `apache2` package was performed
    on the Debian node.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible only distinguishes between a few families (AIX, Alpine, Altlinux, Archlinux,
    Darwin, Debian, FreeBSD, Gentoo, HP-UX, Mandrake, Red Hat, Slackware, Solaris,
    and Suse at the time of writing this book), for this reason a CentOS machine has
    an `ansible_os_family` value; '`RedHat`'.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, you can match for different conditions as well. Ansible supports equal
    to (`==`), different than (`!=`), bigger than (`>`), smaller than (`<`), bigger
    than or equal to (`>=`), and smaller than or equal to (`<=`).
  prefs: []
  type: TYPE_NORMAL
- en: The operators we have seen so far will match the entire content of the variable,
    but what if you just want to check whether a particular character or a string
    is present in a variable? To perform these kinds of checks, Ansible provides the
    in and not operators. You can also match multiple conditions using the `AND` and
    `OR` operators. The `AND` operator will make sure that all conditions are matched
    before executing this task, whereas the `OR` operator will make sure that at least
    one of the conditions there is a match for at least one of the conditions, for
    example, you can use `foo >= 0` and `foo <= 5`.
  prefs: []
  type: TYPE_NORMAL
- en: Boolean conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from string matching, you can also check whether a variable is `True`.
    This type of validation will be useful when you want to check whether a variable
    was assigned a value or not. You can even execute a task based on the Boolean
    value of a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s put the following code in a file called `crontab_backup.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we execute it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We will obtain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But if we change the command slightly, to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in the first case the operation has been executed, while in
    the second case it was skipped. We could have overwritten the backup value using
    a configuration file, a `host` variable, or a `group` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If checked in this way and if the variable is not set, Ansible will assume it
    to be `False`.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if a variable is set
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes you find yourself having to use a variable in a command. Every time
    you do so, you have to ensure that the variable is *set*. This is because some
    commands could be catastrophic if called with an *unset* variable (that is: if
    you execute `rm -rf $VAR/*` and `$VAR` is not set or empty, it will nuke your
    machine). To do so, Ansible provides a way to check whether a variable is defined
    or not.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could improve the previous example in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have used the `fail` module that allows us to put the Ansible
    playbook in a failure state in case the `backup_folder` variable is not set.
  prefs: []
  type: TYPE_NORMAL
- en: Working with include
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `include` feature helps you to reduce duplicity while writing tasks. This
    also allows us to have smaller playbooks by including reusable code in separate
    tasks using the **Don't Repeat Yourself** (**DRY**) principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'To trigger the inclusion of another file, you need to put the following under
    the tasks object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also pass some variables to the included file. To do so, we can specify
    them in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition of passing variables, you can also use conditionals to include
    a file only when certain conditions are matched, for instance to include the `redhat.yaml`
     file only if the machine is running an OS in the Red Hat family using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Working with handlers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many situations, you will have a task or a group of tasks that change certain
    resources on the remote machines, which need to trigger an event to become effective.
    For example, when you change a service configuration, you will need to restart
    or reload the service itself. In Ansible you can trigger this event using the
    `notify` action.
  prefs: []
  type: TYPE_NORMAL
- en: 'Every handler task will run at the end of the playbook if notified. For example,
    you changed your HTTPd server configuration multiple times and you want to restart
    the HTTPd service so that the changes are applied. Now, restarting HTTPd every
    single time you make a configuration change is not a good practice; it is not
    a good practice to restart the server even if no changes has been made to its
    configurations. To deal with such a situation, you can notify Ansible to restart
    the HTTPd service on every configuration change, but Ansible will make sure that
    no matter how many times you notify it for the HTTPd restart, it will call that
    task just once after all other tasks complete. Let''s change the `webserver.yaml`
    file we created in the previous chapters a little bit, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Run this script with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the handler has been triggered from the configuration file change.
    But if we run it a second time, the configuration will not change and therefore
    we will have the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When using handlers, those are triggered only a single time, even if they are
    called multiple times during the playbook execution. By default, handlers are
    executed at the end of the playbook execution, but you can force them to be run
    when you want using the `meta` task with the `flush_handlers` option like: `-
    meta: flush_handlers`'
  prefs: []
  type: TYPE_NORMAL
- en: Working with roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how we can automate simple tasks, but what we have seen up till
    now will not solve all your problems. This is because playbooks are very good
    at executing operations, but are not very good for configuring huge amounts of
    machines, because they will soon become messy. To solve this, Ansible has roles.
  prefs: []
  type: TYPE_NORMAL
- en: My definition of a role is a set of playbooks, templates, files, or variables
    to achieve a specific goal. For instance, we could have a database role and a
    web server role so that those configurations stay cleanly separated.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting to look inside a role, let's talk about a project organization.
  prefs: []
  type: TYPE_NORMAL
- en: Project organization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the last few years, I've worked on multiple Ansible repositories for multiple
    organizations and many of them were very chaotic. To ensure that your repository
    is easy to manage, I'm going to give you a template that I always use.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, I always create three files in the `root` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.cfg`: A small configuration file to explain to Ansible where to find
    the files in our folder structure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hosts`: The hosts file we have already seen in the previous chapters'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`master.yaml`: A playbook that aligns the whole infrastructure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to those three files, I create two folders:'
  prefs: []
  type: TYPE_NORMAL
- en: '`playbooks`: This will contain the playbooks and a folder called *groups* for
    groups management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`roles`: This will contain all the roles we need'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To clarify this, let''s use the Linux `tree` command to see the structure of
    an Ansible repository for a simple web application needing web servers and database
    servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I've added a `common` role as well. This is very useful for
    putting in all the things that should be performed for every server. Usually,
    I configure NTP, motd, and other similar services in this role, as well as the
    machine hostname.
  prefs: []
  type: TYPE_NORMAL
- en: We will now see how to structure a role.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The structure of folders in a role is standard and you cannot change it much.
  prefs: []
  type: TYPE_NORMAL
- en: The most important folder within the role is the `tasks` folder because this
    is the only mandatory folder in it. It has to contain a `main.yaml` file that
    will be the list of tasks to be executed. Other folders that are often present
    in the roles are templates and files. The first one will be used to store templates
    used by the **template task**, while the second will be used to store files that
    are used by the **copy task**.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming your playbooks in a full Ansible project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's see how to transform the three playbooks we used to set up our web infrastructure
    (`common_tasks.yaml`, `firstrun.yaml`, and `webserver.yaml`) to fit this file
    organization. We have to remember that we also used two files (`index.html.j2`
    and `motd`) in those roles, so we have to place these files properly too.
  prefs: []
  type: TYPE_NORMAL
- en: First, we are going to create the folder structure we have seen in the previous
    paragraph.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest playbook to port is the `firstrun.yaml` since we only need to copy
    it into the playbooks folder. This playbook will remain a playbook because it's
    a set of operations that will have to be run just one time for each server.
  prefs: []
  type: TYPE_NORMAL
- en: We now move to the `common_tasks.yaml` playbook, which will need a little bit
    of rework to match the role paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a playbook into a role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first thing we need is to create the `roles/common/tasks` and `roles/common/templates`
    folders. In the first one we will add the following `main.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this is very similar to our `common_tasks.yaml` playbooks.
    In fact, there are only two differences:'
  prefs: []
  type: TYPE_NORMAL
- en: The lines; `hosts`, `remote_user`, and `tasks` (lines 2,3, and 4) have been
    deleted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The indentation of the rest of the file has been fixed accordingly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this role, we used the template task to create a `motd` file on the server
    with the IP of the machine and other interesting information. For this reason,
    we need to create `roles/common/templates` and put the `motd` template in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, our common task will have this structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We now need to instruct Ansible on the machines that will need to perform all
    the tasks specified in the `common` role. To do so, we should look at the `playbooks/groups`
    directory. In this directory, it is handy to have one file for each group of logically
    similar machines (that is, machines that are performing the same kind of operation).
    In our case, database and web server.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s create a `database.yaml` file in `playbooks/groups` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a `webserver.yaml` file in the same folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, those files specify the group of hosts that we want to operate
    on, the remote user to use on those hosts, and the roles that we want to execute.
  prefs: []
  type: TYPE_NORMAL
- en: Helper files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we created the `hosts` file in the previous chapter, we noticed that it
    helps to simplify our command lines. So, let''s start copying the hosts files
    we previously used in the `root` folder of our Ansible repository. Up to now,
    we have always specified the path of this file on the command line. This is no
    longer necessary if we create an `ansible.cfg` file that tells Ansible the location
    of our `hosts` file. For this reason, let''s create an `ansible.cfg` file in the
    root of our Ansible repository with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this file, we have also specified another two variables in addition to the
    `hostfile` one that we already talk about, and those are `host_key_checking` and
    `roles_path`.
  prefs: []
  type: TYPE_NORMAL
- en: The `host_key_checking` flag is useful to not require the verification of the
    remote system SSH key. This is not suggested for use in production, since the
    usage of a public key propagation system is suggested for such environments, but
    is very handy in testing environments since it will help you to reduce the time
    Ansible hangs waiting for user input.
  prefs: []
  type: TYPE_NORMAL
- en: The `roles_path` is used to tell Ansible where to find the roles for our playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'I usually add one additional file, which is `master.yaml`. I find it very useful
    as you will often need to keep your infrastructure aligned with your Ansible code.
    To do it in a single command, you''ll need a file that will run all of the files
    in `playbooks/groups`. So, let''s create a `master.yaml` file in the Ansible repository
    `root` folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the actions listed in the `common` role have been executed on
    the node in the `database` group first and then on the nodes in the `webserver`
    group.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming the webserver role
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we transformed the `common` playbook into the `common` role, we can do the
    same for the `webserver` role.
  prefs: []
  type: TYPE_NORMAL
- en: 'In roles, we need to have the `webserver` folder with the `tasks` subfolder
    inside it. In this folder, we have to put the `main.yaml` file containing the
    `tasks` copied from the playbooks, that should look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In this role, we have used multiple tasks that will need additional resources
    to work properly, more specifically we need to:'
  prefs: []
  type: TYPE_NORMAL
- en: Put the `website.conf` file in `roles/webserver/files`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Put the `index.html.j2` template in `roles/webserver/templates`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create the `Restart HTTPd` handler
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first two should be pretty straightforward. The first one, in fact, is
    an empty file (we have not yet put anything in it since the default configuration
    was good enough for our use) and the `index.html.j2` file should contain the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Handlers in roles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last thing we need to do to complete this role is to create the handler
    for the `Restart HTTPd` notification. To do so, we will need to create a `main.yaml`
    file in `roles/webserver/handlers` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you may notice, this is very similar to the handler we used in the playbook
    if not for the file location and indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only thing that we still need to do to make our role applicable is to add
    the entry in the `playbooks/groups/webserver.yaml` file so that Ansible is informed
    that the servers in the `webserver` group should apply the `webserver` role as
    well as the common role. Our `playbooks/groups/webserver.yaml` will need to be
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We could now execute the `master.yaml` again to apply the `webserver` role
    to the relevant servers, but we can also just execute the `playbooks/groups/webserver.yaml`,
    since the change we just did is relevant only to this group of servers. To do
    so we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive an output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, both the `common` and the `webserver` roles has been applied
    to the `webserver` nodes.
  prefs: []
  type: TYPE_NORMAL
- en: It's very important to apply all roles concerning a specific node and not just
    the one you changed because more often than not, when there is a problem on one
    or more nodes in a group but not on other nodes of the same group, the problem
    is some roles have been applied unequally in the group. Only by applying all concerned
    roles to a group, will it grant you the equality of the nodes of that group.
  prefs: []
  type: TYPE_NORMAL
- en: Execution strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before Ansible 2, every task needed to be executed (and completed) on each machine
    before Ansible issued a new task to all machines. This meant that if you are performing
    tasks on a hundred machines and one of them is under-performing, all machines
    will go at the under-performing machine's speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Ansible 2, the execution strategies have been made modular and therefore
    you can now choose which execution strategy you prefer for your playbooks. You
    can also write custom execution strategies, but this is beyond the scope of this
    book. At the moment (in Ansible 2.1) there are only three execution strategies:
    **linear**, **serial**, and **free**:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Linear execution**: This strategy behaves exactly as Ansible did prior to
    version 2\. This is the default strategy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Serial execution**: This strategy will take a subset of hosts (the default
    is five) and execute all tasks against those hosts before moving to the next subset
    and starting from the beginning. This kind of execution strategy could help you
    to work on a limited number of hosts so that you always have some hosts that are
    available to your users. If you are looking for this kind of deployment, you will
    need a load balancer in front of your hosts that needs to be informed about which
    nodes are in maintenance at every given moment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Free execution**: This strategy will serve a new task to each host as soon
    as that host has completed the previous task. This will allow faster hosts to
    complete the playbook before slower nodes. If you choose this execution strategy
    you have to remember that some tasks could require a previous task to be completed
    on all nodes (for instance, clustering databases require all database nodes to
    have the database installed and running) and in this case they will probably fail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Ansible 2.0 blocks have been made available. Blocks allow you to group tasks
    in a logical way and they can also help for a better error handling. The majority
    of properties you can add to a standard task, you can also add it to the blocks.
    You may need to perform a yum task to install NTPd and enable of the service only
    if the machine is CentOS. To do so, the following code can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can notice, the when clause has been applied to the block so all tasks
    within the block will be performed only if the when clause will be true.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible template - Jinja filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in the second chapter that templates allow you to dynamically complete
    your playbook and place files on servers based on dynamic data such as `host`
    and `group` variables. In this section, we will move forward and see how Jinja2
    filters work with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jinja2 filters are simple Python functions that take some arguments, process
    them, and return the result. For example, consider the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `myvar` is a variable; Ansible will pass `myvar`
    to the Jinja2 filter as an argument. The Jinja2 filter will then process it and
    return the resulting data. Jinja2 filters even accept additional arguments as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In this example, Ansible will now pass two arguments, that is, `myvar` and `2`.
    Likewise, you can pass multiple arguments to filters separated by commas.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible supports a wide variety of Jinja2 filters, we will see some of the important
    Jinja2 filters that you might need to use while writing your playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Formatting data using filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible supports Jinja2 filters to format data to JSON or YAML. You pass a
    dictionary variable to this filter, and it will format your data into JSON or
    YAML. For example, consider the following command-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, `users` is the variable and `to_nice_json` is the
    Jinja2 filter. As we saw earlier, Ansible will internally pass `users` as an argument
    to the Jinja2 filter `to_nice_json`. Likewise, you can format your data into YAML
    as well by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Using filters with conditionals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use Jinja2 filters with conditionals for checking if the status of
    a task is failed, changed, success, or skipped. Let''s start creating a file in
    our `playbooks` folder with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we first checked whether the `httpd` service was running
    and stored the output of that module in the `httpd_result` variable. We then checked
    whether the previous task failed using the Jinja2 filter, `httpd_result|failed`.
    Ansible will skip this task if the when condition fails, that is, if the previous
    task passed. Likewise, you can use changed, success, or skipped filters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now check that the previous `playbook` executed as expected, running
    it as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'I''ve stopped HTTPd on the `ws01.fale.io` server with the command, `systemctl
    stop httpd` and running it will give me the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Defaulting undefined variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have seen in the previous sections, that it is always wise to check if a
    variable is defined before using it. We can set a `default` value for the variable
    so that instead of failing, Ansible will use that value if the variable is not
    defined. To do so, we use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This filter will not assign the `default` value to the variable; it will only
    pass the `default` value to the current task where it is being used. Let''s look
    at a few more examples of Jinja filters themselves before closing this section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using random number filters: To find a random number, character, or string
    out of a list, you can use the random filter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute this to get a random character from a list:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute this to get a random number from 0 to 100:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute this to get a random number from 10 to 50:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute this to get a random number from 20 to 50 in steps of 10:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Concatenating a list to the string using filters: Jinja2 filters allow you
    to concatenate a list to a string using the join filter. This filter takes a separator
    as an extra argument. If you do not specify a separator, then the filter will
    combine all elements of the list together without any separation. Consider the
    following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: The preceding filter will result in a This is a string output. You can specify
    any separator you want instead of a white space.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encoding or decoding data using filters: You can encode or decode data using
    filters as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encode your data to `base64` using the `b64encode` filter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Decode an encoded `base64` string using the `b64decode` filter:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Security management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last section in this chapter is about security management. If you tell your
    sysadmin that you want to introduce a new feature or a tool, one of the first
    questions they would ask you would be; "what security feature(s) are present with
    your tool?". We'll try to answer these questions from an Ansible perspective in
    this section. Let's look at them in greater detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible vault
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible vault is an exciting feature of Ansible that was introduced in Ansible
    version 1.5\. This allows you to have encrypted passwords as part of your source
    code. A recommended practice is to NOT have passwords (as well as any other sensitive
    information such as private keys, SSL certificates, and so on.) in plain text
    as part of your repository because anyone who checks out your repository can view
    your passwords. Ansible vault can help you to secure your confidential information
    by encrypting and decrypting them on your behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible vault supports an interactive mode in which it will ask you for the
    password, or a non-interactive mode where you will have to specify the file containing
    the password and Ansible vault will read it directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'For these examples, we will use the password `ansible`, so let''s start creating
    a hidden file called `.password` with the string `ansible` in it. To do so, let''s
    execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create an `ansible-vault` both in the interactive and non-interactive
    modes. If we want to do it in interactive mode, we will need to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Ansible will ask us for the vault password and then confirm it. Later it will
    open the default text editor (in my case **vi**) to add the content in clear.
    I have used the password `ansible` and the text is This is a password protected
    file. We can now save and close the editor and check that `ansible-vault` has
    encrypted our content, in fact if we run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'In the same way, we can invoke the `ansible-vault` command with the - `vault-password-file=VAULT_PASSWORD_FILE`
    option to specify our `.password` file. We can, for instance, edit our `secret.yaml`
    file with the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: This will open your default text editor where you'll be able to change the file
    as if it was a plain file. When you save the file, Ansible vault will perform
    the encryption before saving it, assuring the confidentiality of your content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes you need to look at the content of a file but you don''t want to
    open it in a text editor, so you usually use `cat` command. Ansible vault has
    a similar feature called `view`, so you can run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Ansible vault allows you to decrypt a file, replacing its encrypted content
    with its plain text content. To do so, you can execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we can the `cat` command on the `secret.yaml` file and the result
    is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Ansible vault also gives you the capability to encrypt files that already exist.
    This is particularly useful if you want to develop all your files on a trusted
    machine (for instance your own local machine) in a clear text to improve your
    efficiency and then encrypt all sensible files afterward. To do so, you can execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: You can now check that the `secret.yaml` file is now encrypted again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last option of the Ansible vault is very important since it''s a `rekey`
    function. This function will allow you to change the encryption key in a single
    command. You could perform the same operation with two commands (decrypt the `secret.yaml`
    file with the **old key** and then encrypt it with the **new key**) but being
    able to perform it in a single step has major advantages since the file in its
    clear-text form will not be stored on the disk at any moment of the process. To
    do so we need a file containing the new password (in our case, the file called
    `.newpassword` and containing the string `ansible2`), and you need to execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `cat` command on to the `secret.yaml` file and we will see
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: This is very different from the previous one we had.
  prefs: []
  type: TYPE_NORMAL
- en: Vaults and playbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can also use vaults with `ansible-playbook`. You''ll need to decrypt the
    file on-the-fly using a command such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'There is yet another option that allows you to decrypt files using a script,
    which can then look up some other source and decrypt the file. This can also be
    a useful option to provide more security. However, make sure that the `get_password.py`
    script has executable permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Before closing this chapter, I'd like to speak a little bit about the password
    file. This file needs to be present on the machine where you execute your playbooks,
    in a location and with permissions so that is readable by the user who is executing
    the playbook. You can create the `.password` file at startup. The '`.`' character
    in the `.password` filename is to make sure that the file is hidden by default
    when you look for it. This is not directly a security measure, but could help
    mitigate cases where an attacker does not know exactly what he is looking for.
  prefs: []
  type: TYPE_NORMAL
- en: The `.password` file content should be a password or key that is secure and
    accessible only to folks who have permission to run Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, make sure that you're not encrypting every file that's available! Ansible
    vault should be used only for important information that needs to be secure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every time you'll save an encrypted file, no matter if changes have been applied
    or not, the file will be re-encrypted and therefore will change in encrypted content.
    This will cause your SCM tool to mark the file as modified.
  prefs: []
  type: TYPE_NORMAL
- en: Encrypting user passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible vault takes care of passwords that are checked in and helps you handle
    them while running Ansible playbooks or commands. However, when Ansible plays
    are run, at times you might need your users to enter passwords. You also want
    to make sure that these passwords don''t appear in the comprehensive Ansible logs
    (the default location: `/var/log/ansible.log`) or on `stdout`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible uses `Passlib`, which is a password hashing library for Python, to
    handle encryption for prompted passwords. You can use any of the following algorithms
    supported by `Passlib`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`des_crypt`: DES Crypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bsdi_crypt`: BSDi Crypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bigcrypt`: BigCrypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`crypt16`: Crypt16'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`md5_crypt`: MD5 Crypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bcrypt`: BCrypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sha1_crypt`: SHA-1 Crypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sun_md5_crypt`: Sun MD5 Crypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sha256_crypt`: SHA-256 Crypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sha512_crypt`: SHA-512 Crypt'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`apr_md5_crypt`: Apache''s MD5-Crypt variant'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phpass`: PHPass'' Portable Hash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pbkdf2_digest`: Generic PBKDF2 Hashes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cta_pbkdf2_sha1`: Cryptacular''s PBKDF2 hash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dlitz_pbkdf2_sha1`: Dwayne Litzenberger''s PBKDF2 hash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`scram`: SCRAM Hash'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bsd_nthash`: FreeBSD''s MCF-compatible `nthash` encoding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s now see how encryption works with a variable prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, `vars_prompt` is used to prompt users for some data.
    The `vars_prompt` is not a task but is another section at the same level as the
    `tasks:` one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `name` module indicates the actual variable name where Ansible will store
    the user password, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `prompt` utility to prompt users for the password as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'We are explicitly asking Ansible to hide the password from `stdout` by using
    `private` module; this works like any other password prompt on a Unix system.
    The `private` module is accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the `md5_crypt` algorithm over here with a salt size of `7`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Moreover, Ansible will prompt for the password twice and compare both passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: Hiding passwords
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible, by default, filters output that contains the `login_password` key,
    the `password` key, and the `user:pass` format. For example, if you are passing
    a password in your module using `login_password` or the `password` key, then Ansible
    will replace your password with `VALUE_HIDDEN`. Let''s now see how you can hide
    a password using the `password` key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding `shell` task, we use the `password` key to pass passwords.
    This will allow Ansible to hide it from `stdout` and its log file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you run the preceding task in the *verbose* mode, you should not
    see your `mypass` password; instead Ansible, with `VALUE_HIDDEN`, will replace
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible will protect the strings you declared as password even if they are being
    used in a different context. For instance, if you have another variable that contains
    the string `my_password`, if you are going to print it, `HIDDEN_VALUE` will appear,
    even if that specific variable has not been declared as the password.
  prefs: []
  type: TYPE_NORMAL
- en: Using no_log
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible will hide your passwords only if you are using a specific set of keys.
    However, this might not be the case every time; moreover, you might also want
    to hide some other confidential data. The `no_log` feature of Ansible will hide
    your entire task from logging it to the `syslog` file. It will still print your
    task on `stdout` and log it to other Ansible logfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, Ansible did not support hiding tasks from
    `stdout` using `no_log`.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to prevent Ansible from logging is to set in the `ansible.cfg` file,
    in the `[defaults]` section, `log_path` with the value `/dev/null` so that all
    logs are saved in `/dev/null`, and therefore lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see how you can hide an entire task with `no_log` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'By passing `no_log`: True to your task, Ansible will prevent the entire task
    from hitting syslog.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen a very large number of Ansible features. We started
    with `local_actions` for performing operations on a machine, then we moved to
    the delegation for performing the task on a third machine. We then moved to conditionals
    and include for making playbooks more flexible. We learned about roles and how
    they can help you keep your system aligned and learned how to organize an Ansible
    repository properly, making the most of Ansible and Git. Later, we covered execution
    strategies and Jinja filters for more flexible executions.
  prefs: []
  type: TYPE_NORMAL
- en: We ended this chapter with Ansible vault and many other tips to make your Ansible
    execution safer.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at how to use Ansible to create infrastructures
    and more specifically, how to do it using the cloud providers, AWS and DigitalOcean.
  prefs: []
  type: TYPE_NORMAL
