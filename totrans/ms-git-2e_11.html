<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-206"><a id="_idTextAnchor229" class="pcalibre1 pcalibre calibre6"/>9</h1>
<h1 id="_idParaDest-207" class="calibre5"><a id="_idTextAnchor230" class="pcalibre1 pcalibre calibre6"/>Merging Changes Together</h1>
<p class="calibre3">The previous chapter, <em class="italic">Advanced Branching Techniques</em>, described how to use branches effectively for collaboration and development.</p>
<p class="calibre3">This chapter will teach you how to integrate changes from different parallel lines of development together (that is, branches) by creating a merge commit, or by reapplying changes with the rebase operation. Here, the concepts of merge and rebase are explained, including the differences between them and how they can be used. This chapter will also explain the different types of merge conflicts and teach you how to avoid them, examine them, and resolve them.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre16">
<li class="calibre15">Merging, merge strategies, and merge drivers</li>
<li class="calibre15">Cherry-picking and reverting a commit</li>
<li class="calibre15">Applying a patch and a patch series</li>
<li class="calibre15">Rebasing a branch and replaying its commits</li>
<li class="calibre15">A merge algorithm at file and contents level</li>
<li class="calibre15">Three stages in the index</li>
<li class="calibre15">Merge conflicts – how to examine and resolve them</li>
<li class="calibre15">Reusing recorded <strong class="source-inline1">[conflict]</strong> resolutions with <strong class="source-inline1">git rerere</strong></li>
<li class="calibre15">An external tool – <strong class="source-inline1">git-imerge</strong></li>
</ul>
<h1 id="_idParaDest-208" class="calibre5"><a id="_idTextAnchor231" class="pcalibre1 pcalibre calibre6"/>Methods of combining changes</h1>
<p class="calibre3">Now that you have<a id="_idIndexMarker744" class="pcalibre1 pcalibre calibre6"/> changes from other people in the remote-tracking branches (or in the series of emails), you need to combine them, perhaps also with your changes.</p>
<p class="calibre3">Alternatively, your work on a new <a id="_idIndexMarker745" class="pcalibre1 pcalibre calibre6"/>feature, created and performed on a separate topic branch, is now ready to be included in the long-lived development branch and made available to other people. Maybe you have created a bug fix and want to include it in all the long-lived graduation branches. In short, you want to join two divergent lines of development by integrating their changes.</p>
<p class="calibre3">Git provides a few different methods to combine changes and variations of these methods. One of these methods is a <em class="italic">merge</em> operation, joining two lines of development with a two-parent commit. Another way to copy introduced work from  one branch to another is via cherry-picking, which is creating a new commit with the same changeset on another line of development (this is sometimes necessary to use). Alternatively, you can reapply changes, transplanting one branch on top of another with <em class="italic">rebase</em>. We will now examine all these methods and their variants, see how they work, and when they can be used.</p>
<p class="calibre3">In many cases, Git will be able to combine changes automatically; the next section will talk about what you can do if it fails and if there are merge conflicts.</p>
<h2 id="_idParaDest-209" class="calibre7"><a id="_idTextAnchor232" class="pcalibre1 pcalibre calibre6"/>Merging branches</h2>
<p class="calibre3">The <code>git </code><code>merge</code> command:</p>
<pre class="console">
$ git switch master
$ git merge bugfix123</pre>
<p class="calibre3">Here, we first switched to a branch we want to merge into (in this example, <code>master</code>) and then provided the branch to be <a id="_idIndexMarker748" class="pcalibre1 pcalibre calibre6"/>merged (here, <code>bugfix123</code>).</p>
<h3 class="calibre9">No divergence – fast-forward and up-to-date cases</h3>
<p class="calibre3">Let’s say that you need to create a fix for a bug somebody found. Let’s assume that you have followed the recommendations of the topic branch workflow from <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>, and created a separate bugfix branch, named <code>i18n</code>.</p>
<p class="calibre3">In such cases, there is often no real <a id="_idIndexMarker749" class="pcalibre1 pcalibre calibre6"/>divergence, which means that there were no commits on the maintenance branch (the branch we are merging into), since a bugfix branch was created. Because of this, Git would, by default, simply move the branch pointer of the current branch forward:</p>
<pre class="console">
$ git switch maint
Switched to branch 'maint'
$ git merge i18n
Updating f41c546..3a0b90c
Fast-forward
  src/random.c | 2 ++
  1 file changed, 2 insertions(+)</pre>
<p class="calibre3">You have probably seen this <code>git pull</code>, when there are no changes on the branch you pull into. The fast-forward merge situation is shown in <em class="italic">Figure 9</em><em class="italic">.1</em>.</p>
<div><div><img alt="Figure 9.1 – The master branch is fast-forwarded to i18n during the merge" src="img/B21194_09_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.1 – The master branch is fast-forwarded to i18n during the merge</p>
<p class="calibre3">This case is important for the<a id="_idIndexMarker750" class="pcalibre1 pcalibre calibre6"/> centralized and the peer-to-peer workflows (described in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>), as it is the fast-forward merge that allows you to ultimately push your changes forward.</p>
<p class="calibre3">In some cases, that is not what you want. For example, note that after the fast-forward merge in <em class="italic">Figure 9</em><em class="italic">.1</em>, we have lost the information that the <code>i18n</code> topic branch. We can force the creation of a merge commit (which is described in the next section), even in a case where there are no changes to the current branch, using the <code>git merge --no-ff</code> command. The default is <code>--ff</code>; to fail instead of creating a merge commit, you can use <code>--ff-only</code> (ensuring fast-forward only).</p>
<div><div><img alt="Figure 9.2 – The master branch is up to date with respect to the i18n branch (i.e., it includes it)" src="img/B21194_09_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.2 – The master branch is up to date with respect to the i18n branch (i.e., it includes it)</p>
<p class="calibre3">There is another situation where the head (tip) of one branch is the ancestor of the other – namely, the up-to-date scenario where the branch we try to merge is already included (merged) in the <a id="_idIndexMarker751" class="pcalibre1 pcalibre calibre6"/>current branch (<em class="italic">Figure 9</em><em class="italic">.2</em>). Git doesn’t need to do anything in this case; it just informs the user about it:</p>
<pre class="console">
$ git merge i18n
Already up to date.</pre>
<h3 class="calibre9">Creating a merge commit</h3>
<p class="calibre3">When you are merging fully fledged feature branches, rather than <a id="_idIndexMarker752" class="pcalibre1 pcalibre calibre6"/>merging bugfix branches as in the previous section, the situation is usually different from the previously described fast-forward case. In the case of feature branch workflow, the development of the feature branch and integration branch would usually have diverged.</p>
<p class="calibre3">Suppose that you have decided that your work on a feature (for example, work on adding support for internationalization on the <code>i18n</code> topic branch) is complete and ready to be included in the master stable branch. In order to do so with a merge operation, you need to first check out the branch you want to merge into and then run the <code>git merge</code> command, with the branch being merged as a parameter:</p>
<pre class="console">
$ git checkout master
Switched to branch 'master'
$ git merge i18n
Merge made by the 'ort' strategy.
 src/random.c |
2 ++
 1 file changed, 2 insertions(+)</pre>
<p class="calibre3">Because the top commit on the branch you are on (and merging into) is not a direct ancestor or a direct descendant of the branch you merge in, Git has to do more work than just moving the branch pointer. In this case, Git does a merge of changes since the divergence and stores it as a <strong class="bold">merge commit</strong> on the current branch.  This commit has two parents, denoting that it was created based on more than one commit (more than one branch); the first parent is the previous tip of the current branch, and the second parent is the tip of the branch you merge in.</p>
<p class="calibre3">Note that Git does start committing the<a id="_idIndexMarker753" class="pcalibre1 pcalibre calibre6"/> result of merge if it can be done automatically, and if there are no conflicts. However, the fact that the merge succeeded at the text level doesn’t necessarily mean that the merge result is correct. You can either ask Git to not automatically commit a merge with <code>git merge --no-commit</code> to examine it first, or you can examine the merge commit and then use the <code>git commit --amend</code> command if it is incorrect (see <em class="italic">Figure 2</em><em class="italic">.4</em>).</p>
<div><div><img alt="Figure 9.3 – Three revisions used in a typical merge and the resulting merge commit" src="img/B21194_09_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.3 – Three revisions used in a typical merge and the resulting merge commit</p>
<p class="calibre3">Git creates contents of a merge commit (<code>git </code><code>merge-base</code> command).</p>
<p class="calibre3">A very important issue is that Git creates the merge commit contents based usually only on the three revisions – merged into (<em class="italic">ours</em>), merged in (<em class="italic">theirs</em>), and the common ancestor (<em class="italic">merge base</em>). It does not examine what happened on the divergent parts of the branches; this is what makes merging fast. However, because of this, Git also does not know about the cherry-picked or reverted changes on the branches being merged, which might lead to surprising results (see, for example, the section about reverting merges in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping </em><em class="italic">History Clean</em>).</p>
<h3 class="calibre9">Merge strategies and their options</h3>
<p class="calibre3">In the merge message, we <a id="_idIndexMarker755" class="pcalibre1 pcalibre calibre6"/>have seen that it was made by the <strong class="bold">‘ort’</strong> strategy (known as <strong class="bold">recursive</strong> in older Git). The <strong class="bold">merge strategy</strong> is an algorithm that Git uses to<a id="_idIndexMarker756" class="pcalibre1 pcalibre calibre6"/> compose the result of joining <a id="_idIndexMarker757" class="pcalibre1 pcalibre calibre6"/>two or more lines of development.</p>
<p class="calibre3">There are a few merge strategies that you can select to use with the <code>--strategy</code>/<code>-s</code> option to the <code>git merge</code> command. By default, Git uses the <em class="italic">ort</em> merge strategy when joining two branches and a very simple <em class="italic">octopus</em> merge strategy when joining more than two branches. You can also choose the <em class="italic">resolve</em> merge strategy if the default one fails; it is fast and safe, although less capable of merging.</p>
<p class="calibre3">The two remaining merge strategies are special-purpose algorithms. The <em class="italic">ours</em> merge strategy can be used when we want to abandon changes in the merged-in branch but keep them in the history of the merged-into branch – for example, for documentation purposes. This strategy simply repeats the current snapshot (the <em class="italic">ours</em> version) as a merge commit. Note that this merge strategy, invoked with <code>--strategy=ours</code> or <code>-s ours</code>, should be not confused with the <em class="italic">ours</em> option to the default <em class="italic">ort</em> merge strategy, <code>--strategy=ort --strategy-option=ours</code>, or just <em class="italic">-Xours</em>, which means something different.</p>
<p class="calibre3">The <em class="italic">subtree</em> merge strategy can be used for subsequent merges from an independent project into a subdirectory (subtree) in a main project. It automatically figures out where the subproject was put. This topic, and the concept of subtrees, will be described in more detail in <a href="B21194_11.xhtml#_idTextAnchor270" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>, <em class="italic">Managing Subprojects</em>.</p>
<p class="calibre3">The default <strong class="bold">ort</strong> (<strong class="bold">Ostensibly Recursive’s Twin</strong>) merge strategy, and its predecessor, the <em class="italic">recursive</em> merge strategy, are named after <a id="_idIndexMarker758" class="pcalibre1 pcalibre calibre6"/>how such a strategy deals with multiple merge bases and criss-cross merges. In the case of more than one merge base (which means that there is more than one common ancestor that can be used for a three-way merge), such a strategy creates a merge tree (conflicts and all) from the ancestors as a merge base – that is, it merges recursively. Of course, again, these common ancestors being merged can have more than one merge base.</p>
<p class="calibre3">Some strategies are customizable and have their own options. You can pass an option  to a merge algorithm with <code>-X&lt;option&gt;</code> (or <code>--strategy-option=&lt;option&gt;</code>) on the command line, or set it with the appropriate configuration variables. You will discover more about merge options in the section <em class="italic">Resolving merge conflicts</em>, when we will discuss solving merge conflicts.</p>
<h3 class="calibre9">A reminder – merge drivers</h3>
<p class="calibre3"><a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a><em class="italic">, Managing Your </em><em class="italic">Worktrees</em>, introduced git attributes – among others, <strong class="bold">merge drivers</strong>. These <em class="italic">drivers</em> are user-defined <a id="_idIndexMarker759" class="pcalibre1 pcalibre calibre6"/>and deal with merging file contents if there is a conflict, replacing the default three-way file-level merge. Merge <em class="italic">strategies</em>, in contrast, deal with DAG-level merging (and tree-level – that is, merging directories), and you can only choose from the built-in options.</p>
<h3 class="calibre9">A reminder – signing merges and merging tags</h3>
<p class="calibre3">In <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>, you learned about signing your work. While using merge to join two lines of <a id="_idIndexMarker760" class="pcalibre1 pcalibre calibre6"/>development, you can either merge a signed tag, sign a <a id="_idIndexMarker761" class="pcalibre1 pcalibre calibre6"/>merge commit, or both. Signing a merge commit is done with the <code>-S</code> / <code>--gpg-sign</code> option to use the <code>git merge</code> or <code>git commit</code> command; the latter is used if there are conflicts, or if the <code>--no-commit</code> option was used while merging.</p>
<h2 id="_idParaDest-210" class="calibre7"><a id="_idTextAnchor233" class="pcalibre1 pcalibre calibre6"/>Copying and applying a changeset</h2>
<p class="calibre3">The merging operation is about joining two lines of development (two branches), including all the changes since their divergence. This means, as described in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced Branching Techniques</em>, that if there is one commit on the less stable branch (for example, <code>master</code>) that you want to have also in a more stable branch (for example, <code>maint</code>), you cannot use the <a id="_idIndexMarker762" class="pcalibre1 pcalibre calibre6"/>merge operation. You need to create a<a id="_idIndexMarker763" class="pcalibre1 pcalibre calibre6"/> copy of such a commit. A situation such as this should be avoided (using topic branches), but it can happen, and handling it is sometimes necessary.</p>
<p class="calibre3">Sometimes, the changes that need to be applied come not from the repository (as a revision in the DAG to be copied) but in the form of a patch – that is, a unified diff or an email generated with <code>git format-patch</code> (with a patch, plus a commit message).</p>
<p class="calibre3">Git includes the <code>git am</code> tool to handle the mass application of commit-containing patches.</p>
<p class="calibre3">Both of these commands are useful on their own, but <a id="_idIndexMarker764" class="pcalibre1 pcalibre calibre6"/>understanding these<a id="_idIndexMarker765" class="pcalibre1 pcalibre calibre6"/> methods of getting changes is also useful to understand how cherry-picking and rebasing work.</p>
<h3 class="calibre9">Cherry-pick – creating a copy of a changeset</h3>
<p class="calibre3">You can create a copy of a commit (or a series of commits) with the <code>cherry-pick</code> command. Given a series of <a id="_idIndexMarker766" class="pcalibre1 pcalibre calibre6"/>commits (usually just a single commit), it applies the changes each one introduces, recording a new commit for each change.</p>
<div><div><img alt="Figure 9.4 – Cherry-picking the C4 commit from master to maint" src="img/B21194_09_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.4 – Cherry-picking the C4 commit from master to maint</p>
<p class="calibre3">An example of a cherry-pick operation is shown in <em class="italic">Figure 9</em><em class="italic">.4</em>. (Note that here the thick dotted arrow from <strong class="bold">C4</strong> to <strong class="bold">C4’</strong> denotes a copy; it is not a reference.)</p>
<p class="calibre3">The copying of changes does not mean that the snapshot (that is, the state of a project) is the same in the original (<strong class="bold">C4</strong> in <em class="italic">Figure 9</em><em class="italic">.4</em>) and in the copy (<strong class="bold">C4’</strong> in <em class="italic">Figure 9</em><em class="italic">.4</em>); the latter will include other changes while missing others. Also, while the changes will usually be the same (as they are in <em class="italic">Figure 9</em><em class="italic">.4</em>, where the difference between <strong class="bold">C3</strong> and <strong class="bold">C4</strong> and the diff between <strong class="bold">C7</strong> and <strong class="bold">C4’</strong> is the same), they can also be different – for example, if part of the changes was already present in the earlier commits.</p>
<p class="calibre3">Note that, by default, Git does not <a id="_idIndexMarker767" class="pcalibre1 pcalibre calibre6"/>save information about where the cherry-picked commit came from. You can append this information to an original commit message, as a <code>git cherry-pick -x &lt;commit&gt;</code>. This is only done for cherry-picks without conflicts. Remember that this information is only useful if you have access to the copied commit. Do not use it if you are copying commits from the private branch, as other developers won’t be able to make use of that information.</p>
<h3 class="calibre9">Revert – undoing the effect of a commit</h3>
<p class="calibre3">Sometimes, it will turn out that, even with a<a id="_idIndexMarker768" class="pcalibre1 pcalibre calibre6"/> code review, there will be some bad commits that you need to reverse (perhaps one turned out to be a not-so-good idea, or it contains bugs). If the commit is already made public, you cannot simply remove it; you need to undo its effects. This issue will be explained in detail in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping </em><em class="italic">History Clean</em>.</p>
<p class="calibre3">This “undoing of a commit” can be done by creating a commit with a reversal of changes, something like cherry-picking but applying the reversal of changes. This is done with the <code>revert</code> command (see <em class="italic">Figure 9</em><em class="italic">.5</em>).</p>
<div><div><img alt="Figure 9.5 – The effect of using ﻿'git revert master^' on a ﻿'master' branch – creating a new commit, denoted !C3, that undoes changes in ﻿the C3 commit" src="img/B21194_09_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.5 – The effect of using 'git revert master^' on a 'master' branch – creating a new commit, denoted !C3, that undoes changes in the C3 commit</p>
<p class="calibre3">The name of this operation might be misleading. If you want to revert all the changes made to the whole working area, you <a id="_idIndexMarker769" class="pcalibre1 pcalibre calibre6"/>can use <code>git reset</code> (in particular, with the <code>--hard</code> option). If you want to revert changes made to a single file, use <code>git checkout &lt;file&gt;</code> or <code>git restore &lt;file&gt;</code>. Both of these are explained in detail in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>. The <code>git revert</code> command records a new commit to reverse the effect of the earlier commit (often, a faulty one).</p>
<h3 class="calibre9">Applying a series of commits from patches</h3>
<p class="calibre3">Some collaborative workflows include<a id="_idIndexMarker770" class="pcalibre1 pcalibre calibre6"/> exchanging the changes as patches via email (or another communication medium). This workflow is often encountered in open source projects; it is often easier for a new or a sporadic contributor to create a specially crafted email (for example, with <code>git format-patch</code>) and send it to a maintainer or a mailing list, rather than setting up a public repository and sending a pull request.</p>
<p class="calibre3">You can apply a series of patches from a mailbox (in the <code>mbox</code> or <code>maildir</code> format; the latter is just a series of files) with the <code>git am</code> command. If these emails (or files) were created from the <code>git format-patch</code> output, you can use <code>git am --3way</code> to use the three-way file merge if there are conflicts. Resolving conflicts will be discussed in in the section, <em class="italic">Resolving </em><em class="italic">merge conflicts</em>.</p>
<p class="calibre3">You can find both tools to help use the patch submission process by sending a series of patches – for example, from the pull request on GitHub (e.g., the <em class="italic">GitGitGadget</em> GitHub app, or the older <em class="italic">submitGit</em> web app, to <a id="_idIndexMarker771" class="pcalibre1 pcalibre calibre6"/>submit patches from GitHub’s pull request to the Git project mailing list) – and tools that track web page patches sent to a mailing list (for example, the <em class="italic">patchwork</em> tool).</p>
<h3 class="calibre9">Cherry-picking and reverting a merge</h3>
<p class="calibre3">This is all good, but what happens if you want to<a id="_idIndexMarker772" class="pcalibre1 pcalibre calibre6"/> cherry-pick or revert a merge commit? Such <a id="_idIndexMarker773" class="pcalibre1 pcalibre calibre6"/>commits have more than one parent; thus, they have more than one change associated with them.</p>
<p class="calibre3">In this case, you have to tell Git which change you want to pick up (in the case of cherry-pick), or back out (in the case of revert) with the <code>-m &lt;parent number&gt;</code> option – for example, <code>-m1</code>.</p>
<p class="calibre3">Note that reverting a merge undoes the changes, but it does not remove the merge from the history of the project. See the section on reverting merges in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping </em><em class="italic">History Clean</em>.</p>
<h2 id="_idParaDest-211" class="calibre7"><a id="_idTextAnchor234" class="pcalibre1 pcalibre calibre6"/>Rebasing a branch</h2>
<p class="calibre3">Besides merging, Git supports an<a id="_idIndexMarker774" class="pcalibre1 pcalibre calibre6"/> additional way to integrate changes from one branch into another – namely, the <strong class="bold">rebase operation</strong>.</p>
<p class="calibre3">Like a merge, it deals with the changes since the point of divergence (at least, by default). However, while a merge creates a new commit by joining two branches, rebase takes the new commits from one branch (i.e., takes the commits since the divergence) and reapplies them on top of the other branch – see <em class="italic">Figure 9</em><em class="italic">.6</em> <a id="_idTextAnchor235" class="pcalibre1 pcalibre calibre6"/>for an example.</p>
<div><div><img alt="Figure 9.6 – The effects of the rebase operation" src="img/B21194_09_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.6 – The effects of the rebase operation</p>
<p class="calibre3">With merge, you first switch to the branch to be merged and then use the merge command to select a branch to<a id="_idIndexMarker775" class="pcalibre1 pcalibre calibre6"/> merge in. With rebase, it is a bit different. First, you select a branch to rebase (i.e., the changes to reapply) and then use the rebase command to select where to put it. In both cases, you first check out the branch to be modified, where a new commit or commits would be (a merge commit in the case of merging, and a replay of commits in the case of rebasing):</p>
<pre class="console">
$ git switch i18n
Switched to branch 'i18n'
$ git rebase master
Successfully rebased and updated refs/heads/master.</pre>
<p class="calibre3">Alternatively, you can use <code>git rebase master i18n</code> as a shortcut. In this form, you can easily see that the rebase operation takes the <code>master..i18n</code> range of revisions (this notation is explained in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>), replays it on top of <code>master</code>, and finally, points <code>i18n</code> to the replayed commits.</p>
<p class="calibre3">Note that old versions of commits don’t vanish, at least not immediately. They will be accessible via a reflog (and <code>ORIG_HEAD</code>) for a grace period. This means that it is not that hard to check how replaying<a id="_idIndexMarker776" class="pcalibre1 pcalibre calibre6"/> changed the snapshots of a project and, with a bit more effort, how changesets themselves have changed.</p>
<h3 class="calibre9">Merge versus rebase</h3>
<p class="calibre3">We have these two ways of integrating<a id="_idIndexMarker777" class="pcalibre1 pcalibre calibre6"/> changes – merge and rebase. How do they differ, and what are their advantages and disadvantages? We can see by comparing <em class="italic">Figure 9</em><em class="italic">.2</em> in the <em class="italic">Creating a merge commit</em> section with <em class="italic">Figure 9</em><em class="italic">.5</em> in the <em class="italic">Rebasing a </em><em class="italic">branch</em> section.</p>
<p class="calibre3">First, merge doesn’t change history (see <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>). It creates and adds a new commit (unless it is a fast-forward merge; then, it just advances the branch head), but the commits that were reachable from the branch remain reachable. This is not the case with rebase. Commits get rewritten, old versions are forgotten, and the DAG of revisions changes. What was once reachable might no longer be reachable. This means that you should not rebase published branches.</p>
<p class="calibre3">Secondly, merge is a one-step operation, with one place to resolve merge conflicts. The rebase operation is multi-step; the steps are smaller (if you follow the recommended practices and keep changes small – see <a href="B21194_15.xhtml#_idTextAnchor371" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 15</em></a>, <em class="italic">Git Best Practices</em>), but there are more of them.</p>
<p class="calibre3">Linked to this is the fact that the merge result is based (usually) on three commits only, and that it does not take into account what happens on either of the branches that are integrated step by step; only the endpoints matter. Conversely, rebase reapplies each commit individually, so the road to the final result matters here.</p>
<p class="calibre3">Third, the history looks different; you get a simple linear history with rebase, while using the merge operation leads to a complex history, with the lines of development forking and joining. The history is simpler for rebase, but you lose the information that the changes were developed on a separate branch and that they were grouped together, which you get with merge (at least with <code>--no-ff</code>). There is even the <code>git-resurrect</code> script in the Git contrib tools that uses the information stored in the commit messages of the merge commits to resurrect the old, long-deleted feature branches.</p>
<p class="calibre3">The last difference is that, because of the underlying<a id="_idIndexMarker778" class="pcalibre1 pcalibre calibre6"/> mechanism, rebase does not, by default, preserve merge commits while reapplying them. You need to explicitly use the <code>--rebase-merges</code> option. The merge operation does not change the history, so merge commits are left as they are.</p>
<h3 class="calibre9">Rebase backends</h3>
<p class="calibre3">The previous section described two <a id="_idIndexMarker779" class="pcalibre1 pcalibre calibre6"/>mechanisms to copy or apply changes – the <code>git cherry-pick</code> command and the pipeline from <code>git format-patch</code> to <code>git am --3way</code>. Either of them can be used by <code>git rebase</code> to reapply commits.</p>
<p class="calibre3">The default is to use the merge-based workflow, as if <code>git rebase</code> was called with the <code>--merge</code> option. The default <code>'ort'</code> merge strategy allows rebase to be aware of the renames on the upstream side (where we put the replayed commits). With this option, you can also select a specific merge strategy and pass options to it.</p>
<p class="calibre3">To switch to a patch-based strategy, use <code>git rebase --apply</code>. In this case, you can pass some options to <code>git am</code> that does the actual replaying of changesets.</p>
<p class="calibre3">These options will be described later when we discuss conflicts.</p>
<p class="calibre3">There is also an interactive rebase with its own set of options. This is one of the main tools in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>. It can be used to execute tests after each replayed commit to check that the replay is correct.</p>
<h3 class="calibre9">Advanced rebasing techniques</h3>
<p class="calibre3">You can also have your rebase<a id="_idIndexMarker780" class="pcalibre1 pcalibre calibre6"/> operation replay on something other than the target branch of the rebase with <code>--</code><code>onto &lt;newbase&gt;</code>.</p>
<p class="calibre3">Let’s assume that your <code>featureA</code> topic branch is based on the unstable development branch named <code>next</code>, as it is dependent on <a id="_idIndexMarker781" class="pcalibre1 pcalibre calibre6"/>some feature that is not yet ready and not yet present in the stable branch (master). If the functionality on which <code>featureA</code> depends is deemed stable and merged into master, you would want to move this branch from being forked from <code>next</code> to being forked from <code>master</code>. Alternatively, perhaps you started the <code>server</code> branch from the related <code>client</code> branch, but you want to make it more obvious that they are independent.</p>
<p class="calibre3">You can do this with <code>git rebase --onto master next featureA</code> in the first case, and <code>git rebase --onto master server client</code> in the second one (which is shown in <em class="italic">Figure 9</em><em class="italic">.7</em>).</p>
<div><div><img alt="Figure 9.7 – The rebasing branch, moving it from one branch to another" src="img/B21194_09_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.7 – The rebasing branch, moving it from one branch to another</p>
<p class="calibre3">Alternatively, perhaps you want to rebase only a part of the branch. You can do this with <code>git rebase --interactive</code>, but you can also use <code>git rebase --onto &lt;new base&gt; &lt;starting point&gt; &lt;branch&gt;</code>. You can even choose to rebase the whole branch (usually, an orphan branch) with the <code>--root</code> option. In this case, you would replay the whole branch and not just a selected subset of it.</p>
<p class="calibre3">You can also keep the base commit as is <a id="_idIndexMarker782" class="pcalibre1 pcalibre calibre6"/>with <code>--keep-base</code>, instead of following the upstream. With the <code>--fork-point</code> option, you can make Git find a better common ancestor using reflog (to find where the branch was created) if it is possible.</p>
<h2 id="_idParaDest-212" class="calibre7"><a id="_idTextAnchor236" class="pcalibre1 pcalibre calibre6"/>Squash merge</h2>
<p class="calibre3">If the changes made on a branch are not worth<a id="_idIndexMarker783" class="pcalibre1 pcalibre calibre6"/> preserving in detail and only their result is, you can use <strong class="bold">squash merge</strong> as a way to integrate them as a <a id="_idIndexMarker784" class="pcalibre1 pcalibre calibre6"/>single commit. This can happen if the branch you want to integrate is full of temporary, work-in-progress commits.</p>
<p class="calibre3">With <code>git merge --squash</code>, Git will produce the same result with respect to the working tree (and to the staging area) as if a real merge happened, but it will not perform the commit (the <code>--commit</code> option to <code>git merge</code> is incompatible with <code>--squash</code>). This is done in such a way that the next git commit will create an ordinary commit, not a merge commit. See <em class="italic">Figure 9</em><em class="italic">.8</em> for a comparison of the merge types.</p>
<div><div><img alt="Figure 9.8 – An ordinary merge versus a squash merge for the same set of branches" src="img/B21194_09_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 9.8 – An ordinary merge versus a squash merge for the same set of branches</p>
<p class="calibre3">By default, the commit message of a <a id="_idIndexMarker785" class="pcalibre1 pcalibre calibre6"/> squashing commit begins with <code>git log master..i18n</code>. However, note<a id="_idIndexMarker786" class="pcalibre1 pcalibre calibre6"/> that this technique should be used only if we intend to drop (delete) the “merged” branch. This is because Git might have trouble merging any further development on the squash-merged branch, as the graph of revisions does not indicate that the commit was the result of a merge.</p>
<p class="calibre3">The alternative is to use the <code>squash</code> command of an interactive rebase.</p>
<h1 id="_idParaDest-213" class="calibre5"><a id="_idTextAnchor237" class="pcalibre1 pcalibre calibre6"/>Resolving merge conflicts</h1>
<p class="calibre3">Merging in Git is typically fairly easy. Since <a id="_idIndexMarker787" class="pcalibre1 pcalibre calibre6"/>Git stores and has access to a full graph of revisions, it can automatically find where the branches diverged and merge only those divergent parts. This works even in the case of repeated merges, so you can keep a very long-lived branch up to date by repeatedly merging into it or rebasing it on top of new changes.</p>
<p class="calibre3">However, it is not always possible to<a id="_idIndexMarker788" class="pcalibre1 pcalibre calibre6"/> automatically combine changes. There are problems that Git cannot solve because, for example, there were different changes to the same area of a file on different branches. These problems are called <strong class="bold">merge conflicts</strong>. Similarly, there can be problems while reapplying changes, although you would still get merge conflicts in case of problems.</p>
<h2 id="_idParaDest-214" class="calibre7"><a id="_idTextAnchor238" class="pcalibre1 pcalibre calibre6"/>The three-way merge</h2>
<p class="calibre3">Unlike some other version control systems, Git does not try to be overly clever about merge conflict resolutions and try to <a id="_idIndexMarker789" class="pcalibre1 pcalibre calibre6"/>solve them all automatically. Git’s philosophy is to be smart about determining the cases when a merge can be easily done<a id="_idIndexMarker790" class="pcalibre1 pcalibre calibre6"/> automatically (for example, taking renames into account) and, if automatic resolution is not possible, to not be overly clever about trying to resolve it. It is better to bail out and ask users to resolve a merge, perhaps unnecessary with a smart algorithm, than to automatically create an incorrect one.</p>
<p class="calibre3">Git uses the <strong class="bold">three-way merge algorithm</strong> to come up with the result of the merge, comparing the common ancestors (<em class="italic">base</em>), the side merged in (<em class="italic">theirs</em>), and the side merged into (<em class="italic">ours</em>). This algorithm is very simple, at least at the tree level – that is, the granularity level of files. The following table explains the rules of the algorithm:</p>
<table class="no-table-style" id="table001-4">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">ancestor (base)</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">HEAD (ours)</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">branch (theirs)</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">result</strong></p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3">B</p>
</td>
<td class="no-table-style2">
<p class="calibre3">C</p>
</td>
<td class="no-table-style2">
<p class="calibre3">merge</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 9.1 – How a three-way merge algorithm works</p>
<p class="calibre3">As shown in the preceding table, the rules for the trivial tree-level three-way merges are as follows:</p>
<ul class="calibre16">
<li class="calibre15">If only one side changes a file, take the changed version</li>
<li class="calibre15">If both sides have the same changes, take the changed version</li>
<li class="calibre15">If one side has a different change from the other, there is a merge conflict at the content level</li>
</ul>
<p class="calibre3">It is a bit more complicated if there is more<a id="_idIndexMarker791" class="pcalibre1 pcalibre calibre6"/> than one ancestor, or if a file is not present in all the versions, but usually, it is enough to just know and understand these rules.</p>
<p class="calibre3">If one side changes a file differently from<a id="_idIndexMarker792" class="pcalibre1 pcalibre calibre6"/> the other (where the type of the change counts – for example, renaming a file on one branch doesn’t conflict with the changing contents of the file on the other branch), Git tries to merge the files at the content level, using the provided <strong class="bold">merge driver</strong> if it is defined, and the content-level three-way merge otherwise (for text files).</p>
<p class="calibre3">The three-way file merge examines whether the changes touch different parts of a file (different lines are changed, and these changes are well separated by more than three lines (the context size) away from each other). If these changes are<a id="_idIndexMarker793" class="pcalibre1 pcalibre calibre6"/> present in different parts of the file, Git resolves the merge automatically (and tells us which files are <strong class="bold">auto-merged</strong>).</p>
<p class="calibre3">However, if you change the same part of the same file differently in the two branches that you’re merging together, Git won’t be able to merge them cleanly:</p>
<pre class="console">
$ git merge i18n
Auto-merging src/rand.c
CONFLICT (content): Merge conflict in src/rand.c
Automatic merge failed; fix conflicts and then commit the result.</pre>
<p class="calibre3">This problem (a <strong class="bold">merge conflict</strong>) is then left for the user to resolve.</p>
<h2 id="_idParaDest-215" class="calibre7"><a id="_idTextAnchor239" class="pcalibre1 pcalibre calibre6"/>Examining failed merges</h2>
<p class="calibre3">If Git is unable to automatically resolve a<a id="_idIndexMarker794" class="pcalibre1 pcalibre calibre6"/> merge (or if you have passed the <code>--no-commit</code> option to the <code>git merge</code> command), it will not create a merge commit. It will pause the process, waiting<a id="_idIndexMarker795" class="pcalibre1 pcalibre calibre6"/> for you to resolve the conflict.</p>
<p class="calibre3">You can then always abort the merging process with <code>git </code><code>merge --abort</code>.</p>
<h3 class="calibre9">Conflict markers in the working tree</h3>
<p class="calibre3">If you want to see which files are <a id="_idIndexMarker796" class="pcalibre1 pcalibre calibre6"/>still unmerged at any point after a merge conflict,  you can run <code>git status</code>:</p>
<pre class="console">
$ git status
On branch master
You have unmerged paths.
  (fix conflicts and run "git commit")
  (use "git merge --abort" to abort the merge)
Unmerged paths:
  (use "git add &lt;file&gt;..." to mark resolution)
        both modified:
src/rand.c</pre>
<p class="calibre3">Anything that has not been resolved is listed as unmerged. In the case of content conflicts, Git uses standard conflict markers, putting them around the place of conflict, with the <em class="italic">ours</em> and <em class="italic">theirs</em> versions of the conflicted area in question. Your file will contain a section that will look somewhat like the following:</p>
<pre class="source-code">
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:src/rand.c
fprintf(stderr, "Usage: %s &lt;number&gt; [&lt;count&gt;<strong class="bold1">]</strong>\n", argv[0]);
=======
fprintf(stderr, <strong class="bold1">_(</strong>"Usage: %s &lt;number&gt; [&lt;count&gt;\n"<strong class="bold1">)</strong>, argv[0]);
&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n:src/rand.c</pre>
<p class="calibre3">This means that the <em class="italic">ours</em> version on the current branch (<code>HEAD</code>) in the <code>src/rand.c</code> file is there at the top of this block, between the <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> and <code>=======</code> markers, while the <em class="italic">theirs</em> version on the <code>i18n</code> branch being merged (also from <code>src/rand.c</code>) is there at the bottom, between the <code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code> markers.</p>
<p class="calibre3">You need to replace this whole block by the resolution of the merge, either by choosing one side (and deleting the rest) or combining both changes, for example:</p>
<pre class="source-code">
fprintf(stderr, <strong class="bold1">_(</strong>"Usage: %s &lt;number&gt; [&lt;count&gt;<strong class="bold1">]</strong>\n"<strong class="bold1">)</strong>, argv[0]);</pre>
<p class="calibre3">To help you avoid committing unresolved changes by mistake, Git by default checks whether committed changes include something that looks like conflict markers, refusing to create a merge commit if it finds them. You can force this check to be skipped with the <code>--</code><code>no-verify</code> option.</p>
<p class="calibre3">If you need to examine a common ancestor version to resolve a conflict, you can switch to <code>diff3-</code> or <code>zdiff3-</code>like conflict markers, which have an additional block, separated by <strong class="bold">|||||||</strong>. This new block shows the common ancestor (<em class="italic">ours</em>) ver<a id="_idTextAnchor240" class="pcalibre1 pcalibre calibre6"/>sion:</p>
<pre class="source-code">
&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:src/rand.c
fprintf(stderr, "Usage: %s &lt;number&gt; [&lt;count&gt;<strong class="bold1">]</strong>\n", argv[0]);
|||||||
fprintf(stderr, "Usage: %s &lt;number&gt; [&lt;count&gt;\n", argv[0]);
=======
fprintf(stderr, <strong class="bold1">_(</strong>"Usage: %s &lt;number&gt; [&lt;count&gt;\n"<strong class="bold1">)</strong>, argv[0]);
&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n:src/rand.c</pre>
<p class="calibre3">You can replace merge conflict markers<a id="_idIndexMarker797" class="pcalibre1 pcalibre calibre6"/> individually on a file-per-file basis by rechecking the file again, using the following command:</p>
<pre class="console">
$ git checkout --conflict=diff3 src/rand.c</pre>
<p class="calibre3">If you prefer to use this format all the time, you can set it as the default for future merge conflicts by setting <code>merge.conflictStyle</code> to <code>diff3</code> or <code>zdiff3</code> (from the default of <code>merge</code>).</p>
<h3 class="calibre9">Three stages in the index</h3>
<p class="calibre3">How does Git keep track of which files are<a id="_idIndexMarker798" class="pcalibre1 pcalibre calibre6"/> merged and which are not? Conflict markers in the working directory files would not be enough. Sometimes, there are legitimate contents that look like commit markers (for example, a file that contains an example of a merge conflict or files in the AsciiDoc format), and there are more conflict types than <strong class="bold">CONFLICT(content)</strong>. How does Git, for example, represent the case where both sides renamed the file but in a different way, or where one side changed the file and the other side removed it?</p>
<p class="calibre3">It turns out that it is another use for the staging area of the commit (a merge commit in this case), which is also known as the index. In the case of conflicts, Git stores all of the conflicted file versions in the index under stages; each stage has a number associated with it.</p>
<ul class="calibre16">
<li class="calibre15">Stage 1 is the common ancestor (<em class="italic">base</em>)</li>
<li class="calibre15">Stage 2 is the merged-into version from <strong class="source-inline1">HEAD</strong> – that is, the current branch (<em class="italic">ours</em>)</li>
<li class="calibre15">Stage 3 is from <strong class="source-inline1">MERGE_HEAD</strong>, the version you’re merging in (<em class="italic">theirs</em>)</li>
</ul>
<p class="calibre3">You can see these stages for the unmerged files with the low-level (plumbing) command, <code>git ls-files --unmerged</code> (or for all the files with <code>git </code><code>ls-files --stage</code>):</p>
<pre class="console">
$ git ls-files --unmerged
100755 ac51efdc3df4f4fd318d1a02ad05331d8e2c9111 1
src/rand.c
100755 36c06c8752c78d2aaf89571132f3bf7841a7b5c3 2
src/rand.c
100755 e85207e04dfdd50b0a1e9febbc67fd837c44a1cd 3
src/rand.c</pre>
<p class="calibre3">You can refer to each version with the <code>:&lt;stage number&gt;:&lt;pathname&gt;</code> specifier. For example, if you want to view a <a id="_idIndexMarker799" class="pcalibre1 pcalibre calibre6"/>common ancestor version of <code>src/rand.c</code>, you can use the following:</p>
<pre class="console">
$ git show :1:src/rand.c</pre>
<p class="calibre3">If there is no conflict, the file is in stage 0 of the index.</p>
<h3 class="calibre9">Examining differences – the combined diff format</h3>
<p class="calibre3">You can use the <code>status</code> command to find <a id="_idIndexMarker800" class="pcalibre1 pcalibre calibre6"/>which files are unmerged, and conflict markers do a good job of showing conflicts. But how do we see only conflicts before we work on them, and how do we see how they were resolved? The answer is <code>git diff</code>.</p>
<p class="calibre3">One thing to remember is that for merges, even <a id="_idIndexMarker801" class="pcalibre1 pcalibre calibre6"/>merges in progress, Git will show the so-called <strong class="bold">combined diff</strong> format. It looks like the following (for a conflicted file during  a merge):</p>
<pre class="console">
$ git diff
diff --cc src/rand.c
index 293c8fc,4b87d29..0000000
--- a/src/rand.c
+++ b/src/rand.c
@@@ -14,16 -14,13 +14,26 @@@ int main(int argc, char *argv[]
return EXIT_FAILURE;
}
++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:src/rand.c
 +fprintf(stderr, "Usage: %s &lt;number&gt; [&lt;count&gt;]\n", argv[0]);
++=======
+ fprintf(stderr, _("Usage: %s &lt;number&gt; [&lt;count&gt;\n"), argv[0]);
++&gt;&gt;&gt;&gt;&gt;&gt;&gt; i18n:src/rand.c</pre>
<p class="calibre3">You can see a few differences from the ordinary unified diff format described in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>. First, this uses <code>diff --cc</code> in the header to denote that it uses the compact combined format (it would use <code>diff --combined</code> instead if you used the <code>git diff -c</code> command). The extended header lines, such as <code>index 293c8fc,4b87d29..0000000</code>, take into account that there is more than one source version. The chunk header, <code>@@@ -14,16 -14,13 +14,26 @@@</code>, is modified (and is different from the one for the ordinary patch) to prevent people from trying to apply a combined diff as a unified diff – for example, with the <code>patch -</code><code>p1</code> command.</p>
<p class="calibre3">Each line of the <code>diff</code> command is prefixed by two or <a id="_idIndexMarker802" class="pcalibre1 pcalibre calibre6"/>more characters (two in the most common cases of merging two branches); the first character informs us about the state of the line in the first preimage (<em class="italic">ours</em>) as compared to the result, the second character informs us about the other preimage (<em class="italic">theirs</em>), and so on. For example, <code>++</code>  means that the line was not present in either of the versions being merged (here, in this example, you can find it on the line with the conflict marker).</p>
<p class="calibre3">Examining differences is even more useful for checking the resolution of a merge conflict.</p>
<p class="calibre3">To compare the result (i.e., the current state of the working directory) with the version from the current branch (i.e., merged into) – that is, the <em class="italic">ours</em> version – you can use <code>git diff –ours</code>. This also applies to the version being merged (<em class="italic">theirs</em>) and the common ancestor  version (<em class="italic">base</em>).</p>
<h3 class="calibre9">How did we get there – git log --merge</h3>
<p class="calibre3">Sometimes, we need more context to<a id="_idIndexMarker803" class="pcalibre1 pcalibre calibre6"/> decide which version to choose or to resolve a conflict. One such technique is reviewing a little bit of history, recalling why the two lines of development that are merged touched the same area of code.</p>
<p class="calibre3">To get the full list of divergent commits that were included in either branch, we can use the triple-dot syntax that you learned about in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>, adding the <code>--left-right</code> option to make Git show which side the given commit belongs to:</p>
<pre class="console">
$ git log --oneline --left-right HEAD...MERGE_HEAD</pre>
<p class="calibre3">We can further simplify this and limit the output to only those commits that touched at least one of the conflicted files, with a <code>--merge</code> option to <code>git log</code>, for example:</p>
<pre class="console">
$ git log --oneline --left-right --merge</pre>
<p class="calibre3">This can be helpful in quickly giving you the context you need to understand why something conflicts and how to intelligently resolve it.</p>
<h2 id="_idParaDest-216" class="calibre7"><a id="_idTextAnchor241" class="pcalibre1 pcalibre calibre6"/>Avoiding merge conflicts</h2>
<p class="calibre3">While Git prefers to fail to auto-merge clearly, rather than <a id="_idIndexMarker804" class="pcalibre1 pcalibre calibre6"/>trying elaborate merge algorithms, there are a few tools and options that you can use to help Git avoid merge conflicts.</p>
<h3 class="calibre9">Useful merge options</h3>
<p class="calibre3">One of the problems while merging <a id="_idIndexMarker805" class="pcalibre1 pcalibre calibre6"/>branches might be that they use different end-of-line normalization or clean/smudge filters (see <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>). This might happen when one branch added such a configuration (e.g., changing a git attributes file) and the other did not. In the case of end-of-line character configuration changes, you would get a lot of spurious changes, where lines differ only in the EOL (end-of-line) characters. In both cases, while resolving a three-way merge, you can make Git run a virtual checkout and check-in of all three stages of a file. This is done by passing the <code>renormalize</code> option to the <code>'ort'</code> merge strategy (<code>git merge -Xrenormalize</code>). This would, as the name suggests, normalize end-of-line characters, making them the same for all stages.</p>
<p class="calibre3">Changing how end of line is defined can contribute to whitespace-related conflicts. It’s pretty easy to tell that this is the case when looking at the conflict, as every line is removed on one side and added again on the other, and <code>git diff --ignore-whitespace</code> shows a more manageable conflict (or even a conflict that is resolved). If you see that you have a lot of whitespace issues in a merge, you can abort and redo it, this time with <code>-Xignore-all-space</code>, <code>-Xignore-space-change</code>, <code>-Xignore-space-at-eol</code>, or <code>-Xignore-cr-at-eol</code>.</p>
<p class="calibre3">Note that whitespace changes mixed with other changes to a line are not ignored.</p>
<p class="calibre3">Sometimes, mis-merges occur due to unimportant matching lines (for example, braces from distinct functions). You can make Git spend more time minimizing differences by selecting <code>patience</code>, a <code>histogram</code>, or a <code>minimal</code> diff algorithm with, <code>-Xdiff-algorithm=patience</code>, and so on.</p>
<p class="calibre3">If the problem is mis-detected renamed files, you can adjust the rename threshold with <code>-Xfind-renames=&lt;n&gt;</code>.</p>
<h3 class="calibre9">Rerere – reuse recorded resolutions</h3>
<p class="calibre3">The <strong class="bold">rerere</strong> (<strong class="bold">reuse recorded resolutions</strong>) functionality is a bit of a hidden feature. As the name of the feature implies, it makes Git<a id="_idIndexMarker806" class="pcalibre1 pcalibre calibre6"/> remember how each conflict was resolved chunk by chunk, so that the next time Git sees the <a id="_idIndexMarker807" class="pcalibre1 pcalibre calibre6"/>same conflict, it will be able to resolve it automatically. However, note that Git will stop at resolving conflicts and does not automatically commit the said rerere-based resolution, even if it resolves it cleanly (if it is superficially correct).</p>
<p class="calibre3">Such a functionality is useful in many scenarios. One example is a situation when you want a long-lived (i.e., long development) branch to merge cleanly at the end of its cycle, but you do not want to create intermediate merge commits. In this<a id="_idIndexMarker808" class="pcalibre1 pcalibre calibre6"/> situation, you can do <strong class="bold">trial merges</strong> (merge, and then delete merge), saving information about how merge conflicts were resolved to the rerere cache. With this technique, the final merge should be easy, as most of it will be cleanly resolved from the resolutions recorded earlier.</p>
<p class="calibre3">Another situation in which you can make use of the rerere cache is when you merge a bunch of topic branches into a testable permanent branch. If the integration test for a branch fails, you want to be able to rewind the failed branch but don’t want to lose the work spent on resolving a merge.</p>
<p class="calibre3">Alternatively, perhaps you have decided that you would rather use rebase than merge. The rerere mechanism allows us to translate the merge resolution into the rebase resolution.</p>
<p class="calibre3">To enable this functionality, simply set <code>rerere.enabled</code> to <code>true</code>, or create the <code>.git/ </code><code>rr-cache</code> file.</p>
<h2 id="_idParaDest-217" class="calibre7"><a id="_idTextAnchor242" class="pcalibre1 pcalibre calibre6"/>Dealing with merge conflicts</h2>
<p class="calibre3">Let’s assume that Git was not able to<a id="_idIndexMarker809" class="pcalibre1 pcalibre calibre6"/> auto-merge cleanly and that there are merge conflicts that you need to resolve to be able to create a new merge commit. What are your options?</p>
<h3 class="calibre9">Aborting a merge</h3>
<p class="calibre3">First, let’s cover how to get out of this situation. If <a id="_idIndexMarker810" class="pcalibre1 pcalibre calibre6"/>you weren’t perhaps prepared for conflicts or you don’t know enough about how to resolve them, you can simply back out from the merge you started with <code>git </code><code>merge --abort</code>.</p>
<p class="calibre3">This command tries to reset to the state before you started a merge. It might be not able to do this if you did not start from a clean state. Therefore, it is better to stash away changes, if there are any, before performing a merge operation (which you can do with <code>--autostash</code>, or the <code>merge.autoStash</code>/<code>rebase.autoStash</code> configuration options).</p>
<h3 class="calibre9">Selecting the ours or theirs version</h3>
<p class="calibre3">Sometimes, it is enough to choose one version in<a id="_idIndexMarker811" class="pcalibre1 pcalibre calibre6"/> the case of conflicts. If you want to resolve all the conflicts this way, forcing all the chunks to resolve in favor of <em class="italic">ours</em> or <em class="italic">theirs</em> version, you can use the <code>-Xours</code> or <code>-Xtheirs</code> merge strategy option, respectively. Note that <code>-Xours</code> (the <code>--strategy=ours</code> (the <strong class="bold">merge strategy</strong>); the latter creates a merge commit where the project state is the same as the <em class="italic">ours</em> version, instead of taking the <em class="italic">ours</em> version only for conflicted files.</p>
<p class="calibre3">If you want to do this only for selected files, you can again check out the file with the <em class="italic">ours</em> or <em class="italic">theirs</em> version with <code>git checkout --ours</code> or <code>git checkout--theirs</code>, respectively. Note that during the rebase, the <em class="italic">ours</em> and <em class="italic">theirs</em> version may appear to be swapped.</p>
<p class="calibre3">You can examine the <em class="italic">base</em>, <em class="italic">ours</em>, or <em class="italic">theirs</em> version with <code>git show :1:file</code>, <code>git show:2:file</code>, or <code>git show:3:file</code>, respectively, as described earlier.</p>
<h3 class="calibre9">Scriptable fixes – manual file remerging</h3>
<p class="calibre3">There are types of changes that Git can’t handle <a id="_idIndexMarker812" class="pcalibre1 pcalibre calibre6"/>automatically, but they are scriptable fixes. The merge can be done automatically, or at least is much easier, if we transform the <em class="italic">ours</em>, <em class="italic">theirs</em>, or <em class="italic">base</em> version first. Renormalization after changing how the file is checked out and stored in the repository (i.e., eol and clean/smudge filters) and handling the whitespace change are built-in options. Another example, but without built-in support, is changing the encoding of a file or another scriptable set of changes, such as renaming variables.</p>
<p class="calibre3">To perform a scripted merge, you first need to extract a copy of each of these versions of the conflicted file, which can be done with the <code>git show</code> command and with <code>:&lt;stage&gt;:&lt;file&gt;</code>:</p>
<pre class="console">
$ git show :1:src/rand.c &gt;src/rand.common.c
$ git show :2:src/rand.c &gt;src/rand.ours.c
$ git show :3:src/rand.c &gt;src/rand.theirs.c</pre>
<p class="calibre3">Now that you have in the working area <a id="_idIndexMarker813" class="pcalibre1 pcalibre calibre6"/>the contents of all three stages of the files, you can fix each version individually – for example, with <code>dos2unix</code> or <code>iconv</code>. You can then remerge the contents of the file with the following command:</p>
<pre class="console">
$ git merge-file -p \
  rand.ours.c rand.common.c rand.theirs.c &gt;rand.c</pre>
<h3 class="calibre9">Using graphical merge tools</h3>
<p class="calibre3">If you want to use a graphical tool to help you resolve<a id="_idIndexMarker814" class="pcalibre1 pcalibre calibre6"/> merge conflicts, you can run <code>git mergetool</code>, which fires up a visual merge tool and guides the invoked tool through all the merge conflicts.</p>
<p class="calibre3">It has a wide set of preconfigured support for various graphical merge helpers. You can configure which tool you want to use with <code>merge.tool</code>. If you don’t do this, Git will try all the possible tools in the sequence, which depends on the operating system and the desktop environment.</p>
<p class="calibre3">You can also configure a setup for your own tool.</p>
<h3 class="calibre9">Marking files as resolved and finalizing merges</h3>
<p class="calibre3">As described earlier, if there is a merge <a id="_idIndexMarker815" class="pcalibre1 pcalibre calibre6"/>conflict for a file, it will have three stages in the index. To mark a file as resolved, you need to put the contents of a file into stage 0. This can be done by<a id="_idIndexMarker816" class="pcalibre1 pcalibre calibre6"/> simply running <code>git add &lt;file&gt;</code> (running <code>git status</code> will give you this hint).</p>
<p class="calibre3">When all the conflicts are resolved, you need to simply run <code>git commit</code> to finalize the merge commit (or you can skip marking each file individually as resolved and just run <code>git commit -a</code>). The default commit message for merge summarizes what we merge, including a list of the conflicts, if any were present. You can make Git add a shortlog of the merged-in branches with the <code>--log</code> option for a single merge, or set it up permanently with the <code>merge.log</code> configuration variable.</p>
<h3 class="calibre9">Resolving rebase conflicts</h3>
<p class="calibre3">When there is a problem with applying a patch or a<a id="_idIndexMarker817" class="pcalibre1 pcalibre calibre6"/> patch series, cherry-picking or reverting a commit, or rebasing a branch, Git will fall back to using the three-way merge algorithm. How to resolve such conflicts is described in the earlier sections.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Note that when using merging strategies (the default), for technical reasons, <em class="italic">ours</em> is the so-far rebased series – that is, the branch being integrated – while <em class="italic">theirs</em> is the working branch (the branch rebased onto).</p>
<p class="calibre3">However, for some of these methods, such as rebase, applying a mailbox (<code>git am</code>), or cherry-picking a series of commits, that are<a id="_idIndexMarker818" class="pcalibre1 pcalibre calibre6"/> done stage by stage (a sequencer operation), there are other issues – namely, what to do if there is a conflict during such a stage.</p>
<p class="calibre3">You have three options:</p>
<ul class="calibre16">
<li class="calibre15">You can resolve the conflict and continue the operation with the <strong class="source-inline1">--continue</strong> parameter (or, in the case of <strong class="source-inline1">git am</strong>, also <strong class="source-inline1">--resolved</strong>)</li>
<li class="calibre15">You can abort the whole operation and reset <strong class="source-inline1">HEAD</strong> to the original branch with <strong class="source-inline1">--abort</strong></li>
<li class="calibre15">You can use <strong class="source-inline1">--skip</strong> to drop a revision, perhaps because the commit is already present in the upstream and we can drop it during replaying</li>
</ul>
<h3 class="calibre9">git-imerge – an incremental merge and rebase for git</h3>
<p class="calibre3">Both rebase and merge have their disadvantages. With <a id="_idIndexMarker819" class="pcalibre1 pcalibre calibre6"/>merge, you need to resolve one big conflict (although using test merges and rerere to keep up-to-date proposed resolutions could help with this) in an all-or-nothing fashion. There is almost no way to save partially a done merge or to test it; <code>git stash</code> can help, but it might be an inadequate solution.</p>
<p class="calibre3">Rebase, conversely, is done in a step-by-step fashion, but it is not ideal for collaboration; you should not rebase published parts of the history of the project. You can interrupt a rebase, but it leaves you in a strange state (on an anonymous branch).</p>
<p class="calibre3">That’s why the <code>git imerge</code> third-party tool was created. It presents conflicts pair-wise in small steps. It records all the intermediate merges in such a way that they can be shared, so one person can start merging and the other can finish it. The final resolution can be stored as an ordinary merge, an ordinary rebase, or a rebase with history.</p>
<h1 id="_idParaDest-218" class="calibre5"><a id="_idTextAnchor243" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter has shown us how to effectively join two lines of development together, combining commits they gathered since their divergence.</p>
<p class="calibre3">First, we got to know various methods of combining changes – merge, cherry-pick, and rebase. This part focused on explaining how these functionalities work at higher levels – at the level of the DAG of revisions. You learned how merge and rebase work and what the difference is between them. Some of the more interesting uses of rebase, such as transplanting a topic branch from one long-lived branch to another, were also shown.</p>
<p class="calibre3">Then, you learned what to do if Git is not able to automatically combine changes – that is, what can be done in the presence of a merge conflict. The important part of this process is to understand how the three-way merge algorithm works, as well as how the index and the working area are affected if there are conflicts. You now know how to examine failed merges, examine proposed resolutions, avoid conflicts, and finally, resolve them and mark them as resolved.</p>
<p class="calibre3">The next chapter, <em class="italic">Keeping History Clean</em>, will explain why we might want to rewrite history to keep it clean (and what that means). One of the tools to rewrite history is an interactive rebase, a close cousin of an ordinary rebase operation described in this chapter. You will learn various methods to rewrite commits: how to reorder them, how to split them if they are too large, how to squash the fixing commit with the commit it corrects, and how to remove a file from history. You will discover what you can do if you cannot rewrite history (understanding why rewriting published history is bad) but you still need to correct it, with <code>git replace</code> and <code>git notes</code> commands. We will also discuss other applications of these mechanisms.</p>
<h1 id="_idParaDest-219" class="calibre5"><a id="_idTextAnchor244" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">What are the advantages and disadvantages of using merge to integrate changes?</li>
<li class="calibre15">What are the advantages and disadvantages of using rebase to integrate changes?</li>
<li class="calibre15">How do we avoid resolving similar conflicts again and again during a merge or rebase?</li>
<li class="calibre15">How can we discover whether we are in the middle of merge or rebase, and remind ourselves on how to resolve conflict or abort an operation?</li>
</ol>
<h1 id="_idParaDest-220" class="calibre5"><a id="_idTextAnchor245" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li class="calibre15">With merge, you do the integration in a single step (which can be an advantage or disadvantage), and you need to test only a single commit – the result of the merge. You can easily see where the branch began and where it ended. The first-parent view can serve as a summary of the integrated branches.</li>
<li class="calibre15">With rebase, you do the integration step by step (which can be a disadvantage or an advantage). Each of the rebased commits might need testing. The resulting history is much simpler, more linear, and easier to see. Using <strong class="source-inline1">bisection</strong> to find regression bugs should be faster with linear history.</li>
<li class="calibre15">You can use the rerere mechanism, which automatically reapplies recorded conflict resolutions.</li>
<li class="calibre15">Use the <strong class="source-inline1">git </strong><strong class="source-inline1">status</strong> command.</li>
</ol>
<h1 id="_idParaDest-221" class="calibre5"><a id="_idTextAnchor246" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Scott Chacon, Ben Straub: <em class="italic">Pro Git</em>, 2nd Edition (2014): <a href="https://git-scm.com/book/en/v2" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2</a>:<ul class="calibre18"><li class="calibre15"><em class="italic">Chapter 3.6</em>, <em class="italic">Git Branching – </em><em class="italic">Rebasing</em></li><li class="calibre15"><em class="italic">Chapter 7.8</em>, <em class="italic">Git Tools – </em><em class="italic">Advanced Merging</em></li><li class="calibre15"><em class="italic">Chapter 7.9</em>, <em class="italic">Git Tools – </em><em class="italic">Rerere</em></li></ul></li>
<li class="calibre15">Julia Evans, <em class="italic">git rebase: what can go wrong?</em> (2023): <a href="https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/" class="pcalibre1 pcalibre calibre6">https://jvns.ca/blog/2023/11/06/rebasing-what-can-go-wrong-/</a></li>
<li class="calibre15">Julia Evans, <em class="italic">How git cherry-pick and revert use 3-way merge</em> (2023): <a href="https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/" class="pcalibre1 pcalibre calibre6">https://jvns.ca/blog/2023/11/10/how-cherry-pick-and-revert-work/</a></li>
<li class="calibre15">Junio C Hamano, <em class="italic">Where do evil merges come from?</em> (2013): <a href="https://git-blame.blogspot.com/2013/04/where-do-evil-merges-come-from.html" class="pcalibre1 pcalibre calibre6">https://git-blame.blogspot.com/2013/04/where-do-evil-merges-come-from.html</a></li>
<li class="calibre15">Nick Quaranto, <em class="italic">git ready – keep either file in merge conflicts</em> (2009): <a href="https://gitready.com/advanced/2009/02/25/keep-either-file-in-merge-conflicts.html" class="pcalibre1 pcalibre calibre6">https://gitready.com/advanced/2009/02/25/keep-either-file-in-merge-conflicts.html</a></li>
<li class="calibre15"><em class="italic">Learn to use email with </em><em class="italic">git!</em>: <a href="https://git-send-email.io/" class="pcalibre1 pcalibre calibre6">https://git-send-email.io/</a></li>
</ul>
</div>
</body></html>