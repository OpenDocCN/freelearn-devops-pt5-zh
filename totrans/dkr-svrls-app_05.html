<html><head></head><body>
        

                            
                    <h1 class="header-title">The Fn Project</h1>
                
            
            
                
<p class="mce-root">This chapter introduces an FaaS platform, <em>the Fn Project</em>. It is another great FaaS framework developed by a team at Oracle Inc. Fn is one of the easiest projects that allows us to deploy an FaaS platform on a plain Docker infrastructure.</p>
<p>This chapter begins with a discussion of what the Fn Project is. It then moves on to look at how its components are organized and what its overall architecture is. We will then learn how to use the Fn CLI to prepare and deploy functions. The chapter then ends with a discussion of how to use Fn subprojects for its UI, scaling, and monitoring of the Fn cluster itself.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>The Fn Project</li>
<li>The Fn's architecture</li>
<li>Using Fn CLI</li>
<li>Deploying a local function</li>
<li>Deploying Fn on Docker Swarm</li>
<li>Monitoring Fn with its built-in UI</li>
<li>Log analysis with a familiar tool</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The Fn Project</h1>
                
            
            
                
<p>The Fn Project was originally devised by the team at <em>Iron.io</em> (<a href="https://www.iron.io/">https://www.iron.io/</a>) under the name of Iron function. After that, the two founders joined Oracle and forked Iron function into the new project, Fn.</p>
<p>Fn is a framework and system designed to develop and deploy serverless/FaaS applications. In contrast to OpenFaaS, Fn does not use any of the orchestrator-level features to manage function containers.</p>
<p>Fn does not only support deployment via its own infrastructure; it also allows you to deploy the same functions to AWS Lambda. However, we will scope only for deploying functions to its own infrastructure, which is, of course, Docker-based.</p>
<p>There are several design reasons behind Fn.</p>
<p>The Fn Project is committed to be open source. It natively supports Docker, which means that we could use a Docker container as its deployment unit—<strong>a function</strong>. Fn supports development in any programming language. The Fn infrastructure is written in the Go programming language and aims to be able to deploy everywhere, including the public cloud, a private cloud, and even the hybrid infrastructure. Fn allows for the importing of the Lambda functions from AWS and then deploying them to its own infrastructure.</p>
<p>As previously mentioned, the serverless/FaaS infrastructure with Docker is basically designed to effect a balance between controlling the whole system and the ease of maintenance and administration of the infrastructure. Fn also has the design goals that align with this concept too.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fn's architecture</h1>
                
            
            
                
<p>The easiest setup of an Fn Server is just bringing up a standalone Fn container; however, the more complete architecture will be as shown here. A cluster implementation will be demonstrated at the end of this chapter. The following diagram shows the overview of the Fn architecture:</p>
<div><img src="img/31b1eb88-ecb6-4b85-9faf-6251d64d41ca.png" style="width:42.58em;height:33.67em;"/></div>
<p>Figure 5.1: The architecture of the Fn FaaS cluster</p>
<p>As is the case with the common FaaS architecture, Fn also has the <em>API gateway</em>, which is <strong>Fn LB</strong> in the previous diagram. Fn LB is basically a load balancer. It passes through requests from the client to each <strong>Fn Server</strong>. In the Fn Server implementation, there is no separation concept of <em>initiator</em> and <em>executor</em> as there is no event bus at the core of the Fn's architecture. So, an Fn Server also acts as an executor to execute functions on its associate Docker engine.</p>
<p>Fn Servers connect to a <strong>Log Store</strong>, which could be a standalone or a cluster of DBMS. All data sent from an Fn function to the standard error is logged to the <strong>Log Store</strong>.</p>
<p><strong>Fn UI</strong> and <strong>Fn LB</strong> are extra components to help make the Fn Project better in terms of production. The Fn UI is the user interface server, such as dashboard, for Fn, while Fn LB is the load balancer to round robin among Fn nodes in the cluster.</p>
<p>There is a concept of an <em>Executor Agent</em> inside the Fn Server. The agent is responsible for controlling the runtime. In the case of Fn, the runtime is Docker. So, the executor agent is also referred as a <em>Docker agent</em> in this chapter. With the default configuration, the Docker agent inside an Fn Server connects to the local Docker engine and starts Fn functions via a local Unix socket:</p>
<div><img src="img/1e846299-3e5e-4981-9e49-1368f4711128.png"/></div>
<p>Figure 5.2: A diagram showing an Fn cluster over a Swarm-scoped network</p>
<p>The previous diagram shows a running Fn cluster over a Swarm-scoped overlay network. To form a cluster, we will use an attachable Swarm-scoped network. Each Fn Server instance has to attach to the network. When a request is made to the gateway or directly to the server, it will be passed through to the <strong>EntryPoint</strong>. The EntryPoint is a language-specific program that wraps around the real function program. For example, in the case of an Fn function built with Java, the EntryPoint is the class <kbd>com.fnproject.fn.runtime.EntryPoint</kbd>. There is a code inside this Java class to invoke the real function via Java's reflection technique:</p>
<div><img src="img/b2280d72-5efe-49de-8417-07de9a774c2e.png"/></div>
<p>Figure 5.3: An Fn function interacting with STDIN, STDOUT, and writing logs to STDERR, where it delegates logs to the store</p>
<p>The Fn Server sends the request body in the form of <strong>STDIN</strong> to the <strong>Function</strong> container. After the <strong>EntryPoint</strong> receives the <strong>STDIN</strong> stream, it converts the data content to match the type of function signature. In the previous diagram, the signature is <strong>String</strong>. So the function body is converted to a string. Output sent to <strong>STDOUT</strong> will be forwarded to the <strong>Fn Server</strong> and sent out as the result, while output sent to <strong>STDERR</strong> will be captured and stored in the <strong>Log Store</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Fn CLI</h1>
                
            
            
                
<p>This section will discuss how to use the basics of the Fn CLI, a command line to control Fn. Let's start with the installation of the Fn CLI. Make sure that the <kbd>curl</kbd> command exists on your system:</p>
<pre><strong>$ curl -LSs https://raw.githubusercontent.com/fnproject/cli/master/install | sh</strong></pre>
<p>After installing the previous command, check its version and help by typing <kbd>fn</kbd>. The current version of the command line is <kbd>0.4.43</kbd> at the time of writing. Things move fast, so you can expect to use the different version anyway:</p>
<pre><strong>$ fn</strong><br/><strong>fn 0.4.43</strong><br/><br/><strong>Fn command line tool</strong><br/><br/><strong>ENVIRONMENT VARIABLES:</strong><br/><strong>   FN_API_URL - Fn server address</strong><br/><strong>   FN_REGISTRY - Docker registry to push images to, use username only to push to Docker Hub - [[registry.hub.docker.com/]USERNAME]</strong><br/><br/><strong>COMMANDS:</strong><br/><strong>...</strong></pre>
<p>There are several sub-commands provided by <kbd>fn</kbd>, for example:</p>
<ul>
<li><kbd>fn start</kbd> is a thin wrapper around the <kbd>docker run</kbd> command. This subcommand starts the new Fn Server instance. The default address will be <kbd>http://localhost:8080</kbd>. The Fn CLI will however be trying to connect to the address defined in <kbd>FN_API_URL</kbd>, if set as an environment variable.</li>
<li><kbd>fn update</kbd> is the command for pulling the latest version of the Fn Server to a local Docker image.</li>
<li><kbd>fn init</kbd> is the command for initializing a skeleton to develop a new function. It accepts the <kbd>--runtime</kbd> parameter to generate the template for a specific language, such as Go, for example.</li>
<li><kbd>fn apps</kbd> contains subcommands for creating, updating, and deleting an application, and is a kind of namespace or package to group functions together. It is required that a function must be defined under an application.</li>
<li><kbd>fn routes</kbd> is a set of commands to define a route pointing to a function container. For example, we have the application <kbd>demo</kbd>, then we can define the route, <kbd>hello</kbd> and point it to the Docker container image, <kbd>test/hello:v1</kbd>. An application may be many routes:</li>
</ul>
<div><img src="img/2f66488b-55b8-42eb-941a-17a11968e653.png" style="border: 1em solid black;color: #333333;text-align: center;width:22.75em;height:21.25em;"/></div>
<p>Figure 5.4: The relation between an Fn application and its routes</p>
<p>Here's how Fn organizes routes under an application. For example, an Fn's API URL is <kbd>http://localhost:8080</kbd>. We may have an application named <kbd>demo</kbd> containing a route named <kbd>hello</kbd> created for the container image, <kbd>test/hello:v1</kbd>. All these together form a fully qualified URL for accessing the function.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Let's deploy a local function</h1>
                
            
            
                
<p>Firstly, carry out <kbd>fn start</kbd> to up a standalone Fn Server instance. The server is started by setting up the log level to be <kbd>info</kbd>, the default setting. The Fn Server then connects to the datastore, the Log Store. The current implementation is SQLite3. After that, the agent will be started. The Docker agent connects to the local Docker engine with its default configuration. Finally, the Fn starts listening to port <kbd>8080</kbd>:</p>
<pre><strong>$ fn start</strong><br/><br/><strong>time="2018-03-17T08:48:39Z" level=info msg="Setting log level to" level=info</strong><br/><strong>time="2018-03-17T08:48:39Z" level=info msg="datastore dialed" datastore=sqlite3 max_idle_connections=256</strong><br/><strong>time="2018-03-17T08:48:40Z" level=info msg="agent starting cfg=&amp;{MinDockerVersion:17.06.0-ce FreezeIdle:50ms EjectIdle:1s HotPoll:200ms HotLauncherTimeout:1h0m0s AsyncChewPoll:1m0s MaxResponseSize:0 MaxLogSize:1048576 MaxTotalCPU:0 MaxTotalMemory:0 MaxFsSize:0}"</strong><br/><strong>time="2018-03-17T08:48:40Z" level=info msg="no docker auths from config files found (this is fine)" error="open /root/.dockercfg: no such file or directory"</strong><br/><br/><strong>        ______</strong><br/><strong>       / ____/___</strong><br/><strong>      / /_ / __ \</strong><br/><strong>     / __/ / / / /</strong><br/><strong>    /_/ /_/ /_/</strong><br/><strong>        v0.3.381</strong><br/><br/><strong>time="2018-03-17T08:48:41Z" level=info msg="available memory" availMemory=12357627495 cgroupLimit=9223372036854771712 headRoom=1373069721 totalMemory=13730697216</strong><br/><strong>time="2018-03-17T08:48:41Z" level=info msg="sync and async ram reservations" ramAsync=9886101996 ramAsyncHWMark=7908881596 ramSync=2471525499</strong><br/><strong>time="2018-03-17T08:48:41Z" level=info msg="available cpu" availCPU=4000 totalCPU=4000</strong><br/><strong>time="2018-03-17T08:48:41Z" level=info msg="sync and async cpu reservations" cpuAsync=3200 cpuAsyncHWMark=2560 cpuSync=800</strong><br/><strong>time="2018-03-17T08:48:41Z" level=info msg="Fn serving on `:8080`" type=full</strong></pre>
<p>To check whether Docker started the Fn Server properly, we can use <kbd>docker ps</kbd> to see the running container. This would be done in another Terminal:</p>
<pre><strong>$ docker ps --format="table {{.ID}}\t{{.Names}}\t{{.Ports}}"</strong><br/><strong>CONTAINER ID    NAMES       PORTS</strong><br/><strong>ab5cd794b787    fnserver    2375/tcp, 0.0.0.0:8080-&gt;8080/tcp</strong></pre>
<p>OK, now we have the Fn Server running on port <kbd>8080</kbd> as we see the mapping <kbd>0.0.0.0:8080-&gt;8080/tcp</kbd> from <kbd>docker ps</kbd>.</p>
<p>At the current directory that started the <kbd>fn start</kbd> command, the container mapped its <kbd>data</kbd> directory to the host's <kbd>$PWD/data</kbd>. The directory contains SQLite3 database files to store logs and information. In the production environment, we will replace this with MySQL DBMS, for example:</p>
<pre><strong>$ tree</strong><br/><strong>.</strong><br/><strong>└── data</strong><br/><strong>    ├── fn.db</strong><br/><strong>    └── fn.mq</strong><br/><br/><strong>1 directory, 2 files</strong></pre>
<p>To see the list of applications, simply use the <kbd>fn apps list</kbd> command:</p>
<pre><strong>$ fn apps list</strong><br/><strong>no apps found</strong></pre>
<p>Well, there is no newly created application as we have just started the server instance. We will create one. Name it <kbd>demo</kbd> and use <kbd>fn apps list</kbd> command again to double-check the created app:</p>
<pre><strong>$ fn apps create demo</strong><br/><strong>Successfully created app: demo</strong><br/><br/><strong>$ fn apps list</strong><br/><strong>demo</strong></pre>
<p>Now we will start developing a function. In this example, we use the Java runtime and later on, we will try another runtime for Go.</p>
<p>Let's initialize the new function. We use <kbd>fn init</kbd> to create a new function project. This command takes <kbd>--runtime</kbd> to specify a language runtime we would like to use.</p>
<p>The <kbd>func.yaml</kbd> is our function descriptor. It contains the version number, runtime, and the EntryPoint of the function:</p>
<pre><strong>$ fn init --runtime java hello</strong><br/><strong>Creating function at: /hello</strong><br/><strong>Runtime: java</strong><br/><strong>Function boilerplate generated.</strong><br/><strong>func.yaml created.</strong></pre>
<p>We will try to learn how to build and deploy a function. So let's build it without modifying anything first. To build the function, simply use <kbd>fn build</kbd>. And to deploy the function, we have <kbd>fn deploy</kbd> to take care of the process for us.</p>
<p>Here's the Fn build behavior. After calling the <kbd>fn build</kbd> command, the build process starts by using the generated Dockerfile. The resulting image will be tagged and stored locally by the Docker engine. For example, the image in the example will be tagged as <kbd>hello:0.0.1</kbd> locally. Then, with the <kbd>fn deploy</kbd> command, it requires <kbd>--registry</kbd> to store the image remotely on Docker Hub. In this example, my Docker's ID is used. Please do not forget to change it to yours.</p>
<p>The <kbd>fn deploy</kbd> command works like this.</p>
<p>First, it increases the version number of the function. Second, it pushes the function's image onto Docker Hub using the <kbd>--registry</kbd> as the repository name. So, <kbd>hello:0.0.2</kbd> becomes <kbd>chanwit/hello:0.0.2</kbd> on the Docker Hub.</p>
<p>Then the <kbd>fn deploy</kbd> will register a new route under the application specified by <kbd>--app</kbd> using the newly built image's name:</p>
<pre><strong>$ fn build</strong><br/><strong>Building image hello:0.0.1 </strong><br/><strong>Function hello:0.0.1 built successfully.</strong><br/><br/><strong>$ fn deploy --app demo --registry chanwit</strong><br/><strong>Deploying hello to app: demo at path: /hello</strong><br/><strong>Bumped to version 0.0.2</strong><br/><strong>Building image chanwit/hello:0.0.2 </strong><br/><strong>Pushing chanwit/hello:0.0.2 to docker registry...The push refers to repository [docker.io/chanwit/hello]</strong><br/><strong>07a85412c682: Pushed </strong><br/><strong>895a2a3582de: Mounted from fnproject/fn-java-fdk </strong><br/><strong>5fb388f17d37: Mounted from fnproject/fn-java-fdk </strong><br/><strong>c5e4fcfb11b0: Mounted from fnproject/fn-java-fdk </strong><br/><strong>ae882186dfca: Mounted from fnproject/fn-java-fdk </strong><br/><strong>aaf375487746: Mounted from fnproject/fn-java-fdk </strong><br/><strong>51980d95baf3: Mounted from fnproject/fn-java-fdk </strong><br/><strong>0416abcc3238: Mounted from fnproject/fn-java-fdk </strong><br/><strong>0.0.2: digest: sha256:c7539b1af68659477efac2e180abe84dd79a3de5ccdb9b4d8c59b4c3ea429402 size: 1997</strong><br/><strong>Updating route /hello using image chanwit/hello:0.0.2...</strong></pre>
<p>Let's check the newly registered route. We use the <kbd>fn routes list &lt;app&gt;</kbd> command  to list all routes under the application <kbd>&lt;app&gt;</kbd>. In the following example, all routes of <kbd>demo</kbd> were listed:</p>
<pre><strong>$ fn routes list demo</strong><br/><strong>path     image                 endpoint</strong><br/><strong>/hello   chanwit/hello:0.0.2   localhost:8080/r/demo/hello</strong></pre>
<p>The previous command also listed the endpoint of each route. With the endpoint, we could basically use <kbd>curl</kbd> to interact with it, just like a normal HTTP endpoint. Do not forget to set the <kbd>-v</kbd> verbose option to <kbd>curl</kbd>. With this option, we can examine what is hidden inside the HTTP headers.</p>
<p>Let's see the lines marked bold in the HTTP response headers. There are some extra entries, <kbd>Fn_call_id</kbd> and <kbd>Xxx-Fxlb-Wait</kbd>.</p>
<p>The header,  <kbd>Fn_call_id</kbd>, is the identifier for each call. This ID will also be used when we enable distributed tracing within Fn. The header, <kbd>Xxx-Fxlb-Wait</kbd> is the information collectible by the Fn LB, so it knows the wait time of this function:</p>
<pre><strong>$ curl -v localhost:8080/r/demo/hello</strong><br/><br/><strong>* Trying 127.0.0.1...</strong><br/><strong>* Connected to localhost (127.0.0.1) port 8080 (#0)</strong><br/><strong>&gt; GET /r/demo/hello HTTP/1.1</strong><br/><strong>&gt; Host: localhost:8080</strong><br/><strong>&gt; User-Agent: curl/7.47.0</strong><br/><strong>&gt; Accept: */*</strong><br/><strong>&gt; </strong><br/><strong>&lt; HTTP/1.1 200 OK</strong><br/><strong>&lt; Content-Length: 13</strong><br/><strong>&lt; Content-Type: text/plain</strong><br/><strong>&lt; Fn_call_id: 01C8SPGSEK47WGG00000000000</strong><br/><strong>&lt; Xxx-Fxlb-Wait: 78.21µs</strong><br/><strong>&lt; Date: Sat, 17 Mar 2018 10:01:43 GMT</strong><br/><strong>&lt; </strong><br/><strong>* Connection #0 to host localhost left intact</strong><br/><strong>Hello, world!</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Trying again with Golang</h1>
                
            
            
                
<p>Let's try creating the next function with another runtime, Go. Unlike Java, Go codes inside an Fn function do not have a proper concept of EntryPoint. Fortunately, the execution model of Fn is simple enough, so this matter is extremely trivial:</p>
<pre><strong>$ fn init --runtime go hello_go</strong><br/><br/><strong>Creating function at: /hello_go</strong><br/><strong>Runtime: go</strong><br/><strong>Function boilerplate generated.</strong><br/><strong>func.yaml created.</strong></pre>
<p>Here's the list of files for the Go Fn function:</p>
<pre><strong>$ cd hello_go</strong><br/><br/><strong>$ tree .</strong><br/><strong>.</strong><br/><strong>├── func.go</strong><br/><strong>├── func.yaml</strong><br/><strong>└── test.json</strong></pre>
<p>The file, <kbd>func.go</kbd> is, of course, the <em>function program</em> itself, while <kbd>func.yaml</kbd> is the Fn's function <em>descriptor</em>. And the one interesting file here is <kbd>test.json</kbd> – a file containing test fixtures for functional tests. Currently, we can use the <kbd>fn test</kbd> command to test the positive paths, but not the negative results.</p>
<p>We will take a look at <kbd>func.yaml</kbd> to see what's inside it first. The <kbd>version</kbd> will be automatically increased every time it is deployed. The <kbd>runtime</kbd> here is <kbd>go</kbd> as we specified it as the <kbd>--runtime</kbd> parameter of <kbd>fn init</kbd>. The <kbd>entrypoint</kbd> here should not be touched. Just leave it there, trust me:</p>
<pre><strong>$ cat func.yaml</strong><br/><br/><strong>version: 0.0.1</strong><br/><strong>runtime: go</strong><br/><strong>entrypoint: ./func</strong></pre>
<p>The Go codes could consume the STDIN directly. The best way is to pass the input as a JSON and use Go's <kbd>encoding/json</kbd> package to process the data. Here's the example adapted from the original Fn example. This program was modified to simplify the output process and add error checking and logging:</p>
<pre>package main<br/><br/>import (<br/>  "encoding/json"<br/>  "fmt"<br/>  "os"<br/>)<br/><br/>type Message struct {<br/>  Name string<br/>}<br/><br/>func main() {<br/>  m := &amp;Message{Name: "world"}<br/><br/>  err := json.NewDecoder(os.Stdin).Decode(m)<br/>  if err != nil {<br/>    fmt.Fprintf(os.Stderr, "err JSON Decode: %s\n", err.Error())<br/>    os.Exit(250)<br/>  }<br/><br/>  fmt.Printf(`{"success": "Hello %s"}`, m.Name);<br/>  os.Exit(0)<br/>}</pre>
<p>In every program, we need to check errors and handle them. As shown in the previous example, we check errors occurring during encoding and then print the error message to <kbd>os.Stderr</kbd>, the standard error file in Go. Then we just exit the process with code <kbd>&gt; 0</kbd>. Here, we use <kbd>250</kbd>.</p>
<p>Let's summarize error handling and logging in Fn. First, write messages to STDERR and they will be stored in the logs. Second, exit the process with an error code, that is, <kbd>&gt; 0</kbd>. Fn will then mark the container execution as <em>error</em>.</p>
<p>Let's see this in action. Make sure we have the previous code example inside <kbd>func.go</kbd> and deploy it with the <kbd>fn deploy</kbd> command:</p>
<pre><strong>$ fn deploy --app demo --registry chanwit</strong><br/><br/><strong>Deploying hello_go to app: demo at path: /hello_go</strong><br/><strong>Bumped to version 0.0.2</strong><br/><strong>Building image chanwit/hello_go:0.0.2 .......</strong><br/><strong>Pushing chanwit/hello_go:0.0.2 to docker registry...The push refers to repository [docker.io/chanwit</strong><br/><strong>/hello_go]</strong><br/><strong>00a6a1467505: Pushed </strong><br/><strong>96252b84ae14: Pushed </strong><br/><strong>97dedccb7128: Mounted from fnproject/go </strong><br/><strong>c9e8b5c053a2: Mounted from fnproject/go </strong><br/><strong>0.0.2: digest: sha256:8a57737bff7a8e4444921959532716654230af0534b93dc6be247ac88e4e7ef2 size: 1155</strong><br/><strong>Updating route /hello_go using image chanwit/hello_go:0.0.2...</strong></pre>
<p>If the last line of <kbd>fn deploy</kbd> is saying that the route is updated, it will be good to go.</p>
<p>Next, we will use the <kbd>fn call</kbd> command to invoke the function, which is now registered as a route under the app <kbd>demo</kbd>. Try calling it without parameters to cause the error:</p>
<pre><strong>$ fn call demo /hello_go </strong><br/><br/><strong>{"error":{"message":"container exit code 250"}}</strong><br/><strong>ERROR: error calling function: status 502</strong></pre>
<p>This is what we would expect. It was a call without input. So the <kbd>encoding/json</kbd> raised the error and the program wrote a log message in STDERR (not shown in the previous code). Finally, the function returns <kbd>250</kbd>. With the message, we saw the <kbd>fn call</kbd> printed out, saying the function container exited with code <kbd>250</kbd>. So the error was handled properly.</p>
<p>No log messages here, but we will get back to them later.</p>
<p>Next, we will make a successful call. To make it green, just pass the JSON body using the <kbd>echo</kbd> command. The JSON body will be piped to <kbd>fn call</kbd>  and turned into a HTTP request, then it will be received by the Fn Server and serialized again to be STDIN for the function program.</p>
<p>The success JSON chuck is what we would expect for a program working correctly.</p>
<p>The syntax of calling a remote function via <kbd>fn call</kbd> is that we need to pass the <em>application name</em> and the <em>route name</em> for it to invoke:</p>
<pre><strong>$ echo '{"Name": "chanwit"}' | fn call demo /hello_go </strong><br/><br/><strong>{"success": "Hello chanwit"}</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Examining call logs and errors</h1>
                
            
            
                
<p>To see all call logs, use the <kbd>fn calls</kbd> command. Please note that it's the <kbd>calls</kbd> command with an <em>s</em>. The <kbd>fn calls list</kbd> command accepts the name of the application. The attributes to focus on are <kbd>ID</kbd>, and <kbd>Status</kbd>. The following example shows two call logs, the first one is <kbd>error</kbd> and the second one is <kbd>success</kbd>, in reverse chronological order:</p>
<pre><strong>$ fn calls list demo </strong><br/><br/><strong>ID: 01C8VRGN9R47WGJ00000000000</strong><br/><strong>App: demo</strong><br/><strong>Route: /hello_go</strong><br/><strong>Created At: 2018-03-18T05:15:04.376Z</strong><br/><strong>Started At: 2018-03-18T05:15:04.738Z</strong><br/><strong>Completed At: 2018-03-18T05:15:07.519Z</strong><br/><strong>Status: success</strong><br/><br/><strong>ID: 01C8VRFE3647WGE00000000000</strong><br/><strong>App: demo</strong><br/><strong>Route: /hello_go</strong><br/><strong>Created At: 2018-03-18T05:14:24.230Z</strong><br/><strong>Started At: 2018-03-18T05:14:24.566Z</strong><br/><strong>Completed At: 2018-03-18T05:14:27.375Z</strong><br/><strong>Status: error</strong></pre>
<p>Now, we pick the second call ID to get the log messages. The command used for  retrieving logs is <kbd>fn logs get</kbd>. It requires the application name and the call ID:</p>
<pre><strong>$ fn logs get demo 01C8VRFE3647WGE00000000000</strong><br/><strong>err JSON Decode: EOF</strong></pre>
<p>The previous log message is the one printed out to <kbd>os.Stderr</kbd> by the Go program.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Deploying Fn on Docker Swarm</h1>
                
            
            
                
<p>In this example, we start an Fn cluster on a Swarm-scoped network.</p>
<p>Starting with deploying a network, we use <kbd>weaveworks/net-plugin</kbd> as the backbone network for stability reasons. Please note that the network must be attachable and the subnet must be inside the scope of  <kbd>10.32.0.0/16</kbd>. So, <kbd>10.32.3.0/24</kbd> is just fine here:</p>
<pre><strong>$ docker network create \</strong><br/><strong>  --driver weaveworks/net-plugin:2.1.3</strong><br/><strong>  --attachable \</strong><br/><strong>  --subnet 10.32.3.0/24 \</strong><br/><strong>  fn_net</strong></pre>
<p>Then we prepare a volume for the datastore. As this section also wanted to demonstrate a product-grade setup, we use MySQL as the store rather than the default SQLite3. Using MySQL allows us to horizontally scale the number of Fn Servers.</p>
<p>The volume will be created using the <kbd>docker volume create</kbd> command. If we'd like to set up a MySQL cluster, the setups would be a bit more complex than this, but it will not be covered by this book:</p>
<pre><strong>$ docker volume create mysql_vol</strong></pre>
<p>This is the <kbd>docker run</kbd> command to start an instance of MySQL. We just attach the instance to the network <kbd>fn_net</kbd> created previously. We specify the network alias here to ensure that the service must be accessible by the name <kbd>mysql</kbd>. All environment variables are designed to set up a username, password, and the default database, <kbd>fn_db</kbd>. Do not forget to bind the volume, <kbd>mysql_vol</kbd>, to <kbd>/var/lib/mysql</kbd> inside the container. This is designed to enable the data survive to when the container is removed:</p>
<pre class="mce-root"><strong>$ docker run \</strong><br/><strong>    --detach \</strong><br/><strong>    --name mysql \</strong><br/><strong>    --network fn_net \</strong><br/><strong>    --network-alias mysql \</strong><br/><strong>    -e MYSQL_DATABASE=fn_db \</strong><br/><strong>    -e MYSQL_USER=func \</strong><br/><strong>    -e MYSQL_PASSWORD=funcpass \</strong><br/><strong>    -e MYSQL_RANDOM_ROOT_PASSWORD=yes \</strong><br/><strong>    -v mysql_vol:/var/lib/mysql \</strong><br/><strong>    mysql</strong></pre>
<p>The next step is to start the Fn Servers. This section demonstrates how to start two Fn Servers pointing to the same Log Store (MySQL). Each Fn Server attaches to the <kbd>fn_net</kbd>. This first instance is named <kbd>fn_0</kbd>. An Fn Server requires <kbd>FN_DB_URL</kbd> to point to an external Log Store, which may be PostgreSQL or MySQL. Just put the complete URL as shown in the following command. We also call the container <kbd>fn_0</kbd> to make it easier to manage.</p>
<p>When having a setting such as this, the Fn Server becomes completely stateless, where all states will be stored externally to the database. So it is now safe to completely remove the Fn Server containers when things go wrong:</p>
<pre class="mce-root"><strong>$ docker run --privileged \</strong><br/><strong>    --detach \</strong><br/><strong>    --network fn_net \</strong><br/><strong>    --network-alias fn_0 \</strong><br/><strong>    --name fn_0 \</strong><br/><strong>    -e "FN_DB_URL=mysql://func:funcpass@tcp(mysql:3306)/fn_db" \</strong><br/><strong>    fnproject/fnserver</strong></pre>
<p>Let's start another one, <kbd>fn_1</kbd>. Basically, this should be done on a separate node (physical or virtual):</p>
<pre class="mce-root"><strong>$ docker run --privileged \</strong><br/><strong>    --detach \</strong><br/><strong>    --network fn_net \</strong><br/><strong>    --network-alias fn_1 \</strong><br/><strong>    --name fn_1 \</strong><br/><strong>    -e "FN_DB_URL=mysql://func:funcpass@tcp(mysql:3306)/fn_db" \</strong><br/><strong>    fnproject/fnserver</strong></pre>
<p>Well, after setting all Fn Server instances, now it's time to aggregate them. We use Fn LB to act as the load balancer in front of all the Fn Servers. Similar to other containers, we just create and attach it to the <kbd>fn_net</kbd>. As it is the FaaS gateway, we also expose its port to <kbd>8080</kbd> (from its internal port <kbd>8081</kbd>) to make the Fn CLI able to connect to the Fn cluster without any special setting. The network alias is just used when we need other services to connect to this gateway.</p>
<p>Next, send a list of Fn Server nodes as the command line.</p>
<p>Currently, the node list configuration is allowed to pass directly to the container only. Just put them in <kbd>&lt;name&gt;:&lt;port&gt;</kbd> format, separated by a <em>comma</em>:</p>
<pre class="mce-root"><strong>$ docker run --detach \</strong><br/><strong>    --network fn_net \</strong><br/><strong>    --network-alias fnlb \</strong><br/><strong>    --name fnlb \</strong><br/><strong>    -p 8080:8081 \</strong><br/><strong>    fnproject/fnlb:latest --nodes fn_0:8080,fn_1:8080</strong></pre>
<p>OK, now it's time to verify that everything is up and running. We double-check all containers with the <kbd>docker ps</kbd> command:</p>
<pre><strong>$ docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Command}}\t{{.Ports}}"</strong><br/><strong>CONTAINER ID   NAMES     COMMAND                  PORTS</strong><br/><strong>ce4f8e9bc300   fnlb      "./fnlb --nodes fn_0…"   0.0.0.0:8080-&gt;8081/tcp</strong><br/><strong>dae4fb892b4d   fn_1      "preentry.sh ./fnser…"   2375/tcp</strong><br/><strong>8aefeb9e19ef   fn_0      "preentry.sh ./fnser…"   2375/tcp</strong><br/><strong>67bd136c331a   mysql     "docker-entrypoint.s…"   3306/tcp</strong></pre>
<p>In the next two sections, we will cover how to monitor what's happening with Fn UI and how to see and maybe further analyze the logs stored in the database.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Monitoring with Fn UI</h1>
                
            
            
                
<p>Fn UI is the user interface project created for Fn. It provides a simple dashboard with easy-to-use time series graphs to monitor how functions are doing in near real time. To start the Fn UI, we create and attach the container to the <kbd>fn_net,</kbd> also with the port published to <kbd>4000</kbd>. The Fn UI requires the URL of an Fn Server. But all of them are behind the Fn LB, so we just set <kbd>FN_API_URL</kbd> to the Fn LB location.</p>
<p>Please note that they are all connected to each other inside the <kbd>fn_net</kbd> network, so the URL appears to be <kbd>http://fnlb:8081</kbd>, using the real name and port of <kbd>fnlb</kbd> inside the network:</p>
<pre class="mce-root"><strong>$ docker run --detach \</strong><br/><strong>    --network fn_net \</strong><br/><strong>    --network-alias fnui \</strong><br/><strong>    -p 4000:4000 \</strong><br/><strong>    -e "FN_API_URL=http://fnlb:8081" fnproject/ui</strong></pre>
<p>After setting up the Fn UI instance, browse to <kbd>localhost:8080</kbd> to open the dashboard. We will see all applications listed there, as shown in the following screenshot. An application could be managed, such as creating or deleting, there too. If you do not want the screen to be always auto refreshing, uncheck Auto refresh:</p>
<div><img src="img/b661769f-08bb-4570-b7ea-b308152d87e0.png"/></div>
<p>Figure 5.5: An Fn dashboard showing the list of Fn applications</p>
<p>After selecting an application, you can execute a function within the dashboard by clicking the Run Function button, as in the following screenshot. If an error occurs when executing the function and it fails, for example, a notification will pop up as in the following example.</p>
<p>To execute the function, put the Payload in the form of JSON and press the Run button:</p>
<div><img src="img/ba0c4b6d-cf17-4869-8495-81fc624414f3.png"/></div>
<p>Figure 5.6: A dialog for invoking functions</p>
<p>When a function invocation is completed, its name and count will appear in the Completed graph. Here's the <kbd>curl</kbd> command to invoke the function. Run it multiple times to see the graph change:</p>
<pre><strong>$ curl -X POST -d '{"Name":"chanwit"}' http://localhost:8080/r/demo/hello_go</strong></pre>
<p>There is also the Running graph that displays the number of functions still running in parallel. The following screenshot shows these graphs in action:</p>
<div><img src="img/8fd504f0-5a58-4c7c-a6c0-cb593dc8fd26.png"/></div>
<p>Figure 5.7: Graphs displaying different states of Fn's functions</p>
<p class="mce-root">Let's see what will happen when we run a number of requests with invalid inputs. Here's the command:</p>
<pre><strong>$ curl -X POST -d '' http://localhost:8080/r/demo/hello_go</strong></pre>
<p>With this, the <kbd>hello_go</kbd> function will exit with code <kbd>250</kbd> and appear in the Failed graph. We run it repeatedly to make the number of failure going up, as seen in the following screenshot:</p>
<div><img src="img/9df97d8e-b9fd-4735-bf73-159286be42c6.png"/></div>
<p>Figure 5.8: The bottom right-hand graph showing the increment numbers of failed functions</p>
<p>We now already know how to use the Fn UI to monitor the function invocation. Next, we will use a simple DBMS UI to help browse the logs collected by Fn Servers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Viewing call logs with MyAdmin</h1>
                
            
            
                
<p>With MySQL as the central Log Store, we can simply access MySQL with any tool to query or event analyze the logs. In this example, we use a simple MyAdmin UI to connect to the MySQL backend. Here's the <kbd>docker run</kbd> command to start MyAdmin.</p>
<p>We just simply attach an instance of MyAdmin to the same network and tell MyAdmin to connect to <kbd>mysql</kbd>, the service name of the backend DB:</p>
<pre class="mce-root"><strong>$ docker run --detach \</strong><br/><strong>    --name myadmin \</strong><br/><strong>    --network fn_net \</strong><br/><strong>    --network-alias myadmin \</strong><br/><strong>    -p 9000:80 \</strong><br/><strong>    -e PMA_HOST=mysql \</strong><br/><strong>    phpmyadmin/phpmyadmin</strong></pre>
<p class="mce-root">Browse to the exposed port, in this example port number <kbd>9000</kbd> , and log in using Username and Password, set during the setup of MySQL (<kbd>func</kbd>/<kbd>funcpass</kbd>). The following screenshot shows the login page of phpMyAdmin:</p>
<div><img src="img/2484860b-e84b-4181-b0b9-006df403a81a.png" style="width:24.75em;height:26.75em;"/></div>
<p>Figure 5.9: The login page of phpMyAdmin that will connect to the Fn's log database</p>
<p>Inside the phpMyAdmin panel, take a look at the <kbd>fn_db</kbd> parameter and we will see all the tables for storing Fn information, as shown in the following screenshot. The data of the table <kbd>apps</kbd> are created by the command <kbd>fn apps create</kbd>, for example. What we'd like to see are table <kbd>calls</kbd> and table <kbd>logs</kbd><em>.</em> The content of table <kbd>calls</kbd> can be retrieved by the <kbd>fn calls list</kbd>, and the content of table <kbd>logs</kbd> can also be retrieved in a similar way using <kbd>fn logs get</kbd>. But when we are able to access the <kbd>logs</kbd> directly, we can even do some analysis directly with the available data:</p>
<div><img src="img/244670aa-29fb-4a4c-abc4-125ad310557d.png"/></div>
<p>Figure 5.10: The list of all Fn's tables in phpMyAdmin</p>
<p>The following screenshot shows the content of table <kbd>calls</kbd>. There is a status column, which allows us to effectively filter to see what the call (status) is: success or error. There is also the stats column, which contains some temporal information to be retrieved and displayed by the Fn UI:</p>
<div><img src="img/0dd3299e-c9ad-4236-aee5-b6e38705ae9f.png" style="width:45.25em;height:23.67em;"/></div>
<p>Figure 5.11: Fn calls log data in table calls</p>
<p>The following screenshot shows table <kbd>logs</kbd>. In the <kbd>logs</kbd> table, it just stamps each entry with the call ID. The column log shows the log message we printed out to the STDERR. We can see that there are different incorrect behaviors just by trying to send some invalid inputs to our <kbd>hello_go</kbd> function. With this table being so accessible, we can troubleshoot the Fn functions effectively without installing other extra tools:</p>
<div><img src="img/54b6697b-726d-40d1-b74b-9a9c5ed215cf.png" style="width:45.25em;height:19.08em;"/></div>
<p>Figure 5.12: Fn logs data captured from a function's STDERR</p>
<p class="mce-root">OK, it seems everything is working correctly if we could get MyAdmin to show the logs data. Finally, to confirm that all containers are running and what they should look like, just use the <kbd>docker ps</kbd> command again to check all running containers:</p>
<div><pre><strong>$ docker ps --format "table {{.ID}}\t{{.Names}}\t{{.Command}}\t{{.Ports}}"</strong><br/><strong>CONTAINER ID   NAMES     COMMAND                  PORTS</strong><br/><strong>70810f341284   fnui      "npm start"              0.0.0.0:4000-&gt;4000/tcp</strong><br/><strong>ce4f8e9bc300   fnlb      "./fnlb --nodes fn_0…"   0.0.0.0:8080-&gt;8081/tcp</strong><br/><strong>dae4fb892b4d   fn_1      "preentry.sh ./fnser…"   2375/tcp</strong><br/><strong>8aefeb9e19ef   fn_0      "preentry.sh ./fnser…"   2375/tcp</strong><br/><strong>8645116af77d   myadmin   "/run.sh phpmyadmin"     9000/tcp, 0.0.0.0:9000-&gt;80/tcp</strong><br/><strong>67bd136c331a   mysql     "docker-entrypoint.s…"   3306/tcp</strong></pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercise</h1>
                
            
            
                
<p>Now it's time to review all the things in this chapter:</p>
<ol>
<li>What does the Fn architecture look like?</li>
<li>How is the architecture different from other FaaS platforms?</li>
<li>What is the role of the Fn Server?</li>
<li>How can we configure an Fn Server to use an external data store?</li>
<li>What is the difference between the techniques used by the Fn's Java runtime and Go runtime?</li>
<li>How are an application and routes organized?</li>
<li>What is the role of Fn LB?</li>
<li>What is the role of the Fn UI?</li>
<li>How can we see the results of previous calls?</li>
<li>How can we examine the log messages of a failed invocation?</li>
<li>Describe how an Fn function interacts with STDIN, STDOUT, and STDERR?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter discussed the Fn Project, its components, and architecture. We started using Fn with its command line, the Fn CLI.</p>
<p>We then discussed the structure of an Fn function, such as how it interacts with STDIN, STDOUT, and STDERR. We learned how to build and deploy Fn functions, both with Java and Go runtimes.</p>
<p>Then we formed an Fn cluster on Docker Swarm and linked the Fn Server instances to an external DB store, MySQL. We load balanced the Fn instances using Fn LB, a load balancer specifically implemented by the same team.</p>
<p>With the Fn UI, we learned how to use it to monitor invocations for Fn. With MyAdmin, we used it to browse calls and error logs directly in MySQL. A simple tool like MyAdmin could be used to achieve the same analytical result without preparing a complex toolchain.</p>
<p>The next chapter will introduce OpenWhisk, another serverless stack from the Apache project, and those used by IBM to offer serverless services in their cloud.</p>


            

            
        
    </body></html>