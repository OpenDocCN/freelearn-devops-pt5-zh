- en: Chapter 4. Build, Test, and Release Faster with Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章。通过持续集成更快地构建、测试和发布
- en: 'The emphasis of this chapter will be the value of quick iteration: Quick over
    quality iteration, as per Boyd''s law (you might recall the OODA principle mentioned
    in [Chapter 1](ch01.html "Chapter 1. What is DevOps and Should You Care?"), *What
    Is DevOps and Should You Care?*).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点将是快速迭代的价值：根据博伊德定律，快速优于高质量迭代（你可能记得在[第 1 章](ch01.html "第1章. 什么是 DevOps，以及你是否应该关心？")提到的
    OODA 原则，*什么是 DevOps，以及你是否应该关心？*）。
- en: By iteration, I am referring to a software development cycle, from the moment
    a piece of code is written, published (committed to version control), compiled
    (if needed), tested and finally deployed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代是指软件开发周期，从代码编写、发布（提交到版本控制）、编译（如果需要）、测试，最后部署的过程。
- en: '**Continuous Integration** (**CI**) defines the routines that should be adopted
    by developers plus the necessary tools to make this iteration as fast as possible.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）定义了开发人员应该采用的常规和必要的工具，以使迭代尽可能快速。'
- en: 'Let us start with the human factor:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从人因开始：
- en: Use version control (for example Git)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用版本控制（例如 Git）
- en: Commit smaller changes, more often
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提交较小的更改，更频繁
- en: Test locally first
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先在本地测试
- en: Do peer code reviews
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进行同伴代码审查
- en: Pause other team activity until an issue is resolved
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在问题解决之前暂停其他团队活动
- en: 'Then add a bit of automation (a CI server):'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然后添加一些自动化（一个 CI 服务器）：
- en: Monitor for version control changes (for example Git commits)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控版本控制的变化（例如 Git 提交）
- en: Pull down changed code
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拉取已更改的代码
- en: Compile and run tests
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编译并运行测试
- en: On success, build an artefact
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功时，构建工件
- en: On failure, notify the team and pause the pipeline
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 失败时，通知团队并暂停管道
- en: Repeat
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复
- en: Committing smaller changes helps detect problems earlier and potentially solves
    them much more easily; and a developer receives feedback on their work more frequently
    which builds confidence that their code is in a good state.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 提交较小的更改有助于更早发现问题，并更容易解决它们；开发者更频繁地收到关于他们工作的反馈，这增加了他们对自己代码状态的信心。
- en: Testing locally, where possible, greatly reduces team distraction caused by
    the CI pipeline tripping over minor issues.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在本地进行测试，尽可能地这样做，能大大减少由于 CI 管道在小问题上卡壳而带来的团队分心。
- en: Code reviews are beneficial at many levels. They eliminate bad coding habits
    as peers ensure code complies with agreed standards. They increase visibility;
    peers get a lot more exposure to the work of others. They help catch the errors
    which a machine would miss.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 代码审查在许多方面都是有益的。它们消除不良的编码习惯，因为同伴会确保代码符合约定的标准。它们增加了可见性；同伴能够更多地接触到他人的工作。它们帮助发现机器可能错过的错误。
- en: The **Toyota Way** teaches us to *Stop the Line* whenever a problem is detected.
    In terms of CI, this translates into halting the pipeline on errors and concentrating
    resources on fixing these. At first this might seem like an obvious way to reduce
    productivity and slow down the whole process, but it's been proven again and again
    that the initial overhead is ultimately worth it. This way you keep your technical
    debt to a minimum; improve code as-you-go, preventing issues from accumulating
    and re-surfacing at a later stage. Now is a good time to restate the **test locally**
    point made earlier. You would likely not want to interrupt your colleagues with
    something trivial, which could have been spotted easily before committing.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**丰田方式**教我们在发现问题时要*停线*。在 CI 方面，这意味着在错误发生时暂停管道，集中资源修复这些错误。刚开始时，这看起来可能像是减少生产力并放慢整个过程的明显方式，但一次又一次地证明，最初的开销最终是值得的。通过这种方式，你可以将技术债务保持在最低限度；在开发过程中不断改进代码，防止问题积累并在后期重新浮现。现在是时候重申之前提到的**本地测试**的观点了。你可能不想因为一些微不足道的错误打扰同事，这些错误本可以在提交之前轻松发现。'
- en: As you succeed in building this team discipline (the hard part), it is time
    to add some automation flavor by setting up a CI pipeline.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你成功建立了这个团队纪律（最困难的部分）之后，是时候通过设置 CI 管道加入一些自动化的味道了。
- en: The CI server tirelessly monitors your code repository and reacts to changes
    by performing a set of tasks over and over again. I believe it is evident how
    this saves engineers a great amount of time and effort, not to mention the fact
    that they avoid having to address the monotone nature of such work.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: CI 服务器不知疲倦地监控你的代码仓库，并通过执行一组任务对变化作出反应。我相信显而易见的是，这为工程师节省了大量时间和精力，更不用说他们避免了处理这种单调工作的麻烦。
- en: 'A pipeline, say in Jenkins, would normally consist of a number of stages: individual
    stages can represent the checking out of the latest code, running build tasks
    on it, performing tests then building artefacts, where each stage runs subject
    to the previous one completing successfully.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一个管道，比如在Jenkins中，通常由多个阶段组成：每个阶段代表拉取最新代码、在其上运行构建任务、执行测试然后构建产物，且每个阶段的运行都依赖于前一个阶段成功完成。
- en: This generally describes how a combination of engineer habits and some tooling
    can greatly improve a software development cycle. Continuous Integration helps
    us collaborate better, write better code, ship more often and get feedback quicker.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常描述了工程师的习惯与一些工具如何大大改善软件开发周期。持续集成帮助我们更好地协作、编写更好的代码、更频繁地发布，并更快地获取反馈。
- en: Users want new features released fast, developers want to see the result of
    their work out there - everybody wins.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 用户希望快速发布新功能，开发人员希望看到自己工作的成果——每个人都能从中受益。
- en: We have discussed the theory, now let us bring our focus to the title of this
    chapter. We are going to use our acquired Terraform and Salt skills to deploy
    a CI environment on AWS featuring a Jenkins (v2) CI server.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了理论，现在让我们将注意力集中在本章的标题上。我们将使用之前学到的Terraform和Salt技能，在AWS上部署一个包含Jenkins（v2）CI服务器的CI环境。
- en: 'Jenkins (ref: [https://jenkins.io](https://jenkins.io)) is a popular, well
    established open source project focusing on automation. It comes with a long list
    of integrations, catering to a variety of platforms and programming languages.
    Meet Jenkins: [https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins（参考：[https://jenkins.io](https://jenkins.io)）是一个流行且成熟的开源项目，专注于自动化。它有许多集成，支持各种平台和编程语言。认识Jenkins：[https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins)。
- en: 'The deployment of our CI environment can be broken down into three main stages:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的CI环境部署可以分为三个主要阶段：
- en: 'Prepare an **Infrastructure as Code** deployment:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备一个**基础设施即代码**部署：
- en: Write **Terraform** templates to provision a VPC and an EC2 instance
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写**Terraform**模板以提供VPC和EC2实例
- en: Write **Salt** States to install Jenkins, NGINX and other software onto the
    EC2 instance
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写**Salt**状态以在EC2实例上安装Jenkins、NGINX和其他软件
- en: 'Deploy IaC:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 部署IaC：
- en: Deploy the Terraform templates and Salt States
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署Terraform模板和Salt状态
- en: 'Setup CI:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置CI：
- en: Configure a Jenkins pipeline for Continuous Integration of a demo application
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Jenkins管道以实现演示应用程序的持续集成
- en: Prepare IaC
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备IaC
- en: In accordance with our *Infrastructure as Code* principles, this deployment
    will also be mostly template driven. We will try to reuse some of the Terraform
    and Salt code from previous chapters.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们的*基础设施即代码*（IaC）原则，这次部署也将主要通过模板来完成。我们将尝试复用上一章的一些Terraform和Salt代码。
- en: Terraform templates
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Terraform模板
- en: For this particular setup we can simplify our template as we will only need
    the VPC, some networking bits, and an EC2 instance.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个特定的设置，我们可以简化我们的模板，因为我们只需要VPC、一些网络配置以及一个EC2实例。
- en: 'Let''s browse through the files in our *TF* repository:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们浏览一下我们*TF*仓库中的文件：
- en: Variables
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量
- en: 'The few variables we need can be grouped into VPC and EC2 related ones:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的几个变量可以分为与VPC和EC2相关的：
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf).'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf)。
- en: '**VPC**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**VPC**'
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '**EC2**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**EC2**'
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Variables (values)
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 变量（值）
- en: 'Following the bare variable definitions, we now supply some values:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 根据基本的变量定义，我们现在提供一些值：
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars).'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars)。
- en: '**VPC**'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '**VPC**'
- en: 'We''ll keep our deployment in US East:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把部署保持在美国东部（US East）：
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**EC2**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**EC2**'
- en: 'A Nano instance will be sufficient for testing. Ensure the referenced key-pair
    exists:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一个Nano实例足以进行测试。请确保引用的密钥对存在：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Resources
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf).'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf)
- en: Create the VPC
  id: totrans-62
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建 VPC
- en: 'As a matter of standard (good) practice we create all our resources inside
    a VPC:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 作为标准（良好）实践，我们将所有资源都创建在 VPC 内：
- en: '[PRE4]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add networking components
  id: totrans-65
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加网络组件
- en: 'We add a gateway, a route table, and an Internet facing subnet from where our
    Jenkins instance will be launched:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个网关、一张路由表，以及一个互联网连接子网，Jenkins 实例将从这里启动：
- en: '**IGW**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**IGW**'
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '**Route table**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**路由表**'
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '**Subnet**'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**子网**'
- en: '[PRE7]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Add EC2 node and related resources
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加 EC2 节点及相关资源
- en: 'The security group for our Jenkins node needs to permit HTTP/S access plus
    SSH for convenience, so that we can access the command line if needed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Jenkins 节点的安全组需要允许 HTTP/S 访问以及 SSH 访问，方便我们在需要时访问命令行：
- en: '**Security Group**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全组**'
- en: '[PRE8]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '**IAM Role**'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**IAM 角色**'
- en: 'We will use an IAM Role to grant Jenkins access to AWS services:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IAM 角色来授予 Jenkins 访问 AWS 服务的权限：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '**IAM Role Policy**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**IAM 角色策略**'
- en: 'This policy will allow Jenkins to read from a codecommit repository and perform
    all actions (except deleting) on an s3 bucket:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这个策略将允许 Jenkins 从 CodeCommit 仓库读取，并在 S3 存储桶上执行所有操作（除了删除）：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '**IAM Profile**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**IAM 配置文件**'
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '**EC2 instance**'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '**EC2 实例**'
- en: 'Here we define a single instance along with its bootstrap UserData script:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个单实例，并且其引导 UserData 脚本：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Here we set the attributes needed to launch an EC2 instance, such as the instance
    type, the AMI to be used, security group(s), subnet and so on.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了启动 EC2 实例所需的属性，比如实例类型、使用的 AMI、安全组、子网等等。
- en: 'Next, we add the bootstrap shell script to help us install required packages,
    checkout Git repositories and run Salt:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了引导 shell 脚本，帮助我们安装所需的软件包、检出 Git 仓库并运行 Salt：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '**Elastic IP**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**弹性 IP**'
- en: 'Finally, we provision a static IP for Jenkins:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们为 Jenkins 配置一个静态 IP：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Outputs
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输出
- en: Note
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf)
- en: 'Some useful outputs to provide us with the address of the Jenkins node:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些有用的输出，用来提供 Jenkins 节点的地址：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: And that is our VPC infrastructure defined. Now we can move onto Salt and the
    application stack.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们定义的 VPC 基础设施。现在我们可以开始配置 Salt 和应用栈了。
- en: SaltStack code
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SaltStack 代码
- en: You'll remember our favorite Configuration Management tool from the previous
    chapter. We will use SaltStack to configure the EC2 Jenkins node for us.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该还记得上一章我们提到的那个最喜爱的配置管理工具。我们将使用 SaltStack 来为我们配置 EC2 Jenkins 节点。
- en: States
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 状态
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states).'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states)
- en: '**top.sls**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**top.sls**'
- en: 'We are working with a single minion, and all our states apply to it:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个单一的从属节点（minion），所有的状态都应用于它：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '**users**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**users**'
- en: 'We add a Linux user account, configure its SSH keys and **sudo** access:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个 Linux 用户账户，配置了其 SSH 密钥和 **sudo** 权限：
- en: '[PRE17]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**yum-s3**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**yum-s3**'
- en: 'As part of our CI pipeline, we will be storing RPM artefacts in S3\. Cob (ref:
    [https://github.com/henrysher/cob](https://github.com/henrysher/cob)) is a Yum
    package manager plugin which makes it possible to access S3 based RPM repositories
    using an IAM Role.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 CI 流水线的一部分，我们将在 S3 中存储 RPM 制品。Cob（参考：[https://github.com/henrysher/cob](https://github.com/henrysher/cob)）是一个
    Yum 包管理器插件，它使得可以通过 IAM 角色访问基于 S3 的 RPM 仓库。
- en: 'We deploy the plugin, its configuration and a repository definition (disabled
    for now) as managed files:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们部署插件、其配置和一个仓库定义（目前禁用）作为管理文件：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '**Jenkins**'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jenkins**'
- en: Here comes the lead character – Mr Jenkins. We make use of Docker in our CI
    pipeline, hence the `include` following. Docker allows us to run the different
    pipeline steps in isolation, which makes dependency management much easier and
    helps keeps the Jenkins node clean.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是主角——Jenkins先生。我们在 CI 流水线中使用 Docker，因此接下来是 `include`。Docker 使我们能够将不同的流水线步骤隔离开来，这让依赖管理变得更加容易，并有助于保持
    Jenkins 节点的干净。
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Also we ensure Java and a few other prerequisites get installed:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 同时我们确保安装 Java 和其他一些前提条件：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Then, install Jenkins itself:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，安装 Jenkins 本身：
- en: '[PRE21]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '**NGINX**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**NGINX**'
- en: 'We will use NGINX as a reverse proxy and an SSL termination point. That is
    not to say that Jenkins cannot serve on its own, it is just considered better
    practice to separate the roles:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 NGINX 作为反向代理和 SSL 终止点。这并不是说 Jenkins 不能单独提供服务，只是将角色分开被认为是更好的实践：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '**Docker**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**Docker**'
- en: 'It is about time we mentioned Docker, given its (deserved) popularity nowadays.
    It is very well suited to our CI needs, providing isolated environments for the
    various tests and builds that may be required:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候提到 Docker 了，鉴于它如今的（应得的）流行。它非常适合我们的 CI 需求，为可能需要的各种测试和构建提供隔离的环境：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Pillars
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Pillars
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars).'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars)。
- en: '**top.sls**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**top.sls**'
- en: 'Our standalone minion gets it all:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的独立 minion 获取了所有内容：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '**users**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**users**'
- en: 'Setting a password hash and a consistent UID for the Linux account:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Linux 账户的密码哈希和一致的 UID：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '**NGINX**'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**NGINX**'
- en: 'We store the SSL data in this Pillar:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 SSL 数据存储在此 Pillar 中：
- en: '[PRE26]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Minion configuration
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Minion 配置
- en: Note
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d).'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d)。
- en: '**masterless.conf**'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**masterless.conf**'
- en: 'We are still using Salt in standalone (masterless) mode, so this is our extra
    `minion` configuration:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然在使用 Salt 的独立（无主）模式，因此这是我们额外的`minion`配置：
- en: '[PRE27]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Thanks to all of the preceding codes, we should be able to run Terraform and
    end up with a Jenkins service ready for use.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于前面的所有代码，我们应该能够运行 Terraform 并最终得到一个准备好使用的 Jenkins 服务。
- en: Let us give that a try.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试试看。
- en: Deploy IaC
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署基础设施即代码（IaC）
- en: 'We start by creating a Terraform EC2 key-pair and a Terraform IAM user as in
    previous chapters (do not forget to write down access/secret API keys). Then we
    grant permissions to the IAM user to perform actions with the EC2, IAM, S3 and
    CodeCommit services:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 Terraform EC2 密钥对和一个 Terraform IAM 用户，方法与前几章相同（不要忘记写下访问/密钥 API）。然后，我们授予
    IAM 用户对 EC2、IAM、S3 和 CodeCommit 服务的操作权限：
- en: Note
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json)。
- en: '[PRE28]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then we associate a SSH public key with the user (as per the screenshots in
    the previous chapter) to allow `codecommit` repository access.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将一个 SSH 公钥与用户关联（按照上一章的截图）以允许 `codecommit` 仓库访问。
- en: 'Next, we need to setup our AWS CLI environment with the keys we produced earlier:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要使用之前生成的密钥设置我们的 AWS CLI 环境：
- en: '[PRE29]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now we should be able to use the CLI tool and create our SaltStack repository:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够使用 CLI 工具并创建我们的 SaltStack 仓库：
- en: '[PRE30]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We clone the repository locally:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本地克隆仓库：
- en: '[PRE31]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: (where `SSH_KEY_ID` is the one we saw after uploading a public key here)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: （其中`SSH_KEY_ID`是我们在这里上传公钥后看到的）
- en: Finally, you can copy the ready salt code examples for this chapter, commit
    and push to the `codecommit` repository.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您可以复制本章的现成 Salt 代码示例，提交并推送到 `codecommit` 仓库。
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt)
- en: 'With the SaltStack repo in sync, we can proceed with Terraform and the bootstrap
    process. Inside our TF templates folder we run the familiar command sequence:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SaltStack 仓库同步后，我们可以继续进行 Terraform 和引导过程。在我们的 TF 模板文件夹中，我们运行熟悉的命令序列：
- en: '[PRE32]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: At the end we get the IP of our Jenkins node which we would need to resolve
    into a hostname (for example via the `nslookup` cmd). Load that in your browser
    and you should be greeted by Jenkins.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们得到 Jenkins 节点的 IP 地址，之后需要将其解析为主机名（例如，通过 `nslookup` 命令）。在浏览器中加载该地址，您应该能看到
    Jenkins 界面。
- en: Setup CI
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 CI
- en: After a successful Terraform deployment, it is time to move onto service configuration.
    More specifically, Jenkins and the integration pipeline.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 成功部署 Terraform 后，我们进入服务配置阶段。更具体地说，是 Jenkins 和集成流水线的配置。
- en: Jenkins initialization
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jenkins 初始化
- en: 'With Jenkins running for the first time, we need to complete a short setup
    routine. First, we need to SSH into the node and retrieve the admin password stored
    in `/var/lib/jenkins/secrets/initialAdminPassword`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jenkins 第一次运行时，我们需要完成一个简短的设置过程。首先，我们需要 SSH 登录到节点，并获取存储在 `/var/lib/jenkins/secrets/initialAdminPassword`
    中的管理员密码：
- en: '![Jenkins initialization](img/image_04_001.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins 初始化](img/image_04_001.jpg)'
- en: 'We are mainly interested in the pipeline group of plugins which is included
    with the suggested ones:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们主要关心的是与建议插件一起包含的流水线插件组：
- en: '![Jenkins initialization](img/image_04_002.jpg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins 初始化](img/image_04_002.jpg)'
- en: 'After the plugins installation has completed, it''s time to create our first
    user:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 插件安装完成后，是时候创建第一个用户了：
- en: '![Jenkins initialization](img/image_04_003.jpg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins 初始化](img/image_04_003.jpg)'
- en: 'With this the initialization process is complete and Jenkins is ready for use:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，初始化过程完成，Jenkins 已经准备好使用：
- en: '![Jenkins initialization](img/image_04_004.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![Jenkins 初始化](img/image_04_004.jpg)'
- en: Writing a demo app
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写一个示例应用
- en: 'Before configuring the CI pipeline, it will help to have something to do some
    integration on. A basic Hello World type of PHP code will do, so with a sincere
    apology to all PHP developers out there, I present you with the source of our
    demo app:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置 CI 流水线之前，最好先有些集成工作可做。一个简单的 Hello World 类型的 PHP 代码就足够了，所以我诚恳地向所有 PHP 开发者道歉，向您展示我们的示例应用源代码：
- en: Note
  id: totrans-180
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app).'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app)。
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a third file in our `demo-app` folder curiously named `Jenkinsfile`
    which we will discuss shortly.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 `demo-app` 文件夹中有一个第三个文件，名字很有意思，叫做 `Jenkinsfile`，我们稍后会讨论它。
- en: 'Now let us get our code into a repository:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们将代码放入代码仓库：
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, we place our `demo-app` code into the empty repository, commit and
    push all changes to codecommit.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `demo-app` 代码放入空的仓库，提交并推送所有更改到 codecommit。
- en: Defining the pipeline
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义流水线
- en: 'It is time to decide on what the CI pipeline is meant to do for us. Here is
    a list of useful steps as a start:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候决定 CI 流水线要为我们做些什么了。这里是一些有用步骤的列表，作为起点：
- en: Checkout application source code from Git
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Git 中检出应用程序源代码
- en: Run tests against it by running PHPUnit inside a Docker container (on the Jenkins
    host)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Docker 容器内运行 PHPUnit（在 Jenkins 主机上）来进行测试
- en: Build application artefacts by executing FPM within a container on the Jenkins
    host
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 Jenkins 主机上的容器中执行 FPM 来构建应用程序工件
- en: Upload artefacts to an external store (for example, a Yum repository)
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将工件上传到外部存储（例如，Yum 仓库）
- en: 'Translated into Jenkins pipeline code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 转换为 Jenkins 流水线代码：
- en: Note
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile)。
- en: '[PRE35]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Generally speaking, defining a pipeline consists of a setting out a series
    of tasks/stages. Let us review each of the preceding stages:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，定义一个流水线包含一系列任务/阶段的设置。让我们回顾一下之前的每个阶段：
- en: We start with a Git checkout of our `demo-app` code. The repository address
    is assumed to be the one of the `Jenkinsfile`.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们从Git检出`demo-app`代码开始。假设代码库地址与`Jenkinsfile`的地址相同。
- en: 'At the next stage we take advantage of Docker''s isolation and spin up a container
    with everything needed for PHPUnit (ref: https://phpunit.de) to run a test against
    our `demo-app` source code. Take a look in the `tests/` folder under `${GIT_URL}/Examples/Chapter-4/CodeCommit/demo-app/`
    if you would like to add more or modify it further.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一个阶段，我们利用Docker的隔离性，启动一个容器，容器中包含运行PHPUnit（参考：https://phpunit.de）所需的一切，以对我们的`demo-app`源代码进行测试。如果你想添加更多测试或进一步修改，可以查看`${GIT_URL}/Examples/Chapter-4/CodeCommit/demo-app/`下的`tests/`文件夹。
- en: 'If the tests pass, we move onto building an RPM artefact using a neat, user-friendly
    tool called FPM (ref: https://github.com/jordansissel/fpm), again in a Docker
    container. We use the short `git commit hash` as the version identifier for our
    demo-app.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果测试通过，我们就开始使用一个干净且用户友好的工具叫做FPM（参考：https://github.com/jordansissel/fpm）在Docker容器中构建一个RPM工件。我们使用短的`git
    commit hash`作为我们的demo-app的版本标识。
- en: We move our RPM artefact to a designated repository folder, create a YUM repository
    out of it using `createrepo` and sync all that data to an Amazon S3 bucket. The
    idea is to use this S3 based YUM repository later on for deploying our `demo-app`.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将RPM工件移动到指定的仓库文件夹，使用`createrepo`将其创建为YUM仓库，并将所有数据同步到一个Amazon S3存储桶。目的是稍后使用这个基于S3的YUM仓库来部署我们的`demo-app`。
- en: Finally, as a bonus, we check that the package we just synced can be retrieved
    via YUM.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，作为一个额外的步骤，我们检查一下我们刚刚同步的包是否可以通过YUM获取。
- en: Our pipeline is now defined but before we can run it, we need to satisfy one
    (S3) dependency. We need to create a S3 bucket to store the RPM artefacts that the
    pipeline would produce. Then we need to update parts of the Jenkins and Saltstack
    code with the address of that S3 bucket.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的流水线现在已定义，但在运行之前，我们需要满足一个（S3）依赖项。我们需要创建一个S3存储桶来存储流水线生成的RPM工件。然后，我们需要更新Jenkins和Saltstack代码中的部分内容，添加该S3存储桶的地址。
- en: 'To interact with S3, we shall use the AWS CLI tool within the environment we
    configured for Terraform earlier:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了与S3进行交互，我们将在之前为Terraform配置的环境中使用AWS CLI工具：
- en: '[PRE36]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The bucket name is up to you, but keep in mind that the global S3 namespace
    is shared, so the more unique the name the better.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 存储桶名称由你决定，但请记住，全球S3命名空间是共享的，所以名称越唯一越好。
- en: 'Next, we update our pipeline definition (`Jenkinsfile`). Look for the line
    containing `MY_BUCKET_NAME`:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们更新我们的流水线定义（`Jenkinsfile`）。查找包含`MY_BUCKET_NAME`的行：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We also need to update SaltStack (again replacing `MY_BUCKET_NAME`):'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新SaltStack（再次替换`MY_BUCKET_NAME`）：
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo).'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo)。
- en: '[PRE38]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'This `repo` file will be used in the last stage of our pipeline, as we will
    see in a moment. At this point you will need to commit and push both changes:
    the `Jenkinsfile` to the `demo-app` repository and the `s3.repo` file to the SaltStack
    one. Then you would SSH into the Jenkins node, pull and apply the Salt changes.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`repo`文件将在流水线的最后阶段使用，正如我们稍后将看到的那样。此时，你需要提交并推送这两项更改：将`Jenkinsfile`提交到`demo-app`仓库，将`s3.repo`文件提交到SaltStack仓库。然后，你需要通过SSH连接到Jenkins节点，拉取并应用Salt更改。
- en: Setting up the pipeline
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置流水线
- en: 'Back to the Jenkins interface. After logging in, we click on the `create new
    jobs` link on the welcome page:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Jenkins界面。在登录后，我们点击欢迎页面上的`创建新作业`链接：
- en: '![Setting up the pipeline](img/image_04_005.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![设置流水线](img/image_04_005.jpg)'
- en: 'We select **Pipeline** as a job type and pick a name for it:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们选择**Pipeline**作为作业类型，并为其选定一个名称：
- en: '![Setting up the pipeline](img/image_04_006.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![设置流水线](img/image_04_006.jpg)'
- en: 'The next screen takes us to the job configuration details. At the top we choose
    to **Discard old builds** in order to keep our Jenkins workspace compact. We are
    saying, only keep details of the last five executions of this job:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 下一屏幕将带我们进入作业配置的详细信息。顶部我们选择**丢弃旧构建**，以保持Jenkins工作空间的简洁。我们设定，只保留此作业最近五次执行的详细信息：
- en: '![Setting up the pipeline](img/image_04_007.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![设置管道](img/image_04_007.jpg)'
- en: 'Under **Build Triggers** we choose to poll our Git repository for changes every
    5 minutes:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在**构建触发器**下，我们选择每5分钟轮询一次Git仓库以检查更改：
- en: '![Setting up the pipeline](img/image_04_008.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![设置管道](img/image_04_008.jpg)'
- en: 'Underneath, we choose **Pipeline script from SCM**, set SCM to **Git** and
    add the URL of our `demo-app` repository (that is [https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app)
    ) to be polled:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在下方，我们选择**从SCM加载管道脚本**，将SCM设置为**Git**，并添加我们`demo-app`仓库的URL（即[https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app)）以进行轮询：
- en: '![Setting up the pipeline](img/image_04_009.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![设置管道](img/image_04_009.jpg)'
- en: 'No need for extra credentials as these will be fetched via the EC2 IAM Role.
    Note the **Script Path** referencing the Jenkins file we mentioned earlier. This
    is a great new feature which gives us pipeline as code functionality as described
    here: [https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm](https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm).'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 无需额外的凭证，因为这些凭证将通过EC2 IAM角色自动获取。请注意**脚本路径**，它引用了我们之前提到的Jenkins文件。这是一个很棒的新功能，它为我们提供了代码作为管道的功能，详细说明请见这里：[https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm](https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm)。
- en: With that we can keep our application code and the Jenkins pipeline definition
    conveniently together under revision control.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以方便地将应用程序代码和Jenkins管道定义一起放在版本控制中。
- en: After we save the pipeline job, Jenkins will start polling the Git repository
    and trigger an execution whenever a change is detected (or you can click on **Build
    Now** to force a run).
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 保存管道作业后，Jenkins将开始轮询Git仓库，并在检测到更改时触发执行（或者你可以点击**立即构建**强制执行一次）。
- en: Each successful build will result in an RPM package uploaded to our YUM repository.
    Go ahead and experiment, breaking the build by changing the `demo-app` source
    code so that the test fails.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 每次成功构建后，都会将一个RPM包上传到我们的YUM仓库。继续进行实验，通过修改`demo-app`源代码来破坏构建，使得测试失败。
- en: 'To troubleshoot, look at the **Build History** list, select the job that failed
    and examine its **Console Output**:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要进行故障排除，请查看**构建历史**列表，选择失败的作业，并检查其**控制台输出**：
- en: '![Setting up the pipeline](img/image_04_010.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![设置管道](img/image_04_010.jpg)'
- en: 'Now that you are familiar with our example pipeline, I encourage you to expand
    it: Add more stages to it, make some of the tasks execute in parallel, enable
    chat or email notifications, or link pipelines so they trigger each other.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉了我们的示例管道，我鼓励你扩展它：添加更多的阶段，让一些任务并行执行，启用聊天或电子邮件通知，或者链接管道让它们触发彼此。
- en: You will appreciate the benefits of implementing a CI server as you continue
    to convert more of your daily, manual routines to Jenkins jobs.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你将更多日常手动操作转化为Jenkins作业，你将会体会到实施CI服务器的好处。
- en: You can be sure your teammates will love it too.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以放心，你的团队成员也会喜欢这个。
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please remember to delete any AWS resources used in the preceding examples (VPC,
    EC2, S3, IAM, CodeCommit, etcetera) to avoid unnecessary charges.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请记得删除之前示例中使用的任何AWS资源（如VPC、EC2、S3、IAM、CodeCommit等），以避免不必要的费用。
- en: Summary
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter we studied examples of how to launch and configure a Continuous
    Integration environment on AWS.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们研究了如何在AWS上启动和配置持续集成环境的示例。
- en: We used our previous Terraform and SaltStack knowledge to prepare the AWS infrastructure.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用之前的Terraform和SaltStack知识来准备AWS基础设施。
- en: With the help of Jenkins CI we composed a pipeline that would take application
    source code, run tests against it, build an RPM package and deposit that into
    a remote YUM repository for later use.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在Jenkins CI的帮助下，我们构建了一个管道，它会获取应用程序源代码，对其进行测试，构建RPM包，并将其存储到远程YUM仓库中以备后用。
- en: Our next topic will be on Continuous Delivery, an extension to Continuous Integration
    which takes us a step closer to being ready to deploy our application to a production
    environment with confidence.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的下一个主题将是持续交付，这是持续集成的扩展，它让我们更接近能够有信心地将应用程序部署到生产环境。
