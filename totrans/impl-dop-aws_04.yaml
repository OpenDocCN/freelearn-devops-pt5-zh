- en: Chapter 4. Build, Test, and Release Faster with Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The emphasis of this chapter will be the value of quick iteration: Quick over
    quality iteration, as per Boyd''s law (you might recall the OODA principle mentioned
    in [Chapter 1](ch01.html "Chapter 1. What is DevOps and Should You Care?"), *What
    Is DevOps and Should You Care?*).'
  prefs: []
  type: TYPE_NORMAL
- en: By iteration, I am referring to a software development cycle, from the moment
    a piece of code is written, published (committed to version control), compiled
    (if needed), tested and finally deployed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous Integration** (**CI**) defines the routines that should be adopted
    by developers plus the necessary tools to make this iteration as fast as possible.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start with the human factor:'
  prefs: []
  type: TYPE_NORMAL
- en: Use version control (for example Git)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commit smaller changes, more often
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test locally first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do peer code reviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pause other team activity until an issue is resolved
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then add a bit of automation (a CI server):'
  prefs: []
  type: TYPE_NORMAL
- en: Monitor for version control changes (for example Git commits)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pull down changed code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compile and run tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On success, build an artefact
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: On failure, notify the team and pause the pipeline
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Committing smaller changes helps detect problems earlier and potentially solves
    them much more easily; and a developer receives feedback on their work more frequently
    which builds confidence that their code is in a good state.
  prefs: []
  type: TYPE_NORMAL
- en: Testing locally, where possible, greatly reduces team distraction caused by
    the CI pipeline tripping over minor issues.
  prefs: []
  type: TYPE_NORMAL
- en: Code reviews are beneficial at many levels. They eliminate bad coding habits
    as peers ensure code complies with agreed standards. They increase visibility;
    peers get a lot more exposure to the work of others. They help catch the errors
    which a machine would miss.
  prefs: []
  type: TYPE_NORMAL
- en: The **Toyota Way** teaches us to *Stop the Line* whenever a problem is detected.
    In terms of CI, this translates into halting the pipeline on errors and concentrating
    resources on fixing these. At first this might seem like an obvious way to reduce
    productivity and slow down the whole process, but it's been proven again and again
    that the initial overhead is ultimately worth it. This way you keep your technical
    debt to a minimum; improve code as-you-go, preventing issues from accumulating
    and re-surfacing at a later stage. Now is a good time to restate the **test locally**
    point made earlier. You would likely not want to interrupt your colleagues with
    something trivial, which could have been spotted easily before committing.
  prefs: []
  type: TYPE_NORMAL
- en: As you succeed in building this team discipline (the hard part), it is time
    to add some automation flavor by setting up a CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The CI server tirelessly monitors your code repository and reacts to changes
    by performing a set of tasks over and over again. I believe it is evident how
    this saves engineers a great amount of time and effort, not to mention the fact
    that they avoid having to address the monotone nature of such work.
  prefs: []
  type: TYPE_NORMAL
- en: 'A pipeline, say in Jenkins, would normally consist of a number of stages: individual
    stages can represent the checking out of the latest code, running build tasks
    on it, performing tests then building artefacts, where each stage runs subject
    to the previous one completing successfully.'
  prefs: []
  type: TYPE_NORMAL
- en: This generally describes how a combination of engineer habits and some tooling
    can greatly improve a software development cycle. Continuous Integration helps
    us collaborate better, write better code, ship more often and get feedback quicker.
  prefs: []
  type: TYPE_NORMAL
- en: Users want new features released fast, developers want to see the result of
    their work out there - everybody wins.
  prefs: []
  type: TYPE_NORMAL
- en: We have discussed the theory, now let us bring our focus to the title of this
    chapter. We are going to use our acquired Terraform and Salt skills to deploy
    a CI environment on AWS featuring a Jenkins (v2) CI server.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jenkins (ref: [https://jenkins.io](https://jenkins.io)) is a popular, well
    established open source project focusing on automation. It comes with a long list
    of integrations, catering to a variety of platforms and programming languages.
    Meet Jenkins: [https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins](https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The deployment of our CI environment can be broken down into three main stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Prepare an **Infrastructure as Code** deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write **Terraform** templates to provision a VPC and an EC2 instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Write **Salt** States to install Jenkins, NGINX and other software onto the
    EC2 instance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploy IaC:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the Terraform templates and Salt States
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setup CI:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure a Jenkins pipeline for Continuous Integration of a demo application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Prepare IaC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In accordance with our *Infrastructure as Code* principles, this deployment
    will also be mostly template driven. We will try to reuse some of the Terraform
    and Salt code from previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this particular setup we can simplify our template as we will only need
    the VPC, some networking bits, and an EC2 instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s browse through the files in our *TF* repository:'
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The few variables we need can be grouped into VPC and EC2 related ones:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: '**VPC**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '**EC2**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Variables (values)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Following the bare variable definitions, we now supply some values:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars).'
  prefs: []
  type: TYPE_NORMAL
- en: '**VPC**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll keep our deployment in US East:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '**EC2**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A Nano instance will be sufficient for testing. Ensure the referenced key-pair
    exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: Create the VPC
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As a matter of standard (good) practice we create all our resources inside
    a VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Add networking components
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We add a gateway, a route table, and an Internet facing subnet from where our
    Jenkins instance will be launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IGW**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '**Route table**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '**Subnet**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Add EC2 node and related resources
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The security group for our Jenkins node needs to permit HTTP/S access plus
    SSH for convenience, so that we can access the command line if needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security Group**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '**IAM Role**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use an IAM Role to grant Jenkins access to AWS services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '**IAM Role Policy**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This policy will allow Jenkins to read from a codecommit repository and perform
    all actions (except deleting) on an s3 bucket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '**IAM Profile**'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '**EC2 instance**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here we define a single instance along with its bootstrap UserData script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here we set the attributes needed to launch an EC2 instance, such as the instance
    type, the AMI to be used, security group(s), subnet and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the bootstrap shell script to help us install required packages,
    checkout Git repositories and run Salt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '**Elastic IP**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we provision a static IP for Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Outputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some useful outputs to provide us with the address of the Jenkins node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: And that is our VPC infrastructure defined. Now we can move onto Salt and the
    application stack.
  prefs: []
  type: TYPE_NORMAL
- en: SaltStack code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You'll remember our favorite Configuration Management tool from the previous
    chapter. We will use SaltStack to configure the EC2 Jenkins node for us.
  prefs: []
  type: TYPE_NORMAL
- en: States
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states).'
  prefs: []
  type: TYPE_NORMAL
- en: '**top.sls**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are working with a single minion, and all our states apply to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '**users**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We add a Linux user account, configure its SSH keys and **sudo** access:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '**yum-s3**'
  prefs: []
  type: TYPE_NORMAL
- en: 'As part of our CI pipeline, we will be storing RPM artefacts in S3\. Cob (ref:
    [https://github.com/henrysher/cob](https://github.com/henrysher/cob)) is a Yum
    package manager plugin which makes it possible to access S3 based RPM repositories
    using an IAM Role.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We deploy the plugin, its configuration and a repository definition (disabled
    for now) as managed files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '**Jenkins**'
  prefs: []
  type: TYPE_NORMAL
- en: Here comes the lead character – Mr Jenkins. We make use of Docker in our CI
    pipeline, hence the `include` following. Docker allows us to run the different
    pipeline steps in isolation, which makes dependency management much easier and
    helps keeps the Jenkins node clean.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Also we ensure Java and a few other prerequisites get installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, install Jenkins itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '**NGINX**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use NGINX as a reverse proxy and an SSL termination point. That is
    not to say that Jenkins cannot serve on its own, it is just considered better
    practice to separate the roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '**Docker**'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is about time we mentioned Docker, given its (deserved) popularity nowadays.
    It is very well suited to our CI needs, providing isolated environments for the
    various tests and builds that may be required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Pillars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars).'
  prefs: []
  type: TYPE_NORMAL
- en: '**top.sls**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our standalone minion gets it all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '**users**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting a password hash and a consistent UID for the Linux account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**NGINX**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We store the SSL data in this Pillar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Minion configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d).'
  prefs: []
  type: TYPE_NORMAL
- en: '**masterless.conf**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are still using Salt in standalone (masterless) mode, so this is our extra
    `minion` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to all of the preceding codes, we should be able to run Terraform and
    end up with a Jenkins service ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Let us give that a try.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy IaC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We start by creating a Terraform EC2 key-pair and a Terraform IAM user as in
    previous chapters (do not forget to write down access/secret API keys). Then we
    grant permissions to the IAM user to perform actions with the EC2, IAM, S3 and
    CodeCommit services:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Then we associate a SSH public key with the user (as per the screenshots in
    the previous chapter) to allow `codecommit` repository access.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to setup our AWS CLI environment with the keys we produced earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we should be able to use the CLI tool and create our SaltStack repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We clone the repository locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: (where `SSH_KEY_ID` is the one we saw after uploading a public key here)
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can copy the ready salt code examples for this chapter, commit
    and push to the `codecommit` repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the SaltStack repo in sync, we can proceed with Terraform and the bootstrap
    process. Inside our TF templates folder we run the familiar command sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At the end we get the IP of our Jenkins node which we would need to resolve
    into a hostname (for example via the `nslookup` cmd). Load that in your browser
    and you should be greeted by Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Setup CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After a successful Terraform deployment, it is time to move onto service configuration.
    More specifically, Jenkins and the integration pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With Jenkins running for the first time, we need to complete a short setup
    routine. First, we need to SSH into the node and retrieve the admin password stored
    in `/var/lib/jenkins/secrets/initialAdminPassword`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins initialization](img/image_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are mainly interested in the pipeline group of plugins which is included
    with the suggested ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins initialization](img/image_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the plugins installation has completed, it''s time to create our first
    user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins initialization](img/image_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this the initialization process is complete and Jenkins is ready for use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jenkins initialization](img/image_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing a demo app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before configuring the CI pipeline, it will help to have something to do some
    integration on. A basic Hello World type of PHP code will do, so with a sincere
    apology to all PHP developers out there, I present you with the source of our
    demo app:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: There is a third file in our `demo-app` folder curiously named `Jenkinsfile`
    which we will discuss shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let us get our code into a repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we place our `demo-app` code into the empty repository, commit and
    push all changes to codecommit.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is time to decide on what the CI pipeline is meant to do for us. Here is
    a list of useful steps as a start:'
  prefs: []
  type: TYPE_NORMAL
- en: Checkout application source code from Git
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run tests against it by running PHPUnit inside a Docker container (on the Jenkins
    host)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build application artefacts by executing FPM within a container on the Jenkins
    host
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload artefacts to an external store (for example, a Yum repository)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Translated into Jenkins pipeline code:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Generally speaking, defining a pipeline consists of a setting out a series
    of tasks/stages. Let us review each of the preceding stages:'
  prefs: []
  type: TYPE_NORMAL
- en: We start with a Git checkout of our `demo-app` code. The repository address
    is assumed to be the one of the `Jenkinsfile`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the next stage we take advantage of Docker''s isolation and spin up a container
    with everything needed for PHPUnit (ref: https://phpunit.de) to run a test against
    our `demo-app` source code. Take a look in the `tests/` folder under `${GIT_URL}/Examples/Chapter-4/CodeCommit/demo-app/`
    if you would like to add more or modify it further.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If the tests pass, we move onto building an RPM artefact using a neat, user-friendly
    tool called FPM (ref: https://github.com/jordansissel/fpm), again in a Docker
    container. We use the short `git commit hash` as the version identifier for our
    demo-app.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We move our RPM artefact to a designated repository folder, create a YUM repository
    out of it using `createrepo` and sync all that data to an Amazon S3 bucket. The
    idea is to use this S3 based YUM repository later on for deploying our `demo-app`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, as a bonus, we check that the package we just synced can be retrieved
    via YUM.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our pipeline is now defined but before we can run it, we need to satisfy one
    (S3) dependency. We need to create a S3 bucket to store the RPM artefacts that the
    pipeline would produce. Then we need to update parts of the Jenkins and Saltstack
    code with the address of that S3 bucket.
  prefs: []
  type: TYPE_NORMAL
- en: 'To interact with S3, we shall use the AWS CLI tool within the environment we
    configured for Terraform earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The bucket name is up to you, but keep in mind that the global S3 namespace
    is shared, so the more unique the name the better.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we update our pipeline definition (`Jenkinsfile`). Look for the line
    containing `MY_BUCKET_NAME`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to update SaltStack (again replacing `MY_BUCKET_NAME`):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This `repo` file will be used in the last stage of our pipeline, as we will
    see in a moment. At this point you will need to commit and push both changes:
    the `Jenkinsfile` to the `demo-app` repository and the `s3.repo` file to the SaltStack
    one. Then you would SSH into the Jenkins node, pull and apply the Salt changes.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Back to the Jenkins interface. After logging in, we click on the `create new
    jobs` link on the welcome page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pipeline](img/image_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We select **Pipeline** as a job type and pick a name for it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pipeline](img/image_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next screen takes us to the job configuration details. At the top we choose
    to **Discard old builds** in order to keep our Jenkins workspace compact. We are
    saying, only keep details of the last five executions of this job:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pipeline](img/image_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Under **Build Triggers** we choose to poll our Git repository for changes every
    5 minutes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pipeline](img/image_04_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Underneath, we choose **Pipeline script from SCM**, set SCM to **Git** and
    add the URL of our `demo-app` repository (that is [https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app)
    ) to be polled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pipeline](img/image_04_009.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'No need for extra credentials as these will be fetched via the EC2 IAM Role.
    Note the **Script Path** referencing the Jenkins file we mentioned earlier. This
    is a great new feature which gives us pipeline as code functionality as described
    here: [https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm](https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm).'
  prefs: []
  type: TYPE_NORMAL
- en: With that we can keep our application code and the Jenkins pipeline definition
    conveniently together under revision control.
  prefs: []
  type: TYPE_NORMAL
- en: After we save the pipeline job, Jenkins will start polling the Git repository
    and trigger an execution whenever a change is detected (or you can click on **Build
    Now** to force a run).
  prefs: []
  type: TYPE_NORMAL
- en: Each successful build will result in an RPM package uploaded to our YUM repository.
    Go ahead and experiment, breaking the build by changing the `demo-app` source
    code so that the test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To troubleshoot, look at the **Build History** list, select the job that failed
    and examine its **Console Output**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the pipeline](img/image_04_010.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now that you are familiar with our example pipeline, I encourage you to expand
    it: Add more stages to it, make some of the tasks execute in parallel, enable
    chat or email notifications, or link pipelines so they trigger each other.'
  prefs: []
  type: TYPE_NORMAL
- en: You will appreciate the benefits of implementing a CI server as you continue
    to convert more of your daily, manual routines to Jenkins jobs.
  prefs: []
  type: TYPE_NORMAL
- en: You can be sure your teammates will love it too.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please remember to delete any AWS resources used in the preceding examples (VPC,
    EC2, S3, IAM, CodeCommit, etcetera) to avoid unnecessary charges.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we studied examples of how to launch and configure a Continuous
    Integration environment on AWS.
  prefs: []
  type: TYPE_NORMAL
- en: We used our previous Terraform and SaltStack knowledge to prepare the AWS infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: With the help of Jenkins CI we composed a pipeline that would take application
    source code, run tests against it, build an RPM package and deposit that into
    a remote YUM repository for later use.
  prefs: []
  type: TYPE_NORMAL
- en: Our next topic will be on Continuous Delivery, an extension to Continuous Integration
    which takes us a step closer to being ready to deploy our application to a production
    environment with confidence.
  prefs: []
  type: TYPE_NORMAL
