- en: Installing, Configuring, and Running Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a relatively new addition to the DevOps and Configuration Management
    ecosystem. Its radical simplicity, structured automation format, and no brainer
    development paradigm has caught the eyes of both corporations and startups alike.
    Organizations such as Twitter have managed to successfully leverage Ansible for
    highly scaled deployments and Configuration Management implementations across,
    and have scaled it to manage and deploy to thousands of servers simultaneously.
    Twitter isn't the only player within the Ansible space that has managed to leverage
    Ansible at scale; other well-known organizations that have successfully leveraged
    Ansible include Logitech, NASA, NEC, Microsoft, and hundreds more.
  prefs: []
  type: TYPE_NORMAL
- en: As it stands today, Ansible is in use by some of the largest and well known
    technology companies and organizations around the world, and is responsible for
    managing thousands of deployments and maintaining the Configuration Management
    solutions for countless organizations. Learning the fundamentals of the Ansible
    solution will provide us with the tools we will need to properly install, configure
    and run Ansible at small and large scales.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will formally introduce you to Ansible. Together we will
    learn how to install it, dive into its run-time architectures, and learn how to
    configure it to run simple automation sequences. In addition to these topics,
    we will cover the basics of the Ansible control server under Ubuntu Linux and
    learn how Ansible can be leveraged for local executions as well as remote management.
    Finally in this chapter, we will cover the basic concept of a playbook and discover
    the underlying constructs behind what makes Ansible so powerful. The goals for
    this chapter will be to grasp the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible Command Line Interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible Inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we have the introductions out of the way let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Installing Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible itself is cross-platform. The basic installation of the Ansible system
    is actually fairly easy. Before we can install it, we need to get the Ansible
    runtime packages. Ansible is available for consumption via the following online
    solutions:'
  prefs: []
  type: TYPE_NORMAL
- en: Yum (Red Hat Linux-based distributions)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apt (Debian)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apt (Ubuntu)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Portage (Gentoo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pkg (FreeBSD)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS (dmg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: OpenCSW (Solaris)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pacman (Arch Linux)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pip (Python)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tarball (Source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Source (Source)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The following is a set of examples and command-line syntaxes for each of the
    listed options. These commands will help you get up-and-running with Ansible quickly
    (they are taken from the Ansible website).
  prefs: []
  type: TYPE_NORMAL
- en: Red Hat Enterprise Linux via Configuration Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Ansible on most popular Red Hat Enterprise Linux flavor distributions
    is quite easy. This can be accomplished as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Apt for Debian/Apt for Ubuntu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Installing Ansible on Debian or Ubuntu flavor Linux distributions is a breeze.
    This can be accomplished using the Apt package management solution as shown in
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Porting Ansible to Gentoo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For Gentoo Linux users, installing Ansible can be accomplished fairly easily.
    The following command-line syntax can be leveraged to accomplish the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: PKG for FreeBSD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'FreeBSD-specific users can use `pkg install` to install the Ansible control
    server solution and get Ansible up-and-running quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Pip for macOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The preferred way to install Ansible for macOS is to use Python's pip installation
    solution. An example of how to do this is provided next.
  prefs: []
  type: TYPE_NORMAL
- en: 'If needed, you can install `pip` via the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `pip` is installed, you can install Ansible with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: OpenCSW for Solaris/SunOS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Solaris users have the ability to install and configure Ansible using the OpenCSW
    package management solution. This solution can be leveraged as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Installing Ansible for Arch Linux is quite simple. The following command should
    help accomplish this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Via Python pip
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prior to installing Ansible using pip we may need to actually install pip.
    To accomplish this on the command line, the following command can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then install Ansible with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Once Ansible has been installed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once Ansible is installed on the desired Linux machine, we will want to verify
    that it is properly installed and functioning. To do this from the command line,
    enter the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Upon successful execution of these commands, Ansible should output version information
    and related help information respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up authentication between the control server and hosts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When connecting Ansible with remote hosts, Ansible's best practices encourage
    the use of SSH key sharing. SSH keys allow one Linux host to talk to another without
    asking for a specific password. In this section we are going to briefly look at
    how to set SSH key sharing up on the control server and *n* number of target machines.
  prefs: []
  type: TYPE_NORMAL
- en: If SSH key Sharing is not available Ansible also offers the option to ask for
    a password using the `--ask-become-pass` command-line argument.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create a `/etc/ansible/hosts` (if it doesn't exist) and add
    one or more remote systems into its contents. Your specific public SSH key should
    be located in `authorized_keys` on those target systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this brief tutorial we will assume the SSH key authentication solution is
    being used. It helps us avoid having to enter or store raw passwords:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now ping all the nodes (assumes you have an inventory file created):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: For a complete documentation set around setting up SSH key sharing in Ubuntu
    the documentation can be found at [http://linuxproblem.org/art_9.html](http://linuxproblem.org/art_9.html).
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible was created with an incredibly flexible and scalable automation engine.
    It allows users to leverage it in many diverse ways and can be adapted to be used
    in the way that best suits your specific needs. Since Ansible is agentless (meaning
    there is no permanently running daemon on the systems it manages or executes from),
    it can be used locally to control a single system (without any network connectivity)
    or leveraged to orchestrate and execute automation against many systems, via a
    control server.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the aforementioned architectures, Ansible can also be leveraged
    via Vagrant or Docker to provision infrastructure automatically. This type of
    solution basically allows Ansible users to bootstrap their hardware or infrastructure
    provisioning by running one or more Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you happen to be a Vagrant user, there are instructions within the HashiCorp
    Ansible provisioning located at the following URL: [https://www.vagrantup.com/docs/provisioning/ansible.html](https://www.vagrantup.com/docs/provisioning/ansible.html).'
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned briefly, Ansible is open source, module-based, pluggable, and
    agentless. These key differentiators from other Configuration Management solutions
    give Ansible a significant edge. Let's take a look at each of these differentiators
    in detail and see what it actually means for Ansible developers and users.
  prefs: []
  type: TYPE_NORMAL
- en: Open source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is no secret that successful open source solutions are usually extraordinarily
    feature-rich. This is because, instead of a simple eight-person (or even 100-person)
    engineering team, there are potentially thousands of developers. Each development
    and enhancement has been designed to fit a unique need. As a result, the end deliverable
    product provides consumers of Ansible with a very well-rounded solution that can
    be adapted or leveraged in numerous ways.
  prefs: []
  type: TYPE_NORMAL
- en: Module-based
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible has been developed for integration with numerous other open and closed
    source software solutions. This idea means that Ansible is currently compatible
    with multiple flavors of Linux, Windows, and cloud providers. Aside from its OS-level
    support, Ansible currently integrates with hundreds of other software solutions:
    EC2, JIRA, Jenkins, Bamboo, Microsoft Azure, DigitalOcean, Docker, Google, and
    many more.'
  prefs: []
  type: TYPE_NORMAL
- en: "For a complete list of Ansible modules, consult the official Ansible module\
    \ support list located at the following URL: [http://docs.ansible.com/ansible/modules_by_category.html](http://docs.ansible.com/ansible/modules_by_category.html)\uFEFF\
    ."
  prefs: []
  type: TYPE_NORMAL
- en: Agentless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key differentiators that gives Ansible an edge against the competition
    is the fact that it is completely agentless. This means there are no daemons that
    need to be installed on remote machines, no firewall ports that need to be opened
    (besides traditional SSH), no monitoring that needs to be performed on remote
    machines, and no management that needs to be performed on the infrastructure fleet.
    In effect, this makes Ansible very self-sufficient.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ansible can be implemented in a few different ways, the aim of this section
    is to highlight these options and help get us familiar with the architecture types
    that Ansible supports. Generally, the architecture of Ansible can be categorized
    into three distinct architecture types. These are described next.
  prefs: []
  type: TYPE_NORMAL
- en: Pluggable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While Ansible comes out-of-the-box with a wide spectrum of software integration
    support, it is oftentimes a requirement to integrate the solution with a company-based
    internal software solution or a software solution that has not already been integrated
    into Ansible's robust playbook suite. The answer to such a requirement would be
    to create a plugin-based solution for Ansible, thus providing the custom functionality
    necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Local automation execution using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to leverage Ansible is to instruct it to manage a local system.
    This means there is no need for SSH connections or port openings or SSH key sharing
    to be done. This implementation simply involves one user, a set of playbooks (or
    one), and a local system. Local automation execution is the scenario in which
    Ansible is leveraged to execute a playbook (a series of automation tasks) against
    a local machine. This specific architecture type means that Ansible does not need
    an available network connection or internet connection for it to perform its work.
  prefs: []
  type: TYPE_NORMAL
- en: 'This architecture type is diagrammed next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02a14c66-a572-400a-b83a-d16a907c27d1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the diagram, Ansible can be used for local provisioning.
    This architecture may seem a bit unscalable, but with a bit of creativity, there
    is a significant amount of power behind this specific architecture. Let''s take
    a look at some of the various ways in which this specific architecture can be
    applied:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To locally provision a development environment and configure it to be a single
    click setup: ideally with this approach, Ansible playbooks will be written and
    stored in the local development source control system and then leveraged by new
    developers to setup and configure their development environments. This will save
    a significant amount of time on-boarding and getting an employee started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To enforce local infrastructure-provisioning rules and revert changes made
    to the system that were done out of band: this solution would be ideal for enforcing
    infrastructure that gets tampered with or altered accidentally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To execute a set of timed automations that could be leveraged to perform automated
    routines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see from the architecture, Ansible''s local execution gives us the
    ability to execute a playbook against a localized system without any fuss or complexity.
    Let''s take a quick look at how to run an Ansible playbook against a local system
    using the command line. To begin though, let''s learn how to run an ad hoc command
    against a local system. The example is provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The command simply tells Ansible to target all systems in the ad hoc inventory
    implementation (which in our simple use case is only localhost), then execute
    the command `echo "hello DevOps world"` against this system. Simple, right? Now
    let''s take a look at how this same implementation might look if it were in Ansible
    playbook form. An example of this in playbook form is provided as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This example represents a very simple Ansible playbook. Ansible playbooks are
    written in **Yet Another Markup Language** (**YAML**). They are intended to be
    easy to read, easy to write, highly structured, and without complexity. The idea
    of a *playbook* in the Ansible world comes from the playbook one might receive
    when attending a broadway show. Playbooks describe in brief the upcoming scenes
    and actors. As such, Ansible playbooks also contain a list of upcoming events
    (defined as tasks, and the details of those events). In our simple example, we
    are telling Ansible to instruct the Linux shell (on the target system(s)) to display
    a simple introductory message: `hello DevOps world`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you may be wondering, *how does one run such a playbook?* I''m
    glad you asked. Playbooks can be run from the command line by specifying the playbook
    name. An example of this is provided here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Next let's take a look at remote automation execution. This methodology is significantly
    different from local execution as it allows for much larger scalability support.
  prefs: []
  type: TYPE_NORMAL
- en: Remote automation execution using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The most popular use of Ansible is through remote execution. This architecture
    requires a network connection and SSH or Windows remoting. By using remote execution,
    we are essentially instructing Ansible to reach out over SSH to one or many machines,
    authenticate using a previously shared SSH or RM key, create a temporary TCP connection
    to one or more remote machines, and execute a set of playbook-based automations
    against them. If this sounds a bit confusing, let's take a look in depth at how
    this architecture and automation solution works.
  prefs: []
  type: TYPE_NORMAL
- en: To begin with, as a local administrator, we will need to pre-authorize the preferred
    Ansible user with the target machines. By doing this pre-authentication, we are
    essentially (most commonly through SSH key sharing) configuring at least two Linux-oriented
    machines (the control and the target) with the permissions needed for the control
    server to communicate with and control the target machine without further authorization.
    Details on how to perform a basic SSH key-sharing implementation are covered later
    in this chapter (or can be found at [http://docs.ansible.com/ansible/intro_getting_started.html](http://docs.ansible.com/ansible/intro_getting_started.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Once key sharing has been implemented and has been verified as working, Ansible
    can effectively take control of the remote systems and execute automation against
    them. This is accomplished through a nifty self-installation solution provided
    by Ansible. Effectively, the Ansible automation system (upon execution) will copy
    itself over to the remote system, install itself on the remote system, run a specified
    set of playbooks on the target system, verify the results of the execution, and
    delete itself (and the playbook) from the target system. This leaves the system
    in the desired state without the need to maintain a running daemon on the target
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The remote automation execution architecture can be seen via the following
    illustration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e474c377-cd57-4561-a3b0-d0e493e60f31.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the previous diagram, the Linux control server (running Ansible)
    uses a set of secure protocols (**SSH** and **Windows RM** respectively) to control,
    automate, and configure the remote systems. These automation executions happen
    in parallel, meaning that Ansible has the ability to simultaneously control between
    1 and 10,000 machines without a significant degradation in performance.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a good idea of how a remote execution architecture works, let's
    take a look at a couple of examples. Ansible (as we discovered in the previous
    section) leverages playbooks to manage human-readable automation. In this first
    example, we will need two machines, both Linux based, with Ansible installed on
    the control server (see the previous diagram for which machine is the control
    server), and a target server with SSH keys shared so that the control server can
    properly control or manage the target.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now to create a playbook, simply edit a file title `hellodevopsworld.yml` and
    paste the following lines of code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file onto disk, in a location you prefer (we chose `/opt/hellodevopsworld.yml`).
    Next we will need to identify the IP address or `HOSTNAME/FQDN` of the target
    machine and run the playbook. For this example our target host is on `192.168.10.10`.
    Now let''s run the playbook against the target machine from the control server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'From this command, we should see Ansible execute the `hellowdevopsworld` playbook
    against the target machine (`192.168.10.10`) and the execution should output `hellodevopsworld`
    to the command-line interface. The following is the output we should see from
    the executions provided through Ansible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: By default Ansible is configured to to execute *all* automations in parallel.
    This can be altered by specifying the `--limit` option on the command line, which
    allows the administrator to limit the number of parallel executions to a specific
    number. This can be handy when you need to be able to debug a playbook or restrict
    the number of simultaneous executions.
  prefs: []
  type: TYPE_NORMAL
- en: Container-oriented automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Container-oriented automation is similar to local automation execution, although
    it leverages the Configuration Management and automation execution capabilities
    of Ansible on the container. This architecture is slightly different from the
    others in the sense that it does not rely on Ansible being installed on a given
    host or container prior to the execution of a playbook but rather installs Ansible
    on-the-fly (during the provisioning phase of the container) and then executes
    a playbook once Ansible is installed. As a result, the flow of automation would
    be better represented through a flow diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6aca378f-bdbe-4297-a7b6-8f00d4f1422a.png)'
  prefs: []
  type: TYPE_IMG
- en: Container-oriented automation can be especially useful for provisioning environments
    (development, testing, production, and so on) as well as helping get developers
    up and running quickly. Let's take a look at a quick Vagrant setup using Ansible
    as the bootstrapping solution within the VM.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, let''s log in to our local machine as the `root` user and create
    a directory setup to hold our local infrastructure. In this example, we are using
    a macOS machine with VirtualBox and Vagrant ([https://www.vagrantup.com/about.html](https://www.vagrantup.com/about.html))
    installed (and while these instructions are macOS-specific, they can be applied
    to Windows machines quite easily as well):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory, which will house our project, and change into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize Vagrant using the `vagrant init` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the newly created `Vagrantfile`, which should be now located at `~/Desktop/helloVagrantAnsible/Vagrantfile`,
    to reflect what is shown here (taken from the Ansible website):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the `Vagrantfile`, we are essentially configuring Vagrant
    to fire up and execute `playbook.yml` upon the initial fire-up. This implementation
    once understood is incredibly powerful as it provides us with a way of bootstrapping
    an infrastructure solution with Ansible as its provisioner. This implementation
    is ideal for developers or quality assurance engineers as it provides them with
    a way of storing their infrastructure as code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our `Vagrantfile`, let''s create `playbook.yml` in the same
    directory as the `Vagrantfile`. Its contents should reflect the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This playbook (as you may have guessed) simply installs Apache2 on the Ubuntu
    system we defined in our `vagrant init` command and tells Ansible to provision
    it with Apache enabled as a system service at boot.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in this tutorial is to simply run our Vagrant setup by typing
    the following command into our command-line window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: If everything was successful, you should be able to see your local Apache instance
    running within the VirtualBox provisioned and running through Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible Command-Line Interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible provides a robust command-line interface, which provides users with
    the ability to run Ansible playbooks, simulate the execution of Ansible playbooks,
    run ad hoc commands, and much more. In the Ansible galaxy (more to come on that
    specific pun later in the book), there are two specific types of Ansible commands
    that can be run. The `ansible` command allows users to run ad hoc commands, whereas
    the `ansible-playbook` command allows the user to execute a set of Ansible playbook
    instructions against the targeted infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: This is ambiguous within the documentation, Ansible and Ansible-playbook appear
    to be symlinks but there are some reports of different functionality between the
    two. More research is needed before final drafting to ensure accuracy of information
    reported. For now, there will be a section for Ansible and Ansible-playbook (provided
    in the following sections) but these may change going forward.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible command-line interface is the gateway into the heart of Ansible
    and provides a wide array of options and configurable switches that will help
    you gain the most out of Ansible. Let's take a quick tour of the Ansible command-line
    interface and see what the available switches and knobs do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Usage: ansible <host-pattern> [options]'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section we are going to take a look at the Ansible command-line patterns
    and see how they function. The implementation of the command line solution for
    Ansible is actually quite easy to understand. Let's take a look at a couple of
    easy examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--help` option will display a complete list of available command-line
    options. This is probably one of the most important command-line options within
    the Ansible CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we know how to use the `help` command let''s take a look at the `version`
    command. This command-line argument provides us with the version information for
    the Ansible installation we are using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ansible --version` command will output the version information for the
    installed copy of Ansible. For example, you might see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we understand the `version` command, let''s see how to check our playbook''s
    syntax and perform a test run of our playbook. This is accomplished through the
    `--check` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option allows you to see what some of the changes Ansible
    would have made would potentially be. This is a great way to simulate the execution
    of a playbook and is a wise first step before actually running one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Specifying an inventory on the command line is important. It is accomplished
    via the `-inventory-file` parameter. This command-line parameter allows us to
    specify a comma-separated list of hostnames that will be targeted by the execution
    of the playbook. This command line allows you to specify a path location to an
    Ansible inventory file (in YAML format). Inside it, you can specify the hostnames
    and groups that combined make up your infrastructure inventory (the host''s Ansible
    will be targeted during execution):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option instructs Ansible to display a list of targeted hosts
    for this execution. This can be useful when you have a large number of hosts separated
    into groups and you only want to target a subset of those hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option instructs Ansible to condense all logging output to
    one line. This includes the facts-gathering processes, task execution output,
    and all `STDOUT` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option instructs Ansible to pipe all output to a specific
    file instead of the traditional console location. Output in the file specified
    will be concatenated in the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option instructs Ansible to perform a syntax check on the
    specified playbook instead of executing it. This is useful for developers who
    want to ensure their playbook is in valid YAML format prior to execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option instructs Ansible to override the default timeout
    (in seconds) from 10 to another number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option instructs Ansible to use a remote user login instead
    of the default SSH shared keys approach when connecting to remote hosts. This
    can be useful if SSH access is not allowed when connecting to some hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'This command-line option instructs Ansible to add verbose logging to the output
    of the execution. This is handy when debugging specific host issues or odd behavior
    that isn''t expected from traditional execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For additional command-line options, consult the Ansible CLI online help or
    documentation. Additional online help can be found at [http://www.ansible.com](http://www.ansible.com).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible command-line examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a pretty good understanding of the various knobs that the
    Ansible command line provides, let''s take a look at a few examples of how to
    use them to enhance the execution of a playbook. The following examples show some
    basic ways in which Ansible can be leveraged to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Configuring Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible maintains a central configuration file, which is used to instruct Ansible
    on how to behave. Ansible''s primary configuration file should be located (for
    most Linux distributions) at the following location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This configuration file instructs Ansible on how to behave at runtime. During
    the pre-startup sequences of Ansible's execution, the configuration file is loaded
    into memory and sets a number of environmental flags. These flags and configuration
    options can help you customize the Ansible runtime. The following configuration
    is a snapshot of the `ansible.cfg` file.
  prefs: []
  type: TYPE_NORMAL
- en: Nearly all Ansible configuration options can be overridden via modifications
    in a playbook. Changes to this configuration file will give you the ability to
    set base functionality/configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The Ansible configuration file has a pretty detailed set of documentation items
    associated with each configurable option available. As such, it would be redundant
    to provide a complete configuration file walk-through within this section. Instead,
    let's take a look at the more commonly tweaked configuration options.
  prefs: []
  type: TYPE_NORMAL
- en: Common base configuration items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most common base configuration items are predefined within Ansible; these
    values however can be overridden through the `ansible.cfg` file and customized
    to suit your specific needs. To override any one of them, simply uncomment the
    line (by removing the `#` symbol in front). These configuration items are provided
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In addition to the base configuration overrides, Ansible has a few other interesting
    configuration tweaks that can be made to the base installation that provide some
    level of flexibility in its operational functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Disable host key checking (useful for auto provisioning new systems) by using
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, the system is configured to run Ansible playbooks as `root`; however,
    this is not always desirable. To alter this, simply uncomment the following line
    and specify the user you would like to use instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes disabling logging is a good thing (for those with limited space options).
    To disable logging, change the following configuration item:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible Inventory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible maintains a central configuration file, which is used to identify and
    maintain the infrastructure identifications. This inventory file allows the Ansible
    administrator/ playbook to easily list, group, and target infrastructure items
    during execution. The default Ansible inventory file created (upon installation
    of Ansible) is `/etc/ansible/hosts`. Inside it are a few examples of basic inventory
    grouping structures and organizational categories for infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, the Ansible inventory file can be leveraged to organize hosts in
    a couple of specific ways: as a set of defined groups, or as a set of defined
    infrastructure pieces (loosely defined and not in a specific group). The inventory
    file can leverage either of the previously described methods or a combination
    of the two. Let''s look in greater detail on how these two inventory organization
    systems operate.'
  prefs: []
  type: TYPE_NORMAL
- en: Defined inventory groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides a robust and feature-rich mechanism for managing the information
    related to the infrastructure it controls. Specifically, inventory files can be
    created to define the infrastructure that will be managed by Ansible. An Ansible
    inventory file as you may have guessed is also in YAML format. Inventory items
    (such as servers or devices) are typically defined within the inventory file and
    are often organized into logically respective groups. An example of these types
    of groups (with inventory items defined within) is shown within the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Based on this information, we can see there are two groups: a web server and
    a database server group. These groups each have two unique servers assigned to
    them and as such provide us with the ability to target either or both groups of
    infrastructure by group name.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible inventory items don't have to be unique to one group specifically. Ansible
    supports the idea that hostnames or IPs can belong to one or many groups. For
    example, a hostname may exist both in the web server group and the database group.
    This adds significant flexibility within the Ansible playbook execution system.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible by nature allows this grouping to be targeted asynchronously. This means
    that the automation can be executed in parallel across either group to target
    a specific group specified in the hosts inventory file.
  prefs: []
  type: TYPE_NORMAL
- en: Loose inventory items/hosts/devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible provides the ability to not group any specific hosts that you want.
    Or mix and match grouped hosts with ''loose hosts''. This functionality allows
    the Ansible developer or user to simply add raw hostnames into the inventory host
    file and not attach it to a specific group. For this specific implementation,
    the hosts file would look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: As you can see from the screenshot, the raw entries that are not grouped are
    simply organized by IP address or hostname at the top of the inventory hosts file.
    This allows you to target these hosts by default automatically and without specifying
    a targeted group name on the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Executing playbook's and targeting specific inventory files and groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a set of inventory groups or raw inventory items defined,
    the next step is to see how to call Ansible and target a specific set of groups
    or even inventory files (if different from the default `/etc/Ansible/hosts` file).
    This functionality is incredibly important as we gain experience using Ansible.
    Let''s take a look at how to target specific groups first. The following example
    provides a simple example of an Ansible command line that executes a playbook
    against a grouped inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: As we can see from the example, we can execute Ansible playbooks against specific
    infrastructure groups. The outcome of these executions is the execution of a set
    of automated tasks against the group's infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed the various architecture types that Ansible provides,
    we talked about how inventory files work, and how to target specific groups and
    servers using the `-l` command. We also talked about how to install, set up, and
    configure Ansible to work under most common conditions. In our examples we look
    at a lot of Ubuntu specific implementations but the conversion to other OS's should
    be easy.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn all about playbook files and inventory file
    extensibility as well as how to create additional inventory files to help manage
    your infrastructure more effectively. Playbook's represent the heart and soul
    of the Ansible platform and instruct it on how to behave on a given server or
    infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: By the time we complete the next chapter, we should begin to have the skills
    you will need to write a playbook and execute it against one of a few machines.
    In addition, you should be able to perform most basic Configuration Management
    and deployment tasks using Ansible. Also, upon completing this chapter, you should
    have a solid understanding of how Ansible inventories work and how to effectively
    create groups and manage infrastructure at scale.
  prefs: []
  type: TYPE_NORMAL
