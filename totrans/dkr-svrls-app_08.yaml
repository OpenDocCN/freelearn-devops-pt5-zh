- en: Putting Them All Together
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有内容整合在一起
- en: In this chapter, we will walk through an example to demonstrate serverless platforms
    working together on a Docker cluster, and we will demonstrate several serverless/FaaS
    use cases.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将通过一个示例演示如何在Docker集群上让无服务器平台协同工作，并展示几个无服务器/FaaS的使用案例。
- en: We will discuss a mobile payment scenario and implement it using functions but,
    unusually at this level of infrastructure, we will connect all three FaaS platforms
    together. The main ideas demonstrated by the content of this chapter are the concept
    of using functions as a **Glue**, using functions to wrap the legacy web-based
    application, and using functions as a data stream processing program.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论一个移动支付场景，并通过函数实现它，但不同于以往在这种基础设施层次下，我们将把三个FaaS平台连接在一起。本章的主要思想是使用函数作为**粘合剂**，使用函数封装传统的基于Web的应用程序，以及将函数作为数据流处理程序。
- en: In the next section, we will start with the settings and scenario used by this
    chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将从本章所使用的设置和场景开始。
- en: 'The topics covered in this chapter are:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题有：
- en: A mobile payment scenario
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个移动支付场景
- en: A Parse platform as a backend
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parse平台作为后端
- en: Preparing a WebHook in Fn
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fn中准备WebHook
- en: An event state machine with a blockchain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带区块链的事件状态机
- en: Wrapping a legacy with a function
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数包装传统系统
- en: Using a function as a Glue
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用函数作为粘合剂
- en: A stream processor
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个流处理器
- en: Inter-FaaS platform networking
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跨FaaS平台的网络连接
- en: A mobile payment scenario
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个移动支付场景
- en: We are using a mobile payment with a money transfer allowed between two banks
    as the scenario for this chapter. With the money transfer, the business logic
    is easy to understand. So, we do not need to worry about this part. Let's focus
    on the complexity of the architecture.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用一个允许两家银行之间进行资金转账的移动支付场景作为本章的案例。对于资金转账，业务逻辑很容易理解。因此，我们无需担心这一部分。我们将集中精力在架构的复杂性上。
- en: 'Money transfer between two different banks with different underlying implementations
    is hard. This is because we cannot directly apply the *concept of traditional
    transactions* to cope with external systems. The system is presented in the following
    diagram:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在两家不同银行之间进行资金转账，并且两家银行有不同的底层实现是困难的。这是因为我们不能直接应用*传统交易的概念*来应对外部系统。系统的结构如下图所示：
- en: '![](img/57635715-e3eb-4413-88e3-e60b8ef6b792.png)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57635715-e3eb-4413-88e3-e60b8ef6b792.png)'
- en: 'Figure 8.1: The overall block diagram of the mobile payment system'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1：移动支付系统的总体框架图
- en: What are we not covering in this chapter?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章没有涵盖哪些内容？
- en: The UI parts are out beyond scope of this book, so they are not available. The
    **Receipt Generator** and the **Receipt Storage** are optional. They are left
    for you to implement, if interested.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的范围不包括用户界面部分，因此它们不可用。**收据生成器**和**收据存储**是可选的。如果有兴趣，你可以自行实现它们。
- en: 'What do we implement and demonstrate? Let''s discuss:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要实现并演示什么？我们来讨论一下：
- en: The Parse platform, as a backend for the UI.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parse平台作为UI的后端。
- en: The **Bank Routing** function. It is written in Java and deployed on Fn. This
    component is called `routing_fn`.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**银行路由**函数。它是用Java编写的，并部署在Fn上。这个组件叫做`routing_fn`。'
- en: '**Bank #1** and its function calling to a legacy web-based system. The function
    here is written in Node.js using the `chromeless` library ([https://github.com/graphcool/chromeless](https://github.com/graphcool/chromeless)).
    The function connects to a headless Chrome instance, our familiar web browser.
    The function drives Chrome to navigate and create a transaction for us on a real
    ERP system. We use Moqui as our ERP backend. Actually, Moqui comes with a complete
    set of REST APIs, but we intentionally use its web base to simulate the scenario
    where we need to modernize some legacy systems. The function of this part is called `hivectl`.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**银行#1**及其调用传统Web系统的函数。这里的函数是用Node.js编写的，并使用`chromeless`库（[https://github.com/graphcool/chromeless](https://github.com/graphcool/chromeless)）。该函数连接到无头的Chrome实例，也就是我们熟悉的Web浏览器。该函数驱动Chrome进行导航并在实际的ERP系统中为我们创建交易。我们使用Moqui作为我们的ERP后端。实际上，Moqui自带完整的REST
    API，但我们故意使用其Web界面来模拟需要现代化某些传统系统的场景。此部分的功能被称为`hivectl`。'
- en: '**Bank #2** and its function, `account_ctl`, connecting to a REST-based bank
    system. The function is written using `Go` and will be running on OpenWhisk. The
    mock bank server behind this component is a simple one written using the Grails/Spring
    Boot framework. We use this component to demonstrate how to write a FaaS function
    to wrap and simplify a REST-based API. The **Bank Routing** function, `routing_fn`,
    will be selectively called by each bank. This **Bank #2** component will be used
    together with **Bank #1** there.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**银行 #2** 及其功能 `account_ctl`，连接到基于 REST 的银行系统。该功能使用 `Go` 编写，并将在 OpenWhisk 上运行。该组件背后的模拟银行服务器是一个简单的服务器，使用
    Grails/Spring Boot 框架编写。我们使用这个组件来演示如何编写 FaaS 函数，以封装和简化基于 REST 的 API。**银行路由**功能
    `routing_fn` 将由每个银行选择性地调用。这个 **银行 #2** 组件将与 **银行 #1** 一起使用。'
- en: A set of smart contracts written in **Solidity** to maintain the mapping of
    mobile numbers to bank accounts. Also, another set of smart contracts will be
    used to maintain the state of the money transfer of each transaction.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一组用 **Solidity** 编写的智能合约，用于维护移动号码与银行账户的映射。此外，另一组智能合约将用于维护每笔交易的资金转移状态。
- en: An agent written in Java and the RxJava library to demonstrate a data stream
    processing component that calls a function and diverts the event to other parts
    of the system.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用 Java 编写的代理，并使用 RxJava 库演示一个数据流处理组件，该组件调用一个函数并将事件转发到系统的其他部分。
- en: A Parse platform as a backend
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作为后端的 Parse 平台
- en: What is Parse? Similar to Firebase, Parse is a **Backend as a Service** (**BaaS**)
    platform. With Parse, developers do not need to code the backend system themselves
    for their UIs or mobile applications. Parse is used by mobile application developers
    to help accelerate the development process. Together with the Parse dashboard,
    they provide an easy UI to craft all data entities, called *classes*, needed to
    process basic business logic.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 Parse？类似于 Firebase，Parse 是一个 **后端即服务**（**BaaS**）平台。使用 Parse，开发者无需为他们的 UI
    或移动应用程序编写后端系统代码。Parse 被移动应用程序开发者使用，以帮助加速开发过程。与 Parse 仪表盘一起，它们提供了一个简易的 UI，用于构建处理基本业务逻辑所需的所有数据实体，称为
    *类*。
- en: Preparation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Here''s how to create a Docker network and deploy a set of Docker compose files.
    We use the concept of metastack to deploy multiple stacks and have some labels
    and naming conventions to group them together:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何创建 Docker 网络并部署一组 Docker Compose 文件。我们使用元堆栈的概念来部署多个堆栈，并有一些标签和命名约定将它们组合在一起：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: While deploying things on production, we do not set up the network and volumes
    with any Docker compose files. All stacks should refer to external volumes and
    networks.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中部署时，我们不使用任何 Docker Compose 文件来设置网络和卷。所有堆栈都应引用外部卷和网络。
- en: 'Starting with MongoDB, we have already set up a volume for it. The following
    is the setup of the MongoDB server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 从 MongoDB 开始，我们已经为其设置了一个卷。以下是 MongoDB 服务器的设置：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We move to the next component, the Parse platform. To make the container work
    with Træfik, we put some labels to the service, saying that it will be on the
    `parse_net` network and will expose port `1337` to Træfik's ingress.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们进入下一个组件，即 Parse 平台。为了使容器与 Træfik 一起工作，我们为服务添加了一些标签，表示它将位于 `parse_net` 网络上，并将端口
    `1337` 暴露给 Træfik 的 ingress。
- en: 'We add a rule to allow every HTTP method, also to define the custom entrypoint,
    and allow `Origin=*` to enable the Parse dashboard, the next section, to be able
    to connect to the Parse server:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一条规则，允许每种 HTTP 方法，同时定义自定义入口点，并允许 `Origin=*`，以便下一个部分的 Parse 仪表盘能够连接到 Parse
    服务器：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here''s the Parse dashboard and its configuration. The current version of the
    dashboard is `1.1.2`. It will be exposed to port `4040` via Træfik''s ingress:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Parse 仪表盘及其配置。当前仪表盘版本为 `1.1.2`。它将通过 Træfik 的 ingress 暴露到端口 `4040`：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The configuration defines the default username and password, and also says
    that the server allows a connection via HTTP. Setting `INSECURE` to be `true`
    is fine, as we could do SSL simply at the ingress layer, using Træfik:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 配置定义了默认的用户名和密码，并且指出服务器允许通过 HTTP 连接。将 `INSECURE` 设置为 `true` 是可以的，因为我们可以简单地在 ingress
    层使用 Træfik 实现 SSL：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following YAML code is to define the L7 Træfik ingress for Parse and Parse
    dashboard. We have to expose Parse to the outside too, as the dashboard is a fat
    client, rather than server-side rendering. This is the main reason we need to
    set `Allow-Origin=*`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 YAML 代码用于定义 Parse 和 Parse 仪表盘的 L7 Træfik ingress。我们还需要将 Parse 暴露到外部，因为仪表盘是一个胖客户端，而不是服务器端渲染。这是我们需要设置
    `Allow-Origin=*` 的主要原因：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If everything goes well, we can open our favorite browser and navigate to `localhost:4040`
    for the Parse dashboard, as shown in the following screenshot. The default Username
    and Password are: `admin`/`password`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们可以打开我们喜欢的浏览器，访问 `localhost:4040` 以查看 Parse 仪表盘，如下图所示。默认的用户名和密码是：`admin`/`password`：
- en: '![](img/53abdb83-15a5-4ccb-916c-1e125c67c894.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53abdb83-15a5-4ccb-916c-1e125c67c894.png)'
- en: 'Figure 8.2: The login page of the Parse dashboard'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：Parse 仪表盘的登录页面
- en: 'Here, in the following screenshot, the dashboard of our Parse platform APP1
    connects to the Parse instance at `http://localhost:1337`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下截图中，我们的 Parse 平台 APP1 仪表盘连接到 `http://localhost:1337` 的 Parse 实例：
- en: '![](img/a2972412-fb81-44e9-8b3d-6458a1cacb17.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2972412-fb81-44e9-8b3d-6458a1cacb17.png)'
- en: 'Figure 8.3: The Parse application screen showing the core part'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：显示核心部分的 Parse 应用界面
- en: Defining a transfer entity
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义转账实体
- en: On the left-hand side navigation pane, we see the Core | Browser menu. This
    is where we can see all the data on our Parse platform. There are already some
    built-in classes, but we are going to define a new class to help do the money
    transfer.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧导航面板中，我们可以看到 Core | Browser 菜单。这里我们可以查看 Parse 平台上的所有数据。虽然已有一些内置类，但我们将定义一个新类来帮助进行资金转账。
- en: 'Click on Create a class in the Core | Browser menu. A dialog box, as shown
    in the following screenshot, will appear. We will use it to name our new class,
    `Transfer`. This will be our main entity responsible for mobile payment and, of
    course, money transfer:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 Core | Browser 菜单中的“创建一个类”。如以下截图所示，将会弹出一个对话框。我们将在此命名我们的新类，`Transfer`。它将成为我们处理移动支付和，当然，资金转账的主要实体：
- en: '![](img/503a0e46-cad1-42ff-a1ea-957de650b2db.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/503a0e46-cad1-42ff-a1ea-957de650b2db.png)'
- en: 'Figure 8.4: A dialog for defining a new class in Parse'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：定义 Parse 中新类的对话框
- en: 'Then we need to set up some new columns for this entity. We define the following
    columns:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要为这个实体设置一些新列。我们定义了以下列：
- en: from: The mobile number to pay money.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'from: 付款人的手机号码。'
- en: to: The mobile number to receive money.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'to: 收款人的手机号码。'
- en: 'amount: The amount of money to pay.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'amount: 需要支付的金额。'
- en: 'sent: A flag needs to be set to `true` when we want to start to process the
    transaction. If this field is `null` or `false`, the WebHook (see next) will just
    receive data and do nothing.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'sent: 当我们要开始处理交易时，需要将此标志设置为 `true`。如果该字段为 `null` 或 `false`，WebHook（见下文）将仅接收数据而不执行任何操作。'
- en: processed: A flag will be automatically set to `true` if the transaction is
    finished processing.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'processed: 如果交易处理完毕，标志将自动设置为 `true`。'
- en: How can we use this class? Using the dashboard, as shown in the following screenshot,
    we set mobile numbers for the  from, to, and amount columns. Then, when we are
    ready, just set the sent column to `true`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何使用这个类？通过仪表盘，如下图所示，我们为 from、to 和 amount 列设置了手机号码。然后，当我们准备好时，只需将 sent 列设置为
    `true`。
- en: 'If the processing goes wrong, the sent flag will be reset to `null` automatically
    by the WebHook:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如果处理出错，发送标志将由 WebHook 自动重置为 `null`：
- en: '![](img/ed892941-46b9-4d16-8b48-648816a47400.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ed892941-46b9-4d16-8b48-648816a47400.png)'
- en: 'Figure 8.5: Browsing the Transfer class using the dashboard'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5：通过仪表盘浏览 Transfer 类
- en: WebHook
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebHook
- en: The Parse platform provides an extensible mechanism to allow us to process business
    logic externally. This is where functions come in. This mechanism is called **WebHook**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Parse 平台提供了一个可扩展的机制，允许我们在外部处理业务逻辑。这就是函数的作用。这个机制称为 **WebHook**。
- en: We may have functions running as external processes, outside the Parse platform,
    and use them in conjunction with Parse's WebHook to perform complex business logic.
    As in the previous example, we already have the `Transfer `class. We then define
    a WebHook for this class to call an external function every time, before each
    of the `Transfer` entities is saved. We specify a URL to a FaaS gateway for this
    WebHook. The `HTTP POST` method will be made to the specified URL with the JSON
    as its request body. The request body contains the data of the current `Transfer`
    entity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会有作为外部进程运行的函数，这些函数在 Parse 平台外部，并与 Parse 的 WebHook 一起使用，以执行复杂的业务逻辑。正如前面的例子中所示，我们已经有了
    `Transfer` 类。然后，我们为这个类定义一个 WebHook，每次在保存每个 `Transfer` 实体之前，调用外部函数。我们为此 WebHook
    指定一个 FaaS 网关的 URL。`HTTP POST` 方法将发送到指定的 URL，JSON 数据将作为请求体。请求体包含当前 `Transfer` 实体的数据。
- en: 'A WebHook in Parse can be created by going to Core | Webhooks and clicking
    on the small Create a webhook option:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过访问 Core | Webhooks 并点击小的“创建一个 Webhook”选项来创建一个 WebHook：
- en: '![](img/80730e70-8319-4198-ac6f-4bb09ef55b48.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/80730e70-8319-4198-ac6f-4bb09ef55b48.png)'
- en: 'Figure 8.6: A screen for listing the existing WebHooks'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：列出现有 WebHooks 的屏幕
- en: 'There are two kinds of WebHook in Parse: Cloud Code functions and triggers.
    The kind we are using in this chapter is the **trigger**. A WebHook trigger can
    hook into many places, such as beforeSave, afterSave, beforeDelete, and afterDelete.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Parse 中有两种 WebHook：Cloud Code 函数和触发器。本章使用的 WebHook 类型是 **触发器**。WebHook 触发器可以挂钩到多个地方，例如
    beforeSave、afterSave、beforeDelete 和 afterDelete。
- en: 'In the example we are discussing in this chapter, the beforeSave trigger will
    be used as shown in the following screenshot. We choose Transfer as the target
    class of this hook. Then we need to specify the Webhook URL, a bank routing function
    deployed to Fn:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章讨论的示例中，将使用如下一截图所示的 beforeSave 触发器。我们选择 Transfer 作为该钩子的目标类。然后我们需要指定 WebHook
    URL，这是部署到 Fn 上的银行路由函数：
- en: '![](img/df3b761c-1a87-4a66-bee0-77c6c56c0e38.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df3b761c-1a87-4a66-bee0-77c6c56c0e38.png)'
- en: 'Figure 8.7: A dialog for defining a new WebHook; beforeSave for class Transfer'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7：定义新 WebHook 的对话框；适用于 Transfer 类的 beforeSave
- en: We will talk about the bank routing WebHook in the next section, but let's see
    it in action briefly before we explore its details.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节讨论银行路由 WebHook，但在深入了解其细节之前，先简要展示其运行效果。
- en: 'We test the WebHook by sending data by creating a new instance of the `Transfer`
    class. In the following screenshot, mobile number `+661234567` is not registered
    yet. So it cannot be looked up, and the WebHook returns an error message:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过创建一个新的 `Transfer` 类实例来测试 WebHook。以下截图中，手机号码 `+661234567` 尚未注册。因此无法进行查找，WebHook
    返回错误消息：
- en: '![](img/620a7f5d-f115-4692-9702-645daf12fedd.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/620a7f5d-f115-4692-9702-645daf12fedd.png)'
- en: 'Figure 8.8: An error message sent back from the WebHook will pop up on the
    bottom right'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8：从 WebHook 返回的错误消息将在右下角弹出
- en: 'To see error logs, click on Core | Logs, as shown in the following screenshot.
    Here is an example of the Webhook returning the following JSON:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看错误日志，请点击 Core | Logs，如下截图所示。这里是 WebHook 返回以下 JSON 的示例：
- en: '[PRE6]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![](img/e1f81644-29a1-4eff-8a32-57cd24e3c0c8.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1f81644-29a1-4eff-8a32-57cd24e3c0c8.png)'
- en: 'Figure 8.9: Info-level log screen displaying all kind of logs, including errors'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9：信息级别的日志屏幕，显示各种日志，包括错误
- en: 'The specifications of the returning messages are `{"success": object}` to update
    data back to the Parse platform, and `{"error":"msg"}` to display the error message.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '返回消息的规范是 `{"success": object}` 用于将数据更新回 Parse 平台，`{"error":"msg"}` 用于显示错误消息。'
- en: Preparing a WebHook in Fn
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Fn 中准备 WebHook
- en: 'The Fn Project works best with functions written in Java. When calling a function,
    the framework would be able to automatically transform the body of the request
    as a parameter of the entrypoint method. In the following example, the JSON from
    the request will be converted into a string for the `handleRequest` method, the
    entrypoint method of this Fn function:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Fn 项目最适合使用 Java 编写的函数。当调用函数时，框架能够自动将请求体转换为入口方法的参数。在以下示例中，请求中的 JSON 将被转换为字符串，作为此
    Fn 函数的入口方法 `handleRequest` 的参数：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here's the list of **data transfer object** (**DTO**) classes to properly encode
    and decode Parse's WebHook messages inside an Fn function. With help from Project
    Lombok and Jackson, we can dramatically reduce numbers of lines of code. An `Input` object
    is the wrapper for a Java's `Transfer` object, that contains all columns similar
    to the `Transfer` class, which we have defined on the Parse platform.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 **数据传输对象** (**DTO**) 类的列表，用于在 Fn 函数中正确地编码和解码 Parse 的 WebHook 消息。借助 Project
    Lombok 和 Jackson，我们可以显著减少代码行数。`Input` 对象是 Java 的 `Transfer` 对象的包装器，包含与我们在 Parse
    平台上定义的 `Transfer` 类相似的所有列。
- en: Please note that we have a **Transfer** class on both sides of the system, on
    the Parse platform, and also on the Fn platform.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在系统的两端都有一个 **Transfer** 类，一个在 Parse 平台上，另一个在 Fn 平台上。
- en: 'The `Success` and `Error` class are for returning processing results back to
    Parse:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Success` 和 `Error` 类用于将处理结果返回到 Parse：'
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As it is a Java project, we do not need to build it inside the container. Here''s
    the Gradle build file, which could be built using the `gradle installDist` command:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是一个 Java 项目，我们不需要在容器内部构建它。以下是 Gradle 构建文件，可以使用 `gradle installDist` 命令进行构建：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following is the Dockerfile to build an image for the Fn Project. It needs
    to inherit from `fn-java-fdk`. We use `jdk9-1.0.56` for the demo in this book.
    What you do is copy all JAR files from the `build` directory to the `/function/app`
    inside the container image:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是用于构建 Fn 项目的 Dockerfile。它需要继承自`fn-java-fdk`。在本书的示例中，我们使用`jdk9-1.0.56`。你需要做的是将`build`目录中的所有
    JAR 文件复制到容器镜像中的`/function/app`目录：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The following steps are to prepare the Fn server, and then we build our function
    with the `gradle` command. Then we build and push its Docker image onto the hub
    before redefining it as an Fn route.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤是准备 Fn 服务器，然后我们使用`gradle`命令构建函数。接着，我们将其 Docker 镜像构建并推送到 Hub，然后重新定义为 Fn 路由。
- en: 'First, we deploy an Fn Server manually with the following `docker run` command. Also,
    we attach Fn to the `parse_net`. There is a special hack to Fn so that we can
    make every container started by Fn be in the same network, as specified by `FN_NETWORK` there:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用以下`docker run`命令手动部署 Fn 服务器。同时，我们将 Fn 连接到`parse_net`。为了使每个由 Fn 启动的容器都位于同一个网络中，我们对
    Fn 进行了特别的黑客处理，如`FN_NETWORK`中所指定的：
- en: '[PRE11]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here''s the build and push script. Save the following scripts as `./buildAndPush`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这是构建和推送脚本。将以下脚本保存为`./buildAndPush`：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then we can start the build and push process by calling the script with a certain
    version number, as in the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以通过调用带有特定版本号的脚本来开始构建和推送过程，如下所示：
- en: '[PRE13]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the next section, we will discuss how the WebHook function looks up account
    data from a blockchain and how we can track the states of each money transfer
    transaction.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论 WebHook 函数如何从区块链中查找账户数据，以及如何跟踪每个资金转账交易的状态。
- en: An event state machine with a blockchain
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个带区块链的事件状态机
- en: 'We use an *Ethereum blockchain* as the event state machine for the money transfer
    system. A blockchain in this role is used for storing the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用*以太坊区块链*作为该事件状态机来处理资金转账系统。在这个角色中，区块链用于存储以下内容：
- en: The mapping between telephone numbers and bank accounts
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话号码与银行账户的映射关系
- en: The overall state of each transfer transaction
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个转账交易的整体状态
- en: Inside the blockchain, there are two kinds of smart contracts. The first one
    implements the **repository pattern**, and the second one implements the **entity
    model**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在区块链内部，有两种类型的智能合约。第一种实现了**仓库模式**，第二种实现了**实体模型**。
- en: We use Truffle ([http://truffleframework.com/](http://truffleframework.com/))
    to create this event state machine. Look at the subproject named *eventmachine*
    in the GitHub repository ([https://github.com/chanwit/eventmachine](https://github.com/chanwit/eventmachine)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Truffle ([http://truffleframework.com/](http://truffleframework.com/))
    来创建这个事件状态机。请查看 GitHub 仓库中名为*eventmachine*的子项目 ([https://github.com/chanwit/eventmachine](https://github.com/chanwit/eventmachine))。
- en: 'Here''s a smart contract under the `entities/` directory, `TransferState.sol`.
    This smart contract maintains the states of each transfer transaction. Each transaction
    is initialized with **NONE**, then **STARTED**, **PENDING**, and finally **COMPLETED**.
    The following diagram illustrates the smart contract `TransferState` working together
    with its repository implementation:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个位于`entities/`目录下的智能合约，`TransferState.sol`。这个智能合约维护着每个转账交易的状态。每个交易的初始状态是**NONE**，然后是**STARTED**、**PENDING**，最终是**COMPLETED**。下图展示了智能合约`TransferState`与其仓库实现协作的过程：
- en: '![](img/458cdcbd-30fe-49e6-8f7b-c1524b9a2b75.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![](img/458cdcbd-30fe-49e6-8f7b-c1524b9a2b75.png)'
- en: 'Figure 8.10: Flow of state transition and event emission by smart contracts'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10：智能合约的状态转换和事件触发流程
- en: 'We then explore its code for a bit. When moving to the next state, we use the
    `require` statement to check and let the smart contract throw an exception, if
    the pre-condition is not met:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们稍微探讨一下其代码。在转换到下一个状态时，我们使用`require`语句进行检查，如果不满足前置条件，智能合约将抛出异常：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'As previously mentioned, the `TransferState` is managed by the smart contract
    `TransferStateRepository`. Basically, this is an implementation of the repository
    pattern ([https://hub.packtpub.com/domain-driven-design/](https://hub.packtpub.com/domain-driven-design/)).
    Additionally, this smart contract naturally runs on the blockchain. To allow it
    to communicate with the outside world, every smart contract has to emit a kind
    of event. In the case of this `TransferStateRepository`, it has been designed
    to emit events when each transaction changes its status to `STARTED`, `PENDING`,
    and also `COMPLETED`. See the event signatures there in *Figure 8.10*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`TransferState` 是由智能合约 `TransferStateRepository` 管理的。基本上，这是仓储模式的实现（[https://hub.packtpub.com/domain-driven-design/](https://hub.packtpub.com/domain-driven-design/)）。此外，该智能合约自然运行在区块链上。为了使其与外界通信，每个智能合约必须触发一种事件。在这个
    `TransferStateRepository` 中，它被设计为在每个事务将其状态更改为 `STARTED`、`PENDING` 和 `COMPLETED`
    时触发事件。请参见 *图 8.10* 中的事件签名：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The mapping between telephone numbers and bank accounts is maintained by `RegistrationRepository`.
    This smart contract uses the same technique to communicate with the outside world,
    emitting events.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 电话号码与银行账户之间的映射由 `RegistrationRepository` 维护。该智能合约使用相同的技术与外界通信，触发事件。
- en: There are four events designed for `RegistrationRepository`. The `Registered` event
    is fired when we register a new telephone number into the mapping. If we try to
    register the same number again, the `AlreadyExisted` event is fired from the blockchain.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegistrationRepository` 设计了四个事件。当我们将一个新的电话号码注册到映射中时，会触发 `Registered` 事件。如果我们尝试再次注册相同的号码，则会触发来自区块链的
    `AlreadyExisted` 事件。'
- en: '`RegistrationFound` is the event fired when we find a mobile number by name
    via the `findTelByNo` function and when this function cannot find any registration
    matched by the input mobile number, the `RegistrationNotFound` event is emitted:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegistrationFound` 是在通过 `findTelByNo` 函数根据姓名找到手机号时触发的事件，当此函数无法找到与输入手机号匹配的注册信息时，会触发
    `RegistrationNotFound` 事件：'
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Using the Truffle framework, we are allowed to initialize some data with JavaScript
    during the development. Here''s one of the migration scripts, found under the `migrations/` directory,
    that is used for deploying smart contracts to the blockchain and registering two
    mobile numbers. The first number links to an account managed by an account managed
    by **Bank #1**, the OpenFaaS bank. The second mobile number is registered and
    linked to **Bank #2**, the OpenWhisk bank. In all banks, we already have accounts
    containing deposits:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '使用 Truffle 框架，我们可以在开发过程中通过 JavaScript 初始化一些数据。以下是一个迁移脚本，位于 `migrations/` 目录下，用于将智能合约部署到区块链，并注册两个手机号码。第一个号码关联到由
    **银行 #1**（OpenFaaS 银行）管理的账户。第二个手机号码已注册并关联到 **银行 #2**（OpenWhisk 银行）。在所有银行中，我们已有包含存款的账户：'
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We set up an Ethereum blockchain network with Parity, one of the most stable
    Ethereum clients. Here''s the setup. We attach the running Parity container to
    the same network of both Fn and the Parse platform:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Parity（一款最稳定的以太坊客户端之一）搭建了一个以太坊区块链网络。以下是设置过程。我们将运行中的 Parity 容器连接到 Fn 和 Parse
    平台的同一网络：
- en: '[PRE18]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the production private blockchain network, we need to set things up differently.
    For example, we need to set up our own genesis block and the mining behavior of
    the network. Anyway, it is beyond the scope of this book. We then deploy the smart
    contract via Truffle:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境的私有区块链网络，我们需要采用不同的设置方式。例如，我们需要设置自己的创世区块以及网络的挖矿行为。无论如何，这已经超出了本书的范围。然后，我们通过
    Truffle 部署智能合约：
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How the WebHook uses the blockchain
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebHook 如何使用区块链
- en: We will regularly go back to the WebHook after discussing each component around
    it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论每个组件后，我们将定期回到 WebHook。
- en: We already know how our blockchain and smart contracts work. They record mobile
    number registration, and maintain states of transfer transactions. In this section,
    we discuss how the WebHook function interacts with the blockchain. The following
    is the snippet from the WebHook function. The lookup method inside the function
    obtains the smart contract `RegistrationRepository` and then invokes `findByTelNo()`
    on the blockchain. The result is then available inside a transaction receipt.
    We check what kind of event is stored inside that receipt. If it is an `RegistrationFound`
    event, then this method returns a result object containing information regarding
    the bank name and account number.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道区块链和智能合约是如何工作的。它们记录手机号码注册，并维护转账交易的状态。在这一部分，我们讨论WebHook功能如何与区块链交互。以下是WebHook函数中的代码片段。函数中的查找方法获取智能合约`RegistrationRepository`，然后在区块链上调用`findByTelNo()`。结果随后会出现在交易回执中。我们检查回执中存储了什么事件。如果是`RegistrationFound`事件，那么该方法返回一个包含银行名称和账户号码信息的结果对象。
- en: There is room for improving this check.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这个检查还有改进的空间。
- en: How should the reader optimize the smart contract to fire only one event and
    meaningfully check whether the telephone number is already registered or not?
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 读者应该如何优化智能合约，以便仅触发一个事件并有意义地检查电话号是否已注册？
- en: 'That is basically about the lookup part:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这就是查找部分：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The transfer state management part is implemented inside a set of methods whose
    names start with `transfer`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 转账状态管理部分是通过一组方法实现的，这些方法的名称以`transfer`开头。
- en: 'Here''s the method to tell that we start new transactions with ID `txId`. It
    uses the `ContractRegistry` to obtain the smart contract, `TransferStateRepository`.
    Then we create a new transaction state and set its state to be `STARTED`. If everything
    is OK, we should get a transaction receipt from the call with an event, `TransferStartedEvent`,
    embedded in the receipt:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这是告诉我们如何开始新的交易的方法，交易ID为`txId`。它使用`ContractRegistry`来获取智能合约`TransferStateRepository`。然后我们创建一个新的交易状态，并将其状态设置为`STARTED`。如果一切正常，我们应该从调用中获取一个交易回执，回执中嵌入了一个事件`TransferStartedEvent`：
- en: '[PRE21]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Wrapping a legacy with a function
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用函数包装一个遗留系统
- en: In this section, we will demonstrate how to write a wrapper function for a legacy
    web-based system. To achieve this, we use the `chromeless` library ([https://github.com/graphcool/chromeless](https://github.com/graphcool/chromeless))
    to connect to a headless Chrome instance. Then the `chromeless` script drives
    the Chrome browser to do the rest for us.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将演示如何为一个遗留的基于Web的系统编写包装函数。为此，我们使用`chromeless`库（[https://github.com/graphcool/chromeless](https://github.com/graphcool/chromeless)）连接到一个无头的Chrome实例。然后，`chromeless`脚本驱动Chrome浏览器为我们完成其余的工作。
- en: 'The following diagram shows the working mechanism of this part of the system:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了系统这一部分的工作机制：
- en: '![](img/6952b6d1-50d6-4266-a91f-94e898a097eb.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6952b6d1-50d6-4266-a91f-94e898a097eb.png)'
- en: 'Figure 8.11: Diagram of implementing an OpenFaaS function to wrap around a
    UI-based ERP'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：实现一个OpenFaaS函数来包装基于UI的ERP的图示
- en: What does `chromeless` do? `chromeless` is a Node.js library that can be used
    to perform browser automation, similar to PhantomJS or Selenium. But it is really
    fast. Together with headless Chrome instances, `chromeless` yields a very fast
    performance. So it could be used as a serverless function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`chromeless`做什么？`chromeless`是一个Node.js库，可以用于执行浏览器自动化，类似于PhantomJS或Selenium。但是它真的非常快速。结合无头的Chrome实例，`chromeless`可以提供非常快的性能。因此，它可以用作无服务器函数。'
- en: 'We start by using FaaS CLI to create a project. We call this function `hivectl`,
    a program to control an ERP program built with the Moqui framework, HiveMind.
    We will talk about HiveMind shortly after setting up this function:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用FaaS CLI创建一个项目。我们称这个函数为`hivectl`，它是一个控制使用Moqui框架构建的ERP程序HiveMind的程序。设置完这个函数后，我们将简要介绍HiveMind：
- en: '[PRE22]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here''s the content of `hivectl.yml`, the OpenFaaS function descriptor for
    the `hivectl` function:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`hivectl.yml`的内容，它是`hivectl`函数的OpenFaaS函数描述符：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Here''s a sample configuration to make `chromeless` connect to headless Chrome
    running inside another container on the same network. The trick is to set `launchChrome` to
    `false`, and set `cdp`, **Chrome DevTool Protocol**, pointing to `host:''chrome'',
    port: 9222`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '这是一个示例配置，使`chromeless`连接到在同一网络上另一个容器内运行的无头Chrome。诀窍是将`launchChrome`设置为`false`，并将`cdp`，**Chrome开发工具协议**，指向`host:''chrome'',
    port: 9222`：'
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the main `chromeless` script to remotely control a headless Chrome
    instance. We will put the program into `hivectl/handler.js`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这是主要的`chromeless`脚本，用于远程控制无头Chrome实例。我们将程序放到`hivectl/handler.js`中：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'With OpenFaaS, we can simply build the function container with the following
    command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 使用OpenFaaS，我们可以通过以下命令简单地构建函数容器：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we will define the function in OpenFaaS. On the OpenFaaS UI, define a
    new function and the dialog will allow us to attach the new function to a specific
    network, `parse_net` in this case:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将在OpenFaaS中定义这个函数。在OpenFaaS UI中，定义一个新函数，弹出对话框允许我们将新函数附加到特定网络，在这个例子中是`parse_net`。
- en: '**Image**: `chanwit/hivectl:0.4`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜像**：`chanwit/hivectl:0.4`'
- en: '**Name**: `hivectl`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：`hivectl`'
- en: '**Network**: `parse_net`'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：`parse_net`'
- en: 'We start a headless Chrome instance, exposing it as `chrome` on the same network
    as the caller function. This Chrome headless will be listening on TCP port `9222`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动一个无头的Chrome实例，并将其暴露为`chrome`，与调用函数处于同一网络。这个无头的Chrome将监听TCP端口`9222`：
- en: '[PRE27]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now start an ERP system. It is the HiveMind ERP built using the Moqui framework.
    We can download it from the Moqui repository on GitHub ([https://github.com/moqui/moqui-framework](https://github.com/moqui/moqui-framework)).
    Fortunately, the Moqui team also prepares a Docker image for use. So just run
    it and attach it to the main `parse_net`. Port `10000` is published only for debugging
    purposes:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们启动一个ERP系统。它是使用Moqui框架构建的HiveMind ERP。我们可以从GitHub上的Moqui仓库下载它（[https://github.com/moqui/moqui-framework](https://github.com/moqui/moqui-framework)）。幸运的是，Moqui团队还准备了一个Docker镜像供使用。所以只需运行它并将其附加到主`parse_net`网络。端口`10000`仅用于调试：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The following screenshot shows the financial account page that will be processed
    by the `chromeless` function:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了将由`chromeless`函数处理的财务账户页面：
- en: '![](img/b1b53acf-c7a6-4e20-af65-c1b31c66afb1.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b1b53acf-c7a6-4e20-af65-c1b31c66afb1.png)'
- en: 'Figure 8.12: The HiveMind financial account page'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12：HiveMind财务账户页面
- en: 'Going back to the **back routing**, here''s the code inside the WebHook (running
    on Fn) calling to the `hivectl` function (running on OpenFaaS). The WebHook code
    creates an HTTP client, then sends two parameters, `accountId` and `amount`, to
    the `hivectl` function:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 回到**回调路由**，这是WebHook（在Fn上运行）调用`hivectl`函数（在OpenFaaS上运行）中的代码。WebHook代码创建一个HTTP客户端，然后将两个参数`accountId`和`amount`发送给`hivectl`函数：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: A function as a Glue
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为粘合剂
- en: Besides writing a simple processor, the technique in this section is one of
    the simplest forms of using functions. We have a bank backend with REST APIs exposed.
    So we write a function as a Glue to hide the complex interface of the backend.
    In this example, we use `Go` as the language to implement the function.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 除了编写一个简单的处理器，本节中的技术是使用函数的最简单形式之一。我们有一个暴露REST API的银行后端。所以我们写一个函数作为粘合剂，隐藏后端复杂的接口。在这个示例中，我们使用`Go`作为语言来实现函数。
- en: 'The scenario is that we have a REST API server and we want to unify it with
    another similar service. In the example in this chapter, we have two banking backends
    with different ways of interaction. The first one is a web-based UI without a
    REST interface, another one is the REST API in this section:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这个场景是我们有一个REST API服务器，并希望将它与另一个类似的服务统一。在本章的示例中，我们有两个不同交互方式的银行后端。第一个是没有REST接口的基于Web的UI，另一个是本节中的REST
    API：
- en: '[PRE30]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We use the multi-stage build. The `go build` command used here in the first
    stage is to produce static binary. Then we copy it to the second stage, `/action/exec`:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用多阶段构建。在这里的第一阶段使用`go build`命令生成静态二进制文件。然后我们将其复制到第二阶段，`/action/exec`：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Do not forget to push the image onto Docker Hub before proceeding to the next
    step.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续下一步之前，别忘了将镜像推送到Docker Hub。
- en: 'Then we define the function using `wsk` CLI commands:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用`wsk` CLI命令来定义函数：
- en: '[PRE32]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'To make a container able to talk to other FaaS platform gateways, we need to
    change the OpenWhisk invoker''s configuration to start every container inside
    the `parse_net` network. The invoker image is fixed to `3a7dce` and the OpenWhisk
    network configuration in the environment variable section of the invoker service, `CONFIG_whisk_containerFactory_containerArgs_network`,
    is set to `parse_net`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让容器能够与其他FaaS平台网关进行通信，我们需要修改OpenWhisk调用器的配置，使每个容器都在`parse_net`网络内启动。调用器镜像固定为`3a7dce`，OpenWhisk网络配置在调用器服务的环境变量部分，`CONFIG_whisk_containerFactory_containerArgs_network`被设置为`parse_net`：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To unify them, we create a function to wrap around the REST API and make both
    of the interfaces as similar as possible.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了统一它们，我们创建一个函数来包装REST API，并使这两个接口尽可能相似。
- en: 'To start the REST API server, we use the `docker run` command and attach it
    to the `parse_net` with the accounting alias. Port `18080` is published for debugging
    purposes only:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动REST API服务器，我们使用`docker run`命令，并将其附加到`parse_net`网络，使用会计别名。端口`18080`仅用于调试目的：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: A stream processor
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个流处理器
- en: Another use case of a function is to use it as a processor for data streams.
    A stream may be sent out from any kind of sources, such as data buses or event
    buses. Kafka, Twitter, or blockchain (in our case, Ethereum) could be a source
    of data streams. An Ethereum blockchain could emit events specific to some smart
    contracts when a certain action is taken.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 函数的另一个用例是将其作为数据流的处理器。流可能来自任何类型的源，例如数据总线或事件总线。Kafka、Twitter或区块链（在我们这个例子中是以太坊）可以是数据流的来源。当某个动作发生时，Ethereum区块链可能会触发某些智能合约相关的事件。
- en: To observe these events in the form of data streams efficiently, we need to
    use a kind of reactive client. RxJava is one of them. Fortunately, `web3j`, the
    Ethereum client we are using, already has RxJava observables to receive streaming
    data from an Ethereum blockchain.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效地观察这些以数据流形式呈现的事件，我们需要使用一种响应式客户端。RxJava就是其中之一。幸运的是，我们使用的以太坊客户端`web3j`已经提供了RxJava的可观察对象，以便接收来自以太坊区块链的流式数据。
- en: 'We call this component `listener`. The following diagram shows what we will
    implement around the Event Listener:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个组件称为`listener`。下图展示了我们将在事件监听器周围实现的内容：
- en: '![](img/798286f5-8ade-4476-8764-b5183e1bfc15.png)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![](img/798286f5-8ade-4476-8764-b5183e1bfc15.png)'
- en: 'Figure 8.13: Diagram illustrating relations around the Event Listener'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：图示说明了事件监听器周围的关系
- en: A requirement is that we run the agent (**Event Listener**) as a container on
    the same network as the blockchain. We use the agent to divert each transaction
    information to other endpoints. In this example, we have two endpoints. The first
    one is the record inside Parse. Another one is the S3-compatible storage, Minio.
    We upload a file to Minio when the transaction is completed.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 一个要求是，我们需要将代理（**事件监听器**）作为容器在与区块链相同的网络上运行。我们使用代理将每个交易信息转发到其他端点。在这个示例中，我们有两个端点。第一个是Parse中的记录，另一个是S3兼容存储Minio。当交易完成时，我们将文件上传到Minio。
- en: 'The following shows how to use a contract observable to listen to blockchain
    events:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 以下展示了如何使用合约可观察对象来监听区块链事件：
- en: '[PRE35]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We use a simple Gradle build script for this component. The project can be
    built using the `gradle installDist` command as usual:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为该组件使用一个简单的Gradle构建脚本。该项目可以像往常一样使用`gradle installDist`命令构建：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Here''s the Dockerfile for this component:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这是该组件的Dockerfile：
- en: '[PRE37]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'This is the Gradle build step, `docker build` and `docker push` command:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Gradle构建步骤，`docker build`和`docker push`命令：
- en: '[PRE38]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Inter-FaaS platform networking
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跨FaaS平台的网络通信
- en: To make all functions of different platforms able to talk together, we need
    to set up a proper container network. The demo project discussed in this chapter
    is not a simple FaaS example. It is a complex scenario where functions are allowed
    to call other functions on the different FaaS platforms.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使不同平台的所有功能能够相互通信，我们需要设置一个合适的容器网络。本章讨论的演示项目并不是一个简单的FaaS示例，而是一个复杂的场景，其中功能允许调用不同FaaS平台上的其他功能。
- en: Normally, on some serverless platforms such as Lambda, we may sometimes assume
    that all functions run on the flat network of the provider. In contrast, when
    we run functions on our own platforms, we could segment the networks ourselves
    and function networking will become a challenge. However, networking will be relatively
    simple because the networking model in Docker and Swarm is the flat network.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在一些无服务器平台如Lambda上，我们有时会假设所有功能都运行在提供商的平面网络上。相比之下，当我们在自己的平台上运行功能时，我们可以自己划分网络，功能网络化将成为一个挑战。然而，由于Docker和Swarm中的网络模型是平面网络，网络化将相对简单。
- en: 'How can we achieve this? By the following:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何实现这一点？通过以下方式：
- en: We create an attachable Swarm-scoped network
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个可附加的Swarm范围网络
- en: We start a FaaS framework and make its gateway attach to that network
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们启动一个FaaS框架，并让其网关连接到该网络
- en: We also need to tell the framework that it must attach that network to every
    container it created
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要告诉框架，必须将该网络附加到每个它创建的容器上
- en: 'In OpenFaas, it allows you to create a function to run on a specific network.
    In OpenWhisk, we can specify this with a configuration of an invoker. For the
    Fn Project, we need an additional hack. Here''s the change required to patch to
    Fn in order to make it able to attach function containers to a specified network
    (`FN_NETWORK`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在 OpenFaas 中，允许你创建在特定网络上运行的函数。在 OpenWhisk 中，我们可以通过配置 invoker 来指定这一点。对于 Fn 项目，我们需要额外的
    hack。以下是需要修改的内容，以便将函数容器附加到指定网络（`FN_NETWORK`）：
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The version with the function networking patch is available at [https://github.com/chanwit/fn](https://github.com/chanwit/fn).
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 带有函数网络补丁的版本可在 [https://github.com/chanwit/fn](https://github.com/chanwit/fn)
    下载。
- en: Exercises
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: 'This chapter covers a lot of practices and hacks to make the whole stack of
    the demo project, a mobile payment system, work. Please go through the content
    of all the sections in this chapter:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了许多实践和 hack，帮助使演示项目的整个堆栈——一个移动支付系统——能够正常运行。请阅读本章所有部分的内容：
- en: Why do we need to hack the Fn to build a custom version of an Fn server?
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么我们需要 hack Fn 来构建定制版本的 Fn 服务器？
- en: What is the concept of inter-FaaS platform networking? Why is it important?
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跨 FaaS 平台网络的概念是什么？为什么它很重要？
- en: What are the two roles of an Ethereum block in the demo project?
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在演示项目中，Ethereum 区块的两个角色是什么？
- en: What is the data type of the parameters of an OpenWhisk function?
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OpenWhisk 函数的参数数据类型是什么？
- en: How can we encode JSON in Java with Fn?
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Fn 中使用 Java 编码 JSON？
- en: How can we encode JSON in Golang?
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在 Golang 中编码 JSON？
- en: What is the Parse platform?
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Parse 平台？
- en: What is the role of Parse WebHook?
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Parse WebHook 的作用是什么？
- en: What is the concept of a Glue function?
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是 Glue 函数的概念？
- en: How can we write a function to wrap a legacy web-based application?
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何编写函数来封装传统的基于 Web 的应用程序？
- en: Summary
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter demonstrated a use case by showing how we can develop a mobile
    payment system on FaaS platforms.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过展示如何在 FaaS 平台上开发移动支付系统，演示了一个用例。
- en: We used Parse as a UI backend. Then we connected Parse to a bank routing function
    running on Fn via the Parse WebHook mechanism. We then demonstrated that with
    functions, it was relatively easy to make a call to a modern infrastructure such
    as blockchain. We simulated two banks to show use cases of a function, a function
    as a Glue, and a function that wrapped legacy systems. Then we demonstrated how
    a function was used in conjunction with a streaming agent to process data streams.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Parse 作为 UI 后端。然后，我们通过 Parse WebHook 机制将 Parse 连接到在 Fn 上运行的银行路由函数。接着我们演示了如何使用函数，相对容易地调用现代基础设施，如区块链。我们模拟了两家银行，展示了函数的用例，一个作为
    Glue 的函数，以及一个封装传统系统的函数。然后，我们演示了如何将函数与流代理结合使用，处理数据流。
- en: All of the three FaaS platforms were linked together and run on the same Docker
    Swarm cluster. It was quite simple to link OpenWhisk and OpenFaaS functions together,
    but in the case of Fn, it was a bit of a hack because the current version of Fn
    doesn't allow you to define a container network.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 所有三个 FaaS 平台都已连接在一起，并在同一个 Docker Swarm 集群上运行。将 OpenWhisk 和 OpenFaaS 函数连接在一起相当简单，但在
    Fn 的情况下，稍显复杂，因为当前版本的 Fn 不允许你定义容器网络。
- en: The next chapter will be the final chapter of this book. We will conclude the
    concept of a function and look forward to see what's next beyond the world of
    FaaS.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将是本书的最后一章。我们将总结函数的概念，并展望 FaaS 世界之外的未来发展。
