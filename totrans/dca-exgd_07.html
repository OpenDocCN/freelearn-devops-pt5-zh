<html><head></head><body>
        

                            
                    Introduction to Docker Content Trust
                
            
            
                
<p class="mce-root">In this chapter, we will learn about the Docker Content Trust concept and its related tools. To provide trusted content in Docker environments, we will use Docker Content Trust to encrypt metadata information applied to Docker objects. Therefore, any unauthorized changes or object manipulation will be reported. We will be able to ensure that all the objects in our environment are trusted if none of these issues are found.</p>
<p>First, we will introduce The Update Framework, and then we will learn how to sign images. After that, we will learn how to verify signatures to ensure their precedence and ownership. Finally, we will apply those concepts to run a trusted environment in production.</p>
<p>We will cover the following topics in this chapter:</p>
<ul>
<li>The Update Framework</li>
<li>Signing images</li>
<li>Reviewing signatures</li>
<li>Creating and running applications in trusted environments</li>
</ul>
<p>Let's get started!</p>
<h1 id="uuid-7d15898b-8626-487e-807d-159e982c5d4b">Technical requirements</h1>
<p>In this chapter, we will learn about various Docker Content Trust concepts. We'll provide some labs at the end of this chapter that will help you understand and learn about the shown concepts. These labs can be run on your laptop or PC using the provided Vagrant standalone environment or any already-deployed Docker host deployed by yourself. You can find additional information in this book's GitHub code repository: <a href="https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git">https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git</a>.</p>
<p>Check out the following video to see the Code in Action:</p>
<p>"<a href="https://bit.ly/3b0qviR" target="_blank">https://bit.ly/3b0qviR</a>"</p>
<h1 id="uuid-cbd2febd-9278-4dbe-9a36-f628da51c322">The Update Framework</h1>
<p class="mce-root">Before learning about <strong>The Update Framework</strong>, also known as <strong>TUF</strong>, we will introduce a number of concepts. The following concepts will help us understand why we need tools to manage application updates:</p>
<ul>
<li><strong>Software update system</strong>: A software update system is an application that looks for new updates continuously. When they are found, it triggers processes to get these updates and installs these changes. A good example is the Google Chrome web browser update system. It continuously looks for its components' updates and, once they are found, it will show us a There is a new release, do you want to update now? message.</li>
<li><strong>Library package managers</strong>: The library package managers will manage and update programming language libraries and their dependencies. Python's <strong>Package Installer for Python</strong> (<strong>PIP</strong>) and Node.js's <strong>Node Package Manager</strong> (<strong>NPM</strong>) are good examples. These applications look for library updates and install them with their requisite dependencies.</li>
<li><strong>Operating system component updates</strong>: In this case, different package managers will manage all software updates and their dependencies, triggering, in some cases, some of the aforementioned solutions (software update systems or library package managers).</li>
</ul>
<p>An application update usually takes three logical steps:</p>
<ol>
<li>It looks for any update or change.</li>
<li>It downloads updates.</li>
<li>It applies changes to our system.</li>
</ol>
<p>What would happen if those updates were malicious because the code was intercepted and modified by an attacker?</p>
<p>TUF was created to prevent these situations. It will handle the steps described for application updates to ensure that downloaded changes are trusted. No manipulated changes will be allowed. TUF metadata includes information related to trusted keys, cryptographic hashes and files, component versions, creation and expiration dates, and signatures. An application that requires a number of updates does not have to manage this verification process. It will ask TUF to manage these processes. To summarize, we can say, in a way, that TUF provides a secure method of obtaining trusted files. </p>
<p>TUF is currently hosted by the Linux Foundation as part of the <strong>Cloud Native Computing Foundation</strong> (<strong>CNCF</strong>). It is open source and can be used in production environments. It is recommended to use this in conjunction with some vendor tools because it will be easier to manage and use.</p>
<p>TUF metadata provides information about the truthfulness of the update to the software update system. This component will then make the right decision (install or reject the update). This metadata information will be presented in JSON format. We will talk about four levels of signing. We will refer to them as roles:</p>
<ul>
<li><strong>Root metadata (</strong><kbd>root.json</kbd><strong>) and role</strong>: This role is related to the owner of the change. It is the top role; others will be related to this one.</li>
<li><strong>Targets metadata (</strong><kbd>targets.json</kbd><strong>) and role</strong>: This role is related to the files included in the package.</li>
<li><strong>Snapshot metadata (</strong><kbd>snapshot.json</kbd><strong>) and role</strong>: All files apart from <kbd>timestamp.json</kbd> will be listed on this role to ensure the consistency of updates.</li>
<li><strong>Timestamp metadata (</strong><kbd>timestamp.json</kbd><strong>) and role</strong>: This sign will ensure the exact date of the update and that it is the only one required when checking for updates, for example.</li>
</ul>
<p>The update application uses TUF to interact with the repositories and sources of files while managing their updates. Roles, trusted keys, and target files should not be included in those repositories because they will be used to manage them.</p>
<p>There should be a client side on this framework so that we can include the roles described in its normal usage. Therefore, a client side must manage the following:</p>
<ul>
<li>Trusted root keys, from all possible owners that must be trusted</li>
<li>Target delegation, when there is a target with many owners</li>
<li>Checking for updates using timestamp role dates</li>
<li>All signing processes</li>
</ul>
<p>Now that we know the benefits of using TUF to manage repository updates, let's review how this is implemented in Docker.</p>
<p>Docker Content Trust is the Docker implementation of TUF. It is integrated using Notary, which is an open source tool for publishing and managing trusted content. The Docker client provides an interface that allows us to sign and verify content publishers.</p>
<p>Notary is a separate piece of software; it can be downloaded and used to inspect keys included in a Docker registry. Docker integrates Notary using its library. Therefore, every time we pull an image when Docker Content Trust is enabled (disabled by default), the Docker daemon will validate its signatures. Image pulling is done by its digest. Image names and tags will not be used. This ensures that only the right image will be downloaded.</p>
<p>Notary usage is beyond the scope of this book. At the time of writing, it is not required in order to pass the DCA certification exam. It is recommended, however, to read about some of the Notary features provided at the following link: <a href="https://docs.docker.com/notary/getting_started">https://docs.docker.com/notary/getting_started</a>.</p>
<p>When we use Docker Content Trust and we push an image, the Docker client will ask us to sign at all the levels described (root, target, snapshot, and timestamp).</p>
<p>In summary, Docker Content Trust (Docker's TUF implementation) will do the following:</p>
<ul>
<li>Ensure image provenance</li>
<li>Sign content prior to distribution</li>
<li>Ensure that everything running on a host is trusted.</li>
</ul>
<p>In the next section, we will learn how to sign and use signed images that have been validated by Docker Engine.</p>
<h1 id="uuid-6320968b-b694-4c55-8a5b-461656ace3a5">Signing images</h1>
<p>So far, we have learned about the different roles and the metadata information that will be used to validate and trust image content. Let's look at a quick summary before getting into the Docker signing action:</p>
<ul>
<li>The root key will validate other keys. It signs the <kbd>root.json</kbd> file, which contains the list of IDs of the root, targets, snapshot, and timestamp public keys. To verify content signatures, the Docker client will use these public keys. The root key is offline and must be kept safe. The owner of a collection of images should maintain this key. Don't lose this key. You can recreate it, but all your signed images will be invalid.</li>
<li>The target key signs the <kbd>targets.json</kbd> file, which contains a list of your content filenames, along with their sizes and hashes. This file is used to delegate trust to other users in a team so that others can sign the same repository. This key is held by administrators and owners of a collection (repository).</li>
<li>The delegation key is used to sign delegation metadata files. This key is held by administrators and everyone who can contribute to the specified collection.</li>
<li>The snapshot key signs the <kbd>snapshot.json</kbd> metadata file. This file also contains filenames, as well as the sizes and hashes of root, targets, and delegation files in the collection. This key will be held by administrators and the collection owner. If we use the Notary service, this key can also be held by this service to allow signing by collection collaborators. This key represents the current package signature.</li>
<li>The timestamp key ensures the freshness of the collection. It is used to verify the integrity of the <kbd>snapshot.json</kbd> file. Because this key is only valid for a period of time, it is better to be held in Notary. In this case, it will not be necessary that owners recreate the key each time it expires. Notary will regenerate this key as needed.</li>
</ul>
<p>Now, let's sign an image using the Docker client.</p>
<p>First, we will enable Docker Content Trust. By default, it is not enabled. We can enable it for all Docker commands or add an argument each time we want to enable it. To enable Docker Content Trust for all subsequent Docker commands, we need to define the <kbd>DOCKER_CONTENT_TRUST</kbd> variable:</p>
<pre><strong>$ export DOCKER_CONTENT_TRUST=1</strong></pre>
<p>Alternatively, we can enable Docker Content Trust for only specified commands:</p>
<pre>$ docker pull <strong>--disable-content-trust=false</strong> busybox:latest</pre>
<p>We used <kbd>--disable-content-trust=false</kbd> here because, by default, Docker Content Trust is disabled.</p>
<p>Now that we have enabled Docker Content Trust for all commands in this session by setting <kbd>DOCKER_CONTENT_TRUST= 1</kbd>, we can pull an image using <kbd>docker image pull</kbd>:</p>
<pre><strong>$ export DOCKER_CONTENT_TRUST=1</strong><br/><br/><strong>$ docker image pull busybox</strong><br/><strong>Using default tag: latest</strong><br/><strong>Pull (1 of 1): busybox:latest@sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a0</strong><br/><strong>sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a0: Pulling from library/busybox</strong><br/><strong>0f8c40e1270f: Pull complete </strong><br/><strong>Digest: sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a0</strong><br/><strong>Status: Downloaded newer image for busybox@sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a0</strong><br/><strong>Tagging busybox@sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a0 as busybox:latest</strong><br/><strong>docker.io/library/busybox:latest</strong></pre>
<p>Notice that the <kbd>docker image pull</kbd> command's output changed. In fact, the downloaded image was managed by its hash; in this case, <kbd>busybox@sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a</kbd>.</p>
<p>Docker's official images and certified images are always signed. Official images are managed and built by Docker, and they are located under <kbd>docker.io/&lt;REPOSITORY&gt;:&lt;TAG&gt;</kbd>. </p>
<p>Let's run this image using <kbd>docker container run</kbd> and see what happens:</p>
<pre><strong>$ docker container run -ti busybox sh</strong><br/><strong>/ # ls </strong><br/><strong>bin dev etc home proc root sys tmp usr var</strong><br/><strong>/ # touch NEW_FILE</strong><br/><strong>/ # exit</strong></pre>
<p>It worked, as expected. We added a file because we wanted to modify a container before committing its content to create a new, untrusted image. For this process, we will run <kbd>docker container commit</kbd>, setting <kbd>DOCKER_CONTENT_TRUST=0</kbd> for the command. We do this because Content Trust was previously enabled in our current session:</p>
<pre><strong>$ DOCKER_CONTENT_TRUST=0 docker container commit 3da3b341e904 busybox:untrusted</strong><br/><strong>sha256:67a6ce66451aa10011d379e4628205889f459c06a3d7793beca10ecd6c21b68a</strong></pre>
<p>Now, we have an untrusted <kbd>busybox</kbd><em><strong> </strong></em>image. What will happen if we try to execute this image?</p>
<pre><strong>$ docker container run -ti busybox:untrusted sh</strong><br/><strong>docker: No valid trust data for untrusted.</strong><br/><strong>See 'docker run --help'.</strong></pre>
<p>We cannot run this image because it is not trusted; it does not have any content trust metadata. Therefore, it cannot be validated and will not be allowed to run. If Docker Content Trust is enabled, unsigned images will not be allowed.</p>
<p>Let's sign this image. In this case, we will change the image name and create a new <kbd>trusted</kbd> tag. The signing process requires two passphrases, as described here:</p>
<ol>
<li>First, we will be asked to set a <kbd>root</kbd> passphrase. You will be asked twice to validate the password that's entered as it is not shown.</li>
<li>Then, you will be asked to set a <kbd>repository</kbd> passphrase. You will be asked twice again to validate the password that's entered as it is not shown.</li>
</ol>
<p>We have been asked for the passphrase twice because we are setting their values for the first time. Next time we use these keys to push or pull to this repository, we will be asked just once (or more if it was typed in incorrectly). Let's execute <kbd>docker image push</kbd>:</p>
<pre>$ docker image push frjaraur/mybusybox:trusted<br/>The push refers to repository [docker.io/frjaraur/mybusybox]<br/>0736ae522762: Pushed <br/>1da8e4c8d307: Mounted from library/busybox <br/>trusted: digest: sha256:e58e349eee38baa38f8398510c44e63a1f331dc1d80d4ed6010fe34960b9945f size: 734<br/><strong>Signing and pushing trust metadata</strong><br/><strong>You are about to create a new root signing key passphrase. This passphrase</strong><br/><strong>will be used to protect the most sensitive key in your signing system. Please</strong><br/><strong>choose a long, complex passphrase and be careful to keep the password and the</strong><br/><strong>key file itself secure and backed up. It is highly recommended that you use a</strong><br/><strong>password manager to generate the passphrase and keep it safe. There will be no</strong><br/><strong>way to recover this key. You can find the key in your config directory.</strong><br/><strong>Enter passphrase for new root key with ID 6e03824:</strong> <br/>Repeat passphrase for new root key with ID 6e03824: <br/>Enter passphrase for new repository key with ID b302395: <br/><strong>Repeat passphrase for new repository key with ID b302395:</strong> <br/>Finished initializing "docker.io/frjaraur/mybusybox"<br/>Successfully signed docker.io/frjaraur/mybusybox:trusted</pre>
<p>The root passphrase is very important. Keep it safe because if you lose it, you will need to start again. If this happens, your already-signed images will be untrusted and you will need to update them. If you lose a key, you will need to contact Docker Support (<kbd>support@docker.com</kbd>) to reset the repository state.</p>
<p>The passphrases you choose for both the root key and your repository should be strong. It is recommended to use randomly generated ones.</p>
<p>Now, we have a signed image. It is owned by us (in this example, I am the owner of <kbd>frjaraur/mybusybox:trusted</kbd>).</p>
<p>Now, we can execute this newly signed (and hence trusted) image using <kbd>docker container run</kbd>:</p>
<pre><strong>$ docker container run -ti frjaraur/mybusybox:trusted</strong><br/><strong>/ # touch OTHERFILE</strong><br/><strong>/ # exit</strong></pre>
<p>To manage Docker Content Trust, we can use <kbd>docker trust</kbd> with its available actions. We will be able to manage keys (load and revoke) and sign images (this process is similar to the one previously described). We can review these signatures using <kbd>docker trust inspect</kbd>:</p>
<pre><strong>$ docker trust inspect --pretty docker.io/frjaraur/mybusybox:trusted</strong><br/><br/><strong>Signatures for docker.io/frjaraur/mybusybox:trusted</strong><br/><br/><strong>SIGNED TAG DIGEST SIGNERS</strong><br/><strong>trusted e58e349eee38baa38f8398510c44e63a1f331dc1d80d4ed6010fe34960b9945f (Repo Admin)</strong><br/><br/><strong>Administrative keys for docker.io/frjaraur/mybusybox:trusted</strong><br/><br/><strong>  Repository Key: b3023954026f59cdc9be0b7ba093039353ce6e2d1a06c1338e4387689663abc0</strong><br/><strong>  Root Key: e9120faa839a565838dbad7d45edd3c329893ae1f2085f225dc039272dec98ed</strong></pre>
<p>Notice that we have used <kbd>docker.io/frjaraur/mybusybox:trusted</kbd> instead of <kbd>frjaraur/mybusybox:trusted</kbd>. This is because if we do not use the registry's <strong>fully qualified domain name</strong> (<strong>FQDN</strong>) and the image exists locally, it will be used to retrieve all signature information and you will receive a <kbd>WARN[0006] Error while downloading remote metadata, using cached timestamp - this might not be the latest version available remotely</kbd> message because you will be using the cached timestamp instead of the real one.</p>
<p class="mce-root">Now that we have learned how to sign content – in this case, images – let's move on and learn how to verify signatures.</p>
<h1 id="uuid-5dc0fcf8-f52f-4da1-a2a0-1323c8a6a76f">Reviewing signatures</h1>
<p class="mce-root">The Docker client stores content trust-related files under the <kbd>.docker/trust</kbd> directory, inside the user's home directory.</p>
<p>If we navigate to the trusted directory, we will find different registry files under <kbd>.docker/trust/tuf</kbd>. We used Docker Hub in this chapter's examples. Therefore, we will find the <kbd>docker.io</kbd> registry and different repositories. This may vary in your environment; you may have more registries or repositories. It will depend on when you started to use Docker Content Trust in your Docker host. Using the examples from the previous sections, we will find a tree-like directory structure under the <kbd>.docker</kbd> directory:</p>
<pre>trust/tuf/docker.io/frjaraur/mybusybox/metadata:<br/>total 16<br/>-rw------- 1 zero zero  494 nov 30 17:29 timestamp.json<br/>-rw------- 1 zero zero  531 nov 30 17:28 targets.json<br/>-rw------- 1 zero zero  682 nov 30 17:28 snapshot.json<br/>-rw------- 1 zero zero 2417 nov 30 17:03 root.json<br/>...<br/>...<br/>trust/tuf/docker.io/library/busybox/metadata:<br/>total 28<br/>-rw------- 1 zero zero 498 nov 30 17:17 timestamp.json<br/>-rw------- 1 zero zero 13335 nov 30 16:41 targets.json<br/>-rw------- 1 zero zero 688 nov 30 16:41 snapshot.json<br/>-rw------- 1 zero zero 2405 nov 30 16:41 root.json</pre>
<p>Remember the JSON files described in the previous section. All these files are located under each registry and repository's structure.</p>
<div><p>The Docker client will store your keys under your <kbd>.docker/trust/private</kbd> directory. It is very important to keep them safe. To back up these keys, use the <kbd>$ umask 077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private; umask 022</kbd> command.</p>
</div>
<p>Notary will assist us in managing signatures. It is an open source server and client application and can be downloaded from its GitHub project page (<a href="https://github.com/theupdateframework/notary">https://github.com/theupdateframework/notary</a>).</p>
<p>Notary can be installed either on Linux or Windows hosts.</p>
<p>We will simply download the latest release using the <kbd>curl</kbd> command and modify its permissions and path:</p>
<pre><strong>$ curl -o /tmp/notary -sL https://github.com/theupdateframework/notary/releases/download/v0.6.1/notary-Linux-amd64</strong><br/><br/><strong>$ sudo mv /tmp/notary /usr/local/bin/notary</strong><br/><br/><strong>$ sudo chmod 755 /usr/local/bin/notary</strong></pre>
<p>In this section, we will use Docker's own Notary server that's been published on the internet (<a href="https://notary.docker.io">https://notary.docker.io</a>) and that is associated with Docker Hub.</p>
<div><br/>
Docker Enterprise will run its own Docker Notary server implementation in your environment.</div>
<p>Let's verify, for example, all the signatures associated with a Docker Hub repository. In this example, we are reviewing the <kbd>busybox</kbd> repository. We use <kbd>notary list</kbd> with the appropriate server and directory arguments:</p>
<pre><strong>$ notary -s https://notary.docker.io -d ~/.docker/trust list docker.io/library/busybox</strong><br/><strong>NAME DIGEST SIZE (BYTES) ROLE</strong><br/><strong>---- ------ ------------ ----</strong><br/><strong>1 1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a0 1864 targets</strong><br/><strong>...</strong><br/><strong>...</strong><br/><strong>1.31.1-uclibc 817e459ca73c567e9132406bad78845aaf72d2e0c0965ff68861b318591e949a 1210 targets</strong><br/><strong>buildroot-2013.08.1 c0a08c5e4c15c53f03323bae8e82fdfd9f4fccb7fd01b97579b19e3e3205915c 5074 targets</strong><br/><strong>buildroot-2014.02 ced99ae82473e7dea723e6c467f409ed8f051bda04760e07fd5f476638c33507 5071 targets</strong><br/><strong>glibc 0ec061426ef36bb28e3dbcd005f9655b6bfa0345f0d219c8eb330e2954f192ac 1638 targets</strong><br/><strong>latest 1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a0 1864 targets</strong><br/><strong>...</strong><br/><strong>...</strong><br/><strong>uclibc 817e459ca73c567e9132406bad78845aaf72d2e0c0965ff68861b318591e949a 1210 targets</strong></pre>
<p>We listed all the targets on a remote trusted collection – in this case, the <kbd>busybox</kbd> collection on Docker Hub (<kbd>docker.io/library/busybox</kbd>).</p>
<p>Now, let's learn how to automate these processes and ensure security to build a trusted environment in our organization.</p>
<h1 id="uuid-49e480c4-59f5-4e67-bdf6-897384a50c82">Creating and running applications in trusted environments</h1>
<p>In this section, we will consider a trusted environment where <kbd>CONTENT_TRUST_ENABLED</kbd> is used for all actions. This will ensure that images built in that environment will always be signed. All images that have been pushed and pulled will be signed, and we will only run containers based on trusted images.</p>
<p>It is interesting to add CI/CD orchestration tools to these processes. It is not easy to disallow non-trusted content without some system or even higher security policies. If we set the <kbd>DOCKER_CONTENT_TRUST</kbd> value to only allow Docker Content Trust, but users are allowed to interact with the Docker host directly, they can disable this feature at the command line.</p>
<p>Automation is key in production environments, although it is true that Docker Enterprise provides other methods, which we will discuss later on in <a href="1879ea92-ae47-4230-ac84-784d4bc73185.xhtml">Chapter 12</a>, <em>Universal Control Plane</em>. Kubernetes also provides features to force security for trusted content, but this topic is beyond the scope of this book.</p>
<p>Using an external CI/CD, we can automate the building, sharing, or deployment of Docker content. Let's look at a brief example of building and pushing an image:</p>
<pre><strong>$ export DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE="MyVerySecureRootPassphraseForAutomation"</strong><br/><strong>$ export DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE="MyVerySecureRepositoryPassphraseForAutomation"</strong><br/><br/><strong>$ docker build -t docker/trusttest:testing .</strong><br/><strong>Using default tag: latest</strong><br/><strong>latest: Pulling from docker/trusttest</strong><br/><strong>b3dbab3810fc: Pull complete</strong><br/><strong>a9539b34a6ab: Pull complete</strong><br/><strong>Digest: sha256:d149ab53f871</strong><br/><br/><strong>$ docker push docker/trusttest:latest</strong><br/><strong>The push refers to a repository [docker.io/docker/trusttest] (len: 1)</strong><br/><strong>a9539b34a6ab: Image already exists</strong><br/><strong>b3dbab3810fc: Image already exists</strong><br/><strong>latest: digest: sha256:d149ab53f871 size: 3355</strong><br/><strong>Signing and pushing trust metadata</strong></pre>
<p>We can write a script for a CI/CD orchestration job using the <kbd>root</kbd> and <kbd>repository</kbd> passphrases to ensure that content trust is applied during building and pushing to our registry. We can follow the same method to deploy on production, disallowing any user interaction with this secure environment. Take care of environment variables for passphrases on scripts because they will be visible. CI/CD orchestrators will provide secure methods to manage this. This will give you an idea of how you should implement a secure chain with your own management configuration tools.</p>
<p>Now, let's review a lab to better understand the topics we've learned in this chapter.</p>
<h1 id="uuid-c6a9e66d-f0f2-4600-be63-efc2bf47758c">Chapter labs</h1>
<p>We will now complete a lab that will help us improve on the concepts we've learned about.</p>
<p>Deploy <kbd>environments/standalone-environment</kbd><em> </em>from this book's GitHub repository (<a href="https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git">https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git</a>) if you have not done so yet. You can use your own CentOS 7 server. Use <kbd>vagrant up</kbd> from the <kbd>environments/standalone-environment</kbd><em> </em>folder to start your virtual environment.</p>
<p>If you are using a standalone environment, wait until it is running. We can check the statuses of our nodes using <kbd>vagrant status</kbd>. Connect to your lab node using <kbd>vagrant ssh standalone</kbd>. <kbd>standalone</kbd> is the name of your node. You will be using the <kbd>vagrant</kbd> user with root privileges using <kbd>sudo</kbd>. You should get the following output:</p>
<pre><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$ vagrant up</strong><br/><strong>Bringing machine 'standalone' up with 'virtualbox' provider...</strong><br/><strong>...</strong><br/><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$ vagrant status</strong><br/><strong>Current machine states:</strong><br/><strong>standalone running (virtualbox)</strong><br/><strong>...</strong><br/><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$</strong></pre>
<p class="mce-root">We can now connect to a standalone node using <kbd>vagrant ssh standalone</kbd>. This process may vary if you've already deployed a standalone virtual node before and you've just started it using <kbd>vagrant up</kbd>:</p>
<pre><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$ vagrant ssh standalone</strong><br/><strong>[vagrant@standalone ~]$</strong> </pre>
<p>If you are reusing your standalone environment, this means Docker Engine is installed. If you started a new instance, please execute the <kbd>/vagrant/install_requirements.sh</kbd> script so that you have all the required tools (Docker Engine and <kbd>docker-compose</kbd>):</p>
<pre><strong>[vagrant@standalone ~]$ /vagrant/install_requirements.sh</strong> </pre>
<p>Now, you are ready to start the labs.</p>
<h2 id="uuid-1d1df7f2-c86a-47a7-9082-582730849bd9">Signing images for Docker Hub</h2>
<p>First, sign in to <a href="https://hub.docker.com/signup">https://hub.docker.com/signup</a> to create your own account at Docker Hub if you do not already have one. You can use your own registry, but you should have a Notary server running. Let's get started:</p>
<p>This lab will use the <kbd>frjaraur/pingo</kbd> repository in Docker Hub. You must substitute <kbd>frjaraur</kbd> with your username.</p>
<ol>
<li>In this lab, we will start from the very beginning. This is a lab, so don't remove your own <kbd>.docker/trust</kbd> directory if you have been signing images beforehand. In that case, back up your trust directory somewhere safe so that you can recover it later or just create a dummy user in your Docker host system. To create this backup, we will just execute <kbd>cp -pR ~/.docker/trust ~/.docker/trust.BKP</kbd>. After these labs, you can recover it:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ </strong><strong>rm -rf ~/.docker/trust/</strong></pre>
<ol start="2">
<li>Now, enable Docker Content Trust and create a directory for this lab:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ </strong><strong>export DOCKER_CONTENT_TRUST=1<br/><br/>[vagrant@standalone ~]$ cd $HOME<br/>[vagrant@standalone ~]$ mkdir chapter6<br/>[vagrant@standalone ~]$ cd chapter6<br/></strong></pre>
<ol start="3">
<li>We have prepared a quite-simple Dockerfile, executing <kbd>ping</kbd> to <kbd>8.8.8.8</kbd> for <kbd>300</kbd> times. These lab files can be found in the <kbd>chapter6</kbd> directory if you have downloaded the book samples from this book's GitHub repository. Create a <kbd>Dockerfile</kbd> file with the following content using your file editor:</li>
</ol>
<pre style="padding-left: 60px">FROM alpine:3.8 <br/>RUN apk add --update curl <br/>CMD ping 8.8.8.8 -c 300 </pre>
<ol start="4">
<li>Now, we can build the image. Remember that Docker Content Trust was enabled. We will use <kbd>docker image build</kbd> in the directory where you wrote your Dockerfile:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone chapter6]$ </strong><strong>docker image build -t frjaraur/pingo:trusted .</strong><br/><br/><strong>Sending build context to Docker daemon 2.048kB</strong><br/><strong>Step 1/3 : FROM alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9</strong><br/><strong>sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9: Pulling from library/alpine</strong><br/><strong>c87736221ed0: Pull complete </strong><br/><strong>Digest: sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9</strong><br/><strong>Status: Downloaded newer image for alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9</strong><br/><strong> ---&gt; dac705114996</strong><br/><strong>Step 2/3 : RUN apk add --update curl</strong><br/>...<br/>...<br/><strong>Successfully built b3aba563b2ff</strong><br/><strong>Successfully tagged frjaraur/pingo:trusted</strong><br/><strong>Tagging alpine@sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9 as alpine:3.8</strong></pre>
<p style="padding-left: 60px">You may have noticed new messages from the Docker daemon. The daemon used the <kbd>alpine:3.8</kbd> image hash, <kbd>sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9</kbd>, instead of the image name and tag. If we had an image locally with the same <kbd>image:tag</kbd> values, it would have been verified. If the hash did not match, it would have been avoided and the real image would have been downloaded from Docker Hub. This will ensure that the trusted <kbd>alpine:3.8</kbd> image will be downloaded.</p>
<ol start="5">
<li>Now, we will sign this image using <kbd>docker trust sign</kbd>. This process will ask us to create a <kbd>root</kbd> passphrase, a <kbd>repository</kbd> passphrase, and a <kbd>user</kbd> passphrase (this is new in this chapter because we did not use Docker Content Trust in previous chapters). This will create a new <kbd>trust</kbd> directory under <kbd>.docker</kbd><em>.</em> When the image is pushed, you will be asked about your registry user passphrase again. This is not your Docker Hub password. This is the passphrase you created so that you can perform signing. We will use <kbd>docker trust sign</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone chapter6]$ </strong><strong>docker trust sign frjaraur/pingo:trusted</strong><br/><strong>You are about to create a new root signing key passphrase. This passphrase</strong><br/><strong>will be used to protect the most sensitive key in your signing system. Please</strong><br/><strong>choose a long, complex passphrase and be careful to keep the password and the</strong><br/><strong>key file itself secure and backed up. It is highly recommended that you use a</strong><br/><strong>password manager to generate the passphrase and keep it safe. There will be no</strong><br/><strong>way to recover this key. You can find the key in your config directory.</strong><br/><strong>Enter passphrase for new root key with ID 9e788ed: </strong><br/><strong>Repeat passphrase for new root key with ID 9e788ed: </strong><br/><strong>Enter passphrase for new repository key with ID fb7b8fd: </strong><br/><strong>Repeat passphrase for new repository key with ID fb7b8fd: </strong><br/><strong>Enter passphrase for new frjaraur key with ID f1916d7: </strong><br/><strong>Repeat passphrase for new frjaraur key with ID f1916d7: </strong><br/><strong>Created signer: frjaraur</strong><br/><strong>Finished initializing signed repository for frjaraur/pingo:trusted</strong><br/><strong>Signing and pushing trust data for local image frjaraur/pingo:trusted, may overwrite remote trust data</strong><br/><strong>The push refers to repository [docker.io/frjaraur/pingo]</strong><br/><strong>6f02cc23eebe: Pushed </strong><br/><strong>d9ff549177a9: Mounted from library/alpine </strong><br/><strong>trusted: digest: sha256:478cd976c78306bbffd51a4b5055e28873697d01504e70ef85bddd9cc348450b size: 739 </strong><br/><strong>Signing and pushing trust metadata </strong><br/><strong>Enter passphrase for frjaraur key with ID f1916d7: </strong><br/><strong>Successfully signed docker.io/frjaraur/pingo:trusted</strong></pre>
<ol start="6">
<li>With that, the image was signed and pushed to Docker Hub. We can verify that the image was uploaded by using <kbd>curl</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone chapter6]$ curl -s https://hub.docker.com/v2/repositories/frjaraur/pingo/tags|jq</strong><br/><strong>{</strong><br/><strong>  "count": 1,</strong><br/><strong>  "next": null,</strong><br/><strong>  "previous": null,</strong><br/><strong>  "results": [</strong><br/><strong>    {</strong><br/><strong>      "name": "trusted",</strong><br/><strong>      "full_size": 4306493,</strong><br/><strong>      "images": [</strong><br/><strong>        {</strong><br/><strong>          "size": 4306493,</strong><br/><strong>          "digest": "sha256:478cd976c78306bbffd51a4b5055e28873697d01504e70ef85bddd9cc348450b",</strong><br/><strong>          "architecture": "amd64",</strong><br/><strong>          "os": "linux",</strong><br/><strong>          "os_version": null,</strong><br/><strong>          "os_features": "",</strong><br/><strong>          "variant": null,</strong><br/><strong>          "features": ""</strong><br/><strong>        }</strong><br/><strong>      ],</strong><br/><strong>      "id": 78277337,</strong><br/><strong>      "repository": 8106864,</strong><br/><strong>      "creator": 380101,</strong><br/><strong>      "last_updater": 380101,</strong><br/><strong>      "last_updater_username": "frjaraur",</strong><br/><strong>      "image_id": null,</strong><br/><strong>      "v2": true,</strong><br/><strong>      "last_updated": "2019-11-30T22:03:28.820429Z"</strong><br/><strong>    }</strong><br/><strong>  ]</strong><br/><strong>}</strong></pre>
<ol start="7">
<li>Finally, we will review the image signatures using <kbd>docker trust inspect</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone chapter6]$ docker trust inspect --pretty frjaraur/pingo:trusted</strong><br/><strong>Signatures for frjaraur/pingo:trusted</strong><br/><strong>SIGNED TAG DIGEST SIGNERS</strong><br/><strong>trusted 478cd976c78306bbffd51a4b5055e28873697d01504e70ef85bddd9cc348450b frjaraur</strong><br/><strong>List of signers and their keys for frjaraur/pingo:trusted</strong><br/><strong>SIGNER KEYS</strong><br/><strong>frjaraur f1916d7ad60b</strong><br/><strong>Administrative keys for frjaraur/pingo:trusted</strong><br/><strong>Repository Key: fb7b8fdaa22738c44b927110c377aaa7c56a6a15e2fa0ebc554fe92a57b5eb0b</strong><br/><strong> Root Key: 4a739a076032b94a79c6d376721649c79917f4b5f8c8035ca11e36a0ed0696b4</strong></pre>
<p>Now, let's look at a brief summary of the topics that were covered in this chapter before we look at some questions.</p>
<h1 id="uuid-0e32fbd0-c8ec-4d7b-b1f4-e006bb16a940" class="mce-root">Summary</h1>
<p class="mce-root">Docker Content Trust helps us guarantee content security in container environments and ensure image provenance and trusted content. In production environments, it is critical to be able to ensure that any running container was generated from trusted content. If image security cannot be validated, no container should be allowed to run based on that image.</p>
<p class="mce-root">We have learned that Content Trust improves Docker repository security by means of four fundamental keys. The root key ensures ownership and the targets key will allow content to be verified in specific collections or repositories. These keys will be protected by passphrases and we will be asked for them when signing. The snapshot and timestamp keys will not require any user interaction and will be generated automatically to guarantee the content key files and the dates and expiration of the signed image.</p>
<p>In the next chapter, we will introduce the concept of orchestration. We will review all the features required to manage container-based applications in distributed environments.</p>
<h1 id="uuid-efebbb3e-95e7-46e4-98d8-81752e021db9" class="mce-root">Questions</h1>
<ol>
<li>Which of these sentences is not true?</li>
</ol>
<p style="padding-left: 90px">a) Docker Content Trust is based on TUF.<br/>
b) TUF was developed to ensure software updating processes.<br/>
c) It is not possible to validate new software releases.<br/>
d) All of the preceding statements are false.</p>
<ol start="2">
<li>Which of the following names represent Docker Content Trust keys used to validate image content?</li>
</ol>
<p style="padding-left: 90px">a) Targets<br/>
b) Users<br/>
c) Groups<br/>
d) Timestamp</p>
<ol start="3">
<li>How can we ensure that the <kbd>busybox:latest</kbd> release is, in fact, the latest one?</li>
</ol>
<p style="padding-left: 90px">a) We cannot ensure the freshness of images.<br/>
b) <kbd>busybox:latest</kbd> indicates that this image is the latest one created.<br/>
c) Content Trust will validate the freshness of images; therefore, we can ensure that the host really executes the <kbd>busybox:latest</kbd> image, although we cannot ensure that it is the latest one.<br/>
d) All of the preceding statements are false.</p>
<ol start="4">
<li>Why will we obtain a <kbd>denied: requested access to the resource is denied</kbd> error when trying to sign <kbd>busybox:trusted</kbd>?</li>
</ol>
<p style="padding-left: 90px">a) This image does not exist.<br/>
b) We are not allowed to modify that repository.<br/>
c) Docker Content Trust was probably not enabled.<br/>
d) All of the preceding.</p>
<ol start="5">
<li>We lost our root key because we changed our laptop. Which of the following statements is true?</li>
</ol>
<p style="padding-left: 90px">a) If we don't have a key under <kbd>.docker/trust/private</kbd>, a new one will be generated when signing.<br/>
b) We can recover the private root key if we perform a backup.<br/>
c) If we generate a new key, our old images will become untrusted and we will need to resign them.<br/>
d) All of the preceding statements are true.</p>
<h1 id="uuid-8cfffdaf-87e1-43b7-8826-74975af03605">Further reading</h1>
<p>You can refer to the following links for more information on the topics that were covered in this chapter:</p>
<ul>
<li>TUF: <a href="https://theupdateframework.io/">https://theupdateframework.io/</a></li>
<li>TUF specification: <a href="https://github.com/theupdateframework/specification">https://github.com/theupdateframework/specification</a></li>
<li>Notary: <a href="https://github.com/theupdateframework/notary">https://github.com/theupdateframework/notary</a></li>
<li>Docker Content Trust: <a href="https://docs.docker.com/engine/security/trust/content_trust/">https://docs.docker.com/engine/security/trust/content_trust/</a></li>
</ul>


            

            
        
    </body></html>