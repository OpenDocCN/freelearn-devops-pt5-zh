- en: Chapter 6. The Power of JIRA Searching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a JQL function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizing JQL functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a search request view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart querying using quick search
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching in plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a JQL query in plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking directly to search queries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index and de-index programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing filters programmatically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIRA is known for its search capabilities. It allows us to extend them in a
    way that impresses its users! In this chapter, we will look at customizing the
    various searching aspects of JIRA such as JQL, searching in plugins, managing
    filters, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start, it would make sense to look at one of the major enhancements
    in JIRA 4, that is, **JQL** – **JIRA Query Language**. JQL brings to the table
    advanced searching capabilities, using which the users can search for issues in
    their JIRA instance and then exploit all the capabilities of issue navigator.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the previous searching capabilities, now called **Simple Searching**,
    JQL or the **Advanced Searching** introduces support for logical operations, including
    AND, OR, NOT, NULL, and EMPTY. It also introduces a set of JQL functions, which
    can be used effectively to search based on predefined criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'JQL is a structured query language that lets us find issues using a simple
    SQL-like syntax. It is simple because of its auto-complete features and maintains
    a query history to navigate easily to the recent searches. As Atlassian puts it:'
  prefs: []
  type: TYPE_NORMAL
- en: '"JQL allows you to use standard boolean operators and wild cards to perform
    complex searches, including fuzzy, proximity, and empty field searches. It even
    supports extensible functions, allowing you to define custom expressions like
    "CurrentUser" or "LastSprint" for dynamic searches."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'A query in *Advanced Search* consists of a **field**, followed by an **operator**,
    followed by a **value** or **function**. To find out all issues in a project,
    we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`project` is the field, `=` is the operator, and `TEST` is the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can find all issues assigned to the current user using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '`assignee` is the field, `=` is the operator, and `currentUser()` is a JQL
    function.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point of time, JQL doesn''t support comparison of two fields or two
    functions in a single query. But we can use logical operators and keywords to
    introduce more control as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This query will display issues that are in the project `TEST` and that have
    the current user as the `assignee`. A more detailed explanation on Advanced Searching,
    along with the full reference to the Keywords, Operators, Fields, and Functions
    used can be found at [http://confluence.atlassian.com/display/JIRA/Advanced+Searching](http://
    http://confluence.atlassian.com/display/JIRA/Advanced+Searching).
  prefs: []
  type: TYPE_NORMAL
- en: Writing a JQL function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, a **JQL function** allows us to define custom expressions or
    searchers. JIRA has a set of built-in JQL functions, the details of which can
    be found at [http://confluence.atlassian.com/display/JIRA/Advanced+Searching#AdvancedSearching-FunctionsReference](http://confluence.atlassian.com/display/JIRA/Advanced+Searching#AdvancedSearching-FunctionsReference).
    In this recipe, we will look at writing a new JQL function.
  prefs: []
  type: TYPE_NORMAL
- en: JQL functions provide a way for values within a JQL query to be calculated at
    runtime. It takes optional arguments and produces results based on the arguments
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, let us consider creating a function `projects()`, which can
    take a list of project keys and return all issues in the supplied projects. For
    example,
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It will be equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We are introducing this new function just for the sake of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using the Atlassian plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JIRA uses the **JQL Function Module** to add new JQL functions to the Advanced
    Search. The following is the step-by-step process for our example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the plugin descriptor to include the JQL function module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As with any other plugin modules, a JQL function module also has a unique **key**.
    The other major attribute of the function module is the function **class**. In
    this example, `ProjectsFunction` is the function class. The root element, `jql-function`,
    has two other elements—`fname` and `list`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`fname` holds the JQL function name that is visible to the user. This will
    be used in the JQL query.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`list` indicates whether the function returns a list or not. In our example,
    we return a list of projects, and hence we use the value `true` to indicate that
    it is a list. A list can be used along with operators `IN` and `NOT` `IN`, whereas
    a scalar can be used with operators `=`, `!=`, `<`, `>`, `<=`, `>=`, `IS`, and
    `IS` `NOT`.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Implement the function class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The class name here is the name used in the module description, `ProjectsFunction`
    in this case. The class should extend the `AbstractJqlFunction` class. We now
    need to implement the major methods detailed next:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getDataType` – This method defines the return type of the function. In our
    example, we take a list of project keys and return valid projects, and hence we
    will implement the method to return the `PROJECT` datatype as follows:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Check out the `JiraDataTypes` class to see other supported data types.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getMinimumNumberOfExpectedArguments` – It returns the smallest number of arguments
    that the function may accept. The auto-population of the method in the issue navigator
    takes this into consideration and puts sufficient double quotes within brackets
    when the function is selected.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, in our case, we need at least one project key in the function
    name and hence we `return 1` as follows:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The pre-populated function will then look like `projects("")`.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '`validate` – This method is used to do validation of the arguments we have
    passed. In our example, we need to check if the method has at least one argument
    or not and make sure all the arguments passed are valid project keys. The validate
    method looks like the following:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here we instantiate a new `MessageSet` and add error messages to it, if the
    validation fails. We must always return a `MessageSet`, even if it is empty. Returning
    `null` is not permitted. We can also add warning messages which doesn't prevent
    the JQL execution, but warns the user about something.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The most important argument in the `validate` method is `FunctionOperand`, as
    it holds the arguments of the function which can be retrieved as `operand.getArgs()`.
    The other argument `terminalClause` is JIRA's representation of the JQL condition
    we are validating for. We can extract the name, operator, and function from the
    argument using `terminalClause.getName`, `terminalClause.getOperator`, and `terminalClause.getOperand`
    respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `AbstractJqlFunction` has a validation method in it to check the number
    of arguments. So if we know the expected number of arguments (which is not the
    case in our example as we can have any number of projects passed in the example),
    we can validate it using:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code adds an error if the number of arguments is not 1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`getValues` – This is the method that takes the arguments and returns the date
    type as a list or scalar depending on the function. In our example, the `getValues`
    method returns a list of literals that has the project ID.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The method is implemented as follows in our example:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: '`notnull()` is a predefined method from the `Asserions` class that checks whether
    the query creation context is null or not and throws an error if null. This is
    not mandatory and can be handled in some other way if needed.'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: The arguments `operand` and `terminalClause` are the same as what we have seen
    in the validate method. The `QueryCreationContext` argument holds the context
    in which the query is executed. `QueryCreationContext.getUser` will retrieve the
    user who executed the query, and the `QueryCreationContext.isSecurityOverriden`
    method indicates whether or not this function should actually perform security
    checks.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The function should always return a list of `QueryLiteral` objects. Even when
    the function returns a scalar instead of list, it should return a list of `QueryLiteral`,
    which can be created like the following:'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: A `QueryLiteral` represents either a `String`, `Long`, or `EMPTY` value. These
    three represent JQL's distinguishable types. Construct it with no value and it
    will represent EMPTY, construct it with a String and it represents a String, or
    construct it with a Long and it represents a Long.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, we use the project ID (LONG) which is unique across projects.
    For projects, we can even use the key (STRING) or name (STRING), as they are also
    unique. However, it may not work with fields such as Fix For Version as you might
    find two Fix Versions with the same name. It is recommended to return the ID wherever
    possible to avoid such unambiguous search results.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: To summarize, we find out the project objects using the project keys supplied
    by the user and return a list of `QueryLiterals`, created using the project IDs.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the plugin is deployed, we can go to the Issue Navigator and open the
    advanced search to start using our brand new function! When you start typing **project
    in** **p**, JIRA auto-populates the available options including our new function,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the function with appropriate arguments is added, the search is executed
    and results are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When an invalid project key is given as the argument, our `validate` method
    populates the error message, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a skeleton plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process"), *Plugin Development Process*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying your plugin*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sanitizing JQL functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don't want to make your JQL function violate the strict security aspects
    of your JIRA instance, sanitizing the JQL functions is a must! So, what does this
    actually mean?
  prefs: []
  type: TYPE_NORMAL
- en: Imagine a filter created by you to find out issues in a pre-defined set of projects.
    What will happen if you share the filter with a friend of yours who is not supposed
    to see the project or know that the project existed? The person with whom you
    shared it won't be able to modify the issues in the protected project due to JIRA's
    permission schemes but he/she will surely see the name of the project in the JQL
    query that is used in the filter!
  prefs: []
  type: TYPE_NORMAL
- en: This is where sanitizing of the JQL function will help. In essence, we just
    modify the JQL query to protect the arguments in line with the permission schemes.
    Let us see an example of doing that by sanitizing the JQL function we created
    in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Develop the JQL function, as explained in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our JQL function, we use the project keys as the arguments. To explain the
    Function Sanitization, we will look to replace the keys with project IDs whenever
    the user doesn''t have the permission to browse a project. The following is the
    step-by-step process showing you how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the JQL function class to implement the `ClauseSanitisingJqlFunction`
    interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `sanitiseOperand` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here we read all the existing arguments of the JQL function, from the `FunctionOperand`
    argument, and modify it to include project IDs instead of keys, wherever the user
    doesn''t have Browse permissions:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Package and deploy the modified plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the plugin is deployed, if a user doesn't have the permission to browse
    a project, he/she will see the project ID instead of the key that was originally
    entered when the filter was created. Following is a sample screenshot of how the
    query will look in that case. In this case, I just removed myself from the Browse
    permission of the `TEST` project, and you can see that the query is modified to
    replace the key `TEST` with its unique ID, which doesn't reveal much information!
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What if you try to edit the filter now? Our validation will now kick in as it
    is not able to find a project with the ID, as shown next! Nice, eh?
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is only an example, and we can sanitize the query in a similar way in every
    other case.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a JQL function*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a search request view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the customizable features in JIRA is its **Issue Navigator**. It lets
    us search based on numerous criteria, choose the fields that need to be shown,
    in a way we want to see them!
  prefs: []
  type: TYPE_NORMAL
- en: The normal or the default view in the issue navigator is the tabular view to
    display the issues and the fields we have chosen by configuring the issue navigator.
    JIRA also gives us a few other options to see the search results in different
    formats, to export them into Excel, Word, or XML, and so on with the help of the
    pre-defined search request views.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can add more search views in to JIRA that
    enables us to see the search results in a format we like. To achieve this we need
    to use the **Search Request View Plugin** module.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a plugin skeleton using Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned before, we use the Search Request View Plugin module to create
    custom search views. In our example, let us create a simple HTML view that just
    displays the issue key and summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the step-by-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Define the plugin descriptor with the search request view module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As usual, the module has a unique key. Following are the other attributes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`name`: The name that will appear in the Issue Navigator for the View'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`class`: The search request view class. This is where we populate the velocity
    contexts with the necessary information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`contentType`: The `contentType` of the file that is generated. `text/html`,
    `text/xml`, `application/rss+xml`, `application/vnd.ms-word`, `application/vnd.ms-excel`,
    and so on'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fileExtension`: The extension of the file generated. `html`, `xml`, `xml`,
    `doc`, `xls`, and so on'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`state`: Enabled or disabled. Determines whether the module is enabled at startup'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Search-Request-View element also has few child elements to define the velocity
    templates required for the various views and to determine the `order` in which
    the views will appear. Modules with lower `order` values are shown first. JIRA
    uses an order of 10 for the built-in views. A lower value will put the new view
    above the built-in views and a higher value will put the new view at the bottom.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the Search Request View class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Search Request View class must implement the `SearchRequestView` interface.
    To make things easier, we can extend the `AbstractSearchRequestView` class that
    already implements this interface. When we do that, we have one method, `writeSearchResults`,
    to be implemented!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This method takes a writer argument using which we can generate the output
    using the various template views we define. For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It will identify the velocity template with the view named as `header` and will
    use the variables on the map – `headerParams` to render the template. We can similarly
    define as many templates as we want and write them to create the view that we
    need.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, we have three views defined – header, body, and footer. These
    views can be named in any way we want, but the same names that we define in the
    `atlassian-plugin.xml` should be used in the Search Request View class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In our class implementation, we use the three views to generate the simple
    HTML view. We use the header and footer views in the beginning and end and will
    use the body view to generate the issue view for each individual issue in search
    results. The following is how we do it:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Generate a map with the default velocity context parameters:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Populate the map with the variables that we need in the context to render the
    header template and write the header. In our example, let us keep the header fairly
    simple and just use the filter name and the current user:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to write the search results. We should iterate over each issue
    in the search results and write it to the writer using the format we defined.
    To ensure that this doesn''t result in huge memory consumption, only one issue
    should be loaded into memory at a time. This can be guaranteed by using a **Hitcollector**.
    This collector is responsible for writing out each issue as it is encountered
    in the search results. It will be called for each search result by the underlying
    Lucene search code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: All we do here is define the `HitCollector` and invoke the `searchAndSort` method,
    which will then use the `HitCollector` to generate the view for each issue. Here
    we can add more variables if we need them in the view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now write the footer before we finish. Let us again put the user just
    for educational purpose:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here we created a simple map just to show that we need only the variables we
    use in the view.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The method will now look as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the velocity templates. As we saw, we are using three views:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Header** – The velocity template is `templates/searchrequest-html-header.vm`.
    The following is how it looks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We just greet the user and display the filter name here. It also has a `<table>`
    tag which is used at the beginning of the issue table. The table will be closed
    in the footer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Body** – The velocity template is `templates/searchrequest-html-body.vm`.
    The following is how it looks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Whatever appears here is common to all the issues. Here we create a table row
    for each issue and display the key and summary appropriately.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Footer** – The velocity template is `templates/searchrequest-html-footer.vm`.
    The following code shows how it looks:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: We just close the table and wind up with a message!
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the plugin is deployed, we will find a new view in the issue navigator
    named **Simple HTML View**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On selecting the view, the current search results will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If the results belong to a filter, it will display the filter name instead
    of Anonymous:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-06-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is now left to our creativity to make it more beautiful or use an entirely
    different content type instead of HTML. An example of how an XML view is generated
    can be found in the JIRA documentation at [https://developer.atlassian.com/display/JIRADEV/Search+Request+View+Plugin+Module](https://developer.atlassian.com/display/JIRADEV/Search+Request+View+Plugin+Module).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Creating a skeleton plugin* in [Chapter 1](ch01.html "Chapter 1. Plugin Development
    Process"), *Plugin Development Process*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deploying your plugin*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smart querying using quick search
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name says it all! JIRA allows smart querying using its Quick Search functionality
    and it enables the users to find critical information with ease. There is a pre-defined
    set of search keywords that JIRA recognizes and we can use them to search smart
    and fast!
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will look at how we can do smart querying on some of the
    JIRA fields.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start, the **Quick Search** box is located at the right-hand top
    corner of JIRA, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-06-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following is how we can search on some of the fields as of JIRA 4.4\. Don't
    forget to check how many of them are supported in your version of JIRA!
  prefs: []
  type: TYPE_NORMAL
- en: '**Issue key**: If you already know the issue key that you want to see, it doesn''t
    get any better! Just type the issue key in the **Quick Search** box and JIRA will
    take you to the view issue page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And there's more! If you are browsing a project or viewing an issue and if you
    want to see another issue for which the key is known, all you need to type is
    the number in the unique key (just the numerical part). There isn't even a need
    to type in the full key.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For example, **TEST-123** will take you to that issue directly. Typing **125**
    will then take you to **TEST-125**!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Project**: If you type in the project key, the quick search will show you
    all the issues in that particular project. The project name can also be used as
    long as there are no spaces in it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, **TEST** will return all issues in the project `TEST` or a project
    with the key **TEST**. 'TEST Project' will not display issues in the project with
    the name 'Test Project', as the quick search interprets it as two different keywords.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Assignee**: The keyword **my** can be used to find all issues assigned to
    me.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reporter**: The keyword **r:** is followed by **me**, or the *reporter name*
    can find all issues reported by me or the user respectively For example, **r:none**
    is also supported and it returns issues without any reporter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**r:me** will retrieve all issues reported by me, whereas **r:admin** will
    retrieve all issues reported by the user – admin.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Date** **fields**: Quick Search can be done based on the three major date
    fields on the issue – **created**, **updated**, and **due** **date**. The keywords
    used are **created**, **updated**, and **due** respectively. The keyword should
    be followed by **:** and the date range without any spaces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The date range can use one of the following keywords – **today**, **tomorrow**,
    **yesterday**, or a single date range (for example,. ''-5d'') or two date ranges
    (for example,. ''-2w,1w''). The date ranges cannot have spaces in them. Valid
    date/time abbreviations are: ''w'' (week), ''d'' (day), ''h'' (hour), and ''m''
    (minute). For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**created:today** will retrieve all issues created on the date.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**updated:-5d** will retrieve all issues updated in the last five days.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**due:-2w,1w** will retrieve all issues due in the last two weeks and in the
    next week.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use the keyword **overdue** to retrieve all issues that are overdue
    (has a past due date).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Priority**: The quick search can be done using the priority values **blocker**,
    **critical**, **major**, **minor**, and **trivial**. Just typing the value will
    retrieve all the issues that have the given priority value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, all issues with the priority **major** can be retrieved by searching
    with **major**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**IssueType**: Issue type names can be used in the Quick search as long as
    it doesn''t have any spaces in it. Even plurals will work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, typing **bug** or **bugs** will retrieve all the issues with the
    issue type of bug.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Versions**: Quick Search can find issues with known Affected Versions or
    Fix for versions using the keywords **v:** or **ff:** followed by the value without
    any space. There shouldn''t be any spaces between **v:** and the version name.
    It can also use wild card search. The search will also find all issues with version
    values that contain the string you specify, followed immediately by a space. For
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**v:2.0** will find issues in versions – 2.0, 2.0 one, 2.0 beta, and so on.
    But it wouldn''t find issues in version 2.0.1'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**v:2.*** will find issues in versions – 2.0, 2.0 one, 2.0.1, 2.2, and so on.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The same applies to fixes for versions. The prefix only changes to ff:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Components**: Quick search can find issues with component names using the
    prefix **c:** followed by the component name. It will retrieve all issues where
    the component has the value somewhere in its name, not necessarily starting with
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, **c:jql** will find all issues in components that have the word
    'jql' in it. It will work for the components jql, jql performance, advanced jql,
    and so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Quick Search can also be used to search for any word within the issue(s) you
    are looking for, provided the word is in the summary, description, or comments
    of the issue. It is called **Smart** **Search**.
  prefs: []
  type: TYPE_NORMAL
- en: If you think you want to use any of these keywords without using Smart search,
    the query can be run without smart search when the results are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Smart Querying can have multiple keywords combined to narrow down the search.
    It can even be combined with Free Text Search.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, **my open bugs** will retrieve all bugs that are opened and assigned
    to me. It is equivalent to the JQL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '**my open bugs jql** will retrieve all bugs that are opened and assigned to
    me and has the word ''jql'' in its summary, description, or comments. It is equivalent
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '**my open bugs jql performance** is equivalent to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: More on advanced searching or JQL can be found at [http://confluence.atlassian.com/display/JIRA/Advanced+Searching](http://confluence.atlassian.com/display/JIRA/Advanced+Searching).
  prefs: []
  type: TYPE_NORMAL
- en: Searching in plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the invention of JQL, JIRA Search APIs have changed drastically from 3.x
    versions. Searching in plugins is now done using APIs supporting JQL. In this
    recipe, we will see how to search for issues within our plugins using those APIs.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the sake of concentrating on the search APIs, we will look at writing a
    simple method, `getIssues()`, that returns a list of issue objects based on some
    search criteria.
  prefs: []
  type: TYPE_NORMAL
- en: The essence of searching is to build a `Query` object using `JqlQueryBuilder`.
    A `Query` object will have a `where` clause and an `order by` clause, which are
    built using the `JqlClauseBuilder`. We can also incorporate conditions in between
    clauses using `ConditionBuilders`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let us assume we want to find all the issues in a particular project
    (project ID: 10000, Key: DEMO) and assigned to the current user within our plugin.
    The JQL equivalent for this is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the steps to do this programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a JqlQueryBuilder ([http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlQueryBuilder.html](http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlQueryBuilder.html))
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`JqlQueryBuilder` is used to build the query that is used to perform issue
    searching. The following is how a `JqlQueryObject` is created:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a `where` clause that returns a JqlClauseBuilder ([http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlClauseBuilder.html](http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/jql/builder/JqlClauseBuilder.html)).
    A query is constructed with one or more JQL clauses with different conditions
    added in between.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`builder.where()` returns a `JqlClauseBuilder` object for our `QueryBuilder`
    on which we can then add multiple clauses.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the project clause to search for a project with its ID as argument. The
    project clause will return a `ConditionBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `assignee` clause using the `AND` condition on the `ConditionBuilder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can have numerous clauses added like this using the different conditions.
    Let us see some examples in the 'There's More...' section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add ordering, if you have any, using the `Order By` clause. We can sort based
    on assignee as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SortOrder.DESC` can be used for descending orders.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Build the `Query` (`com.atlassian.query.Query`) object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Query` object is immutable; once it is created it cannot be changed. The
    `JqlQueryBuilder` represents the mutable version of a `Query` object. We can create
    a Query from an already existing Query by calling `JqlQueryBuilder.newBuilder(existingQuery)`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get an instance of the `SearchService`. It could be injected in the constructor
    of your plugin using dependency injection or can be retrieved from the `ComponentManager`
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Search using the query to retrieve the SearchResults ([http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/search/SearchResults.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/issue/search/SearchResults.html)):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we used `PagerFilter.getUnlimitedFilter()` to retrieve all the results.
    It is possible to limit the results to a particular range, say from 20 to 80 results,
    using the method `PagerFilter.newPageAlignedFilter(index, max)`. This will be
    useful when Pagination is done, such as in the case of issue navigator.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Retrieve the issues from the search results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The entire method will look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Hopefully, that is a good starting point from which to write more complex queries!
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As promised earlier, let us look at writing complex queries with a couple of
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can extend the aforementioned search to include multiple projects, assignees,
    and a custom field. The JQL representation of the query will be:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `where` clause is written as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 10000L is the ID of the custom field Customer Name.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can group the conditions using `sub()` and `endsub()` to write even more
    complex queries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can be written as:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Similarly, we can write more complex queries.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a JQL funcion*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parsing a JQL query in plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to build a Query to search within JIRA. In
    this recipe, we will see searching again, but without building a Query using the
    APIs. We will use the JQL Query as it is written in the Issue Navigator in advanced
    mode and search using the same.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose we know the query that we want to execute. Let us assume it is the
    same we saw in the previous recipe: `project = "DEMO" and assignee = currentUser()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is how we do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Parse the JQL query:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Check if the parsed result is valid or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the result is valid, get the `Query` object from the `ParseResult`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Search for the issues and retrieve the `SearchResults`, as we have seen in
    the previous recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the list of issues from the search results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here the `parseQuery` operation in `SearchService` converts the `String` JQL
    query in to the `Query` object we normally construct using `JqlQueryBuilder`.
    The actual parse operation is done by `JqlQueryParser` behind the scenes.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Searching in plugins*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking directly to search queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Haven't you wondered how we can link to a query from a template or JSP from
    a custom page or plugin page? In this recipe, we will see how we can create a
    link programmatically and otherwise to use in various places.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us first look at creating a search link programmatically. Perform the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the `Query` object using `JqlQueryBuilder`, as we have seen in the previous
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get an instance of the `SearchService`. It could be injected in the constructor
    of your plugin using dependency injection or can be retrieved from the `ComponentManager`
    class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the query string from the `Query` object using `SearchService`, as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Construct the link using the context path. In JSPs, you can do it as shown
    next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `getQueryString()` in the `Action` class returns the preceding `queryString`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'And in velocity templates:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `$queryString` is the preceding `queryString` in context!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `mode` parameter can have the values `hide` or `show` depending on whether
    you want to open the issue navigator in view or edit mode!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `getQueryString` method in `SearchService` returns the `queryString` in
    a manner in which it can be used in a URL. It starts with `&jqlQuery=`, followed
    by the actual query as a web URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Linking to a Quick Search is also pretty easy and useful. We can even store
    such searches in our browser favorites. All we need to do is find out the URL
    by replacing `%s` in JIRA''s URL as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://<Context_Path>/secure/QuickSearch.jspa?searchString=%s`'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if your JIRA instance is `http://localhost:8080/` and you want
    to Quick Search for all the issues where you are the assignee, the relevant quick
    search string will be: **my open**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'And the URL will then be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/QuickSearch.jspa?searchString=my+open`'
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the spaces in Quick Search are replaced by `+` while substituting
    `%s`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/QuickSearch.jspa?searchString=my+open+critical`
    retrieves all open critical issues assigned to you'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/QuickSearch.jspa?searchString=created:-1w+my`
    retrieves all the issues assigned to you, created in the past week'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Index and de-index programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen in the JIRA architecture explained in [Chapter 2](ch02.html
    "Chapter 2. Understanding Plugin Framework"), *Understanding Plugin Framework*,
    searching in JIRA is based on Apache Lucene. The Lucene indexes are stored in
    the File System and are used as the basis for the search queries executed in JIRA.
    Whenever an issue is updated, more records are created or existing records are
    updated for that particular issue in the filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to programmatically index selected or all issues or de-index
    an issue. Also, we can switch OFF or ON indexing selectively in our plugins if
    needed. In this recipe, we will see both of these.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the indexing operations can be done with the help of `IssueIndexManager`.
    An instance of `IssueIndexManager` can be created either by injecting in the constructor
    or as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the important operations supported by `IssueIndexManager`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`reIndexAll()` – Indexes all the issues in JIRA. A good method if you want
    a custom admin operation to do indexing as well!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reIndex(GenericValue issue)`or `reIndex(Issue issue)` – To selectively index
    an issue by passing the `Issue` object or its `GenericValue`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deIndex(GenericValue issue)` – Method to de-index an issue. Once this is done,
    the issue won''t appear in the search results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Be aware that when the issue is later updated or a comment is added on the issue,
    JIRA automatically indexes again. So don't rely on calling this just once to permanently
    hide your issue from searches. To do so, the `IssueIndexer` should be overridden
    so that it won't index the issue again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`reIndexIssues(final Collection<GenericValue> issues)or reIndexIssueObjects(final
    Collection<? extends Issue>issueObjects)` – Indexes a Collection of issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checkout the Java Docs at [http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/issue/index/IssueIndexManager.html](http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/issue/index/IssueIndexManager.html)
    for more available methods on the `IssueIndexManager`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to make sure that indexing is turned ON when we make a major update
    on an issue, we can do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here we use `ImportUtils` to save the current indexing state and turn it ON.
    After the update to issue(s) is done, indexing is turned back to whatever it was!
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Searching in plugins*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing filters programmatically
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Be it a beginner in JIRA or a pro, one of the features used often is creating
    and managing filters. The fact that we can save the searches, share them, and
    subscribe to it adds a lot of value to JIRA. So, how do we programmatically create
    and manage filters?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to manage filters programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will see the various aspects of managing the filters one-by-one:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Creating a filter**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the operations on managing filters are done using `SearchRequestService`.
    For creating a filter, following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the Query to be saved as filter. The Query can be created using `JqlQueryBuilder`,
    as we have seen in the previous recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `SearchRequest` object from the Query
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JIRA Service Context. If you are in an action class, you can get the
    service context by calling `getJiraServiceContext()` and if not, an instance can
    be created as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where user is the user for which the filter should be created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Get an instance of `SearchRequestService`. It can be either injected in the
    constructor or as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the filter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where `favourite` is a boolean which can be set to true, if you want the filter
    to be made a favorite.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Updating a filter**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Updating a filter is much similar to creating a filter. Once the `SearchRequest`
    is updated and context is created, we need to invoke the following method to update
    and persist in the database the filter with the new search parameters, that is,
    the new query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'To update the attributes such as name, description, and so on, one of the following
    methods is invoked, depending on whether we want to make the filter favorite or
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '**Deleting a filter**'
  prefs: []
  type: TYPE_NORMAL
- en: 'JIRA takes the filter ID as the input for deleting a filter. Before we actually
    delete the filter, we need to validate the deletion as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: If there are any errors, it will be added into the Action's error collection.
    We can then check for the errors and delete the filter, if there are no errors.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also delete all the filters of a user using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '**Retrieving filters**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SearchRequestService` also has few methods to retrieve favorite filters,
    filters owned by a user, non-private filters, and so on. Key methods are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The method names are self explanatory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sharing a filter**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to share a filter, we need to retrieve the relevant filter and set
    the permissions on it using:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Where permissions is a set of `SharePermission` objects. The `SharePermission`
    objects can be created from a JSONArray using the `SharePermissionUtils utility`
    class. The JSONObject can have three keys – `Type`, `Param1`, and `Param2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Type` can have the following values: `global`, `group`, or `project`.'
  prefs: []
  type: TYPE_NORMAL
- en: When `Type` is `global`, `Param1` and `Param2` are not required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is `group`, `Param1` is populated with the `groupname`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When it is `project`, `Param1` is the ID of the project and `Param2` is the
    ID of the project role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Example of JSON arrays is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Searching in plugins*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to a filter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen various methods of managing filters. While filters are a great
    way to save searches and access them quickly at a later point of time, filter
    subscriptions are even better! The subscriptions help us to see the issues of
    interest at regular intervals without even logging in to JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: How do we subscribe to a filter programmatically? In this recipe, we will focus
    on subscribing to a filter in our plugins.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the subscription of filters, JIRA provides a manager class implementing
    the `FilterSubscriptionService` interface. This class provides the important methods
    needed for managing filter subscriptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three important parameters for Filter Subscriptions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cron Expression**: This is the most important part of a subscription. It
    tells us when the subscription has to run, or in other words, it defines the schedule
    of a subscription.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cron expressions consist of the following fields separated by spaces.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Field | Allowed Values | Allowed Special Characters |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Second` | 0-59 | `, - * /` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Minute` | 0-59 | `, - * /` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Hour` | 0-23 | `, - * /` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Day-of-Month` | 1-31 | `, - * / ? L W C` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Month` | 1-12 Or JAN-DEC | `, - * /` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Day-of-week` | 1-7 Or SUN-SAT | `, - * / ? L C #` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `Year (Optional)` | 1970-2099 | `, - * /` |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'The special characters denote the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| Special Character | Usage |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `,` | List of values. For example, ''MON,WED,FRI'' means ''every Monday,
    Wednesday, and Friday''. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `-` | Range of Values. For example, ''MON-WED'' means ''every Monday, Tuesday,
    Wednesday''. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `*` | All possible values. For example, * in the `Hour` field means ''every
    hour of the day''. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `/` | Increments to the give value. For example, 1/3 in `Hour` field means
    '' every 3 hours during the day, starting from 1.00 AM''. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `?` | No particular value. This is useful when you need to specify a value
    for only one of the two fields, `Day-of-month` or `Day-of-week`, but not the other.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `L` | Last possible value. It has different meanings based on the context.
    For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: L in `Day-of-week` means 'Last day of every week'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 7L means 'last Saturday of the month'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: L in `Day-of-month` means 'last day of the month'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: LW means 'last weekday of the month'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '| `W` | Weekday (MON-FRI) nearest to the given day of the month.For example,
    1W means ''nearest working day to the 1st of the month'' – useful when you want
    to get the first working day of the month!It cannot be used with a range of days.
    |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| `#` | N''th occurance of a given day of the week.For example, MON#3 means
    ''3rd Monday of the month'' |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: 'We need to create a valid Cron expression based on the subscription we want
    to set up. The following are some examples based on these rules:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`0 7 30 * * ?` – 7:30 AM Every Day'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`0 0/15 15 * * ?` – Every 15 minutes starting at 3.00PM ending at 3:59 PM'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find more examples in the Atlassian documentation for filter subscriptions
    at [http://confluence.atlassian.com/display/JIRA/Receiving+Search+Results+via+Email](http://confluence.atlassian.com/display/JIRA/Receiving+Search+Results+via+Email).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Group Name**: This is the group that we want to subscribe the filter. If
    the value is null, it will be considered as a personal subscription and the user
    in the context will be used.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Email On Empty**: It is a boolean value which is `true` if you want the subscription
    to send an e-mail, even when it has no results.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let us see the steps to subscribe to a known filter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get an instance of the `FilterSubscriptionService`. You can either inject the
    class in the constructor or get it using the `ComponentManger` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the cron expression based on the aforementioned rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the group name. Use `null` if it is a personal subscription:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a JIRA Service Context. If you are in an action class, you can get the
    service context by calling `getJiraServiceContext()`, and if not, an instance
    can be created as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Where `user` is the user for whom the filter is subscribed, in case it is a
    personal subscription.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define whether an e-mail should be sent, even when the number of results is
    zero or not:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Validate the cron expression:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If there are any errors, the Error Collection in `JiraServiceContext` will be
    populated with an error message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If there are no errors, use the `FilterSubscriptionService` class to store
    the subscription:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `filterId` is the ID of the filter we want to subscribe to and can be obtained
    as `searchRequest.getId()`!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The subscription should now be saved and the mails will be sent based on the
    schedule defined by the cron expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also update an existing subscription using `FilterSubscriptionService`
    using the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Where `subId` is the existing subscription ID!
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each subscription we create is stored as **Quartz** scheduled jobs in the system,
    which runs based on the cron expression we have defined while storing the subscription.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to use a Web Form, like the one used in JIRA, to create filter subscriptions
    and you don't want to write the cron expression, you can create a `CronEditorBean`
    using the parameters from the Web Form.
  prefs: []
  type: TYPE_NORMAL
- en: The various attributes supported in the form can be found from the `CronEditorBean`
    class. The Java Docs can be found at [http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/web/component/cron/CronEditorBean.html](http://docs.atlassian.com/software/jira/docs/api/latest/com/atlassian/jira/web/component/cron/CronEditorBean.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the `CronEditorBean` is created, it can be parsed into a cron expression
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Searching in plugins*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
