- en: The Future of Serverless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter discusses what lies ahead beyond FaaS. We will start by discussing
    a new experimental technique to restore the speed of the container runtime by
    introducing RunF, a libcontainer-based runtime designed for invoking immutable
    function containers. This chapter will continue the discussion of the possibility
    of using LinuxKit to prepare immutable infrastructure for FaaS platforms in general.
    We conclude this chapter by exploring a new architecture to hybrid the FaaS architecture
    on-premises with the serverless architecture on the public cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Before going to these topics, let's start by summarizing what we have learned
    so far.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: FaaS and Docker reviews
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime for function containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LinuxKit – immutable infrastructure for FaaS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Beyond serverless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FaaS and Docker reviews
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we introduced serverless, the FaaS platforms, and how Docker is
    relevant to this technology. We learned together about how to set up Docker Swarm
    clusters on production.
  prefs: []
  type: TYPE_NORMAL
- en: The book discussed three well-known FaaS platforms, which are *OpenFaaS*, *OpenWhisk*,
    and the *Fn Project*. OpenFaaS uses the Swarm-based orchestrator, while OpenWhisk
    and Fn used their own scheduling techniques on plain Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we demonstrated a project in [Chapter 8](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml),
    *Putting Them All Together*, to present how we can link all of these three platforms
    together, by running them on the same network of a Docker cluster. The project
    was demonstrated on how we could invoke the services of other FaaS platforms.
    Functions written in several programming languages were presented including Java,
    Go, and JavaScript (Node.js).
  prefs: []
  type: TYPE_NORMAL
- en: We used Java to write a simple function. For modern programming models, we could
    use the RxJava library to help writing Java programs in the reactive style, which
    fit very nicely for the event-driven programming.
  prefs: []
  type: TYPE_NORMAL
- en: With JavaScript, we wrote a Chrome-based scripting to connect through. We also
    deployed a blockchain to demonstrate that it works nicely with the FaaS computing
    model.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we will discuss some advanced, experimental topics
    that go deeply or beyond the current scope of serverless and FaaS. However, some
    of them may be going to be mainstream in the near future.
  prefs: []
  type: TYPE_NORMAL
- en: Runtime for function containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important components of the container ecosystem is the **container
    runtime**. During the early days of Docker, the runtime was LXC, then it changed
    to be the Docker-owned libcontainer. The libcontainer was later donated to **OCI**,
    the **Open Container Initiative** project under the Linux Foundation. Later, Project
    RunC was started. RunC is a command-line wrapper around libcontainer to enable
    developers to start containers from a Terminal. A developer could start a container
    by invoking the RunC binary and passing a root filesystem and a container specification
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: RunC is an extremely stable piece of software. It has been with Docker since
    version 1.12 and is already used by millions of users. The `docker run` command actually
    sends its parameters to another daemon, containerd, which converts that information
    into a configuration file for RunC.
  prefs: []
  type: TYPE_NORMAL
- en: RunC makes the dependencies simpler as we need only a single binary, a root
    filesystem, and a configuration file to start a container.
  prefs: []
  type: TYPE_NORMAL
- en: As RunC is a thin wrapper around libcontainer, its code is straightforward.
    It is relatively easy to directly make use of libcontainer with some Go programming
    knowledge. The only drawback of RunC is that it is designed and built to run containers
    in general. In the next section, we will introduce *RunF,* a minimal runtime designed
    specially for running function containers efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Meet RunF
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section introduces RunF. It is a RunC counterpart that is designed for
    running immutable function containers. RunF is an experimental project that uses
    *libcontainer* to implement a new runtime to run containers in the read-only and
    rootless environment. Containers started with RunF are expected to be running
    efficiently, even inside other containers. RunF allows rootless container execution
    by mapping a non-root user from the host to the root user's ID inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we use it? The following diagram illustrates the scenario. We have
    a FaaS platform, and the **Gateway** accepts the incoming request and forwards
    it to the function **Initiator**. Through the **Event Bus**, a **Function Executor**
    then uses it rather than Docker to invoke the function container. With this architecture,
    we can improve the overall performance of the platform:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ba5ab83d-cca2-4693-b9fd-8c6162aab03c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.1: The block diagram illustrating a FaaS architecture with RunF as
    its runtime'
  prefs: []
  type: TYPE_NORMAL
- en: A rootless container is a container allowed to run without the root user, such
    as in AWS Lambda. We want an immutable version of a function with read-only and
    rootless, because rootless containers make the system and infrastructure more
    secure.
  prefs: []
  type: TYPE_NORMAL
- en: Then there is a network constraint. A function should not be aware of any network-related
    configuration. All current FaaS platforms we have implemented so far have this
    limitation. Say we need to attach a running function to a certain network in order
    to make it work correctly, and be able to resolve names of other dependent services.
  prefs: []
  type: TYPE_NORMAL
- en: We found during [Chapter 8](0d30ef75-34b4-4a72-9b0a-71a8e335d494.xhtml), *Putting
    Them All Together*, that it is tricky to make a function container work virtually
    with any network provided by the platform. *RunF* is designed to solve this issue
    by letting the function container use the outer container network namespace. With
    this execution model, the *function proxy* is responsible for attaching itself
    to the networks, and the function container will also use these networks to access
    other services. If the function container runs inside the container of the function
    proxy, all network configuration could be eliminated.
  prefs: []
  type: TYPE_NORMAL
- en: Performance-wise with a special container runtime such as *RunF*, it is possible
    to cache all necessary filesystems inside each function proxy, and make them immutable.
    With this, we can achieve the highest possible performance similar to the way
    the mechanism of hot functions work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s see what''s inside the implementation to make it meet all requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rootless
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Host networking by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We mostly use the libcontainer APIs directly. Here, we explain the details to
    show how RunF uses libcontainer to achieve the mutable runtime for function containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The program starts by initializing the libcontainer, with the `Cgroupfs` configuration,
    to say that libcontainer will use `Cgroup` to control the resources of the process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The following snippet creates a config. The default location of the `rootfs`
    is `./rootfs` under the current directory. We set the flag `Readonlyfs` to be
    `true` for the immutable filesystem. `NoNewPrivileges` is set to `true` so as
    to not allow the process to gain any new privilege. `Rootless` being `true` is
    designed to tell us that we will map non-root UID and GID to the container''s
    root ID. After the initial flags, we then set the capability of the process. Here''s
    the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CAP_AUDIT_WRITE` is the ability to write to the kernel''s audit logs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_KILL` is the ability for the process to send the signals'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CAP_NET_BIND_SERVICE` is the ability to bind a socket to the privileged ports'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `Namespaces` property is one of the most important settings of the container
    runtime. Within this block of configuration, we set it to use the following namespaces,
    `NS`, `UTS` (hostname and domain name), `IPC`, `PID`, and `USER`. The user namespace,
    `NSUSER`, is the key setting to allow running containers in the rootless mode.
    We left out the `NET` namespace. The reason is that `runf` will start a function
    container inside another container, the *function executor*. Without the `NET`
    namespace isolation, the function container will use the same network namespace
    as the outside container, so it will be able to access any service attached to
    the network of the function executor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another setting is the `Cgroup` setting. This setting allows hierarchical control
    resources of the process. This is mostly the default configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`MaskPaths` and `ReadonlyPaths` are set as the following. This setting is mainly
    to prevent the changes made by the running process to the system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All devices are set to be auto created. Then, the `Mount` setting defines a
    set of filesystems required to mount from the host into the container. In the
    case of RunF, it is a nested mounted from the function executor to the function
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the UID and GID mapping from the host ID (`HostID`) to the ID inside
    the container (`ContainerID`). In the following example, we map the current user
    ID to the ID of the `root` user inside the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We use libcontainer''s factor to create a container with the generated ID and
    the `config` we have set:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we prepare environment variables. They are simply an *array of strings*.
    Each element is a *key=value* pair of each variable that we''d like to set for
    the process. We prepare a process to run using `libcontainer.Process`. Process
    input, output, and error are redirected to the default standard counterparts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then prepare and build the `runf` binary. This requires *libcontainer*
    and other few to build. We normally use the `go get` command to do so. After that,
    just simply build with the `go build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: To prepare a root filesystem, we use `undocker.py` together with the `docker
    save` command. The `undocker.py` script can be downloaded from [https://github.com/larsks/undocker](https://github.com/larsks/undocker).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the command to prepare a root filesystem to the `rootfs` directory
    from the `busybox` image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s test running some containers. We will see that the `ls` command
    lists files inside a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Within a Docker network
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will try something a bit advanced by preparing a small system that
    looks similar to the following diagram. The scenario is that we would like a container
    started by **runf** inside another container, **wrapper-runf** (which is, in reality,
    a function executor), to connect to some network services running on the same
    Docker network, **test_net**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/215f30db-9eb2-4691-ac17-cd519153647c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2: An example of using RunF inside a Docker network'
  prefs: []
  type: TYPE_NORMAL
- en: 'The trick is that we put `resolv.conf` from the standard Docker Swarm mode
    as `./rootfs/etc/resolv.conf` to make the process inside the nested container
    be able to resolve all service names on the attached Docker network. Here''s the
    content of `resolv.conf`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we prepare a Dockerfile for the `wrapper-runf` container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build it normally with the `docker build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The following snippet is the preparation for creating a Docker network, attaching
    `nginx` to the network, then running a `wrapper-runf` container with `/bin/bash`
    there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we start a nested container with `runf` that connects to `nginx`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What's next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With `runf`, it is potentially a way to move towards another step of fast and
    immutable functions with a special runtime. What you can try is to implement a
    proxy container wrapping around `runf` and make it run functions inside the real
    platform. This is left as an (a bit advanced) exercise.
  prefs: []
  type: TYPE_NORMAL
- en: LinuxKit – immutable infrastructure for FaaS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LinuxKit is a set of tools for preparing immutable sets of infrastructure. It
    is designed to compose containers into a ready-to-use OS. Of course, an OS produced
    by LinuxKit is for running containers. To make an immutable and scalable infrastructure
    for FaaS platforms, LinuxKit is one of the best choices out there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a sample of a LinuxKit YAML file to build an immutable OS for Docker.
    The kernel block is saying that this OS will boot with Linux Kernel 4.14.23\.
    The `boot` command, `cmdline`, says that the kernel will be starting with consoles
    on four different TTYs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The four next containers declared inside the `init` block are the base programs
    that will be unpacked directly onto the filesystem. All the `init` level programs
    include `runc` and containerd. Also, the CA certificates will be installed directly
    onto the filesystem before the programs declared in the next, `onboot`, block
    can proceed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `onboot` block and the `mountie` command will automatically mount the first
    available partition to `/var/lib/docker`. Please note that LinuxKit only allows
    you to mount to the directory under the `/var` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `services` block declares system containers, which serve as long running
    services. All these services are run and maintained by containers, started by
    the `init` process in the `init` block.
  prefs: []
  type: TYPE_NORMAL
- en: A service declared in this block can be started in any order.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, `docker` is one of the services. Docker image, `docker:17.09.0-ce-dind`,
    is used for running this Docker service. This service runs on the host network.
    This is basically the same concept as RancherOS. This instance of `dockerd` run
    by the `docker` service is the user-level container management system, while containerd
    from the `init` block is the system-level container management system. Other system
    containers here are `rngd`—a random number generator daemon, `dhcpd`—an DHCP service,
    and `ntpd`—the OpenNTPD daemon for syncing the machine clock, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The file block is for declaring *files* or *directories* that we would like
    to have on our immutable filesystem. In the following example, we declare `/var/lib/docker`
    and create a Docker''s daemon configuration `/etc/docker/daemon.json` with the
    content `{"debug": true}` inside it. These files are created during the image''s
    build phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We have another example of the `files` block. This is the standard way to put
    our public key into the filesystem image. The attribute `mode` is for setting
    the file mode when copying the file to the final image. In this example, we require
    the public key file to be `0600`. With this configuration and the running `sshd`
    service, we will be allowed to remotely SSH into the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the step to build the LinuxKit command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If we have already installed the Go programming language using GVM, the binary
    will be available to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll build a Docker OS, available at [https://github.com/linuxkit/linuxkit/blob/master/examples/docker.yml](https://github.com/linuxkit/linuxkit/blob/master/examples/docker.yml):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Beyond serverless
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hybrid serverless would be a deployment model that links hybrid cloud to the
    serverless deployment model. It is already started by IT vendors offering hardware
    rental services in the form of private clouds, putting them to customer's organizations,
    and charging at the rate of pay-as-you-go.
  prefs: []
  type: TYPE_NORMAL
- en: When the serverless and FaaS computing platforms are deployed on top of that
    kind of hybrid infrastructure, they become **hybrid serverless**. This could be
    the next generation of computing platform that allows you to store sensitive data
    inside the organization, having some important FaaS functions running on the local
    system, while leveraging some extra computing resources as pay-per-request. It
    will be in the scope of the definition of serverless, if the customer's organization
    does not need to maintain or administer any of the hardware servers. Fortunately,
    when mixing this model with what we have discussed throughout this book, using
    Docker as our infrastructure would still be applied to this kind of infrastructure.
    Docker is still a good choice for balancing between maintaining infrastructure
    on our own and making the serverless platforms do the rest of the work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, the overall system shows a hybrid architecture. In
    the case of using a FaaS platform only from inside the organization, requests
    would be made firstly to the on-premises infrastructure. When loads become large,
    instances of the function executors would be scaled out and eventually burst to
    a public cloud infrastructure. However, the data stores are usually placed inside
    the organization. So, the outside function executors must be able to access them
    just as if they were running on-premises:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6768fae-af48-4305-b6bc-136a4c2c085f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.3: A hybrid architecture for FaaS'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Declarative containers could be considered as a technology in between a normal
    container and a container running on FaaS. Let''s look at the following imaginary
    Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: What do we see here? At the first time of reading, it would look like a normal
    Dockerfile. Yes, it is. But it's not a declarative way to define an application
    container. Why?
  prefs: []
  type: TYPE_NORMAL
- en: We already know that this is a Java application doing some work for us. But
    it has hardcoded some important and brittle configurations, for example, when
    `openjdk:8` pinned the app to use only that implementation, while `-Xmx2G` limits
    the memory usage of the app.
  prefs: []
  type: TYPE_NORMAL
- en: All FaaS platforms these days use containers in the same way. They tie some
    specific configurations into function containers but actually people need a very
    neutral and portable way of deploying functions.
  prefs: []
  type: TYPE_NORMAL
- en: So what does a declarative container look like?
  prefs: []
  type: TYPE_NORMAL
- en: 'It looks something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You might think it is impossible to run this container on any runtime at the
    moment. The answer is you are correct. But I still argue that the application
    should be declared in the same way. We should remove all brittle configuration
    out of the `Dockerfile` as much as possible. Then we should let a new entity,
    maybe inside a container engine, manage the environment around the application
    for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, it is relatively easy to intercept the container creation process
    then compute the limitation of the memory allowed by the container (via `docker
    run -m` for example) and put that value into the command line of `java` to cap
    the memory limit at the application level. The entity responsible for this kind
    of work inside a container engine would be called the **Application Profile Manager**,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/61d4cc6a-a41b-470a-b849-92fb0861c78f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.4: A container engine with the application profile manager'
  prefs: []
  type: TYPE_NORMAL
- en: The crosscutting concept like this is nothing new. We already have a similar
    concept applied to Docker. Guess what? It's the security concern. Docker already
    has the AppArmor default profile applied to each running container with the AppArmor
    subsystem enabled. That's about security concerns. This is at the more application-specific
    level of concern, so why don't we have a similar concept to help make our life
    easier?
  prefs: []
  type: TYPE_NORMAL
- en: With this concept, container images would become declarative containers as there
    is no specific environment or configuration hardcoded for them. And it's the responsibility
    of the **Application Profile Manager** to selectively apply an appropriate profile
    for the container and make it work nicely.
  prefs: []
  type: TYPE_NORMAL
- en: What is the practical benefit of declarative containers? Here's a concrete explanation
    for the Java app we discussed earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of Java, the application architecture has been designed to decouple
    between the application and the runtime. With the very strong specification of
    the JVM, the JVM for running applications is always swappable and replaceable.
    For example, if we start running an application with an OpenJDK, and we are not
    happy with its performance, we can safely swap the JVM to be the Zulu JVM or the
    IBM J9.
  prefs: []
  type: TYPE_NORMAL
- en: With the declarative approach to containers, the Java runtime would be easily
    swappable on-the-fly without rebuilding the Docker image. It also allows you to
    apply JVM hot fixes to the running system.
  prefs: []
  type: TYPE_NORMAL
- en: We can download the modified version of Docker with this declarative feature
    for Java from [http://github.com/joconen/engine](http://github.com/joconen/engine).
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to review all the concepts in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What do you think is lying ahead after the serverless era?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the next generation of computing you might probably be thinking of?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the feature of libcontainer that allows rootless execution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the namespaces provided by Linux?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain why RunF is able to access the network services when running inside
    other containers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the benefit of using LinuxKit to prepare an infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is a declarative approach to containers? How could it apply to other application
    platforms, beside Java?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How could we design a hybrid serverless architecture when we would like to access
    services from outside the organization?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter ends this book with a discussion of what we could use to make the
    FaaS moving forward. We reviewed what we have been through with Docker and three
    major FaaS platforms running on it.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a great infrastructure when it's considered that all these three FaaS
    platforms are actually using its direct feature, rather than solely relying on
    its orchestrator functionalities. Why? Maybe because the FaaS computing model
    fits this simple kind of infrastructure instead of complex ones.
  prefs: []
  type: TYPE_NORMAL
- en: What if we could simply do `docker run`, then the container is transformed into
    a FaaS function serving its functionality somewhere on the cluster? Function wrapper,
    action proxy, or function watchdog could be injected into a simple container that
    processes input and output via standard I/O and turns it into an online function.
    Then a kind of magical infrastructure will be taking care of everything for us.
    We are gradually moving toward to that reality.
  prefs: []
  type: TYPE_NORMAL
- en: References
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Apache Foundation. *Apache OpenWhisk*. Available at: [https://openwhisk.apache.org/.](https://openwhisk.apache.org/.)
    (Accessed: March 28, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Microsoft Corp. Azure functions—serverless architecture | Microsoft Azure.
    Available at: [https://azure.microsoft.com/en-us/services/functions/.](https://azure.microsoft.com/en-us/services/functions/.)
    (Accessed: March 28, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Burns, B., Grant, B., Oppenheimer, D., Brewer, E. & Wilkes, J. Borg, Omega,
    and Kubernetes. Queue 14, 10:70–10:93 (2016).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Schickling, J., Lüthy, M., Suchanek, T. & et al. *chromeless: Chrome automation
    made simple.* (Graphcool, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Google Inc. Concepts | Cloud Functions. *Google Cloud* Available at: [https://cloud.google.com/functions/docs/concepts.](https://cloud.google.com/functions/docs/concepts.)
    (Accessed: 28th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Crosby, M., Day, S., Laventure, K.-M., McGowan, D. & et al. *containerd: An
    open and reliable container runtime.* (containerd, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Docker Inc. Docker. (2018). Available at: [https://www.docker.com/.](https://www.docker.com/.)
    (Accessed: 28th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Smith, R. *Docker Orchestration*. (Packt Publishing Ltd, 2017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Merkel, D. Docker: Lightweight Linux Containers for Consistent Development
    and Deployment. *Linux J.* **2014**, (2014).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Go Community. Documentation - The Go Programming Language. Available at:
    [https://golang.org/doc/.](https://golang.org/doc/.) (Accessed: 30th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Linux Foundation. Envoy Proxy - Home. Available at: [https://www.envoyproxy.io/.](https://www.envoyproxy.io/.)
    (Accessed: 1st April 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Ethereum Foundation. Ethereum Project. Available at: [https://www.ethereum.org/.](https://www.ethereum.org/.)
    (Accessed: 30th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avram, A. FaaS, PaaS, and the Benefits of the Serverless Architecture. *Retrieved
    from’InfoQ’https://www. infoq. com/news/2016/06/faasserverless-architecture* on
    **28**, (2016).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Oracle Inc. Fn Project - The Container Native Serverless Framework. Available
    at: [https://fnproject.io/.](https://fnproject.io/.) (Accessed: 28th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Arimura, C., Reeder, T. & et al. *Fn: The container native, cloud agnostic
    serverless platform.* (Oracle inc., 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Google Inc. Google Cloud Functions Documentation | Cloud Functions. *Google
    Cloud* Available at: [https://cloud.google.com/functions/docs/.](https://cloud.google.com/functions/docs/.)
    (Accessed: 28th March 2018). Kaewkasi, C. & Chuenmuneewong, K. Improvement of
    container scheduling for docker using ant colony optimization. in *Knowledge and
    Smart Technology (KST), 2017 9th International Conference on* 254–259 (IEEE, 2017).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apache Foundation. incubator-openwhisk: *Apache OpenWhisk is a serverless event-based
    programming service and an Apache Incubator project.* (The Apache Software Foundation,
    2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Cormack, J. & et al. linuxkit: *A toolkit for building secure, portable and
    lean operating systems for containers.* (LinuxKit, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Janakiraman, B. Martin Fowler’s bliki: Serverless. *martinfowler.com* (2016).
    Available at: [https://martinfowler.com/bliki/Serverless.html.](https://martinfowler.com/bliki/Serverless.html.)
    (Accessed: 28th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sharma, S. *Mastering Microservices with Java 9*. (Packt Publishing Ltd, 2017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moby Community,The. Moby. *GitHub* Available at: [https://github.com/moby.](https://github.com/moby.)
    (Accessed: 30th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Moby Community,The. moby: *Moby Project* - a collaborative project for the
    container ecosystem to assemble container-based systems. (Moby, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Jones, D. E. & et al. Moqui Ecosystem. Available at: [https://www.moqui.org/.](https://www.moqui.org/.)
    (Accessed: 30th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Soppelsa, F. & Kaewkasi, C. *Native Docker Clustering with Swarm.* (Packt Publishing
    - ebooks Account, 2017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Marmol, V., Jnagal, R. & Hockin, T. Networking in containers and container clusters.
    *Proceedings of netdev 0.1, February* (2015).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ellis, A. *OpenFaaS - Serverless Functions Made Simple for Docker & Kubernetes.*
    (OpenFaaS, 2018).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Amazon Web Services, Inc. Optimizing Enterprise Economics with Serverless Architectures.
    (2017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Parse Community,The. Parse + Open Source. *Parse Open Source Hub* Available
    at: [http://parseplatform.org/.](http://parseplatform.org/.) (Accessed: 30th March
    2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Vilmart, F. & et al. parse-server: *Parse-compatible API server module for
    Node/Express*. (Parse, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Linux Foundation,The. *runc: CLI tool for spawning and running containers according
    to the OCI specification*. (Open Container Initiative, 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Christensen, B., Karnok, D. & et al. *RxJava – Reactive Extensions for the JVM
    – a library for composing asynchronous and event-based programs using observable
    sequences for the Java VM*. (ReactiveX, 2018).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Roberts, M. Serverless Architectures. *martinfowler.com* (2016). Available
    at: [https://martinfowler.com/articles/serverless.html.](https://martinfowler.com/articles/serverless.html.)
    (Accessed: 28th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Baldini, I. et al. Serverless computing: Current trends and open problems.
    in *Research Advances in Cloud Computing* 1–20 (Springer, 2017).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'GOTO Conferences. *Serverless: the Future of Software Architecture by Peter
    Sbarski.* (2017).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fox, G. C., Ishakian, V., Muthusamy, V. & Slominski, A. Status of Serverless
    Computing and Function-as-a-Service (FaaS) in Industry and Research. *arXiv preprint
    arXiv:1708.08028* (2017).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Docker Inc. Swarm mode overview. *Docker Documentation (2018)*. Available at:
    [https://docs.docker.com/engine/swarm/.](https://docs.docker.com/engine/swarm/.)
    (Accessed: 28th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Kaewkasi, C. & et al. *The Docker Swarm 2000 Collaborative Project.* (SwarmZilla
    Collaborative Project, 2016).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Containous. Træfik. Available at: [https://traefik.io/.](https://traefik.io/.)
    (Accessed: 1st April 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Lubin, J. & et al. Truffle Suite - Your Ethereum Swiss Army Knife. *Truffle
    Suite* Available at: [http://truffleframework.com.](http://truffleframework.com./)
    (Accessed: 30th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Weaveworks Inc. Weave Net: Network Containers Across Environments | Weaveworks.
    Available at: [https://www.weave.works/oss/net/.](https://www.weave.works/oss/net/.)
    (Accessed:30th March 2018).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
