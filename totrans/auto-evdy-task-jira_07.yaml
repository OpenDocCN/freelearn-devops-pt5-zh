- en: '*Chapter 5*: Working with External Systems'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Applications rarely exist in isolation. They tend to specialize in doing one
    thing well, but to be truly useful, they need to co-exist with other applications
    within your organization.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially true for Jira, and this can be seen in the Atlassian Marketplace
    where, among the large number of available apps, hundreds of them exist solely
    to integrate Jira with other applications and systems.
  prefs: []
  type: TYPE_NORMAL
- en: Even with the number of integrations with various applications available as
    plugins to Jira, there will often be occasions where the integration you need
    is not catered for, or where an existing integration does not quite meet your
    specific requirements.
  prefs: []
  type: TYPE_NORMAL
- en: In recent years, many applications and systems have embraced JSON-based REST
    APIs to enable third-party systems to integrate with them, and automation rules
    in Jira provide us with the components necessary to take advantage of this.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how we can send requests to external systems
    using automation rules and how to work with the data that is returned from these
    requests. In addition, we will explore how we can use automation rules to set
    up incoming webhooks that can listen for requests from external systems to trigger
    a rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How to send requests to external systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data returned from requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to receive requests using incoming webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data in incoming webhooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The requirements for this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Jira Cloud environment**: If you don''t already have access to Jira, you
    can create a free Jira Cloud account at [https://www.atlassian.com/software/jira/free](https://www.atlassian.com/software/jira/free)
    and ensure that you have both Jira Software and Jira Service Management selected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jira Server environment**: If you are using Jira Server (available from [https://www.atlassian.com/software/jira/download](https://www.atlassian.com/software/jira/download)),
    ensure you have licenses for both Jira Software and Jira Service Management. In
    addition, you will also need to ensure that you install the *Automation for Jira*
    app available from the Atlassian Marketplace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confluence Cloud environment**: If you don''t already have access to Confluence,
    you can use the application switcher menu in your Jira Cloud instance to set up
    a Confluence site in your cloud account. If you don''t have a Jira Cloud account,
    you can set up a free Confluence Cloud account at [https://www.atlassian.com/software/confluence/free](https://www.atlassian.com/software/confluence/free).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Confluence Server environment**: If you are using Jira Server, you can either
    download and install Confluence Server from [https://www.atlassian.com/software/confluence/download](https://www.atlassian.com/software/confluence/download)
    or you can create and use a Confluence Cloud account.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In both instances, you will need to have at least **Project Administrator**
    access to a Service Management project and a Scrum Software project to be able
    to follow the examples in this chapter. For the examples in this chapter, we have
    used the *IT Service Management project template* to create the Service Management
    project and the *Scrum Software project template* to create the Software project.
  prefs: []
  type: TYPE_NORMAL
- en: You can download the latest code samples for this chapter from this book's official
    GitHub repository at [https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira](https://github.com/PacktPublishing/Automate-Everyday-Tasks-in-Jira).
    The Code in Action videos for this chapter are available at [https://bit.ly/2LJAJvN](https://bit.ly/2LJAJvN).
  prefs: []
  type: TYPE_NORMAL
- en: How to send requests to external systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The ability to send requests to external systems from your automation rules
    opens up a whole new realm of extremely powerful possibilities. This functionality
    can be used to send notifications, or issue data or any custom data to any application
    or system that accepts web requests over HTTP or HTTPS. For example, you could
    use this functionality to kick off a build process in a build tool such as Bamboo
    or Jenkins, or to initiate a password change in a centralized user directory system
    if it supports this.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will look at the **Send web request** component and how
    to use it in automation rules to send requests to external systems. We'll begin
    by taking a look at the various configuration options available in the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the configuration options for the **Send
    web request** action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Configuring the Send web request action'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Configuring the Send web request action
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at each field in the configuration screen and how we can
    make use of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '`urlEncode` to ensure the smart value is properly encoded. For example, you
    should insert the issue key in the field as `{{issue.key.urlEncode}}`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Headers** field is where you add any HTTP request headers required by
    the external system you're going to connect to, such as an **Authorization** header,
    which allows you to submit credentials or authorization tokens to the remote system,
    or the **Content-Type** header, which informs the remote system of the nature
    of the data you will be sending. We'll be making use of both of these headers
    in our example when we publish release notes to Confluence.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Header names are generally case-insensitive. However, you should always ensure
    that you use the case defined in the official specifications to avoid any unexpected
    results. Wikipedia maintains a handy list of the standard request headers, complete
    with examples of accepted input for each header, at [https://en.wikipedia.org/wiki/List_of_HTTP_header_fields](https://en.wikipedia.org/wiki/List_of_HTTP_header_fields).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can add as many HTTP request headers as you need by clicking on the **Add**
    link below the **Name** field. If you need to remove a header, you can do so by
    using the trash can icon to the right of the **Value** field.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The **HTTP method** field allows you to select the correct method required
    by the external resource to perform the selected operation. The **Send web request**
    action supports the following standard HTTP methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**GET**: Generally used to retrieve a resource from the external system.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**POST**: Generally used to create a resource in the external system using
    the data located in the request body.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**PUT**: Generally used to replace a resource or create it if it does not exist,
    with the resource data located in the request body.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**PATCH**: Generally used to update a resource, with the updated data located
    in the request body.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**DELETE**: Generally used to delete a resource from the external system.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Get issue` at the following link: [https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-issues/#api-rest-api-3-issue-issueidorkey-get).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Custom data**: Selecting this option will cause the **Custom data** field
    (6) to be shown. This option is usually needed when using the **POST**, **PUT**,
    or **PATCH** methods and the external system is not expecting data in the Jira
    issue format.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `{{webhookResponse}}` smart value field. We will explore this in more detail
    in the next section, *Working with data returned from requests*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`{{issue.description.abbreviate(255).jsonEncode}}` to ensure that the content
    of the description field is properly encoded.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Always make sure when sending custom data that you use the **Headers** field
    to specify the correct content type of your data to the external system with the
    *Content-Type* header name. For example, if you're sending JSON data, set *Content-Type*
    to *application/json*, or to *application/xml* for XML data.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you've configured your web request with the correct URL, headers, method,
    and optional data, you should always test that the request generated, and response
    received, are what you're expecting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can do this by expanding the **Validate your webhook configuration** disclosure
    and clicking the **Validate** link. Supplying an optional issue key will ensure
    that any smart values are substituted during the validation process.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When you click the **Validate** link, a request with your configured options
    and data will be generated and sent to the external system and the response received
    will be captured and presented back to you, similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Validating a web request configuration'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Validating a web request configuration
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, validating the request will return the response received from
    the external system, as well as the request that was generated and sent to the
    external system. Expanding the **Payload** disclosures will reveal the actual
    data received and sent by the web request, allowing you to ensure that the data
    in both directions is what you expected to see.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned about the various configuration options for sending a
    web request, let's look at using these in an automation rule.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to publish release notes to Confluence
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B16551_04_Final_ASB_ePub.xhtml#_idTextAnchor080), *Sending
    Automated Notifications*, we showed you how to create a rule to send an email
    notification to various stakeholders when a software version is released in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to revisit that rule in this example. However, instead of sending
    an email notification when a version is released, we will instead publish a page
    to Confluence using the **Send web request** action.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we have created a new Confluence space and a Releases page.
    Individual release notes pages will be created as children of the Releases page.
  prefs: []
  type: TYPE_NORMAL
- en: To make things easier, we'll create a **Release Notes Template** page in Confluence,
    complete with all the relevant smart values populated. Once we have our template,
    we need to copy the page using its storage format so we can include it in the
    **Send web request** body in our automation rule.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the completed template and the option
    to view the storage format of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Getting the Release Notes Template page source'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.3.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Getting the Release Notes Template page source
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy all the code in the storage format view into a text editor, and then we''ll
    modify the `{{#lookupIssues}}` section as follows to ensure that the smart value
    substitutions work as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next, we will escape all the double quote characters in the code by prepending
    a backslash to them and then remove all the new lines so that the entire code
    is on a single line.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: We use the storage format when working with Confluence as this gives us access
    to the underlying HTML formatting of the page, including the XML used to define
    the various Confluence macros in the page, and allows us greater flexibility in
    making adjustments to the final content that will be displayed when the page is
    published.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to ensure that you have a valid API token, which will be needed
    to authorize the web request later in the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: Navigate to [https://id.atlassian.com/manage-profile/security/api-tokens](https://id.atlassian.com/manage-profile/security/api-tokens)
    and click on **Create API token**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You cannot use two-step authentication for the account that you use in an automation
    rule. Two-step verification is designed for human users who have access to a secondary
    device and is impossible to implement for an automated system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Give your token a label, for example, `Automation Rules`, and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the token somewhere safe, as you will not be able to retrieve it once you
    close the pop-up window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to encode our credentials for use in our automation rule. You can
    use an online tool such as the one at [https://www.base64encode.org](https://www.base64encode.org)
    to perform the encoding.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter your email address, followed immediately by a colon (:) and then your
    API token, click the **Encode** button, and then copy the resulting encoded value
    somewhere safe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you're using Confluence Server, you need only the username and password of
    a user who can create pages in the Confluence space. To encode the credentials,
    replace the email address in the preceding *step 4* with the username, and the
    API token with the user's password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let''s move on to building the automation rule:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Version released** trigger and click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select `fixVersion = "{{version.name}}"`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select `https://<your_site>.atlassian.net/wiki/rest/api/content`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First `Content-Type`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`application/json`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Second `Authorization`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Basic <your base64-encoded credentials>`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`POST`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Custom data`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to retrieve the page ID of the Release Notes page as this will be the
    parent of our release pages. To do so, navigate to the Release Notes page in Confluence,
    and then click the `ancestors` item in the JSON.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You also need to ensure you use the correct Confluence space key. In our example,
    this is **MA**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the JSON structure looks like the preceding code, copy the JSON into the
    **Custom data** field, after which your rule should look similar to the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Configuring the Send web request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.4.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.4 – Configuring the Send web request
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, click `Publish release notes to Confluence`, and click **Turn it on**
    to save and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When you release a version in your Jira Software project now, you should have
    a published page in Confluence under **Release Notes** that looks similar to the
    following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The release notes published by the automation rule'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.5.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – The release notes published by the automation rule
  prefs: []
  type: TYPE_NORMAL
- en: We have now learned how to send a web request to an external system using automation
    rules. In the next section, we'll expand on this and see how we can incorporate
    the data returned from the external system in subsequent rule components.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data returned from requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many systems you will integrate with not only accept data you send, but also
    respond with additional data depending on the request. With automation rules,
    we are able to retrieve the response from a request and utilize this data in subsequent
    conditions and actions in our rules. This ability gives our rules even greater
    flexibility and power as we can now make decisions and perform actions based on
    the specific content returned from the external system.
  prefs: []
  type: TYPE_NORMAL
- en: When configuring the `{{webhookResponse}}`, with the response from the external
    system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{{webhookResponse}}` smart value contains a number of fields that you
    can access in your subsequent rule components, and these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`200` or `201` for successful requests, or in the range `300` to `599` for
    redirection and errors. You can find more about HTTP response codes at [https://en.wikipedia.org/wiki/List_of_HTTP_status_codes](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`{{webhookResponse.headers.Content-Type}}` will retrieve the **Content-Type**
    header returned by the external system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{{webhookResponse.body}}**: The body field will contain the body of the response
    from the external system. If the external system response is a JSON object, you
    can access any of the fields using **dot notation**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**{{webhookResponses}}**: If you have multiple **Send web request** actions
    in your rule, each response, if present, will be added to this list and you can
    use the smart value list functions that we covered in [*Chapter 3*](B16551_03_Final_ASB_ePub.xhtml#_idTextAnchor065),
    *Enhancing Rules with Smart Values*, to work with the list items.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's now take a look at how we can incorporate the response from a web request
    into an automation rule.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to add incident managers as watchers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we are going to add the members of the VIP group that we created
    in [*Chapter 1*](B16551_01_Final_ASB_ePub.xhtml#_idTextAnchor017), *Key Concepts
    of Automation*, as watchers to issues whose priority is set to **Highest** when
    the issue is either created or updated.
  prefs: []
  type: TYPE_NORMAL
- en: As Jira itself has a powerful REST API, we can treat it as an external system
    in our automation rules and retrieve data for use in our rules that we wouldn't
    ordinarily have access to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Service Management project, navigate to **Project settings**, click
    on the **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Issue Created` and `Issue Updated`. Then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now select `Issue Type`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`equals`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Incident`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then select `Priority`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`equals`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Highest`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, select `https://<your_site.domain.com>/rest/api/3/group/member?groupname=VIP`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Authorization`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Basic <your base64-encoded credentials>`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GET`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Empty`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Wait for response**: Select the checkbox'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The response from this API call returns a list of users in the **values** array
    that belong to the **groupname** we specified in the query parameter, similar
    to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can find more information about this API call at [https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get](https://developer.atlassian.com/cloud/jira/platform/rest/v3/api-group-groups/#api-rest-api-3-group-member-get).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To complete the rule, select `{{webhookResponse.body.values.accountId}}`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your rule should look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Using webhookResponse data in a rule'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.6.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.6 – Using webhookResponse data in a rule
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, click `Add` `watchers` `to` `Highest` `priority` `incidents`, and then
    click **Turn it on** to save and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we have learned how to expose the response returned from an
    external system request and how we can use this data to create much more powerful
    automation rules.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how we can listen for web requests from external
    systems and how these can be used to trigger our automation rules.
  prefs: []
  type: TYPE_NORMAL
- en: How to receive requests using incoming webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous two sections, we learned how to use automation rules to send
    notifications and data to external systems and how to work with the response data
    received from an external system.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, automation rules also allow us to receive notifications
    and data from external systems using the **Incoming webhook** trigger. This component
    will create a unique URL for each trigger that can then be called by an external
    system and will trigger the automation rule to run. These incoming webhooks can
    receive a list of issues on which to act as well as custom data in the form of
    JSON objects, which can be used in later rule components to make decisions using
    conditions or to create or update issues using the custom data provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the configuration options for the **Incoming
    webhook** trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Configuring the Incoming webhook trigger'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.7.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Configuring the Incoming webhook trigger
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at how each of the configuration options works:'
  prefs: []
  type: TYPE_NORMAL
- en: The **Webhook URL** is the unique URL that will cause the rule to run when an
    external system sends an HTTP **POST** request to it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This URL is generated automatically and requires no authentication to use. If
    the URL is compromised, you can use the **Regenerate** link to generate a new
    URL for the webhook and update any external systems that use it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Incoming webhooks only support the HTTP **POST** method. They will not respond
    to HTTP **GET** or any other method. In addition, you need to ensure that the
    external system that sends a request to the webhook sets the *Content-Type* request
    header to *application/json*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `issue`, for example, `https://automation.atlassian.com/pro/hooks/<unique-webhook-token>?issue=MAPP-1`.
    To specify multiple issues, you should include either the issue key or the issue
    ID in an `"issues"` list in the JSON-formatted request body as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Issues provided by running the following JQL search** will display the **JQL**
    field (3), which allows you to input a JQL query to search for the relevant issues.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**No issues from the webhook** means the webhook is not expecting to operate
    on any existing issue. You could use this option if you needed to create issues
    as a result of the webhook being called, for example.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As mentioned in *step 2* above, the **JQL** field is displayed when you use
    the **Issues provided by running the following JQL search** option and allows
    you to define a JQL query to return the issues that will be updated as a result
    of calling the webhook. You can use smart values and functions in the query. However,
    doing so means you cannot validate the query using the **Validate query** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's now look at how we can use an incoming webhook to trigger an automation
    rule that we've seen in order to configure incoming webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to resolve open issues using an automation webhook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many software projects have some form of automated build and deploy tool that
    automates the building, testing, and deployment of code.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to assume that the developers will move their
    issues to the *Waiting for deploy* status once they have completed development.
    When our automated deployment starts, we want to automatically resolve all issues
    in the currently open sprint that are awaiting deployment by having our build
    and deploy tool an automation rule in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: In our example Jira Software project, we are using the *Software Simplified*
    workflow, so we will edit the workflow from the **Project Settings** screen and
    add a new *Waiting for deploy* status and allow all statuses to transition to
    it. In addition, add the *Resolve issue* screen to the *Done* transition to allow
    comments to be added when resolving issues.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve adjusted our workflow to take this new status into account,
    let''s create the automation rule:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the project settings menu, and then click **Create rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Issues provided by running the following JQL search`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`sprint in openSprints() AND status = "Waiting for deploy"`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, select `Done` in the **Destination status** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In addition, we want to add a comment to these issues to the effect that the
    issue was automatically resolved by the build system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, expand the **More options** disclosure, add the following JSON
    in the **Additional fields** editor, and then click **Save**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your rule should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Configuring a rule with an incoming webhook'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.8.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.8 – Configuring a rule with an incoming webhook
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, name your rule `Release` `issues` `waiting` `for` `deploy` and click
    **Turn it on** to save and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we have learned how to create and use incoming webhooks to
    trigger automation rules. In the next section, we'll learn how we can also make
    use of data supplied by the external system to further enhance our automation
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Working with data in incoming webhooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having the ability to trigger actions in Jira from external systems enables
    you to create really powerful integrations with automation rules.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous section, you can act on specific issues by including
    them in the incoming request body. However, with the `{{webhookData}}` smart value,
    where you can access any of the JSON object fields using dot notation.
  prefs: []
  type: TYPE_NORMAL
- en: This powerful functionality will enable you to integrate with any external system
    that can send web requests and allow you to extract valuable data for use in your
    issues. For example, you could potentially set up your monitoring tools to send
    notifications to an automation rule when an incident occurs and use the data it
    provides to create a new incident and set affected components based on which asset
    caused the incident.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at how we can configure an automation rule that makes
    use of custom data from an incoming web request.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a rule to raise new issues using an automation webhook
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Being able to collect information about your deployed software when something
    goes wrong is invaluable for many developers and many software applications allow
    users to submit feedback when an error occurs.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are going to create an automation rule using an incoming
    webhook to receive a bug report and automatically create a bug in our Jira project
    to track it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to expect a JSON object with the following structure to process
    this incoming information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you were including this in a product, you could probably add more relevant
    data, such as stack traces to the JSON structure to make the bug report more contextual.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at how to build this automation rule:'
  prefs: []
  type: TYPE_NORMAL
- en: In your Jira Software project, navigate to **Project settings**, click on the
    **Automation** link in the **Project Settings** menu, and then click **Create
    rule**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `No issues from the webhook` as we're going to be using this rule to
    create an issue. Then click **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, select `Same project`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`Bug`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{{webhookData.summary}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`{{webhookData.bugDescription}}`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We also want to capture the software version that was deployed when this bug
    was submitted, and we'd like to add some labels to the issue to make it easier
    to find bugs raised from the in-product feedback collector.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To do this, expand the **More options** disclosure and then add the following
    JSON to the **Additional fields** editor:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your rule should now look similar to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 5.9 – Consuming incoming webhook data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/B16551_Figure_5.9.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Figure 5.9 – Consuming incoming webhook data
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on `In-product` `bug` `collector`, and then click **Turn it on** to save
    and enable the rule.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You have now learned how to consume request data from an external system in
    an incoming webhook.
  prefs: []
  type: TYPE_NORMAL
- en: The ability to consume incoming data from external systems and use it to make
    decisions and effect changes to issues using automation rules gives you some extremely
    powerful options in terms of automating your projects in Jira.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how you can integrate to external systems
    using automation rules by sending web requests and how you can include custom
    data in these requests using smart values and smart value functions.
  prefs: []
  type: TYPE_NORMAL
- en: We have also learned how to ensure we can receive a response from a request
    to an external system and how we can extract the data for use in subsequent rule
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned to set up an incoming webhook using automation rules to listen
    for requests coming from external systems and how to optionally process data sent
    in the request body and use this in subsequent rule components.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in this chapter, the ability to integrate with external systems
    using automation rules opens a world of possibilities to your Jira projects. For
    example, you could start a software build or deployment from your build tool when
    you release a version or complete a sprint in Jira Software. In Service Management,
    you could integrate with your user directory service to automatically provision
    new accounts based on service requests or reset passwords automatically, if supported.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can use the skills learned in this
    and previous chapters to help build automations in your Service Management instances.
  prefs: []
  type: TYPE_NORMAL
