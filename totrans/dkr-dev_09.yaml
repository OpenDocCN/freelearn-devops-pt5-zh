- en: '*Chapter 7*: Continuous Deployment with Jenkins'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to reliably use Docker containers in production, you need a process
    that will consistently build, test, and deploy your software. A team building
    very small applications might be satisfied with running tests and deployment scripts
    manually. However, discipline often breaks down, and people step on each other's
    toes. This often results in broken builds and tests that are not run before or
    after a production deployment. The aftermath is often downtime and unhappy customers.
    In order to make sure that we can build, test, and deploy software reliably, we
    can use continuous integration software. This type of software can reliably build,
    test, and deploy revisions in a disciplined and traceable way. A well-run modern
    project can even use this software to achieve continuous deployment, where even
    the smallest changes to the software can be quickly promoted to either a test
    or production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we show how to configure Jenkins, one of the most popular continuous
    integration software systems, to facilitate deployment to the minimal environment
    shown in the previous chapter. We will use Jenkins to manage both the production
    installation and a new staging environment installation of the application used
    to test changes before they reach production.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will know when it might be a good idea to deploy
    Jenkins for CI and CD with Docker. You will learn how to set up a basic `Jenkinsfile`
    that can help Jenkins `docker-compose` commands to update the application. You
    will discover how to set up Jenkins parameterized builds that allow both changing
    and auditing configuration parameters. You will extend the simple production setup
    by adding an isolated staging environment to allow developers to make changes
    more confidently. Finally, you will know when this type of solution has exhausted
    its limits and when it is time to reach for more sophisticated tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkins to facilitate continuous deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Jenkinsfile and host connectivity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Driving configuration changes through Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying to multiple environments through multiple branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complexity and limits to scaling deployments through Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the exercises in this chapter, you'll need Git and Docker on your
    local workstation, and you will need to have already set up a production application
    as described in the previous chapter. To complete the exercises about deploying
    to multiple environments, you will need another host to run a test environment,
    with similar specifications as the production host.
  prefs: []
  type: TYPE_NORMAL
- en: You will also need a Jenkins server. This chapter will go over some options
    for the simple setup and maintenance of a Jenkins server if you don't already
    have one available to you. If your company already runs a Jenkins server, you
    can use that—ask the system administrators for permission. This server will need
    to be able to reach your production server via SSH.
  prefs: []
  type: TYPE_NORMAL
- en: You will need to be able to create DNS entries in a zone you control, for both
    the staging server and the Jenkins server. You can use the same DNS zone as you
    used in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub repository for this chapter is [https://github.com/Packt-Publishing/Docker-for-Developers](https://github.com/Packt-Publishing/Docker-for-Developers)—please
    see the `chapter7` folder inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3kL1EUU](https://bit.ly/3kL1EUU)'
  prefs: []
  type: TYPE_NORMAL
- en: Example application – ShipIt Clicker v3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The version of *ShipIt Clicker* in this chapter is very similar to the one in
    the previous chapter. We will use it to test deployment through Jenkins to both
    a production and a staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkins to facilitate continuous deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world of continuous integration servers has come a long way in the last
    20 years. One of the most popular systems is Jenkins (see [https://jenkins.io/](https://jenkins.io/))—because
    it is free, flexible, and offers a huge variety of integrations and plugins. CloudBees
    [(https://www.cloudbees.com](https://www.cloudbees.com/)/), the company behind
    it, also offers commercial support via a paid version. Your company might already
    be running Jenkins, in which case you may not need to do much setup to get your
    project to build and run.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use the Jenkins 2.x Pipeline project type, where a `Jenkinsfile`
    is committed to source control in GitHub and controls the steps Jenkins uses to
    build and deploy the project.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid these traps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we set up Jenkins, we should make sure we avoid certain common traps
    people fall into when setting it up for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid running Jenkins in Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although you can use Docker to run a Jenkins server, doing so introduces some
    complications that are best avoided, especially when just trying to get a continuous
    integration server running for the first time. You would either need to use a
    feature called **Docker-in-Docker** (**dind**) or a customized Docker installation
    of Jenkins that has the correct ports and files mapped from the host in a very
    specific way. If you don't get it just right, you might run into trouble with
    not being able to build Docker containers since you can't double-mount a union
    filesystem, for example.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Jenkins itself running as a Docker container and working through
    the quirks would probably consume a ton of effort and time, and is beyond the
    scope of the advice we can give in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid running Jenkins on the production server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a previous chapter, we set up a production server in the cloud to host an
    application. You might be tempted to have that same server you already have running
    do double-duty by having it run the Jenkins CI server as well. This would be economical,
    but it is risky as any problem with either the production configuration or the
    Jenkins server could both bring down production and knock your CI server offline.
    This would also complicate the network and web hosting virtual host configuration—it
    would be too easy to have these distinct services conflict, without a more sophisticated
    orchestration system.
  prefs: []
  type: TYPE_NORMAL
- en: Part of running robust systems is to have adequate isolation between processes
    and systems that have distinct purposes, so avoid doubling-up Jenkins and your
    production server; run it on a system separate from your production server.
  prefs: []
  type: TYPE_NORMAL
- en: Avoid running Jenkins on your local workstation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You might also be tempted to just install Jenkins on your local workstation
    to give it a test drive. However, you will find several major drawbacks to this
    approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Your workstation probably does not have a stable IP address, necessitating dynamic
    DNS solutions, and possibly punching holes in firewalls and setting up NAT port
    redirections.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You would have to run Jenkins on your system constantly to have it process and
    build changes to the software as commits get pushed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins can be pretty heavyweight to run alongside a full development environment—and
    it may slow your workstation down significantly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we should not run Jenkins as a Docker container, and we should not run it
    on our local workstation, where should we run Jenkins? Let's explore the options.
  prefs: []
  type: TYPE_NORMAL
- en: Using an existing Jenkins server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You don't have to set up Jenkins from scratch if you have access to a Jenkins
    server running a recent version of Jenkins in the 2.x series. Recent versions
    of Jenkins have excellent support for Docker, assuming that the hosts running
    the Jenkins builds have Docker running on them.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to make sure that the following Jenkins plugins are present:'
  prefs: []
  type: TYPE_NORMAL
- en: SSH credentials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, the Jenkins server would already be set up with the GitHub Organization
    plugin and it should be configured so that it can automatically manage GitHub
    webhooks. If this is the case, you can either fork the sample repository or clone
    it and push it into your GitHub organization as a new repository and start deploying
    from there.
  prefs: []
  type: TYPE_NORMAL
- en: You will need enough permissions on the Jenkins server to create credentials,
    which we will use to hold secrets required for building and deploying the software.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new Jenkins server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A convenient way to simplify the set of technologies you have to maintain is
    to use the same base operating system and Docker setup that the production host
    runs. The instructions and scripts here are tailored to a CentOS 7 installation,
    but you can follow the same basic steps for other operating system distributions
    with some modification of the specific commands used to set up and maintain the
    packages, for example using `apt-get` instead of `yum` to install operating system
    packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by installing Docker and `docker-compose` just as you did in the previous
    chapter. Once that is done, test that Docker works with the `docker run --rm hello-world`
    command and then install Jenkins. If you are using CentOS 7, you can use the script
    at https://github.com/PacktPublishing/Docker-for-Developers/blob/master/chapter7/bin/provision-jenkins.sh
    to install both Docker and Jenkins together (replace `centos@jenkins.example.com`
    with the user name and IP address or hostname of your new Jenkins server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are using another operating system, consult the Jenkins documentation
    online for installation instructions: [https://wiki.jenkins.io/display/JENKINS/Installing+Jenkins](https://wiki.jenkins.io/display/JENKINS/Installing+Jenkins)'
  prefs: []
  type: TYPE_NORMAL
- en: In order to configure CentOS 7 to allow network traffic to flow to Jenkins,
    you may have to configure its host firewall to allow inbound traffic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, it is desirable to have Jenkins listen on a standard port such as port
    `80` or `443`. This can be accomplished in several ways, including having a web
    server act as a proxy for Jenkins, or using a load balancer to terminate SSL.
    A shortcut for allowing network traffic to flow to Jenkins on port `80` for CentOS
    7 is as follows (if you used the `provision-docker.sh` script to provision Jenkins
    this is already done):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `firewall-cmd` invocation will allow you to reach Jenkins on port `80` instead
    of specifying port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Jenkins is installed, you must retrieve a password from its logs to connect
    to the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note the password given in the output of this command. If this does not work
    immediately, wait a  few minutes and try again, as Jenkins may still be starting
    up.
  prefs: []
  type: TYPE_NORMAL
- en: Then, open a web browser and put in the IP address with the appropriate port,
    either `8080` or `80` depending on whether you have redirected connections. For
    example, enter [http://192.2.0.10:8080](http://192.2.0.10:8080) and navigate to
    the site.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see a screen that says **Unlock Jenkins**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Unlock Jenkins](img/B11641_07_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Unlock Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: Use the administrator password from the `/var/log/jenkins/jenkins.log` file
    to sign in for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next screen will prompt you to install plugins. Please install the suggested
    plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Customize Jenkins'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_07_002.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Customize Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: 'If your system has less than 4 GB of memory, you will want to run with a swap
    file. Run the `free` command to see if the server has any swap memory available.
    If not, issue these commands to create a 1 GB swap file and activate it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You should see that the system has non-zero swap memory in the output of `free`.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins security and HTTPS
  prefs: []
  type: TYPE_NORMAL
- en: For production use, you should configure Jenkins to run behind either an SSL-terminating
    load balancer or a web server configured with an SSL certificate that will listen
    on HTTPS. Please consult the Jenkins documentation or the many tutorials available
    on the internet regarding securing Jenkins with HTTPS on how to accomplish this.
    You should also consider restricting the set of IP addresses that can directly
    reach the Jenkins server as these servers are frequent targets for malicious actors.
    See the *Further reading* section at the end of this chapter for more about securing
    Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: In order to use Jenkins with Docker, you will need to install the Docker Pipeline
    plugin. From the Jenkins main screen, go to the **Manage Jenkins** | **Manage
    Plugins** menu, click on the **Available** tab, select the **Docker Pipeline**
    plugin, and then press the **Download now and install after restart** button.
    When Jenkins restarts, log in again.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a Jenkins server available to you, you can proceed to configure
    it to talk to the production server.
  prefs: []
  type: TYPE_NORMAL
- en: How Jenkins can support continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jenkins can check out the sources for a project from version control, build
    the software, run tests, and run deployment scripts. Because it has Docker support,
    it can build a Docker container, push the container to Docker Hub or another container
    repository, and then run deployment scripts that connect to a server to tell it
    to update its running Docker containers. In order to support all these objectives,
    we must configure Jenkins to integrate with the production server, with a version
    control repository, and with Docker Hub. First, we will ensure that we can use
    Jenkins to connect to the production server.
  prefs: []
  type: TYPE_NORMAL
- en: The Jenkinsfile and host connectivity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure repeatable builds, we are going to use Jenkins scripts to run build
    and deployment automation. Jenkins supports a type of script called a `Jenkinsfile`.
    Because these scripts are written using the G[roovy language (see http](https://groovy-lang.org/)s://groovy-lang.org/),
    you can declare variables, write functions, and use many features of this very
    powerful language to help you build and deploy your software. Jenkins supports
    both a free-form scripting style and a more structured declarative style of script
    that uses a special Groovy DSL to provide more scaffolding for concise scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'See here for more information on how to write a `Jenkinsfile`: [https://www.jenkins.io/doc/book/pipeline/jenkinsfile/](https://www.jenkins.io/doc/book/pipeline/jenkinsfile/)'
  prefs: []
  type: TYPE_NORMAL
- en: You can either directly enter these scripts into a Jenkins job definition or
    store them in version control. If you put a file called `Jenkinsfile` in the root
    of a version control repository, Jenkins can discover those files if it gets configured
    to talk to a version control system such as GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Jenkins and Docker with a pipeline script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To test that Jenkins and Docker are working together, we will first enter a
    script through the console. At the top-level Jenkins screen, click on the `Hello
    Docker`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – New Item – Hello Docker pipeline ](img/B11641_07_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – New Item – Hello Docker pipeline
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `chapter7/``Jenkinsfile-hello-world` in the companion GitHub project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the job and click on the **Build Now** link, and Jenkins will create build
    **#1**. Follow the link for **#1** that appears on the left and then click on
    the **Console Output** button. You should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – New Item – Hello Docker Console Output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_07_004.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – New Item – Hello Docker Console Output
  prefs: []
  type: TYPE_NORMAL
- en: You should see `Hello, World (Docker for Developers Chapter 7)` in the **Console
    Output** on the Jenkins web page. If you see out of memory errors here, ensure
    that you have a swap file on your Jenkins server. If you see an error about Docker
    not being a known agent type, go to the **Manage Jenkins** | **Manage Plugins**
    menu, and install the **Docker Pipeline** plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the production server via SSH
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will configure Jenkins to connect to the production server via SSH.
    We need to do this in order to control the Docker subsystem on the remote server.
    We will generate an SSH key for Jenkins to use and add it to the production server's
    list of authorized keys.
  prefs: []
  type: TYPE_NORMAL
- en: Generating an SSH key and adding it to Jenkins credentials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'On your local workstation, issue the following command to generate a 2,048-bit
    RSA SSH key pair and view it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Copy the contents of the `jenkins.shipit` file to your clipboard, then go to
    your Jenkins home page, and in the left-hand menu, navigate to the `jenkins.shipit`
    and enter the username of the non-root user from the production server (typically,
    `centos` for CentOS 7 cloud servers). Click on **Enter directly** and add the
    key and click on the **OK** button to save the credentials:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Add Credentials – SSH key'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_07_005.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Add Credentials – SSH key
  prefs: []
  type: TYPE_NORMAL
- en: 'Copy the SSH public key, `jenkins.shipit.pub`, from your local system to the
    production server and append it to the `~/.ssh/authorized_keys` file. By entering
    the following commands on your local workstation, replace `centos@192.2.0.10`
    with the username and IP address of your production server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Test that the SSH key authentication is working by using the key to log in
    from your local workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Once you have done this, you can create a test job that uses these credentials
    to SSH to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Use a Jenkins Pipeline job to SSH to the production server
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the Jenkins web console, create a new Jenkins job with the `SSH to Production`,
    and pick the **Pipeline** job type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Create Item – SSH to Production'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_07_006.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Create Item – SSH to Production
  prefs: []
  type: TYPE_NORMAL
- en: 'In the job definition form, in the `centos@192.2.0.10` to the user and host
    for your production se[rver, and save the job script (see `chapte`](https://github.com/PacktPublishing/Docker-for-Developers/blob/master/chapter7/Jenkinsfile-ssh-proof-of-concept)`r7/Jenkinsfile-ssh-proof-of-concept`)
    in the companion GitHub project):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When you run this by clicking on the **Build Now** link, and view the console
    output, you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you do not see the output of `docker ps`, double-check the username, IP address,
    and SSH key. Check for any error messages that Jenkins emits about the `Jenkinsfile`
    or related to the `ssh` shell command to troubleshoot. You will need to get this
    to work in order to get the next stage to work reliably.
  prefs: []
  type: TYPE_NORMAL
- en: You can use Jenkins to connect to other hosts to run scripts that use `docker`
    and `docker-compose`. But you can also run `docker` and `docker-compose` directly
    on the Jenkins server if you need to. We will explore that later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can use Jenkins to connect to the production server via SSH, using
    a pipeline script, we can use that connection to make changes to the production
    server, including deploying new changes to the server.
  prefs: []
  type: TYPE_NORMAL
- en: Driving configuration changes through Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Next, we will learn how to make changes to the production system by running
    scripts from the Git repository hosted in Jenkins. We can use Jenkins both to
    build the Docker containers for the application and to deploy those containers
    on the production server. That way, any changes to either the program or to its
    `Dockerfile` or the `docker-compose.yml` file can be propagated through automation
    to the production system.
  prefs: []
  type: TYPE_NORMAL
- en: Here are some tips for integrating Jenkins with other systems, including GitHub,
    that can make your life easier. The first tip relates to the best way to configure
    Jenkins with a `Jenkinsfile`—by storing it in a version control system.
  prefs: []
  type: TYPE_NORMAL
- en: Using Git and GitHub to store your Jenkinsfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we used `Jenkinsfile` entered directly into a Jenkins
    job to do some quick testing. That works well for doing exploratory work, but
    to build and manage a more complex set of scripts, you should use Git version
    control to store the `Jenkinsfile` and use GitHub to store and share the Git repository,
    since GitHub integrates nicely with Jenkins. This will let you make changes not
    only to your program but also to the deployment scripts in a controlled fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about why you should use the Git version control system
    in conjunction with GitHub, see this introductory guide: [https://guides.github.com/introduction/git-handbook/](https://guides.github.com/introduction/git-handbook/).'
  prefs: []
  type: TYPE_NORMAL
- en: We can combine the power of a script stored in GitHub with the Jenkins `Jenkinsfile`
    as the one in the repository for this book to deploy the demonstration project.
    This support for environment variable substitution will allow you to use the `Jenkinsfile`
    unchanged, even though your production server may be set up with a distinct user
    and host, while also using your SSH, Docker Hub, and GitHub credentials, which
    are similarly distinct.
  prefs: []
  type: TYPE_NORMAL
- en: In order to make further progress, you must make sure that Jenkins has a GitHub
    username and security token as a credential so that you can use Jenkins to check
    out GitHub repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring Jenkins has a GitHub username and security token credential
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In order to use Jenkins with GitHub, you will need to save a Jenkins credential
    that has a GitHub personal access token. I[n a web browser, sign in to GitHub](https://github.com/settings/tokens),
    and go to [https://github.com/settings/tokens](https://github.com/settings/tokens)
    and generate a token that has both the `repo` and `admin:repo_hook` scopes. Copy
    the generated token to the clipboard. Then, in another browser window, go to your
    Jenkins server and navigate through credentials to the Jenkins global credentials
    and create a `github.repo.username` and a description of `username` with your
    actual GitHub username. Press the **OK** button to save the credential.
  prefs: []
  type: TYPE_NORMAL
- en: Option 1 – Configuring Jenkins with a GitHub organization item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jenkins has support for defining *items* that might be individual Jenkins jobs
    or collections of related jobs. Several of the types of items allow you to connect
    a version control system to Jenkins so that it will automatically define multiple
    Jenkins jobs. One of the most powerful of these is a `GitHub Organization` item.
    Using a `GitHub Organization` item will allow Jenkins to scan GitHub for every
    project that has a `Jenkinsfile`, and Jenkins will automatically set up a forest
    of child items for all the repositories in the GitHub organization where it finds
    a `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: This is the easiest way to have Jenkins manage a set of related projects If
    you are using a new Jenkins server to explore Docker development, in a GitHub
    organization you control, try setting this up. If you are using a corporate Jenkins
    server, this may already be set up.
  prefs: []
  type: TYPE_NORMAL
- en: From your Jenkins installation's home page, click the `GitHub Organization`.
    Use the credentials labeled as **GitHub repo credentials (username)** and make
    sure the name in the organization field matches your GitHub organization name.
  prefs: []
  type: TYPE_NORMAL
- en: You can set up a filter so that this scans only the projects you want for a
    `Jenkinsfile`. This might be a good idea if you have a huge number of repositories
    and branches in your organization, or if you only want your installation of Jenkins
    to build specific repositories—the repositories that might work with Jenkins—or
    there is some other Jenkins server that also builds a subset of the projects in
    your GitHub organization. If you want to do this, add a `Behavior` of type `Filter
    by name (with regular expression)` and construct a regular expression to match
    the names of only the repositories you want to include.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub, fork the Docker-for-Developers repository ([https://github.com/PacktPublishing/Docker-for-Developers/](https://github.com/PacktPublishing/Docker-for-Developers/))
    to your organization. Alternatively, if you don't want to fork the repository,
    create an empty repository in your organization. Then, push your local copy of
    the repository to the freshly created repository, go into the GitHub organization
    item you created, and you should see a **Docker-for-Developers** item show up.
  prefs: []
  type: TYPE_NORMAL
- en: If you are using an individual GitHub account, and lack access to a GitHub organization,
    this may not be a good option, however. You could instead configure Jenkins with
    a multibranch pipeline item that retrieves the `Jenkinsfile` from a single GitHub
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Option 2 – Configuring Jenkins with a multibranch pipeline item
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a multibranch pipeline item will allow Jenkins to scan GitHub for a single
    repository for every project that has a `Jenkinsfile`, and Jenkins will automatically
    set up a forest of child items for branches and pull requests for a single configured
    GitHub repository, for branches where it finds a `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Fork the Docker-for-Developers repository to your organization or create an
    empty repository in your account and push your local copy of the repository to
    GitHub. You need to do this before configuring the multibranch pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: From your Jenkins installation's home page, click the `Multibranch Pipeline`.
    In **Branch Sources**, choose **GitHub**, and then fill out the GitHub form with
    the credentials labeled as **GitHub repo credentials (username)**, and put the
    URL of your GitHub repository in the **Repository HTTPS URL** field. Then, save
    the item. It will scan the repository and set up the individual Jenkins jobs for
    each Git branch.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, whether you have used the multibranch pipeline or the GitHub
    organization item type, you should have a set of branches in your Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the origin of all checked out repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you should also change the URL for your Git repositories, both
    on your local workstation, and on the production server you set up in the previous
    chapter, to the new repository URL. Replace `example` with the name of your GitHub
    organization or user where you forked the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Checking that your GitHub repository is talking to Jenkins via a webhook
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub can communicate with other systems via webhooks, which are HTTP requests
    that the system triggers, targeting another system, when people do certain actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'See here for more information about GitHub''s support for webhooks and system
    integration: [https://developer.github.com/webhooks/](https://developer.github.com/webhooks/)'
  prefs: []
  type: TYPE_NORMAL
- en: When we set up the `GitHub Organization` item or the `MultiBranch Pipeline`
    item, Jenkins should have set up one of these webhooks in GitHub so that it can
    talk to Jenkins. If it did not, you can go to the `https://jenkins.example.com/github-webhook/`
    (replacing `jenkins.example.com` with your Jenkins server).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have configured Jenkins to be able to communicate with GitHub, we
    want to make sure that pushing a branch to GitHub triggers builds in Jenkins.
    Depending on your account's GitHub permissions and the Jenkins configuration,
    it might not have created the webhook automatically.
  prefs: []
  type: TYPE_NORMAL
- en: In a web browser, navigate to your GitHub repository and go to **Settings**,
    then to **Webhooks**, and verify that there is a webhook with your Jenkins server
    URL there.
  prefs: []
  type: TYPE_NORMAL
- en: What to expect now that Jenkins is connected to GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have configured Jenkins to be able to check for the presence of
    a `Jenkinsfile` in the repository we are using, we can proceed. Jenkins will try
    to build the project you have just defined. The build will fail unless you provide
    Jenkins with additional variables and credentials, however.
  prefs: []
  type: TYPE_NORMAL
- en: In order to tie the specific configurations for the build to your environment,
    we will need to use Jenkins to set up some environment variables to store the
    less sensitive items, in addition to storing cryptographic keys and passwords
    using the **Credentials** feature.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Jenkins environment variables for production support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Jenkins has support for setting environment variables that items (build and
    deployment jobs, for example) can reference. For secret variables, such as SSH
    private keys, or Docker Hub API credentials, you can use the **Credentials** system
    that we used in the previous section to store these securely. For values that
    are less sensitive, we can use the **Environment variables** settings available
    on the Jenkins **configuration** screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Jenkins configuration – Environment variables for production
    host'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_07_007.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Jenkins configuration – Environment variables for production host
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to proceed, please double-check with the DNS provider that you use
    that your production host has a DNS name associated with its IP address. In [*Chapter
    6*](B11641_06_Final_NM_ePub.xhtml#_idTextAnchor102), *Deploying Applications with
    Docker Compose*, we set up DNS names for the production server. Having a DNS name
    will make the configurations more readable and will make it easier for people
    to reach the server in a web browser. Set up variables for these keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shipit_prod_host`: Production server DNS domain name, for example, [shipitclicker.example.com](http://shipitclicker.example.com))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shipit_prod_user`: Production server username, for example, `centos`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have set up these variables, hit the **Save** button. We will use these
    variables when we run the Jenkins job that updates the running containers. Before
    we do that though, we need a place to put the containers. In a previous chapter,
    you learned how to push a container image to Docker Hub. Next, we will automate
    that process.
  prefs: []
  type: TYPE_NORMAL
- en: Building Docker containers and pushing them to Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to avoid building the containers on the production server, we will
    need to build them on Jenkins and then push the containers into a Docker container
    registry, such as Docker Hub. This allows a clean separation of building the Docker
    containers from deploying them. If you try to both build and deploy the container
    on a single small server, it is highly likely that at some point you will run
    into out of memory issues or other system stability problems. And on a production
    server, you want to maximize the stability of that environment.
  prefs: []
  type: TYPE_NORMAL
- en: While you could push the container to Docker Hub from your local workstation,
    part of the benefit of using Jenkins is that you can use it to automatically build
    and push containers to a central repository. To do that, you will need to give
    Jenkins credentials to Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker Hu[b credentials to Jenkin](https://hub.docker.com/)s credential
    manager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Log in to [https://hub.docker.com/](https://hub.docker.com/) with your Docker
    accoun[t and create an API token for Jenkins t](https://hub.docker.com/settings/security)o
    use from the [https://hub.docker.com/settings/security](https://hub.docker.com/settings/security)
    security settings page. Copy that API token to the clipboard and in another web
    browser tab, visit the Jenkins credential manager and create another global unrestricted
    credential of type `Username with Password`. Give it an ID called [shipit.dockerhub.id](http://shipit.dockerhub.id)
    and put your Docker account username in the `username` field, and the access token
    in the `password` field and save it.
  prefs: []
  type: TYPE_NORMAL
- en: This will allow you to use your Docker Hub credentials to push a build to Docker
    Hub, and since we already have SSH credentials set up in Jenkins, we can use those
    to push a Docker image to Docker Hub after we build it, and then to connect to
    the production server in order to deploy the new software.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring the previous production environment is stopped
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the production environment from the previous chapter is running, you will
    need to stop it in order to deploy the new environment. This will ensure that
    the new production environment can bind to the correct TCP ports.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In a situation where you have a real production application with valuable customer
    data, you would want to back up and restore any databases and other persistent
    storage to the new environment. The ShipIt Clicker application only uses Redis
    in order to save details about the production environment. For Redis, this can
    be done via the CLI using the `SAVE` command. You can then copy the resulting
    `dump.rdb` file into the Docker volume that this chapter's Redis container uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'From your local workstation, SSH to the server and stop it (replace `192.0.2.10`
    with the IP address of your server):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now that the previous Docker containers are stopped, you may proceed with using
    Jenkins to build the software, push to Docker Hub, and deploy the containers on
    the production server. You only have to do this once, when you are first transitioning
    from the setup from the previous chapter to the environment managed by Jenkins
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's trigger a production environment deployment through Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing to Docker Hub and triggering a production deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have all the environment variables and credentials in place, we
    can trigger a Jenkins build. Jenkins normally triggers a build when it detects
    a commit, but we can also force Jenkins to start a build. Go to the Jenkins job
    that is hooked up to the GitHub repository where the application code resides
    for the `master` branch and click on **Build Now**. Jenkins will start building
    the job and show the build number in the user interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Jenkins jobs in GitHub Organization – master branch'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B11641_07_008.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Jenkins jobs in GitHub Organization – master branch
  prefs: []
  type: TYPE_NORMAL
- en: Before we check on the progress of the job, let's examine how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jenkins runs a combination of the `Jenkinsfile` and the script `chapter7/bin/`[dep-ssh.sh](http://dep-ssh.sh)
    in order to build and deploy the software. The `Jenkinsfile` checks out the repository,
    builds the Docker container, and pushes it to Docker Hub. The following excerpt
    from the `Jenkinsfile` shows the code that manages the checkout, build, and push
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The next stage, the `deploy` stage, runs when the branch is `master` or staging
    and invokes the shell script `chapter7/bin/dep-ssh.sh`, which connects to the
    server via SSH and updates the copy of the repository, pulls the built Docker
    containers, and restarts the containers. See the following excerpt from `dep-ssh.sh`
    for the most important part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now that you understand how the build and deploys are chained together, you
    should see whether the deployment to the production environment worked.
  prefs: []
  type: TYPE_NORMAL
- en: Verifying that the deployment worked
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Click on the most recent build and then click on `Finished: Success` at the
    end of the console output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The console output will show these basic steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The Git repository being cloned from GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker container being built.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The Docker container being pushed to Docker Hub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Jenkins connecting to the production server via SSH.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The script `chapter7/bin/ssh-dep.sh` runs on the production server, which then
    pulls the image from Docker Hub and restarts the Docker services.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If any of the preceding steps fail, the Jenkins job will fail. If that happens,
    double-check that the credentials and environment variables are correct. You [can
    compare the output of](https://github.com/PacktPublishing/Docker-for-Developers/blob/master/chapter7/consoleOutput.txt)
    your test run to the sample output, `chapter7/consoleOutput.txt`, in the companion
    GitHub repository to see whether your Jenkins run worked as expected.
  prefs: []
  type: TYPE_NORMAL
- en: If this has built successfully, you should be able to go [to the same URL you
    used in the p](http://shipitclicker.example.com/)revious chapter (for example,
    [http://shipitclicker.example.com/](http://shipitclicker.example.com/) or [http://192.2.0.10/](http://192.2.0.10/))
    in order to see the application. Congratulations! Now every push to the master
    branch, including when pull requests get merged to the master branch, will deploy
    the production environment. This is one of the simplest ways to achieve continuous
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: You might want to be able to see your changes in a separate environment that
    is stable and always available so that if you make changes that might break the
    production environment, you can test them out in isolation. In the next section,
    we will learn how to set up a staging environment similar to the production environment
    and orchestrate deployments to it using Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying to multiple environments through multiple branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Being able to deploy to a single production environment is valuable, but in
    order to support development and testing, it is useful to have at least one other
    environment other than the production environment to test with. That way, people
    testing the software who do not have a development environment can see the effect
    of changes you make, without you having to deploy them to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next part of the chapter, we are going to create a second environment,
    a staging environment, to allow us to test changes before they are in production.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a staging environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You will need another host, similar in specifications to the one running the
    production environment, for the staging environment. Once you can SSH to that
    host, you could follow the instructions in the previous chapter about installing
    Docker and Git. Assuming you are running on CentOS 7, you can use the following
    script snippet to quickly provision Docker on that system and test that it is
    working (replace `centos@192.2.0.11` with the user and host you are using for
    your staging environment, and the GitHub URL with the URL of your organization''s
    fork of the project repository):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have Docker working on the staging system, you can enter the `exit`
    command to go back to your local workstation. Then, make sure that the staging
    system has the same SSH public key that the production system has. Do this from
    the directory that contains the `jenkins.shipit.pub` key file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now that the staging server has been prepared with the right SSH credentials
    and the essential software needed to run Docker applications, we will configure
    Jenkins to support this staging environment.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Jenkins environment variables for staging support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to prepare Jenkins for deployments to the staging server, we will
    return to the **Environment variables** settings available on the Jenkins **configuration**
    screen. In order to proceed, please make sure that your staging host has a DNS
    name associated with it. Set up variables for these keys and values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`shipit_staging_host`: Staging server DNS domain name, for example, `shipit-staging.example.com`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`shipit_staging_user`: Staging server username, for example, `centos`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying by force-pushing to the staging branch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The deployment scripts detect what branch is being processed and deploy to the
    right environment. This is done with a combination of directives in the `Jenkinsfile`
    and having the deploy script use environment variables set up through the `Jenkinsfile`
    and the Jenkins global configuration. Before we get to the example that shows
    how to use Git to force-push, we need to examine the `Jenkinsfile` and support
    scripts to see how they handle branch names.
  prefs: []
  type: TYPE_NORMAL
- en: How do the scripts know what server to use?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Jenkinsfile` will only run the deploy stage if the branch name is either
    `master` or `staging`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we are going to see some of the power of using a `Jenkinsfile`, showing
    off some of the Groovy language features such as variable interpolation and calling
    functions. The steps that follow in the `Jenkinsfile` define environment variables
    that the `chapter7/bin/ssh-dep.sh` script uses to help pick the right environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: These use Jenkins variable interpolation expressions to call Jenkins functions
    written in Groovy (`getTarget()` and `getImageName(appName)`) that set some of
    the environment variables that the  `chapter7/bin/ssh-dep.sh` script uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getTarget()` function uses this ternary expression to pick whether to
    target the `prod` or `staging` environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the flow of control has passed to the `chapter7/bin/ssh-dep.sh` script,
    it uses the target environment variables to pick what environment to target and
    sets variables up so that the SSH command will pick the correct server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, the shell script sets up `targetEnv` so that the following SSH
    command can reach the correct server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now that you see how the variables in the `Jenkinsfile` and `chapter7/bin/ssh-dep.sh`
    interact, you are ready to use Git to initiate a deployment to staging.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing to use Git to force-push a branch to staging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although force-pushing branches in Git can be problematic, this is one of the
    times when it makes sense. If you consider the `staging` branch to be special,
    not something that you would ordinarily merge into the master, you can then repeatedly
    force-push work in progress from any branch to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'On your local workstation, create a new branch in the Git repository called
    `experiment` by issuing the command `git checkout -b experiment`. Edit the `chapter7/src/public/index.html`
    file and change the text enclosed in the `<h1>` tags to `ShipIt Clicker Experiment`.
    Save the file and do a `git commit` command. Then, force-push the `HEAD` of your
    branch to GitHub as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will push the code you just committed to GitHub. Then, open a web browser
    to your Jenkins server and examine the item for your repository. You should shortly
    see that Jenkins has created a `staging` branch job and will build the software
    and push it to Docker Hub, and deploy it to the staging environment. Observe the
    Jenkins console log for the job for the `staging` branch and make sure that it
    is similar to the one for the production deployments from the `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: If your deployment worked, check with a web browser to see that the title of
    the application on the staging server is `ShipIt Clicker Experiment`—the text
    you changed.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have used Jenkins to deploy a Docker application to both a
    production and a staging server. You might wonder what it would take to add a
    third or fourth environment, or what the drawbacks of this approach might be.
    Very complex scripts and environments might make it harder to deploy with Jenkins—let's
    examine that more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Complexity and limits to scaling deployments through Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Jenkins is a general-purpose tool for building and scripting processes
    related to software development, it offers immense flexibility, but at the cost
    of complexity. While it can do almost any function related to continuous integration
    and deployment, it may take more scripting and setup than other systems, such
    as Spinnaker, CodeFresh, or WeaveWorks, that are more purpose-built. Some other
    continuous integration and deployment systems deal exclusively with Docker-focused
    workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Using Jenkins to manage builds, tests, and deployments to one or two hosts is
    quite manageable. But when you start to scale out, it may become more complex
    and difficult to continue to use Jenkins to handle builds and deployments. The
    build and deployment scripts may also become too complex to manage due to the
    many different programming languages and approaches required. Let's examine these
    limits, starting with limits about managing multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Managing multiple hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scripts shown in this chapter handled deployments to two environments:
    a production environment and a staging environment. However, if we wanted to have
    four more similar environments, say, development, QA, demo, and beta, we might
    have to spin up four additional hosts and extend our scripts accordingly. It could
    get to be a big, expensive mess pretty fast. Also consider what would happen if
    one host became too small to run the production site. You might need to run a
    fleet of instances and make sure that they all use the same database. Then, you
    would get into issues about how you might update and deploy that fleet of instances
    without downtime. The questions and problems start to get bigger if you use a
    brute-force scripting approach.'
  prefs: []
  type: TYPE_NORMAL
- en: If you were going to use Jenkins to manage multiple hosts at scale, you would
    want to look into integrating it with services that offer additional abstractions
    to handle scaling and deployment, such as AWS EC2 Auto Scaling Groups, and AWS
    CodeDeploy. However, neither of those are focused on Docker-specific functionality.
    You could also use Jenkins to run scripts that used Kubernetes tools, such as
    `kubectl` or `helm`, in order to deploy the software to a Kubernetes cluster,
    if you have an organizational commitment to using Jenkins as your continuous integration
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of build scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the best things about Jenkins is that it allows you to script builds
    using the Groovy domain-specific language; however, this can be one of the worst
    things simultaneously. Groovy is a powerful and concise Java virtual machine-based
    language, but it is much less well known than many other scripting languages,
    such as Python, Ruby, and Bash. Furthermore, Jenkins uses a sandbox model to limit
    what type of Groovy statements are allowed.
  prefs: []
  type: TYPE_NORMAL
- en: This often means that implementers must split their build scripts between a
    high-level orchestration layer written in the Jenkins pipeline DSL dialect of
    Groovy and some other language. This project uses a combination of Groovy `Jenkinsfile`
    and Bash shell scripts to do this, which drive the Docker builds and deploys.
  prefs: []
  type: TYPE_NORMAL
- en: How do you know when you have hit the limit?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'People who have had many years of experience using Jenkins and hand-rolled
    scripts to build and deploy software have learned to recognize a few signs that
    using Jenkins for your purposes has hit its limits:'
  prefs: []
  type: TYPE_NORMAL
- en: The installation of Jenkins itself becomes fragile and too complex for new people
    on the project to learn quickly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It becomes difficult to upgrade Jenkins because of plugin incompatibilities.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The build scripts fail routinely, and people ignore the failures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It starts taking too long to build and deploy the software to meet the business
    needs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you maintain many applications, the scripts used to build and maintain them
    become a maze of cut and paste spaghetti code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you see these signs, it might be time to consider using a more purpose-built
    approach, such as Spinnaker, GitLab CI, or CodeFresh as your CI and container
    pipeline management tool.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned how to construct a continuous deployment pipeline
    using Docker, Jenkins, and GitHub. You learned how to establish connectivity between
    a Jenkins server and multiple host servers through SSH, scripted using a `Jenkinsfile`.
    You learned how to combine those techniques to drive configuration changes and
    Docker deployments to the production host using Jenkins. You also learned how
    to set up a second staging environment and use the Jenkins environment variables
    and credentials support in order to make a single set of scripts deploy to multiple
    environments. Finally, you learned about the limitations of using Jenkins to manage
    larger-scale deployments, and when it might be time to reach for other tools to
    manage continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have mastered the basics of using Jenkins to build and deploy software
    to both a production and a staging environment, you can apply this to your own
    projects. This will help you build and deploy your software more reliably.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how we can use Kubernetes and the **Amazon
    Web Services Elastic Kubernetes Service** (**AWS EKS**) to manage larger-scale,
    more robust clusters of servers that can host applications running in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you choose to use Jenkins to manage your Docker-based environments, you
    should look at these resources more closely:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a `Jenkinsfile`: [https://jenkins.io/doc/book/pipeline/jenkinsfile/](https://jenkins.io/doc/book/pipeline/jenkinsfile/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jenkins Docker integration docs: [https://jenkins.io/doc/book/pipeline/docker/](https://jenkins.io/doc/book/pipeline/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Securing Jenkins: [https://jenkins.io/doc/book/system-administration/security/](https://jenkins.io/doc/book/system-administration/security/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using Let''s Encrypt and Apache to secure Jenkins with SSL: https://www.agileana.com/blog/serve-jenkins-over-https-with-apache-as-proxy-and-certbot-lets[encrypt-ssl/](https://wiki.jenkins.io/display/JENKINS/Jenkins+behind+an+NGinX+reverse+proxy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[Using an NGINX reverse proxy or AWS ELB to secure Jenkins with S](https://wiki.jenkins.io/display/JENKINS/Jenkins+behind+an+NGinX+reverse+proxy)SL:
    [https://wiki.jenkins.io/display/JENKINS/Jenkins+behind+an+NGinX+reverse+proxy](https://wiki.jenkins.io/display/JENKINS/Jenkins+behind+an+NGinX+reverse+proxy)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you are running a real production application on a single host with `docker-compose`,
    you should strongly consider securing your site with SSL. You can use Let''s Encrypt
    and a host of Docker sidecar containers to achieve this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to use Let''s Encrypt, NGINX, and Docker to secure your site with SSL:
    [https://github.com/nginx-proxy/docker-letsencrypt-nginx-proxy-companion](https://github.com/nginx-proxy/docker-letsencrypt-nginx-proxy-companion)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using `docker-compose.yml` to configure Let''s Encrypt with NGINX and Docker:
    [https://github.com/nginx-proxy/docker-letsencrypt-nginx-proxy-companion/blob/master/docs/Docker-Compose.md](https://github.com/nginx-proxy/docker-letsencrypt-nginx-proxy-companion/blob/master/docs/Docker-Compose.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
