<html><head></head><body>
        

                            
                    <h1 class="header-title">Branching, Merging, and Options</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Managing your local branches</li>
<li>Branches with remotes</li>
<li>Forcing a merge commit</li>
<li>Using git reuse recorded resolution (rerere) to merge Git conflicts</li>
<li>Computing the difference between branches</li>
<li>Orphan branches</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>If you are developing a small application in a big corporation as a developer, or you are trying to wrap your head around an open source project from GitHub, you have already been using branches with Git.</p>
<p>Most of the time, you may have just been working on a local development or master branch, and so didn't care so much about other branches.</p>
<p>In this chapter, we will show you different branch types and how to work with them.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing your local branches</h1>
                
            
            
                
<p>Suppose you just have your local Git repository, and, at the moment, you have no intention of sharing the code with others; you can, however, easily share the knowledge you have while working with a repository with one or more remotes. Local branches with no remotes work exactly in this fashion. As you can see in the examples, we are cloning a repository, and thus we have a remote.</p>
<p>Let's start by creating a few local branches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Use the following command to clone the <kbd>jgit</kbd> repository to match:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit</strong> 
<strong>$ cd jgit</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Perform the following steps to manage your local branches:</p>
<ol>
<li>Whenever you start working on a bug fix or a new feature in your project, you should create a branch. You can do so using the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch newBugFix</strong> 
<strong>$ git branch</strong> 
<strong>* master</strong> 
<strong> newBugFix</strong> </pre>
<ol start="2">
<li>The <kbd>newBugFix</kbd> branch points to the current <kbd>HEAD</kbd> you were on at the time of the creation. You can see the <kbd>HEAD</kbd> with <kbd>git log -1</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1 newBugFix --format=format:%H</strong> 
<strong>25fe20b2dbb20cac8aa43c5ad64494ef8ea64ffc</strong> </pre>
<ol start="3">
<li>If you want to add a description to the branch, you can do this with the <kbd>--edit-description</kbd> option for the git branch command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch --edit-description newBugFix</strong></pre>
<ol start="4">
<li>The previous command will open an editor where you can type in a description:</li>
</ol>
<pre style="padding-left: 60px"><strong>Refactoring the Hydro controller</strong> 

<strong>The hydro controller code is currently horrible needs to be refactored. </strong> </pre>
<ol start="5">
<li>Close the editor and the message will be saved.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Git stores the information in the local <kbd>git config</kbd> file; this also means that you cannot push this information to a remote repository.</p>
<p>To retrieve the description for the branch, you can use the <kbd>--get</kbd> flag for the <kbd>git config</kbd> command:</p>
<pre><strong>$ git config --get branch.newBugFix.description</strong> 
<strong>Refactoring the Hydro controller</strong> 

<strong>The hydro controller code is currently horrible and needs to be refactored. </strong> </pre>
<p>This will be beneficial when we automate some tasks in <a href="fcc6f77f-119c-41e9-b4b0-9b7df263b7f1.xhtml">Chapter 7</a>, <em>Enhancing Your Daily Work with Git Hooks</em>, <em>Aliases, and Scripts</em>.</p>
<p>Remember to perform a checkout of <kbd>newBugFix</kbd> before you start working on it. This must be done with the Git checkout of <kbd>newBugFix</kbd>. If you are in a hurry, you can create and checkout a new branch in a single command. Just give the option <kbd>-b</kbd> to <kbd>checkout</kbd>.</p>
<p>The branch information is stored as a file in <kbd>.git/refs/heads/newBugFix</kbd>:</p>
<pre><strong>$ cat .git/refs/heads/newBugFix</strong> 
<strong>25fe20b2dbb20cac8aa43c5ad64494ef8ea64ffc</strong> </pre>
<p>Note that it is the same commit hash we retrieved with the <kbd>git log</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Perhaps you want to create specific branches from specific commit hashes. The first thought might be to check out the commit, and then create a branch; however, it is much easier to use the <kbd>git branch</kbd> command to create the branches without checking out the commits:</p>
<ol>
<li>If you need a branch from a specific commit hash, you can create it with the <kbd>git branch</kbd> command as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch anotherBugFix 979e346</strong> 
<strong>$ git log -1 anotherBugFix --format=format:%h</strong> 
<strong>979e346</strong> 

<strong>$ git log -1 anotherBugFix --format=format:%H</strong> 
<strong>979e3467112618cc787e161097986212eaaa4533</strong> </pre>
<ol start="2">
<li>As you can see, the abbreviated commit hash is shown when you use <kbd>%h</kbd>, and the full commit hash is shown when you use <kbd>%H</kbd>. You can see that the abbreviated commit hash is the same as the one used to create the branch. Most of the time, you want to create and start working on the branch immediately:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b lastBugFix 979e346</strong> 
<strong>Switched to a new branch 'lastBugFix'</strong> </pre>
<ol start="3">
<li>Git switches to the new branch immediately after it creates the branch. Verify with <kbd>gitk</kbd> to see whether the <kbd>lastBugFix</kbd> branch is checked out and another <kbd>BugFix</kbd> branch is at the same commit hash:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ gitk</strong></pre>
<p style="padding-left: 60px">This can be shown via a screenshot as follows:</p>
<div><img class="alignnone size-full wp-image-195 image-border" src="img/77c7e1a2-9511-4240-878c-ab4d41cdafe5.png" style="width:33.75em;height:14.92em;"/></div>
<ol start="4">
<li>Instead of using Gitk, you can also add <kbd>-v</kbd> to the <kbd>git branch</kbd> command or even another <kbd>-v</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch -v</strong> 

<strong>  anotherBugFix 979e346 Interactive Rebase: Do actions if </strong> 
<strong>* lastBugFix    979e346 Interactive Rebase: Do actions if </strong> 
<strong>  master        25fe20b Add missing package import for jg</strong> 
<strong>  newBugFix     25fe20b Add missing package import for jg</strong> </pre>
<ol start="5">
<li>With <kbd>-v</kbd>, you can see the abbreviated commit hash for each branch, and with <kbd>-vv</kbd>, you can also see that the master branch tracks the origin/master branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch -vv</strong> 

<strong>  anotherBugFix 979e346 Interactive Rebase: Do actions if e</strong> 
<strong>* lastBugFix    979e346 Interactive Rebase: Do actions if e</strong> 
<strong>  master        25fe20b [origin/master] Add missing package </strong> 
<strong>  newBugFix     25fe20b Add missing package import for g</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Branches with remotes</h1>
                
            
            
                
<p>At some point, it is very likely that you have cloned somebody's repository. This means that you have an associated remote. The remote is usually called origin because it is where the source originated from.</p>
<p>While working with Git and remotes, you will get some benefits from Git.</p>
<p>We can start with git status and see what we get while working with the remote.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Follow these steps:</p>
<ol>
<li>We will start by checking out a local branch that tracks a remote branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b remoteBugFix --track origin/stable-3.2</strong> 
<strong>Branch remoteBugFix set up to track remote branch stable-3.2 from origin.</strong> 
<strong>Switched to a new branch 'remoteBugFix'</strong></pre>
<ol start="2">
<li>The previous command creates and checks out the <kbd>remoteBugFix</kbd> branch that will track the <kbd>origin/stable-3.2</kbd> branch. Therefore, for instance, executing <kbd>git status</kbd> will automatically show how different your branch is from <kbd>origin/stable-3.2</kbd>, and it will also show whether your branch's <kbd>HEAD</kbd> can be fast forwarded to the <kbd>HEAD</kbd> of the remote branch or not.</li>
<li>To provide an example of how the previous step works, we need to do some manual work that will simulate this situation. First, we find a commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -10 origin/stable-3.2 --oneline</strong> 
<strong>f839d383e (HEAD -&gt; remoteBugFix, origin/stable-3.2) Prepare post 3.2.0 builds</strong><br/><strong>699900c30 (tag: v3.2.0.201312181205-r) JGit v3.2.0.201312181205-r</strong><br/><strong>0ff691cdb Revert "Fix for core.autocrlf=input resulting in modified file..."</strong><br/><strong>1def0a125 Fix for core.autocrlf=input resulting in modified file and unsmudge</strong><br/><strong>0ce61caef Canonicalize worktree path in BaseRepositoryBuilder if set via config</strong><br/><strong>be7942f2b Add missing @since tags for new public methods in Config</strong><br/><strong>ea04d2329 Don't use API exception in RebaseTodoLine</strong><br/><strong>3a063a0ed Merge "Fix aborting rebase with detached head" into stable-3.2</strong><br/><strong>e90438c0e Fix aborting rebase with detached head</strong><br/><strong>2e0d17885 Add recursive variant of Config.getNames() methods </strong></pre>
<ol start="4">
<li>The command will list the last 10 commits on the <kbd>stable-3.2</kbd> branch from the remote origin. The <kbd>--oneline</kbd> option will show the abbreviated commit hash and the commit subject. For this recipe, we will be using the following commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard 2e0d178</strong> 
<strong>HEAD is now at 2e0d178 Add recursive variant of Config.getNames() methods</strong> </pre>
<ol start="5">
<li>This will reset the <kbd>remoteBugFix</kbd> branch to the <kbd>2e0d178</kbd> commit hash. We are now ready to continue using the free benefits of Git when we have a remote tracking branch.</li>
</ol>
<p>We are resetting to a commit that is accessible from the <kbd>origin/stable-3.2</kbd> remote tracking branch; this is done to simulate that we have performed a Git fetch and new commits were downloaded for the <kbd>origin/stable-3.2</kbd> branch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Here, we will try a few commands that assist you when you have a remote tracking branch:</p>
<ol>
<li>Start by executing <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong> 

<strong>On branch remoteBugFix</strong> 
<strong>Your branch is behind 'origin/stable-3.2' by 9 commits, and can be fast-forwarded.</strong> 
<strong>  (use "git pull" to update your local branch)</strong> 

<strong>  nothing to commit, working directory clean</strong> </pre>
<p style="padding-left: 60px">Git is very descriptive when you have a tracking branch and you use <kbd>git status</kbd>.</p>
<p style="padding-left: 60px"><br/>
As you can see from the message, you can use <kbd>git pull</kbd> to update your local branch, which we will try in the next example. The message says it can be fast-forwarded. It simply means that Git can advance the <kbd>HEAD</kbd> without merging. Now, we will just perform the merge:</p>
<p>The <kbd>git pull</kbd> command is just a <kbd>git fetch</kbd> command and then a <kbd>git merge</kbd> command with the remote tracking branch.</p>
<pre style="padding-left: 60px"><strong>$ git merge origin/stable-3.2</strong> 

<strong>Updating 2e0d178..f839d38</strong> 
<strong>Fast-forward</strong> 
<strong> .../org/eclipse/jgit/api/RebaseCommandTest.java    | 213 +++++++++++</strong> 
<strong> .../src/org/eclipse/jgit/api/RebaseCommand.java    |  31 +--</strong> 
<strong> .../jgit/errors/IllegalTodoFileModification.java   |  59 ++++++</strong> 
<strong> .../eclipse/jgit/lib/BaseRepositoryBuilder.java    |   2 +-</strong> 
<strong> .../src/org/eclipse/jgit/lib/Config.java           |   2 +<br/> .../src/org/eclipse/jgit/lib/RebaseTodoLine.java   |  16 +-</strong> 
<strong> 6 files changed, 266 insertions(+), 57 deletions(-)</strong> 
<strong> create mode 100644 org.eclipse.jgit/src/org/eclipse/jgit/errors/IllegalTodoFileModification.java</strong></pre>
<ol start="2">
<li>From the output, you can see it is a fast-forward merge, as Git predicted in the<br/>
output of <kbd>git status</kbd>.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You can also add a remote to an existing branch, which is very handy when you realize that you actually wanted a remote tracking branch but forgot to add the tracking information while creating the branch:</p>
<ol>
<li>Start by creating a local branch at the <kbd>2e0d17</kbd> commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b remoteBugFix2 2e0d17</strong> 
<strong>Switched to a new branch 'remoteBugFix2'</strong> </pre>
<ol start="2">
<li>The <kbd>remoteBugFix2</kbd> branch is just a local branch at the moment with no tracking information; to set the tracking branch, we need to use <kbd>--set-upstream-to</kbd>  or <kbd>-u</kbd> as a flag to the <kbd>git branch</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch --set-upstream-to origin/stable-3.2</strong> 
<strong>Branch remoteBugFix2 set up to track remote branch stable-3.2 from origin.</strong> </pre>
<ol start="3">
<li>As you can see from the Git output, we are now tracking the <kbd>stable-3.2</kbd> branch from the origin:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong> 
<strong>On branch remoteBugFix2</strong> 
<strong>Your branch is behind 'origin/stable-3.2' by 9 commits, and can be fast-forwarded.</strong> 
<strong>  (use "git pull" to update your local branch)</strong> <br/><strong>nothing to commit, working directory clean</strong> </pre>
<ol start="4">
<li>You can see from the Git output that you are nine commits ahead, and you can use <kbd>git pull</kbd> to update the branch. Remember that a <kbd>git pull</kbd> command is just a <kbd>git fetch</kbd> command, followed by a <kbd>git merge</kbd> command with the upstream branch, which we also call the remote tracking branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git pull</strong> 

<strong>Updating 2e0d17885..f839d383e</strong><br/><strong>Fast-forward</strong><br/><strong> org.eclipse.jgit.test/tst/org/eclipse/jgit/api/RebaseCommandTest.java | 213 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++----------------</strong><br/><strong> org.eclipse.jgit/src/org/eclipse/jgit/api/RebaseCommand.java | 31 ++++++++------</strong><br/><strong> org.eclipse.jgit/src/org/eclipse/jgit/errors/IllegalTodoFileModification.java | 59 +++++++++++++++++++++++++++</strong><br/><strong> org.eclipse.jgit/src/org/eclipse/jgit/lib/BaseRepositoryBuilder.java | 2 +-</strong><br/><strong> org.eclipse.jgit/src/org/eclipse/jgit/lib/Config.java | 2 +</strong><br/><strong> org.eclipse.jgit/src/org/eclipse/jgit/lib/RebaseTodoLine.java | 16 ++++----</strong><br/><strong> 6 files changed, 266 insertions(+), 57 deletions(-)</strong><br/><strong> create mode 100644 org.eclipse.jgit/src/org/eclipse/jgit/errors/IllegalTodoFileModification.java</strong></pre>
<ol start="5">
<li>From the output, you can see that the branch has been fast forwarded to the <kbd>f839d383e</kbd> commit hash, which is equivalent to <kbd>origin/stable-3.2</kbd>. You can verify this with <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1 origin/stable-3.2  --format=format:%h</strong> 
<strong>f839d383e</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Forcing a merge commit</h1>
                
            
            
                
<p>You might have seen a lot of basic examples of software delivery chains and branching models before reading this book. It is very likely that you have been trying to use different strategies and found that none of them completely support your scenario, which is perfectly fine as long as the tool can support your specific workflow.</p>
<p>Git supports almost any workflow. We have often encountered a situation that requires a merge commit while merging a feature, even though it can be done with a fast-forward merge. Those who requested it often use it to indicate that you have actually merged in a feature and want to store the information in the repository.</p>
<p>Git has fast and easy access to all the commit messages, so the repository should be used as a journal, and not just a backup of the source code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Start by checking out a local branch <kbd>remoteOldbugFix</kbd> that tracks <kbd>origin/stable-3.1</kbd>:</p>
<pre><strong>$ git checkout -b remoteOldBugFix --track origin/stable-3.1</strong> 
<strong>Branch remoteOldBugFix set up to track remote branch stable-3.1 from Switched to a new branch 'remoteOldBugFix'</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following steps will show you how to force a merge commit:</p>
<ol>
<li>To force a merge commit, you need to use the <kbd>--no-ff</kbd> flag; <em>no-ff</em> means no fast forward. We will also use the <kbd>--quiet</kbd> flag to minimize the output and <kbd>--edit</kbd> to allow us to edit the commit message. Unless you have a merge conflict, Git will create the merge commit for you automatically:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge origin/stable-3.2 --no-ff --edit --quiet</strong> 

<strong>Auto-merging </strong><strong>org.eclipse.jgit.test/tst/org/eclipse/jgit/test/resources/SampleDat</strong> 
<strong>Removing org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/GCTe</strong> 
<strong>Auto-merging org.eclipse.jgit.packaging/org.eclipse.jgit.target/jgit-4.3.target</strong> </pre>
<ol start="2">
<li>
<p>The commit message editor will open, and you can write a commit message. Closing the editor creates the merge commit and we are done.</p>
</li>
<li>
<p>To verify this, you can reset back to <kbd>origin/stable-3.1</kbd> and perform the merge without the <kbd>--no-ff</kbd> flag:</p>
</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard  remotes/origin/stable-3.1</strong> 
<strong>HEAD is now at da6e87b Prepare post 3.1.0 builds</strong> </pre>
<ol start="4">
<li>Now, perform the merge with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge origin/stable-3.2 --quiet</strong></pre>
<ol start="5">
<li>You can see the difference using Gitk. The following screenshot shows the fast- forward merge; as you can see, our <kbd>remoteOldBugFix</kbd> branch points to <kbd>origin/stable-3.2</kbd>:</li>
</ol>
<div><img src="img/89096683-4d34-4b7c-83f8-f2a6c4d6ca81.png" style="width:31.92em;height:19.42em;"/></div>
<ol start="6">
<li>The next screenshot shows the merge commit we forced Git to create. Our branch <kbd>remoteOldBugFix</kbd> is ahead of <kbd>remotes/origin/stable-3.2</kbd>, and then we performed the commit:</li>
</ol>
<div><img src="img/58b2d86a-c920-4e9e-ba1e-4c28cf78ec48.png" style="width:29.33em;height:19.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Although most branching scenarios expect you to completely merge branches, there are situations when, while working in a real environment, you only need to merge specific pieces of one branch into another branch. Using the <kbd>--no-commit</kbd> option, Git will make the merge and stop before committing, allowing you to modify and add files to the merge commit before committing.</p>
<p>For example, we have been working with projects where versions of strings have been updated in the feature branch but not in the master branch. So, an automatic merge into master would replace the current version string used on the master branch, which, in this case, was not the intention. In the following example, we will use a simple Git repository with a few commits and files:</p>
<ol>
<li>Start by checking out a local <kbd>remotePartlyMerge</kbd> branch that tracks <kbd>origin/release/1.0</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model.git<br/>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition_hello_world_flow_model<br/></strong><strong>$ git checkout -b remotePartlyMerge --track origin/release/1.0<br/></strong><strong>Branch remotePartlyMerge set up to track remote branch release/1.0 from origin.</strong> <br/><strong>Switched to a new branch 'remotePartlyMerge'</strong></pre>
<ol start="2">
<li>Then, to create the merge and allow you to decide what will be part of the commit, you can use <kbd>--no-commit</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge origin/master  --no-ff --no-commit</strong> 
<strong>  Automatic merge went well; stopped before committing as requested</strong> </pre>
<ol start="3">
<li>Again, Git is very informative; you can see from the output that everything went well and Git stopped before committing as requested. To continue, let's pretend we didn't want the <kbd>LICENSE</kbd> file to be part of the merge commit.<br/> To achieve this, we reset the directory using the <kbd>git reset &lt;path&gt;</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset LICENSE</strong></pre>
<ol start="4">
<li>You can see from the output that you have unstaged changes after the reset; this is exactly what we want. You can check which unstaged changes you have by running <kbd>git status</kbd>. Now, we will just finish the merge:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit -m "Merging without LICENSE"</strong> 
<strong>[remotePartlyMerge f138175] Merging without LICENSE<br/></strong></pre>
<ol start="5">
<li>The merge commit is complete. If you run a <kbd>git status</kbd> command now, you will still have the unstaged changes in you work area. To verify whether the result is as expected, we can compute the difference for this using <kbd>git diff</kbd> to show that the files are as they are on the <kbd>origin/master</kbd> branch, excluding the <kbd>LICENSE</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git diff origin/master !(LICENSE)</strong></pre>
<ol start="6">
<li>There is no output from diff; this is the expected result. We are telling the <kbd>diff</kbd> command to <kbd>diff</kbd> our current <kbd>HEAD</kbd> commit and branch <kbd>origin/master</kbd>, and we do not care about the diffs in <kbd>LICENSE</kbd></li>
</ol>
<p>If you don't specify <kbd>HEAD</kbd>, you will <kbd>diff</kbd> with your current <kbd>WA</kbd>, and the <kbd>diff</kbd> command will have a lot of output as you have unstaged changes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using git reuse recorded resolution (rerere) to merge Git conflicts</h1>
                
            
            
                
<p>While working on a feature branch, you probably like to merge daily or perhaps more often, but when you work on long-living feature branches, you end up in a situation where you have the same conflicts occurring repeatedly.</p>
<p>Here, you can use <kbd>git rerere</kbd>, which stands for <em>reuse recorded resolution</em>. Git rerere is not enabled by default, but can be enabled with the following command:</p>
<pre><strong>$ git config rerere.enabled true</strong></pre>
<p>You can configure it globally by adding <kbd>--global</kbd> to the <kbd>git config</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Perform the following steps to merge the known conflicts:</p>
<ol>
<li>In the <kbd>jgit</kbd> repository folder, start by checking out a branch that tracks <kbd>origin/stable-2.2</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b rerereExample --track origin/stable-2.2</strong> </pre>
<ol start="2">
<li>Now, change the maven-compiler-plugin version to something personalized, such as 2.5.2, as this is in line 211 in <kbd>pom.xml</kbd>. If you run <kbd>git diff</kbd>, you should get a result very similar to the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git diff</strong> 

<strong>diff --git a/pom.xml b/pom.xml</strong> 
<strong>index 085e00f..d5aec17 100644</strong> 
<strong>--- a/pom.xml</strong> 
<strong>+++ b/pom.xml</strong> 
<strong>@@ -208,7 +208,7 @@</strong> <br/><strong>         &lt;plugin&gt;</strong> 
<strong>           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</strong> 
<strong>-          &lt;version&gt;2.5.1&lt;/version&gt;</strong> 
<strong>+          &lt;version&gt;2.5.2&lt;/version&gt;</strong> 
<strong>         &lt;/plugin&gt;</strong>  
<br/><strong>         &lt;plugin&gt; </strong> </pre>
<ol start="3">
<li>Now add the file and create a commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add pom.xml</strong> 
<strong>$ git commit -m "Update maven-compiler-plugin to 2.5.2"</strong> 
<strong>[rerereExample d474848] Update maven-compiler-plugin to 2.5.2</strong> 
<strong> 1 file changed, 1 insertion(+), 1 deletion(-)</strong> </pre>
<ol start="4">
<li>Store your current commit in a backup branch named <kbd>rerereExample2</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch rerereExample2</strong> </pre>
<p style="padding-left: 60px">Here, <kbd>git branch rerereExample2</kbd> is just storing the current commit as a branch, as we need to use that for the second rerere example.</p>
<ol start="5">
<li>Now, we need to perform the first merge that will fail on auto merge. Then we can solve that. After solving it, we can reuse the merge resolution to solve the same problem in the future:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge --no-ff v3.0.2.201309041250-rc2</strong> 

<strong>A lot of output ...</strong> 

<strong>Automatic merge failed; fix conflicts and then commit the result.</strong> </pre>
<ol start="6">
<li>As we have <kbd>git rerere</kbd> enabled, we can use <kbd>git rerere status</kbd> to see which files or paths will be recorded:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rerere status</strong> 
<strong>pom.xml</strong> </pre>
<ol start="7">
<li>Edit the <kbd>pom.xml</kbd> file (around line 229) and solve the merge conflict so that you can get the <kbd>diff</kbd> output shown as follows. You have to remove the line with 3.1 and the merge markers:</li>
</ol>
<p>Merge markers are lines that begin with <kbd>&lt;&lt;&lt;&lt;&lt;&lt;</kbd>, <kbd>&gt;&gt;&gt;&gt;&gt;&gt;</kbd>, or <kbd>======</kbd>; these lines indicate the points where Git could not perform an auto merge.</p>
<pre style="padding-left: 60px"><strong>$ git diff v3.0.2.201309041250-rc2 pom.xml</strong> 

<strong>diff --git a/pom.xml b/pom.xml</strong> 
<strong>index 60cb0c8..faa7618 100644</strong> 
<strong>--- a/pom.xml</strong> 
<strong>+++ b/pom.xml</strong> 
<strong>@@ -226,7 +226,7 @@</strong> 
<br/><strong>      &lt;plugin&gt;</strong> 
<strong>           &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</strong> 
<strong>-          &lt;version&gt;3.1&lt;/version&gt;</strong> 
<strong>+          &lt;version&gt;2.5.2&lt;/version&gt;</strong> 
<strong>         &lt;/plugin&gt;</strong> 
<br/><strong>         &lt;plugin&gt;</strong></pre>
<ol start="8">
<li> Mark the merge as complete by adding <kbd>pom.xml</kbd> to the staging area using <kbd>git add</kbd> and then run <kbd>git commit</kbd> to finish the merge:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit</strong> 
<strong>Recorded resolution for 'pom.xml'.</strong> 
<strong>[rerereExample 9b8725f] Merge tag 'v3.0.2.201309041250-rc2' into rerereExample</strong> </pre>
<ol start="9">
<li>Note the recorded resolution for the <kbd>pom.xml</kbd> output from Git; this will not be here without enabling <kbd>git rerere</kbd>. Git has recorded this resolution to this particular merge conflict and will also record how to resolve this. Now, we can try to <kbd>rebase</kbd> the change to another branch.</li>
<li>Start by checking out the <kbd>rerereExample2</kbd> branch from our repository:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout rerereExample2</strong> 

<strong>Switched to branch 'rerereExample2'</strong> </pre>
<ol start="11">
<li>Try to rebase your change on top of the <kbd>origin/stable-3.2</kbd> branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase origin/stable-3.2</strong> 
<strong>First, rewinding head to replay your work on top of it...</strong><br/><strong>Applying: Update maven-compiler-plugin to 2.5.2</strong><br/><strong>Using index info to reconstruct a base tree...</strong><br/><strong>M pom.xml</strong><br/><strong>Falling back to patching base and 3-way merge...</strong><br/><strong>Auto-merging pom.xml</strong><br/><strong>CONFLICT (content): Merge conflict in pom.xml</strong><br/><strong>Resolved 'pom.xml' using previous resolution.</strong><br/><strong>error: Failed to merge in the changes.</strong><br/><strong>Patch failed at 0001 Update maven-compiler-plugin to 2.5.2</strong><br/><strong>The copy of the patch that failed is found in: .git/rebase-apply/patch</strong><br/><br/><strong>Resolve all conflicts manually, mark them as resolved with</strong><br/><strong>"git add/rm &lt;conflicted_files&gt;", then run "git rebase --continue".</strong><br/><strong>You can instead skip this commit: run "git rebase --skip".</strong><br/><strong>To abort and get back to the state before "git rebase", run "git rebase --abort".</strong></pre>
<ol start="12">
<li>You should notice the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>CONFLICT (content): Merge conflict in pom.xml</strong> 
<strong>Resolved 'pom.xml' using previous resolution</strong></pre>
<ol start="13">
<li>As the merge conflict is the same in <kbd>pom.xml</kbd>, Git can solve the conflict in the file for you. This is very clear when you open the file and see there are no merge markers, as the resolution Git had recorded has been applied. Finish the merge by adding <kbd>pom.xml</kbd> and continue the <kbd>rebase</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add pom.xml </strong> 
<strong>$ git rebase --continue</strong> 
<strong>Applying: Update maven-compiler-plugin to 2.5.2</strong> </pre>
<ol start="14">
<li>Start Gitk to see that the commit has been rebased on top of the <kbd>origin/stable-3.2</kbd> branch:</li>
</ol>
<div><img src="img/910cc116-cd54-4833-b72a-488fa62440c4.png" style="width:30.83em;height:20.33em;"/></div>
<p>You can try the same scenario with merging and it will merge the file automatically for you.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>When you merge different branches often and you are not sure which branch a specific error fix is a part of, it is actually quite easy to find out:</p>
<ol>
<li>You need to find a commit for which you are interested in getting this information. Then, use the <kbd>--contains</kbd> flag for the <kbd>git branch</kbd> command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch --contains 699900c308</strong> 

<strong>  anotherBugFix</strong> 
<strong>  lastBugFix</strong> 
<strong>  master</strong> 
<strong>  newBugFix</strong> 
<strong>  remoteBugFix</strong> 
<strong>  remoteBugFix2</strong> 
<strong>  remoteOldbugFix</strong> 
<strong>* rerereExample2</strong> </pre>
<ol start="2">
<li>The previous command lists all the branches that have the specific commit. If you leave out the commit argument (<kbd>8e2886897</kbd>), Git will check <kbd>HEAD</kbd>. So, for instance, checking out the <kbd>rerereExample2</kbd> branch and executing the following command, you will see the commit is present only on that branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout rerereExample2</strong> 
<strong>Switched to branch 'rerereExample2'</strong> 

<strong>$ git branch -a --contains</strong> 
<strong>* rerereExample2</strong> </pre>
<p>The <kbd>-a</kbd> option indicates that you wish to check all the remote branches as well. If you leave this out, it will check only local branches.</p>
<p style="padding-left: 60px">However, as you can see, our commit is not on any remote branch, as the commit has just been created locally and has not been pushed to any remotes yet.</p>
<p>You can use tags, branch names, or commit hashes while using the git branch <kbd>-a --contains</kbd> command.</p>
<ol start="3">
<li>Let's try to see the branches where the <kbd>v2.3.0.201302130906</kbd> tag is present:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ </strong><strong>git branch -a --contains v2.3.0.201302130906</strong> 

<strong>  anotherBugFix</strong> 
<strong>  lastBugFix</strong> 
<strong>  master</strong> 
<strong>  newBugFix</strong> 
<strong>  remoteBugFix</strong> 
<strong>  remoteBugFix2</strong> 
<strong>  remoteOldbugFix</strong> 
<strong>  remotePartlyMerge</strong> 
<strong>* rerereExample2</strong> 
<strong>  remotes/origin/HEAD -&gt; origin/master</strong> 
<strong>  remotes/origin/master</strong> 
<strong>  remotes/origin/stable-2.3</strong> 
<strong>  remotes/origin/stable-3.0</strong> 
<strong>  remotes/origin/stable-3.1</strong> 
<strong>  remotes/origin/stable-3.2</strong> <br/><br/><strong>... and many more</strong></pre>
<p style="padding-left: 60px">That tag can be found in quite a lot of branches.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compute the difference between branches</h1>
                
            
            
                
<p>Checking the difference between branches can show valuable information before merging.</p>
<p>A regular <kbd>git diff</kbd> between two branches will show you all the information, but it can be rather exhausting to sit and look at; maybe you are only interested in one file. Thus, you don't need the long unified diff.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To start with, we decide on two branches, tags, or commits we want to see the difference between. Then, to list files that have changed between these branches, you can use the <kbd>--name-only</kbd> flag.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Perform the following steps to see the difference between the branches:</p>
<ol>
<li>Diff <kbd>origin/stable-3.1</kbd> with the <kbd>origin/stable-3.2</kbd> branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git diff --name-only origin/stable-3.1 origin/stable-3.2 org.eclipse.jgit/src/org/eclipse/jgit/transport/org.eclipse.jgit/src/org/eclipse/jgit/transport/BasePackFetch</strong> 

<strong>More output..</strong> </pre>
<ol start="2">
<li>We are building the command in this pattern, that is, <kbd>git diff [options] &lt;commit&gt; &lt;commit&gt; &lt;path&gt;</kbd>. Then, we can diff what we care about while looking into the differences between branches. This is very useful if you are responsible for a subset of the source code, and you wish to diff that area only.</li>
</ol>
<p> </p>
<ol start="3">
<li>Let's try the same diff between branches, but this time we will diff the entire branches, not just a sub-directory; however, we only want to show the deleted or added files between the branches. This is done by using the <kbd>--diff-filter=DA</kbd> and <kbd>--name-status</kbd> options. The <kbd>--name-status</kbd> option will only show the filenames and the type of change. The <kbd>--diff-filter=DA</kbd> option will only show the deleted and added files:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git diff --name-status --diff-filter=DA origin/stable-3.1 origin/stable-3.2</strong> 
<br/><strong>A org.eclipse.jgit.packaging/org.eclipse.jgit.target/jgit-4.4.target</strong><br/><strong>A org.eclipse.jgit.pgm.test/tst/org/eclipse/jgit/pgm/DescribeTest.java</strong><br/><strong>A org.eclipse.jgit.pgm.test/tst/org/eclipse/jgit/pgm/FetchTest.java</strong><br/><strong>A org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/Describe.java</strong><br/><strong>A org.eclipse.jgit.test/tst/org/eclipse/jgit/api/DescribeCommandTest.java</strong><br/><strong>A org.eclipse.jgit.test/tst/org/eclipse/jgit/api/Sets.java</strong><br/><strong>D org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/GCTest.java</strong>
<br/><strong> More output..</strong> </pre>
<ol start="4">
<li>This shows the files that have been added and deleted while moving from <kbd>origin/stable-3.1</kbd> to <kbd>origin/stable-3.2</kbd>.</li>
<li>If we switch the branches around, as in the following command, we will get the opposite result:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git diff --name-status --diff-filter=DA origin/stable-3.2 origin/stable-3.1</strong> 

<strong>D org.eclipse.jgit.packaging/org.eclipse.jgit.target/jgit-4.4.target</strong><br/><strong>D org.eclipse.jgit.pgm.test/tst/org/eclipse/jgit/pgm/DescribeTest.java</strong><br/><strong>D org.eclipse.jgit.pgm.test/tst/org/eclipse/jgit/pgm/FetchTest.java</strong><br/><strong>D org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/Describe.java</strong><br/><strong>D org.eclipse.jgit.test/tst/org/eclipse/jgit/api/DescribeCommandTest.java</strong><br/><strong>D org.eclipse.jgit.test/tst/org/eclipse/jgit/api/Sets.java</strong><br/><strong>A org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/GCTest.java</strong>

<strong> More output..</strong> </pre>
<p>Note that the indication letters A and D switched places because now we want to know what happens if we move from <kbd>origin/stable-3.2</kbd> to <kbd>origin/stable-3.1</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Orphan branches</h1>
                
            
            
                
<p>You are now familiar with Git's data model, the DAG. You have seen that objects have a parent. When you create a new branch, the commit is its parent. However, in some situations, it is useful to have a branch with no parent.</p>
<p>One example would be an instance where you have your code base in two separate repositories, but, for some reason, you now want to consolidate it into one. One way is to simply copy the files and add them to one of the repositories, but the disadvantage is that you will lose the histories. The second way is to use an orphan branch that can help you to fetch one repository in another.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>It is actually easy to create an orphan branch. The flag <kbd>--orphan</kbd> to <kbd>checkout</kbd> will do it. It can be executed as follows:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition.git</strong><br/><strong>$ cd Git-Version-Control-Cookbook-Second-Edition<br/></strong><strong>$ git checkout --orphan fresh-start</strong><br/><strong>Switched to a new branch 'fresh-start'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>We now have a branch with no parent. You can verify it by examining the commit log as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log</strong><br/><strong>fatal: your current branch 'fresh-start' does not have any commits yet</strong></pre>
<p style="padding-left: 60px"><kbd>Fresh start</kbd> does not mean that you are starting from scratch. The files and directories that have been added to the repository still exist:</p>
<pre style="padding-left: 60px"><strong>$ ls</strong><br/><strong>README.md a_sub_directory another-file.txt cat-me.txt hello_world.c</strong><br/><strong>$ git status</strong><br/><strong>On branch fresh-start</strong><br/><br/><strong>No commits yet</strong><br/><br/><strong>Changes to be committed:</strong><br/><strong> (use "git rm --cached &lt;file&gt;..." to unstage)</strong><br/><br/><strong> new file: README.md</strong><br/><strong> new file: a_sub_directory/readme</strong><br/><strong> new file: another-file.txt</strong><br/><strong> new file: cat-me.txt</strong><br/><strong> new file: hello_world.c</strong></pre>
<ol start="2">
<li>If you need a fresh start, you can delete the files (but remember not to delete <kbd>.git</kbd>) as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rm --cached README.md a_sub_directory/readme another-file.txt cat-me.txt hello_world.c</strong><br/><strong>$ rm -rf README.md a_sub_directory another-file.txt cat-me.txt hello_world.c</strong><br/><strong>$ git status</strong><br/><strong>On branch fresh-start</strong><br/><br/><strong>No commits yet</strong><br/><br/><strong>nothing to commit (create/copy files and use "git add" to track)</strong></pre>
<ol start="3">
<li>You have a branch with no files and no commits. Moreover, the branch does not share any commit history with your <kbd>master</kbd> branch. You could add another repository and fetch all its commits using <kbd>git remote add</kbd> and <kbd>git fetch</kbd>. Instead, we will simply add a text file to illustrate it as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "This is from an orphan branch." &gt; orphan.txt</strong><br/><strong>$ git add orphan.txt</strong><br/><strong>$ git commit  -m "Orphan"</strong></pre>
<p style="padding-left: 60px">Commit is the only thing in the history that you can verify with the command <kbd>git log</kbd>. If you fetch another repository into the branch, you will see all the commits and, more importantly you will have a copy of the repository's history. </p>
<ol start="4">
<li>Once you have your commits in place on the orphan branch, it is time to merge them into your master branch. However, your first attempt will fail. For example, check the following:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout master</strong><br/><strong>$ git merge fresh-start</strong><br/><strong>fatal: refusing to merge unrelated histories</strong></pre>
<ol start="5">
<li>As you can see, the orphan branch does not share history with the master branch, and git will not allow you to merge the branch. It shouldn't come as a surprise, since it is basically what an orphan branch is all about. However, you can still merge an orphan branch by allowing unrelated histories to be merged:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git merge fresh-start --allow-unrelated-histories</strong><br/><strong>$ git log -3</strong><br/><strong>commit aa804347c728552f7ce9298a83ab646148078dab (HEAD -&gt; master)</strong><br/><strong>Merge: 13dcada 45d1798</strong><br/><strong>Author: John Doe &lt;john.doe@example.com&gt;</strong><br/><strong>Date: Fri May 11 08:57:45 2018 +0200</strong><br/><br/><strong>Merge branch 'fresh-start'</strong><br/><br/><strong>commit 45d179838f8f9f8fd64c6c7bf96147e09ceadbc2 (fresh-start)</strong><br/><strong>Author: John Doe &lt;john.doe@example.com&gt;</strong><br/><strong>Date: Fri May 11 08:57:22 2018 +0200</strong><br/><br/><strong>Orphan</strong><br/><br/><strong>commit 13dcada077e446d3a05ea9cdbc8ecc261a94e42d (origin/master, origin/HEAD)</strong><br/><strong>Author: John Doe &lt;john.doe@example.com&gt;</strong><br/><strong>Date: Fri Dec 13 12:26:00 2013 +0100</strong><br/><br/><strong>This is the subject line of the commit message</strong><br/><br/><strong>... and more output</strong></pre>
<p>It is unlikely that you will use orphan branches on a daily basis, but it is a strong feature to know when you need to reorganize your code base.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are more options in the help files for Git. Just run <kbd>git merge --help</kbd> or <kbd>git branch --help</kbd> to see what other options are available. </p>


            

            
        
    </body></html>