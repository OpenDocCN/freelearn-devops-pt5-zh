<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Tracking Application Changes and the ROI of Applying DevOps to Salesforce</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will discuss how we can track application changes using open source technologies, such as the Git source control versioning system. We will learn the basics of Bugzilla and how to track issues when they are reported by a tester or user until the fix for the issue/feature is deployed to production.</p>
<p>We will also see how to add some post-build steps in Jenkins to report the build status to Git. This will allow developers to get information about the build status related to every commit. We will discuss how DevOps helps any Salesforce organization to deliver applications faster and what the ROI is from applying DevOps to Salesforce.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to track application changes</h1>
                </header>
            
            <article>
                
<p>Tracking application changes without a version control system is like finding a needle in a haystack. We have seen how to use GitLab to track application changes in <a href="45e26817-986f-4fa4-a9c3-3044e7aad5da.xhtml">Chapter 5</a>, <em>Version Control</em>. Whenever bugs are reported by testers, we use a bug tracker such as Bugzilla to track the life cycle of a bug—from identifying it until the fix is released to production. When a new bug or feature is added to the bug tracker, it is assigned to a developer and the developer starts working on that fix or new feature. Code changes are tracked in Git repositories when developers commit changes to the respective feature branch. The <span class="packt_screen">develop</span> branch commit message should contain the bug ID to identify the changes done with respect to a particular bug or feature.</p>
<p class="mce-root"/>
<p>If a new feature is added or an issue is fixed, developers can add meaningful commit messages to help us track changes for a new functionality. When we want to merge changes to develop a branch or perform cherry-picks on commits, this becomes easy with meaningful commit messages with a bug ID.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Bugzilla</h1>
                </header>
            
            <article>
                
<p>Bugzilla bug tracking is an open source bug tracking system. Using Bugzilla, you can create a bug and track that bug until it is closed. Bugzilla provides project management and issue tracking features. Bugzilla is used to improve performance and scalability. Other features include an advanced query application that can remember your searches and integrated email capabilities.</p>
<p>First, you have to install Bugzilla on your system or server, from where you can access Bugzilla using a web browser. The steps are as follows:</p>
<ol>
<li>You can install Bugzilla on a machine from <a href="https://www.bugzilla.org/docs/4.4/en/html/installation.html">https://www.bugzilla.org/docs/4.4/en/html/installation.html</a>.</li>
<li>Now open Bugzilla through your browser; the screen looks like the following:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/714acd78-4701-4398-94e3-1cc4b47011d3.png"/></div>
<p class="mce-root"/>
<ol start="3">
<li>Click on <span class="packt_screen">Log In</span> and enter the credentials. Once you have logged in, the page will look like this:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/fe2d1663-d574-4c3b-8251-5914d2c4fe6e.png"/></div>
<ol start="4">
<li>Now click on <span class="packt_screen">User Preferences</span> or on <span class="packt_screen">Administration</span> to open the admin panel.</li>
<li>Once the admin panel is opened, click on <span class="packt_screen">Users</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/0a10bfaf-fdc3-4a4e-8eb1-62916ad234ff.png"/></div>
<ol start="6">
<li>In the next screen, click on <span class="packt_screen">add a new user</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/997db10b-5567-4c84-9736-73d80b05462a.png"/></div>
<ol start="7">
<li>Enter the <span class="packt_screen">Login name</span>, <span class="packt_screen">Password</span>, and <span class="packt_screen">Real name</span>. Finally, click on <span class="packt_screen">Add</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/f9ac0f66-a604-4bb1-9ffb-45406757017c.png"/></div>
<ol start="8">
<li>Select the relevant accesses and click on <span class="packt_screen">Save Changes</span>:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/4e25fa31-fccd-40fe-9d2c-9c3e05bbc332.png"/></div>
<p class="mce-root"/>
<ol start="9">
<li>Now click on <span class="packt_screen">File a Bug</span> on the home page:</li>
</ol>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/9a6dd36e-a57b-4d82-b9c3-4b71b0901874.png"/></div>
<ul>
<li style="list-style-type: none">In the following screen, you can see the multiple fields:
<ul>
<li><span class="packt_screen">Product: Git Demo Project</span></li>
<li><span class="packt_screen">Reporter: ngornalli</span></li>
<li><span class="packt_screen">Component: Git Project Model</span></li>
<li><span class="packt_screen">Component Description</span>: <span class="packt_screen">This component is created for Git Demo Project</span></li>
<li><span class="packt_screen">Version: 1.0</span></li>
<li><span class="packt_screen">Severity: High</span></li>
<li><span class="packt_screen">Hardware: Other</span></li>
<li><span class="packt_screen">OS: Windows</span></li>
<li><span class="packt_screen">Org*: Transformer</span></li>
<li><span class="packt_screen">Type of the Ticket*: Defect</span></li>
<li><span class="packt_screen">Raised By: QA</span></li>
<li><span class="packt_screen">Steps to Reproduce Issue*:</span> <span class="packt_screen">Steps to reproduce issue</span></li>
<li><span class="packt_screen">Expected Result*: Expected Result</span></li>
<li><span class="packt_screen">Summary: New Defect added for Git Demo Project</span></li>
<li><span class="packt_screen">Description: Description</span></li>
<li><span class="packt_screen">Attachment:</span> If there is any screenshot then attach it here</li>
</ul>
</li>
</ul>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/1072a174-e5b6-4c14-b540-6a462ff5b625.png"/></div>
<ol start="10">
<li>Finally, click on <span class="packt_screen">Submit Bug</span>.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Publishing a build report to Git</h1>
                </header>
            
            <article>
                
<p>As we have seen in <a href="c18c24e5-b3e1-467c-8e33-cc278016e0a6.xhtml" target="_blank">Chapter 6</a>, <em>Continuous Integration</em>, we can trigger a Jenkins job as code is pushed to Jenkins using a Git Webhook. Jenkins will start the build using the Ant Migration Tool and deploy metadata to the sandbox. However, whether the build failed or is successful is not shown anywhere. So we need to change the Jenkins job to deploy changes from Git to the sandbox. Go to the Jenkins job that you want to change and click on <span class="packt_screen">Configure</span>.</p>
<p>Add the post-build <span class="packt_screen">Git Publisher</span> step to set the build status to Git commit:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/c4cf87bf-886d-4d77-8807-57a17ff24305.png" style="width:28.50em;height:22.67em;"/></div>
<p>In GitLab, you can view the status of the Jenkins job to check whether is successful or it failed. We can track each commit in Git and see if the deployment to the sandbox step build has passed. If we configure the Jenkins job to run automation test cases after deployment is done in testing the sandbox, we can get the status of the execution of automation test cases in Git:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/569e4ab4-2309-44e3-b00c-b58e6c1c8739.png"/></div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How DevOps helps organizations deliver quickly</h1>
                </header>
            
            <article>
                
<p>Version control helps us track issues and revert changes. Differentiating between branches becomes easy with GitLab. If something goes wrong, finding a bug or issue is easy as we have all the changes tracked in Git repositories. Also, with Jenkins being able to retrieve metadata from the sandbox and store it in Git, it is very useful while taking backups. We don't need to do the same task again. We can configure a Jenkins job to take a backup of metadata components in Git and send a notification email to the respective admins.</p>
<p class="mce-root"/>
<p>The Jenkins continuous integration server helps us to deploy changes from a developer's machine to the sandbox or from one sandbox to another sandbox. We can configure Jenkins jobs to deploy changes as soon as they are pushed to Git using Jenkins Webhooks. Deployment of metadata from a developer sandbox to UAT sandboxes can be automated and your Salesforce credentials are safely stored in Jenkins Credentials in secret text, which will be only used during execution of a Jenkins job.</p>
<p>Code coverage is important for improving the quality of code written by developers. We can make sure that standard practices are being followed while developing an application. Making use of Jenkins to execute Apex tests in the deployment of metadata to the sandbox is an easy way to ensure we have 75% code coverage as per the Salesforce criteria.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Enhanced productivity</h1>
                </header>
            
            <article>
                
<p>When we have most deployments automated using the Jenkins continuous integration server and all the changes being made are tracked in a source control versioning system such as Git, developers can spend more time on actual development tasks. As we have seen in <a href="95062e49-8aff-4b6f-a02d-d81ca0f7cc41.xhtml">Chapter 7</a>, <em>Continuous Testing</em>, with the help of automation testing, we can cover the testing cycle faster and fulfill code coverage criteria in Salesforce. Selenium makes it easy to automate test cases. Finding bugs in an early phase of the software development cycle is very important in order to make sure software is bug-free and application deliverables are deployed to production faster.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to measure ROI?</h1>
                </header>
            
            <article>
                
<p>Applying DevOps methodologies to Salesforce using open source tools, such as GitLab, Jenkins, Selenium, and so on, helps organizations set up their automation process at minimal cost and with minimal efforts (in doing a one-time setup and configuration).</p>
<p>ROI cannot be measured as a number, but the ROI from applying DevOps can be measured as of the time we save in the deployment of Salesforce and the rework we do whenever developers accidentally overwrite each others' changes. Identifying issues faster with automation testing in the early stages of software development makes it easy to fix issues. Fixing defects in production costs us more time than fixing bugs early in a test or pre-production environment. Having a bug in production will have a business impact on our application.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The reduced time in the maintenance window when we are deploying changes to production and the reduced number of issues in production help us to measure the ROI from applying DevOps to our Salesforce organization. The release cycle can be reduced from weeks to days with automated test cases using Jenkins continuous integration.</p>
<p>By applying DevOps practices to a Salesforce application, we can achieve customer satisfaction and speed up the product delivery process. Developers need to work less hard at maintaining an application, focusing more on developing new features.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we learned about tracking application changes, Bugzilla, enhancing productivity, and measuring ROI.</p>
<p>We started this book with very basic or no knowledge of DevOps practices or tools used in DevOps. We learned some basics about Salesforce by creating a sample application in Salesforce and discussed the different sandbox environments. Using Eclipse with Salesforce, we can integrate Git with a sandbox to achieve a source control version system. We learned about different deployment methods used in Salesforce, and we automated Salesforce deployments using the Jenkins continuous integration server.</p>
<p>We learned about setting up our own GitLab server and pushing code changes from a Salesforce sandbox to a GitLab repository. Implementing continuous integration in a Salesforce environment with the Jenkins server helps us to speed up deployment to UAT or another sandbox.</p>
<p>We learned how to automate testing for a Salesforce application with Selenium. We discussed Selenium record and playback with a sample Salesforce application. Automation testing helped us reduce the testing cycle from days to hours. We saw how DevOps tools can be used in a Salesforce application. You can apply the concepts learned in this book to any Salesforce application. Throughout this book, we tried to provide you with good insights into DevOps tools and step-by-step instructions to set up your own DevOps process with open source tools. Most of the exercises in this book can be followed using a free Salesforce account.</p>


            </article>

            
        </section>
    </body></html>