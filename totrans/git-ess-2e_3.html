<html><head></head><body>
        

                            
                    <h1 class="header-title">Git Fundamentals - Working Remotely</h1>
                
            
            
                
<p>In the previous chapter, we learned a lot about Git; we learned how it works internally and how to manage a local repository, but now it's time to learn how to share our goodies.</p>
<p>In this chapter, we finally start to work in a distributed manner, using remote servers as a contact point for different developers. These are the main topics we will focus on:</p>
<ul>
<li>Dealing with remotes</li>
<li>Cloning a remote repository</li>
<li>Working with online hosting services, such as GitHub</li>
</ul>
<p>As we said before, Git is a distributed version control system: this chapter concerns the <em>distributed</em> part.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with remotes</h1>
                
            
            
                
<p>Git is a tool for versioning files, as you know, but it has been built with collaboration in mind. In 2005, Linus Torvalds had the need for a light and efficient tool to share the Linux kernel code, allowing him and hundreds of other people to work on it without going crazy; the pragmatism that guided its development gave us a very robust layer for sharing data among computers, without the need of a central server.</p>
<p>Basically, a Git <strong>remote</strong> is another "place" that has the same repository you have on your computer. As shown in the following image, you can think of it as different copies of the same repository that can exchange data between themselves:</p>
<div><img height="146" width="196" class=" image-border" src="img/e86549ee-2280-4e74-9f98-ee6f972e265f.png"/></div>
<p>So, a remote Git repository is just a remote copy of the same Git repository we created locally; if you have access to that remote via common protocols such as SSH, the custom <kbd>git://</kbd> protocol, or other protocols, you can keep in sync your modification with it.</p>
<p>Even another folder in your computer can act as a remote: for Git, the filesystem is a <em>communication protocol</em> like any other, and you are allowed to use it if you like.</p>
<p>This is what we will do to grasp the basic concepts about remotes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Clone a local repository</h1>
                
            
            
                
<p>Create a new folder on your disk to clone our <kbd>grocery</kbd> repository:</p>
<pre class="mce-root"><strong>[1] ~</strong>
<strong>$ mkdir grocery-cloned</strong></pre>
<p class="mce-root">Then clone the <kbd>grocery</kbd> repository using the git clone command:</p>
<pre class="mce-root"><br/><strong>[2] ~</strong> <strong>$ cd grocery-cloned</strong> <strong>[3] ~/grocery-cloned</strong> <strong>$ git clone ~/grocery .</strong> <strong>Cloning into '.'...</strong></pre>
<p class="mce-root">Done.</p>
<p>The dot <kbd>.</kbd> argument at the end of the command means <em>clone the repository in the current folder</em>, while the <kbd>~/grocery</kbd> argument is actually the path where Git has to look for the repository.</p>
<p>Now, go directly to the point with a <kbd>git log</kbd> command:</p>
<pre><strong>[4] ~/grocery-cloned (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 6409527 (HEAD -&gt; master, origin/master, origin/HEAD) Add a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (origin/melons) Add a watermelon</strong>
<strong>| * ef6c382 (origin/berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>As you can see, other than the green <kbd>master</kbd> branch label, we have some red <kbd>origin/&lt;branch&gt;</kbd> labels on our log output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The origin</h1>
                
            
            
                
<p>What is the <em>origin</em>?</p>
<p>Git uses origin as the default name of a remote. Like with <kbd>master</kbd> for branches, <kbd>origin</kbd> is just a convention: you can call remotes whatever you want.</p>
<p>The interesting thing to note here is that Git, thanks to the <kbd>--all</kbd> option in the <kbd>git log</kbd> command, shows us that there are some more branches in the remote repository, but as you can see, they do not appear in the locally cloned one. In the cloned repository, there is only <kbd>master</kbd>.</p>
<p>But don't worry: a local branch in which to work locally can be created by simply checking it out:</p>
<pre><strong>[5] ~/grocery-cloned (master)</strong>
<strong>$ git checkout berries</strong>
<strong>Branch berries set up to track remote branch berries from origin.</strong>
<strong>Switched to a new branch 'berries'</strong></pre>
<p>Look at the message, Git says that a <em>local branch has been set up to track the remote</em> one; this means that, from now on, Git will actively track differences between the local branch and the remote one, notifying you of differences while giving you output messages (for example, while using the <kbd>git status</kbd> command).</p>
<p>Having said that, if you do a commit in this branch, you can send it to the remote and it will be part of the remote <kbd>origin/berries</kbd>.</p>
<p>This seems obvious, but, in Git, you can pair branches as you want; for example, you can track a remote <kbd>origin/foo</kbd> branch by a local <kbd>bar</kbd> branch, if you like. Alternatively, you can have local branches that simply don't exist on the remote. Later, we will look at how to work with remote branches.</p>
<p>Now, look at the log again:</p>
<pre><strong>[6] ~/grocery-cloned (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* 6409527 (origin/master, origin/HEAD, master) Add a grape</strong>
<strong>* 603b9d1 Add a peach</strong>
<strong>| * a8c6219 (origin/melons) Add a watermelon</strong>
<strong>| * ef6c382 (HEAD -&gt; berries, origin/berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Now a green <kbd>berries</kbd> label appears, just near the red <kbd>origin/berries</kbd> one; this makes us aware that the local <kbd>berries</kbd> branch and remote <kbd>origin/berries</kbd> branch point to the same commit.</p>
<p>What happens if I do a new commit?</p>
<p>Let's try:</p>
<pre><strong>[7] ~/grocery-cloned (berries)</strong>
<strong>$ echo "blueberry" &gt;&gt; shoppingList.txt</strong>
  
<strong>[8] ~/grocery-cloned (berries)</strong>
<strong>$ git commit -am "Add a blueberry"</strong>
<strong>[berries ab9f231] Add a blueberry</strong>
<strong>Committer: Santacroce Ferdinando &lt;san@intre.it&gt;</strong></pre>
<p>Your name and email address were configured automatically based on your <em>username</em> and <em>hostname</em>. Please check that they are accurate.</p>
<p>You can suppress this message by setting them explicitly:</p>
<pre><strong>git config --global user.name "Your Name"</strong>
<strong>git config --global user.email you@example.com</strong></pre>
<p>After doing this, you may fix the identity used for this commit with the following code:</p>
<pre><strong>git commit --amend --reset-author</strong>
 
<strong>1 file changed, 1 insertion(+)</strong></pre>
<p>As in the previous chapter, Git warns me about author and email; this time I will go with the suggested ones.</p>
<p>OK, let's see what happened:</p>
<pre><strong>[9] ~/grocery-cloned (berries)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* ab9f231 (HEAD -&gt; berries) Add a blueberry</strong>
<strong>| * 6409527 (origin/master, origin/HEAD, master) Add a grape</strong>
<strong>| * 603b9d1 Add a peach</strong>
<strong>| | * a8c6219 (origin/melons) Add a watermelon</strong>
<strong>| |/</strong>
<strong>|/|</strong>
<strong>* | ef6c382 (origin/berries) Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Nice! The local <kbd>berries</kbd> branch moved forward, while <kbd>origin/berries</kbd> is still in the same place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sharing local commits with git push</h1>
                
            
            
                
<p>As you may already know, Git works locally; there's no need for a remote server.</p>
<p>So, when you do a commit, it is available only locally; if you want to share it with a remote counterpart, you have to send it in some manner.</p>
<p>In Git, this is called <strong>push</strong>.</p>
<p>Now, we will try to push the modifications in the <kbd>berries</kbd> branch to the <kbd>origin</kbd>; the command is <kbd>git push</kbd>, followed by the name of the remote and the target branch:</p>
<pre><strong>[10] ~/grocery-cloned (berries)</strong>
<strong>$ git push origin berries</strong>
<strong>Counting objects: 3, done.</strong>
<strong>Delta compression using up to 8 threads.</strong>
<strong>Compressing objects: 100% (2/2), done.</strong>
<strong>Writing objects: 100% (3/3), 323 bytes | 0 bytes/s, done.</strong>
<strong>Total 3 (delta 0), reused 0 (delta 0)</strong>
<strong>To C:/Users/san/Google Drive/Packt/PortableGit/home/grocery</strong>
<strong>   ef6c382..ab9f231  berries -&gt; berries</strong>
  </pre>
<p>Wow! There is a lot of things in this output message. Basically, Git informed us about the operations it does before and during the sending of commits to the remote.</p>
<p>Note that, as Git will send only the objects it knows are not present in the remote to the remote (three, in this case: a commit, a tree, and a blob), it will not send unreachable commits, nor other related unreachable objects (such as trees, blobs, or annotated that tighten only with unreachable commits).</p>
<p>Finally, Git tells us where it is sending objects, the destination, which in this case is just another folder on my computer: <kbd>To C:/Users/san/Google Drive/Packt/PortableGit/home/grocery</kbd>. It then tells the commit hash remote where the <kbd>origin/berries</kbd> originally was and the hash of the new tip commit, that is the same as the one in the local <kbd>berries</kbd> branch, <kbd>ef6c382..ab9f231</kbd>. Lastly, it gives the name of the two branches, the local and the remote branches, <kbd>berries -&gt; berries</kbd>.</p>
<p>Now, we obviously want to see if, in the remote repository, there is a new commit in the <kbd>berries</kbd> branch; so, open the <kbd>grocery</kbd> folder in a new console and do <kbd>git log</kbd>:</p>
<pre><strong>[11] ~</strong>
<strong>$ cd grocery</strong>

<strong>[12] ~/grocery (master)</strong>
<strong>$ git log --oneline --graph --decorate --all</strong>
<strong>* ab9f231 (berries) Add a blueberry</strong>
<strong>| * 6409527 (HEAD -&gt; master) Add a grape</strong>
<strong>| * 603b9d1 Add a peach</strong>
<strong>| | * a8c6219 (melons) Add a watermelon</strong>
<strong>| |/</strong>
<strong>|/|</strong>
<strong>* | ef6c382 Add a blackberry</strong>
<strong>|/</strong>
<strong>* 0e8b5cf Add an orange</strong>
<strong>* e4a5e7b Add an apple</strong>
<strong>* a57d783 Add a banana to the shopping list</strong></pre>
<p>Yes, wonderful!</p>
<p>Just a little warning: usually, a remote repository copy is managed as a <strong>bare repository</strong>; in <a href="406afcc0-b4a9-45b3-b238-a4d52873c9df.xhtml">Chapter 4</a>, <em>Git Fundamentals - Niche Concepts, Configurations, and Commands</em>, we will spend some words on it. As you normally won't work directly on it, a bare repository contains only the <kbd>.git</kbd> folder; it doesn't have a checked out working tree nor a HEAD reference. Instead, we use a normal repository as a remote. This is not a problem; you have just to remember one thing: you cannot push changes to the actual checked out remote branch.</p>
<p>In fact, in that <kbd>grocery</kbd> repository, we are actually on the <kbd>master</kbd> branch, and in the <kbd>grocery-cloned</kbd> repository, we push the <kbd>berries</kbd> branch.<br/>
The reason for this is quite simple to understand: by pushing to a remote checked out branch, you will affect the work in progress on that repository, maybe destroying ongoing changes, and this is not fair.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting remote commits with git pull</h1>
                
            
            
                
<p>Now, it's time to experiment the inverse: retrieving updates from the remote repository and applying them to our local copy.</p>
<p>So, make a new commit in the <kbd>grocery</kbd> repository, and then, we will download it into the <kbd>grocery-cloned</kbd> one:</p>
<pre><strong>[13] ~/grocery (master)</strong>
<strong>$ printf "\r\n" &gt;&gt; shoppingList.txt</strong></pre>
<p>I firstly need to create a new line, because due to the previous <em>grape rebase</em>, we ended having the <kbd>shoppinList.txt</kbd> file with no new line at the end, as <kbd>echo "" &gt;&gt; &lt;file&gt;</kbd> usually does:</p>
<pre><strong>[14] ~/grocery (master)</strong>
<strong>$ echo "apricot" &gt;&gt; shoppingList.txt</strong>

<strong>[15] ~/grocery (master)</strong>
<strong>$ git commit -am "Add an apricot"</strong>
<strong>[master 741ed56] Add an apricot</strong>
<strong> 1 file changed, 2 insertions(+), 1 deletion(-)</strong></pre>
<p>OK, now back to the <kbd>grocery-cloned</kbd> repository.</p>
<p>We can retrieve objects from a remote with <kbd>git pull</kbd>.</p>
<p>In truth, <kbd>git pull</kbd> is a <em>super command</em>; in fact, it is basically the sum of two other Git commands, <kbd>git fetch</kbd> and <kbd>git merge</kbd>. While obtaining objects from a remote, Git won't force you to merge them into a local branch; this can seem a little bit confusing at first, as in other versioning systems, such as Subversion, this is the default behavior.</p>
<p>Instead, Git is more conservative: it could happen that someone pushed a commit or more on top of a branch, but you realized those commits are not good for you, or simply they are just wrong. So, using <kbd>git fetch</kbd>, you can get and inspect them before applying them on your local branch with a <kbd>git merge</kbd>.</p>
<p>Let's try <kbd>git pull</kbd> for now, then we will try to use <kbd>git fetch</kbd> and <kbd>git merge</kbd> separately.</p>
<p>Go back to the <kbd>grocery-cloned</kbd> repository, switch to the <kbd>master</kbd> branch, and do a <kbd>git pull</kbd>:</p>
<pre><strong>[16] ~/grocery-cloned (berries)</strong>
<strong>$ git checkout master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
<strong>Switched to branch 'master'</strong></pre>
<p>Git says that our branch is up-to-date with <kbd>'origin/master'</kbd>, but this is not true, as we just did a new commit there. This is because, for Git, the only way to know if we are updated in respect a remote repository is to perform a <kbd>git fetch</kbd>, and we didn't. Later we will see this more clearly.</p>
<p>For now, go with <kbd>git pull</kbd>: the command wants you to specify the name of the remote you want to pull from, which is <kbd>origin</kbd> in this case, and then the branch you want to merge into your local one, which is <kbd>master</kbd>, of course:</p>
<pre><strong>[17] ~/grocery-cloned (master)</strong>
<strong>$ git pull origin master</strong>
<strong>remote: Counting objects: 3, done.</strong>
<strong>remote: Compressing objects: 100% (2/2), done.</strong>
<strong>remote: Total 3 (delta 0), reused 0 (delta 0)</strong>
<strong>Unpacking objects: 100% (3/3), done.</strong>
<strong>From C:/Users/san/Google Drive/Packt/PortableGit/home/grocery</strong>
<strong> * branch    master     -&gt; FETCH_HEAD</strong>
<strong>   6409527..741ed56  master     -&gt; origin/master</strong>
<strong>Updating 6409527..741ed56</strong>
<strong>Fast-forward</strong>
<strong> shoppingList.txt | 3 ++-</strong>
<strong> 1 file changed, 2 insertions(+), 1 deletion(-)</strong>
  </pre>
<p>Good! Git tells us that there are three new objects to fetch; after it has obtained them, it performs a merge on top of the local <kbd>master</kbd> branch, and in this case, it performs a fast-forward merge.</p>
<p>OK, now I want you to try doing these steps in a separate manner; create the umpteenth new commit in the <kbd>grocery</kbd> repository, the <kbd>master</kbd> branch:</p>
<pre><strong>[18] ~/grocery (master)</strong>
<strong>$ echo "plum" &gt;&gt; shoppingList.txt</strong>

<strong>[19] ~/grocery (master)</strong>
<strong>$ git commit -am "Add a plum"</strong>
<strong>[master 50851d2] Add a plum</strong>
<strong>1 file changed, 1 insertion(+)</strong></pre>
<p>Now perform a <kbd>git fetch</kbd> on <kbd>grocery-cloned</kbd> repository:</p>
<pre><strong>[20] ~/grocery-cloned (master)</strong>
<strong>$ git fetch</strong>
<strong>remote: Counting objects: 3, done.</strong>
<strong>remote: Compressing objects: 100% (2/2), done.</strong>
<strong>remote: Total 3 (delta 0), reused 0 (delta 0)</strong>
<strong>Unpacking objects: 100% (3/3), done.</strong>
<strong>From C:/Users/san/Google Drive/Packt/PortableGit/home/grocery</strong>
<strong>   741ed56..50851d2  master     -&gt; origin/master</strong>
  </pre>
<p>As you can see, Git found new objects on the remote, and it downloaded them.</p>
<p>Note that you can do a <kbd>git fetch</kbd> in whatever branch you are in, as it simply downloads remote objects; it won't merge them. Instead, while doing a <kbd>git pull</kbd>, you have to be sure to be in the right local target branch.</p>
<p>Do a <kbd>git status</kbd> now:</p>
<pre><strong>[21] ~/grocery-cloned (master)</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is behind 'origin/master' by 1 commit, and can be fast-forwarded.</strong>
<strong>  (use "git pull" to update your local branch)</strong>
<strong>nothing to commit, working tree clean</strong>
  </pre>
<p>OK, as you can see, when there is a remote, <kbd>git status</kbd> informs you even on the state of the <em>synchronization</em> between your local repository and the remote one; here it tells us we are behind the remote because it has because it has one commit more than us in the <kbd>master</kbd> branch, and that commit can be fast-forwarded.</p>
<p>Now, let's sync with a <kbd>git merge</kbd>; to merge a remote branch, we have to specify, other than the branch name, even the remote one, as we did in the <kbd>git pull</kbd> command previously:</p>
<pre><strong>[22] ~/grocery-cloned (master)</strong>
<strong>$ git merge origin master</strong>
<strong>Updating 741ed56..50851d2</strong>
<strong>Fast-forward</strong>
<strong> shoppingList.txt | 1 +</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<p>That's all!</p>
<p>This is basically what you need to know to work with remotes. Note that, if some changes on the remote are in conflict with the local ones, you will have to solve them as we did in the previous merge examples.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How Git keeps track of remotes</h1>
                
            
            
                
<p>Git stores remote branch labels in a similar way to how it stores the local branches ones; it uses a subfolder in <kbd>refs</kbd> for the scope, with the symbolic name we used for the remote, in this case <kbd>origin</kbd>, the default one:</p>
<pre><strong>[23] ~/grocery-cloned (master)</strong>
<strong>$ ll .git/refs/remotes/origin/</strong>
<strong>total 3</strong>
<strong>drwxr-xr-x 1 san 1049089  0 Aug 27 11:25 ./</strong>
<strong>drwxr-xr-x 1 san 1049089  0 Aug 26 18:19 ../</strong>
<strong>-rw-r--r-- 1 san 1049089 41 Aug 26 18:56 berries</strong>
<strong>-rw-r--r-- 1 san 1049089 32 Aug 26 18:19 HEAD</strong>
<strong>-rw-r--r-- 1 san 1049089 41 Aug 27 11:25 master</strong>
  </pre>
<p>The command to deal with remotes is <kbd>git remote</kbd>; you can add, remove, rename, list, and do a lot of other things with them; there's no room here to see all the options. Please refer to the Git guide if you need to know more about the <kbd>git remote</kbd> command.</p>
<p>Now, we will play a little bit with a remote on a public server; we will use free GitHub hosting for this purpose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Working with a public server on GitHub</h1>
                
            
            
                
<p>To start working with a public hosted remote, we have to get one. Today, it is not difficult to achieve; the world has plenty of free online services offering room for Git repositories. One of the most commonly used is <strong>GitHub</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up a new GitHub account</h1>
                
            
            
                
<p>GitHub offers unlimited free public repositories, so we can make use of it without investing a penny. In GitHub, you have to pay only if you need private repositories; for example, to store closed source code you base your business on.</p>
<p>Creating a new account is simple:</p>
<ol>
<li>Go to <a href="https://github.com/">https://github.com</a>.</li>
<li>Sign up, filling the textboxes, as per the following image, and provide a username, a password, and your email:</li>
</ol>
<div><img class=" image-border" src="img/88f28145-6321-46de-a694-06d66c0b087b.png"/></div>
<p>When done, we are ready to create a brand new repository in which to push our work:</p>
<div><img class=" image-border" src="img/b0e47506-62c7-4fc3-8433-322436fbf9c1.png"/></div>
<p>Go to the Repositories tab, click the green New button, and choose a name for your repository, as you can see in the following screenshot:</p>
<div><img height="253" width="503" class=" image-border" src="img/290ff070-b9e4-4385-8fc0-ac91f4953974.png"/></div>
<p>For the purpose of learning, I will create a simple repository for my personal recipes, written using the <strong>markdown markup language</strong> (<a href="http://daringfireball.net/projects/markdown/">http://daringfireball.net/projects/markdown/</a>):</p>
<div><img height="489" width="776" class="aligncenter size-full wp-image-47 image-border" src="img/06dd1613-78b2-49db-b3aa-9c19dd509dc0.png"/></div>
<p>Then, you can write a description for your repository; this is useful for allowing people that come to visit your profile to better understand what your project is intended for. We create our repository as public because private repositories have a cost, as we said before, and then we initialize it with a <kbd>README</kbd> file; choosing this, GitHub makes a first commit for us, initializing the repository that now is ready to be cloned.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cloning the repository</h1>
                
            
            
                
<p>Now that we have a remote repository, it's time to <em>hook</em> it locally. For this, Git provides the <kbd>git clone</kbd> command, as we have already seen.</p>
<p>Using this command is quite simple; in this case, all we need to know is the URL of the repository to clone. The URL is provided by GitHub on the right down part of the repository home page:</p>
<div><img height="171" width="218" class="aligncenter size-full wp-image-48 image-border" src="img/0ff5ab15-8bf0-43da-863e-5d64b80fbe74.png"/></div>
<p>To copy the URL, you can simply click the clipboard button at the right of the textbox.</p>
<p>So, let's try to follow these steps together:</p>
<ol>
<li>Go to a local root folder for the repositories.</li>
<li>Open a Bash shell within it.</li>
<li>Type <kbd>git clone https://github.com/fsantacroce/Cookbook.git</kbd>.</li>
</ol>
<p>Obviously, the URL of your repository will be different; as you can see, GitHub URLs are composed as follows: <kbd>https://github.com/&lt;Username&gt;/&lt;RepositoryName&gt;.git</kbd>:</p>
<pre><strong>[1] ~</strong>
<strong>$ git clone https://github.com/fsantacroce/Cookbook.git</strong>
<strong>Cloning into 'Cookbook'...</strong>
<strong>remote: Counting objects: 15, done.</strong>
<strong>remote: Total 15 (delta 0), reused 0 (delta 0), pack-reused 15</strong>
<strong>Unpacking objects: 100% (15/15), done.</strong>

<strong>[2] ~</strong>
<strong>$ cd Cookbook/</strong>

<strong>[3] ~/Cookbook (master)</strong>
<strong>$ ll</strong>
<strong>total 13</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 27 14:16 ./</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 27 14:16 ../</strong>
<strong>drwxr-xr-x 1 san 1049089   0 Aug 27 14:16 .git/</strong>
<strong>-rw-r--r-- 1 san 1049089 150 Aug 27 14:16 README.md</strong>
  </pre>
<p>At this point, Git creates a new <kbd>Cookbook</kbd> folder containing the downloaded copy of our repository; inside, we will find a <kbd>README.md</kbd> file, a classical one for a GitHub repository. In that file, you can describe your repository using the common markdown markup language to users who will chance upon it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Uploading modifications to remotes</h1>
                
            
            
                
<p>So, let's try to edit the <kbd>README.md</kbd> file and upload modifications to GitHub:</p>
<ol>
<li>Edit the <kbd>README.md</kbd> file using your preferred editor, adding, for example, a new sentence.</li>
<li>Add it to the index and then commit.</li>
<li>Put your commit on the remote repository using the <kbd>git push</kbd> command.</li>
</ol>
<p>But firstly, set the user and email this time, so Git will not output the message we have seen in the previous chapters:</p>
<pre><strong>[4] ~/Cookbook (master)</strong>
<strong>$ git config user.name "Ferdinando Santacroce"</strong>

<strong>[5] ~/Cookbook (master)</strong>
<strong>$ git config user.email "ferdinando.santacroce@gmail.com"</strong>

<strong>[6] ~/Cookbook (master)</strong>
<strong>$ vim README.md</strong>

<strong>Add a sentence then save and close the editor.</strong>

<strong>[7] ~/Cookbook (master)</strong>
<strong>$ git add README.md</strong>

<strong>[8] ~/Cookbook (master)</strong>
<strong>$ git commit -m "Add a sentence to readme"</strong>
<strong>[master 41bdbe6] Add a sentence to readme</strong>
<strong> 1 file changed, 2 insertions(+)</strong>
  </pre>
<p>Now, try to type <kbd>git push</kbd> and press <kbd>ENTER</kbd>, without specifying anything else:</p>
<pre><strong>[9] ~/Cookbook (master)</strong>
<strong>$ git push</strong></pre>
<p>Here, in my Windows 10 workstation, this window appears:</p>
<div><img height="328" width="322" class="aligncenter size-full wp-image-49 image-border" src="img/81e9d578-11b8-4fbc-b3c4-29c0eadd2ad8.png"/></div>
<p>This is the <strong>Git Credential Manager</strong>; it allows you to set credentials on your Windows machine. If you are on Linux or macOS, the situation may be different, but the underlying concept is the same: we have to give Git the credentials in order to access the remote GitHub repository; they will then be stored to our system.</p>
<p>Input your credentials, and then press the Login button; after that, Git continues with:</p>
<pre><strong>[10] ~/Cookbook (master)</strong>
<strong>$ git push</strong>
<strong>Counting objects: 3, done.</strong>
<strong>Delta compression using up to 8 threads.</strong>
<strong>Compressing objects: 100% (2/2), done.</strong>
<strong>Writing objects: 100% (3/3), 328 bytes | 0 bytes/s, done.</strong>
<strong>Total 3 (delta 1), reused 0 (delta 0)</strong>
<strong>remote: Resolving deltas: 100% (1/1), completed with 1 local object.</strong>
<strong>To https://github.com/fsantacroce/Cookbook.git</strong>
<strong>   e1e7236..41bdbe6  master -&gt; master</strong>
  </pre>
<p>The <kbd>git push</kbd> command allows you to <em>upload</em> local work to a configured remote location; in this case, a remote GitHub repository, as you can see in the following screenshot:</p>
<div><img height="423" width="609" class="aligncenter size-full wp-image-50 image-border" src="img/b4855a7b-154d-4736-99c2-65139bc5ec6c.png"/></div>
<p>There are a few more things we need know about pushing; we can begin to understand the message Git gave us just after we ran the <kbd>git push</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What do I send to the remote when I push?</h1>
                
            
            
                
<p>When you give a <kbd>git push</kbd> without specifying anything else, Git sends all the <strong>new commits</strong> and all the related objects you did locally in your current branch to the remote; for <em>new commits</em>, it mean that we will send only local commits that have not been uploaded yet.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pushing a new branch to the remote</h1>
                
            
            
                
<p>Obviously, we can create and push a new branch to the remote to make our work public and visible to other collaborators; for instance, I will create a new branch for a new recipe, then I will push to the remote GitHub server. Follow these simple steps:</p>
<ol>
<li>Create a new branch, for instance <kbd>Risotti</kbd>.</li>
<li>Add to it a new file, for example, <kbd>Risotto-alla-Milanese.md</kbd>, and commit it.</li>
<li>Push the branch to the remote using <kbd>git push -u origin Risotti</kbd>:</li>
</ol>
<pre><strong>      [11] ~/Cookbook (master)</strong>
      <strong>$ git branch Risotti</strong>

      <strong>[12] ~/Cookbook (master)</strong>
      <strong>$ git checkout Risotti</strong>

      <strong>[13] ~/Cookbook (Risotti)</strong>
      <strong>$ notepad Risotto-alla-Milanese.md</strong>
 
      <strong>[14] ~/Cookbook (Risotti)</strong>
      <strong>$ git add Risotto-alla-Milanese.md</strong>
 
      <strong>[15] ~/Cookbook (Risotti)</strong>
      <strong>$ git commit -m "Add risotto alla milanese recipe ingredients"</strong>
      <strong>[Risotti b62bc1f] Add risotto alla milanese recipe ingredients</strong>
      <strong> 1 file changed, 15 insertions(+)</strong>
      <strong> create mode 100644 Risotto-alla-Milanese.md</strong>

      <strong>[16] ~/Cookbook (Risotti)</strong>
      <strong>$ git push -u origin Risotti</strong>
      <strong>Total 0 (delta 0), reused 0 (delta 0)</strong>
      <strong>Branch Risotti set up to track remote branch Risotti from origin.</strong>
      <strong>To https://github.com/fsantacroce/Cookbook.git</strong>
      <strong> * [new branch]      Risotti -&gt; Risotti</strong></pre>
<p>Before continuing, we have to examine in depth some things that happened after this <kbd>git push</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The origin</h1>
                
            
            
                
<p>With the <kbd>git push -u origin Risotti</kbd> command, we told Git to upload our <kbd>Risotti</kbd> branch (and the commits within it) to the <kbd>origin</kbd>; with the <kbd>-u</kbd> option, we set the local branches to track the remote one.</p>
<p>We know that <kbd>origin</kbd> is the default remote of a repository, just as <kbd>master</kbd> is the default branch name; when you clone a repository from a remote, that remote becomes your <kbd>origin</kbd> alias. When you tell Git to push or pull something, you often have to tell it the remote you want to use; using the alias <kbd>origin</kbd>, you say to Git you want to use your default remote.</p>
<p>If you want to see remotes actually configured in your repository, you can type a simple <kbd>git remote</kbd> command, followed by <kbd>-v</kbd> (<kbd>--verbose</kbd>) to get some more details:</p>
<pre><strong>[17] ~/Cookbook (master)</strong>
<strong>$ git remote -v</strong>
<strong>origin  https://github.com/fsantacroce/Cookbook.git (fetch)</strong>
<strong>origin  https://github.com/fsantacroce/Cookbook.git (push)</strong>
  </pre>
<p>In the details, you will see the full URL of the remote and discover that Git stores two different URLs:</p>
<ul>
<li>The Fetch URL, which is where we take updates from others</li>
<li>The Push URL, which is where we send out updates to others</li>
</ul>
<p>This allows us to push and pull changes from different remotes, if you like, and underlines how Git can be considered a peer-to-peer versioning system.</p>
<p>You can add, update, and delete remotes using the <kbd>git remote</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tracking branches</h1>
                
            
            
                
<p>Using the <kbd>-u</kbd> option, we told Git to <strong>track</strong> the remote branch. Tracking a remote branch is <em>the way to tie your local branch with the remote one</em>; please note that this behavior is not automatic, you have to set it if you want it. When a local branch tracks a remote branch, you actually have a local and a remote branch that can be kept easily in sync (please note that a local branch can track only one remote branch). This is very useful when you need to collaborate with some remote coworkers at the same branch, allowing all of them to keep their work in sync with other people's changes.</p>
<p>To better understand the way our repository is now configured, try to type <kbd>git remote show origin</kbd>:</p>
<pre><strong>[18] ~/Cookbook (master)</strong>
<strong>$ git remote show origin</strong>
<strong>* remote origin</strong>
<strong>  Fetch URL: https://github.com/fsantacroce/Cookbook.git</strong>
<strong>  Push  URL: https://github.com/fsantacroce/Cookbook.git</strong>
<strong>  HEAD branch: master</strong>
<strong>  Remote branches:</strong>
<strong>    Pasta   tracked</strong>
<strong>    Risotti tracked</strong>
<strong>    master  tracked</strong>
<strong>  Local branches configured for 'git pull':</strong>
<strong>    Risotti merges with remote Risotti</strong>
<strong>    master  merges with remote master</strong>
<strong>  Local refs configured for 'git push':</strong>
<strong>    Risotti pushes to Risotti (up to date)</strong>
<strong>    master  pushes to master  (fast-forwardable)</strong>
  </pre>
<p>As you can see, the <kbd>Pasta</kbd> <strong>,</strong> <kbd>Risotti</kbd>, and <kbd>master</kbd> branches are all tracked.</p>
<p>You see also that your local branches are configured to push and pull to remote branches with the same name, but remember: it is not mandatory to have local and remote branches with the same name; the local branch, <kbd>foo</kbd>, can track the remote branch, <kbd>bar</kbd>, and vice versa; there's no restrictions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Going backward – publishing a local repository to GitHub</h1>
                
            
            
                
<p>Commonly, you will find yourself needing to put your local repository on a shared place where someone else can look at your work; in this section, we will learn how to achieve this purpose.</p>
<p>Create a new local repository to publish, following these simple steps:</p>
<ol>
<li>Go to our local repositories folder.</li>
<li>Create a new <kbd>HelloWorld</kbd> folder.</li>
<li>In it place a new repository, as we did in first chapter.</li>
</ol>
<p> </p>
<ol start="4">
<li>Add a new <kbd>README.md</kbd> file and commit it:</li>
</ol>
<pre><strong>      [19] ~</strong>
      <strong>$ mkdir HelloWorld</strong>

      <strong>[20] ~</strong>
      <strong>$ cd HelloWorld/</strong>

      <strong>[21] ~/HelloWorld</strong>
      <strong>$ git init</strong>
      <strong>Initialized empty Git repository in C:/Users/san/Google <br/>      Drive/Packt/PortableGit/home/HelloWorld/.git/</strong>

      <strong>[22] ~/HelloWorld (master)</strong>
      <strong>$ echo "Hello World!" &gt;&gt; README.md</strong>

      <strong>[23] ~/HelloWorld (master)</strong>
      <strong>$ git add README.md</strong>

      <strong>[24] ~/HelloWorld (master)</strong>
      <strong>$ git config user.name "Ferdinando Santacroce"</strong>

      <strong>[25] ~/HelloWorld (master)</strong>
      <strong>$ git config user.email "ferdinando.santacroce@gmail.com"</strong>

      <strong>[26] ~/HelloWorld (master)</strong>
      <strong>$ git commit -m "First commit"</strong>
      <strong>[master (root-commit) 5b41441] First commit</strong>
      <strong> 1 file changed, 1 insertion(+)</strong>
      <strong> create mode 100644 README.md</strong>

      <strong>[27] ~/HelloWorld (master)</strong></pre>
<p>Now, create the GitHub repository as we did previously; this time leave it empty. Don't initialize it with a readme file; we already have one in our local repository. The following is a screenshot taken directly from the GitHub repository creation page:</p>
<div><img height="787" width="1008" class="aligncenter size-full wp-image-51 image-border" src="img/abda2e4b-32cb-466c-8579-d53ae9113ba7.png"/></div>
<p>At this point, we are ready to publish our local repository on GitHub or, even better, to add a remote to it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a remote to a local repository</h1>
                
            
            
                
<p>To publish our <kbd>HelloWorld</kbd> repository, we simply have to add its first remote; adding a remote is quite simple: <kbd>git remote add origin &lt;remote-repository-url&gt;</kbd></p>
<p>So, this is the full command we have to type in the Bash shell:</p>
<pre><strong>[27] ~/HelloWorld (master)</strong>
<strong>$ git remote add origin https://github.com/fsantacroce/HelloWorld.git</strong></pre>
<p>Adding a remote, like adding or modifying other configuration parameters, simply consists of editing some text files in the <kbd>.git</kbd> folder, so it is blazing fast.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pushing a local branch to a remote repository</h1>
                
            
            
                
<p>After that, push your local changes to the remote using <kbd>git push -u origin master</kbd>:</p>
<pre><strong>[28] ~/HelloWorld (master)</strong>
<strong>$ git push -u origin master</strong>
<strong>Counting objects: 3, done.</strong>
<strong>Writing objects: 100% (3/3), 231 bytes | 0 bytes/s, done.</strong>
<strong>Total 3 (delta 0), reused 0 (delta 0)</strong>
<strong>Branch master set up to track remote branch master from origin.</strong>
<strong>To https://github.com/fsantacroce/HelloWorld.git</strong>
<strong> * [new branch]      master -&gt; master</strong></pre>
<p>That's all!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Social coding - collaborating using GitHub</h1>
                
            
            
                
<p>GitHub's trademark is the concept of so-called <strong>social coding</strong>; from its first steps, GitHub made it easy to share code, track other people's work, and collaborate using two basic concepts: <strong>forks</strong> and <strong>pull requests</strong>. In this section, I will illustrate them in brief.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Forking a repository</h1>
                
            
            
                
<p>Forking is a common concept for a developer; if you have already used a GNU-Linux based distribution, you know that there are some forefathers, such as Debian, and some derived distro, such as Ubuntu, also commonly called <em>forks</em> of the original distribution.</p>
<p>In GitHub things are similar. At some point, you find an interesting open-source project you want to modify slight to perfectly fit your needs; at the same time, you want to benefit from bug fixes and new features from the original project, keeping your work in touch. The right thing to do in this situation is to <em>fork</em> the project. But first, remember: <strong>fork is not a Git term</strong>, but GitHub terminology.</p>
<p>When you fork on GitHub, what you get <em>is essentially a server-side clone of the repository</em> on your GitHub account; if you clone your forked repository locally, in the remote list, you will find an <kbd>origin</kbd> that points to your account repository, while the original repository will assume the <em>upstream</em> alias (you have to add it manually anyway):</p>
<div><img height="298" width="287" class="aligncenter size-full wp-image-52 image-border" src="img/f40a810c-1bc9-47bb-a10e-590a4e3e615d.png"/></div>
<p>To better understand this feature, go to your GitHub account and try to fork a common GitHub repository called <kbd>Spoon-Knife</kbd>, made by GitHub mascot user <kbd>octocat</kbd>; so:</p>
<ol>
<li>Log in to your GitHub account</li>
<li>Look for <kbd>spoon-knife</kbd> using the search textbox located up on the left of the page:
<div><img height="42" width="415" class="aligncenter size-full wp-image-53 image-border" src="img/903d4a2e-a861-4b04-b755-1e5b69a212ad.png"/></div>
</li>
<li>Click on the first result, octocat/Spoon-Knife repository</li>
</ol>
<p> </p>
<ol start="4">
<li>Fork the repository using the Fork button at the right of the page:</li>
</ol>
<div><img height="89" width="799" class="aligncenter size-full wp-image-54 image-border" src="img/be37c6fd-ee2d-40c1-88d6-2a044217d435.png"/></div>
<ol start="5">
<li>After a funny photocopy animation, you will get a brand-new Spoon-Knife repository in your GitHub account:
<div><img height="119" width="322" class="aligncenter size-full wp-image-55 image-border" src="img/d6a1bfda-c56b-43ce-9b96-1c2e38833649.png"/></div>
</li>
</ol>
<p>Now, you can clone that repository locally, as we did before:</p>
<pre><strong>[1] ~</strong>
<strong>$ git clone https://github.com/fsantacroce/Spoon-Knife.git</strong>
<strong>Cloning into 'Spoon-Knife'...</strong>
<strong>remote: Counting objects: 19, done.</strong>
<strong>remote: Total 19 (delta 0), reused 0 (delta 0), pack-reused 19</strong>
<strong>Unpacking objects: 100% (19/19), done.</strong>

<strong>[2] ~</strong>
<strong>$ cd Spoon-Knife</strong>

<strong>[3] ~/Spoon-Knife (master)</strong>
<strong>$ git remote -v</strong>
<strong>origin  https://github.com/fsantacroce/Spoon-Knife.git (fetch)</strong>
<strong>origin  https://github.com/fsantacroce/Spoon-Knife.git (push)</strong>

  </pre>
<p>As you can see, the <kbd>upstream</kbd> remote is not present, you have to add it manually; to add it, use the <kbd>git remote add</kbd> command:</p>
<pre><strong>[4] ~/Spoon-Knife (master)</strong>
<strong>$ git remote add upstream https://github.com/octocat/Spoon-Knife.git</strong>

<strong>[5] ~/Spoon-Knife (master)</strong>
<strong>$ git remote -v</strong>
<strong>origin https://github.com/fsantacroce/Spoon-Knife.git (fetch)</strong>
<strong>origin https://github.com/fsantacroce/Spoon-Knife.git (push)</strong>
<strong>upstream https://github.com/octocat/Spoon-Knife.git (fetch)</strong>
<strong>upstream https://github.com/octocat/Spoon-Knife.git (push)</strong>
  </pre>
<p>Now, you can keep your local repository in sync with the changes in your remote, the <kbd>origin</kbd>, and you can also get those ones coming from the <kbd>upstream</kbd> remote, the original repository you forked. At this point. you are probably wondering how to deal with two different remotes; well, it is easy: simply pull from the <kbd>upstream</kbd> remote and merge those modifications in your local repository, then push them into your <kbd>origin</kbd> remote in a bundle with your changes. If someone else clones your repository, he or she will receive your work merged with the work done by someone else on the original repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Submitting pull requests</h1>
                
            
            
                
<p>If you created a fork of a repository, it is because you are not a direct contributor of the original project, or simply you don't want to make a mess in other people's work before becoming familiar with the code.</p>
<p>However, at a certain point, you realize your work can be useful even for the original project: you realize a better implementation of a previous piece of code, you add a missing feature, and so on.</p>
<p>So, you find yourself needing to notify the original author that you did something interesting, asking him if he wants to take a look and, maybe, integrate your work. This is the moment when <strong>pull requests</strong> come in handy.</p>
<p>A pull request is a way to tell the original author <em>Hey! I did something interesting using your original code, do you want to take a look and integrate my work, if you find it good enough?</em> This is not only a technical way to achieve the purpose of integrating work, but it is even a powerful practice for promoting <strong>code reviews</strong> (and then the so-called <em>social coding</em>) as recommended by <em>eXtreme Programming</em> fellows (for more information, visit: <a href="http://en.wikipedia.org/wiki/Extreme_programming">http://en.wikipedia.org/wiki/Extreme_programming</a>).</p>
<p>Another reason to use a pull request is that <strong>you cannot push directly</strong> to the <kbd>upstream</kbd> remote <strong>if you are not a contributor</strong> of the original project: pull requests are the only way. In small scenarios (such as a team of two or three developers that works in the same room) probably the <em>fork and pull</em> model represents an overhead, so it is more common to directly share the original repository with all the contributors, skipping the fork and pull ceremony.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a pull request</h1>
                
            
            
                
<p>To create a pull request, you have to go on your GitHub account and make it directly from your forked account; but first, you have to know that <strong>pull requests can be made only from separated branches</strong>. At this point of the book, you are probably used to creating a new branch for a new feature or refactor purpose, so this is nothing new, isn't it?</p>
<p>To make an attempt, let's create a local <kbd>TeaSpoon</kbd> branch in our repository, commit a new file, and push it to our GitHub account:</p>
<pre><strong>[6] ~/Spoon-Knife (master)</strong>
<strong>$ git branch TeaSpoon</strong>

<strong>[7] ~/Spoon-Knife (master)</strong>
<strong>$ git checkout TeaSpoon</strong>
<strong>Switched to branch 'TeaSpoon'</strong>

<strong>[8] ~/Spoon-Knife (TeaSpoon)</strong>
<strong>$ vi TeaSpoon.md</strong>

<strong>[9] ~/Spoon-Knife (TeaSpoon)</strong>
<strong>$ git add TeaSpoon.md</strong>

<strong>[10] ~/Spoon-Knife (TeaSpoon)</strong>
<strong>$ git commit -m "Add a TeaSpoon to the cutlery"</strong>
<strong>[TeaSpoon 62a99c9] Add a TeaSpoon to the cutlery</strong>
<strong>1 file changed, 2 insertions(+)</strong>
<strong> create mode 100644 TeaSpoon.md</strong>

<strong>[11] ~/Spoon-Knife (TeaSpoon)</strong>
<strong>$ git push origin TeaSpoon</strong>
<strong>Counting objects: 3, done.</strong>
<strong>Delta compression using up to 8 threads.</strong>
<strong>Compressing objects: 100% (3/3), done.</strong>
<strong>Writing objects: 100% (3/3), 417 bytes | 0 bytes/s, done.</strong>
<strong>Total 3 (delta 0), reused 0 (delta 0)</strong>
<strong>To https://github.com/fsantacroce/Spoon-Knife.git</strong>
<strong>   d0dd1f6..62a99c9  TeaSpoon -&gt; TeaSpoon</strong>
  </pre>
<p>If you take a look at your account, you will find a surprise: in your <kbd>Spoon-Knife</kbd> repository, there is now a New pull request button made for the purpose of starting a pull request, as you can see in the following screenshot:</p>
<div><img height="919" width="1006" class="aligncenter size-full wp-image-56 image-border" src="img/b0306886-7497-4f8e-a786-d28985c538ba.png"/></div>
<p>Clicking that button makes GitHub open a new page; you now have to select the branch you want to compare to the original repository; look at the following screenshot:</p>
<div><img height="782" width="1005" class="aligncenter size-full wp-image-57 image-border" src="img/75b3eb4c-4364-41cf-9086-a633ecb5206d.png"/></div>
<p>Go to the branches combo (1), select TeaSpoon branch (2), and then GitHub will show you something similar to the following screenshot:</p>
<div><img height="424" width="491" class="aligncenter size-full wp-image-58 image-border" src="img/032e325b-307a-4a93-a6bd-6a3d7e8fa421.png"/></div>
<p>This is a report, where you can see what you are going to propose: a commit containing a new file.</p>
<p>But let me analyze the page.</p>
<p>In the top left corner of the preceding screenshot, you will find what branches GitHub is about to compare for you; take a look at details in the following image:</p>
<div><img height="98" width="994" class="aligncenter size-full wp-image-59 image-border" src="img/a9a033e7-155d-4c5f-bbf3-11e61eccd837.png"/></div>
<p>This means that you are about to compare your local <kbd>TeaSpoon</kbd> branch with the original <kbd>master</kbd> branch of the <kbd>octocat</kbd> user. At the end of the page, you can see all the different details (files added, removed, changed, and so on):</p>
<div><img height="134" width="1003" class="aligncenter size-full wp-image-60 image-border" src="img/99b0ef05-12dd-4830-b66d-a5241e17aabc.png"/></div>
<p>Now, you can click on the green Create pull request button; the window in the following screenshot will appear:</p>
<div><img height="473" width="496" class="aligncenter size-full wp-image-61 image-border" src="img/a5347094-ea35-4be5-a770-bf2922665f1d.png"/></div>
<p>In the central part of the page, you can describe the work you did in your branch. A green Able to merge text on the top left informs you that these two branches can be automatically merged (there are no unresolved conflicts; that is always good if you want to see your work considered).</p>
<p>And now the last step: click the Create pull request button to send your request to the original author, letting him get your work and analyze it before accepting the pull request.</p>
<p>At this point, a new conversation begins, where you and the project collaborators can start to discuss your work; during this period, you and other collaborators can change the code to better fit common needs, until an original repository collaborator decides to accept your request or discard it, closing the pull request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we finally got in touch with the Git ability to manage multiple remote copies of repositories. This gives you a wide range of possibilities to better organize your collaboration workflow inside your team. In the next chapter, you will learn some advanced techniques using well-known and niche commands. This will make you a more secure and proficient Git user, allowing you to resolve some common issues that occur in a developer's life with ease.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    </body></html>