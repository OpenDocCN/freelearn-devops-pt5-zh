<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Using ConfigMaps to Inject Configuration Files</h1>
                </header>
            
            <article>
                
<div class="packt_tip">ConfigMaps allow us to keep configurations separate from application images. Such separation is useful when other alternatives are not a good fit.</div>
<p>Almost every application can be fine-tuned through configuration. Traditional software deployment methods fostered the use of configuration files. However, we are not discussing traditional, but advanced, distributed, and immutable deployments through Kubernetes schedulers. Usage of fundamentally new technology often requires new processes and different architecture, if we are to leverage its potential to its maximum. On the other hand, we cannot just throw away everything we have and start anew.</p>
<p>We'll have to try to balance new principles and the legacy needs.</p>
<p>If we were to start developing a new application today, it would be, among other things, distributed, scalable, stateless, and fault tolerant. Those are some of the today's needs. While we might question how many of us know how to design an application with those quality attributes in mind, hardly anyone would argue against having any of them. What is often forgotten is the configuration. Which mechanism should your new application use to configure itself? How about environment variables?</p>
<div class="packt_tip">Environment variables fit well into distributed systems. They are easy to define, and they are portable. They are the ideal choice for configuration mechanism of new applications.</div>
<p>However, in some cases, the configuration might be too complex for environment variables. In such situations, we might need to fall back to files (hopefully YAML). When those cases are combined with legacy applications which are almost exclusively using file-based configuration, it is evident that we cannot rely only on environment variables.</p>
<p>When a configuration is based on files, the best approach we can take is to bake the configuration into a Docker image. That way, we are going down the fully-immutable road. Still, that might not be possible when our application needs different configuration options for various clusters (for example, testing and production). I'll ignore my internal need to convert this into a discussion that ends with "you do NOT need a different configuration for different environments". Rather just assume that you might have an excellent reason for something like that. In such a case, baking config files into images will not do the trick. That's where ConfigMaps comes into play.</p>
<p>ConfigMap allows us to "inject" configuration into containers. The source of the configs can be files, directories, or literal values. The destination can be files or environment variables.</p>
<div class="packt_tip">ConfigMap takes a configuration from a source and mounts it into running containers as a volume.</div>
<p>That's all the theory you'll get up-front. Instead of a lengthy explanation, we'll run some examples, and comment on the features we experience. We'll be learning by doing, instead of learning by memorizing theory.</p>
<p>Let's prepare the cluster and see ConfigMaps in action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a cluster</h1>
                </header>
            
            <article>
                
<p>It's still the same process as before, so let's get over with it silently.</p>
<div class="packt_infobox">All the commands from this chapter are available in the <kbd>09-config-map.sh</kbd> (<a href="https://gist.github.com/vfarcic/717f8418982cc5ec1c755fcf7d4255dd" target="_blank"><span class="URLPACKT">https://gist.github.com/vfarcic/717f8418982cc5ec1c755fcf7d4255dd</span></a>) Gist.</div>
<pre><strong>cd k8s-specs</strong>
    
<strong>git pull</strong>
    
<strong>minikube start --vm-driver=virtualbox</strong>
    
<strong>minikube addons enable ingress</strong>
    
<strong>kubectl config current-context</strong>  </pre>
<p>Now we can try out the first variation of a ConfigMap.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting configurations from files</h1>
                </header>
            
            <article>
                
<p>In its purest, and probably the most common form, a ConfigMap takes a single file. For example, we can create one from the <kbd>cm/prometheus-conf.yml</kbd> file:</p>
<pre><strong>kubectl create cm my-config \</strong>
<strong>    --from-file=cm/prometheus-conf.yml</strong></pre>
<p>We created a <strong>ConfigMap</strong> (<kbd>cm</kbd>) called <kbd>my-config</kbd>. The data of the map is the content of the <kbd>cm/prometheus-conf.yml</kbd> file.</p>
<p>Let's describe it, and see what we'll get.</p>
<pre><strong>kubectl describe cm my-config</strong>  </pre>
<p>The output is as follows:</p>
<pre>Name:         my-config 
Namespace:    default 
Labels:       &lt;none&gt; 
Annotations:  &lt;none&gt; 
 
Data 
==== 
prometheus-conf.yml: 
---- 
global: 
  scrape_interval:     15s 
 
scrape_configs: 
  - job_name: Prometheus 
    metrics_path: /prometheus/metrics 
    static_configs: 
      - targets: 
        - localhost:9090 
 
Events:  &lt;none&gt; </pre>
<p>The important part is located below <kbd>Data</kbd>. We can see the key which, in this case, is the name of the file (<kbd>prometheus-conf.yml</kbd>). Further down you can see the content of the file. If you execute <kbd>cat cm/prometheus-conf.yml</kbd>, you'll see that it is the same as what we saw from the ConfigMap's description.</p>
<p>ConfigMap is useless by itself. It is yet another Volume which, like all the others, needs a mount.</p>
<p>Let's take a look at a Pod specification defined in <kbd>cm/alpine.yml</kbd>.</p>
<pre><strong>cat cm/alpine.yml</strong>  </pre>
<p>The output is as follows:</p>
<pre>apiVersion: v1 
kind: Pod 
metadata: 
  name: alpine 
spec: 
  containers: 
  - name: alpine 
    image: alpine 
    command: ["sleep"] 
    args: ["100000"] 
    volumeMounts: 
    - name: config-vol 
      mountPath: /etc/config 
  volumes: 
  - name: config-vol 
    configMap: 
      name: my-config </pre>
<p>The essential sections are <kbd>volumeMounts</kbd> and <kbd>volumes</kbd>. Since <kbd>volumeMounts</kbd> are the same no matter the type of the Volume, there's nothing special about it. We defined that it should be based on the volume called <kbd>config-vol</kbd> and that it should mount the path <kbd>/etc/config</kbd>. The <kbd>volumes</kbd> section uses <kbd>configMap</kbd> as the type and, in this case, has a single item <kbd>name</kbd>, that coincides with the name of the ConfigMap we created earlier.</p>
<p>Let's create the Pod and see what happens.</p>
<pre><strong>kubectl create -f cm/alpine.yml</strong>
    
<strong>kubectl get pods</strong>  </pre>
<p>Please confirm that the Pod is indeed running before moving on.</p>
<p>Let's see the content of the <kbd>/etc/config</kbd> directory inside the Pod's only container.</p>
<pre><strong>kubectl exec -it alpine -- \</strong>
<strong>    ls /etc/config</strong> </pre>
<p>The output is as follows:</p>
<pre><strong><span class="VerbatimChar">prometheus-conf.yml</span></strong></pre>
<p>The <kbd>/etc/config</kbd> now has a single file that coincides with the file we stored in the ConfigMap.</p>
<p>If you add <kbd>-l</kbd> to the <kbd>ls</kbd> command we executed a moment ago, you'll see that <kbd>prometheus-conf.yml</kbd> is a link to <kbd>..data/prometheus-conf.yml</kbd>. If you dig deeper, you'll see that <kbd>..data</kbd> is also a link to the directory named from a timestamp. And so on, and so forth. For now, the exact logic behind all the links and the actual files is not of great importance. From the functional point of view, there is <kbd>prometheus-conf.yml</kbd>, and our application can do whatever it needs to do with it.</p>
<p>Let's confirm that the content of the file inside the container is indeed the same as the source file we used to create the ConfigMap:</p>
<pre><strong>kubectl exec -it alpine -- \</strong>
<strong>    cat /etc/config/prometheus-conf.yml</strong>  </pre>
<p>The output should be the same as the contents of the <kbd>cm/prometheus-conf.yml</kbd> file.</p>
<p>We saw one combination of ConfigMap. Let's see what else we can do with it. We'll remove the objects we created thus far and start over:</p>
<pre><strong>kubectl delete -f cm/alpine.yml</strong>
    
<strong>kubectl delete cm my-config</strong>  </pre>
<p>We are not limited to a single <kbd>--from-file</kbd> argument. We can specify as many as we need.</p>
<p>Let's see what happens when we execute the commands that follow:</p>
<pre><strong>kubectl create cm my-config \</strong>
<strong>    --from-file=cm/prometheus-conf.yml \ </strong>
    <strong>--from-file=cm/prometheus.yml</strong>
    
<strong>kubectl create -f cm/alpine.yml</strong>
    
<strong>kubectl exec -it alpine -- \</strong>
<strong>    ls /etc/config</strong></pre>
<p>We created a ConfigMap with two files, and we created the same Pod based on the <kbd>alpine.yml</kbd> definition. Finally, we output the list of files from the <kbd>/etc/config</kbd> directory inside the Pod's only container. The output of the latter command is as follows:</p>
<pre><strong><span class="VerbatimChar">prometheus-conf.yml  prometheus.yml</span></strong>  </pre>
<p>We can see that both files are present in the container. That leads us to the conclusion that a ConfigMap can contain multiple files, and all will be created inside containers that mount it.</p>
<p>Let's delete the objects (again), and explore one more option behind the <kbd>--from-file</kbd> argument.</p>
<pre><strong>kubectl delete -f cm/alpine.yml</strong>
    
<strong>kubectl delete cm my-config</strong>  </pre>
<p>The <kbd>--from-file</kbd> argument might lead you to the conclusion that you can specify only a file path as its value. It works with directories as well. We can, for example, add all files from the <kbd>cm</kbd> directory to a ConfigMap.</p>
<pre><strong>kubectl create cm my-config \</strong>
<strong>    --from-file=cm</strong>  </pre>
<p>We created <kbd>my-config</kbd> ConfigMap with the directory <kbd>cm</kbd>. Let's describe it, and see what's inside.</p>
<pre><strong>kubectl describe cm my-config</strong>  </pre>
<p>The output is as follows (content of the files is removed for brevity).</p>
<pre><strong>Name:         my-config</strong>
<strong>Namespace:    default</strong>
<strong>Labels:       &lt;none&gt;</strong>
<strong>Annotations:  &lt;none&gt;</strong>
    
<strong>Data</strong>
<strong>====</strong>
<strong>alpine-env-all.yml:</strong>
<strong>----</strong>
<strong>...</strong>
<strong>alpine-env.yml:</strong>
<strong>----</strong>
<strong>...</strong>
<strong>alpine.yml:</strong>
<strong>----</strong>
<strong>...</strong>
<strong>my-env-file.yml:</strong>
<strong>----</strong>
<strong>...</strong>
<strong>prometheus-conf.yml:</strong>
<strong>----</strong>
<strong>...</strong>
<strong>prometheus.yml:</strong>
<strong>----</strong>
<strong>...</strong>
    
<strong>Events:  &lt;none&gt;</strong>  </pre>
<p>We can see that all six files from the <kbd>cm</kbd> directory are now inside the <kbd>my-config</kbd> ConfigMap.</p>
<p>I'm sure you already know what will happen if we create a Pod that mounts that ConfigMap. We'll check it out anyways:</p>
<pre><strong>kubectl create -f cm/alpine.yml</strong>
    
<strong>kubectl exec -it alpine -- \</strong>
<strong>    ls /etc/config</strong>  </pre>
<p>The output of the latter command is as follows:</p>
<pre><strong>alpine-env-all.yml alpine.yml      prometheus-conf.yml</strong>
<strong>alpine-env.yml     my-env-file.yml prometheus.yml</strong>  </pre>
<p>All the files are there, and the time has come to move away from files and directories. So, let's remove the objects first, and discuss the other sources.</p>
<pre><strong>kubectl delete -f cm/alpine.yml</strong>
    
<strong>kubectl delete cm my-config</strong>  </pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting configurations from key/value literals</h1>
                </header>
            
            <article>
                
<p>Hopefully, even when our applications need different configs to work in distinct clusters, the differences are limited. Often, they should be limited to only a few key/value entries. In such cases, it might be easier to create ConfigMaps using <kbd>--from-literal</kbd>.</p>
<p>Let's take a look at an example:</p>
<pre><strong>kubectl create cm my-config \</strong>
<strong>    --from-literal=something=else \</strong>
<strong>    --from-literal=weather=sunny</strong>
    
<strong>kubectl get cm my-config -o yaml</strong>  </pre>
<p>The output of the latter command is as follows (<kbd>metadata</kbd> is removed for brevity):</p>
<pre>apiVersion: v1 
data: 
  something: else 
  weather: sunny 
kind: ConfigMap 
... </pre>
<p>We can see that two entries were added, one for each literal.</p>
<p>Let's create a Pod with the ConfigMap mounted:</p>
<pre><strong>kubectl create -f cm/alpine.yml 
 
kubectl exec -it alpine -- \
    ls /etc/config</strong> </pre>
<p>The output of the latter command is as follows:</p>
<pre><strong><span class="VerbatimChar">something  weather</span>
    </strong>
<strong>Both files are there.</strong>  </pre>
<p>Finally, let's confirm that the content of one of the files is correct.</p>
<pre><strong>kubectl exec -it alpine -- \</strong>
<strong>    cat /etc/config/something</strong>  </pre>
<p>The output is as follows:</p>
<pre><strong><span class="VerbatimChar">else</span></strong>  </pre>
<div class="packt_tip">The <kbd>--from-literal</kbd> argument is useful when we're in need to set a relatively small set of configuration entries in different clusters. It makes more sense to specify only the things that change, than all the configuration options.</div>
<p>The problem is that most of the existing applications are not designed to read separate configuration entries from different files. On the other hand, if you're sketching a new application, you might not choose this option either since you'd be able to develop it in a way that it reads environment variables. When faced with a choice between ConfigMap and environment variables, the latter wins most of the time.</p>
<p>All in all, I'm not sure how often you'll be using the <kbd>--from-literal</kbd> argument. Maybe a lot, more likely not at all.</p>
<p>There's one more config source left to explore, so let's delete the objects we're currently running, and move on.</p>
<pre><strong>kubectl delete -f cm/alpine.yml</strong>
    
<strong>kubectl delete cm my-config</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Injecting configurations from environment files</h1>
                </header>
            
            <article>
                
<p>Let's take a look at the <kbd>cm/my-env-file.yml</kbd> file:</p>
<pre><strong>cat cm/my-env-file.yml</strong>  </pre>
<p>The output is as follows:</p>
<pre>something=else 
weather=sunny </pre>
<p>The file has the same key/value pairs as those we used in the example with <kbd>--from-literal</kbd>:</p>
<p>Let's see what happens if we create a ConfigMap using that file as the source.</p>
<pre><strong>kubectl create cm my-config \</strong>
<strong>    --from-env-file=cm/my-env-file.yml</strong>
    
<strong>kubectl get cm my-config -o yaml</strong>  </pre>
<p>We created the ConfigMap using the <kbd>--from-env-file</kbd> argument, and we retrieved the ConfigMap in <kbd>yaml</kbd> format.</p>
<p>The output of the latter command is as follows (<kbd>metadata</kbd> is removed for brevity):</p>
<pre>apiVersion: v1 
data: 
  something: else 
  weather: sunny 
kind: ConfigMap 
... </pre>
<p>We can see that there are two entries, each corresponding to key/value pairs from the file. The result is the same as when we created a ConfigMap using <kbd>--from-literal</kbd> arguments. Two different sources produced the same outcome:</p>
<p>If we used <kbd>--from-file</kbd> argument, the result would be as follows:</p>
<pre>apiVersion: v1 
data: 
  my-env-file.yml: | 
    something=else 
    weather=sunny 
kind: ConfigMap 
... </pre>
<p>All in all, <kbd>--from-file</kbd> reads the content of a one or more files, and stores it using file names as keys. <kbd>--from-env-file</kbd>, assumes that content of a file is in key/value format, and stores each as a separate entry.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Converting ConfigMap output into environment variables</h1>
                </header>
            
            <article>
                
<p>All the examples we've seen so far are differing only in the source. The destination is always the same. No matter whether ConfigMap is created from a file, from a directory, from literal values, or from an environment file, it perpetually resulted in one or more files being injected into a container.</p>
<p>This time we'll try something different. We'll see how we can convert a ConfigMap into environment variables.</p>
<p>Let's take a look at a sample definition:</p>
<pre><strong>cat cm/alpine-env.yml</strong>  </pre>
<p>The output is as follows.</p>
<pre>apiVersion: v1 
kind: Pod 
metadata: 
  name: alpine-env 
spec: 
  containers: 
  - name: alpine 
    image: alpine 
    command: ["sleep"] 
    args: ["100000"] 
    env: 
    - name: something 
      valueFrom: 
        configMapKeyRef: 
          name: my-config 
          key: something 
    - name: weather 
      valueFrom: 
        configMapKeyRef: 
          name: my-config 
          key: weather </pre>
<p class="mce-root"/>
<p>The major difference, when compared with <kbd>cm/alpine.yml</kbd>, is that <kbd>volumeMounts</kbd> and <kbd>volumes</kbd> sections are gone. This time we have <kbd>env</kbd> section.</p>
<p>Instead of a <kbd>value</kbd> field, we have <kbd>valueFrom</kbd>. Further on, we declared that it should get values from a ConfigMap (<kbd>configMapKeyRef</kbd>) named <kbd>my-config</kbd>. Since that ConfigMap has multiple values, we specified the <kbd>key</kbd> as well.</p>
<p>Let's create the Pod:</p>
<pre><strong>kubectl create \</strong>
<strong>    -f cm/alpine-env.yml</strong>
    
<strong>kubectl exec -it alpine-env -- env</strong>  </pre>
<p>We created the Pod and executed the <kbd>env</kbd> command inside its only container. The output of the latter command, limited to the relevant parts, is as follows:</p>
<pre>... 
weather=sunny 
something=else 
... </pre>
<p>There's another, often more useful way to specify environment variables from a ConfigMap. Before we try it, we'll remove the currently running Pod:</p>
<pre><strong>kubectl delete \</strong>
<strong>    -f cm/alpine-env.yml</strong>  </pre>
<p>Let's take a look at yet another definition:</p>
<pre><strong>cat cm/alpine-env-all.yml</strong>  </pre>
<p>The output is as follows:</p>
<pre>apiVersion: v1 
kind: Pod 
metadata: 
  name: alpine-env 
spec: 
  containers: 
  - name: alpine 
    image: alpine 
    command: ["sleep"] 
    args: ["100000"] 
    envFrom: 
    - configMapRef: 
        name: my-config </pre>
<p class="mce-root"/>
<p>The difference is only in the way environment variables are defined. This time, the syntax is much shorter. We have <kbd>envFrom</kbd>, instead of the <kbd>env</kbd> section. It can be either <kbd>configMapRef</kbd> or <kbd>secretRef</kbd>. Since we did not yet explore Secrets, we'll stick with the prior. Inside <kbd>configMapRef</kbd> is the <span class="VerbatimChar">name</span> reference to the <kbd>my-config</kbd> ConfigMap.</p>
<p>Let's see it in action.</p>
<pre><strong>kubectl create \</strong>
<strong>    -f cm/alpine-env-all.yml</strong>
    
<strong>kubectl exec -it alpine-env -- env</strong>  </pre>
<p>We created the Pod and retrieved all the environment variables from inside its only container. The output of the latter command, limited to the relevant parts, is as follows:</p>
<pre>... 
something=else 
weather=sunny 
... </pre>
<p>The result is the same as before. The difference is only in the way we define environment variables. With <kbd>env.valueFrom.configMapKeyRef</kbd> syntax, we need to specify each ConfigMap key separately. That gives us control over the scope and the relation with the names of container variables.</p>
<p>The <kbd>envFrom.configMapRef</kbd> converts all ConfigMap's data into environment variables. That is often a better and simpler option if you don't need to use different names between ConfigMap and environment variable keys. The syntax is short, and we don't need to worry whether we forgot to include one of the ConfigMap's keys.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining ConfigMaps as YAML</h1>
                </header>
            
            <article>
                
<p>All ConfigMaps we created so far were done through <kbd>kubectl create cm</kbd> commands. It would be a shame if we could not specify them through YAML definitions, just like other Kubernetes resources and objects. Fortunately, we can. Everything in Kubernetes can be defined as YAML, and that includes ConfigMaps as well.</p>
<p>Even though we have not yet specified ConfigMaps as YAML, we have seen the format quite a few times throughout this chapter. Since I cannot be sure whether you can create a ConfigMap YAML file from memory, let's make things easy on ourselves and use <kbd>kubectl</kbd> to output our existing <kbd>my-config</kbd> ConfigMap in YAML format.</p>
<pre><strong>kubectl get cm my-config -o yaml</strong>  </pre>
<p>The output is as follows:</p>
<pre>apiVersion: v1 
data: 
  something: else 
  weather: sunny 
kind: ConfigMap 
metadata: 
  name: my-config 
  ... </pre>
<p>Just as with any other Kubernetes object, ConfigMap has <kbd>apiVersion</kbd>, <kbd>kind</kbd>, and <kbd>metadata</kbd>. The data is where the maps are defined. Each must have a key and a value. In this example, there's the key <kbd>weather</kbd> with the value <kbd>sunny</kbd>.</p>
<p>Let's try to translate that knowledge into the objects we'd need to deploy Prometheus.</p>
<pre><strong>cat cm/prometheus.yml</strong>  </pre>
<p>The output, limited to the relevant parts, is as follows:</p>
<pre>apiVersion: apps/v1beta2 
kind: Deployment 
metadata: 
  name: Prometheus 
spec: 
  ... 
  template: 
    ... 
    spec: 
      containers: 
        ... 
        volumeMounts: 
        - mountPath: /etc/Prometheus 
          name: prom-conf 
      volumes: 
      - name: prom-conf 
        configMap: 
          name: prom-conf 
... 
apiVersion: v1 
kind: ConfigMap 
metadata: 
  name: prom-conf 
data: 
  prometheus.yml: | 
    global: 
      scrape_interval:     15s 
 
    scrape_configs: 
      - job_name: Prometheus 
        metrics_path: /prometheus/metrics 
        static_configs: 
          - targets: 
            - localhost:9090 </pre>
<p>The <kbd>Deployment</kbd> object defines the <kbd>volumeMount</kbd> that references the <kbd>prom-conf</kbd> Volume, which is a <kbd>configMap</kbd>. We saw quite a few similar examples before.</p>
<p>The <kbd>ConfigMap</kbd> object's <kbd>data</kbd> section has only one key (<kbd>prometheus.yml</kbd>). Once this ConfigMap is mounted as a volume, the name of the file will be the same as the key (<kbd>prometheus.yml</kbd>). The value has a bit of "special" syntax. Unlike the previous example where the value was a single word written directly after the colon, the structure of the value is now a bit more complex. To be more precise, it contains multiple lines. When working with a large value, we can start with the pipe sign (<kbd>|</kbd>). Kubernetes will interpret the value as "everything that follows, as long as it is indented." You'll notice that all the lines of the value are at least two spaces to the right of the beginning of the key (<kbd>prometheus.yml</kbd>). If you'd like to insert an additional key, all you'd need to do is to add it on the same level (indentation), as the other <kbd>prometheus.yml</kbd>.</p>
<p>Let's create the application and confirm that everything works as expected.</p>
<pre><strong>cat cm/prometheus.yml | sed -e \</strong>
<strong>    "s/192.168.99.100/$(minikube ip)/g" \</strong>
<strong>    | kubectl create -f -</strong>
    
<strong>kubectl rollout status deploy prometheus</strong>
    
<strong>open "http://$(minikube ip)/prometheus/targets"</strong>  </pre>
<p>We created the objects (with the help of <kbd>sed</kbd> transformations), we waited until the Deployment rolled out, and, finally, we opened the Prometheus targets screen in a browser. The result should be a green target towards Prometheus internal metrics.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A plea NOT to use ConfigMaps!</h1>
                </header>
            
            <article>
                
<p>ConfigMaps, in my experience, are overused.</p>
<p>If you have a configuration that is the same across multiple clusters, or if you have only one cluster, all you should do is include it in your Dockerfile and forget it ever existed. When there are no variations of a config, there's no need to have a configuration file. At least, not outside an immutable image. Unfortunately, that is not always the case. Heck, it's almost never the case. We tend to make things more complicated than they should be. That, among other things, often means an endless list configuration options hardly anyone ever uses. Still, some things usually do change, from one cluster to another, and we might need to look into alternatives to configurations baked into images.</p>
<p>Design your new applications to use a combination of configuration files and environment variables. Make sure that the default values in a configuration file are sensible and applicable in most use-cases. Bake it into the image. When running a container, declare only the environment variables that represent the differences of a specific cluster. That way, your configuration will be portable and simple at the same time.</p>
<p>What if your application is not new and it does not support configuration through environment variables? Refactor it so that it does. It shouldn't be hard to add the ability to read a few environment variables. Keep in mind that you don't need all the settings, but only those that differ from one cluster to another. It would be hard to imagine that such a trivial request would be complex or time-consuming. If it is, you might have more significant issues to fix before even thinking about putting your application into a container.</p>
<p>Still, configuration files will not disappear. No matter which strategy we choose, each image should have a copy of them with sensible default values. Maybe, we can put in an extra effort and change the application, so that configuration entries are loaded from two locations. That way, we can load the default values from one, and only the differences from the other. That would, at least, reduce the need to have to specify more than the minimum required for each cluster. In such a case, ConfigMap's <kbd>--from-literal</kbd> and <kbd>--from-env-file</kbd> sources are an excellent choice.</p>
<p>When everything else fails, the <kbd>--from-file</kbd> source is your friend. Just make sure that ConfigMap is not defined in the same file as the objects that mount it. If it is, it would mean that they could be used only inside one cluster. Otherwise, we'd be deploying the same config, and we should go back to the initial idea of having it baked into the image together with the application.</p>
<p>Do not let this pessimism discourage you from using ConfigMaps. They are very handy, and you should adopt them. My intent to discourage you from doing so had the intention of making you think of alternatives, not to tell you never to use ConfigMaps.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What now?</h1>
                </header>
            
            <article>
                
<p>The next chapter will explore something very similar to ConfigMaps. The significant difference is that we'll be more secretive this time.</p>
<p>For now, we'll destroy the cluster we used in this chapter.</p>
<pre><strong>minikube delete</strong> </pre>
<div class="packt_infobox">If you'd like to know more about ConfigMaps, please explore ConfigMap v1 core (<span class="URLPACKT"><a href="https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#configmap-v1-core" target="_blank">https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/#configmap-v1-core</a></span>) API documentation.</div>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/b59369c1-925f-4718-ac20-8ccb2113093f.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Figure 9-1: The components explored so far</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Kubernetes ConfigMaps compared to Docker Swarm configs</h1>
                </header>
            
            <article>
                
<p>The mechanisms behind Kubernetes ConfigMaps and Docker Swarm Configs are almost the same. At least, from the functional perspective. Both allow us to store some literal texts in the scheduler's internal data store, and both enable us to add them to containers. The syntax is equally simple and straightforward in both cases. Still, there are a few differences.</p>
<p>Docker is good at preventing people from doing silly things (the politically correct version of the word <em>stupid</em>). An example would be an attempt to delete a configuration. It cannot be deleted if there are Docker services that reference the configuration. Only after all the services that reference it are removed, are we allowed to remove the configuration source. Kubernetes, on the other hand, will let us delete a ConfigMap object without even a hint about the consequences.</p>
<p>Kubernetes ConfigMap, on the other hand, provides a wider variety of options. While a Docker Swarm configuration can be created only from a file or <kbd>stdin</kbd>, the Kubernetes equivalent can be generated from a file, from a directory, from a literal value, and from files with environment variables. Each of those sources can be used multiple times. We can even combine them. Further on, Kubernetes ConfigMaps can be converted not only to files, but also to environment variables. Flexibility and extra functionalities are available both at the source and the destination end-points.</p>
<p>Docker Swarm wins a user experience point. Kubernetes gains a star for providing more choices. Neither has a significant difference that would warrant a win, so I'm proclaiming it a <em>tie</em>.</p>
<p>There are many more features worthwhile comparing. We're not yet finished. Stay tuned for more.</p>


            </article>

            
        </section>
    </body></html>