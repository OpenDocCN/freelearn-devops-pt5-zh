- en: Git Fundamentals - Niche Concepts, Configurations, and Commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is a collection of short but useful tricks to make our Git experience
    more comfortable. In the first three chapters, we learned all the concepts we
    need to take the first steps into versioning systems using the Git tool; now it's
    time to go a little bit in depth to discover some other powerful weapons in the
    Git arsenal, and how to use them (without shooting yourself in the foot, preferably).
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting Git configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the first part of this chapter, you will learn how to enhance our Git configuration
    to better fit your needs and speed up the daily work: it''s time to become familiar
    with configuration internals.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Configuration options are stored in plain text files. The `git config` command
    is just a convenient tool to edit these files without the hassle of remembering
    where they are stored and opening them in a text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration levels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Git, we have *three configuration levels*:'
  prefs: []
  type: TYPE_NORMAL
- en: System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global (user-wide)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are different configuration files for every different configuration level.
  prefs: []
  type: TYPE_NORMAL
- en: You can basically set every parameter at every level, according to your needs.
    If you set the same parameters at different levels, the lowest-level parameter
    hides the top-level ones; so, for example, if you set `user.name` at the global
    level, it will hide the one eventually set up at the system level, and if you
    set it at the repository level, it will hide the one specified at the global level
    and the one eventually set up at the system level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure will help you to better understand these levels:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7680d0a-e844-4de0-8210-f85631aea0b5.png)'
  prefs: []
  type: TYPE_IMG
- en: System level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The system level contains **system-wide configurations**; if you edit the configuration
    at this level, *every user and every user's repository will be affected*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration is stored in the `gitconfig` file usually located in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: `C:\Program Files\Git\etc\gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: `/etc/gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS: `/usr/local/git/etc/gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To edit parameters at this level, you have to use the `--system` option; please
    note that it requires administrative privileges (for example, root permission
    on Linux and macOS).
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, as a rule of thumb, *editing the configuration at system level is discouraged*,
    in favor of per user configuration modification.
  prefs: []
  type: TYPE_NORMAL
- en: Global level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The global level contains **user-wide configurations**; if you edit the configuration
    at this level, *every user's repository will be affected*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration is stored in the `.gitconfig` file usually located in:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: `C:\Users\<UserName>\.gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: `~/.gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS: `~/.gitconfig`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To edit parameters at this level, you have to use the `--global` option.
  prefs: []
  type: TYPE_NORMAL
- en: Repository level
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The repository level contains **repository only configurations**; if you edit
    the configuration at this level, *only the repository in use will be affected*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This configuration is stored in the `config` file located in the `.git` repository
    subfolder:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Windows: `C:\<MyRepoFolder>\.git\config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Linux: `~/<MyRepoFolder>/.git/config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'macOS: `~/<MyRepoFolder>/.git/config`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To edit parameters at this level, you can use the `--local` option or simply
    avoid using any option, as this is the default one.
  prefs: []
  type: TYPE_NORMAL
- en: Listing configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get a list of all the configurations currently in use, you can run the `git
    config --list` command; if you are inside a repository, it will show all the configurations,
    from repository to system level. To filter the list, append optionally `--system`,
    `--global` or `--local` options to obtain only the desired level configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Editing configuration files manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even if it is generally discouraged, you can modify Git configurations directly
    by editing the files. Git configuration files are quite easy to understand, so
    when you look on the internet for a particular configuration you want to set,
    it is not unusual to find just the right corresponding text lines; the only little
    foresight in such cases is to back up files before editing them, just in case
    you mess with them. In the following paragraphs, we will try to make some changes
    in this manner.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up some other environment configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Git can be a painful experience if you are not able to place it conveniently
    inside your work environment. Let's start to shape some rough edges using a bunch
    of custom configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Basic configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we have seen that we can change a Git variable value using
    the `git config` with the `<variable.name> <value>` syntax. In this section, we
    will make use of the `config` command to vary some Git behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Typos autocorrection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, let''s try to fix an annoying question about typing command: *typos*. I
    often find myself re-typing the same command two or more times; Git can help us
    with embedded *autocorrection*, but we first have to enable it. To enable it,
    you have to modify the `help.autocorrection` parameter, defining how many tenths
    of a second Git will wait before running the assumed command; so giving a `help.autocorrect
    10`, Git will wait for a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: To abort the auto-correction, simply type *Ctrl*+*C*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know about configuration files, you can note that the parameters
    we set by the command line are in this form: `section.parameter_name`. You can
    see the section names within `[]` if you look in the configuration file; for example,
    in `C:\Users\<UserName>\.gitconfig`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2c3bbdd3-ff34-48e6-9d10-366af70ee2cb.png)'
  prefs: []
  type: TYPE_IMG
- en: Push default
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already talked about the `git push` command and its default behavior. To
    avoid annoying issues, it is good practice to set a more convenient default behavior
    for this command.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two ways we can do this. First one: set Git to ask us the name of
    the branch we want to push every time, so a simple `git push` will have no effect.
    To obtain this, set `push.default` to `nothing`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, now Git pretends that you specify the target branch at every
    push.
  prefs: []
  type: TYPE_NORMAL
- en: This is maybe too restrictive, but at least you can avoid common mistakes such
    as pushing some personal local branches to the remote, thus generating confusion
    in the team.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to save yourself from this kind of mistake is to set the `push.default`
    parameter to `simple`, allowing Git to push only when there is a remote branch
    with the same name as the local one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will push the local tracked branch to the remote.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the default editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some people really don''t like `vim`, even only for writing commit messages;
    if you are one of them, there is good news: you can change it by setting the `core.default`
    config parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, you can set nearly all available text editors on the market. If you
    are a Windows user, remember that the full path of the editor has to be in the
    `PATH` environment variable; basically, if you can run your preferred editor by
    typing its executable name in a DOS shell, you can use it even in a Bash shell
    with Git.
  prefs: []
  type: TYPE_NORMAL
- en: Other configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can browse a wide list of other configuration variables at [git-scm.com/docs/git-config](http://git-scm.com/docs/git-config).
  prefs: []
  type: TYPE_NORMAL
- en: Git aliases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already mentioned Git aliases and their purpose; in this section, I will
    suggest only a few more, to help make things easier.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcuts to common commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing you may find useful is to *shorten common commands* such as `git
    checkout` and so on; therefore, useful aliases can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Another common practice is to shorten a command, adding one or more options
    you use all the time; for example, set a `git cm <commit message>` command shortcut
    to the alias `git commit -m <commit message>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Creating commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common way to customize your Git experience is to *create commands*
    you think should exist.
  prefs: []
  type: TYPE_NORMAL
- en: git unstage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The classic example is the `git unstage` alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'With this alias, you can remove a file from the index in a more meaningful
    way, compared to the equivalent `git reset HEAD -- <file>` syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Now behaves the same as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: git undo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Want a fast way to revert the last ongoing commit? Create a `git undo` alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You can obviously use `--hard` instead of `--soft`, or go with the default `--mixed`
    option.
  prefs: []
  type: TYPE_NORMAL
- en: git last
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `git last` alias is useful to read about your last commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: git difflast
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With the `git difflast` alias, you can see a `diff` against your last commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Advanced aliases with external commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you want the alias to run external shell commands, instead of a Git sub-command,
    you have to prefix the alias with a `!`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you are annoyed by the canonical `git add <file>` plus `git commit
    <file>` sequence of commands, and you want to do it in a single shot; you can
    call the `git` command twice in sequence by creating this alias:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: With this alias you commit a file, adding it before if necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Have you noted that I set the `cm` alias again? If you set an already configured
    alias, the previous alias will be overwritten.
  prefs: []
  type: TYPE_NORMAL
- en: There are also aliases that define and use complex functions or scripts, but
    I'll leave it to the curiosity of the reader to explore these aliases. If you
    are looking for inspiration, take a look at this GitHub repository at [https://github.com/GitAlias/gitalias](https://github.com/GitAlias/gitalias).
  prefs: []
  type: TYPE_NORMAL
- en: Removing an alias
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Removing an alias is quite easy; you have to use the `--unset` option, specifying
    the alias to remove. For example, if you want to remove the `cm` alias, you have
    to run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that you have to specify the configuration level with the appropriate option;
    in this case, we are removing the alias from the user (`--global`) level.
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing the git command itself
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'I''ve already said I''m a bad typist; if you are too, you can alias the git
    command itself (using the default `alias` command in Bash):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, you will save some other keyboard strokes. Note that this is
    not a Git alias, but a Bash shell alias.
  prefs: []
  type: TYPE_NORMAL
- en: Useful techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will improve our skills, learning some techniques that will
    come in handy in different situations.
  prefs: []
  type: TYPE_NORMAL
- en: Git stash - putting changes temporally aside
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It sometimes happens that you need to switch branches for a moment, but some
    changes are in progress in the current branch. To put aside those changes for
    a while, we can use the `git stash` command: let''s give it a try in our `grocery`
    repository.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Append a new fruit to the shopping list, then try to switch branch; Git won''t
    allow you to do so, because with the checkout you would lose your local (not yet
    committed) changes to the `shoppingList.txt` file. So, type the `git stash` command;
    your changes will be set apart and removed from your current branch, letting you
    switch to another one (`berries`, in this case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'How does `git stash` work? Actually, `git stash` is a fairly complex command.
    It basically saves from two up to three different commits:'
  prefs: []
  type: TYPE_NORMAL
- en: A new *WIP commit* containing the actual state of the working copy; it contains
    all the tracked files, and their modifications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An *index commit*, as a parent of the WIP commit. This contains stuff added
    to the staging area.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An optional third commit, let's call it an *untracked files commit*, which contains
    untracked files (using the `--include-untracked` option) or untracked plus previously
    ignored files (using the `--all` option).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the actual situation in our repository using the `git
    log` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in this case there are only two commits. The *WIP commit*, `fedc4cf`,
    is the one with the message starting with *WIP on master*, where `master` is of
    course the branch where `HEAD` was at the time of the `git stash` command run.
    The *index commit*, `7312ff0`, is the one with the message starting with *index
    on master*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *WIP commit* contains the unstaged changes made to tracked files; as you
    can see, the *WIP commit* has two parents: one is the *index commit*, containing
    staged changes, the other is the last commit on the `master` branch, where `HEAD`
    was and where we run the `git stash` command.'
  prefs: []
  type: TYPE_NORMAL
- en: With all this shelved information, Git can then re-apply your work on top of
    the `master` branch when you finish your job on the `berries` branch; a stash
    can be applied wherever you want, and more than once if you like.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `git stash` command, we actually used the `git stash save` subcommand,
    the default option. The `save` subcommand saves changes to tracked files only,
    using a default set of messages for these *special commits* we see.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve a stash, the command is `git stash apply <stash>`; it applies changes
    within the two commits, eventually modifying your working copy and staging area.
    The stash will not be deleted after the apply; you can do it manually using the
    `git stash drop <stash>` subcommand. Another way implies the `git stash pop <stash>`
    subcommand: it applies the stash and then deletes it.'
  prefs: []
  type: TYPE_NORMAL
- en: While using these subcommands, you can refer to the various stashes you did
    in the past using different notations; the most common is `stash@{0}`, where `0`
    means *the last stash you did*. To retrieve the penultimate, you can use `stash@{1}`
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make a complete example, let''s drop the actual stash without applying it,
    and then do a new one following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Drop the last stash created using `git stash drop` (`git stash clear` drops
    all the stashes).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Append a new fruit to the shopping list (for example, a plum) and add it to
    the staging area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then add another one (for example, a pear) but avoid adding it to the staging
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now create a new untracked file (for example, `notes.txt`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new stash using `-u` (the `--include-untracked` option).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is the complete list of commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, let''s see what happened using the `git log` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this time there is one more commit, the *untracked files* one:
    this commit contains the `notes.txt` file, and figures as an additional parent
    for the *WIP commit*.'
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing, you basically use the `git stash save` command (with the `-u` or
    `--all` option if needed) to shelve your modification and then `git stash apply`
    to retrieve them; I suggest using `git stash apply` and then `git stash drop`
    instead of `git pop` to have a chance to redo your stash application when needed,
    or when your stash is not as trivial as usual.
  prefs: []
  type: TYPE_NORMAL
- en: To take a look at all the options for this command, please refer to the `git
    stash --help` output.
  prefs: []
  type: TYPE_NORMAL
- en: Git commit amend - modify the last commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This trick is for people that don''t double-check what they''re doing. If you
    have pressed the enter key too early, there''s a way to modify the last commit
    message or add that file you forgot, using the `git commit` command with the `--amend`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Please note that with the `--amend` option, you are actually re-doing the commit,
    which will have a new hash; if you already pushed the previous commit, changing
    the last commit is not recommended - rather, it is deplorable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you amend an already pushed commit, then push the new one, you are basically
    discarding the latest commit on a branch, replacing it with the newly amended
    one: for those who will pull the branch, this can lead to some confusion, as they
    will see their local branch losing the last commit, replaced by a new one.'
  prefs: []
  type: TYPE_NORMAL
- en: Git blame - tracing changes in a file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working on source code in a team, it is not uncommon to have the need to look
    at the last modifications made to a particular file to better understand how it
    evolved over time. To achieve this result, we can use the `git blame <filename>`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try it inside the `Spoon-Knife` repository to see changes made to the
    `README.md` file during a specific time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the result reports all the affected lines of the `README.md`
    file; for every line, you can see the commit hash, the author, the date, and the
    row number of the text file lines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose now you found that the modification you are looking for is the one
    made in the `d0dd1f61` commit; to see what happened there, type the `git show
    d0dd1f61` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `git show` command is a multi-purpose command that can show to you one or
    more objects; in this case, we have used it to show the modification made in a
    particular commit using the `git show <commit-hash>` format.
  prefs: []
  type: TYPE_NORMAL
- en: The `git blame` and `git show` commands have a quite long list of options; the
    purpose of this section is to only point the reader to the way they can trace
    changes on a file; you can inspect other possibilities using the ever-useful `git
    <command> --help` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last tip I want to suggest is to use the Git GUI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/3c4f9e4e-bdb1-4280-a6b9-c95c0f2d379b.png)'
  prefs: []
  type: TYPE_IMG
- en: With the help of the GUI, things are even easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, I would like to suggest just a bunch of tips and tricks I have
    found useful in the past.
  prefs: []
  type: TYPE_NORMAL
- en: Bare repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Bare repositories are repositories that do not contain working copy files,
    but only the `.git` folder. A bare repository is essentially *for sharing*: if
    you use Git in a centralized way, pushing and pulling to a common remote (a local
    server, a GitHub repository, and so on), you will agree that the remote has no
    interest in checking out files you work on; the scope of that remote is only to
    be a central point of contact for the team, so having working copy files in it
    is only a waste of space as no one will edit them directly on the remote.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to set up a bare repository, you only have to use the `--bare`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As you may have noticed, I called it `NewRepository.git`, using a `.git` extension;
    this is not mandatory, but is a common way to identify bare repositories. If you
    pay attention, you will note that even in GitHub every repository ends with a
    `.git` extension.
  prefs: []
  type: TYPE_NORMAL
- en: Converting a regular repository to a bare one
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It can happen that you start working on a project in a local repository, and
    then you feel the need to move it to a centralized server to make it available
    for other people or from other locations.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily convert a regular repository to a bare one using the `git clone`
    command with the same `--bare` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this manner, you have a 1:1 copy of your repository in another folder, but
    in a bare version, ready to be pushed.
  prefs: []
  type: TYPE_NORMAL
- en: Backup repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you need a backup, there are two commands you can use: one for archiving
    only files and one for backing up the entire bundle, including versioning information.'
  prefs: []
  type: TYPE_NORMAL
- en: Archiving the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To archive the repository without including versioning information, you can
    use the `git archive` command; there are many output formats but the classic one
    is the `.zip` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note that using this command is not the same as backing up folders in
    a filesystem; as you will have noticed, the `git archive` command can produce
    archives in a smarter way, including only files in a branch or even in a single
    commit; for example, by doing this you are archiving only the last commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Archiving files in this way can be useful if you have to share your code with
    people that don't have Git installed.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another interesting command is the `git bundle` command. With `git bundle`,
    you can export a snapshot from your repository and then restore it wherever you
    want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you want to clone your repository on another computer, and the network
    is down or absent; with this command, you can create a `repo.bundle` file of the
    `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With this other command, we can restore the bundle in the other computer using
    the `git clone` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we enhanced our knowledge about Git and its wide set of commands.
    We discovered how configuration levels work, and how to set our preferences using
    Git by, for example, adding useful command aliases to the shell. Then we looked
    at how Git deals with stashes, providing the way to shelve then and reapply changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, we added some other techniques to our skill set, learning some
    things we will use as soon as we start to use Git extensively. Some simple tricks
    provide a way to stimulate the curiosity of the reader: Git has a lot more commands
    to explore.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will leave the console for a while, and talk about strategies
    to better organize our repositories. We will try to learn how to make significant
    commits, and we will get to know some of the adoptable flows to reconcile Git
    with our way of working.
  prefs: []
  type: TYPE_NORMAL
