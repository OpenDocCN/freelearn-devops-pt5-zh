- en: Introduction to Docker Content Trust
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn about the Docker Content Trust concept and its
    related tools. To provide trusted content in Docker environments, we will use
    Docker Content Trust to encrypt metadata information applied to Docker objects.
    Therefore, any unauthorized changes or object manipulation will be reported. We
    will be able to ensure that all the objects in our environment are trusted if
    none of these issues are found.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will introduce The Update Framework, and then we will learn how to
    sign images. After that, we will learn how to verify signatures to ensure their
    precedence and ownership. Finally, we will apply those concepts to run a trusted
    environment in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: The Update Framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reviewing signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and running applications in trusted environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn about various Docker Content Trust concepts.
    We''ll provide some labs at the end of this chapter that will help you understand
    and learn about the shown concepts. These labs can be run on your laptop or PC
    using the provided Vagrant standalone environment or any already-deployed Docker
    host deployed by yourself. You can find additional information in this book''s
    GitHub code repository: [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '"[https://bit.ly/3b0qviR](https://bit.ly/3b0qviR)"'
  prefs: []
  type: TYPE_NORMAL
- en: The Update Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before learning about **The Update Framework**, also known as **TUF**, we will
    introduce a number of concepts. The following concepts will help us understand
    why we need tools to manage application updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Software update system**: A software update system is an application that
    looks for new updates continuously. When they are found, it triggers processes
    to get these updates and installs these changes. A good example is the Google
    Chrome web browser update system. It continuously looks for its components'' updates
    and, once they are found, it will show us a There is a new release, do you want
    to update now? message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Library package managers**: The library package managers will manage and
    update programming language libraries and their dependencies. Python''s **Package
    Installer for Python** (**PIP**) and Node.js''s **Node Package Manager** (**NPM**)
    are good examples. These applications look for library updates and install them
    with their requisite dependencies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operating system component updates**: In this case, different package managers
    will manage all software updates and their dependencies, triggering, in some cases,
    some of the aforementioned solutions (software update systems or library package
    managers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An application update usually takes three logical steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It looks for any update or change.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It downloads updates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It applies changes to our system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What would happen if those updates were malicious because the code was intercepted
    and modified by an attacker?
  prefs: []
  type: TYPE_NORMAL
- en: TUF was created to prevent these situations. It will handle the steps described
    for application updates to ensure that downloaded changes are trusted. No manipulated
    changes will be allowed. TUF metadata includes information related to trusted
    keys, cryptographic hashes and files, component versions, creation and expiration
    dates, and signatures. An application that requires a number of updates does not
    have to manage this verification process. It will ask TUF to manage these processes.
    To summarize, we can say, in a way, that TUF provides a secure method of obtaining
    trusted files.
  prefs: []
  type: TYPE_NORMAL
- en: TUF is currently hosted by the Linux Foundation as part of the **Cloud Native
    Computing Foundation** (**CNCF**). It is open source and can be used in production
    environments. It is recommended to use this in conjunction with some vendor tools
    because it will be easier to manage and use.
  prefs: []
  type: TYPE_NORMAL
- en: 'TUF metadata provides information about the truthfulness of the update to the
    software update system. This component will then make the right decision (install
    or reject the update). This metadata information will be presented in JSON format.
    We will talk about four levels of signing. We will refer to them as roles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root metadata (**`root.json`**) and role**: This role is related to the owner
    of the change. It is the top role; others will be related to this one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Targets metadata (**`targets.json`**) and role**: This role is related to
    the files included in the package.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Snapshot metadata (**`snapshot.json`**) and role**: All files apart from
    `timestamp.json` will be listed on this role to ensure the consistency of updates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timestamp metadata (**`timestamp.json`**) and role**: This sign will ensure
    the exact date of the update and that it is the only one required when checking
    for updates, for example.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The update application uses TUF to interact with the repositories and sources
    of files while managing their updates. Roles, trusted keys, and target files should
    not be included in those repositories because they will be used to manage them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There should be a client side on this framework so that we can include the
    roles described in its normal usage. Therefore, a client side must manage the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Trusted root keys, from all possible owners that must be trusted
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Target delegation, when there is a target with many owners
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for updates using timestamp role dates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All signing processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we know the benefits of using TUF to manage repository updates, let's
    review how this is implemented in Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Content Trust is the Docker implementation of TUF. It is integrated using
    Notary, which is an open source tool for publishing and managing trusted content.
    The Docker client provides an interface that allows us to sign and verify content
    publishers.
  prefs: []
  type: TYPE_NORMAL
- en: Notary is a separate piece of software; it can be downloaded and used to inspect
    keys included in a Docker registry. Docker integrates Notary using its library.
    Therefore, every time we pull an image when Docker Content Trust is enabled (disabled
    by default), the Docker daemon will validate its signatures. Image pulling is
    done by its digest. Image names and tags will not be used. This ensures that only
    the right image will be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notary usage is beyond the scope of this book. At the time of writing, it is
    not required in order to pass the DCA certification exam. It is recommended, however,
    to read about some of the Notary features provided at the following link: [https://docs.docker.com/notary/getting_started](https://docs.docker.com/notary/getting_started).'
  prefs: []
  type: TYPE_NORMAL
- en: When we use Docker Content Trust and we push an image, the Docker client will
    ask us to sign at all the levels described (root, target, snapshot, and timestamp).
  prefs: []
  type: TYPE_NORMAL
- en: 'In summary, Docker Content Trust (Docker''s TUF implementation) will do the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure image provenance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sign content prior to distribution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that everything running on a host is trusted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, we will learn how to sign and use signed images that have
    been validated by Docker Engine.
  prefs: []
  type: TYPE_NORMAL
- en: Signing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have learned about the different roles and the metadata information
    that will be used to validate and trust image content. Let''s look at a quick
    summary before getting into the Docker signing action:'
  prefs: []
  type: TYPE_NORMAL
- en: The root key will validate other keys. It signs the `root.json` file, which
    contains the list of IDs of the root, targets, snapshot, and timestamp public
    keys. To verify content signatures, the Docker client will use these public keys.
    The root key is offline and must be kept safe. The owner of a collection of images
    should maintain this key. Don't lose this key. You can recreate it, but all your
    signed images will be invalid.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target key signs the `targets.json` file, which contains a list of your
    content filenames, along with their sizes and hashes. This file is used to delegate
    trust to other users in a team so that others can sign the same repository. This
    key is held by administrators and owners of a collection (repository).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The delegation key is used to sign delegation metadata files. This key is held
    by administrators and everyone who can contribute to the specified collection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The snapshot key signs the `snapshot.json` metadata file. This file also contains
    filenames, as well as the sizes and hashes of root, targets, and delegation files
    in the collection. This key will be held by administrators and the collection
    owner. If we use the Notary service, this key can also be held by this service
    to allow signing by collection collaborators. This key represents the current
    package signature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The timestamp key ensures the freshness of the collection. It is used to verify
    the integrity of the `snapshot.json` file. Because this key is only valid for
    a period of time, it is better to be held in Notary. In this case, it will not
    be necessary that owners recreate the key each time it expires. Notary will regenerate
    this key as needed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's sign an image using the Docker client.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will enable Docker Content Trust. By default, it is not enabled.
    We can enable it for all Docker commands or add an argument each time we want
    to enable it. To enable Docker Content Trust for all subsequent Docker commands,
    we need to define the `DOCKER_CONTENT_TRUST` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can enable Docker Content Trust for only specified commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We used `--disable-content-trust=false` here because, by default, Docker Content
    Trust is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have enabled Docker Content Trust for all commands in this session
    by setting `DOCKER_CONTENT_TRUST= 1`, we can pull an image using `docker image
    pull`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `docker image pull` command's output changed. In fact, the downloaded
    image was managed by its hash; in this case, `busybox@sha256:1303dbf110c57f3edf68d9f5a16c082ec06c4cf7604831669faf2c712260b5a`.
  prefs: []
  type: TYPE_NORMAL
- en: Docker's official images and certified images are always signed. Official images
    are managed and built by Docker, and they are located under `docker.io/<REPOSITORY>:<TAG>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s run this image using `docker container run` and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It worked, as expected. We added a file because we wanted to modify a container
    before committing its content to create a new, untrusted image. For this process,
    we will run `docker container commit`, setting `DOCKER_CONTENT_TRUST=0` for the
    command. We do this because Content Trust was previously enabled in our current
    session:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have an untrusted `busybox`image. What will happen if we try to execute
    this image?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We cannot run this image because it is not trusted; it does not have any content
    trust metadata. Therefore, it cannot be validated and will not be allowed to run.
    If Docker Content Trust is enabled, unsigned images will not be allowed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s sign this image. In this case, we will change the image name and create
    a new `trusted` tag. The signing process requires two passphrases, as described
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we will be asked to set a `root` passphrase. You will be asked twice
    to validate the password that's entered as it is not shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, you will be asked to set a `repository` passphrase. You will be asked
    twice again to validate the password that's entered as it is not shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have been asked for the passphrase twice because we are setting their values
    for the first time. Next time we use these keys to push or pull to this repository,
    we will be asked just once (or more if it was typed in incorrectly). Let''s execute
    `docker image push`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The root passphrase is very important. Keep it safe because if you lose it,
    you will need to start again. If this happens, your already-signed images will
    be untrusted and you will need to update them. If you lose a key, you will need
    to contact Docker Support (`support@docker.com`) to reset the repository state.
  prefs: []
  type: TYPE_NORMAL
- en: The passphrases you choose for both the root key and your repository should
    be strong. It is recommended to use randomly generated ones.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have a signed image. It is owned by us (in this example, I am the owner
    of `frjaraur/mybusybox:trusted`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can execute this newly signed (and hence trusted) image using `docker
    container run`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To manage Docker Content Trust, we can use `docker trust` with its available
    actions. We will be able to manage keys (load and revoke) and sign images (this
    process is similar to the one previously described). We can review these signatures
    using `docker trust inspect`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have used `docker.io/frjaraur/mybusybox:trusted` instead of `frjaraur/mybusybox:trusted`.
    This is because if we do not use the registry's **fully qualified domain name**
    (**FQDN**) and the image exists locally, it will be used to retrieve all signature
    information and you will receive a `WARN[0006] Error while downloading remote
    metadata, using cached timestamp - this might not be the latest version available
    remotely` message because you will be using the cached timestamp instead of the
    real one.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have learned how to sign content – in this case, images – let's
    move on and learn how to verify signatures.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing signatures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker client stores content trust-related files under the `.docker/trust`
    directory, inside the user's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we navigate to the trusted directory, we will find different registry files
    under `.docker/trust/tuf`. We used Docker Hub in this chapter''s examples. Therefore,
    we will find the `docker.io` registry and different repositories. This may vary
    in your environment; you may have more registries or repositories. It will depend
    on when you started to use Docker Content Trust in your Docker host. Using the
    examples from the previous sections, we will find a tree-like directory structure
    under the `.docker` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Remember the JSON files described in the previous section. All these files are
    located under each registry and repository's structure.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client will store your keys under your `.docker/trust/private` directory.
    It is very important to keep them safe. To back up these keys, use the `$ umask
    077; tar -zcvf private_keys_backup.tar.gz ~/.docker/trust/private; umask 022`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Notary will assist us in managing signatures. It is an open source server and
    client application and can be downloaded from its GitHub project page ([https://github.com/theupdateframework/notary](https://github.com/theupdateframework/notary)).
  prefs: []
  type: TYPE_NORMAL
- en: Notary can be installed either on Linux or Windows hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will simply download the latest release using the `curl` command and modify
    its permissions and path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In this section, we will use Docker's own Notary server that's been published
    on the internet ([https://notary.docker.io](https://notary.docker.io)) and that
    is associated with Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Enterprise will run its own Docker Notary server implementation in your
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify, for example, all the signatures associated with a Docker Hub
    repository. In this example, we are reviewing the `busybox` repository. We use
    `notary list` with the appropriate server and directory arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We listed all the targets on a remote trusted collection – in this case, the
    `busybox` collection on Docker Hub (`docker.io/library/busybox`).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's learn how to automate these processes and ensure security to build
    a trusted environment in our organization.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and running applications in trusted environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will consider a trusted environment where `CONTENT_TRUST_ENABLED`
    is used for all actions. This will ensure that images built in that environment
    will always be signed. All images that have been pushed and pulled will be signed,
    and we will only run containers based on trusted images.
  prefs: []
  type: TYPE_NORMAL
- en: It is interesting to add CI/CD orchestration tools to these processes. It is
    not easy to disallow non-trusted content without some system or even higher security
    policies. If we set the `DOCKER_CONTENT_TRUST` value to only allow Docker Content
    Trust, but users are allowed to interact with the Docker host directly, they can
    disable this feature at the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Automation is key in production environments, although it is true that Docker
    Enterprise provides other methods, which we will discuss later on in [Chapter
    12](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal Control Plane*. Kubernetes
    also provides features to force security for trusted content, but this topic is
    beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using an external CI/CD, we can automate the building, sharing, or deployment
    of Docker content. Let''s look at a brief example of building and pushing an image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We can write a script for a CI/CD orchestration job using the `root` and `repository`
    passphrases to ensure that content trust is applied during building and pushing
    to our registry. We can follow the same method to deploy on production, disallowing
    any user interaction with this secure environment. Take care of environment variables
    for passphrases on scripts because they will be visible. CI/CD orchestrators will
    provide secure methods to manage this. This will give you an idea of how you should
    implement a secure chain with your own management configuration tools.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's review a lab to better understand the topics we've learned in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter labs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now complete a lab that will help us improve on the concepts we've learned
    about.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy `environments/standalone-environment`from this book's GitHub repository
    ([https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git))
    if you have not done so yet. You can use your own CentOS 7 server. Use `vagrant
    up` from the `environments/standalone-environment`folder to start your virtual
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are using a standalone environment, wait until it is running. We can
    check the statuses of our nodes using `vagrant status`. Connect to your lab node
    using `vagrant ssh standalone`. `standalone` is the name of your node. You will
    be using the `vagrant` user with root privileges using `sudo`. You should get
    the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now connect to a standalone node using `vagrant ssh standalone`. This
    process may vary if you''ve already deployed a standalone virtual node before
    and you''ve just started it using `vagrant up`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are reusing your standalone environment, this means Docker Engine is
    installed. If you started a new instance, please execute the `/vagrant/install_requirements.sh`
    script so that you have all the required tools (Docker Engine and `docker-compose`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, you are ready to start the labs.
  prefs: []
  type: TYPE_NORMAL
- en: Signing images for Docker Hub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, sign in to [https://hub.docker.com/signup](https://hub.docker.com/signup)
    to create your own account at Docker Hub if you do not already have one. You can
    use your own registry, but you should have a Notary server running. Let''s get
    started:'
  prefs: []
  type: TYPE_NORMAL
- en: This lab will use the `frjaraur/pingo` repository in Docker Hub. You must substitute
    `frjaraur` with your username.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this lab, we will start from the very beginning. This is a lab, so don''t
    remove your own `.docker/trust` directory if you have been signing images beforehand.
    In that case, back up your trust directory somewhere safe so that you can recover
    it later or just create a dummy user in your Docker host system. To create this
    backup, we will just execute `cp -pR ~/.docker/trust ~/.docker/trust.BKP`. After
    these labs, you can recover it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, enable Docker Content Trust and create a directory for this lab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We have prepared a quite-simple Dockerfile, executing `ping` to `8.8.8.8` for
    `300` times. These lab files can be found in the `chapter6` directory if you have
    downloaded the book samples from this book''s GitHub repository. Create a `Dockerfile`
    file with the following content using your file editor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can build the image. Remember that Docker Content Trust was enabled.
    We will use `docker image build` in the directory where you wrote your Dockerfile:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed new messages from the Docker daemon. The daemon used the
    `alpine:3.8` image hash, `sha256:04696b491e0cc3c58a75bace8941c14c924b9f313b03ce5029ebbc040ed9dcd9`,
    instead of the image name and tag. If we had an image locally with the same `image:tag`
    values, it would have been verified. If the hash did not match, it would have
    been avoided and the real image would have been downloaded from Docker Hub. This
    will ensure that the trusted `alpine:3.8` image will be downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will sign this image using `docker trust sign`. This process will ask
    us to create a `root` passphrase, a `repository` passphrase, and a `user` passphrase
    (this is new in this chapter because we did not use Docker Content Trust in previous
    chapters). This will create a new `trust` directory under `.docker`*.* When the
    image is pushed, you will be asked about your registry user passphrase again.
    This is not your Docker Hub password. This is the passphrase you created so that
    you can perform signing. We will use `docker trust sign`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'With that, the image was signed and pushed to Docker Hub. We can verify that
    the image was uploaded by using `curl`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will review the image signatures using `docker trust inspect`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's look at a brief summary of the topics that were covered in this chapter
    before we look at some questions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Content Trust helps us guarantee content security in container environments
    and ensure image provenance and trusted content. In production environments, it
    is critical to be able to ensure that any running container was generated from
    trusted content. If image security cannot be validated, no container should be
    allowed to run based on that image.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned that Content Trust improves Docker repository security by means
    of four fundamental keys. The root key ensures ownership and the targets key will
    allow content to be verified in specific collections or repositories. These keys
    will be protected by passphrases and we will be asked for them when signing. The
    snapshot and timestamp keys will not require any user interaction and will be
    generated automatically to guarantee the content key files and the dates and expiration
    of the signed image.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concept of orchestration. We will
    review all the features required to manage container-based applications in distributed
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these sentences is not true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Docker Content Trust is based on TUF.
  prefs: []
  type: TYPE_NORMAL
- en: b) TUF was developed to ensure software updating processes.
  prefs: []
  type: TYPE_NORMAL
- en: c) It is not possible to validate new software releases.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the preceding statements are false.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following names represent Docker Content Trust keys used to validate
    image content?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Targets
  prefs: []
  type: TYPE_NORMAL
- en: b) Users
  prefs: []
  type: TYPE_NORMAL
- en: c) Groups
  prefs: []
  type: TYPE_NORMAL
- en: d) Timestamp
  prefs: []
  type: TYPE_NORMAL
- en: How can we ensure that the `busybox:latest` release is, in fact, the latest
    one?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We cannot ensure the freshness of images.
  prefs: []
  type: TYPE_NORMAL
- en: b) `busybox:latest` indicates that this image is the latest one created.
  prefs: []
  type: TYPE_NORMAL
- en: c) Content Trust will validate the freshness of images; therefore, we can ensure
    that the host really executes the `busybox:latest` image, although we cannot ensure
    that it is the latest one.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the preceding statements are false.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why will we obtain a `denied: requested access to the resource is denied` error
    when trying to sign `busybox:trusted`?'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) This image does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: b) We are not allowed to modify that repository.
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Content Trust was probably not enabled.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the preceding.
  prefs: []
  type: TYPE_NORMAL
- en: We lost our root key because we changed our laptop. Which of the following statements
    is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) If we don't have a key under `.docker/trust/private`, a new one will be generated
    when signing.
  prefs: []
  type: TYPE_NORMAL
- en: b) We can recover the private root key if we perform a backup.
  prefs: []
  type: TYPE_NORMAL
- en: c) If we generate a new key, our old images will become untrusted and we will
    need to resign them.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the preceding statements are true.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following links for more information on the topics that
    were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TUF: [https://theupdateframework.io/](https://theupdateframework.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'TUF specification: [https://github.com/theupdateframework/specification](https://github.com/theupdateframework/specification)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Notary: [https://github.com/theupdateframework/notary](https://github.com/theupdateframework/notary)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Content Trust: [https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
