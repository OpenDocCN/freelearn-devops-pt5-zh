<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-188"><a id="_idTextAnchor566"/>13</h1>
<h1 id="_idParaDest-189"><a id="_idTextAnchor567"/>Scanning Your Ansible Playbooks</h1>
<p>In this chapter, you will learn how to scan your Ansible playbooks using two third-party tools: Checkov and KICS. Both are open source and can help you identify and fix common configuration issues within your Ansible code, such as syntax errors, misconfigurations, hardcoded secrets, and deployment problems, which could lead to potential breaches.</p>
<p>By the end of this chapter, you will have done the following:</p>
<ul>
<li>Installed and run Checkov and KICS scans on our Ansible playbooks</li>
<li>Reviewed the results and reports generated during the scans</li>
<li>Fixed any issues detected during the scans</li>
</ul>
<p>The chapter covers the following topics:</p>
<ul>
<li>Why scan your playbooks?</li>
<li>Docker overview and installation</li>
<li>Exploring Checkov</li>
<li>Exploring KICS</li>
</ul>
<h1 id="_idParaDest-190"><a id="_idTextAnchor568"/>Technical requirements</h1>
<p>Rather than installing the tools locally, we will use Docker to execute the scans; there will be a little detail on how to install Docker later in the chapter. Additionally, we will be scanning a variation of the playbook we wrote in <a href="B21620_11.xhtml#_idTextAnchor501"><em class="italic">Chapter 11</em></a>, <em class="italic">Highly Available Cloud Deployments</em>; this can be found in the repository at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter13">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter13</a>.</p>
<h1 id="_idParaDest-191"><a id="_idTextAnchor569"/>Why scan your playbooks?</h1>
<p>While we have been taking<a id="_idIndexMarker730"/> a sensible approach to deploying our cloud resources in previous chapters, many of the guardrails we have put in place have all been ones I have learned through experience and by applying a little common sense.</p>
<p>For example, when launching a virtual machine resource in either Microsoft Azure or Amazon Web Services, we have been locking down the SSH or RDP service to the host’s public IP address, which is running Ansible; up until now, this has been your local machine rather than just opening SSH or RDP to the world by using <code>0.0.0.0/0</code> as the source address, which is the CIDR notation for <em class="italic">“</em><em class="italic">allow all.”</em></p>
<p>This is not a problem for the workloads we have been working on; having a virtual machine exposed directly to the internet with its management port open for everyone to access is not considered best practice, as it will expose you to brute-force attacks, which, if they are successful, will not only lead to that machine being compromised; it could also act as a gateway to the rest of your network and other associated resources such as databases and storage.</p>
<p>I would class the preceding example as common sense, but as we launch more and more cloud services using our playbooks, how can we ensure that we are following best practices for services that maybe we haven’t had much experience with outside of getting something up and running? How can we put some guardrails in place to stop us from doing something before resources are deployed?</p>
<p>This is where the two tools we will look at in this chapter come in; they are designed to scan your playbooks, look at the configuration, and compare them to their best practice policies. Eventually, in <a href="B21620_15.xhtml#_idTextAnchor641"><em class="italic">Chapter 15</em></a>, <em class="italic">Using Ansible with GitHub Actions and Azure DevOps</em>, we will build one of the two tools into our deployment pipelines, but for now, we are going to look at the tools and run them locally using Docker.</p>
<h1 id="_idParaDest-192"><a id="_idTextAnchor570"/>Docker overview and installation</h1>
<p>Docker, the platform that made<a id="_idIndexMarker731"/> containers popular, is both an open source and commercial solution that enables you to package all of the elements of your application, including libraries and other dependencies, alongside your own code in a single, easy-to-distribute package; this means that we won’t need to download and install all of the prerequisites for the tools that we will be running in this chapter or need to compile the tools<a id="_idIndexMarker732"/> from source to get working executables for our system.</p>
<p>To follow the example in this chapter, you must install <strong class="bold">Docker Desktop</strong> on your host.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor571"/>Installing Docker Desktop on macOS</h2>
<p>To install Docker Desktop<a id="_idIndexMarker733"/> on macOS, follow<a id="_idIndexMarker734"/> these three steps:</p>
<ol>
<li>Choose the appropriate installer for your Mac’s architecture:<ol><li class="upper-roman">For ARM64 (Apple Silicon), use <a href="https://desktop.docker.com/mac/main/arm64/Docker.dmg">https://desktop.docker.com/mac/main/arm64/Docker.dmg</a>.</li><li class="upper-roman">For AMD64 (Intel Macs), use <a href="https://desktop.docker.com/mac/main/amd64/Docker.dmg">https://desktop.docker.com/mac/main/amd64/Docker.dmg</a>.</li></ol></li>
<li>After downloading, open the <code>Docker.dmg</code> file by double-clicking it. In the opened window, drag the Docker icon to your Applications folder to install Docker Desktop. It will be installed at <code>/Applications/Docker.app</code>.</li>
<li>To launch Docker, navigate to the Applications folder and double-click on <strong class="bold">Docker</strong>; this will start <strong class="bold">Docker Desktop</strong>.</li>
</ol>
<p>When you first launch Docker Desktop, it will walk you through the remaining installation steps and run in the background once compl<a id="_idTextAnchor572"/>ete.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor573"/>Installing Docker Desktop on Windows</h2>
<p>To install Docker Desktop<a id="_idIndexMarker735"/> on Windows, follow these<a id="_idIndexMarker736"/> instructions:</p>
<ol>
<li>Download the Docker Desktop Installer for Windows<a id="_idIndexMarker737"/> from this link: <a href="https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe">https://desktop.docker.com/win/main/amd64/Docker%20Desktop%20Installer.exe</a>.</li>
<li>Run the downloaded <code>C:\Program Files\Docker\Docker</code>.</li>
<li>During the installation, you may be prompted to choose whether to use <strong class="bold">WSL 2 (Windows Subsystem for Linux 2)</strong> or <strong class="bold">Hyper-V</strong> as the backend. Select the <strong class="bold">Use WSL 2 instead of Hyper-V</strong> option, as we have used this throughout the book to run Ansible.</li>
<li>Follow the on-screen instructions provided by the installation wizard to authorize the installer and complete the installation process.</li>
<li>Once the installation is completed, click <strong class="bold">Close</strong> to finish the setup.</li>
</ol>
<p>From here, you can open<a id="_idIndexMarker738"/> Docker Desktop<a id="_idIndexMarker739"/> from the start menu, and it will run in the background.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor574"/>Installing Docker Desktop on Linux</h2>
<p>If you are running a Linux<a id="_idIndexMarker740"/> Desktop, the instructions<a id="_idIndexMarker741"/> will differ slightly depending on your Linux<a id="_idIndexMarker742"/> distribution; for detailed instructions, see <a href="https://docs.docker.com/desktop/linux/install/">https://docs.docker.com/desktop/linux/install/</a>.</p>
<p>Now, with Docker Desktop installed, we can look at the first of the two tools we will look a<a id="_idTextAnchor575"/>t.</p>
<h1 id="_idParaDest-196">Exploring Checko<a id="_idTextAnchor576"/>v</h1>
<p>Checkov is an open source<a id="_idTextAnchor577"/><a id="_idIndexMarker743"/> static code analysis tool maintained<a id="_idIndexMarker744"/> by Prisma Cloud designed for <strong class="bold">infrastructure-as-code</strong> (<strong class="bold">IaC</strong>).</p>
<p>It helps developers and DevOps teams identify misconfigurations in their files before deployment to cloud environments. By scanning the code for tools such as Terraform, CloudFormation, Kubernetes, and others, including Ansible, Checkov checks against best practices and compliance guidelines, ensuring your infrastructure deployments are secure, efficient, and compliant with industry standards before it is deployed.</p>
<p class="callout-heading">Important note</p>
<p class="callout">You may have noticed that Ansible is mentioned as “others” in the preceding description; that is because support for Ansible was only just introduced at the time of writing this in early 2024. Because of this, while we will be looking at Checkov during this chapter, we will not be going into as much detail about Checkov or the second tool, Kics.</p>
<p>Before we run our scan, we need<a id="_idIndexMarker745"/> a playbook; open your terminal and check out the scan GitHub repository by running the following:</p>
<pre class="console">
$ git clone git@github.com:PacktPublishing/Learn-Ansible-Second-Edition.git</pre> <p>This repository contains a copy of the final playbook code from <a href="B21620_11.xhtml#_idTextAnchor501"><em class="italic">Chapter 11</em></a>, <em class="italic">Highly Available </em><em class="italic">Cloud Deployments</em>.</p>
<p>Now that we have the code checked out, we can download the Checkov container image. To do this, we need to pull it from Docker Hub by running the following command:</p>
<pre class="console">
$ docker image pull bridgecrew/checkov:latest</pre> <p>This will download<a id="_idIndexMarker746"/> the image from <a href="https://hub.docker.com/r/bridgecrew/checkov">https://hub.docker.com/r/bridgecrew/checkov</a>, and with it downloaded, we can now scan our playbook code.</p>
<p>To run the scan, issue the following commands:</p>
<pre class="console">
$ cd Learn-Ansible-Second-Edition/Chapter13
$ docker container run --rm --tty --volume ./:/ansible --workdir /ansible bridgecrew/checkov --directory /ansible</pre> <p>Before we review the results, let’s quickly break down the command that we have just run:</p>
<ul>
<li><code>docker container run</code> executes a new Docker container.</li>
<li><code>--rm</code> instructs Docker to remove the container after it exits automatically.</li>
<li><code>--tty</code> allocates a pseudo-TTY, which makes the scan output readable to our session.</li>
<li><code>--volume ./:/ansible</code> mounts the current directory, defined as <code>./</code>, to the <code>/ansible</code> path inside the container.</li>
<li><code>--workdir /ansible</code> sets the working directory inside the container to <code>/ansible</code>.</li>
<li><code>bridgecrew/checkov</code> specifies the Checkov Docker image we have just pulled from the Docker Hub.</li>
<li><code>--directory /ansible</code> instructs Checkov to scan files in <code>/ansible</code>; it is not part of the Docker command but is sending instructions to the Checkov binary, which is the default entry point for our container to run the scan. If we had Checkov installed locally, then this would be the equivalent to running the <code>checkov --directory /</code><code>ansible</code> command.</li>
</ul>
<p>Now that we have broken<a id="_idIndexMarker747"/> down the command used to run the scan, we can look at the output of the scan itself, starting with the overview:</p>
<pre class="source-code">
ansible scan results:
Passed checks: 5, Failed checks: 3, Skipped checks: 0</pre> <p>As you can see, we have more passes than failed checks, which is a good start; the next section of the output details the checks, starting with the following passes:</p>
<pre class="source-code">
Check: CKV_ANSIBLE_2: "Ensure that certificate validation isn't disabled with get_url"
     PASSED for resource: tasks.ansible.builtin.get_url.download wp-cli
     File: /roles/wordpress/tasks/main.yml:11-17</pre> <p>Our first pass checks to see if we are instructing the <code>ansible.builtin.get_url</code> module to bypass certificate validation when connecting to an HTTPS site to download content.</p>
<p>The next four passes are for the two times our playbook uses the <code>ansible.builtin.apt</code> module:</p>
<pre class="source-code">
Check: CKV_ANSIBLE_5: "Ensure that packages with untrusted or missing signatures are not used"
     PASSED for resource: tasks.ansible.builtin.apt.update apt-cache and upgrade packages
     File: /roles/stack-install/tasks/main.yml:5-13
Check: CKV_ANSIBLE_5: "Ensure that packages with untrusted or missing signatures are not used"
     PASSED fo<a id="_idTextAnchor578"/>r resource: tasks.ansible.builtin.apt.update cache and install the stack packages
     File: /roles/stack-install/tasks/main.yml:27-33</pre> <p>The first pair of passes ensures<a id="_idIndexMarker748"/> that we are not installing any packages that are not correctly signed. The second pair of passes also checks for the same thing:</p>
<pre class="source-code">
Check: CKV_ANSIBLE_6: "Ensure that the force parameter is not used, as it disables signature validation and allows packages to be downgraded which can leave the system in a broken or inconsistent state"
     PASSED for resource: tasks.ansible.builtin.apt.update apt-cache and upgrade packages
     File: /roles/stack-install/tasks/main.yml:5-13
Check: CKV_ANSIBLE_6: "Ens<a id="_idTextAnchor579"/>ure that the force parameter is not used, as it disables signature validation and allows packages to be downgraded which can leave the system in a broken or inconsistent state"
     PASSED for resource: tasks.ansible.builtin.apt.update cache and install the stack packages
     File: /roles/stack-install/tasks/main.yml:27-33</pre> <p>However, this time, the check ensures that we are not using the force parameter, which, as you can see from the description, disables signature checks and can also leave our APT database in a little bit of a state if things go wrong.</p>
<p>Now, we move on to the failures; the first failure is the one we called out as the example when we spoke about why you would want to use the tools we are covering in this chapter:</p>
<pre class="source-code">
Check: CKV_AWS_88: "EC2 instance should not have public IP."
     FAILED for resource: tasks.amazon.aws.ec2_instance.Create the temporary ec2 instance
     File: /roles/ec2tmp/tasks/main.yml:53-75
      Guide: https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/public-policies/public-12
           62 |     network:
           63 |       assign_public_ip: "{{ ec2.public_ip }}"</pre> <p>So, what gives? As you may recall from <a href="B21620_11.xhtml#_idTextAnchor501"><em class="italic">Chapter 11</em></a>, <em class="italic">Highly Available Cloud Deployments</em>, the instance<a id="_idIndexMarker749"/> we are launching is only temporary and accessible while the playbook is running. However, Checkov doesn’t know this, so it rightly calls it out and, as you can see, provides details on why this is via the guide URL, which, for this check, is <a href="https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/public-policies/public-12">https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/public-policies/public-12</a>.</p>
<p>Moving on to the next failure in the scan, we see the following:</p>
<pre class="source-code">
Check: CKV_AWS_135: "Ensure that EC2 is EBS optimized"
     FAILED <a id="_idTextAnchor580"/>for resource: tasks.amazon.aws.ec2_instance.Create the temporary ec2 instance
     File: /roles/ec2tmp/tasks/main.yml:53-75
     Guide: https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-general-policies/ensure-that-ec2-is-ebs-optimized</pre> <p>In this case, Checkov believes a parameter <a id="_idTextAnchor581"/>is missing from the <code>amazon.aws.ec2_instance</code> block when we launch the temporary EC2 instance. It is recommended that the parameter <code>ebs_optimized</code> is set to <code>true</code> rather than keeping the value as <code>false</code>, which is the default for the parameter.</p>
<p>The final failure in the scan<a id="_idIndexMarker750"/> output is as follows:</p>
<pre class="source-code">
Check: CKV2_ANSIBLE_2: "Ensure that HTTPS url is used with get_url"
     FAILED for resource: tasks.ansible.builtin.get_url.download wp-cli
    File: /roles/wordpress/tasks/main.yml:11-17
           11 | - name: "download wp-cli"
           12 |   ansible.builtin.get_url:
    <a id="_idTextAnchor582"/>       13 |     url: "{{ wp_cli.download }}"
           14 |     dest: "{{ wp_cli.path }}"</pre> <p>As Checkov is doing static code analysis, it isn’t designed to check for the contents of variables. Because the policy checks that we are providing a secure URL (that is, <code>https://domain.com/</code> in the <code>url</code> section of the task) it fails, <a id="_idTextAnchor583"/>as it is just seeing the <code>{{ wp_cli.download }}</code> variable name rather than the contents of the variable.</p>
<p>If you are keeping count, that makes two of the three failed checks false positives; for the first failure, we can accept the risk, as we know the machine is only temporary, and we know that we are locking the EC2 instance down to trusted IP addresses.</p>
<p>For the third failure, we can confirm that the contents of the <code>{{ wp_cli.download }}</code> variable is a secure URL, as it is <code>https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar</code>.</p>
<p>The second failure is the only one we need to look at; let’s take a look at the tasks, starting with the <code>Amazon.aws.ec2_instance</code> one.</p>
<p>Here, we need to add two things; the first thing is a comment to instruct Checkov that we accept the risk being highlighted by the <code>CKV_AWS_88</code> policy, and then we need to set <code>ebs_optimized</code> to <code>true</code>.</p>
<p>The following code shows the up<a id="_idTextAnchor584"/>dates I have made to <code>roles/ec2tmp/tasks/main.yml</code>; everything below the <code>name</code> parameter remains as is:</p>
<pre class="source-code">
- name: "Create the temporary ec2 instance"
  amazon.aws.ec2_instance:
    # checkov:skip=CKV_AWS_88:"While a public IP address is assigned to the instance, it is locked down by the security group and the ins<a id="_idTextAnchor585"/>tanc<a id="_idTextAnchor586"/>e is temporary."
    ebs_optimized: true
    name: "{{ ec2_tmp_name }}"</pre> <p>As you can see, instructing Checkov<a id="_idIndexMarker751"/> to skip a check is straightforward; the comment is split into four parts:</p>
<ul>
<li><code>#</code> is the standard syntax for starting a comment in a YAML file</li>
<li><code>checkov:</code> instructs Checkov to pay attention to the content<a id="_idTextAnchor587"/>s of the comment</li>
<li><code>skip=CKV_AWS_88:</code> instructs Checkov to skip the <code>CKV_AWS_88</code> check when it runs</li>
<li><code>"While a public IP address is assigned to the instance, it is locked down by the security group and the instance is temporary."</code> is the suppress comment that will appear in the output when we run the scan</li>
</ul>
<p>The next line in the update task implements the recommendation that we set the <code>ebs_optimized</code> parameter to <code>true</code>.</p>
<p>Now, we move on to the second task, which we need to update, and can be found in <code>roles/wordpress/tasks/main.yml</code>. Here, we just add a comment to make Checkov skip <code>CKV2_ANSIBLE_2</code>:</p>
<pre class="source-code">
- name: "download wp-cli"
  ansible<a id="_idTextAnchor588"/>.builtin.get_url:
    # checkov:skip=CKV2_ANSIBLE_2:"The URL passed in the variable is secured with SSL/TLS protocol."
    url: "{{ wp_cli.download }}"
    dest: "{{ wp_cli.path }}"</pre> <p>If you are following along, the repository contains a branch called <code>checkov</code>; with the preceding detailed changes applied, you can switch to it by running the following:</p>
<pre class="console">
$ git switch chapter13-checkov</pre> <p>Then, we can re-run the scan using the following command:</p>
<pre class="console">
$ docker container run --rm --tty --volume ./:/ansible --workdir /ansible bridgecrew/checkov --directory /ansible</pre> <p>I can see that my changes<a id="_idIndexMarker752"/> have both suppressed and resolved the three failures:</p>
<pre class="source-code">
ansible scan results:
Passed checks: 6, Failed checks: 0, Skipped checks: 2</pre> <p>We have the pass for <code>CKV_AWS_135</code>:</p>
<pre class="source-code">
Check: CKV_AWS_135: "Ensure that EC2 is EBS optimized"
     PASSED for resource: tasks.amazon.aws.ec2_instance.Create the temporary ec2 instance
      File: /roles/ec2tmp/tasks/main.yml:53-77
      Guide: https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/aws-general-policies/ensure-that-ec2-is-ebs-optimized</pre> <p>We also have the two false positives now showing:</p>
<pre class="source-code">
Check: CKV_AWS_88: "EC2 instance should not have public IP."
     SKIPPED for resource: tasks.amazon.aws.ec2_instance.Create the temporary ec2 instance
     Suppress comment: "While a public IP address is assigned to the instance, it is locked down by the security group and the instance is temporary."
     File: /roles/ec2tmp/tasks/main.yml:53-77
     Guide: https://docs.prismacloud.io/en/enterprise-edition/policy-reference/aws-policies/public-policies/public-12</pre> <p>For the second one, we have the following:</p>
<pre class="source-code">
Check: CKV2_ANSIBLE_2: "Ensure that HTTPS url is used with get_url"
     SKIPPED for resource: tasks.ansible.builtin.get_url.download wp-cli
     Suppress comment: "The URL passed in the variable is secured with SSL/TLS protocol."
     File: /roles/wordpress/tasks/main.yml:11-18</pre> <p>As you can see, our comments are visible for all to see.</p>
<p>So, returning to the call-out at the start of the section, why have we covered this tool if Checkov doesn’t have full coverage for Ansible? As you can see from the output of the scan of our playbook, while there<a id="_idIndexMarker753"/> is not much coverage now, each new release brings additional Ansible policies. Hence, as time goes on, coverage should only get more robust, and hopefully, we will bring this promising tool in line with the second tool we will look at: <strong class="bold">KICS</strong>, or to <a id="_idTextAnchor589"/>give it its full title, <strong class="bold">keeping infrastructure as </strong><strong class="bold">code secure</strong>.</p>
<h1 id="_idParaDest-197"><a id="_idTextAnchor590"/>Exploring KICS</h1>
<p>KICS is another static code analysis<a id="_idIndexMarker754"/> tool, and like Checkov, it is open source. It is designed to help you find common misconfiguration issues, potential compliance issues, and even security vulnerabilities within your IaC code. It ships with support for Kubernetes, Docker, AWS CloudFormation, Terram, and, of course, Ansible, which we will be focusing on in this chapter.</p>
<p>KICS is designed to be easy to install, understand, and integrate into CI/CD pipelines. It includes over 2,400 customizable rules and is built for extensibility, allowing for the easy addition of support for new IaC tools and updates to existing integrations.</p>
<p>KICS is maintained and supported by <strong class="bold">Checkmarx</strong> specialists in software application<a id="_idIndexMarker755"/> security testing, meaning<a id="_idIndexMarker756"/> that KICS has a good pedigree.</p>
<h2 id="_idParaDest-198"><a id="_idTextAnchor591"/>Running the scan</h2>
<p>Let’s dive straight in. If you haven’t already, check<a id="_idIndexMarker757"/> out the example repository using the following command:</p>
<pre class="console">
$ git clone https://github.com/russmckendrick/Learn-Ansible-Second-Edition-Scan.git</pre> <p>Now, we can pull the latest container image from Docker Hub (<a href="https://hub.docker.com/r/checkmarx/kics">https://hub.docker.com/r/checkmarx/kics</a>) by using the following command:</p>
<pre class="console">
$ docker image pull checkmarx/kics:latest</pre> <p>Change to the folder containing our Ansible playbook:</p>
<pre class="console">
$ cd Learn-Ansible-Second-Edition-Sca<a id="_idTextAnchor592"/>n</pre> <p>Then run the scan itself:</p>
<pre class="console">
$ docker container run --rm --tty --volume ./:/ansible checkmarx/kics scan --path /ansible/</pre> <p>As you can see, the docker command follows the same pattern we discussed when we ran Checkov up until where we pass the options to the KICS binary; here, we instruct KICS to run <code>scan</code> against the <code>--path /ansible/</code>, which is the directory we have mounting from our host machine inside the container using the <code>--</code><code>volume</code> option.</p>
<h2 id="_idParaDest-199"><a id="_idTextAnchor593"/>Reviewing the results</h2>
<p>Now, let’s take a look<a id="_idIndexMarker758"/> at the result of the scan; KICS presents its output, which is slightly different from Checkov in that the initial output is designed to give real-time information on the scan itself:</p>
<pre class="source-code">
Scanning with Keeping Infrastructure as Code Secure v1.7.12
Preparing Scan Assets: Done
Executing queries: [------------------------------] 100.00%
Files scanned: 33
Parsed files: 32
Queries loaded: 292
Queries failed to execute: 0</pre> <p>Let’s now work through<a id="_idIndexMarker759"/> the various results and group them by severity levels.</p>
<h3>Info and low-severity results</h3>
<p>The first result highlights potentially risky <a id="_idIndexMarker760"/>file permissions for the files we create (using templates) or copy:</p>
<pre class="source-code">
Risky File Permissions, Severity: INFO, Results: 5
Description: Some modules could end up creating new files on disk with permissions that might be too open or unpredictable
Platform: Ansible
Learn more about this vulnerability: https://docs.kics.io/latest/queries/ansible-queries/common/88841d5c-d22d-4b7e-a6a0-89ca50e44b9f</pre> <p>It then goes on to list all the affected files; here is a snippet of the first few:</p>
<pre class="source-code">
[1]: ../../ansible/destroy.yml:52
     051:     - name: "Delete the group_vars/generated_aws_endpoints.yml file"
     052:       ansible.builtin.file:
     053:         path: "group_vars/generated_aws_endpoints.yml"</pre> <p>Here is another:</p>
<pre class="source-code">
[2]: ../../ansible/destroy.yml:81
     080:     - name: "Delete the group_vars/generated_efs_targets.yml file"
     081:       ansible.builtin.file:
     082:         path: "group_vars/generated_efs_targets.yml"</pre> <p>Moving on to the next issue, we see the following:</p>
<pre class="source-code">
Unpinned Package Version, Severity: LOW, Results: 1
Description: Setting state to latest performs an update and installs additional packages possibly resulting in performance degradation or loss of service
Platform: Ansible
Learn more about this vulnerability: https://docs.kics.io/latest/queries/ansible-queries/common/c05e2c20-0a2c-4686-b1f8-5f0a5612d4e8</pre> <p>Again, here is a sample<a id="_idIndexMarker761"/> of where it has spotted the issue:</p>
<pre class="source-code">
[1]: ../../ansible/roles/stack_install/tasks/main.yml:8
      007:     name: "*"
      008:     state: "latest"
      009:     update_cache: true</pre> <p>The next and final low-scoring result is as follows:</p>
<pre class="source-code">
EFS Without Tags, Severity: LOW, Results: 1
Description: Amazon Elastic Filesystem should have filesystem tags associated
Platform: Ansible
Learn more about this vulnerability: https://docs.kics.io/latest/queries/ansible-queries/aws/b8a9852c-9943-4973-b8d5-77dae9352851</pre> <p>Here are the details:</p>
<pre class="source-code">
[1]: ../../ansible/destroy.yml:75
      074:     - name: "Delete the EFS File System"
      075:       community.aws.efs:
      076:         name: "{{ efs_name }}"</pre> <p>Let’s quickly review the low-scoring ones before moving on to the one result with a medium score.</p>
<p>So, the first result was, <strong class="bold">“Some modules could end up creating new files on disk with permissions that might be too open or unpredictable”</strong>. It called out 11 places within our playbook where this could be an issue, so we should look at resolving these.</p>
<p>First off, if you ran the full scan, you will have noticed that three of the results are from the <code>destroy.yml</code> file.</p>
<p>Given that these tasks<a id="_idIndexMarker762"/> are removing files, we don’t care about the file permissions here. So, rather than adding the permissions to the individual tasks, we should instruct KICS not to run the check across the whole file.</p>
<p>To do this, we need to add the following comment at the very top of the file:</p>
<pre class="source-code">
# kics-scan disable=88841d5c-d<a id="_idTextAnchor594"/>22d-4b7e<a id="_idTextAnchor595"/>-a6a0-89ca50e44b9f</pre> <p>Next, we have <code>ansible.builtin.template</code> in <code>roles/efs/tasks/main.yml</code>. Rather than skip the test, I added the permissions using the <code>mode</code> key:</p>
<pre class="source-code">
- name: "Generate the efs targets vars file"
  ansible.builtin.template:
    src: "targets.j2"
    dest: "group_vars/generated_efs_targets.yml"
    mode: "0<a id="_idTextAnchor596"/>644"</pre> <p>The final result is for the <code>ansible.builtin.get_url</code> module used by the task, which downloads <code>wp-cli</code> in the <code>roles/wordpress/tasks/main.yml</code> file.</p>
<p>When reviewing the code, it looked like the follow<a id="_idTextAnchor597"/>ing:</p>
<pre class="source-code">
- name: "Download wp-cli"
  ansible.builtin.get_url:
    url: "{{ wp_cli.download }}"
    dest: "{{ wp_cli.path }}"</pre> <p>This was immediately followed by the following:</p>
<pre class="source-code">
- name: "Update permissions of wp-cli to allow anyone to execute it"
  ansible.builtin.fil<a id="_idTextAnchor598"/>e:
    path: "{{ wp_cli.path }}"
    mode: "0755"</pre> <p>Here, KICS highlights<a id="_idIndexMarker763"/> that we can set the mode as part of <code>ansible.builtin.get_url</code>, which means we do not have to do it separately, so I added the following to the download task:</p>
<pre class="source-code">
    mode: "0755"</pre> <p>Then, I removed the second task. That clears the file permission issues KICS reported.</p>
<p>The next LOW score says, <strong class="bold">“Setting state to latest performs an update and installs additional packages possibly resulting in performance degradation or <a id="_idTextAnchor599"/>loss </strong><strong class="bold">of service”</strong>.</p>
<p>This appears in <code>roles/stack-install/tasks/main.yml</code>, where the task uses <code>ansible.builtin.apt</code> to update the installed images, as this task is only called when we bootstrap our temporary EC2 instance and we made allowances for changes to the PHP version in the main playbook. I think it is safe to accept this as a false positive, so we can tell KICS not to run the test on this file by adding the following to the very top of <code>roles/stack-install/tasks/main.yml</code>:</p>
<pre class="source-code">
# kics-scan disable=c05e2c20-0a2c-4686-b1f8-5f0a5612d4e8</pre> <p>This leaves us with <code>destroy.yml</code>, so the lack of tags does matter.</p>
<p>Let’s exclude the check from being run. To do this, we need to append it to the end of the comment we already added, which means the comment at the end of <code>destroy.yml</code> now reads this:</p>
<pre class="source-code">
# kics-scan disable=88841d5c-d22d-4b7e-a6a0-89ca50e44b9f,b8a9852c-9943-4973-b8d5-77dae9352851</pre> <p>When appending IDs, please<a id="_idIndexMarker764"/> ensure that a comma separates them; otherwise, KICS will read them as one string. Finally, we have the high-severity results.</p>
<h3>High-severity results</h3>
<p>Luckily, here we have just<a id="_idIndexMarker765"/> two problems called out across four tasks, starting with the following:</p>
<pre class="source-code">
EFS Not Encrypted, Severity: HIGH, Results: 2
Description: Elastic File System (EFS) must be encrypted
Platform: Ansible
Learn more about this vulnerability: https://docs.kics.io/latest/queries/ansible-queries/aws/727c4fd4-d604-4df6-a179-7713d3c85e20</pre> <p>These are the two tasks:</p>
<pre class="source-code">
[1]: ../../ansible/roles/efs/tasks/main.yml:25
     024: - name: "Create the EFS File System"
     025:   community.aws.efs:</pre> <p>The second is in the <code>destroy.yml</code> file:</p>
<pre class="source-code">
[2]: ../../ansible/destroy.yml:77
     076:     - name: "Delete the EFS File System"
     077:       community.aws.efs:</pre> <p>I think you can probably guess how we are going to resolve the second one; let’s get it to ignore the test in <code>destroy.yml</code>:</p>
<pre class="source-code">
# kics-scan disable=88841d5c-d22d-4b7e-a6a0-89ca50e44b9f,b8a9852c-9943-4973-b8d5-77dae9352851,050f085f-a8db-4072-9010-2cca235cc02f,727c4fd4-d604-4df6-a179-7713d3c85e20</pre> <p>For <code>roles/efs/tasks/main.yml</code>, the recommendation is to enable encryption, so let’s take that advice:</p>
<pre class="source-code">
- name: "Create the EFS Fi<a id="_idTextAnchor600"/>le System"
  community.aws.efs:
    encrypt: true
    name: "{{ efs_name }}"</pre> <p>As you can see from the preceding snippet, we have added the <code>encrypt</code> parameter and set it to <code>true</code>.</p>
<p>The next issue highlighted by KICS also has to do with EFS filesystem encryption:</p>
<pre class="source-code">
EFS Without KMS, Severity: HIGH, Results: 2
Description: Amazon Elastic Filesystem should have filesystem encryption enabled using KMS CMK customer-managed keys instead of AWS managed-keys
Platform: Ansible
Learn more about this vulnerability: https://docs.kics.io<a id="_idTextAnchor601"/>/latest/queries/ansible-queries/aws/bd77554e-f138-40c5-91b2-2a09f878608e</pre> <p>The results are for the same files as the previous issue, so we will append the ID to the list of checks to disable at the top of the <code>destroy.yml</code> file.</p>
<p>Given that this is just a demo environment, I am happy to accept the potential risk of not using a customer-managed key vault to store my own managed encryption keys; so, in this instance, I will add the following:</p>
<pre class="source-code">
# kics-scan disable=bd77554e-f138-40c5-91b2-2a09f878608e</pre> <p>I’ll do so at the very top of the <code>roles/efs/tasks/main.yml</code> file. If this were a fixed production environment, then I would have<a id="_idIndexMarker766"/> added a role to launch and maintain<a id="_idIndexMarker767"/> AWS Key Management Service (<a href="https://aws.amazon.com/kms/">https://aws.amazon.com/kms/</a>) as part of the deployment.</p>
<h3>The results summary</h3>
<p>The final part of the rules <a id="_idIndexMarker768"/>gives an overview of everything we have covered, which, for the initial scan with none of the fixes in place, is as follows:</p>
<pre class="source-code">
Results Summary:
HIGH: 4
MEDIUM: 0
LOW: 2
INFO: 5
TOTAL: 11</pre> <h2 id="_idParaDest-200"><a id="_idTextAnchor602"/>Re-running the scan</h2>
<p>As before, there is a branch<a id="_idIndexMarker769"/> containing all of the updated files we discussed and implemented in the previous section; to change to it, run the following:</p>
<pre class="console">
$ git switch chapter13-kics</pre> <p>You can then run the scan again using this:</p>
<pre class="console">
$ docker container run --rm --tty --volume ./:/ansible checkmarx/kics scan --path /ansible/</pre> <p>This should now return a clean bill of health:</p>
<pre class="source-code">
Scanning with Keeping Infrastructure as Code Secure v1.7.13
Preparing Scan Assets: Done
Executing queries: [------------------------------] 100.00%
Results Summary:
HIGH: 0
MEDIUM: 0
LOW: 0
INFO: 0
TOTAL: 0</pre> <p>As you can see, no problems<a id="_idIndexMarker770"/> are being reported now.</p>
<h2 id="_idParaDest-201"><a id="_idTextAnchor603"/>Output files</h2>
<p>Before we finish<a id="_idIndexMarker771"/> the chapter, there is one more thing that we should quickly discuss about KICS: its ability to output a report in various file formats.</p>
<p>If you were to re-run the scans against the <code>main</code> and <code>kics</code> branches but using the following command, then you will notice that a file called <code>results.html</code> appears in your repo folder:</p>
<pre class="console">
$ docker container run --rm --tty --volume ./:/ansible checkmarx/kics scan<a id="_idTextAnchor604"/> --path /ansible/ --report-formats "html" --output-path /ansible/</pre> <p>As you can see, we are passing in two new flags; the first, <code>--report-formats</code>, tells KICS to output a report as an <code>html</code> file, and the second, <code>--output-path</code>, lets KICS know where to save the report file; in our case, as we are running KICS in a container that needs to be a location within the container that persists, once the container has finished running, the container will automatically be removed along with any files written.</p>
<p>When running the command against the main branch, which does not contain any of the fixes, we applied the header of the r<a id="_idTextAnchor605"/>eport, which looks like the following:</p>
<div><div><img alt="Figure 13.1 – Viewing the report showing issues" src="img/B21620_13_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Viewing the report showing issues</p>
<p>Then, re-running the scan<a id="_idIndexMarker772"/> against the KICS branch updates it to the following:</p>
<div><div><img alt="Figure 13.2 – A clean bill of health" src="img/B21620_13_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – A clean bill of health</p>
<p>You can also output in PDF, JSON, and other standard reporting formats. As you can see, this is a little more digestible than reading the output of the command line report we covered in the previous section.</p>
<p>We will put <a id="_idTextAnchor606"/>these reports to good use when we get to <a href="B21620_15.xhtml#_idTextAnchor641"><em class="italic">Chapter 15</em></a>, <em class="italic">Using Ansible with GitHub Actions and Azure DevOps</em>, as we will publish<a id="_idIndexMarker773"/> the results as part of our pipeline runs.</p>
<h1 id="_idParaDest-202"><a id="_idTextAnchor607"/>Summary</h1>
<p>In this chapter, we have covered two tools that we can add to our workflows, and we manually ran scans against the playbook we developed in <a href="B21620_11.xhtml#_idTextAnchor501"><em class="italic">Chapter 11</em></a>, <em class="italic">Highly Available Cloud Deployments</em>. As mentioned in the chapter, Checkov's support for Ansible is relatively new, so it has a different coverage to KICS. However, I am sure you agree that both tools worked well.</p>
<p class="callout-heading">Important note</p>
<p class="callout">There is one elephant in the room, though; even without the same coverage level, both tools came up with slightly different results, so you should never rely on them 100% to fully secure your deployments. Think of them as trusted colleagues reviewing your code for anything obvious that stands out as being an issue rather than a security-focused cloud platform architect with a working knowledge of your workload who dictates precisely what measures you should take when deploying your infrastructure in a secure way fully.</p>
<p>As already mentioned at the end of the previous section, we will be revisiting KICS in <a href="B21620_15.xhtml#_idTextAnchor641"><em class="italic">Chapter 15</em></a>, <em class="italic">Using Ansible with GitHub Actions and Azure DevOps</em>. Before we get there, now that we have looked at how we can review and secure our playbook code, we can now look at how we can secure our workload by quickly applying security best practices to the host operating systems that we are targeting using Ansible.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor608"/>Further reading</h1>
<p>For more information about the tools and their maintainers, see the following links:</p>
<ul>
<li><strong class="bold">Checkov</strong>: <a href="https://www.checkov.io/">https://www.checkov.io/</a></li>
<li><strong class="bold">Prisma </strong><strong class="bold">Cloud</strong>: <a href="https://www.paloaltonetworks.com/prisma/cloud/">https://www.paloaltonetworks.com/prisma/cloud/</a></li>
<li><strong class="bold">KICS</strong>: <a href="http://kics.io/">http://kics.io/</a></li>
<li><strong class="bold">Checkmarx</strong>: <a href="https://checkmarx.com/">https://checkmarx.com/</a></li>
</ul>
</div>
</body></html>