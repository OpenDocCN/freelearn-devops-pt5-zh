<html><head></head><body>
  
    
      <h1>Running Services in a Container</h1>
    

    
      <p>We have come thus far by carefully explaining the various aspects of the Docker technology. The previous chapters definitely have laid down a stellar foundation for the overwhelmingly accepted Docker platform and the forthcoming chapters will be like the meticulously crafted buildings on that grandiose foundation.</p>

      <p>We described the important building blocks (the highly usable and reusable Docker images) to bring forth powerful Docker containers. There are briefs about the various easy-to-learn-and-employ techniques and tips on how to store and share Docker images through a well-designed storage framework. Typically, images have to go through a series of verifications, validations, and refinements constantly in order to be right and relevant for the aspiring development community.</p>

      <p>In this chapter, we are going to take our learning to the next level by detailing the key steps in creating a small web server, run the same inside a container, and enable outsiders to connect to the containerized web server through the Internet.</p>

      <p>In this chapter, we will cover the following topics:</p>

      <ul>
        <li>Container networking</li>

        <li><strong>Container as a Service</strong> (<strong>CaaS</strong>) – building, running, exposing, and connecting to container services</li>

        <li>Publishing and retrieving containers' port</li>

        <li>Binding a container to a specific IP address</li>

        <li>Autogenerating the Docker host port</li>

        <li>Port binding using the <code>EXPOSE</code> and <code>-P</code> options</li>
      </ul>
    
  

  
    
      <h2 id="sigil_toc_id_90">A brief overview of container networking</h2>
    

    
      <p>Networking is a critical infrastructure component of enterprise and cloud IT. Especially, as computing becomes extremely distributed, networking becomes indispensable. Typically, a Docker host comprises multiple Docker containers and hence the networking has become a crucial component for realizing composite containerized applications. Docker containers also need to interact and collaborate with local as well as remote ones to come out with distributed applications. Precisely speaking, different and distributed containers need to be publicly found, network-accessible, and composable to bring forth business-centric and process-aware applications.</p>

      <p>One of the key strengths of the Docker containerization paradigm is the ability to network seamlessly without much effort from the user. The earlier version of Docker supported just the bridge network; later, Docker acquired the SDN startup SocketPlane to add additional networking capabilities. Since then, Docker's networking capability has grown leaps and bounds and a separate set of subcommands, namely <code>docker network connect</code>, <code>docker network create</code>, <code>docker network disconnect</code>, <code>docker network inspect</code>, <code>docker network ls</code>, and <code>docker network rm</code>, were introduced to handle the nitty-gritty of the Docker networking. By default, during installation, the Docker Engine creates three networks for you, which you can list using the <code>docker network ls</code> subcommand, as shown here:</p>

      <div><img class="image-border" height="90" src="img/image_06_001.jpg" width="463"/>
      </div>

      <p>As you can see in the preceding screenshot, during the Docker setup, the Docker Engine creates the <code>bridge</code>, <code>host</code>, and <code>none</code> (<code>null</code>) networks. When Docker spins up a new container, by default, it creates a network stack for the container and attaches to the default <code>bridge</code> network. However, optionally, you could attach the container to the <code>host</code> or <code>none</code> network or the user-defined network using the <code>--net</code> option of the <code>docker run</code> subcommand. If you choose the <code>host</code> network, the container gets attached to the <code>host</code> network stack and shares the host's IP addresses and ports. The <code>none</code> network mode creates a network stack with just the Loopback (<code>lo</code>) interface. We can confirm this using the <code>docker run --rm --net=none busybox ip addr</code> command, as shown here:</p>

      <div><img class="image-border" height="103" src="img/image_06_002.jpg" width="383"/>
      </div>

      <p>Evidently, as you can see in the preceding screenshot, the container has got just a Loopback interface. Since this container has got just a Loopback interface, the container cannot communicate with other containers or the external world.</p>

      <p>The <code>bridge</code> network is the default network interface that Docker Engine assigns to a container if the network is not configured using the <code>--net</code> option of the <code>docker run</code> subcommand. To have a better understanding of the <code>bridge</code> network, let's begin by inspecting it using the <code>docker network inspect</code> subcommand, as shown here:</p>

      <div><img class="image-border" height="389" src="img/image_06_003.jpg" width="498"/>
      </div>

      <p>Here, in the preceding screenshot, we have highlighted three paramount insights. You can find the relevant description of what happens during the Docker installation process:</p>

      <ul>
        <li><code>docker0</code>: Docker creates an Ethernet bridge interface inside the Linux kernel with the <code>docker0</code> name on the Docker host. This interface is used as a bridge to pass the Ethernet frames between containers and also between containers and an external network.</li>

        <li><code>Subnet</code>: Docker also selects a private IP subnet from the address range of <code>172.17.0.0</code> to <code>172.17.255.255</code> and keeps it revered for its containers. In the preceding screenshot, Docker has selected the <code>172.17.0.0/16</code> subnet for the containers.</li>

        <li><code>Gateway</code>: The <code>docker0</code> interface is the gateway for the <code>bridge</code> network and Docker, from the IP subnet range selected earlier, assigns an IP address to <code>docker0</code>. Here, in the preceding example, <code>172.17.0.1</code> is assigned to the gateway.</li>
      </ul>

      <p>We can cross-check the gateway address by listing the <code>docker0</code> interface using the <code>ip addr show</code> Linux command:</p>

      <pre><strong>$ ip addr show docker0</strong>
</pre>

      <p>The third line of the output shows the assigned IP address and its network prefix:</p>

      <pre><strong>inet 172.17.0.1/16 scope global docker0 </strong>
</pre>

      <p>Apparently, from the preceding text, <code>172.17.0.1</code> is the IP address assigned to <code>docker0</code>, the Ethernet bridge interface, which is also listed as the gateway address in the output of the <code>docker network inspect bridge</code> command.</p>

      <p>Now that we have a clear understanding of the bridge creation and the subnet/gateway address selection process, let's explore the container networking in the <code>bridge</code> mode a bit more in detail. In the <code>bridge</code> network mode, the Docker Engine creates a network stack with a Loopback (<code>lo</code>) interface and an Ethernet (<code>eth0</code>) interface during the launch of the container. We can quickly examine this by running the <code>docker run --rm busybox ip addr</code> command:</p>

      <div><img class="image-border" height="206" src="img/image_06_004.jpg" width="559"/>
      </div>

      <p>Evidently, the preceding output of the <code>ip addr</code> command shows that the Docker Engine has created a network stack for the container with two network interfaces, which are as follows:</p>

      <ul>
        <li>The first interface is the <code>lo</code> (Loopback) interface, for which the Docker Engine assigned the <code>127.0.0.1</code> Loopback address. The Loopback interface is used for local communication within a container.</li>
      </ul>

      <ul>
        <li>The second interface is an <code>eth0</code> (Ethernet) interface, for which the Docker Engine assigned the <code>172.17.0.3</code> IP address. Obviously, this address also falls within the same IP address range of the <code>docker0</code> Ethernet bridge interface. Besides, the address assigned to the <code>eth0</code> interface is used for intra-container communication and host-to-container communication.</li>
      </ul>

      <p>The <code>ip addr</code> and/or <code>ifconfig</code> commands are not supported by all Docker images, including <code>ubuntu:14.04</code> and <code>ubuntu:16.04</code>. The <code>docker inspect</code> subcommand is the reliable way to find the IP address of the container.
      </p>

      <p>Earlier, we mentioned that <code>docker0</code>, the Ethernet bridge interface, acts as a conduit to pass the Ethernet frames between containers and also between containers and the external world. However, we have not yet clarified how the containers connect with the <code>docker0</code> bridge. The following diagram unravels some of the mystery around this connection:</p>

      <div><img class="image-border" height="232" src="img/image_06_005.png" width="391"/>
      </div>

      <p>As depicted here, the container's <code>eth0</code> interface is connected to the <code>docker0</code> bridge using <code>veth</code>. The <code>eth0</code> and <code>veth</code> interfaces belong to a special type of Linux network interface called a <strong>Virtual Ethernet</strong> (<strong>veth</strong>) Interface. The <code>veth</code> interface always comes in a pair, and they are like a water pipe wherein the data send from one <code>veth</code> interface will come out of the other interface and vice versa. The Docker Engine assigns one of the <code>veth</code> interfaces to the container with the <code>eth0</code> name and assigns the container IP address to that interface. The other <code>veth</code> interface of the pair is bound to the <code>docker0</code> bridge interface. This ensures the seamless flow of data between the Docker host and the containers.</p>

      <p>Docker assigns private IP addresses to the container, which is not reachable from outside of the Docker host. However, the container IP address comes in handy for debugging within the Docker host. As we noted earlier, many Docker images do not support the <code>ip addr</code> or <code>ifconfig</code> commands, besides we may not directly have access to the container prompt to run any of these commands. Fortunately, Docker provides a <code>docker inspect</code> subcommand, which is as handy as a Swiss Army knife, to dive deep into the low-level details of the Docker container or image. The <code>docker inspect</code> subcommand reports quite a lot of details including the IP address and the gateway address. For the practical purpose, here you can either select a running container or temporarily launch a container, as follows:</p>

      <pre><strong>$ sudo docker run -itd ubuntu:16.04 </strong>  
</pre>

      <p>Here, let's assume the container ID is <code>4b0b567b6019</code> and run the <code>docker inspect</code> subcommand, as shown here:</p>

      <pre><strong>$ sudo docker inspect 4b0b567b6019</strong>
</pre>

      <p>This command generates quite a lot of information about the container. Here, we show some excerpts of the container's network configuration from the output of the <code>docker inspect</code> subcommand:</p>

      <pre><strong>"Networks": {</strong><br/><strong> "bridge": {</strong><br/><strong> "IPAMConfig": null,</strong><br/><strong> "Links": null,</strong><br/><strong> "Aliases": null,</strong><br/><strong> "NetworkID": "ID removed for readability",</strong><br/><strong> "EndpointID": "ID removed for readability",</strong><br/><strong> "Gateway": "172.17.0.1",</strong><br/><strong> "IPAddress": "172.17.0.3",</strong><br/><strong> "IPPrefixLen": 16,</strong><br/><strong> "IPv6Gateway": "",</strong><br/><strong> "GlobalIPv6Address": "",</strong><br/><strong> "GlobalIPv6PrefixLen": 0,</strong><br/><strong> "MacAddress": "02:42:ac:11:00:03"</strong><br/><strong> }</strong><br/><strong>}</strong>
</pre>

      <p>Here are the details of some of the important fields in the network configuration:</p>

      <ul>
        <li><code>Gateway</code>: This is the gateway address of the container, which is the address of the <code>bridge</code> interface as well</li>

        <li><code>IPAddress</code>: This is the IP address assigned to the container</li>

        <li><code>IPPrefixLen</code>: This is the IP prefix length, another way of representing the subnet mask</li>
      </ul>

      <p>Without doubt, the <code>docker inspect</code> subcommand is quite convenient to find the minute details of a container or an image. However, it's a tiresome job to go through the intimidating details and to find the right information that we are keenly looking for. Perhaps, you can narrow it down to the right information, using the <code>grep</code> command. Alternatively, even better, the <code>docker inspect</code> subcommand helps you pick the right field from the JSON array using the <code>--format</code> option of the <code>docker inspect</code> subcommand.</p>

      <p>Notably, in the following example, we use the <code>--format</code> option of the <code>docker inspect</code> subcommand to retrieve just the IP address of the container. The IP address is accessible through the <code>.NetworkSettings.IPAddress</code> field of the JSON array:</p>

      <pre><strong>$ sudo docker inspect \</strong><br/><strong> --format='{{.NetworkSettings.IPAddress}}' 4b0b567b6019</strong><br/><strong>172.17.0.3</strong>
</pre>

      <p>In addition to the <code>none</code>, <code>host</code>, and <code>bridge</code> networking modes, Docker also supports the <code>overlay</code>, <code>macvlan</code>, and <code>ipvlan</code> network modes.</p>
    
  

  
    
      <h2 id="sigil_toc_id_91">Envisaging container as a service</h2>
    

    
      <p>We laid a good foundation of the fundamentals of the Docker technology. In this section, we are going to focus on crafting an image with the HTTP service, launch the HTTP service inside the container using the crafted image, and then, demonstrate the connectivity to the HTTP service running inside the container.</p>
    
  

  
    
      <h3 id="sigil_toc_id_92">Building an HTTP server image</h3>
    

    
      <p>In this section, we are going to craft a Docker image in order to install Apache2 on top of the Ubuntu 16.04 base image, and configure an Apache HTTP server to run as an executable, using the <code>ENTRYPOINT</code> instruction.</p>

      <p>In <a href="../Text/Ch03.xhtml">Chapter 3</a>, <em>Building Images</em>, we illustrated the concept of <code>Dockerfile</code> to craft an Apache2 image on top of the Ubuntu 16.04 base image. Here, in this example, we are going to extend this <code>Dockerfile</code> by setting the Apache log path and setting Apache2 as the default execution application, using the <code>ENTRYPOINT</code> instruction. The following is a detailed explanation of the content of <code>Dockerfile</code>.</p>

      <p>We are going to build an image using <code>ubuntu:16.04</code> as the base image, using the <code>FROM</code> instruction, as shown in the <code>Dockerfile</code> snippet:</p>

      <pre>########################################### <br/># Dockerfile to build an apache2 image <br/>########################################### <br/># Base image is Ubuntu <br/>FROM ubuntu:16.04 
</pre>

      <p>Set the author's detail using the <code>MAINTAINER</code> instruction:</p>

      <pre># Author: Dr. Peter <br/>MAINTAINER Dr. Peter &lt;peterindia@gmail.com&gt; 
</pre>

      <p>Using one <code>RUN</code> instruction, we will synchronize the APT repository source list, install the <code>apache2</code> package, and then clean the retrieved files:</p>

      <pre># Install apache2 package <br/>RUN apt-get update &amp;&amp; \ <br/>     apt-get install -y apache2 &amp;&amp; \ <br/>     apt-get clean 
</pre>

      <p>Set the Apache log directory path using the <code>ENV</code> instruction:</p>

      <pre># Set the log directory PATH <br/>ENV APACHE_LOG_DIR /var/log/apache2 
</pre>

      <p>Now, the final instruction is to launch the <code>apache2</code> server using the <code>ENTRYPOINT</code> instruction:</p>

      <pre># Launch apache2 server in the foreground <br/>ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"] 
</pre>

      <p>In the preceding line, you might be surprised to see the <code>FOREGROUND</code> argument. This is one of the key differences between the traditional and the container paradigm. In the traditional paradigm, the server applications are usually launched in the background either as a service or a daemon because the host system is a general-purpose system. However, in the container paradigm, it is imperative to launch an application in the foreground because the images are crafted for a sole purpose.</p>

      <p>Having prescribed the image building instruction in the <code>Dockerfile</code>, let's now move to the next logical step of building the image using the <code>docker build</code> subcommand by naming the image as <code>apache2</code>, as shown here:</p>

      <pre><strong>$ sudo docker build -t apache2 .</strong>  
</pre>

      <p>Let's now do a quick verification of the images using the <code>docker images</code> subcommand:</p>

      <pre><strong>$ sudo docker images</strong>
</pre>

      <p>As we have seen in the previous chapters, the <code>docker images</code> command displays the details of all the images in the Docker host. However, in order to illustrate precisely the images created using the <code>docker build</code> subcommand, we highlight the details of <code>apache2:latest</code> (the target image) and <code>ubuntu:16.04</code> (the base image) from the complete image list, as shown in the following output snippet:</p>

      <pre>    <strong>apache2 latest 1b34e47c273d About a minute ago 265.5 MB</strong><br/><strong>ubuntu 16.04 f753707788c5 3 weeks ago 127.2 MB</strong> 
</pre>

      <p>Having built the HTTP server image, let's now move on to the next session to learn how to run the HTTP service.</p>
    
  

  
    
      <h3 id="sigil_toc_id_93">Running the HTTP server image as a service</h3>
    

    
      <p>In this section, we are going to launch a container using the Apache HTTP server image, we crafted in the previous section. Here, we launch the container in the detached mode (similar to the UNIX daemon process) using the <code>-d</code> option of the <code>docker run</code> subcommand:</p>

      <pre><strong>$ sudo docker run -d apache2</strong><br/><strong>9d4d3566e55c0b8829086e9be2040751017989a47b5411c9c4f170ab865afcef</strong>  
</pre>

      <p>Having launched the container, let's run the <code>docker logs</code> subcommand to see whether our Docker container generates any output on its stdin (standard input) or stderr (standard error):</p>

      <pre><strong>$ sudo docker logs \<br/>9d4d3566e55c0b8829086e9be2040751017989a47b5411c9c4f170ab865afcef</strong> 
</pre>

      <p>As we have not fully configured the Apache HTTP server, you will find the following warning, as the output of the <code>docker logs</code> subcommand:</p>

      <pre><strong>AH00558: apache2: Could not reliably determine the server's fully qualified domain name, using 172.17.0.13. Set the 'ServerName' directive globally to suppress this message</strong>
</pre>

      <p>From the preceding warning message, it is quite evident that the IP address assigned to this container is <code>172.17.0.13</code>.</p>
    
  

  
    
      <h3 id="sigil_toc_id_94">Connecting to the HTTP service</h3>
    

    
      <p>In the preceding section, indecently, from the warning message, we find out that the IP address of the container is <code>172.17.0.13</code>. On a fully configured HTTP server container, no such warning is available, so let's still run the <code>docker inspect</code> subcommand to retrieve the IP address using the container ID:</p>

      <pre><strong>$ sudo docker inspect \</strong><br/><strong>--format='{{.NetworkSettings.IPAddress}}' <br/>9d4d3566e55c0b8829086e9be2040751017989a47b5411c9c4f170ab865afcef</strong><br/><strong>172.17.0.13</strong>
</pre>

      <p>Having found the IP address of the container as <code>172.17.0.13</code>, let's quickly run a web request on this IP address from the shell prompt of the Docker host, using the <code>wget</code> command. Here, we choose to run the <code>wget</code> command with <code>-qO -</code> in order to run in the quiet mode and also display the retrieved HTML file on the screen:</p>

      <pre><strong>$ wget -qO - 172.17.0.13</strong>
</pre>

      <p>Here, we are showcasing just the first five lines of the retrieved HTML file:</p>

      <pre>&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" <br/> "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt; <br/>&lt;html &gt; <br/>  &lt;!-- <br/>    Modified from the Debian original for Ubuntu <br/>    Last updated: 2014-03-19 
</pre>

      <p>Awesome, isn't it? We got our first service running in a container, and we are able to reach out to our service from our Docker host.</p>

      <p>Furthermore, on a plain vanilla Docker installation, the service offered by one container is accessible by any other container within the Docker host. You can go ahead, launch a new Ubuntu container in the interactive mode, install the <code>wget</code> package using <code>apt-get</code>, and run the same <code>wget -qO - 172.17.0.13</code> command, as we did in the Docker host. Of course, you will see the same output.</p>
    
  

  
    
      <h2 id="sigil_toc_id_95">Exposing container services</h2>
    

    
      <p>So far, we successfully launched an HTTP service and accessed the service from the Docker host as well as another container within the same Docker host. Furthermore, as demonstrated in the <em>Building images from containers</em> section of <a href="../Text/Ch02.xhtml">Chapter 2</a>, <em>Handling Docker Containers</em>, the container is able to successfully install the <code>wget</code> package by making a connection to the publicly available APT repository over the Internet. Nonetheless, the outside world cannot access the service offered by a container by default. At the outset, this might seem like a limitation in the Docker technology. However, the fact is, the containers are isolated from the outside world by design.</p>

      <p>Docker achieves network isolation for the containers by the IP address assignment criteria, as enumerated here:</p>

      <ul>
        <li>Assigning a private IP address to the container, which is not reachable from an external network</li>

        <li>Assigning an IP address to the container outside the host's IP network</li>
      </ul>

      <p>Consequently, the Docker container is not reachable even from the systems that are connected to the same IP network as the Docker host. This assignment scheme also provides protection from an IP address conflict that might otherwise arise.</p>

      <p>Now, you might wonder how to make the services run inside a container that is accessible to the outside world, in other words, exposing container services. Well, Docker bridges this connectivity gap in a classy manner by leveraging the Linux <code>iptables</code> functionality under the hood.</p>

      <p>At the frontend, Docker provides two different building blocks for bridging this connectivity gap for its users. One of the building blocks is to bind the container port using the <code>-p</code> (publish a container's port to the host interface) option of the <code>docker run</code> subcommand. Another alternative is to use the combination of the <code>EXPOSE</code> instruction of <code>Dockerfile</code> and the <code>-P</code> (publish all exposed ports to the host interfaces) option of the <code>docker run</code> subcommand.</p>
    
  

  
    
      <h3 id="sigil_toc_id_96">Publishing a container's port - the -p option</h3>
    

    
      <p>Docker enables you to publish a service offered inside a container by binding the container's port to the host interface. The <code>-p</code> option of the <code>docker run</code> subcommand enables you to bind a container port to a user-specified or autogenerated port of the Docker host. Thus, any communication destined for the IP address and the port of the Docker host will be forwarded to the port of the container. The <code>-p</code> option, actually, supports the following four formats of arguments:</p>

      <ul>
        <li><code>&lt;hostPort&gt;:&lt;containerPort&gt;</code></li>

        <li><code>&lt;containerPort&gt;</code></li>

        <li><code>&lt;ip&gt;:&lt;hostPort&gt;:&lt;containerPort&gt;</code></li>

        <li><code>&lt;ip&gt;::&lt;containerPort&gt;</code></li>
      </ul>

      <p>Here, <code>&lt;ip&gt;</code> is the IP address of the Docker host, <code>&lt;hostPort&gt;</code> is the Docker host port number, and <code>&lt;containerPort&gt;</code> is the port number of the container. Here, in this section, we present you with the <code>-p &lt;hostPort&gt;:&lt;containerPort&gt;</code> format and introduce other formats in the succeeding sections.</p>

      <p>In order to understand the port binding process better, let's reuse the <code>apache2</code> HTTP server image that we crafted previously and spin up a container using a <code>-p</code> option of the <code>docker run</code> subcommand. The <code>80</code> port is the published port of the HTTP service, and as the default behavior, our <code>apache2</code> HTTP server is also available on port <code>80</code>. Here, in order to demonstrate this capability, we are going to bind port <code>80</code> of the container to port <code>80</code> of the Docker host, using the <code>-p &lt;hostPort&gt;:&lt;containerPort&gt;</code> option of the <code>docker run</code> subcommand, as shown in the following command:</p>

      <pre><strong>$ sudo docker run -d -p 80:80 apache2</strong><br/><strong>baddba8afa98725ec85ad953557cd0614b4d0254f45436f9cb440f3f9eeae134</strong>
</pre>

      <p>Now that we have successfully launched the container, we can connect to our HTTP server using any web browser from any external system (provided it has a network connectivity) to reach our Docker host.</p>

      <p>So far, we have not added any web pages to our <code>apache2</code> HTTP server image. Hence, when we connect from a web browser, we will get the following screen, which is nothing but the default page that comes along with the Ubuntu Apache2 package:</p>

      <div><img class=" image-border" height="104" src="img/image_06_006.png" width="527"/>
      </div>
    
  

  
    
      <h3 id="sigil_toc_id_97">NAT for containers</h3>
    

    
      <p>In the previous section, we saw how a <code>-p 80:80</code> option did the magic, didn't we? Well, in reality, under the hood, the Docker Engine achieves this seamless connectivity by automatically configuring the <strong>Network Address Translation</strong> (<strong>NAT</strong>) rule in the Linux <code>iptables</code> configuration files.</p>

      <p>To illustrate the automatic configuration of the NAT rule in Linux <code>iptables</code>, let's query the Docker hosts <code>iptables</code> for its NAT entries, as follows:</p>

      <pre><strong>$ sudo iptables -t nat -L -n</strong>  
</pre>

      <p>The ensuing text is an excerpt from the <code>iptables</code> NAT entry, which is automatically added by the Docker Engine:</p>

      <pre><strong>Chain DOCKER (2 references)</strong><br/><strong>target prot opt source destination</strong><br/><strong>DNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:80 to:172.17.0.14:80</strong>
</pre>

      <p>From the preceding excerpt, it is quite evident that the Docker Engine has effectively added a <code>DNAT</code> rule. The following are the details of the <code>DNAT</code> rule:</p>

      <ul>
        <li>The <code>tcp</code> keyword signifies that this <code>DNAT</code> rule applies only to the TCP transport protocol.</li>

        <li>The first <code>0.0.0.0/0</code> address is a meta IP address of the source address. This address indicates that the connection can originate from any IP address.</li>

        <li>The second <code>0.0.0.0/0</code> address is a meta IP address of the destination address on the Docker host. This address indicates that the connection can be made to any valid IP address in the Docker host.</li>

        <li>Finally, <code>dpt:80 to:172.17.0.14:80</code> is the forwarding instruction used to forward any TCP activity on port <code>80</code> of the Docker host to be forwarded to the <code>172.17.0.17</code> IP address, the IP address of our container and port <code>80</code>.</li>
      </ul>

      <p>Therefore, any TCP packet that the Docker host receives on port <code>80</code> will be forwarded to port <code>80</code> of the container.
      </p>
    
  

  
    
      <h3 id="sigil_toc_id_98">Retrieving the container port</h3>
    

    
      <p>The Docker Engine provides at least three different options to retrieve the container's port binding details. Here, let's first explore the options, and then, move on to dissect the retrieved information. The options are as follows:</p>

      <ul>
        <li>The <code>docker ps</code> subcommand always displays the port binding details of a container, as shown here:</li>
      </ul>

      <pre class="CDPAlignLeft CDPAlign"><strong> $ sudo docker ps</strong><br/><strong> CONTAINER ID IMAGE COMMAND </strong><br/><strong> CREATED STATUS PORTS </strong><br/><strong> NAMES</strong><br/><strong> baddba8afa98 apache2:latest </strong><br/><strong> "/usr/sbin/apache2ct </strong><br/><strong> 26 seconds ago Up 25 seconds </strong><br/><strong> 0.0.0.0:80-&gt;80/tcp </strong><br/><strong> furious_carson</strong>
</pre>

      <ul>
        <li>The <code>docker inspect</code> subcommand is another alternative; however, you have to skim through quite a lot of details. Run the following command:</li>
      </ul>

      <pre>      <strong>$ sudo docker inspect baddba8afa98</strong>
</pre>

      <ul>
        <li>The <code>docker inspect</code> subcommand displays the port binding related information in three JSON objects, as shown here:</li>
      </ul>

      <div><ul>
          <li>The <code>ExposedPorts</code> object enumerates all ports that are exposed through the <code>EXPOSE</code> instruction in <code>Dockerfile</code>, as well as the container ports that are mapped using the <code>-p</code> option in the <code>docker run</code> subcommand. Since we didn't add the <code>EXPOSE</code> instruction in our <code>Dockerfile</code>, what we have is just the container port that was mapped using <code>-p 80:80</code> as an argument to the <code>docker run</code> subcommand:</li>
        </ul>
      </div>

      <pre>            <strong> "ExposedPorts": {</strong><br/><strong> "80/tcp": {}</strong><br/><strong> },</strong>
</pre>

      <div><ul>
          <li>The <code>PortBindings</code> object is part of the <code>HostConfig</code> object, and this object lists out all the port binding done through the <code>-p</code> option in the <code>docker run</code> subcommand. This object will never list the ports exposed through the <code>EXPOSE</code> instruction in the <code>Dockerfile</code>:</li>
        </ul>
      </div>

      <pre><strong> "PortBindings": {</strong><br/><strong> "80/tcp": [</strong><br/><strong> {</strong><br/><strong> "HostIp": "",</strong><br/><strong> "HostPort": "80"</strong><br/><strong> }</strong><br/><strong> ]</strong><br/><strong> },</strong>
</pre>

      <p>      </p>

      <div><ul>
          <li>The <code>Ports</code> object of the <code>NetworkSettings</code> object has the same level of details, as the preceding <code>PortBindings</code> object. However, this object encompasses all ports that are exposed through the <code>EXPOSE</code> instruction in <code>Dockerfile</code>, as well as the container ports that are mapped using the <code>-p</code> option in the <code>docker run</code> subcommand:</li>
        </ul>
      </div>

      <pre><strong> "NetworkSettings": {</strong><br/><strong> "Bridge": "",</strong><br/><strong> "SandboxID":"ID removed for readability",</strong><br/><strong> "HairpinMode": false,</strong><br/><strong> "LinkLocalIPv6Address": "",</strong><br/><strong> "LinkLocalIPv6PrefixLen": 0,</strong><br/><strong> "Ports": {</strong><br/><strong> "80/tcp": [</strong><br/><strong> {</strong><br/><strong> "HostIp": "0.0.0.0",</strong><br/><strong> "HostPort": "80"</strong><br/><strong> }</strong><br/><strong> ]</strong><br/><strong> },</strong>
</pre>

      <p>Of course, the specific port field can be filtered using the <code>--format</code> option of the <code>docker inspect</code> subcommand.</p>

      <p>The <code>docker port</code> subcommand enables you to retrieve the port binding on the Docker host by specifying the container's port number:</p>

      <pre><strong>$ sudo docker port baddba8afa98 80</strong><br/><strong>0.0.0.0:80</strong>  
</pre>

      <p>Evidently, in all the preceding output excerpts, the information that stands out is the <code>0.0.0.0</code> IP address and the <code>80</code> port number. The <code>0.0.0.0</code> IP address is a meta address, which represents all the IP addresses configured on the Docker host. In effect, the <code>80</code> container's port is bound to all the valid IP addresses on the Docker host. Therefore, the HTTP service is accessible through any of the valid IP addresses configured on the Docker host.</p>
    
  

  
    
      <h3 id="sigil_toc_id_99">Binding a container to a specific IP address</h3>
    

    
      <p>Until now, with the method that you learned, the containers always get bound to all the IP addresses configured on the Docker host. However, you may want to offer different services on different IP addresses. In other words, a specific IP address and port would be configured to offer a particular service. We can achieve this in Docker using the <code>-p &lt;ip&gt;:&lt;hostPort&gt;:&lt;containerPort&gt;</code> option of the <code>docker run</code> subcommand, as shown in the following example:</p>

      <pre><strong>$ sudo docker run -d -p 198.51.100.73:80:80 apache2</strong><br/><strong>92f107537bebd48e8917ea4f4788bf3f57064c8c996fc23ea0fd8ea49b4f3335</strong>  
</pre>

      <p>Here, the IP address must be a valid IP address on the Docker host. If the specified IP address is not a valid IP address on the Docker host, the container launch will fail with an error message, as follows:</p>

      <pre><strong>2014/11/09 10:22:10 Error response from daemon: Cannot start container <br/>99db8d30b284c0a0826d68044c42c370875d2c3cad0b87001b858ba78e9de53b: <br/>Error starting user land proxy: listen tcp 10.110.73.34:49153: bind:cannot assign requested address</strong>
</pre>

      <p>Now, let's quickly review the port mapping as well the NAT entry for the preceding example:</p>

      <ul>
        <li>The following text is an excerpt from the output of the <code>docker ps</code> subcommand that shows the details of this container:</li>
      </ul>

      <pre><strong> 92f107537beb apache2:latest "/usr/sbin/apache2ct <br/> About a minute ago Up About a minute 198.51.100.73:80-&gt;80/tcp <br/> boring_ptolemy</strong>
</pre>

      <ul>
        <li>The following text is an excerpt from the output of the <code>iptables -n nat -L -n</code> command that shows the <code>DNAT</code> entry created for this container:</li>
      </ul>

      <pre><strong> DNAT tcp -- 0.0.0.0/0 198.51.100.73 tcp dpt:80 <br/> to:172.17.0.15:80</strong>
</pre>

      <p>After reviewing both the output of the <code>docker run</code> subcommand and the <code>DNAT</code> entry of <code>iptables</code>, you will realize how elegantly the Docker Engine has configured the service offered by the container on the <code>198.51.100.73</code> IP address and <code>80</code> port of the Docker host.</p>
    
  

  
    
      <h3 id="sigil_toc_id_100">Autogenerating the Docker host port</h3>
    

    
      <p>The Docker containers are innately lightweight and due to their lightweight nature, you can run multiple containers with the same or different service on a single Docker host. Particularly, autoscaling of the same service across several containers based on the demand is the need of the IT infrastructure today. Here, in this section, you will be informed about the challenge in spinning up multiple containers with the same service and also the Docker's way of addressing this challenge.</p>

      <p>Earlier in this chapter, we launched a container using Apache2 HTTP server by binding it to port <code>80</code> of the Docker host. Now, if we attempt to launch one more container with the same port <code>80</code> binding, the container would fail to start with an error message, as you can see in the following example:</p>

      <pre><strong>$ sudo docker run -d -p 80:80 apache2</strong><br/><strong>6f01f485ab3ce81d45dc6369316659aed17eb341e9ad0229f66060a8ba4a2d0e</strong><br/><strong>2014/11/03 23:28:07 Error response from daemon: Cannot start container <br/>6f01f485ab3ce81d45dc6369316659aed17eb341e9ad0229f66060a8ba4a2d0e: <br/>Bind for 0.0.0.0:80 failed: port is already allocated</strong>  
</pre>

      <p>Obviously, in the preceding example, the container failed to start because the previous container is already mapped to <code>0.0.0.0</code> (all the IP addresses of the Docker host) and port <code>80</code>. In the TCP/IP communication model, the combination of the IP address, port, and the transport protocols (TCP, UDP, and so on) has to be unique.</p>

      <p>We could have overcome this issue by manually choosing the Docker host port number (for instance, <code>-p 81:80</code> or <code>-p 8081:80</code>). Though this is an excellent solution, it does not scale well for autoscaling scenarios. Instead, if we give the control to Docker, it would autogenerate the port number on the Docker host. This port number generation is achieved by underspecifying the Docker host port number, using the <code>-p &lt;containerPort&gt;</code> option of the <code>docker run</code> subcommand, as shown in the following example:</p>

      <pre><strong>$ sudo docker run -d -p 80 apache2</strong><br/><strong>ea3e0d1b18cff40ffcddd2bf077647dc94bceffad967b86c1a343bd33187d7a8</strong>  
</pre>

      <p>Having successfully started the new container with the autogenerated port, let's review the port mapping as well the NAT entry for the preceding example:</p>

      <ul>
        <li>The following text is an excerpt from the output of the <code>docker ps</code> subcommand that shows the details of this container:</li>
      </ul>

      <pre><strong> ea3e0d1b18cf apache2:latest "/usr/sbin/apache2ct <br/> 5 minutes ago Up 5 minutes 0.0.0.0:49158-&gt;80/tcp <br/> nostalgic_morse</strong>  
</pre>

      <ul>
        <li>The following text is an excerpt from the output of the <code>iptables -n nat -L -n</code> command that shows the <code>DNAT</code> entry created for this container:</li>
      </ul>

      <pre><strong> DNAT tcp -- 0.0.0.0/0 0.0.0.0/0 tcp dpt:49158 <br/> to:172.17.0.18:80</strong>  
</pre>

      <p>After reviewing both the output of the <code>docker run</code> subcommand and the <code>DNAT</code> entry of <code>iptables</code>, what stands out is the <code>49158</code> port number. The <code>49158</code> port number is niftily autogenerated by the Docker Engine on the Docker host, with the help of the underlying operating system. Besides, the <code>0.0.0.0</code> meta IP address implies that the service offered by the container is accessible from outside, through any of the valid IP addresses configured on the Docker host.</p>

      <p>You may have a use case where you want to autogenerate the port number. However, if you still want to restrict the service to a particular IP address of the Docker host, you can use the <code>-p &lt;IP&gt;::&lt;containerPort&gt;</code> option of the <code>docker run</code> subcommand, as shown in the following example:</p>

      <pre><strong>$ sudo docker run -d -p 198.51.100.73::80 apache2</strong><br/><strong>6b5de258b3b82da0290f29946436d7ae307c8b72f22239956e453356532ec2a7</strong>
</pre>

      <p>In the preceding two scenarios, the Docker Engine autogenerated the port number on the Docker host and exposed it to the outside world. The general norm of network communication is to expose any service through a predefined port number so that anybody knows the IP address, and the port number can easily access the offered service. Whereas, here the port numbers are autogenerated and as a result, the outside world cannot directly reach the offered service. So, the primary purpose of this method of container creation is to achieve autoscaling, and the container created in this fashion would be interfaced with a proxy or load balance service on a predefined port.</p>
    
  

  
    
      <h3 id="sigil_toc_id_101">Port binding using EXPOSE and -P option</h3>
    

    
      <p>So far, we have discussed the four distinct methods to publish a service running inside a container to the outside world. In all these four methods, the port binding decision is taken during the container launch, and the image has no information about the ports on which the service is being offered. It has worked well so far because the image is being built by us, and we are pretty much aware of the port in which the service is being offered.</p>

      <p>However, in the case of third-party images, the port usage inside a container has to be published unambiguously. Besides, if we build images for third-party consumption or even for our own use, it is a good practice to explicitly state the ports in which the container offers its service. Perhaps, the image builders could ship a README document along with the image. However, it is even better to embed the port details in the image itself so that you can easily find the port details from the image both manually as well as through automated scripts.</p>

      <p>The Docker technology allows us to embed the port information using the <code>EXPOSE</code> instruction in the <code>Dockerfile</code>, which we introduced in <a href="../Text/Ch03.xhtml">Chapter 3</a>, <em>Building Images</em>. Here, let's edit the <code>Dockerfile</code> we used to build the <code>apache2</code> HTTP server image earlier in this chapter, and add an <code>EXPOSE</code> instruction, as shown in the following code. The default port for the HTTP service is port <code>80</code>, hence port <code>80</code> is exposed:</p>

      <pre>########################################### <br/># Dockerfile to build an apache2 image <br/>########################################### <br/># Base image is Ubuntu <br/>FROM ubuntu:16.04 <br/># Author: Dr. Peter <br/>MAINTAINER Dr. Peter &lt;peterindia@gmail.com&gt; <br/># Install apache2 package <br/>RUN apt-get update &amp;&amp;  <br/>     apt-get install -y apache2 &amp;&amp;  <br/>     apt-get clean <br/># Set the log directory PATH <br/>ENV APACHE_LOG_DIR /var/log/apache2 <br/># Expose port 80 <br/>EXPOSE 80 <br/># Launch apache2 server in the foreground <br/>ENTRYPOINT ["/usr/sbin/apache2ctl", "-D", "FOREGROUND"] 
</pre>

      <p>Now that we have added the <code>EXPOSE</code> instruction to our <code>Dockerfile</code>, let's move to the next step of building the image using the <code>docker build</code> command. Here, let's reuse the <code>apache2</code> image name, as shown here:</p>

      <pre><strong>$ sudo docker build -t apache2 .</strong>  
</pre>

      <p>Having successfully built the image, let's inspect the image to verify the effects of the <code>EXPOSE</code> instruction to the image. As we learned earlier, we can resort to the <code>docker inspect</code> subcommand, as shown here:</p>

      <pre><strong>$ sudo docker inspect apache2</strong>  
</pre>

      <p>On a close review of the output generated by the preceding command, you will realize that Docker stores the exposed port information in the <code>ExposedPorts</code> field of the <code>Config</code> object. The following is an excerpt to show how the exposed port information is being displayed:</p>

      <pre><strong>"ExposedPorts": {</strong><br/><strong> "80/tcp": {}</strong><br/><strong>},</strong>  
</pre>

      <p>Alternatively, you can apply the <code>--format</code> option to the <code>docker inspect</code> subcommand in order to narrow down the output to a very specific information. In this case, the <code>ExposedPorts</code> field of the <code>Config</code> object is shown in the following example:</p>

      <pre><strong>$ sudo docker inspect --format='{{.Config.ExposedPorts}}' </strong><strong>apache2</strong><br/><strong>map[80/tcp:map[]]</strong>  
</pre>

      <p>To resume our discussion on the <code>EXPOSE</code> instruction, we can now spin up containers using an <code>apache2</code> image, we just crafted. Yet, the <code>EXPOSE</code> instruction by itself cannot create a port binding on the Docker host. In order to create a port binding for the port declared using the <code>EXPOSE</code> instruction, the Docker Engine provides a <code>-P</code> option in the <code>docker run</code> subcommand.</p>

      <p>In the following example, a container is launched from the <code>apache2</code> image, which was rebuilt earlier. Here, the <code>-d</code> option is used to launch the container in the detached mode, and the <code>-P</code> option is used to create the port binding on the Docker host for all the ports declared, using the <code>EXPOSE</code> instruction in the <code>Dockerfile</code>:</p>

      <pre><strong>$ sudo docker run -d -P apache2</strong><br/><strong>fdb1c8d68226c384ab4f84882714fec206a73fd8c12ab57981fbd874e3fa9074</strong>  
</pre>

      <p>Now that we have started the new container with the image that was created using the <code>EXPOSE</code> instruction, like the previous containers, let's review the port mapping as well the NAT entry for the preceding example:</p>

      <ul>
        <li>The following text is an excerpt from the output of the <code>docker ps</code> subcommand that shows the details of this container:</li>
      </ul>

      <pre>      <strong>ea3e0d1b18cf apache2:latest "/usr/sbin/apache2ct <br/> 5 minutes ago Up 5 minutes 0.0.0.0:49159-&gt;80/tcp <br/> nostalgic_morse</strong> 
</pre>

      <ul>
        <li>The following text is an excerpt from the output of the <code>iptables -t nat -L -n</code> command that shows the <code>DNAT</code> entry created for this container:</li>
      </ul>

      <pre>      <strong>DNAT tcp -- 0.0.0.0/0 0.0.0.0/0 <br/> tcp dpt:49159 to:172.17.0.19:80</strong>
</pre>

      <p>The <code>-P</code> option of the <code>docker run</code> subcommand does not take any additional arguments, such as an IP address or a port number; consequently, fine-tuning of the port binding is not possible, such as the <code>-p</code> option of the <code>docker run</code> subcommand. You can always resort to the <code>-p</code> option of the <code>docker run</code> subcommand if fine-tuning of port binding is critical to you.</p>
    
  

  
    
      <h2 id="sigil_toc_id_102">Summary</h2>
    

    
      <p>Containers do not deliver anything substantial in an isolated or solo way. They need to be systematically built and provided with a network interface along with a port number. These lead to the standardized exposition of containers to the outside world, facilitating other hosts or containers to find, bind, and leverage their unique capabilities on any network. Thus, the network accessibility is paramount for containers to get noticed across and be utilized in innumerable ways. This chapter was dedicated to showcase how containers are being designed and deployed as a service, and how the aspect of container networking comes in handy in precisely and profusely empowering the peculiar world of container services as the days unfold. In the forthcoming chapters, we will deal and dwell at length on the various capabilities of Docker containers in the software-intensive IT environments.</p>
    
  
</body></html>