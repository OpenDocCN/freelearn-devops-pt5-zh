- en: Testing with Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Undoubtedly, the trait of testing has been at the forefront of the software
    engineering discipline. The deep and decisive presence of software in every kind
    of tangible object in our daily environments these days in order to have plenty
    of smart, connected, and digitized assets is widely accepted. Also, with an increased
    focus on distributed and synchronized software, the complexity of the software
    design, development, testing and debugging, deployment, and delivery are continuously
    on the rise. Various means and mechanisms are unearthed to simplify and streamline
    the much-needed automation of software building and the authentication of software
    reliability, resiliency, and sustainability. Docker is emerging as an extremely
    flexible tool to test a wide variety of software applications. In this chapter,
    we will discuss how to effectively leverage the noteworthy advancements of Docker
    for software testing and its unique advantages in accelerating and augmenting
    testing automation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics are discussed in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing your code inside Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Docker testing process into Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker containers are currently being leveraged to create development and testing
    environments that are the exact replicas of the production environment. Containers
    require less overhead when compared with virtual machines, which have been the
    primary environments for development, staging, and deployment environments. Let's
    start with an overview of **Test-driven Development** (**TDD**) of the next generation
    software and how Docker-inspired containerization becomes handy in simplifying
    the TDD process.
  prefs: []
  type: TYPE_NORMAL
- en: A brief overview of TDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The long and arduous journey of software development has taken many twists and
    turns in the past decades, and one of the prominent software engineering technique
    is nonetheless TDD.
  prefs: []
  type: TYPE_NORMAL
- en: For more details and documents on TDD refer to [http://agiledata.org/essays/tdd.html](http://agiledata.org/essays/tdd.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, TDD is a software development practice in which the development
    cycle begins with writing a test case that will fail, then writes the actual software
    to make the test pass, and continues to refactor and repeat the cycle till the
    software reaches the acceptable level. This process is depicted in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing your code inside Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we will take you through a journey in which we will show you
    how TDD is done using stubs and how Docker can come in handy when developing software
    in the deployment equivalent system. For this purpose, we take a web application
    use case that has a feature to track the visit count of each of its users. For
    this example, we use Python as the implementation language and `redis` as the
    key-value pair database to store the users hit count. Besides, to showcase the
    testing capability of Docker, we limit our implementation to just two functions—`hit`
    and `getHit`.
  prefs: []
  type: TYPE_NORMAL
- en: All the examples in this chapter use Python 3 as the runtime environment. The
    Ubuntu 16.04 installation comes with Python 3 by default. If you don't have Python
    3 installed on your system, refer to the respective manual to install Python 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the TDD practice, we start by adding unit test cases for the `hit` and
    `getHit` functions, as depicted in the following code snippet. Here, the test
    file is named `test_hitcount.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This example is also available at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: Here, in the first line, we are importing the `unittest` Python module that
    provides the necessary framework and functionality to run the unit test and generate
    a detailed report on the test execution. In the second line, we are importing
    the `hitcount` Python module, where we are going to implement the hit count functionality.
    Then, we will continue to add the test code that will test the `hitcount` module's
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the test suite using the unit test framework of Python, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output generated by the unit test framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, the test failed with the `ImportError: No module named ''hitcount''`
    error message because we had not even created the file and hence, it could not
    import the `hitcount` module.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, create a file with the `hitcount.py` name in the same directory as `test_hitcount.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Continue to run the unit test suite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the output generated by the unit test framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, the test suite failed like earlier, but with a different error message
    `AttributeError: ''module'' object has no attribute ''hit''`. We are getting this
    error because we have not implemented the `hit` function yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s proceed to implement the `hit` and `getHit` functions in `hitcount.py`,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: To continue with this example, you must have the Python 3 compatible version
    of package installer (`pip3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following command is used to install `pip3`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the preceding program, we are importing the `redis` driver,
    which is the connectivity driver of the `redis` database. In the following line,
    we are connecting to the `redis` database, and then we will continue to implement
    the `hit` and `getHit` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `redis` driver is an optional Python module, so let''s proceed to install
    the `redis` driver using the `pip` installer, which is illustrated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `unittest` module will still fail even after installing the `redis` driver
    because we are not running a `redis` database server yet. So, we can either run
    a `redis` database server to successfully complete our unit testing or take the
    traditional TDD approach of mocking the `redis` driver. Mocking is a testing approach
    wherein complex behavior is substituted by predefined or simulated behavior. In
    our example, to mock the `redis` driver, we are going to leverage a third-party
    Python package called `mockredis`. This mock package is available at [https://github.com/locationlabs/mockredis](https://github.com/locationlabs/mockredis)
    and the `pip` installer name is `mockredispy`. Let''s install this mock using
    the `pip` installer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Having installed `mockredispy`, the `redis` mock, let''s refactor our test
    code `test_hitcount.py` (which we had written earlier) to use the simulated `redis`
    functionality provided by the `mockredis` module. This is accomplished by the
    `patch` method provided by the `unittest.mock` mocking framework, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the test suite again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Finally, as we can see in the preceding output, we successfully implemented
    our visitors count functionality through the test, code, and refactor cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test inside a container
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the previous section, we walked you through the complete cycle of TDD, in
    which we installed additional Python packages to complete our development. However,
    in the real world, one might work on multiple projects that might have conflicting
    libraries and hence, there is a need for the isolation of runtime environments.
    Before the advent of Docker technology, the Python community used to leverage
    the Virtualenv tool to isolate the Python runtime environment. Docker takes this
    isolation a step further by packaging the OS, the Python toolchain, and the runtime
    environment. This type of isolation gives a lot of flexibility to the development
    community to use appropriate software versions and libraries as per the project
    needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the step-by-step procedure to package the test and visitor count implementation
    of the previous section to a Docker container and perform the test inside the
    container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Craft a `Dockerfile` to build an image with the `python3` runtime, the `redis`
    and `mockredispy` packages, and both the `test_hitcount.py` test file and the
    visitors count implementation `hitcount.py`, and finally, launch the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This example is also available on GitHub at [https://github.com/thedocker/testing/tree/master/src](https://github.com/thedocker/testing/tree/master/src).
  prefs: []
  type: TYPE_NORMAL
- en: Now create a directory called `src`, where we crafted our `Dockerfile`. Move
    the `test_hitcount.py` and `hitcount.py` files to the newly created `src` directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build the `hit_unittest` Docker image using the `docker build` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have successfully built the image, let''s launch our container
    with the unit testing bundle using the `docker run` subcommand, as illustrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, the unit test ran successfully with no errors because we already
    packaged the tested code.
  prefs: []
  type: TYPE_NORMAL
- en: In this approach, for every change, the Docker image is built and then the container
    is launched to complete the test.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Docker container as a runtime environment
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In the previous section, we built a Docker image to perform the testing. Particularly,
    in the TDD practice, the unit test cases and the code go through multiple changes.
    Consequently, the Docker image needs to be built over and over again, which is
    a daunting task. In this section, we will see an alternative approach in which
    the Docker container is built with a runtime environment, the development directory
    is mounted as a volume, and the test is performed inside the container.
  prefs: []
  type: TYPE_NORMAL
- en: During this TDD cycle, if an additional library or update to the existing library
    is required, then the container will be updated with the required libraries and
    the updated container will be committed as a new image. This approach gives the
    isolation and flexibility that any developer would dream of because the runtime
    and its dependency live within the container, and any misconfigured runtime environment
    can be discarded and a new runtime environment can be built from a previously
    working image. This also helps to preserve the sanity of the Docker host from
    the installation and uninstallation of libraries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example is a step-by-step instruction on how to use the Docker
    container as a non-polluting yet very powerful runtime environment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with launching the Python runtime interactive container, using the
    `docker run` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, in this example, the `/home/peter/src/hitcount` Docker host directory
    is earmarked as the placeholder for the source code and test files. This directory
    is mounted in the container as `/src`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, on another Terminal of the Docker host, copy both the `test_hitcount.py`
    test file and the `hitcount.py` visitors count implementation to the `/home/peter/src/hitcount`
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Switch to the Python runtime interactive container Terminal, change the current
    working directory to `/src`, and run the unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the test failed because it could not find the `mockredis` Python
    library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proceed to install the `mockredispy` pip package because the previous step
    failed as it could not find the `mockredis` library in the runtime environment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Rerun the Python unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Again, the test failed because the `redis` driver is not yet installed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Continue to install the `redis` driver using the `pip` installer, as shown
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Having successfully installed the `redis` driver, let''s once again run the
    unit test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Apparently, this time the unit test passed with no warnings or error messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a runtime environment that is good enough to run our test cases.
    It is better to commit these changes to a Docker image for reuse, using the `docker
    commit` subcommand:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: From now on, we can use the `python_rediswithmock` image to launch new containers
    for our TDD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In this section, we vividly illustrated the approach on how to use the Docker
    container as a testing environment, and also at the same time, preserve the sanity
    and sanctity of the Docker host by isolating and limiting the runtime dependency
    within the container.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Docker testing into Jenkins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we laid out a stimulating foundation on software testing,
    how to leverage the Docker technology for the software testing, and the unique
    benefits of the container technology during the testing phase. In this section,
    we will introduce you to the steps required to prepare the Jenkins environment
    for testing with Docker, and then, demonstrate how Jenkins can be extended to
    integrate and automate testing with Docker, using the well-known hit count use
    case.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the Jenkins environment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this section, we will take you through the steps to install Jenkins, the
    GitHub plugin for Jenkins and `git`, and the revision control tool. The steps
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with adding the Jenkins'' trusted PGP public key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using `wget` to download the PGP public key, and then we add it
    to the list of trusted keys using the `apt-key` tool. Since Ubuntu and Debian
    share the same software packaging, Jenkins provides a single common package for
    both Ubuntu and Debian.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the Debian package location to the `apt` package source list, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding the package source, continue to run the `apt-get` command `update`
    option to resynchronize the package index from the sources:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, install Jenkins using the `apt-get` command `install` option, as demonstrated
    here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, activate the Jenkins service using the `service` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The Jenkins service can be accessed through any web browser by specifying the
    IP address (`54.86.87.243`) of the system in which Jenkins is installed. The default
    port number for Jenkins is `8080`. The latest Jenkins 2.62 is already installed.
    The following screenshot is the entry page or dashboard of Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Provide the password from the file and login. This user is the admin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This will take you to the Customize Jenkins page, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_09_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select Install suggested plugins on the left-hand side of the screen, which
    will take us to the installation page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the Create First Admin User page, select Continue as admin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**![](img/image_09_004.jpg)**'
  prefs: []
  type: TYPE_NORMAL
- en: 'This will take us to the Jenkins is ready! page, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, clicking on the Start using Jenkins button will take you to the Welcome
    to Jenkins! page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_09_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Ensure that the `git` package is installed, otherwise install the `git` package
    using the `apt-get` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we have been running the Docker client using the `sudo` command, but
    unfortunately, we could not invoke `sudo` inside Jenkins because sometimes it
    prompts for a password. To overcome the `sudo` password prompt issue, we can make
    use of the Docker group, wherein any user who is part of the Docker group can
    invoke the Docker client without using the `sudo` command. Jenkins installation
    always sets up a user and group called `jenkins` and runs the Jenkins server using
    that user and group. So, we just need to add the `jenkins` user to the Docker
    group to get the Docker client working without the sudo command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Restart the Jenkins service for the group change to take effect using the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We have set up a Jenkins environment that is now capable of automatically pulling
    the latest source code from the [http://github.com](http://github.com) repository,
    packaging it as a Docker image, and executing the prescribed test scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: You are also encouraged to run Jenkins as a Docker container from the official
    Jenkins Docker image at [https://github.com/jenkinsci/docker](https://github.com/jenkinsci/docker).
    This will be very good exercise also to validate your Docker container concepts
    from previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Automating the Docker testing process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this section, we will explore how to automate testing using Jenkins and Docker.
    As mentioned earlier, we are going to use GitHub as our repository. We have already
    uploaded the `Dockerfile`, `test_hitcount.py`, and `hitcount.py` files of our
    previous example to GitHub at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    which we are to use in the ensuing example. However, we strongly encourage you
    to set up your own repository at
  prefs: []
  type: TYPE_NORMAL
- en: '[http://github.com](http://github.com), using the fork option that you can
    find at [https://github.com/thedocker/testing](https://github.com/thedocker/testing),
    and substitute this address wherever applicable in the ensuing example.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the detailed steps to automate Docker testing:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure Jenkins to trigger a build when a file is modified in the GitHub
    repository, which is illustrated in the following substeps:'
  prefs: []
  type: TYPE_NORMAL
- en: Connect to the Jenkins server again.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select create new jobs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in the following screenshot, give a name to the project (for example,
    `Docker-Testing`), and select Freestyle project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/JenkinsUpdate_1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As shown in the next screenshot, select the Git radio button under Source Code
    Management, and specify the GitHub repository URL in the Repository URL text field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_09_008.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Select Poll SCM under Build Triggers to schedule GitHub polling for every
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '15-minute interval. Type the following line of code `H/15 * * * *` in the Schedule
    textbox, as shown in the following screenshot. For testing purposes, you can reduce
    the polling interval:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/JenkinsUpdate_2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Scroll down the screen a little further and click on the Add build step button
    under Build. In the drop-down list, select Execute shell and type in the text,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/JenkinsUpdate_3.png)'
  prefs: []
  type: TYPE_IMG
- en: Finally, save the configuration by clicking on the Save button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to the Jenkins dashboard, and you can find your test listed on the
    dashboard:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_09_011.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can either wait for the Jenkins schedule to kick-start the build or you
    can click on the clock icon on the right-hand side of the screen to kick-start
    the build immediately. As soon as the build is done, the dashboard is updated
    with the build status as a success or failure and the build number:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_09_012.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you hover the mouse closer to the build number, you will get a drop-down
    button with options, such as Changes and Console Output, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/image_09_013.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The Console Output option will show the details highlighted for the build,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's test the failed case because of the wrong module name, `error_hitcount`,
    which we deliberately introduced. Now, let's experiment a negative scenario by
    deliberately introducing a bug in `test_hitcount.py` and observe the effect on
    the Jenkins build. As we have configured Jenkins, it faithfully polls the GitHub
    and kick-starts the build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Apparently, the build failed as we expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/image_09_014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As a final step, open Console Output of the failed build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Evidently, the test failed because of the wrong module name, `error_hitcount`,
    which we deliberately introduced.
  prefs: []
  type: TYPE_NORMAL
- en: Cool, isn't it? We automated our testing using Jenkins and Docker. Besides,
    we are able to experience the power of testing automation using Jenkins and Docker.
    In a large-scale project, Jenkins and Docker can be combined together to automate
    the complete unit testing needs, and thus, to automatically capture any defects
    and deficiencies introduced by any developers.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The potential benefits of containerization are being discovered across the breadth
    and the length of software engineering. Previously, testing sophisticated software
    systems involved a number of expensive and hard-to-manage server modules and clusters.
    Considering the costs and complexities involved, most of the software testing
    is accomplished using mocking procedures and stubs. All of this is going to end
    for good with the maturity of the Docker technology. The openness and flexibility
    of Docker enable it to work seamlessly with other technologies to substantially
    reduce the testing time and complexity.
  prefs: []
  type: TYPE_NORMAL
- en: For a long time, the leading ways of testing software systems included mocking,
    dependency, injection, and so on. Usually, these mandate creating many sophisticated
    abstractions in the code. The current practice for developing and running test
    cases against an application is actually done on stubs rather than on the full
    application. This means that, with a containerized workflow, it is very much possible
    to test against real application containers with all the dependencies. The contributions
    of the Docker paradigm, especially for the testing phenomenon and phase are therefore
    being carefully expounded and recorded in the recent past. Precisely speaking,
    the field of software engineering is moving towards smarter and sunnier days with
    all the innovations in the Docker space.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we clearly expounded and explained a powerful testing framework
    for integrated applications using the Docker-inspired containerization paradigm.
    Increasingly, for the agile world, the proven and potential TDD method is being
    insisted as an efficient software building and sustenance methodology. This chapter
    has utilized the Python unit test framework to illustrate how the TDD methodology
    is a pioneering tool for software engineering. The unit test framework is tweaked
    to be efficiently and elegantly containerized, and the Docker container is seamlessly
    integrated with Jenkins, which is a modern day deployment tool for continuous
    delivery, and is part and parcel of the agile programming world, as described
    in this chapter. The Docker container source code is pre-checked before it enters
    into the GitHub code repository. The Jenkins tool downloads the code from GitHub
    and runs the test inside a container. In the next chapter, we will dive deep into
    and describe the theoretical aspects of the process isolation through the container
    technology and various debugging tools and techniques.
  prefs: []
  type: TYPE_NORMAL
