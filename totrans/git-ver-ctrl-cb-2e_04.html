<html><head></head><body>
        

                            
                    <h1 class="header-title">Rebasing Regularly and Interactively, and Other Use Cases</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Rebasing commits to another branch</li>
<li>Continuing a rebase with merge conflicts</li>
<li>Rebasing selected commits interactively</li>
<li>Squashing commits using an interactive rebase</li>
<li>Changing the author of commits using a rebase</li>
<li>Autosquashing commits</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Rebase is an incredibly strong Git feature. Hopefully, you have used it before; if not, you might have heard about it. Rebasing is exactly what the word implies. So, if you have a certain commit, <kbd>A</kbd>, which is based on commit <kbd>B</kbd>, then rebasing <kbd>A</kbd> to <kbd>C</kbd> would result in commit <kbd>A</kbd> being based on commit <kbd>C</kbd>.</p>
<p>As you will see in the different examples in this chapter, it is not always as simple as that.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rebasing commits to another branch</h1>
                
            
            
                
<p>To start with, we are going to perform a very simple rebase, where we will introduce a new file, commit that file, make a change to it, and then commit it again so that we end up with two new commits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before we start, we need a repository to work in. You can use a previous clone of <kbd>jgit</kbd>, but to get a close-to-identical output from the example, you can clone the <kbd>jgit</kbd> repository.</p>
<p>The <kbd>jgit</kbd> repository can be cloned as follows:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit chapter4</strong>
<strong>$ cd chapter4</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We start by creating a local branch and then make two commits by performing the following steps; these are the commits that we want to rebase onto another branch:</p>
<ol>
<li>Check out a new branch, <kbd>rebaseExample</kbd>, which tracks <kbd>origin/stable-3.1</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b rebaseExample --track origin/stable-3.1</strong>
<strong>Branch rebaseExample set up to track remote branch stable-3.1  from origin.</strong>
<strong>Switched to a new branch 'rebaseExample'</strong></pre>
<ol start="2">
<li>Make two commits on the <kbd>rebaseExample</kbd> branch, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "My Fishtank</strong>
    
<strong>Gravel, water, plants</strong>
<strong>Fish, pump, skeleton" &gt; fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit -m "My brand new fishtank"</strong>
<strong>[rebaseExample 4b2c2ec] My brand new fishtank</strong>
  <strong>1 file changed, 4 insertions(+)</strong>
   <strong>create mode 100644 fishtank.txt</strong>
<strong>$ echo "mosquitos" &gt;&gt; fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit -m "Feeding my fish"</strong>
<strong>[rebaseExample 2132d88] Feeding my fish</strong>
  <strong>1 file changed, 1 insertion(+)</strong></pre>
<ol start="3">
<li>Then, we rebase the change on top of the <kbd>origin/stable-3.2</kbd> branch instead:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase origin/stable-3.2</strong>
<strong>First, rewinding head to replay your work on top of it...</strong>
<strong>Applying: My brand new fishtank</strong>
<strong>Applying: Feed the fish</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>When you execute <kbd>git rebase</kbd>, Git starts by finding the common ancestor of the current <kbd>HEAD</kbd> branch and the branch you want to rebase to. When Git finds <kbd>merge-base</kbd>, it will find the commits that are not available in the branch you are rebasing onto. Git will simply try to apply those commits one by one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Continuing a rebase with merge conflicts</h1>
                
            
            
                
<p>When you rebase a commit or a branch on top of a different <kbd>HEAD</kbd>, you may eventually see a conflict.</p>
<p>If there is a conflict, you will be asked to solve the merge conflict and continue with the rebase using <kbd>git rebase --continue</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will be creating a commit that adds the same <kbd>fishtank.txt</kbd> file on top of the <kbd>origin/stable-3.1</kbd> branch; then, we will try to rebase this on top of the <kbd>rebaseExample</kbd> branch we created in the <em>Rebasing commits to another branch</em> section:</p>
<ol>
<li>Check out the branch named <kbd>rebaseExample2</kbd>, which tracks <kbd>origin/stable-3.1</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b rebaseExample2 --track origin/stable-3.1</strong>
<strong>Checking out files: 100% (212/212), done.</strong>
<strong>Branch rebaseExample2 set up to track remote branch stable-3.1 from origin.</strong>
<strong>Switched to a new branch 'rebaseExample2'</strong></pre>
<ol start="2">
<li>Make a commit on the branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "My Fishtank</strong>
<strong>Pirateship, Oister shell</strong>
<strong>Coconut shell</strong>
<strong>"&gt;fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit -m "My brand new fishtank"</strong>
<strong>[rebaseExample2 39811d6] My brand new fishtank</strong>
  <strong>1 file changed, 4 insertions(+)</strong>
<strong>create mode 100644 fishtank.txt</strong></pre>
<ol start="3">
<li>Try to rebase the branch on top of the <kbd>rebaseExample</kbd> branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase rebaseExample</strong>
<strong>First, rewinding head to replay your work on top of it...</strong>
<strong>Applying: My brand new fishtank</strong>
<strong>Using index info to reconstruct a base tree...</strong>
<strong>&lt;stdin&gt;:12: new blank line at EOF.</strong>
  <strong>+</strong>
  <strong>warning: 1 line adds whitespace errors.</strong>
  <strong>Falling back to patching base and 3-way merge...</strong>
  <strong>Auto-merging fishtank.txt</strong>
  <strong>CONFLICT (add/add): Merge conflict in fishtank.txt</strong>
  <strong>Failed to merge in the changes.</strong>
  <strong>Patch failed at 0001 My brand new fishtank</strong>
  <strong>The copy of the patch that failed is found in:</strong>
 <strong>   /Users/JohnDoe/repos/chapter4/.git/rebase-apply/patch</strong>
    
  <strong>When you have resolved this problem, run "git rebase --continue".</strong>
  <strong>If you prefer to skip this patch, run "git rebase --skip" instead.</strong>
  <strong>To check out the original branch and stop rebasing, run "git rebase --abort".</strong></pre>
<ol start="4">
<li>You can solve the conflict in your preferred editor. Then, add the file to the index using <kbd>git add</kbd> and continue with the rebase.</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add fishtank.txt</strong>
<strong>$ git rebase --continue</strong>
<strong>Applying: My brand new fishtank</strong></pre>
<ol start="5">
<li>We can now check with <kbd>gitk</kbd> to see whether our change is rebased on top of the <kbd>rebaseExample</kbd> branch, as shown in the following screenshot:</li>
</ol>
<div><img class="alignnone size-full wp-image-196 image-border" src="img/a936be88-0c44-4f1c-987a-563944183fa7.png" style="width:26.25em;height:10.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As we learned from the first example, Git will apply the commits that are not available in the branch you are rebasing onto. In our example, it is only our commit, as we made it, that is available on the <kbd>rebaseExample2</kbd> branch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You might have noticed in the output of the failing rebase that you have two extra options for the commit.</p>
<p>When you have resolved this problem, run <kbd>git rebase --continue</kbd>. If you prefer to skip this patch, run <kbd>git rebase --skip</kbd> instead. To check out the original branch and stop rebasing, run <kbd>git rebase --abort</kbd>.</p>
<p>The first extra option we have is to totally ignore this patch by skipping it; you can do this using <kbd>git rebase --skip</kbd>. In our example, this will cause our branch to be fast-forwarded to the <kbd>rebaseExample</kbd> branch. So, both our branches will point to the same commit hash.</p>
<p>The second option is to abort the rebasing. If we choose to do this, then we will go back to the branch as it was prior to starting the rebase. This can be done using <kbd>git rebase --abort</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Rebasing selected commits interactively</h1>
                
            
            
                
<p>When you are working on a new feature and have branched from an old release into a feature branch, you might want to rebase this branch onto the latest release. When looking into the list of commits on the feature branch, you may realize that some of the commits are not suitable for the new release. In that case, when you want to rebase the branch onto a new release, you will need to remove some commits. This can be achieved with interactive rebasing, where Git gives you the option to pick the commits you wish to rebase.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To get started with this example, you need to check the previously created branch, <kbd>rebaseExample</kbd>; if you don't have this branch, follow the steps from the <em>Rebasing commits to another branch</em> section and use the following command:</p>
<pre><strong>$ git checkout rebaseExample</strong>
<strong>Switched to branch 'rebaseExample'</strong>
<strong>Your branch is ahead of 'origin/stable-3.1' by 109 commits.</strong>
<strong>(use "git push" to publish your local commits)</strong></pre>
<p>Notice that, because we are tracking <kbd>origin/stable-3.1</kbd>, the Git checkout will tell us how far ahead we are in comparison with that branch.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will try to rebase our current branch, <kbd>rebaseExample</kbd>, on top of the <kbd>origin/stable-3.1</kbd> branch by performing the following steps. Remember that Git will apply the commits that are not available on the branch we are rebasing to; so, in this case, there will be a lot of commits:</p>
<ol>
<li>Rebase the branch onto <kbd>origin/stable-3.1</kbd> by using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase --interactive origin/stable-3.1</strong></pre>
<ol start="2">
<li>What you will see now is a list of all the commits you will be rebasing onto the <kbd>origin/stable-3.1</kbd> branch. These commits are all the commits between the <kbd>origin/stable-3.1</kbd> and <kbd>rebaseExample</kbd> branches. The commits will be applied from top to bottom, hence, the commits will be listed in reverse order—at least compared to what you would normally see in Git. This actually makes good sense. The commits have the keyword <kbd>pick</kbd> to the left and then the abbreviated commit hash, and finally the title of the commit subject.</li>
</ol>
<p style="padding-left: 60px">If you scroll down to the bottom, you will see a list along the lines of the following:</p>
<pre style="padding-left: 60px"><strong>pick 43405e6 My brand new fishtank</strong>
<strong>pick 08d0906 Feed the fish</strong>
<strong># Rebase da6e87b..08d0906 onto da6e87b</strong>
<strong>#</strong>
<strong># Commands:</strong>
<strong>#  p, pick = use commit</strong>
<strong>#  r, reword = use commit, but edit the commit message</strong>
<strong>#  e, edit = use commit, but stop for amending</strong>
<strong>#  s, squash = use commit, but meld into previous commit</strong>
<strong>#  f, fixup = like "squash", but discard this commit's log message</strong>
<strong>#  x, exec = run command (the rest of the line) using shell</strong>
<strong>#</strong>
<strong># These lines can be re-ordered; they are executed from top to bottom.</strong>
<strong>#</strong>
<strong># If you remove a line here THAT COMMIT WILL BE LOST.</strong>
<strong>#</strong>
<strong># However, if you remove everything, the rebase will be aborted.</strong>
<strong>#</strong>
<strong># Note that empty commits are commented out</strong></pre>
<p style="padding-left: 60px">So, if we only want our <kbd>fishtank</kbd> commits to be based on top of the <kbd>origin/stable-3.1</kbd> branch, we should remove all the commits except for our two.</p>
<ol start="3">
<li>Remove all the lines except for the two commits at the bottom; for now, leave <kbd>pick</kbd> as the keyword. Save the file and close the editor, and you will get the following message from Git:</li>
</ol>
<pre style="padding-left: 60px"><strong>Successfully rebased and updated refs/heads/rebaseExample.</strong></pre>
<ol start="4">
<li>Now, with <kbd>gitk</kbd>, check whether we accomplished what we predicted. The next screenshot shows our two <kbd>fishtank</kbd> commits on top of the <kbd>origin/stable-3.1</kbd> branch. The following screenshot is what we expected:</li>
</ol>
<div><img class="alignnone size-full wp-image-197 image-border" src="img/2fa6ba1e-496b-4bc2-8814-ed2f55c70ce5.png" style="width:25.50em;height:11.08em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The same thing could actually be achieved with a single short Git command. We have been rebasing commits from the <kbd>origin/stable-3.2</kbd> branch to the <kbd>rebaseExample</kbd> branch onto the <kbd>origin/stable-3.2</kbd> branch. This can also be achieved in the following manner:</p>
<pre><strong>$ git rebase --onto origin/stable-3.1 origin/stable-3.2 rebaseExample</strong>
<strong>First, rewinding head to replay your work on top of it...</strong>
<strong>Applying: My brand new fishtank</strong>
<strong>Applying: Feed the fish</strong></pre>
<p class="mce-root CDPAlignLeft CDPAlign">The <kbd>--onto origin/stable-3.2</kbd> flag tells Git to rebase onto <kbd>origin/stable-3.2</kbd>, and it has to be from <kbd>origin/stable-3.1</kbd> to the <kbd>rebaseExample</kbd> branch. So, we end up having the <kbd>rebaseExample</kbd> branch to the branch of the <kbd>origin/stable-3.1</kbd> and so on. The next diagram illustrates both before the rebase example, where we have our two commits on top of <kbd>origin/stable-3.2</kbd>, and after the rebase, where our commits are on top of <kbd>origin/stable-3.1</kbd>, as we wanted:</p>
<div><img class="alignnone size-full wp-image-198 image-border" src="img/49a5c6d8-ec59-4496-8d7b-8864d0d28c6a.png" style="width:38.83em;height:21.83em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Squashing commits using an interactive rebase</h1>
                
            
            
                
<p>When I work on a local branch, I prefer to commit in small increments with a few comments on what I did in the commits; however, as these commits do not build or pass any test requirements, I cannot submit them for review and verification one by one. I have to merge them in my branch, but still, cherry-picking my fix would require me to cherry-pick twice the number of commits, which is not very handy.</p>
<p>What we can do is rebase and squash the commits into a single commit, or at least fewer commits.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To get started with this example, we need a new branch, namely <kbd>rebaseExample3</kbd>, which tracks <kbd>origin/stable-3.1</kbd>. Create the branch with the following command:</p>
<pre><strong>$ git checkout -b rebaseExample3 --track origin/stable-3.1</strong>
<strong>Branch rebaseExample3 set up to track remote branch stable-3.1 from origin.</strong>
<strong>Switched to a new branch 'rebaseExample3'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To really showcase this Git feature, we will start off six commits ahead of the <kbd>origin/stable-3.1</kbd> branch. This is to simulate the fact that we have just created six commits on top of the <kbd>rebaseExample3</kbd> branch; to do this, perform the following steps:</p>
<ol>
<li>Find a commit that is between <kbd>origin/stable-3.1</kbd> and <kbd>origin/stable-3.2</kbd>, and list the commits in reverse order. Alternatively, you can scroll down to the bottom of the output and find the commit we will use, as shown in the following snippet:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log origin/stable-3.1..origin/stable-3.2 --oneline --reverse</strong>
<strong>8a51c44 Do not close ArchiveOutputStream on error</strong>
<strong>3467e86 Revert "Close unfinished archive entries on error"</strong>
<strong>f045a68 Added the git-describe implementation</strong>
<strong>0be59ab Merge "Added the git-describe implementation"</strong>
<strong>fdc80f7 Merge branch 'stable-3.1'</strong>
<strong>7995d87 Prepare 3.2.0-SNAPSHOT builds</strong>
<strong>5218f7b Propagate IOException where possible when getting refs.</strong></pre>
<ol start="2">
<li>Reset the <kbd>rebaseExample3</kbd> branch to the <kbd>5218f7b</kbd> commit; this will simulate having six commits on top of the <kbd>origin/stable-3.1</kbd> branch. This can be tested by running the status of Git as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard 5218f7b</strong>
<strong>HEAD is now at 5218f7b Propagate IOException where possible when getting refs.</strong>
<strong>$ git status</strong>
<strong>On branch rebaseExample3</strong>
<strong>Your branch is ahead of 'origin/stable-3.1' by 6 commits.</strong>
<strong>(use "git push" to publish your local commits)</strong>
    
<strong>nothing to commit, working directory clean</strong></pre>
<ol start="3">
<li>Now, we have these six commits on top of the <kbd>origin/stable-3.1</kbd> branch, and we want to squash these commits into two different commits. This can be done by simply running <kbd>git rebase --interactive</kbd>. Note that we are not specifying which branch we want to rebase to, since we have already set up a tracking branch when we created the branch using <kbd>--track</kbd>.</li>
</ol>
<p style="padding-left: 60px">To continue, let's execute the rebase command as follows:</p>
<pre style="padding-left: 60px"><strong>$ git rebase --interactive</strong>
<strong>pick 8a51c44 Do not close ArchiveOutputStream on error</strong>
<strong>pick f045a68 Added the git-describe implementation</strong>
<strong>pick 7995d87 Prepare 3.2.0-SNAPSHOT builds</strong>
<strong>pick 5218f7b Propagate IOException where possible when getting refs.</strong></pre>
<ol start="4">
<li>The editor will open, and you will see four commits, not six as you would expect. This is because the rebase, in general, refuses to take merged commits as part of the rebase scenario. Although you can use the <kbd>--preserve-merges</kbd> flag, as per the Git Help section, this is not recommended.</li>
</ol>
<p>According to the Git Help section, instead of ignoring merges, <kbd>--preserve-merges</kbd> tries to recreate them. The <kbd>--preserve-merges</kbd> flag uses the <kbd>--interactive</kbd> machinery internally, but combining it with the <kbd>--interactive</kbd> option explicitly is generally not a good idea, unless you know what you are doing (see the bugs in the following snippet).</p>
<ol start="5">
<li>Edit the file so that it looks as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>pick 8a51c44 Do not close ArchiveOutputStream on error</strong>
<strong>squash f045a68 Added the git-describe implementation</strong>
<strong>pick 7995d87 Prepare 3.2.0-SNAPSHOT builds</strong>
<strong>squash 5218f7b Propagate IOException where possible when getting refs.</strong></pre>
<ol start="6">
<li>Remember that commits are listed in reverse order compared to the Git log. So, when squashing commits, we squash up into the commits we have marked with the <kbd>pick</kbd>. When you close the editor, Git will start the rebase from top to bottom. First, apply <kbd>8a51c44</kbd> and then squash <kbd>f045a68</kbd> into the commit <kbd>8a51c44</kbd>. This will open the commit message editor, which contains both of the commit messages. You can edit the commit messages, but for now, let's just close the editor to finish with the rebase and the squashing of these two commits. The editor will open one more time to complete the squashing of <kbd>5218f7b</kbd> into <kbd>7995d87</kbd>. Use <kbd>gitk</kbd> to verify the result.</li>
</ol>
<p style="padding-left: 60px">The following screenshot is as expected; now, we only have two commits on top of the <kbd>origin/stable-3.1</kbd> branch: </p>
<div><img class="alignnone size-full wp-image-199 image-border" src="img/e5490c91-8648-43ec-b575-50a267630a57.png" style="width:25.50em;height:12.58em;"/></div>
<ol start="7">
<li>If you check the commit message of the <kbd>HEAD</kbd> commit, you will see that it has the information of two commits, as shown in the following command. This is because we decided not to change the commit message when we made the change:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1
commit 9c96a651ff881c7d7c5a3974fa7a19a9c264d0a0
Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;
Date:   Thu Oct 3 17:40:22 2013 +0200
    
 Prepare 3.2.0-SNAPSHOT builds
    
 Change-Id: Iac6cf7a5bb6146ee3fe38abe8020fc3fc4217584
 Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;
    
 Propagate IOException where possible when getting refs.
    
 Currently, Repository.getAllRefs() and Repository.getTags() </strong><br/><strong> silently
 ignores an IOException and instead returns an empty map. Repository
  is a public API and as such cannot be changed until the next major
  revision change. Where possible, update the internal jgit APIs to
  use the RefDatabase directly, since it propagates the error.
    
 Change-Id: I4e4537d8bd0fa772f388262684c5c4ca1929dc4c</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Now we have squashed two commits, but we could have used other keywords when editing the rebase's to-do list.</p>
<p>We will try the fixup functionality, which works like the squash functionality, by performing the following steps; the exception is that Git will select the commit message of the commits using the <kbd>pick</kbd> keyword:</p>
<ol>
<li>Start by resetting back to our starting point:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard 5218f7b</strong>
<strong>HEAD is now at 5218f7b Propagate IOException where possible when getting refs.</strong>
<strong>$ git status</strong>
<strong>On branch rebaseExample3</strong>
<strong>Your branch is ahead of 'origin/stable-3.1' by 6 commits.</strong>
<strong>(use "git push" to publish your local commits)</strong>
    
<strong>nothing to commit, working directory clean</strong></pre>
<ol start="2">
<li>As you can see, we are back at the starting point, that is, we're six commits ahead of the <kbd>origin/stable-3.1</kbd> branch. Now we can try the fixup functionality. Start the interactive rebase and change the file according to the following output. Notice that you can use <kbd>f</kbd> instead of <kbd>fixup</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase --interactive</strong>
<strong>pick 8a51c44 Do not close ArchiveOutputStream on error</strong>
<strong>f f045a68 Added the git-describe implementation</strong>
<strong>pick 7995d87 Prepare 3.2.0-SNAPSHOT builds</strong>
<strong>f 5218f7b Propagate IOException where possible when getting refs.</strong></pre>
<ol start="3">
<li>Once you close the editor, you will see rebase's progress through Git. As predicted, the commit message editor will not open. Git will just rebase the changes into two commits on top of the <kbd>origin/stable-3.1</kbd> branch. Using <kbd>git status</kbd>, you can confirm that you have just two commits:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status<br/>On branch rebaseExample3<br/>Your branch is ahead of 'origin/stable-3.1' by 2 commits.<br/>  (use "git push" to publish your local commits)<br/><br/>nothing to commit, working tree clean</strong></pre>
<ol start="4">
<li>Another difference is that the commit message from the two commits we marked with fixup has disappeared. So, if you compare this with the previous example, it's very clear what the difference is; it's shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>    <br/><strong>commit c5bc5cc9e0956575cc3c30c3be4aecab19980e4d</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Thu Oct 3 17:40:22 2013 +0200</strong>
    
<strong>  Prepare 3.2.0-SNAPSHOT builds</strong>
    
<strong>  Change-Id: Iac6cf7a5bb6146ee3fe38abe8020fc3fc4217584</strong>
<strong>  Signed-off-by: Matthias Sohn matthias.sohn@sap.com</strong></pre>
<ol start="5">
<li>Finally, we can also confirm that we still have the same source code, but with different commits. This can be done by comparing this commit with the commit we created via <kbd>5218f7b</kbd>, using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git diff 5218f7b</strong></pre>
<p>As predicted, there is no output from <kbd>git diff</kbd>, so we still have the same source code.</p>
<p>This check can also be performed on the previous example.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the author of commits using a rebase</h1>
                
            
            
                
<p>When starting to work on a new project, it is common to forget to set the author name and author email address for the specified project. Therefore, you will often have commits in your local branch that have been committed with the wrong username and/or email ID.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before we begin this exercise, we need a branch, as always with Git. Name the branch <kbd>resetAuthorRebase</kbd> and make it track <kbd>origin/master</kbd>. Use the following command to achieve this:</p>
<pre><strong>$ git checkout -b resetAuthorRebase -t origin/master</strong>
<strong>Branch resetAuthorRebase set up to track remote branch 'master' from 'origin'.</strong>
<strong>Switched to a new branch 'resetAuthorRebase'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Now, we want to change the author of all the commits from <kbd>origin/stable-3.2</kbd> to our <kbd>HEAD</kbd>, which is <kbd>master</kbd>. This is just an example; you will rarely have to change the author of commits that have already been published to a remote repository.</p>
<p>You can change the author of the <kbd>HEAD</kbd> commit by using <kbd>git commit --amend --reset-author</kbd>; however, this will only change the author of <kbd>HEAD</kbd> and leave the rest of the commits as they were. We will start by changing the author of the <kbd>HEAD</kbd> commit and then verify why that is wrong by performing the following steps:</p>
<ol>
<li>Change the author of the <kbd>HEAD</kbd> commit as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --amend --reset-author</strong>
<strong>[resetAuthorRebase b0b2836] Update Kepler target platform to use Kepler SR2 orbi</strong><strong>t R-build</strong>
  <strong>1 file changed, 1 insertion(+), 1 deletion(-)</strong></pre>
<ol start="2">
<li>Verify that you have changed it using the Git log command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --format='format:%h %an &lt;%ae&gt;' origin/stable-3.2..HEAD</strong>
<strong>b0b2836 John Doe &lt;john.doe@example.com&gt;</strong>
<strong>b9a0621 Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>ba15d82 Matthias Sohn matthias.sohn@sap.com</strong></pre>
<ol start="3">
<li>We will list all the commits from <kbd>origin/stable-3.2</kbd> to <kbd>HEAD</kbd> and we will define a format with <kbd>%h</kbd> as the abbreviated commit hash, <kbd>%an</kbd> for the author's name, and <kbd>%ae</kbd> for the author's email address. From the output, you can see that I am now the author of the <kbd>HEAD</kbd> commit, but what we really wanted was to change the author of all the commits. To do this, we will rebase onto the <kbd>origin/stable-3.2</kbd> branch; then, for each commit, we will stop to amend and reset the author. Git can do most of that work with <kbd>--exec option</kbd> for the <kbd>git</kbd> rebase, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase --interactive --exec "git commit --amend --reset-author" origin/stable-3.2</strong>
<strong>pick b14a939 Prepare 3.3.0-SNAPSHOT builds</strong>
<strong>exec git commit --amend --reset-author</strong>
<strong>pick f2abbd0 archive: Prepend a specified prefix to all entry filenames</strong>
<strong>exec git commit --amend --reset-author</strong></pre>
<ol start="4">
<li>As you can see, Git has opened the rebase's to-do list for you, and between every commit, you have the <kbd>exec</kbd> keyword and the command we specified on the command line. You can have more <kbd>exec</kbd> lines between commits if you have a use case for them. Closing the editor will start the rebase.</li>
</ol>
<p> </p>
<ol start="5">
<li>As you will see, this process is not very good, as the commit message editor opens every time and you have to close the editor to allow Git to continue with the rebase. To stop the rebase, clear the commit message editor and Git will return to the command line; then, you can use <kbd>git rebase --abort</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>Executing: git commit --amend --reset-author</strong>
<strong>Aborting commit due to empty commit message.</strong>
<strong>Execution failed: git commit --amend --reset-author</strong>
<strong>You can fix the problem, and then run</strong>
    
<strong>        git rebase --continue</strong>
<strong>$ git rebase --abort</strong></pre>
<p style="padding-left: 60px">To achieve what we really want, you can add the <kbd>--reuse-message</kbd> option for <kbd>git commit</kbd>; this will reuse the commit message for the commit you will specify. We want to use the message of <kbd>HEAD</kbd>, as we are going to amend it to the <kbd>HEAD</kbd> commit. So, try again, as shown in the following command:</p>
<pre style="padding-left: 60px"><strong>$ git rebase --interactive --exec "git commit --amend --reset-author --reuse-message=HEAD" origin/stable-3.2</strong>
<strong>Executing: git commit --amend --reset-author --reuse-message=HEAD</strong>
<strong>[detached HEAD 0cd3e87] Prepare 3.3.0-SNAPSHOT builds</strong>
<strong> 51 files changed, 291 insertions(+), 291 deletions(-)</strong>
<strong> rewrite org.eclipse.jgit.java7.test/META-INF/MANIFEST.MF (62%)</strong>
<strong> rewrite org.eclipse.jgit.junit/META-INF/MANIFEST.MF (73%)</strong>
 <strong>rewrite org.eclipse.jgit.pgm.test/META-INF/MANIFEST.MF (61%)</strong>
 <strong>rewrite org.eclipse.jgit.test/META-INF/MANIFEST.MF (76%)</strong>
 <strong>rewrite org.eclipse.jgit.ui/META-INF/MANIFEST.MF (67%)</strong>
    <strong>Executing: git commit --amend --reset-author --reuse-message=HEAD</strong>
    <strong>[detached HEAD faaf25e] archive: Prepend a specified prefix to all entry filenam</strong><strong>es</strong>
    <strong> 5 files changed, 115 insertions(+), 1 deletion(-)</strong>
    <strong>Executing: git commit --amend --reset-author --reuse-message=HEAD</strong>
    <strong>[detached HEAD cfd743e] [CLI] Add option --millis / -m to debug-show-dir-cache c</strong>
    <strong>Command</strong>
    <strong>Successfully rebased and updated refs/heads/resetAuthorRebase.</strong></pre>
<ol start="6">
<li>Git provides an output indicating that the action was a success; however, to verify this, you can execute the previous Git log command and you should see that the email address has changed on all the commits, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --format='format:%h %an &lt;%ae&gt;' origin/stable-3.2..HEAD</strong>
<strong>9b10ff9 John Doe &lt;john.doe@example.com&gt;</strong>
<strong>d8f0ada John Doe &lt;john.doe@example.com&gt;</strong>
<strong>53df2b7 John Doe &lt;john.doe@example.com&gt;</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>It works as you would expect! There is one thing to remember: when using the <kbd>exec</kbd> option, Git will check the work area for unstaged and staged changes. Consider the following command line:</p>
<pre> <strong>exec echo rainy_day &gt; weather_main.txt<br/> exec echo sunny_day &gt; weather_california.txt</strong></pre>
<p>If you were to have a line as illustrated in the preceding command, the first <kbd>exec</kbd> would be executed and you would then have an unstaged change in your work area. Git would complain and you would have to solve that before continuing with the next <kbd>exec</kbd>.</p>
<p>So, if you want to do something like this, you must create a single exec line that executes all the things you want. Besides this, the rebase functionality is fairly simple; it just tries to apply the changes in the order specified in the rebase's to-do list. Git will only apply the changes specified in the list, so if you remove some of them, they will not be applied. This is a way to clean up a feature branch for unwanted commits, for instance, commits that enable you to debug.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Autosquashing commits</h1>
                
            
            
                
<p>When I work with Git, I often create a lot of commits for a single bug fix, but when making the delivery to the remote repository, I prefer—and recommend—delivering the bug fix as one commit. This can be achieved with an interactive rebase, but since this should be a common workflow, Git has a built-in feature called autosquash, which will help you squash the commits together.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Before we begin with this exercise, we will create a branch from <kbd>origin/master</kbd> so we are ready to add commits to our fix.</p>
<p>Let's start with something like this:</p>
<pre><strong>$ git checkout -b readme_update_developer --track origin/master</strong>
<strong>Branch readme_update_developer set up to track remote branch master from origin.</strong>
<strong>Switched to a new branch 'readme_update_developer'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>After checking the branch, we will create the first commit that we want to squash other commits to. We need to use the abbreviated commit hash from this commit to automatically create other commits that will squash to this commit by performing the following steps:</p>
<ol>
<li>Start by echoing some text into <kbd>README.md</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "More information for developers" &gt;&gt; README.md</strong></pre>
<ol start="2">
<li>This will append more information to <kbd>README.md</kbd> for developers; verify that the file has changed using the Git status as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong>
<strong>On branch readme_update_developer</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
<strong>Changes not staged for commit:</strong>
<strong>  (use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>  (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
    <strong>        modified:   README.md</strong>
    
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong></pre>
<ol start="3">
<li>Now, we want to add and commit this. We can do this with the <kbd>commit</kbd> command using the <kbd>-a</kbd> flag, which will add any unstaged changes to the commit, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit -a -m "Updating information for developers"</strong>
<strong>[readme_update_developer d539645] Updating information for developers</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<ol start="4">
<li>After you create the commit, remember the abbreviated commit hash; we have highlighted it in bold in the command output. The abbreviation will be different in your environment, and you should have your own abbreviation once you finish the exercise.</li>
<li>To continue, we will add three commits to the branch, and we would like to squash two of these with the first commit, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "even More information for developers" &gt;&gt; README.md</strong>
<strong>$ git commit -a --squash=d539645 --no-edit</strong>
<strong>[readme_update_developer d62922d] squash! Updating information for developers</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<ol start="6">
<li>This is the first commit. Pay attention to why we needed to store the abbreviated hash of the first commit—we used it with the <kbd>--squash</kbd> option for <kbd>git commit</kbd>. This option will create the commit with the subject of the commit specified. It will also add <kbd>squash!</kbd> to the start of the subject. This is to indicate that Git should squash this commit when performing a rebase. Now, create the second commit, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "even More information for developers" &gt;&gt; README.md</strong>
<strong>$ git commit -a --squash=d539645 --no-edit</strong>
<strong>[readme_update_developer 7d6194d] squash! Updating information for developers</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<ol start="7">
<li>We have added two commits that we would like to squash with the first commit. When committing, I also used the <kbd>--no-edit</kbd> option; this skips the opening of the commit's message editor. If you leave the flag out, the editor will open as it usually does when committing. The difference is that the commit subject has already been set, and you only need to write the commit message. Now, we will create the last commit; we don't want to squash this commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "Adding configuration information" &gt;&gt; README.md</strong>
<strong>$ git commit -a -m "Updating information on configuration"</strong>
<strong>[readme_update_developer fd07857] Updating information on configuration</strong>
<strong> 1 file changed, 1 insertion(+)</strong></pre>
<ol start="8">
<li>We add the final commit, which does not have anything to do with the first three commits we added. This is why we did not use the <kbd>--squash</kbd> option. We can now squash the commits together using <kbd>git rebase -i</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase -i</strong></pre>
<ol start="9">
<li>You will get the rebase's to-do list up in the configured commit editor. What we would have expected was to have Git configure a squash for the commits we wanted to squash, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>pick d539645 Updating information for developers</strong>
<strong>pick d62922d squash! Updating information for developers</strong>
<strong>pick 7d6194d squash! Updating information for developers</strong>
<strong>pick fd07857 Updating information on configuration</strong></pre>
<ol start="10">
<li>What you can see is that Git inserted <kbd>squash</kbd> to the subject of two of the commits, but besides this, we did not get what we had expected. Git requires you to specify <kbd>--autosquash</kbd> to the <kbd>git rebase -i</kbd> command. Close the editor and Git will perform the rebase and give the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>Successfully rebased and updated </strong><strong>refs/heads/readme_update_developer.</strong></pre>
<ol start="11">
<li>Let's try again with <kbd>--autosquash</kbd> and see what happens with the rebase's to-do list:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git rebase -i --autosquash</strong>
<strong>pick d539645 Updating information for developers</strong>
<strong>squash d62922d squash! Updating information for developers</strong>
<strong>squash 7d6194d squash! Updating information for developers</strong>
<strong>pick fd07857 Updating information on configuration</strong></pre>
<ol start="12">
<li>Now, the rebase's to-do list looks much more as we expected. Git has preconfigured the to-do list to show which commits it will squash and which commits it will keep.</li>
<li>Closing the to-do list now will start the rebase, and we don't want that (the next step will show what we really want). If you clear the to-do list (deleting all lines), save and close the editor, the rebase will be aborted. This is what we want. The output will be as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>Nothing to do</strong></pre>
<ol start="14">
<li>What we really want to do is just run <kbd>git rebase -i</kbd> and Git will use <kbd>--autosquash</kbd> as the default. This can be achieved with <kbd>git config rebase.autosquash true</kbd>; try it and then run <kbd>git rebase -i</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config rebase.autosquash true</strong>
<strong>$ git rebase -i</strong></pre>
<ol start="15">
<li>The rebase's to-do list pops up, and we have the expected result as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>pick d539645 Updating information for developers</strong>
<strong>squash d62922d squash! Updating information for developers</strong>
<strong>squash 7d6194d squash! Updating information for developers</strong>
<strong>pick fd07857 Updating information on configuration</strong></pre>
<ol start="16">
<li>Now close the editor and allow the rebase to start. The editor opens and you can change the commit message for the combined message, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong># This is a combination of 3 commits.</strong>
<strong># The first commit's message is:</strong>
<strong>Updating information for developers</strong>
    
<strong># This is the 2nd commit message:</strong>
    
<strong>squash! Updating information for developers</strong>
    
<strong># This is the 3rd commit message:</strong>
    
<strong>squash! Updating information for developers</strong></pre>
<ol start="17">
<li>Modify the message and close the editor; Git continues with the rebase and ends with the following message:</li>
</ol>
<pre style="padding-left: 60px"><strong>[detached HEAD baadd53] Updating information for developers</strong>
<strong>  1 file changed, 3 insertions(+)</strong>
<strong>Successfully rebased and updated refs/heads/readme_update_developer.</strong>
<strong>Verify the commit log with git log -3</strong>
<strong>$ git log -3</strong>
<strong>commit 6d83d44645e330d0081d3679aca49cd9bc20c891</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Wed May 21 10:52:03 2014 +0200</strong>
    
<strong>    Updating information on configuration</strong>
    
<strong>commit baadd53018df2f6f3cdf88d024c3b9db16e526cf</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Wed May 21 10:25:43 2014 +0200</strong>
    
<strong>    Updating information for developers</strong>
<strong>commit 6d724dcd3355f09e3450e417cf173fcafaee9e08</strong>
<strong>Author: Shawn Pearce &lt;spearce@spearce.org&gt;</strong>
<strong>Date:   Sat Apr 26 10:40:30 2014 -0700</strong></pre>
<ol start="18">
<li>As expected, we now have two commits on top of the <kbd>origin/master</kbd> commit.</li>
</ol>
<p>Hopefully, this will assist you when you are just making changes and committing them, but want to deliver the code as one commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If you want to avoid opening the commit message editor, as in step 17 of the <em>Autosquashing commits</em> recipe, you can use <kbd>--fixup=d539645</kbd>. This will use the commit message from the first commit and totally disregard any message written in the commits.</p>


            

            
        
    </body></html>