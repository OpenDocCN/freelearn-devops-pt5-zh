<html><head></head><body><div><div><p id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor109"/><em class="italic">Chapter 3</em></p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor110"/>Storing and Distributing Images </h1>
			<p>In this chapter, we will cover several services, such as Docker Hub, which allows you to store your images, and Docker Registry, which you can use to run your local storage for Docker containers. We will review the differences between these services, as well as when and how to use each of them. This chapter will also cover how to set up automated builds using web hooks, as well as all the pieces that are required to set them up. </p>
			<p>Let's take a quick look at the topics we will cover in this chapter:</p>
			<ul>
				<li><a id="_idTextAnchor111"/>U<a id="_idTextAnchor112"/>nderstanding Docker Hub</li>
				<li>Deploying your own Docker registry</li>
				<li>Reviewing third-party registries</li>
				<li>Looking at Microbadger</li>
			</ul>
			<p>Let's get started!</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor113"/>Technical requirements</h1>
			<p>In this chapter, we will be using our Docker installation to build images. As mentioned in the previous chapter, although the screenshots in this chapter will be from my preferred operating system, which is macOS, the commands we will be running will work on all three operating systems covered in the previous chapters.</p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3iaKo9I">https://bit.ly/3iaKo9I</a></p>
			<h1 id="_idParaDest-60"><a id="_idTextAnchor114"/>Understanding Docker Hub</h1>
			<p>Although we were introduced to Docker Hub in the previous two chapters, we haven't interacted with it much <a id="_idIndexMarker171"/>other than when using the <code>docker image pull</code> command to download remote images.</p>
			<p>In this section, we will focus on Docker Hub, which has both a freely available option, where you can only host publicly accessible images, and also a subscription option, which allows you to host your own private images. We will focus on the web aspect of Docker Hub and the management you can do there.</p>
			<p>The home page, which <a id="_idIndexMarker172"/>can be found at <a href="https://hub.docker.com">https://hub.docker.com</a>, contains a <strong class="bold">Sign-Up</strong> form and, at the top-right, an option to <strong class="bold">Sign in</strong>. The odds are that if you have <a id="_idIndexMarker173"/>been dabbling with Docker, then you already have a Docker ID. If you don't, use the <strong class="bold">Sign-Up</strong> form on the home page to create one. If you already have a Docker ID, then simply click <strong class="bold">Sign in</strong>.</p>
			<p>Once logged in, you will be presented with the main Dashboard.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor115"/>The Docker Hub Dashboard</h2>
			<p>After logging <a id="_idIndexMarker174"/>in to Docker Hub, you will be taken to the following landing page. This page is known as the Dashboard of Docker Hub:</p>
			<div><div><img src="img/Figure_3.01_B15659.jpg" alt="Figure 3.1 – The initial Docker Hub Dashboard&#13;&#10;" width="1637" height="1033"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – The initial Docker Hub Dashboard</p>
			<p>From here, you can get to all the other subpages of Docker Hub. However, before we look at those sections, we should talk a little about the Dashboard. From here, you can view all <a id="_idIndexMarker175"/>your images, both public and private. They are ordered first by the number of stars and then by the number of pulls; this order cannot be changed.</p>
			<p>In the upcoming sections, we will go through everything you can see on the Dashboard, starting with the light blue menu at the top of the page.</p>
			<h3>Explore</h3>
			<p>The Explore option <a id="_idIndexMarker176"/>takes you to a list of official Docker images; like your Dashboard, they are ordered by stars and then pulls. As shown in the following screenshot, I have selected the base images. Each of the most popular official images has had over 10 million downloads and have thousands of stars:</p>
			<div><div><img src="img/Figure_3.02_B15659.jpg" alt="Figure 3.2 – Exploring Docker Hub&#13;&#10;" width="1639" height="1243"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Exploring Docker Hub</p>
			<p>Docker Hub now integrates the Docker Store, giving you a one-stop shop for everything Docker-related from a single location rather than several different sources.</p>
			<h3>Repositories</h3>
			<p>We will go <a id="_idIndexMarker177"/>into more detail about creating a repository when in the <em class="italic">Creating an automated build </em>section of this chapter, so I will not go into any details here. This section is where you can manage your own repositories. As shown in the following screenshot, you get a quick overview of how many people have started you repository, as well as how many pulls your image has had, along with details of whether the repository is public or private:</p>
			<div><div><img src="img/Figure_3.03_B15659.jpg" alt="Figure 3.3 – A list of my repositories in Docker &#13;&#10;" width="1650" height="762"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – A list of my repositories in Docker </p>
			<p>As you can see, there is a <strong class="bold">Create Repository</strong> button here. Since we are going to be looking at this process in more detail when it comes to the <em class="italic">Creating an automated build</em> section, we will move on to the next option.</p>
			<h3>Organizations</h3>
			<p><strong class="bold">Organizations</strong> are those <a id="_idIndexMarker178"/>that you have either created or been added to. <strong class="bold">Organizations</strong> allow you to layer on control for, say, a project that multiple people are collaborating on. The organization gets its own settings, such as whether to store repositories as public or private by default or changing plans that will allow different numbers of private repositories and separate repositories altogether from the ones you or others have:</p>
			<div><div><img src="img/Figure_3.04_B15659.jpg" alt="Figure 3.4 – Viewing my list of organizations&#13;&#10;" width="1649" height="553"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – Viewing my list of organizations</p>
			<p>You can <a id="_idIndexMarker179"/>also access or switch between accounts or organizations from the Dashboard just below the Docker logo, where you will typically see your username when you log in:</p>
			<div><div><img src="img/Figure_3.05_B15659.jpg" alt="Figure 3.5 – Switching organizations&#13;&#10;" width="1650" height="764"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – Switching organizations</p>
			<p>Organizations are useful when it comes to managing how you distribute your container images for different projects/applications.  </p>
			<h3>Get Help</h3>
			<p>This dropdown menu is a jumping off point to various help and support sites managed by Docker. Let's take <a id="_idIndexMarker180"/>a quick look where each of these links will lead you to:</p>
			<ul>
				<li><strong class="bold">Documentation</strong>: This takes you to the official documentation for Docker Hub.</li>
				<li><strong class="bold">Docker Hub</strong>: This takes you straight to the Docker Hub category on the Docker community forums.</li>
				<li><strong class="bold">What's New</strong>: This takes you to a list of Docker Blog posts tagged with Docker Hub.</li>
				<li><strong class="bold">Support</strong>: This is an FAQ about Docker Hub with the option to contact support.</li>
			</ul>
			<h3>Profile and settings</h3>
			<p>The final <a id="_idIndexMarker181"/>option in the top menu is about managing your <strong class="bold">Profile</strong>, <strong class="bold">Content</strong>, and <strong class="bold">Settings</strong>:</p>
			<div><div><img src="img/Figure_3.06_B15659.jpg" alt="Figure 3.6 – Viewing your profile&#13;&#10;" width="1631" height="696"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – Viewing your profile</p>
			<p>The settings page allows you to set up your public profile, which includes the following options:</p>
			<ul>
				<li><strong class="bold">General</strong>: You can add email addresses to your account, change your password, and configure what information is visible in your profile, such as your name, company location, and a link.</li>
				<li><strong class="bold">Linked Accounts</strong>: Here, you can link your GitHub and Bitbucket accounts (more details on this will be discussed in the <em class="italic">Creating an automated build</em> section of this chapter).</li>
				<li><strong class="bold">Security</strong>: This is where you can manage personal access tokens and the recently introduced Two-Factor authentication.</li>
				<li><strong class="bold">Default Privacy</strong>: Do you want your newly created repositories to be public or private by default? This is where you can choose.</li>
				<li><strong class="bold">Notifications</strong>: This is where you can sign up to notifications about your builds and account activity. Here, you can provide an email address or connect to a Slack installation.</li>
				<li><strong class="bold">Convert Account</strong>: Here, you can convert your account into an organization. You probably don't want to do this; read the warnings on the page before going any further with this option.</li>
				<li><strong class="bold">Deactivate Account</strong>: This does exactly what you would think it does. Again, take a look at the warnings <a id="_idIndexMarker182"/>on the page before doing anything as this action cannot be undone.</li>
				<li><strong class="bold">My Profile</strong>: This menu <a id="_idIndexMarker183"/>item takes you to your public profile page; mine can be found at  <a href="https://hub.docker.com/u/russmckendrick/">https://hub.docker.com/u/russmckendrick/</a>.</li>
				<li><strong class="bold">My Content</strong>: This link takes you to a list of containers that you may have subscribed to on Docker Hub.</li>
			</ul>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor116"/>Creating an automated build</h2>
			<p>In this section, we will <a id="_idIndexMarker184"/>look at automated builds. Automated builds are those that you can link to your GitHub or Bitbucket account(s), and as you update the code in your code repository, you can have the image automatically built on Docker Hub. We will look at all the pieces required to do so. By the end of this section, you'll be able to automate your own builds.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor117"/>Setting up your code</h2>
			<p>The first step to <a id="_idIndexMarker185"/>creating an automated build is to set up your GitHub or Bitbucket repository. These are the two options you have while selecting where to store your code. For example, I will be using GitHub, but the setup will be the same for you if you were using GitHub or Bitbucket.</p>
			<p>In fact, I will be using the repository that accompanies this book. Since the repository is publicly available, you can fork it and follow along using your own GitHub account, as I have done in the following screenshot:</p>
			<div><div><img src="img/Figure_3.07_B15659.jpg" alt="Figure 3.7 – Forking the accompanying GitHub repository&#13;&#10;" width="1650" height="1003"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Forking the accompanying GitHub repository</p>
			<p>In <a href="B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Container Images</em>, we worked through a few different Dockerfiles. We will be using these for our automated builds. As you may recall, we installed NGINX and added a simple page with the message <strong class="bold">Hello world! This is being served from Docker</strong>. We also had a multi-stage build.</p>
			<p>Now that we know which Dockerfile we will be using, let's set up a repository in Docker Hub.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor118"/>Setting up Docker Hub</h2>
			<p>In <strong class="bold">Docker Hub</strong>, we are <a id="_idIndexMarker186"/>going to use the <strong class="bold">Create Repository</strong> button, which can be found under <strong class="bold">Repositories</strong>. After clicking it, we will be taken to a screen where we need to provide a little information about our build. We will also need to select a source:</p>
			<div><div><img src="img/Figure_3.08_B15659.jpg" alt="Figure 3.8 – Creating a repository in Docker Hub&#13;&#10;" width="1307" height="889"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – Creating a repository in Docker Hub</p>
			<p>As you can see from the preceding screenshot, I already have my GitHub account linked to my Docker Hub account. The process of linking the two tools was simple – all I had to do was allow Docker Hub <a id="_idIndexMarker187"/>permission to access my GitHub account by following the on-screen instructions.</p>
			<p>When connecting Docker Hub to GitHub, there are two options:</p>
			<ul>
				<li><strong class="bold">Public:</strong> This limits Docker Hub's access to publicly available repositories and organizations. If you link your accounts using this option, Docker Hub won't be able to configure the web hooks needed for automated builds. You then need to search and select the repository from either of the locations you want to create the automated build from. This will essentially create a web hook that is triggered each time a commit is made on the selected GitHub repository. With this, a new build will be created on Docker Hub.</li>
				<li><strong class="bold">Private</strong>: This is the recommended option out of the two as Docker Hub will have access to all your public and private repositories, as well as organizations. Docker Hub will also be able to configure the web hooks needed when setting up automated builds.</li>
			</ul>
			<p>In the preceding screenshot, I selected <code>masteringdockerfourthedition</code> and visited the settings page for the automated build. From here, we can choose which Docker Hub profile the image is attached to, name the image, change it from a public to a privately available image, describe the build, and customize it by clicking on <strong class="bold">Click here to customise</strong>. </p>
			<p>We can let Docker Hub know the location of our Dockerfile as follows:</p>
			<div><div><img src="img/Figure_3.09_B15659.jpg" alt="Figure 3.9 – This is what the completed form looks like&#13;&#10;" width="1316" height="929"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.9 – This is what the completed form looks like</p>
			<p>If you <a id="_idIndexMarker188"/>are following along, I entered the following information:</p>
			<ul>
				<li><code>dockerfile-example</code></li>
				<li><code>Testing an automated build</code></li>
				<li><code>Public</code></li>
			</ul>
			<p>Then, under <strong class="bold">Build Settings</strong>, select <strong class="bold">GitHub</strong>:</p>
			<ul>
				<li><strong class="bold">Organization</strong>: Select the GitHub organization where your code is hosted.</li>
				<li><code>Master-Docker-Fourth-Edition</code>.</li>
			</ul>
			<p>Click on the + icon next to Build Rules and then enter the following:</p>
			<ul>
				<li><code>Branch</code></li>
				<li><code>master</code></li>
				<li><code>latest</code></li>
				<li><code>Dockerfile</code></li>
				<li><strong class="bold">Build Caching</strong>: Leave this selected</li>
			</ul>
			<p>Upon clicking on <strong class="bold">Create</strong>, you will be taken to a screen similar to the following:</p>
			<div><div><img src="img/Figure_3.10_B15659.jpg" alt="Figure 3.10 – The created repository&#13;&#10;" width="1640" height="1075"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.10 – The created repository</p>
			<p>Now that we <a id="_idIndexMarker189"/>have our build defined, we can add some additional configurations by clicking on <strong class="bold">Builds</strong>. Since we are using the official Alpine Linux image in our Dockerfile, we can link that to our own build. When doing this, we also need to configure an additional path. To do this follow these steps:</p>
			<ol>
				<li>Click on the <strong class="bold">Configure Automated Builds</strong> button. Then, click on the <strong class="bold">Enable for Base Image</strong> radio icon in the <strong class="bold">Repository Links</strong> section of the configuration and then the <strong class="bold">Save</strong> button. </li>
				<li>This will kick off an unattended build each time a new version of the official Alpine Linux image is published. </li>
				<li>Next, scroll down to <code>./chapter02/dockerfile-example/</code>. This will make sure that Docker's build servers can find any files that we add to our Dockerfile:</li>
			</ol>
			<div><div><img src="img/Figure_3.11_B15659.jpg" alt="Figure 3.11 – Linking our repository to our Dockerfile&#13;&#10;" width="1622" height="926"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.11 – Linking our repository to our Dockerfile</p>
			<p>So, now, our image will be automatically rebuilt and published whenever we update the GitHub repository, or when a new official image is published. </p>
			<p>As neither of <a id="_idIndexMarker190"/>these is likely to happen immediately, click on the <strong class="bold">Trigger</strong> button on the <strong class="bold">Builds</strong> page to manually kick off a build:</p>
			<div><div><img src="img/Figure_3.12_B15659.jpg" alt="Figure 3.12 – Triggering a build&#13;&#10;" width="1464" height="620"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.12 – Triggering a build</p>
			<p>You will notice that the <strong class="bold">Trigger</strong> button turns into a spinning icon and that <strong class="bold">Latest Build Status</strong> changes to <strong class="bold">PENDING</strong>, as shown in the following screenshot. This confirms that a build has been scheduled in the background:</p>
			<div><div><img src="img/Figure_3.13_B15659.jpg" alt="Figure 3.13 – The build is progressing&#13;&#10;" width="1604" height="690"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.13 – The build is progressing</p>
			<p>Once you <a id="_idIndexMarker191"/>have triggered your build, scroll down to <strong class="bold">Recent Builds</strong>. This will list all of the builds for the image – successful, failed, and ones that are in progress. You should see a build underway; clicking on the build will bring up the logs for it:</p>
			<div><div><img src="img/Figure_3.14_B15659.jpg" alt="Figure 3.14 – Viewing the progress of the build &#13;&#10;" width="1618" height="1462"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.14 – Viewing the progress of the build </p>
			<p>Once built, you <a id="_idIndexMarker192"/>should then able to move to your local Docker installation by running the following commands, making sure to pull your own image if you have been following along:</p>
			<pre>$ docker image pull masteringdockerfouthedition/dockerfile-example:latest
$ docker image ls</pre>
			<p>These commands are shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.15_B15659.jpg" alt="Figure 3.15 – Pulling our newly built image &#13;&#10;" width="1650" height="623"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.15 – Pulling our newly built image </p>
			<p>You can also <a id="_idIndexMarker193"/>run the image created by Docker Hub using the following command, again making sure to use your own image if you have one:</p>
			<pre>$ docker container run -d -p8080:80 --name example masteringdockerthirdedition/dockerfiles-example</pre>
			<p>I also add the multi-stage build in exactly the same way. Docker Hub had no problem with the build, as shown by the following logs, which start off with a little bit of information about Docker's build environment:</p>
			<pre>Cloning into '.'...
Warning: Permanently added the RSA host key for IP address '140.82.114.3' to the list of known hosts.
Reset branch 'master'
Your branch is up-to-date with 'origin/master'.
KernelVersion: 4.4.0-1060-aws
Components: [{u'Version': u'18.03.1-ee-3', u'Name': u'Engine', u'Details': {u'KernelVersion': u'4.4.0-1060-aws', u'Os': u'linux', u'BuildTime': u'2018-08-30T18:42:30.000000000+00:00', u'ApiVersion': u'1.37', u'MinAPIVersion': u'1.12', u'GitCommit': u'b9a5c95', u'Arch': u'amd64', u'Experimental': u'false', u'GoVersion': u'go1.10.2'}}]
Arch: amd64
BuildTime: 2018-08-30T18:42:30.000000000+00:00
ApiVersion: 1.37
Platform: {u'Name': u''}
Version: 18.03.1-ee-3
MinAPIVersion: 1.12
GitCommit: b9a5c95
Os: linux
GoVersion: go1.10.2</pre>
			<p>The build <a id="_idIndexMarker194"/>then starts by compiling our code, as follows:</p>
			<pre>Starting build of index.docker.io/masteringdockerfouthedition/multi-stage:latest...
Step 1/8 : FROM golang:latest as builder
---&gt; 374d57ff6662
Step 2/8 : WORKDIR /go-http-hello-world/
Removing intermediate container 63fc21e72f2b
---&gt; 25ed949838cf
Step 3/8 : RUN go get -d -v golang.org/x/net/html
---&gt; Running in 57072354b296
get "golang.org/x/net/html": found meta tag get.metaImport{Prefix:"golang.org/x/net", VCS:"git", RepoRoot:"https://go.googlesource.com/net"} at //golang.org/x/net/html?go-get=1
get "golang.org/x/net/html": verifying non-authoritative meta tag
golang.org/x/net (download)
Removing intermediate container 57072354b296
---&gt; 6731fc3ade79
Step 4/8 : ADD https://raw.githubusercontent.com/geetarista/go-http-hello-world/master/hello_world/hello_world.go ./hello_world.go
---&gt; 2129f7e7cbab
Step 5/8 : RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o app .
---&gt; Running in 9d5646bf1b92
Removing intermediate container 9d5646bf1b92
---&gt; 997b92d1a701</pre>
			<p>Now that <a id="_idIndexMarker195"/>our code has been compiled, it moves on to copying the application binary to what will be the final image using <code>scratch</code>:</p>
			<pre>Step 6/8 : FROM scratch
---&gt;
Step 7/8 : COPY --from=builder /go-http-hello-world/app .
---&gt; 70eb0af7f82c
Step 8/8 : CMD ["./app"]
---&gt; Running in 41cc8b47f714
Removing intermediate container 41cc8b47f714
---&gt; 71fc328a30c4
Successfully built 71fc328a30c4
Successfully tagged masteringdockerfouthedition/multi-stage:latest
Pushing index.docker.io/masteringdockerfouthedition/multi-stage:latest...
Done!
Build finished
You can pull and launch a container using the image with the following commands:
$ docker image pull masteringdockerfouthedition/multi-stage
$ docker image ls
$ docker container run -d -p 8000:80 --name go-hello-world masteringdockerfouthedition/multi-stage
$ curl http://localhost:8000/</pre>
			<p>As you can <a id="_idIndexMarker196"/>see from the following screenshot, the image acts in the exact same way as it did when we created it locally:</p>
			<div><div><img src="img/Figure_3.16_B15659.jpg" alt="Figure 3.16 – Pulling our multi-stage environment and launching the build&#13;&#10;" width="1650" height="913"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.16 – Pulling our multi-stage environment and launching the build</p>
			<p>You can remove the containers if you launched them by using the following commands:</p>
			<pre>$ docker container stop example go-hello-world 
$ docker container rm example go-hello-world</pre>
			<p>Now that we have looked at automated builds, we will discuss how else we can push images to Docker Hub.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor119"/>Pushing your own image</h2>
			<p>In <a href="B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a><em class="italic">, Building Container Images</em>, we discussed creating an image without using a Dockerfile. While this <a id="_idIndexMarker197"/>is still not a good idea and should only be done when you really need to, you can push your own images to Docker Hub.</p>
			<p class="callout-heading">Tip</p>
			<p class="callout">When pushing images to Docker Hub in this way, ensure that you do not include any code, files, or environment variables you would not want to be publicly accessible.</p>
			<p>To do this, we first need to link our local Docker client to Docker Hub by running the following command:</p>
			<pre>$ docker login</pre>
			<p>You will then be prompted for your Docker ID and password. However, if you have enabled multi-factor authentication, then you will need to use a personal access token rather than your password. To create a personal access token, go to <strong class="bold">Settings</strong> in Docker Hub, click on <strong class="bold">Security</strong> from the left-hand menu, and then click the <strong class="bold">New Access Token</strong> button. As per the on-screen instructions, the access token will only be displayed once, so make sure you make a note of it. Treat personal access tokens as alternatives to your password and store them appropriately:</p>
			<div><div><img src="img/Figure_3.17_B15659.jpg" alt="Figure 3.17 – Logging into Docker Hub using the Docker client&#13;&#10;" width="1650" height="298"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.17 – Logging into Docker Hub using the Docker client</p>
			<p>Also, if you are using Docker for Mac or Docker for Windows, you will now be logged in via the app and should be able to access Docker Hub from the menu:</p>
			<div><div><img src="img/Figure_3.18_B15659.jpg" alt="Figure 3.18 – Viewing your Docker Hub details in Docker Desktop&#13;&#10;" width="1213" height="714"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.18 – Viewing your Docker Hub details in Docker Desktop</p>
			<p>Now that our <a id="_idIndexMarker198"/>client is authorized to interact with Docker Hub, we need an image to build. </p>
			<p>Let's look at pushing the scratch image we built in <a href="B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068"><em class="italic">Chapter 2</em></a>, <em class="italic">Building Container Images</em>. First, we need to build the image. To do this, I am using the following command:</p>
			<pre>$ docker build --tag masteringdockerfouthedition/scratch-example:latest .</pre>
			<p>If you are following along, then you should replace <code>masteringdockerfouthedition</code> with your own username or organization:</p>
			<div><div><img src="img/Figure_3.19_B15659.jpg" alt="Figure 3.19 – Building an image locally&#13;&#10;" width="1650" height="554"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.19 – Building an image locally</p>
			<p>Once the <a id="_idIndexMarker199"/>image has been built, we can push it to Docker Hub by running the following command:</p>
			<pre>$ docker image push masteringdockerfouthedition/scratch-example:latest</pre>
			<p>The following screenshot shows the output:</p>
			<div><div><img src="img/Figure_3.20_B15659.jpg" alt="Figure 3.20 – Pushing an image to Docker Hub&#13;&#10;" width="1650" height="262"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.20 – Pushing an image to Docker Hub</p>
			<p>As you can see, because we defined <code>masteringdockerfouthedition/scratchexample:latest</code> when we built the image, Docker automatically uploaded the image to that location, which, in turn, added a new image to the <code>masteringdockerfouthedition</code> organization:</p>
			<div><div><img src="img/Figure_3.21_B15659.jpg" alt="Figure 3.21 – Viewing our locally built image in Docker Hub&#13;&#10;" width="1650" height="907"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.21 – Viewing our locally built image in Docker Hub</p>
			<p>You will notice <a id="_idIndexMarker200"/>that there is not much you can do with the build in Docker Hub. This is because the image was not built by Docker Hub, and therefore, it does not really have any idea what has gone into building the image, which is exactly why this method of distributing images is discouraged.</p>
			<p>Now that we have discussed how to distribute images, let's look at the complete opposite and discuss certified images and publ<a id="_idTextAnchor120"/>i<a id="_idTextAnchor121"/>shers.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor122"/>Docker Certified Images and Verified Publishers</h2>
			<p>You may <a id="_idIndexMarker201"/>remember that in <a href="B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046"><em class="italic">Chapter 1</em></a>, <em class="italic">Docker Overview</em>, we downloaded Docker <a id="_idIndexMarker202"/>for macOS and Docker for Windows, as well as Docker Hub. As well as acting as a single location for downloading both Docker CE and Docker EE for various platforms, it is now also the preferred location for finding Docker Plugins, Docker Certified Images, and Images from Verified Publishers:</p>
			<div><div><img src="img/Figure_3.22_B15659.jpg" alt="Figure 3.22 – Exploring Docker Certified Images on Docker Hub&#13;&#10;" width="1614" height="1235"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.22 – Exploring Docker Certified Images on Docker Hub</p>
			<p>Taking a <a id="_idIndexMarker203"/>closer look at the <strong class="bold">Splunk Enterprise</strong> image in Docker Hub gives <a id="_idIndexMarker204"/>you information about who is responsible for the image. It also shows that it is a certified image, as shown in the following screenshot:</p>
			<div><div><img src="img/Figure_3.23_B15659.jpg" alt="Figure 3.23 – Viewing the Splunk Enterprise Docker Hub image&#13;&#10;" width="1639" height="621"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.23 – Viewing the Splunk Enterprise Docker Hub image</p>
			<p>As you <a id="_idIndexMarker205"/>may have noticed, the image has a price attached to it (the Free version is $0.00, but is limited), meaning that you can buy commercial software <a id="_idIndexMarker206"/>through Docker Hub since it has payments and licensing built in. If you are a software publisher, you can sign and distribute your own software through Docker Hub.</p>
			<h1 id="_idParaDest-67"><a id="_idTextAnchor123"/>Deploying your own Docker Registry</h1>
			<p>In this section, we will look at Docker Registry. Docker Registry is an open source application that you can run anywhere <a id="_idIndexMarker207"/>you please and store your Docker image in. We will provide at a comparison between Docker Registry and Docker Hub, as well as how to choose between the two. </p>
			<p>By the end of this section, you will have learned how to run your own Docker Registry and check whether it's a proper fit for you.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor124"/>An overview of Docker Registry</h2>
			<p>Docker Registry, as stated earlier, is an open source application that you can utilize to store your Docker images <a id="_idIndexMarker208"/>on a platform of your choice. This allows you to keep them 100% private if you wish or share them as needed.</p>
			<p>Docker Registry makes a lot of sense if you want to deploy your own registry without having to pay for all the private features of Docker Hub. Let's take a look at some comparisons between Docker Hub and Docker Registry to help you make an educated decision as to which option is best for you when it comes to choosing to store your own images.</p>
			<p>Docker Registry <a id="_idIndexMarker209"/>has the following features:</p>
			<ul>
				<li>You can host and manage your own registry, from which you can serve all the repositories as private, public, or a mix between the two.</li>
				<li>You can scale the registry as needed, based on how many images you host or how many pull requests you are serving out.</li>
				<li>Everything is command-line-based.</li>
			</ul>
			<p>With Docker Hub, you will be able to do the following:</p>
			<ul>
				<li>Get a GUI-based interface that you can use to manage your images</li>
				<li>Have a location already set up in the cloud that is ready to handle public and/or private images</li>
				<li>Have the peace of mind of not having to manage a server that is hosting all your images</li>
			</ul>
			<p>Now that we know the differences between deploying our own registry and Docker Hub, let's look at the steps for deploying our own registry.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor125"/>Deploying your own registry</h2>
			<p>As you may <a id="_idIndexMarker210"/>have already guessed, Docker Registry is distributed as an image from Docker Hub, which makes deploying it as easy as running the following commands:</p>
			<pre>$ docker image pull registry:2
$ docker container run -d -p 5000:5000 --name registry registry:2</pre>
			<p>Running these commands should give you something like the following Terminal output:</p>
			<div><div><img src="img/Figure_3.24_B15659.jpg" alt="Figure 3.24 – Deploying your Docker Registry&#13;&#10;" width="1588" height="626"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.24 – Deploying your Docker Registry</p>
			<p>These commands <a id="_idIndexMarker211"/>will give you the most basic installation of Docker Registry. Let's take a quick look at how we can push and pull an image to it. To start off with, we need an image, so let's grab the Alpine image (again):</p>
			<pre>$ docker image pull alpine</pre>
			<p>Now that we have a copy of the Alpine Linux image, we need to push it to our local Docker Registry, which is available at <code>localhost:5000</code>. To do this, we need to tag the Alpine Linux image with the URL of our local Docker Registry, along with a different image name:</p>
			<pre>$ docker image tag alpine localhost:5000/localalpine</pre>
			<p>Now that we have tagged our image, we can push it to our locally hosted Docker Registry by running the following command:</p>
			<pre>$ docker image push localhost:5000/localalpine</pre>
			<p>The following screenshot shows the output of the preceding commands:</p>
			<div><div><img src="img/Figure_3.25_B15659.jpg" alt="Figure 3.25 – Pushing an image to your own Docker Registry&#13;&#10;" width="1650" height="531"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25 – Pushing an image to your own Docker Registry</p>
			<p>Try running the following command:</p>
			<pre>$ docker image ls</pre>
			<p>The output should show you that you have two images with the same <code>IMAGE ID</code>:</p>
			<div><div><img src="img/Figure_3.26_B15659.jpg" alt="Figure 3.26 – Listing the images&#13;&#10;" width="1304" height="307"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.26 – Listing the images</p>
			<p>Before we pull the image back down from our local Docker Registry, we should remove the two local copies of the image. We need to use the <code>REPOSITORY</code> name to do this, rather than <code>IMAGE ID</code>, since we have <a id="_idIndexMarker212"/>two images from two locations with the same ID, and Docker will throw an error:</p>
			<pre>$ docker image rm alpine localhost:5000/localalpine</pre>
			<p>Now that the original and tagged images have been removed, we can pull the image from our local Docker Registry by running the following command:</p>
			<pre>$ docker image pull localhost:5000/localalpine
$ docker image ls</pre>
			<p>As you can see, we now have a copy of our image that has been pulled from the Docker Registry running at <code>localhost:5000</code>:</p>
			<div><div><img src="img/Figure_3.27_B15659.jpg" alt="Figure 3.27 – Pulling from your own Docker Registry&#13;&#10;" width="1602" height="582"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.27 – Pulling from your own Docker Registry</p>
			<p>You can stop and remove the Docker Registry by running the following commands:</p>
			<pre>$ docker container stop registry
$ docker container rm -v registry</pre>
			<p>Now, there are a lot of options and considerations when it comes to launching a Docker Registry. As you can imagine, the most important is in regards to storage.</p>
			<p>Given that a registry's sole purpose is storing and distributing images, it is important that you use some level of persistent OS storage. Docker Registry currently supports the following storage options:</p>
			<ul>
				<li><code>/var/lib/registry</code>.</li>
				<li><strong class="bold">Azure</strong>: This uses Microsoft Azure Blob Storage.</li>
				<li><strong class="bold">GCS</strong>: This uses <a id="_idIndexMarker213"/>Google Cloud storage.</li>
				<li><strong class="bold">S3</strong>: This uses <strong class="bold">Amazon Simple Storage Service</strong> (<strong class="bold">Amazon S3</strong>).</li>
				<li><strong class="bold">Swift</strong>: This uses OpenStack Swift.</li>
			</ul>
			<p>As you <a id="_idIndexMarker214"/>can see, other than the filesystem, all the storage engines that are supported are all highly available, distributed, object-level forms of storage. </p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor126"/>Docker Trusted Registry</h2>
			<p>One of the <a id="_idIndexMarker215"/>components that ships with the commercial <strong class="bold">Docker Enterprise Edition</strong> (<strong class="bold">Docker EE</strong>) is <strong class="bold">Docker Trusted Registry</strong> (<strong class="bold">DTR</strong>), both of which are now <a id="_idIndexMarker216"/>being developed and supported by Mirantis. Think of it as a version of Docker Hub that you can host in your own infrastructure. DTR adds the following features <a id="_idIndexMarker217"/>on top of the ones provided by the free Docker Hub and Docker Registry:</p>
			<ul>
				<li>Integration into your authentication services, such as Active Directory or LDAP</li>
				<li>Deployment on your own infrastructure (or cloud) behind your firewall</li>
				<li>Image signing to ensure your images are trusted</li>
				<li>Built-in security scanning</li>
				<li>Access to prioritized support directly from Mirantis</li>
			</ul>
			<h1 id="_idParaDest-71"><a id="_idTextAnchor127"/>Reviewing third-party registries</h1>
			<p>It is not only Docker that offers image registry services; companies such as Red Hat offer their own registry, where you <a id="_idIndexMarker218"/>can find the Red Hat Container Catalog, which hosts containerized versions of all of Red Hat's product offerings, along with containers to support its OpenShift offering. Services such as Artifactory by JFrog offer a private Docker registry as part of their build services.</p>
			<p>There are also other Registry-as-a-Service offerings, such as Quay, which is also by Red Hat, as well as services from GitHub, Amazon Web Services, Microsoft Azure, and Google Cloud. </p>
			<p>Let's take a quick look at some of these services.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor128"/>GitHub Packages and Actions</h2>
			<p>The first service <a id="_idIndexMarker219"/>we are going to look at is GitHub Packages. Here, we will <a id="_idIndexMarker220"/>take a look at uploading a container to my fork <a id="_idIndexMarker221"/>of this book's GitHub repository. First of all, we are going to need a personal <a id="_idIndexMarker222"/>access token. To get this, log into your GitHub account and go to <strong class="bold">Settings</strong>, then <strong class="bold">Developer settings</strong>, and then <strong class="bold">Personal access tokens</strong>. </p>
			<p>Generate an access token, call it <code>cli-package-access</code>, and give it the following permissions:</p>
			<ul>
				<li><code>repo</code></li>
				<li><code>write:packages</code></li>
				<li><code>read:packages</code></li>
				<li><code>delete:packages</code></li>
				<li><code>workflow</code></li>
			</ul>
			<p>Make a note of the token when it is displayed as you will never be able to view it again. After doing this, I put my token in a file called <code>.githubpackage</code> in my users root folder. Putting it in there will mean that I don't need to enter the password each time I log in. I can do this by using the following command:</p>
			<pre>$ cat ~/.githubpackage | docker login docker.pkg.github.com -u russmckendrick --password-stdin</pre>
			<p>Once logged in, we can build an image. For this example, I used <code>dockerfile-example</code>:</p>
			<pre>$ docker image build --tag docker.pkg.github.com/russmckendrick/mastering-docker-fourth-edition/dockerfile-example:latest .</pre>
			<p>Notice that I am using the repository name <code>mastering-docker-fourth-edition</code> and that it is all in lowercase. If you were to try and use any uppercase characters, Docker will complain. </p>
			<p>Once built and tagged, you can push your image using the following command:</p>
			<pre>$ docker image push docker.pkg.github.com/russmckendrick/
mastering-docker-fourth-edition/dockerfile-example:latest</pre>
			<p>Once <a id="_idIndexMarker223"/>pushed, you should <a id="_idIndexMarker224"/>be able to see that there is now a package in your repository:</p>
			<div><div><img src="img/Figure_3.28_B15659.jpg" alt="Figure 3.28 – Viewing the package that was pushed to GitHub&#13;&#10;" width="1647" height="1040"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.28 – Viewing the package that was pushed to GitHub</p>
			<p>Drilling <a id="_idIndexMarker225"/>down to the package shows the following basic stats and <a id="_idIndexMarker226"/>download information:</p>
			<div><div><img src="img/Figure_3.29_B15659.jpg" alt="Figure 3.29 – Viewing more information about the package&#13;&#10;" width="1650" height="1008"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.29 – Viewing more information about the package</p>
			<p>You can also download the image by running the following command:</p>
			<pre>$ docker image pull docker.pkg.github.com/russmckendrick/
mastering-docker-fourth-edition/dockerfile-example:latest</pre>
			<p>Since our GitHub repository is public, our package will be too, meaning that anyone can download it.</p>
			<p>So, that covers pushing an existing image. However, as we have mentioned a few times already throughout this chapter, this is not really recommended. Luckily, GitHub introduced GitHub Actions, which <a id="_idIndexMarker227"/>allows you to set up automated workflows that action <strong class="bold">things</strong> whenever an event, such as a push to the repository, occurs.</p>
			<p>To create <a id="_idIndexMarker228"/>a GitHub Action, go to your repository and click on the <code>.github/workflows/main.yml</code> in your repository. </p>
			<p>Enter the <a id="_idIndexMarker230"/>following content in the space provided:</p>
			<pre>name: Create Multi Stage Docker Image CI
on: [push]
jobs:
  build_docker_image:
    runs-on: ubuntu-18.04
    steps:
    - uses: actions/checkout@v1
    - name: Build and tag image
      run: docker build -t "docker.pkg.github.com/$(echo $GITHUB_REPOSITORY | tr '[:upper:]' '[:lower:]')/multi-stage:$GITHUB_RUN_NUMBER" -f ./chapter02/multi-stage/Dockerfile ./chapter02/multi-stage/
    - name: Docker login
      run: docker login docker.pkg.github.com -u $GITHUB_ACTOR -p $GITHUB_TOKEN
      env:
        GITHUB_TOKEN: ${{secrets.GITHUB_TOKEN}}
    - name: Publish to GPR
      run: docker push "docker.pkg.github.com/$(echo $GITHUB_REPOSITORY | tr '[:upper:]' '[:lower:]')/multi-stage:$GITHUB_RUN_NUMBER"</pre>
			<p>As you <a id="_idIndexMarker231"/>can see, this closely follows the steps we took to build and tag our image, authenticate against GitHub Packages, and push the image. There are some things that are relevant <a id="_idIndexMarker232"/>to GitHub Actions, such as the <code>$GITHUB_REPOSITORY</code> and <code>$GITHUB_RUN_NUMBER</code> variables, as well as <code>${{secrets.GITHUB_TOKEN}}</code>, all of which make sure that there is nothing from my Action that's hardcoded. This means you can run safely it in your own repository.</p>
			<p>Once <a id="_idIndexMarker233"/>entered, click on the <strong class="bold">Start commit</strong> button, enter some details, and click on <strong class="bold">Commit new file</strong>. Once committed, the workflow will start automatically. You can <a id="_idIndexMarker234"/>view the output by going back to <strong class="bold">Actions</strong> and then selecting the newly created workflow and then job:</p>
			<div><div><img src="img/Figure_3.30_B15659.jpg" alt="Figure 3.30 – Viewing our GitHub Actions build results&#13;&#10;" width="1626" height="837"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.30 – Viewing our GitHub Actions build results</p>
			<p>Once <a id="_idIndexMarker235"/>complete, going to <strong class="bold">Packages</strong> in your repository should show you a package that looks <a id="_idIndexMarker236"/>as follows:</p>
			<div><div><img src="img/Figure_3.31_B15659.jpg" alt="Figure 3.31 – Checking the package created by our GitHub Action&#13;&#10;" width="1635" height="877"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.31 – Checking the package created by our GitHub Action</p>
			<p>As you <a id="_idIndexMarker237"/>can see, while this does pretty much the same as an automated <a id="_idIndexMarker238"/>Docker Hub build, you have a lot more control over what happens and the build process itself.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor129"/>Azure Container Registry</h2>
			<p>Next up on <a id="_idIndexMarker239"/>our third-party container registry walkthrough, we have Microsoft's Azure Container Registry. To create one, log into your Microsoft Azure account. We will <a id="_idIndexMarker240"/>talk about Microsoft Azure in more detail in <a href="B15659_10_Final_JM_ePub.xhtml#_idTextAnchor277"><em class="italic">Chapter 10</em></a>, <em class="italic">Running Docker in Public Clouds</em>. </p>
			<p>Once logged in, type <code>Container registries</code> into the search bar at the top of the screen and select the option from the results. Once the <strong class="bold">Container registries</strong> page loads, click on the <strong class="bold">+ Add</strong> button. You will be presented with a page that looks as follows:</p>
			<div><div><img src="img/Figure_3.32_B15659.jpg" alt="Figure 3.32 – Creating our Azure Container Registry&#13;&#10;" width="1509" height="1161"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.32 – Creating our Azure Container Registry</p>
			<p>If you <a id="_idIndexMarker241"/>are following along, enter the following information:</p>
			<ul>
				<li><strong class="bold">Subscription</strong>: Select the <a id="_idIndexMarker242"/>subscription you would like to use.</li>
				<li><code>masteringdocker-acr-rg</code>.</li>
				<li><code>masteringdocker</code>.</li>
				<li><code>UK South</code>.</li>
				<li><code>Enable</code>.</li>
				<li><code>Basic</code>. This should be enough for testing.</li>
			</ul>
			<p>We are going to ignore the encryption options for now as they are only available when using the premium SKU as well as the tags, so click on <strong class="bold">Review + Create</strong>. Once your deployment has been validated, click on the <strong class="bold">Create</strong> button. After a few minutes, your deployment will be complete.</p>
			<p>As with GitHub Packages, we are going to build and push a container. To do this, we need some credentials. To find these, click on <strong class="bold">Access Keys</strong> and make a note of the details for <strong class="bold">Login server</strong>, <strong class="bold">Username</strong>, and one of the two <strong class="bold">passwords</strong>:</p>
			<div><div><img src="img/Figure_3.33_B15659.jpg" alt="Figure 3.33 – Getting the access key for our Azure Container Registry&#13;&#10;" width="1638" height="1178"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.33 – Getting the access key for our Azure Container Registry</p>
			<p>Like with <a id="_idIndexMarker243"/>GitHub Packages, put the password in a text file. I used <code>~/.azureacrpassword</code>. Then, log in with the Docker command-line client by running the following:</p>
			<pre>$ cat ~/.azureacrpassword | docker login masteringdocker.azurecr.io -u masteringdocker --password-stdin</pre>
			<p>Now that <a id="_idIndexMarker244"/>we are authenticated, change to the <code>dockerfile-example</code> folder, which can be found in the <code>chapter02</code> folder in this book's GitHub repository, and build, tag, and push our image:</p>
			<pre>$ docker image build --tag masteringdocker.azurecr.io/dockerfile-example:latest .
$ docker image push masteringdocker.azurecr.io/dockerfile-example:latest</pre>
			<p>Once pushed, you should be able to see it listed on the Azure Container Registry page by clicking on <strong class="bold">Registries</strong> in the <strong class="bold">Services</strong> section of the main menu. Select the image and version. After doing this, you will see something like the following:</p>
			<div><div><img src="img/Figure_3.34_B15659.jpg" alt="Figure 3.34 – Viewing our container in the Azure Container Registry&#13;&#10;" width="1645" height="900"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.34 – Viewing our container in the Azure Container Registry</p>
			<p>When it comes to pulling images, you will need to make sure that you are authenticated against your Container Registry as it is a private service. Trying to pull and not being logged in will result in an error.</p>
			<p>You can <a id="_idIndexMarker245"/>also automate these builds based on committing your Dockerfile to a GitHub repository. This is, however, a little more involved as it can currently <a id="_idIndexMarker246"/>only be configured using Azure's command-line tools. See the <em class="italic">Further reading</em> section for more information about how to configure Azure Container Registry Tasks.</p>
			<p>Looking at MicroBadger</p>
			<p>Microbadger is a <a id="_idIndexMarker247"/>great tool when you are looking at shipping your containers or moving your <a id="_idIndexMarker248"/>images around. It will take into account everything that is going on in every single layer of a particular Docker image and give you an output regarding how much weight it has in terms of its actual size or the amount of disk space it will take up.</p>
			<p>The following <a id="_idIndexMarker249"/>page is what you will be presented with when navigating to the MicroBadger website, <a href="https://microbadger.com/">https://microbadger.com/</a>:</p>
			<div><div><img src="img/Figure_3.35_B15659.jpg" alt="Figure 3.35 – The Microbadger home page&#13;&#10;" width="1637" height="946"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.35 – The Microbadger home page</p>
			<p>You can search for images that are on Docker Hub to have MicroBadger provide information about that image. Alternatively, you can load up a sample image set if you are looking to provide some sample sets, or to view <a id="_idIndexMarker250"/>some more complex setups.</p>
			<p>In this example, we are going to search for one of my images, <code>russmckendrick/ab</code>, and select the latest tag. By default, it will <a id="_idIndexMarker251"/>always load the latest tag, but you also have the option of changing the tag you are viewing by selecting your desired tag from the <strong class="bold">Versions</strong> drop-down menu. This could be useful if you have, for example, a staging tag and are thinking of pushing this new image to your latest tag, but want to see what impact it will have on the size of the image.</p>
			<p>As shown in the following screenshot, MicroBadger presents information about how many layers your image contains:</p>
			<div><div><img src="img/Figure_3.36_B15659.jpg" alt="Figure 3.36 – Viewing the details of our container in MicroBadger&#13;&#10;" width="1620" height="818"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.36 – Viewing the details of our container in MicroBadger</p>
			<p>By showing <a id="_idIndexMarker252"/>the size of each layer and the Dockerfile command that was executed during the image build, you can see at which stage of the image build the bloat was added, which is <a id="_idIndexMarker253"/>extremely useful when it comes to reducing the size of your images.</p>
			<p>Another great feature of MicroBadger is that it gives you the option to embed basic statistics about your images in your GitHub repository or Docker Hub. For example, the following screenshot shows the Docker Hub page for <code>russmckendrick/ab</code>:</p>
			<div><div><img src="img/Figure_3.37_B15659.jpg" alt="Figure 3.37 – Adding MicroBadger stats to an image's README file&#13;&#10;" width="1448" height="831"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.37 – Adding MicroBadger stats to an image's README file</p>
			<p>As you <a id="_idIndexMarker254"/>can see, MicroBadger is displaying the overall size of the image, which in this example is <code>5.1MB</code>, as well as the total number of layers the image is made up of, which is <code>7</code>. The MicroBadger service <a id="_idIndexMarker255"/>is still in its beta stage and new functions are being added all the time. I recommend that you keep an eye on it.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor130"/>Summary</h1>
			<p>In this chapter, we looked at several ways in which we can both manually and automatically build container images using Docker Hub. We discussed the various registries we can use besides Docker Hub, such as GitHub Packages and Microsoft's Azure Container Registry.</p>
			<p>We also looked at deploying our own local Docker Registry and touched upon the considerations we need to make around storage when deploying one. Finally, we looked at MicroBadger, a service that allows us to display information about our remotely hosted container images.</p>
			<p>All of this means you now have a way of distributing your own container images, both securely and in a way that allows you to easily keep your container images up to date.</p>
			<p>This is important as it means that, if you wish, it is possible to trigger an update of all your images with a single build, rather than having to manually build and push each individual image.</p>
			<p>In the next chapter, we are going to look at how to manage our containers from the command line.</p>
			<h1 id="_idParaDest-75"><a id="_idTextAnchor131"/>Questions</h1>
			<ol>
				<li value="1">True or false: Docker Hub is the only source from which you can download official Docker images.</li>
				<li>Describe why you would want to link an automated build to an official Docker Hub image.</li>
				<li>Are multi-stage builds supported on Docker Hub?</li>
				<li>True or false: Logging into Docker on the command line also logs you into the desktop application.</li>
				<li>How would you delete two images that share the same <code>IMAGE ID</code>?</li>
				<li>Which port does Docker Registry run on by default?</li>
			</ol>
			<h1 id="_idParaDest-76"><a id="_idTextAnchor132"/>Further reading</h1>
			<p>More information on Docker Store, Trusted Registry, and Registry can be found at the following links:</p>
			<ul>
				<li>Docker Hub Publisher Signup: <a href="https://store.docker.com/publisher/signup/">https://store.docker.com/publisher/signup/</a></li>
				<li>Docker Registry Documentation: <a href="https://docs.docker.com/registry/">https://docs.docker.com/registry/</a></li>
				<li><strong class="bold">Docker Trusted Registry</strong> (<strong class="bold">DTR</strong>): <a href="https://www.mirantis.com/software/docker/image-registry/">https://www.mirantis.com/software/docker/image-registry/</a></li>
			</ul>
			<p>You can find more details about the different types of cloud-based storage you can use for Docker Registry at the following links:</p>
			<ul>
				<li>Azure Blob Storage: <a href="https://azure.microsoft.com/en-gb/services/storage/blobs/">https://azure.microsoft.com/en-gb/services/storage/blobs/</a></li>
				<li>Google Cloud storage: <a href="https://cloud.google.com/storage/">https://cloud.google.com/storage/</a></li>
				<li><strong class="bold">Amazon Simple Storage Service</strong> (<strong class="bold">Amazon S3</strong>): <a href="https://aws.amazon.com/s3/">https://aws.amazon.com/s3/</a></li>
				<li>Swift: <a href="https://wiki.openstack.org/wiki/Swift">https://wiki.openstack.org/wiki/Swift</a></li>
			</ul>
			<p>Some of the third-party registry services can be found here:</p>
			<ul>
				<li>GitHub Actions: <a href="https://github.com/features/actions">https://github.com/features/actions</a></li>
				<li>Azure Container Registry: <a href="https://azure.microsoft.com/en-gb/services/container-registry/">https://azure.microsoft.com/en-gb/services/container-registry/</a></li>
				<li>Azure Container Registry Tasks: <a href="https://docs.microsoft.com/en-gb/azure/container-registry/container-registry-tutorial-quick-task">https://docs.microsoft.com/en-gb/azure/container-registry/container-registry-tutorial-quick-task</a></li>
				<li>Amazon Elastic Container Registry: <a href="https://aws.amazon.com/ecr/">https://aws.amazon.com/ecr/</a></li>
				<li>Google Cloud Container Registry: <a href="https://cloud.google.com/container-registry">https://cloud.google.com/container-registry</a></li>
				<li>Red Hat Container Catalog: <a href="https://catalog.redhat.com/software/containers/explore">https://catalog.redhat.com/software/containers/explore</a></li>
				<li>OpenShift: <a href="https://www.openshift.com/">https://www.openshift.com/</a></li>
				<li>Quay by Red Hat: <a href="https://quay.io/">https://quay.io/</a></li>
				<li>Artifactory by JFrog: <a href="https://www.jfrog.com/artifactory/">https://www.jfrog.com/artifactory/</a> </li>
			</ul>
			<p>Finally, you can find links to Docker Hub and Microbadger for my Apache Bench image here:</p>
			<ul>
				<li>Apache Bench Image (Docker Hub): <a href="https://hub.docker.com/r/russmckendrick/ab/">https://hub.docker.com/r/russmckendrick/ab/</a></li>
				<li>Apache Bench Image (Microbadger): <a href="https://microbadger.com/images/russmckendrick/ab">https://microbadger.com/images/russmckendrick/ab</a></li>
			</ul>
		</div>
	</div>



  </body></html>