<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-27"><a id="_idTextAnchor028" class="pcalibre1 pcalibre calibre6"/>2</h1>
<h1 id="_idParaDest-28" class="calibre5"><a id="_idTextAnchor029" class="pcalibre1 pcalibre calibre6"/>Developing with Git</h1>
<p class="calibre3">This chapter will describe how to create new revisions and new lines of development (new branches) with Git.</p>
<p class="calibre3">Here, we will focus on committing one’s own work on the solo development. The description of working as one of the contributors is left for <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>, while <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>, will show how to join created lines of development and how Git can help in maintainer duties.</p>
<p class="calibre3">This chapter will introduce the very important Git <a id="_idIndexMarker050" class="pcalibre1 pcalibre calibre6"/>concept of the <strong class="bold">staging area</strong> (also called the index), while more advanced techniques for manipulating it will be described in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>. It will also explain, in detail, the idea of a <strong class="bold">detached HEAD</strong> — that is, an <a id="_idIndexMarker051" class="pcalibre1 pcalibre calibre6"/>anonymous, unnamed branch. Here, you can also find how Git describes differences between two versions of the project, or changes to the project, including a detailed description <a id="_idIndexMarker052" class="pcalibre1 pcalibre calibre6"/>of the so-called extended <strong class="bold">unified </strong><strong class="bold">diff format</strong>.</p>
<p class="calibre3">The following is the list of the topics we will cover in this chapter:</p>
<ul class="calibre16">
<li class="calibre15">The index — a staging area for commits</li>
<li class="calibre15">Examining the status of the working area, and changes in it</li>
<li class="calibre15">How to read the extended unified diff that is used to describe changes</li>
<li class="calibre15">Selective and interactive commit, and amending a commit</li>
<li class="calibre15">Creating, listing, renaming, and switching to branches, and listing tags</li>
<li class="calibre15">What can prevent switching branches, and what you can do then</li>
<li class="calibre15">Rewinding a branch with <strong class="source-inline1">git reset</strong></li>
<li class="calibre15">Detached <strong class="source-inline1">HEAD</strong> — that is, the unnamed branch (for example, a result of checking out a tag)</li>
</ul>
<h1 id="_idParaDest-29" class="calibre5"><a id="_idTextAnchor030" class="pcalibre1 pcalibre calibre6"/>Creating a new commit</h1>
<p class="calibre3">Before starting to develop with Git, you should introduce yourself with a name and an email, as shown in <a href="B21194_01.xhtml#_idTextAnchor015" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 1</em></a>, <em class="italic">Git Basics in Practice</em>. This information will be used to identify your work, either as an author or as a committer. The setup can be global for all your repositories (with <code>git config --global</code>, or by editing the <code>~/.gitconfig</code> file directly), or local to a repository (with <code>git config</code>, or by editing the <code>.git/config</code> file inside the <a id="_idIndexMarker053" class="pcalibre1 pcalibre calibre6"/>given repository). The per-repository configuration overrides the per-user one (you will learn more about this in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and </em><em class="italic">Extending Git</em>).</p>
<p class="callout-heading">Multiple identities</p>
<p class="callout">You might want to use your company email for <em class="italic">work</em> repositories, but your own, non-work email for public repositories you work on. This can be done by setting one identity globally (for the user) and using the local repository config for setting an alternate identity for exceptions. Another possible solution<a id="_idIndexMarker054" class="pcalibre1 pcalibre calibre6"/> would be to use <strong class="bold">conditional includes</strong> with the <strong class="source-inline1">includeIf</strong> section, using it to include appropriate configuration files with per-directory identities.</p>
<p class="calibre3">The relevant fragment of the appropriate config file could look like the following example:</p>
<pre class="source-code">
[user]
    name = Joe R. Hacker
    email = joe@company.com</pre>
<h2 id="_idParaDest-30" class="calibre7"><a id="_idTextAnchor031" class="pcalibre1 pcalibre calibre6"/>How a new commit extends a project’s history</h2>
<p class="calibre3">Contributing to the development of a project usually consists of creating new revisions of said project. To mark the current state of the project as a new version, you use the <code>git commit</code> command. Git will then <a id="_idIndexMarker055" class="pcalibre1 pcalibre calibre6"/>ask for a description of changes (<strong class="bold">commit message</strong>), and then extend the project history with the newly created<a id="_idIndexMarker056" class="pcalibre1 pcalibre calibre6"/> revision. Here’s what is happening behind the curtain — it’s useful to understand this to better use advanced Git techniques.</p>
<p class="calibre3">In Git, the history of the project is stored as a graph of revisions (versions), where each revision points to the previous version it was based on. The <code>git commit</code> command simply creates a new node in this graph (a <strong class="bold">commit</strong> node), extending it.</p>
<p class="calibre3">To know where each branch is, Git uses <strong class="bold">branch HEAD</strong> as a reference to the graph of revisions. The <strong class="bold">HEAD</strong> denotes which branch is the current branch — that is, on which branch to create new commits at a given point in time.</p>
<p class="calibre3">You can find out more <a id="_idIndexMarker057" class="pcalibre1 pcalibre calibre6"/>about the concept of the <strong class="bold">Directed Acyclic Graph</strong> (<strong class="bold">DAG</strong>) of revisions in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>. Creating a new commit adds a new node to the graph of revisions, and adjusts the position of branch tips (heads), as shown on the following figure.</p>
<div><div><img alt="Figure 2.1 – The graph of revisions for an example project, before and after creating a new commit on the “master” branch" src="img/B21194_02_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.1 – The graph of revisions for an example project, before and after creating a new commit on the “master” branch</p>
<p class="calibre3">Let’s assume that we are on the <code>master</code> branch and that we want to create a new version (the details of this operation will be described in more detail later). The <code>git commit</code> command will create <a id="_idIndexMarker058" class="pcalibre1 pcalibre calibre6"/>a new commit object — a new revision node. This commit will have the checked-out revision (<strong class="bold">c7cd3</strong> in the example in <em class="italic">Figure 2</em><em class="italic">.1</em>) as the<a id="_idIndexMarker059" class="pcalibre1 pcalibre calibre6"/> previous node (as a <strong class="bold">parent</strong>).</p>
<p class="calibre3">That revision is found by following references starting from <code>HEAD</code>; here, it is a chain starting at <code>HEAD</code>, then following to <code>master</code>, and finally arriving at <code>c7cd3</code>.</p>
<p class="calibre3">Then, Git will create a new commit node, <code>a3b79</code>, and then move the <code>master</code> pointer to that new node. In <em class="italic">Figure 2</em><em class="italic">.1</em>, the new commit is marked with a thick red outline. Note that the <code>HEAD</code> pointer doesn’t change; all the time, it points to <code>master</code>. The performed commit <a id="_idIndexMarker060" class="pcalibre1 pcalibre calibre6"/>operation is logged in the <code>master</code> branch and for <code>HEAD</code> (current branch); one can examine this log with the <code>git reflog master</code> or <code>git reflog </code><code>HEAD<a id="_idTextAnchor032" class="pcalibre1 pcalibre calibre6"/></code> command.</p>
<h2 id="_idParaDest-31" class="calibre7"><a id="_idTextAnchor033" class="pcalibre1 pcalibre calibre6"/>The index — a staging area for commits</h2>
<p class="calibre3">Each of the files inside the working area of the Git repository can at a given point in time be either known or unknown to Git — that is, version-controlled or not. Any file known to Git is also<a id="_idIndexMarker061" class="pcalibre1 pcalibre calibre6"/> known as a <code>git </code><code>add</code> command.</p>
<p class="calibre3">  Files tracked by Git are usually in either of the two states: committed (or unchanged) or modified. The <code>HEAD</code>), which is safely stored in the repository. The file is <code>HEAD</code>.</p>
<p class="calibre3">However, in Git, there are other states possible. Let’s consider what happens when we use the <code>git add</code> command to add a file that was previously unknown to Git (an untracked file), but before creating a new commit that adds this file. A version control system needs to store somewhere the information that the given file is to be included in the next commit. Git uses something called the <code>git add &lt;file&gt;</code> command <strong class="bold">stages</strong> the current contents (current version) of the file, adding it to the index.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you want to only <em class="italic">mark a file for the addition</em>, you can use <strong class="source-inline1">git add -N &lt;file&gt;</strong> or <strong class="source-inline1">git add --intent-to-add &lt;file&gt;</strong>; these commands simply stage the empty contents for a file (<strong class="source-inline1">&lt;file&gt;</strong> here is a placeholder for the file’s name).</p>
<p class="calibre3">The staging area stores the state of the project. It is the third such section, after a working directory (which contains your own copy of the project files and is used as a private isolated workspace to make changes) and a local repository (which stores your own copy of the project history and is used to synchronize changes with other developers). <em class="italic">Figure 2</em><em class="italic">.2</em> shows how you can interact with these three sections, specifically in the context of <a id="_idIndexMarker063" class="pcalibre1 pcalibre calibre6"/>creating a new commit:</p>
<div><div><img alt="Figure 2.2 – The working directory, the staging area, and the local git repository, creating a new commit" src="img/B21194_02_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.2 – The working directory, the staging area, and the local git repository, creating a new commit</p>
<p class="calibre3">The arrows on this diagram show how the Git commands copy contents. For example, <code>git add</code> takes the content of the file from the working directory and puts it into the staging area. Creating a new commit requires, explicitly or implicitly, the following steps:</p>
<ol class="calibre14">
<li class="calibre15">You make changes to files in your working directory, usually modifying them using your favorite editor.</li>
<li class="calibre15">You stage the files, adding snapshots of them (their current contents) to your staging area, usually with the <strong class="source-inline1">git </strong><strong class="source-inline1">add</strong> command.</li>
<li class="calibre15">You create a new revision with the <strong class="source-inline1">git commit</strong> command, which takes the files as they are in the staging area and stores that snapshot permanently in your <strong class="bold">local repository</strong>.</li>
</ol>
<p class="calibre3">In the beginning, and usually just after the commit (unless it was a selective commit), the tracked files are identical in the working directory, in the staging area, and in the last commit (in the committed<a id="_idIndexMarker064" class="pcalibre1 pcalibre calibre6"/> version, that is <code>HEAD</code>).</p>
<p class="callout-heading">Examining the staged file contents and the committed file contents</p>
<p class="callout">To examine the working directory state of a file, you can simply open it in an editor, or (on Linux or in Git Bash) simply use <strong class="source-inline1">cat &lt;filename&gt;</strong>; examining other stages is more involved. To see the state in the <a id="_idIndexMarker065" class="pcalibre1 pcalibre calibre6"/>staging area, you can use the <strong class="source-inline1">git show :&lt;filename&gt;</strong> command. To see<a id="_idIndexMarker066" class="pcalibre1 pcalibre calibre6"/> the committed version, use the <strong class="source-inline1">git show &lt;revision&gt;:&lt;filename&gt;</strong> command (where <strong class="source-inline1">&lt;revision&gt;</strong> may be <strong class="source-inline1">HEAD</strong>). Here, a filename starting with <strong class="source-inline1">./</strong> or <strong class="source-inline1">../</strong> denotes that the path is relative to the current directory; otherwise, it is taken to be relative to the top-level directory of the repository you are in.</p>
<p class="calibre3">Often, however, one would use a special shortcut, the <code>git commits -a</code> command (spelled as <code>git commit --all</code> in the long form), which would take <em class="italic">all the changed tracked files</em>, add them to the staging area, and create a new commit (see <em class="italic">Figure 2</em><em class="italic">.2</em>). This command gives the same result as running <code>git add --update</code>, followed by a <code>git commit</code> command. Note that the new files still need to be explicitly added using <code>git add</code> to be tracked and included in new commits.</p>
<h2 id="_idParaDest-32" class="calibre7"><a id="_idTextAnchor034" class="pcalibre1 pcalibre calibre6"/>Examining the changes to be committed</h2>
<p class="calibre3">Before committing to the <a id="_idIndexMarker067" class="pcalibre1 pcalibre calibre6"/>changes and creating a new revision (a new commit), you would want to see what you have done.</p>
<p class="calibre3">Git adds the information about the changes to be committed to the commit message template, which is then passed to the editor, and you will see this when writing the commit message. This is, of course, unless you specify the commit message on the command line — for example, with <code>git commit -m "Short description"</code>. The commit message template in Git is configurable (refer to <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and Extending Git,</em> for more information).</p>
<p class="callout-heading">Important note</p>
<p class="callout">You can always abort creating a commit by exiting the editor without any changes, or with an empty commit message (comment lines — that is, lines beginning with <strong class="source-inline1">#</strong> — do not count). If you want to create a commit with an empty commit message, you need to use the <strong class="source-inline1">--</strong><strong class="source-inline1">allow-empty-message</strong> option.</p>
<p class="calibre3">In most cases, you would want to examine pending changes for correctness before creating a commit.</p>
<h3 class="calibre9">The status of the working directory</h3>
<p class="calibre3">The main tool you use to <a id="_idIndexMarker068" class="pcalibre1 pcalibre calibre6"/>examine which files are in which state — that is, which files have changed, whether there are any new files, and so on — is the <code>git </code><code>status</code> command.</p>
<p class="calibre3">The default output is explanatory and quite verbose. If there are no changes, for example, directly after cloning, you could see something like this:</p>
<pre class="console">
$ git status
On branch master
nothing to commit, working tree clean</pre>
<p class="calibre3">If the current branch (which, in this example, is the <code>master</code> branch) is a local branch intended to create changes that are to be published and to appear in the public repository, and is configured to track its upstream branch, <code>origin/master</code>, you would also see the information about the tracked branch:</p>
<pre class="console">
Your branch is up to date with 'origin/master'.</pre>
<p class="calibre3">In further examples in this chapter, we will ignore it and not include the information about branches and tracking branches.</p>
<p class="calibre3">Let’s say you have added two new files to your project: a <code>COPYING</code> file with the copyright and license, and a <code>NEWS</code> file, which is currently empty. In order to begin tracking a new <code>COPYING</code> file, you used <code>git add COPYING</code>. Accidentally, you removed the <code>README</code> file from<a id="_idIndexMarker069" class="pcalibre1 pcalibre calibre6"/> the working directory with <code>rm README</code>. You also modified the <code>Makefile</code> and renamed <code>rand.c</code> to <code>random.c</code> with <code>git mv</code> without modifying the file.</p>
<p class="calibre3">The default long format is designed to be human-readable, verbose, and descriptive:</p>
<pre class="console">
$ git status
On branch master
Changes to be committed:
  (use "git restore --staged &lt;file&gt;..." to unstage)
        new file:   COPYING
        renamed:    src/rand.c -&gt; src/random.c
Changes not staged for commit:
  (use "git add &lt;file&gt;..." to update what will be committed)
  (use "git restore &lt;file&gt;..." to discard changes in working directory)
        modified:   Makefile
        deleted:    README
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
        NEWS</pre>
<p class="calibre3">Older versions of Git will suggest using different commands than <code>git restore</code>.</p>
<p class="calibre3">As you can see, Git not only describes which files have changed but also explains how to change their status — either include it in the commit or remove it from the set of pending changes (more<a id="_idIndexMarker070" class="pcalibre1 pcalibre calibre6"/> information about commands shown in the <code>git status</code> output can be found in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>). There are up to three sections present in the output:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Changes to be committed</strong>: This section is about the staged changes that would be committed with <strong class="source-inline1">git commit</strong> (without the <strong class="source-inline1">-a</strong>/<strong class="source-inline1">--all</strong> option). It lists files whose snapshot in the staging area is different from the version from the last commit (<strong class="source-inline1">HEAD</strong>).</li>
<li class="calibre15"><strong class="bold">Changes not staged for commit</strong>: This section lists the files whose working directory contents are different from their snapshots in the staging area. Those changes would not be committed with <strong class="source-inline1">git commit</strong>, but would be committed with <strong class="source-inline1">git commit -a</strong> as changes in the tracked files.</li>
<li class="calibre15"><strong class="bold">Untracked files</strong>: This lists the files, unknown to Git, that are not ignored (refer to <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em> for how to use <strong class="bold">gitignores</strong> to make files be ignored). These files would be added with the bulk add command, <strong class="source-inline1">git add .</strong>, if run in the top directory of the project. You can skip this section with the <strong class="source-inline1">--untracked-files=no</strong> (<strong class="source-inline1">-uno</strong> for short) option.</li>
</ul>
<p class="calibre3">If the section does not contain any files, it will be not shown. Note also that the file may appear in more than one section. For example, a new file that got added with <code>git add</code> and then modified would appear in both <strong class="bold">Changes to be committed</strong> and <strong class="bold">Changes not staged </strong><strong class="bold">for commit</strong>.</p>
<p class="calibre3">One does not need to make use of the flexibility that the explicit staging area gives; one can simply use <code>git add</code> just to add new files and <code>git commit –a</code> to create the commit from changes to all tracked files. In this case, you would create a commit from both the <strong class="bold">Changes to be committed</strong> and <strong class="bold">Changes not staged for </strong><strong class="bold">commit</strong> sections.</p>
<p class="calibre3">There is also a terse <code>--short</code> output format for <code>git status</code>. Its <code>--porcelain</code> version is suitable for scripting<a id="_idIndexMarker071" class="pcalibre1 pcalibre calibre6"/> because it is promised to remain stable, while <code>--short</code> is intended for user output, uses color if possible, and could change in the future. For the same set of changes, this output format would look something like the following:</p>
<pre class="console">
$ git status --short
A  COPYING
 M Makefile
 D README
R  src/rand.c -&gt; src/random.c
?? NEWS</pre>
<p class="calibre3">In this format, the status of each path is shown using a <em class="italic">two-letter status code</em>. The first letter shows the status of the index (the difference between the staging area and the last commit), and the second letter shows the status of the worktree (the difference between the working area and the staging area):</p>
<table class="no-table-style" id="table001-1">
<colgroup class="calibre10">
<col class="calibre11"/>
<col class="calibre11"/>
</colgroup>
<thead class="calibre17">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Symbol</strong></p>
</td>
<td class="no-table-style2">
<p class="calibre3"><strong class="bold">Meaning</strong></p>
</td>
</tr>
</thead>
<tbody class="calibre12">
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">(a space)</p>
</td>
<td class="no-table-style2">
<p class="calibre3">Not updated/unchanged</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">M</p>
</td>
<td class="no-table-style2">
<p class="calibre3"><em class="italic">M</em>odified (updated)</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">A</p>
</td>
<td class="no-table-style2">
<p class="calibre3"><em class="italic">A</em>dded</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">D</p>
</td>
<td class="no-table-style2">
<p class="calibre3"><em class="italic">D</em>eleted</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">R</p>
</td>
<td class="no-table-style2">
<p class="calibre3"><em class="italic">R</em>enamed</p>
</td>
</tr>
<tr class="no-table-style1">
<td class="no-table-style2">
<p class="calibre3">C</p>
</td>
<td class="no-table-style2">
<p class="calibre3"><em class="italic">C</em>opied</p>
</td>
</tr>
</tbody>
</table>
<p class="img---caption" lang="en-US" xml:lang="en-US">Table 2.1 – Letter status codes used in the short format of the git-status command</p>
<p class="calibre3">Not all combinations are possible. Status letters <em class="italic">A</em>, <em class="italic">R</em>, and <em class="italic">C</em> are possible only in the first column, for the status of the index.</p>
<p class="calibre3">A special case, <code>??</code>, is used<a id="_idIndexMarker072" class="pcalibre1 pcalibre calibre6"/> for the unknown (untracked) files, and <code>!!</code> for ignored files (when using <code>git status --</code><code>short --ignored</code>).</p>
<p class="callout-heading">Note about status codes</p>
<p class="callout">All the possible outputs are described here; the case where we have just done a merge that resulted in merge conflicts is not shown in <em class="italic">Table 2.1</em> but is left to be described in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging </em><em class="italic">Changes Together</em>.</p>
<h3 class="calibre9">Examining differences from the last revision</h3>
<p class="calibre3">If you want to know not only<a id="_idIndexMarker073" class="pcalibre1 pcalibre calibre6"/> which files were changed (which you get with <code>git status</code>), but also what exactly you have changed, you can use the <code>git </code><code>diff</code> command:</p>
<div><div><img alt="Figure 2.3 – Examining the differences between the working directory, the staging area, and the local Git repository" src="img/B21194_02_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Examining the differences between the working directory, the staging area, and the local Git repository</p>
<p class="calibre3">In the last section, we learned that in Git, there are three stages: the working directory, the staging area, and the<a id="_idIndexMarker074" class="pcalibre1 pcalibre calibre6"/> repository (usually the last commit). Therefore, we have not one set of differences, but three, as shown in <em class="italic">Figure 2</em><em class="italic">.3</em>. You can ask Git the following questions:</p>
<ul class="calibre16">
<li class="calibre15">What have you changed but not yet staged — that is, what are the differences between the staging area and the working directory?</li>
<li class="calibre15">What have you staged that you are about to commit — that is, what are the differences between the last commit (<strong class="source-inline1">HEAD</strong>) and the staging area?</li>
<li class="calibre15">What changes have you made to the files in the working directory since the last commit (<strong class="source-inline1">HEAD</strong>)?</li>
</ul>
<p class="calibre3">To see what you’ve changed but not yet staged, type <code>git diff</code> with no other arguments. This command compares what is in your working directory to what is in your staging area. These are the changes that could be added but wouldn’t be present if we created a commit with <code>git commit</code> (without <code>-a</code>); those changes are listed in the <code>git </code><code>status</code> output.</p>
<p class="calibre3">To see what you’ve staged that will go into your next commit, use <code>git diff --staged</code> (or <code>git diff --cached</code>). This command compares what is in your staging area to the content of your last commit. These are the changes that <em class="italic">would</em> be added with <code>git commit</code> (without <code>-a</code>) — <code>git status</code> output. You can compare your staging area to any commit with <code>git diff --staged &lt;commit&gt;</code>; <code>HEAD</code> (the last commit) is just the default.</p>
<p class="calibre3">You can use <code>git diff HEAD</code> to compare what is in your working directory to the last commit (or arbitrary commit with <code>git diff &lt;commit&gt;</code>). These are the changes that would be added with the <code>git commit -</code><code>a</code> shortcut.</p>
<p class="calibre3">If you are using <code>git commit –a</code> and not making use of the staging area, usually, it is enough to use <code>git diff</code> to examine<a id="_idIndexMarker075" class="pcalibre1 pcalibre calibre6"/> the changes that will land in the next commit. The only issue is the new files that are added with bare <code>git add</code>; they won’t show in the <code>git diff</code> output unless you use <code>git add --intent-to-add</code> (or its equivalent <code>git add -N</code>) to add new files.</p>
<h3 class="calibre9">Unified Git diff format</h3>
<p class="calibre3">Git, by default, and in most cases, will show the changes in the <code>git bisect</code> has found the suspected commit.</p>
<p class="callout-heading">Different ways of examining differences</p>
<p class="callout">You can request only <em class="italic">statistics of changes</em> with the <strong class="source-inline1">--stat</strong> or <strong class="source-inline1">--dirstat</strong> option, just <em class="italic">names of the changed files</em> with <strong class="source-inline1">--name-only</strong>, filenames with the type of changes with <strong class="source-inline1">--name-status</strong>, a tree-level view of changes with <strong class="source-inline1">--raw</strong>, or a <em class="italic">condensed summary</em> of extended header information with <strong class="source-inline1">--summary</strong> (see later for an explanation of what “extended header” means and what information it contains). You can also request <strong class="bold">word diff</strong> rather than line diff with <strong class="source-inline1">--word-diff</strong>, though this changes only the description of changes; headers and hunk headers remain similar.</p>
<p class="callout">Diff generation can also be configured for specific files or types of files with appropriate <strong class="bold">gitattributes</strong>. You can specify an external <em class="italic">diff helper</em>  — that is, the command that describes the changes — or you can specify a <em class="italic">text conversion</em> filter for binary files (you will learn more about this in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing </em><em class="italic">Your </em><em class="italic">Worktrees</em>).</p>
<p class="callout">If you prefer to examine the changes in a graphical tool (which usually provides <em class="italic">side-by-side diff</em>), you can do it by using <strong class="source-inline1">git difftool</strong> instead of <strong class="source-inline1">git diff</strong>. You can specify the tool with the <strong class="source-inline1">--tool=&lt;tool&gt;</strong> option or with the <strong class="source-inline1">diff.tool</strong> configuration variable. If the tool you use is not supported by Git or is not in <strong class="source-inline1">PATH</strong>, this may require some configuration. Using external tools with Git like this will be explained in more detail in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and </em><em class="italic">Extending Git.</em></p>
<p class="calibre3">Let’s look at an example of<a id="_idIndexMarker077" class="pcalibre1 pcalibre calibre6"/> an advanced diff from Git project history, using the diff from the <code>1088261f</code> commit from the <code>git.git</code> repository. You can view these changes in a web browser — for example, on GitHub; this is the third patch in this commit, <a href="https://github.com/git/git/commit/1088261f6fc90324014b5306cca4171987da85" class="pcalibre1 pcalibre calibre6">https://github.com/git/git/commit/1088261f6fc90324014b5306cca4171987da85</a>:</p>
<pre class="source-code">
diff --git a/builtin-http-fetch.c b/http-fetch.c
similarity index 95%
rename from builtin-http-fetch.c
rename to http-fetch.c
index f3e63d7206..e8f44babd9 100644
--- a/builtin-http-fetch.c
+++ b/http-fetch.c
@@ -1,8 +1,9 @@
 #include "cache.h"
 #include "walker.h"
-int cmd_http_fetch(int argc, const char **argv, const char *prefix)
+int main(int argc, const char **argv)
 {
+       const char *prefix;
        struct walker *walker;
        int commits_on_stdin = 0;
        int commits;
@@ -18,6 +19,8 @@ int cmd_http_fetch(int argc, const char **argv,
        int get_verbosely = 0;
        int get_recover = 0;
+       prefix = setup_git_directory();
+
        git_config(git_default_config, NULL);
        while (arg &lt; argc &amp;&amp; argv[arg][0] == '-') {</pre>
<p class="calibre3">Let’s analyze this patch line by line. The first line, <code>diff --git a/builtin-http-fetch.c b/http-fetch.c</code>, is a <code>diff --git a/file1 b/file2</code>. The <code>a/</code> and <code>b/</code> filenames are the same unless rename or copy operation is involved (such as in our case), even if the file is added or deleted.  The <code>--git</code> option means that the diff is in the git diff output format.</p>
<p class="calibre3">The next lines are one or more <code>builtin-http-fetch.c</code> to <code>http-fetch.c</code> and that these <a id="_idIndexMarker078" class="pcalibre1 pcalibre calibre6"/>two files are 95% identical (information that was used to detect this rename):</p>
<pre class="source-code">
similarity index 95%
rename from builtin-http-fetch.c
rename to http-fetch.c</pre>
<p class="callout-heading">Important note</p>
<p class="callout">Extended header lines describe information that cannot be represented in an ordinary unified diff, except for information that the file was renamed. Besides a similarity or dissimilarity score, like in this example, those lines can also describe the changes in file type (such as from a non-executable to an executable file).</p>
<p class="calibre3">The last line in the extended diff header, in this example, is as follows:</p>
<pre class="source-code">
index f3e63d7206..e8f44babd9 100644</pre>
<p class="calibre3">The preceding code tells us about the mode (permissions) of a given file. Here, <code>100644</code> means that it is an ordinary file and not a symbolic link, and that it hasn’t set the executable permission bit (these three are the only file permissions tracked by Git). This line also tells us about the shortened hash of the <code>f3e63d7206</code> here) and <code>e8f44babd9</code> here). This line is used by <code>git am --3way</code> to try to do a three-way merge if the patch cannot be applied itself. For the new files, the pre-image hash is <code>0000000000</code>; it’s the same for the deleted files with the post-image hash.</p>
<p class="calibre3">Next is the <strong class="bold">unified diff header</strong>, which consists of two lines:</p>
<pre class="source-code">
--- a/builtin-http-fetch.c
+++ b/http-fetch.c</pre>
<p class="calibre3">Compared to the <code>diff -U</code> result, it doesn’t have a from-file modification time or a to-file modification time. Those should be present after the space just after the source (pre-image) and the destination <a id="_idIndexMarker079" class="pcalibre1 pcalibre calibre6"/>or the target (post-image) filenames. If the file was created, the source would be <code>/dev/null</code>; if the file was deleted, the target would be <code>/dev/null</code>.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you set the <strong class="source-inline1">diff.mnemonicPrefix</strong> configuration variable to <strong class="source-inline1">true</strong> in place of the <strong class="source-inline1">a/</strong> prefix for the pre-image and <strong class="source-inline1">b/</strong> for the post-image in this two-line header, you would instead have the <strong class="source-inline1">c/</strong> prefix for commit, <strong class="source-inline1">i/</strong> for index, <strong class="source-inline1">w/</strong> for worktree, and <strong class="source-inline1">o/</strong> for object, respectively, to show what you’re comparing This makes it easy to distinguish sides in <strong class="source-inline1">git diff</strong>, <strong class="source-inline1">git diff --cached</strong>, <strong class="source-inline1">git diff HEAD</strong> output, and so on.</p>
<p class="calibre3">Next comes one or more <strong class="bold">change hunks</strong>, or hunks<a id="_idIndexMarker080" class="pcalibre1 pcalibre calibre6"/> of differences; each hunk shows one area where the files differ. Unified format hunks start with the line describing where the changes <a id="_idIndexMarker081" class="pcalibre1 pcalibre calibre6"/>were in the file, called the <strong class="bold">hunk header</strong>, as follows:</p>
<pre class="source-code">
@@ -1,8 +1,9 @@</pre>
<p class="calibre3">This line matches the following format pattern: <code>@@ from-file-range to-file-range @@</code>. The from-file range is in the form <code>-&lt;start line&gt;,&lt;number of lines</code>&gt;, and the <em class="italic">to-file range</em> is <code>+&lt;start line&gt;,&lt;number of lines&gt;</code>. Both <code>start line</code> and <code>number of lines</code> refer to the position and length of the hunk in the pre-image and post-image, respectively. If <code>number of lines</code> is not shown, it means that it is <code>0</code>.</p>
<p class="calibre3">In this example, we can see that the changes begin at the first line of the file, both in the pre-image (file before the changes) and post-image (file after the changes). We also see that the fragment of code corresponding to this hunk of diff has eight lines in the pre-image and nine lines in the post-image. This difference in the number of lines means that one line is added. By<a id="_idIndexMarker082" class="pcalibre1 pcalibre calibre6"/> default, Git will also show three unchanged lines surrounding changes (three<a id="_idIndexMarker083" class="pcalibre1 pcalibre calibre6"/> so-called <strong class="bold">context lines</strong>).</p>
<p class="calibre3">Git will also show the “<em class="italic">function name</em>” where each change occurs (or equivalent, if any, for other types of files; this can be configured with <code>.gitattributes</code> via diff driver —see <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>, in the <em class="italic">Configuring diff output</em> section in <em class="italic">File attributes</em>); it is like the <code>-p</code> option in GNU diff:</p>
<pre class="source-code">
@@ -18,6 +19,8 @@ int cmd_http_fetch(int argc, const char</pre>
<p class="calibre3">Git includes many builds in patterns for extracting the “<em class="italic">function</em>” heading for the hunk for various programming languages.</p>
<p class="calibre3">Next is the description of where and how files differ. The lines common to both files are prefixed with a space “<code>(" ")</code>” indicator character. The lines that differ between the two files have one of the following indicator characters in the left print column:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">+</strong>: A line was added here to the second file</li>
<li class="calibre15"><strong class="bold">-</strong>: A line was removed here from the first file</li>
</ul>
<p class="callout-heading">Note</p>
<p class="callout">In the <strong class="bold">plain word-diff</strong> format, instead of comparing file contents line by line, added words are surrounded by <strong class="source-inline1">{+</strong> and <strong class="source-inline1">+}</strong> and removed words by <strong class="source-inline1">[-</strong> and <strong class="source-inline1">-]</strong>, as in the following example:</p>
<pre class="source-code">
int <strong class="bold1">[-cmd_http_fetch-]{+main+}</strong>(int argc, const char **argv<strong class="bold1">[-, const char *prefix-]</strong>)</pre>
<p class="calibre3">If the last hunk includes, among its lines, the very last line of either version of the file, and that last line is <strong class="bold">incomplete line</strong> (which means that the file does not end with the end-of-line character at the end of the hunk), you will find the following:</p>
<pre class="source-code">
\ No newline at end of file</pre>
<p class="calibre3">This situation is not present in the example used.</p>
<p class="calibre3">So, for the example used here, the first hunk means that <code>cmd_http_fetch</code> was replaced by <code>main</code> and the <code>const char *prefix;</code> line was added:</p>
<pre class="source-code">
#include "cache.h"
 #include "walker.h"
-int cmd_http_fetch(int argc, const char **argv, const char *prefix)
+int main(int argc, const char **argv)
 {
+       const char *prefix;
        struct walker *walker;
        int commits_on_stdin = 0;
        int commits;</pre>
<p class="calibre3">See how for the <em class="italic">replaced line</em>, the old <a id="_idIndexMarker084" class="pcalibre1 pcalibre calibre6"/>version of the line appears as removed (<code>-</code>) and the new version as added (<code>+</code>).</p>
<p class="calibre3">In other words, before the change, the appropriate fragment of the file, which was then named <code>builtin-http-fetch.c</code>, looked similar to the following code fragment:</p>
<pre class="source-code">
#include "cache.h"
#include "walker.h"
int <strong class="bold1">cmd_http_fetch</strong>(int argc, const char **argv<strong class="bold1">, const char *prefix</strong>)
{
       struct walker *walker;
       int commits_on_stdin = 0;
       int commits;</pre>
<p class="calibre3">After the change, this fragment of<a id="_idIndexMarker085" class="pcalibre1 pcalibre calibre6"/> the file, which is now named <code>http-fetch.c</code>, looks similar to the following instead:</p>
<pre class="source-code">
#include "cache.h"
#include "walker.h"
int <strong class="bold1">main</strong>(int argc, const char **argv)
{
       <strong class="bold1">const char *prefix;</strong>
       struct walker *walker;
       int commits_on_stdin = 0;
       int commits;</pre>
<h2 id="_idParaDest-33" class="calibre7"><a id="_idTextAnchor035" class="pcalibre1 pcalibre calibre6"/>Selective commit</h2>
<p class="calibre3">Sometimes, after examining the pending changes as explained, you realize that you have two (or more) unrelated changes in<a id="_idIndexMarker086" class="pcalibre1 pcalibre calibre6"/> your working directory that should belong to two different logical changes; such a problem is sometimes called the <strong class="bold">tangled working copy problem</strong>. You need to put those unrelated changes into separate <a id="_idIndexMarker087" class="pcalibre1 pcalibre calibre6"/>commits as separate changesets. This is the type of situation that can occur even when trying to follow best practices (see <a href="B21194_15.xhtml#_idTextAnchor371" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 15</em></a>, <em class="italic">Git </em><em class="italic">Best Practices</em>).</p>
<p class="calibre3">One solution is to create the commit as-is and fix it later (split it in two). You can read about how to do this in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping </em><em class="italic">History Clean</em>.</p>
<p class="calibre3">Sometimes, however, some of the changes are needed now and must be shipped immediately (for example, a bugfix to a live website), while the rest of the changes are not ready yet (they are a work in progress). You need to tease those changes apart into two separate commits.</p>
<h3 class="calibre9">Selecting files to commit</h3>
<p class="calibre3">The simplest situation is when these unrelated changes touch different files. For example, if the bug was in the <code>view/entry.tmpl</code> file and the bugfix changes only this file (and there were <a id="_idIndexMarker088" class="pcalibre1 pcalibre calibre6"/>no other changes to this file, unrelated to fixing the bug), you can create a bugfix commit with the following command:</p>
<pre class="console">
$ git commit view/entry.tmpl</pre>
<p class="calibre3">This command will ignore changes staged in the index (what was in the staging area), and instead record the current contents of a given file or files (what is in the working directory).</p>
<h3 class="calibre9">Interactively selecting changes</h3>
<p class="calibre3">Sometimes, however, the changes <a id="_idIndexMarker089" class="pcalibre1 pcalibre calibre6"/>cannot be separated in this simple way; the changes to the file are tangled together. You can try to tease them apart by giving the <code>-</code><code>‍</code><code>-</code><code>‍</code><code>interactive</code> option to the <code>git </code><code>commit</code> command:</p>
<pre class="console">
$ git commit --interactive
           staged     unstaged path
  1:    unchanged        +3/-2 Makefile
  2:    unchanged       +64/-1 src/rand.c
*** Commands ***
  1: status       2: update       3: revert       4: add untracked
  5: patch        6: diff         7: quit         8: help
What now&gt;</pre>
<p class="calibre3">Here, Git shows us the status and the summary of changes to the working area (<code>unstaged</code>) and the staging area (<code>staged</code>), which is also the output of the <code>status</code> subcommand. The changes are described by the number of added and deleted lines — for example, <code>+3/-2</code> here (this is similar to what the <code>git diff --numstat</code> command would show).</p>
<p class="callout-heading">Tip</p>
<p class="callout">It might be easier to use a graphical tool such as <strong class="source-inline1">git gui</strong> with this capability. In GUIs, such as the one mentioned, one can use the mouse to select which lines of changes to include or exclude.</p>
<p class="calibre3">You can use the <code>help</code> subcommand, accessed by pressing <em class="italic">h</em>, to check what those listed operations mean:</p>
<pre class="console">
What now&gt; h
status        - show paths with changes
update        - add working tree state to the staged set of changes
revert        - revert staged set of changes back to the HEAD version
patch         - pick hunks and update selectively
diff          - view diff between HEAD and index
add untracked - add contents of untracked files to the staged set of changes</pre>
<p class="calibre3">To tease apart changes, you need to choose the <code>patch</code> subcommand (for example, with <em class="italic">5</em> or <em class="italic">p</em>). Git will then ask for<a id="_idIndexMarker090" class="pcalibre1 pcalibre calibre6"/> the files with the <code>Update&gt;&gt;</code> prompt; you then need to select the files to selectively update with their numeric identifiers, as shown in the status, and type <code>return</code>. You can type <code>*</code> to select all the files possible. After making the selection, end it by answering with an empty line:</p>
<pre class="console">
What now&gt; p
           staged     unstaged path
  1:    unchanged        +3/-2 Makefile
  2:    unchanged       +64/-1 src/rand.c
Patch update&gt;&gt; 1
           staged     unstaged path
* 1:    unchanged        +3/-2 Makefile
  2:    unchanged       +64/-1 src/rand.c
Patch update&gt;&gt;</pre>
<p class="calibre3">You can skip directly to patching files by using <code>git commit --patch</code> instead of <code>git </code><code>commit -</code><code>‍</code><code>-</code><code>‍</code><code>interactive</code>.</p>
<p class="calibre3">Git will then display all the changes to the specified files on a hunk-by-hunk basis, and let you choose, among<a id="_idIndexMarker091" class="pcalibre1 pcalibre calibre6"/> others, one of the following options for each hunk:</p>
<pre class="console">
y - stage this hunk
n - do not stage this hunk
q - quit; do not stage this hunk or any of the remaining ones
a - stage this hunk and all later hunks in the file
…
s - split the current hunk into smaller hunks
e - manually edit the current hunk
? - print help</pre>
<p class="calibre3">The hunk output and the prompt look similar to the following:</p>
<pre class="console">
@@ -16,7 +15,6 @@ int main(int argc, char *argv[])
        int max = atoi(argv[1]);
+       srand(time(NULL));
        int result = random_int(max);
        printf("%d\n", result);
Stage this hunk [y,n,q,a,d,/,j,J,g,e,?]? y</pre>
<p class="calibre3">In many cases, it is enough to simply select which of those hunks of changes you want to have in the commit. In extreme cases, you can<a id="_idIndexMarker092" class="pcalibre1 pcalibre calibre6"/> split a chunk into smaller pieces, or even manually edit the difference.</p>
<p class="calibre3">Many graphical tools, including <code>git gui</code>, also allow for the interactive selection of changes going to the next commit. You can find out more in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and Extending Git</em>, in the <em class="italic">Graphical </em><em class="italic">interfaces</em> section.</p>
<h3 class="calibre9">Creating a commit step by step</h3>
<p class="calibre3">Using <code>git commit --interactive</code> to select changes to a commit doesn’t, unfortunately, allow you to test the changes to be committed. You can always check that everything works after creating a<a id="_idIndexMarker093" class="pcalibre1 pcalibre calibre6"/> commit (that is, compile the code and/or run tests), and then amend it if there are any errors (see the next section, <em class="italic">Amending a commit</em>). There is, however, an alternative solution.</p>
<p class="calibre3">Instead of using the interactive commit feature, you can prepare to commit by putting the pending changes into the staging area with <code>git add --interactive</code> or an equivalent solution (such as a graphical commit tool for Git — for example, <code>git gui</code>). The interactive commit is just a shortcut for <code>git diff --cached</code>, modifying them as appropriate with <code>git add &lt;file&gt;</code>, <code>git checkout &lt;file</code>&gt;, and <code>git </code><code>reset &lt;file&gt;</code>.</p>
<p class="calibre3">In theory, you should also test whether these changes are correct, checking that at least they do not break the build. To do this, first use <code>git stash save --keep-index</code> to save the current state and bring the working directory to the state prepared in the staging area (the index). After this command, you can run tests (or at least check whether the program compiles and doesn’t crash). If tests pass, you can then run <code>git commit</code> to create a new revision. If tests fail, you should restore the working directory while keeping the staging area state with the <code>git stash pop --index</code> command; it might be required to precede it with <code>git reset --hard</code>. The latter might be needed because Git is overly conservative when preserving your work and does not know that you have just stashed. First, there are uncommitted changes in the index that prevent Git from applying the stash, and second, the changes to the working directory are the same as those stashed, so, of course, they would conflict.</p>
<p class="calibre3">You can find more<a id="_idIndexMarker094" class="pcalibre1 pcalibre calibre6"/> information about <strong class="bold">stashes</strong>, including how they<a id="_idIndexMarker095" class="pcalibre1 pcalibre calibre6"/> work, in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>, in the <em class="italic">Stashing away your </em><em class="italic">changes</em> section.</p>
<h1 id="_idParaDest-34" class="calibre5"><a id="_idTextAnchor036" class="pcalibre1 pcalibre calibre6"/>Amending a commit</h1>
<p class="calibre3">One of the better things about Git is that <a id="_idIndexMarker096" class="pcalibre1 pcalibre calibre6"/>you can undo almost anything; you only need to know how to. This is because no matter how carefully you craft your commits, sooner or later, you’ll forget to add a change or mistype the commit message. That’s when the <code>--amend</code> flag of the <code>git commit</code> command comes in handy; it allows you to change the very last commit really easily. Note that with <code>git commit -- amend</code>, you can also amend the merge commits (for example, to fix a merging error). <em class="italic">Figure 2</em><em class="italic">.4</em> shows how this amend operation changes the graph of revisions which represents the history of the project.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you want to change a commit deeper in the history (assuming that it was not published, or, at least, there isn’t anyone who based their work on the old version of the said commit), you need to <a id="_idIndexMarker097" class="pcalibre1 pcalibre calibre6"/>use <strong class="bold">interactive rebase</strong>, or some specialized tool <a id="_idIndexMarker098" class="pcalibre1 pcalibre calibre6"/>such as <strong class="bold">StGit</strong> (a <strong class="bold">patch stack management interface</strong> on top of Git). Refer to <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>, for more information.</p>
<div><div><img alt="Figure 2.4 – The graph of revisions before and after amending the last commit" src="img/B21194_02_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.4 – The graph of revisions before and after amending the last commit</p>
<p class="calibre3">If you just want to correct the <a id="_idIndexMarker099" class="pcalibre1 pcalibre calibre6"/>commit message, assuming you don’t have any staged changes, you simply run <code>git commit --amend</code> and fix it (note that we use <code>git commit</code> without the <code>-a</code> / <code>--</code><code>all</code> flag):</p>
<pre class="console">
$ git commit --amend</pre>
<p class="calibre3">If you want to add some more changes to that last commit, you can simply stage them as normal with <code>git add</code> and then <em class="italic">amend</em> the last commit, as shown in the preceding example, or make the changes and then use <code>git commit -</code><code>a --amend</code>:</p>
<p class="callout-heading">Important note</p>
<p class="callout">There is a very important caveat: you should <em class="italic">never</em> amend a commit that has already been published! This is because amending effectively produces a completely new commit object that replaces the old one, as can be seen in <em class="italic">Figure 2</em><em class="italic">.4</em>. In this figure, you can see that the most recent commit before the operation, denoted by <strong class="bold">C5</strong>, is replaced in the project history by the commit <strong class="bold">C5’</strong>, with amended changes.</p>
<p class="callout">If you’re the only person who had this commit, doing this is safe. However, after publishing the original commit to a remote repository, other people might already have based their new work on that version of the commit. In this case, replacing the original with an amended version will cause problems downstream. You will find out more about this issue in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping </em><em class="italic">History Clean</em>.</p>
<p class="callout">That is why, if you try to push (publish) a branch with the published commit amended, Git prevents overwriting the published history and asks you to <strong class="bold">force push</strong> if you really want to replace the old version (unless you configure it to force push by default). More about that in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development </em><em class="italic">with Git</em>.</p>
<p class="calibre3">The old version of the commit <a id="_idIndexMarker100" class="pcalibre1 pcalibre calibre6"/>before amending would be available in the branch reflog and in the HEAD reflog; for example, just after amending, the amended version would be available as <code>@{1}</code>. This means that you can undo the amend operation with, for example, <code>git reset --keep HEAD@{1}</code>, as described in the <em class="italic">Rewinding or resetting a branch</em> section. Git would keep the old version for a month (30 days) by default if not configured otherwise, unless the reflog is manually purged.</p>
<p class="calibre3">You can always check the log of operations in the reflog by using the <code>git reflog</code> command. Just after amending a commit, that command output would look like the following:</p>
<pre class="console">
$ git reflog --no-decorate
94d3e03 HEAD@{0}: commit (amend): After amending
d69a0a9 HEAD@{1}: commit: Before amending</pre>
<p class="calibre3">Here, <code>HEAD@{1}</code> means the position of the current branch <code>1</code> operation back. Besides the HEAD reflog, there is also a reflog for each branch, as described later. Note that you can read more about using reflog to refer to commits in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring </em><em class="italic">Project History</em>.</p>
<h1 id="_idParaDest-35" class="calibre5"><a id="_idTextAnchor037" class="pcalibre1 pcalibre calibre6"/>Working with branches and tags</h1>
<p class="calibre3">In version control, <strong class="bold">branches</strong> are separate lines <a id="_idIndexMarker101" class="pcalibre1 pcalibre calibre6"/>of development, a way of separating different ideas and different parts of changes. You can use branches in different ways, which are described in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced </em><em class="italic">Branching Techniques</em>.</p>
<p class="calibre3"><code>v1.0</code> tag, you will be able to go to exactly version 1.0 of the code. Additionally, with <strong class="bold">annotated tags</strong>, you can <a id="_idIndexMarker103" class="pcalibre1 pcalibre calibre6"/>give a longer description of the tagged<a id="_idIndexMarker104" class="pcalibre1 pcalibre calibre6"/> revision, and <strong class="bold">signed tags</strong> also help ensure that it was you who created it.</p>
<p class="calibre3">In Git, each branch is realized as a named “<em class="italic">pointer</em>” (reference) to some commit in the graph of revisions, the so-called <a id="_idIndexMarker105" class="pcalibre1 pcalibre calibre6"/>branch head. The same is true for <strong class="bold">lightweight tags</strong>; for annotated and signed tags, the “<em class="italic">pointer</em>” refers to the tag object (with annotation or signature), which points to<a id="_idIndexMarker106" class="pcalibre1 pcalibre calibre6"/> a commit.</p>
<p class="callout-heading">Representation of branches in Git</p>
<p class="callout">Git currently uses <a id="_idIndexMarker107" class="pcalibre1 pcalibre calibre6"/>two different on-disk representations of branches: the “<em class="italic">loose</em>” format (which takes precedence) and the “<em class="italic">packed</em>” format.</p>
<p class="callout">Take, for example, the <strong class="source-inline1">master</strong> branch (which is currently the default name of the branch in Git; you start on this branch in a newly created repository, unless configured otherwise). In the “<em class="italic">loose</em>” format (which takes precedence), the branch is represented as the one-line <strong class="source-inline1">.git/refs/heads/master</strong> file with a textual hexadecimal representation of SHA-1 at the tip of the branch. In the “<em class="italic">packed</em>” format, a branch is represented as a line in the .<strong class="source-inline1">git/packed-refs</strong> file, connecting the SHA-1 identifier of the top commit with the fully qualified branch name.</p>
<p class="calibre3">The (named) <strong class="bold">line of development</strong> is then a set of all the revisions that are reachable from the branch head. It is not necessarily a straight line of revisions — it can fork and join.</p>
<h2 id="_idParaDest-36" class="calibre7"><a id="_idTextAnchor038" class="pcalibre1 pcalibre calibre6"/>Creating a new branch</h2>
<p class="calibre3">When creating a new branch, you can just create it and switch to it later, or you can create it and switch to it with a single<a id="_idIndexMarker108" class="pcalibre1 pcalibre calibre6"/> command. This is explained in <em class="italic">Figure 2</em><em class="italic">.5</em>.</p>
<p class="calibre3">You can create a new branch with the <code>git branch</code> command. For example, to create a new <code>testing</code> branch starting from the current branch (see the top-right part of <em class="italic">Figure 2</em><em class="italic">.5</em>), run the following:</p>
<pre class="console">
$ git branch testing</pre>
<p class="calibre3">What happens here? Well, this command creates a new pointer (a new reference) for you to move around. You can give an optional parameter to this command if you want to create the new branch pointing to some other commit, like in the following example:</p>
<pre class="console">
$ git branch testing HEAD^^^</pre>
<div><div><img alt="Figure 2.5 – Creating a new branch named “testing” and switching to this branch, or creating a new branch and switching to it at once, with one command" src="img/B21194_02_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Creating a new branch named “testing” and switching to this branch, or creating a new branch and switching to it at once, with one command</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline1">HEAD^^^</strong> notation will be<a id="_idIndexMarker109" class="pcalibre1 pcalibre calibre6"/> explained in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring </em><em class="italic">Project History</em>.</p>
<p class="calibre3">However, the <code>git branch &lt;new branch&gt;</code> command would not change which branch is the current branch; it does not switch to the just-created branch. It would not change the position of the <code>HEAD</code> (the symbolic reference pointing to the current branch) and would not change the<a id="_idIndexMarker110" class="pcalibre1 pcalibre calibre6"/> contents of the working directory.</p>
<p class="calibre3">If you want to create a new branch and switch to it (to start working on a new branch immediately), you can use the following shortcut:</p>
<pre class="console">
$ git switch -c testing</pre>
<p class="calibre3">Here, the short <code>-c</code> option stands for <code>--create</code>. You can also use the following alternative command, which is the only option for older Git:</p>
<pre class="console">
$ git checkout -b testing</pre>
<p class="calibre3">If you want to forcibly create a branch with a name that already exists, effectively deleting the existing branch, you will need to use the <code>-C</code> and <code>-B</code> options instead of the <code>-c</code> and <code>-b</code> options, respectively.</p>
<p class="calibre3">If we create a new branch at the current state of the repository, the <code>switch -c</code> and <code>checkout -b</code> commands differ only in that they also move the <code>HEAD</code> pointer; see the transition from the left-hand side to the bottom right in <em class="italic">Figure 2</em><em class="italic">.5</em>.</p>
<h2 id="_idParaDest-37" class="calibre7"><a id="_idTextAnchor039" class="pcalibre1 pcalibre calibre6"/>Creating orphan branches</h2>
<p class="calibre3">Rarely, you might want to <a id="_idIndexMarker111" class="pcalibre1 pcalibre calibre6"/>create a new unconnected <strong class="bold">orphan branch</strong> in your repository that doesn’t share any history with other branches. Perhaps you want to store the generated documentation for each release to make it easy for users to get readable documentation (for example, as man pages or HTML help) without requiring the installation of conversion tools or renderers (for example, AsciiDoc or a Markdown parser). Or, you might want to store web pages for a project in the same repository as the project itself; that is what GitHub project pages can use. Perhaps you want to open source your code, but you need to clean up the code first (for example, because of copyrights and licensing).</p>
<p class="calibre3">One solution is to create a<a id="_idIndexMarker112" class="pcalibre1 pcalibre calibre6"/> separate repository for the contents of an orphan branch and fetch from it into some remote-tracking branch. You can then create a local branch based on it. This has the advantage of having unconnected contents separately, but on the other hand, it is one more repository to manage.</p>
<p class="calibre3">You can also do this with either the <code>git switch</code> or <code>git checkout</code> command by using the <code>--</code><code>orphan</code> option:</p>
<pre class="console">
$ git switch --orphan gh-pages
Switched to a new branch 'gh-pages'</pre>
<p class="calibre3">This reproduces the state similar to just after <code>git init</code>: the <code>HEAD</code> <code>symref</code> points to the <code>gh-pages</code> branch, which<a id="_idIndexMarker113" class="pcalibre1 pcalibre calibre6"/> does not exist yet; it will be created on the first commit.</p>
<p class="calibre3">If you want to start with a clean state, such as with GitHub Pages, you will also need to remove the contents of the start point of the branch (which defaults to <code>HEAD</code> — that is, to the current branch and the current state of the working directory) — for example, with the following:</p>
<pre class="console">
$ git rm -rf .</pre>
<p class="calibre3">In the case of open sourcing code with proprietary parts to be excluded, where the orphan branch is used to make sure not to bring the proprietary code accidentally to the open source version on merging, you would want to carefully edit the working directory instead.</p>
<h2 id="_idParaDest-38" class="calibre7"><a id="_idTextAnchor040" class="pcalibre1 pcalibre calibre6"/>Selecting and switching to a branch</h2>
<p class="calibre3">To switch to an existing<a id="_idIndexMarker114" class="pcalibre1 pcalibre calibre6"/> local branch, you need to run the <code>git switch</code> command. For example, after creating the <code>testing</code> branch, you can switch to it with the following <a id="_idIndexMarker115" class="pcalibre1 pcalibre calibre6"/>command:</p>
<pre class="console">
$ git switch testing</pre>
<p class="calibre3">This is shown in <em class="italic">Figure 2</em><em class="italic">.6</em> as the vertical transition from the top-right to the bottom-right state; this figure also shows that you can use <code>git checkout</code> to switch branches.</p>
<h3 class="calibre9">Obstacles to switching to a branch</h3>
<p class="calibre3">When switching to a branch, Git also <a id="_idIndexMarker116" class="pcalibre1 pcalibre calibre6"/>checks out its contents in the working directory. What happens then if you have uncommitted changes (that are not considered by Git to be on any branch)?</p>
<p class="callout-heading">Tip</p>
<p class="callout">It is a good practice to switch branches in a clean state, stashing away changes or creating a commit if necessary. Checking out a branch with uncommitted changes is useful only in a few rare cases, some of which are described in the following section.</p>
<p class="calibre3">If the difference between the current branch and the branch you want to switch to does not touch the changed files, the uncommitted changes are moved to the new branch. This is very useful if you started working on something and only later realized that it would be better to do this work in a separate feature branch.</p>
<p class="calibre3">If uncommitted changes conflict with changes on the given branch, Git will refuse to switch to the said branch to prevent you from losing your work:</p>
<pre class="console">
$ git checkout other-branch
error: Your local changes to the following files would be overwritten by checkout:
        file-with-local-changes
Please commit your changes or stash them before you switch branches.
Aborting</pre>
<p class="calibre3">In such a situation, you have a few possible different solutions:</p>
<ul class="calibre16">
<li class="calibre15">You can <em class="italic">stash away</em> your <a id="_idIndexMarker117" class="pcalibre1 pcalibre calibre6"/>changes with the <strong class="source-inline1">git stash</strong> command and restore them when you come back to the branch you were on. This is usually the preferred solution.<p class="calibre3">Alternatively, you can simply create a temporary commit of the work in progress with those changes, and then either amend the commit or rewind the branch when you get back to it.</p></li>
<li class="calibre15">You can try to move your changes to the new branch by <em class="italic">merging</em>, either with <strong class="source-inline1">git switch --merge</strong> (which would do the three-way merge between the current branch, the contents of your working directory with unsaved changes, and the new branch), or by stashing away your changes before checkout and then unstashing them after a switch.</li>
<li class="calibre15">You can also <em class="italic">throw away</em> your changes with <strong class="source-inline1">git switch --discard-changes</strong> or <strong class="source-inline1">git </strong><strong class="source-inline1">checkout --force</strong>.</li>
</ul>
<h3 class="calibre9">Anonymous branches</h3>
<p class="calibre3">What happens if you try to <a id="_idIndexMarker118" class="pcalibre1 pcalibre calibre6"/>check out (switch to) something that is not a local branch — for example, an arbitrary revision (such as <code>HEAD^</code>), a tag (such as <code>v0.9</code>), or a remote-tracking branch (for example, <code>origin/master</code>)? Git assumes that you need to be able to create commits on top of the current state of the working directory.</p>
<p class="calibre3">Older Git refused to <a id="_idIndexMarker119" class="pcalibre1 pcalibre calibre6"/>switch to a non-branch. Nowadays, Git will create an <strong class="bold">anonymous branch</strong> by detaching the <strong class="bold">HEAD</strong> pointer and making it refer directly to a commit (that’s why it is also called a detached HEAD state) rather than being a symbolic <a id="_idIndexMarker120" class="pcalibre1 pcalibre calibre6"/>reference to a branch; see <em class="italic">Figure 2</em><em class="italic">.6</em> for an example.</p>
<div><div><img alt="Figure 2.6 – ﻿The result of checking out a non-branch is a detached HEAD state (which is like being on the anonymous branch)" src="img/B21194_02_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.6 – The result of checking out a non-branch is a detached HEAD state (which is like being on the anonymous branch)</p>
<p class="calibre3">Because this feature is used only rarely, to avoid landing in such a state explicitly, the<code> git switch</code> command requires the use of the <code>--detach</code> option; for backward compatibility, <code>git checkout</code> does not require using this option to detach the <strong class="bold">HEAD</strong> pointer. This option is also useful to explicitly create an anonymous branch at the current position. The detached HEAD state is shown in the branch listing as (<strong class="bold">no branch</strong>) in older versions of Git, or (<strong class="bold">detached from HEAD</strong>) or (<strong class="bold">HEAD detached at</strong>...) in newer versions.</p>
<p class="calibre3">If you did detach HEAD by mistake, you can always <em class="italic">go back to the previous branch</em> with the following command (where <code>-</code> means the name of the previous branch):</p>
<pre class="console">
$ git switch -
Previous HEAD position was a3bl9 &lt;Some commit message&gt;
Switched to branch 'master'</pre>
<p class="callout-heading">Important note</p>
<p class="callout">The <strong class="source-inline1">git switch -</strong> command uses the HEAD reflog to switch to a previous branch. This may not work correctly after renaming the branch.</p>
<p class="calibre3">As Git informs you, when creating<a id="_idIndexMarker121" class="pcalibre1 pcalibre calibre6"/> a detached branch without using the <code>--detach</code> option, you can always give a name to the anonymous branch with <code>git switch -</code><code>c &lt;new-branch-name&gt;</code>.</p>
<p class="calibre3">Because tags are meant to be immutable, trying to check one out (or switch to it) also creates a detached <code>HEAD</code> — tags are not branches.</p>
<h3 class="calibre9">The switch command DWIM-mery</h3>
<p class="calibre3">There is a special case of checking out something that is not a branch. If you check out a remote-tracking branch (for example, <code>origin/next</code>) by its short name (in this case, <code>next</code>) as if it were a local branch, Git <a id="_idIndexMarker122" class="pcalibre1 pcalibre calibre6"/>would assume that you meant to create new contents on top of the remote-tracking branch state and will do what it thinks<a id="_idIndexMarker123" class="pcalibre1 pcalibre calibre6"/> you need. This <code>--no-guess</code> option, or the accompanying <code>checkout.guess</code> configuration variable.</p>
<p class="calibre3">This means that:</p>
<pre class="console">
$ git switch next</pre>
<p class="calibre3">is equivalent to:</p>
<pre class="console">
$ git switch -c next --track origin/next</pre>
<p class="calibre3">Git will do it only if there are no ambiguities; the local branch must not exist (otherwise the command would simply switch to the local branch given) and there can be only one remote-tracking branch that <a id="_idIndexMarker124" class="pcalibre1 pcalibre calibre6"/>matches. The latter condition can be checked by running <code>git show-ref next</code> (using the short name) and verifying that it returns only one line, with remote-tracking branch information:</p>
<pre class="console">
$ git show-ref --abbrev next
4936735 refs/remotes/origin/next</pre>
<h2 id="_idParaDest-39" class="calibre7"><a id="_idTextAnchor041" class="pcalibre1 pcalibre calibre6"/>Listing branches and tags</h2>
<p class="calibre3">If you use the <code>git branch</code> command without any other arguments, it will list all the branches, marking the current<a id="_idIndexMarker125" class="pcalibre1 pcalibre calibre6"/> branch with an asterisk — that is, <code>*</code>.</p>
<p class="callout-heading">Programmatically determining the current branch</p>
<p class="callout">The <strong class="source-inline1">git branch</strong> command is intended for the end user; its output may change in the future version of Git. To find out programmatically, in a shell script, the name of the current branch, uses <strong class="source-inline1">git symbolic-ref HEAD</strong> (or <strong class="source-inline1">git branch --show-current</strong>). To find the SHA-1 function of the current commit, use <strong class="source-inline1">git rev-parse HEAD</strong>. To list all the branches, use <strong class="source-inline1">git show-ref</strong> or <strong class="source-inline1">git for-each-ref</strong>; this also works for tags and remote-tracking branches.</p>
<p class="callout">The <strong class="source-inline1">git symbolic-ref</strong>, <strong class="source-inline1">git rev-parse</strong>, <strong class="source-inline1">git show-ref,</strong> and <strong class="source-inline1">git for-each-ref</strong> commands are all <strong class="bold">plumbing</strong> — that is, commands intended for use in scripts.</p>
<p class="calibre3">You can request more information with <code>-v</code> ( <code>--verbose</code>) or <code>-vv</code>. You can also limit branches shown to only those matching the given shell wildcard with <code>git branch --list &lt;pattern&gt;</code> (quoting the pattern <a id="_idIndexMarker126" class="pcalibre1 pcalibre calibre6"/>to prevent its expansion by the shell, if necessary).</p>
<p class="calibre3">Querying information about remotes, which includes the list of remote branches, by using <code>git remote show</code> is described in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced </em><em class="italic">Branching Techniques</em>.</p>
<p class="calibre3">To list all tags, you can use the <code>git tag</code> command without any arguments, or <code>git tag --list</code>; with <code>git tag --list &lt;pattern&gt;</code>, you can select which tags to show (such as for branches), as in the following example:</p>
<pre class="console">
$ git tag --list "v0.9*"
v0.99
v0.99.1
v0.99.2</pre>
<h2 id="_idParaDest-40" class="calibre7"><a id="_idTextAnchor042" class="pcalibre1 pcalibre calibre6"/>Rewinding or resetting a branch</h2>
<p class="calibre3">What do you do if you want to<a id="_idIndexMarker127" class="pcalibre1 pcalibre calibre6"/> abandon the last commit and <code>git reset --keep</code> (to try to keep the uncommitted changes) or <code>git reset --hard</code> (to drop them). The result of such reset operation is shown in <em class="italic">Figure 2</em><em class="italic">.7</em>.</p>
<div><div><img alt="Figure 2.7 – Rewinding a branch one commit back, to HEAD^, with the reset command" src="img/B21194_02_07.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Rewinding a branch one commit back, to HEAD^, with the reset command</p>
<p class="calibre3">The reset command and its effects <a id="_idIndexMarker130" class="pcalibre1 pcalibre calibre6"/>on the working area will be explained in more <a id="_idIndexMarker131" class="pcalibre1 pcalibre calibre6"/>detail in <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing </em><em class="italic">Your </em><em class="italic">Worktrees</em>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="source-inline1">git reset &lt;commit&gt;</strong> command always <a id="_idIndexMarker132" class="pcalibre1 pcalibre calibre6"/>changes where the current branch points to (moves the ref), while <strong class="source-inline1">git switch</strong> always modifies where the <strong class="source-inline1">HEAD</strong> points to, either changing the current branch or detaching it.</p>
<h2 id="_idParaDest-41" class="calibre7"><a id="_idTextAnchor043" class="pcalibre1 pcalibre calibre6"/>Deleting a branch</h2>
<p class="calibre3">Because in Git, a branch is just a <a id="_idIndexMarker133" class="pcalibre1 pcalibre calibre6"/>pointer and an external reference to the node in the DAG of revisions, deleting a branch is just deleting a pointer. This means that deleting the branch does not immediately delete the history, but it might make it not accessible except via <code>reflog</code>. It is not kept forever, though; the <code>reflog</code> entries expire.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Actually, deleting a branch also removes, irretrievably (at least, in the current Git version), the <strong class="source-inline1">reflog</strong> for the branch being deleted — that is, the log of its history of local operations.</p>
<div><div><img alt="Figure 2.8 – Deleting ﻿the 'based-doc' branch that just got merged into 'master', while being on ﻿the 'master' branch that includes it" src="img/B21194_02_08.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Deleting the 'based-doc' branch that just got merged into 'master', while being on the 'master' branch that includes it</p>
<p class="calibre3">You can delete a branch with <code>git branch --delete &lt;branch-name&gt;</code>, or with <code>branch -d</code>, provided that the branch is not checked out anywhere.</p>
<p class="calibre3">There is, however, one issue to consider — what happens if you delete a branch, and there is no other reference to<a id="_idIndexMarker135" class="pcalibre1 pcalibre calibre6"/> the part of the project history it pointed to? Those revisions will become unreachable, and Git would delete them after the HEAD reflog expires (which, with default configuration, is after 30 days).</p>
<p class="calibre3">That is why Git would allow you to delete only the completely merged-in branch, whose commits are all reachable from <code>HEAD</code>, as in the example in <em class="italic">Figure 2</em><em class="italic">.8</em> (or if the branch deleted is reachable from its upstream branch, if it exists).</p>
<p class="calibre3">To delete a branch that was not merged in, which risks parts of the DAG becoming unreachable, as seen in <em class="italic">Figure 2</em><em class="italic">.9</em>, you need a stronger command — namely, <code>git branch -D</code>  or <code>git branch --delete --force</code>. Git will suggest this operation when refusing to delete an <a id="_idIndexMarker136" class="pcalibre1 pcalibre calibre6"/>unmerged branch.</p>
<div><div><img alt="Figure 2.9 – Deleting the unmerged branch, which results in parts of the history being unreachable" src="img/B21194_02_09.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Deleting the unmerged branch, which results in parts of the history being unreachable</p>
<p class="calibre3">You can check whether the branch was merged into any other branch by checking whether <code>git branch --contains &lt;branch&gt;</code> shows anything. You cannot delete the current branch.</p>
<p class="calibre3">If you ever switched to the branch that got deleted, this event and the switch away from the branch will be kept in the <code>reflog</code> for HEAD. This information can then be used to undelete that branch, or rather, to recreate it:</p>
<pre class="console">
$ git reflog --no-decorate HEAD
…
3a59408 HEAD@{3}: checkout: moving from base-doc to master</pre>
<h2 id="_idParaDest-42" class="calibre7"><a id="_idTextAnchor044" class="pcalibre1 pcalibre calibre6"/>Changing the branch name</h2>
<p class="calibre3">Sometimes, the name<a id="_idIndexMarker137" class="pcalibre1 pcalibre calibre6"/> chosen for a branch needs to be changed. This can happen, for example, if the scope of the branch changes during the development and the old name no longer fits it. Names of branches will appear and be kept forever, by default, in commit messages for merge commits; that’s why you want them to be meaningful.</p>
<p class="calibre3">You can rename a branch with <code>git branch -m</code> (use <code>-M</code> if the target name exists and you want to overwrite it); it will rename a branch and move the corresponding reflog. This will also change the name of the branch in all of its configuration (its description, its upstream, and so on).</p>
<p class="calibre3">The renaming<a id="_idIndexMarker138" class="pcalibre1 pcalibre calibre6"/> event is stored in the reflog, where you can find the previous name and use it to undo the operation (to rename the branch back to the old name):</p>
<pre class="console">
$ git reflog --no-decorate new-name
3a59408 new-name@{0}: branch: renamed refs/heads/old-name to refs/heads/new-name</pre>
<h1 id="_idParaDest-43" class="calibre5"><a id="_idTextAnchor045" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we have learned how to develop with Git and extend the project history by creating new commits and new lines of development (branches). We know what it means to create a commit, amend a commit, create a branch, switch a branch, rewind a branch, and delete a branch from the point of view of the graph of revisions.</p>
<p class="calibre3">This chapter showed a very important Git feature — the staging area for creating commits, also known as the index. This is what makes it possible to untangle the changes to the working directory by selectively and interactively choosing what to commit.</p>
<p class="calibre3">We learned how to examine the changes to the working area before creating a commit. This chapter described, in detail, the extended unified diff format that Git uses to describe the changes.</p>
<p class="calibre3">We also learned about the concept of detached HEAD (or anonymous branch) and orphan branches.</p>
<p class="calibre3">In <a href="B21194_03_split_000.xhtml#_idTextAnchor049" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 3</em></a>, <em class="italic">Managing Your </em><em class="italic">Worktrees</em>, we will learn how to use Git to prepare new commits and how to configure it to make our work easier. We will also learn how to examine, search, and study the contents of the working directory, the staging area, and the project history. We will also see how to use Git to deal with interruptions and recover from mistakes.</p>
<h1 id="_idParaDest-44" class="calibre5"><a id="_idTextAnchor046" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">How does creating a new commit change the history stored in the repository — that is, how does it change the graph of revisions and where branch heads point to?</li>
<li class="calibre15">What is the difference between <strong class="source-inline1">git commit</strong> and <strong class="source-inline1">git commit --all</strong> (or <strong class="source-inline1">git </strong><strong class="source-inline1">commit -a</strong>)?</li>
<li class="calibre15">How do you check what changes you have made in the local repository? How do you undo them?</li>
<li class="calibre15">What is the simplest way to fix an error in the commit message of the last commit on the current branch?</li>
<li class="calibre15">What do you do when you realize that the changes you started to write (but didn’t commit) should be made on a separate new branch?</li>
<li class="calibre15">What is the simplest way to switch to the previous branch, and when can it fail?</li>
</ol>
<h1 id="_idParaDest-45" class="calibre5"><a id="_idTextAnchor047" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li value="1" class="calibre15">Creating a new commit makes a new node in the graph of revisions that has a previous commit as a parent, advances the branch head ref for the current branch to the freshly created node, and keeps <strong class="source-inline1">HEAD</strong> unchanged.</li>
<li class="calibre15">The <strong class="source-inline1">git commit</strong> operation creates the new commit out of the staging area contents, while the <strong class="source-inline1">git commit --all</strong> creates it out of the changes to all tracked files.</li>
<li class="calibre15">You can use <strong class="source-inline1">git status</strong> to examine what files have changed and <strong class="source-inline1">git diff</strong> or <strong class="source-inline1">git diff HEAD</strong> to examine the changes. You can find the explanation of how to undo changes you have made in the full <strong class="source-inline1">git </strong><strong class="source-inline1">status</strong> output.</li>
<li class="calibre15">To change the commit message (that is, the description of the changes) of the last commit, you can use <strong class="source-inline1">git </strong><strong class="source-inline1">commit --amend</strong>.</li>
<li class="calibre15">Because uncommitted changes do not belong to a branch, you can simply create a new branch and switch to it with <strong class="source-inline1">git switch -c &lt;branch-name&gt;</strong> or <strong class="source-inline1">git checkout -</strong><strong class="source-inline1">b &lt;branch-name&gt;</strong>.</li>
<li class="calibre15">To switch to the previous branch, you can use <strong class="source-inline1">git switch -</strong> (with <strong class="source-inline1">-</strong> in place of the branch name). Git finds what the previous branch was by searching reflogs. This operation can fail if the branch was deleted or rename</li>
</ol>
<h1 id="_idParaDest-46" class="calibre5"><a id="_idTextAnchor048" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Scott Chacon, Ben Straub. <em class="italic">Pro Git</em>, 2nd Edition (2014), Apress, <em class="italic">Chapter 2</em><em class="italic">.2</em>, <em class="italic">Git Basics - Recording Changes to the </em><em class="italic">Repository</em>: <a href="https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2/Git-Basics-Recording-Changes-to-the-Repository</a></li>
<li class="calibre15">Jakub Narębski. <em class="italic">How to read the output from git diff?</em> (the answer to the question on StackOverflow): <a href="https://stackoverflow.com/questions/2529441/how-to-read-the-output-from-git-diff/2530012#2530012" class="pcalibre1 pcalibre calibre6">https://stackoverflow.com/questions/2529441/how-to-read-the-output-from-git-diff/2530012#2530012</a></li>
<li class="calibre15">Dragos Barosan. <em class="italic">New in Git: switch and restore</em> (2021): <a href="https://www.banterly.net/2021/07/31/new-in-git-switch-and-restore/" class="pcalibre1 pcalibre calibre6">https://www.banterly.net/2021/07/31/new-in-git-switch-and-restore/</a></li>
<li class="calibre15">Junio C Hamano. <em class="italic">Fun with a new feature in recent Git</em> (2016), about the <strong class="source-inline1">--sort</strong> option of the <strong class="source-inline1">git branch</strong> command: <a href="https://git-blame.blogspot.com/2016/05/fun-with-new-feature-in-recent-git.html" class="pcalibre1 pcalibre calibre6">https://git-blame.blogspot.com/2016/05/fun-with-new-feature-in-recent-git.html</a></li>
<li class="calibre15">Tobias Günther. <em class="italic">A look under the hood: how branches work in Git</em> (2021): <a href="https://stackoverflow.blog/2021/04/05/a-look-under-the-hood-how-branches-work-in-git/" class="pcalibre1 pcalibre calibre6">https://stackoverflow.blog/2021/04/05/a-look-under-the-hood-how-branches-work-in-git/</a></li>
<li class="calibre15">Ryan Tomayko. <em class="italic">The Thing About Git</em> (2008), about the tangled working copy problem, and how to resolve it in Git: <a href="https://tomayko.com/blog/2008/the-thing-about-git" class="pcalibre1 pcalibre calibre6">https://tomayko.com/blog/2008/the-thing-about-git</a></li>
<li class="calibre15">Nick Quaranto. <em class="italic">Reflog, your safety net</em> (2009), on Gitready: <a href="http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html" class="pcalibre1 pcalibre calibre6">http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html</a></li>
</ul>
</div>
</body></html>