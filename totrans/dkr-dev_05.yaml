- en: '*Chapter 4*: Composing Systems Using Containers'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we created a server-side application using microservices
    architecture. The application was made up of five separate containers: three official
    images and two custom images. The official images were for MongoDB, Redis, and
    Mosca (MQTT).'
  prefs: []
  type: TYPE_NORMAL
- en: For the most part, communication between containers is done via MQTT message
    passing. The subscriber container carries out the database `localhost` (`127.0.0.1`)
    and both subscriber and publisher programs to access Mosca/MQTT at `localhost`,
    too.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to discuss composing systems—specifically, Docker
    Compose.  We are also going to learn how to keep network access private so that
    services can be accessed from within our containers but not be accessible from
    the host. We will learn how we can share volumes in the filesystem between containers.
    There are alternatives to Docker Compose, and we will look at some of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Docker local networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local volumes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other composition tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To recap, we have three official image containers for MongoDB, Mosca, and Redis.
    We have an additional two containers created for this book—publisher and subscriber
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: 'The publisher microservice has been modified to present a form in a web browser.
    The fields in the form and the submit buttons allow us to exercise the various
    operations supported by the subscriber microservice:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The form generated by our updated publisher program](img/B11641_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – The form generated by our updated publisher program
  prefs: []
  type: TYPE_NORMAL
- en: You can choose which database to perform CRUD operations on. You can also set
    a value that is to be used for the **List**, **Count**, **Add**, and **Remove**
    operations. There is a button for each of the CRUD operations, as well as a **Flush**
    button, which removes all the records from the selected database. The return value/result
    of the operation is shown beneath the form under the **Result** heading.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prerequisite software for this chapter includes Docker, Docker Compose (see
    [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)),
    Git, and a web browser, such as Google Chrome or Safari.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker and Docker Compose documentation use the term *service*, whereas
    we use the term *microservice*. For the purposes of this chapter, the terms are
    interchangeable.
  prefs: []
  type: TYPE_NORMAL
- en: In the GitHub repository ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)),
    there is a `chapter4/` directory that accompanies this chapter. It contains a
    modified version of the microservices architecture code used in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3iRWqoH](https://bit.ly/3iRWqoH)'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A composing system for containers is a tool that allows us to describe the whole
    microservices architecture program in a configuration file and then perform operations
    on the system described. Docker Compose is one such tool. Before we get into what
    Docker Compose is and does, let's look at the reason why we need a tool like this.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with .sh scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we''ve been using `.sh` scripts to make working with our microservices
    application easy. We have used the following scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: start-mongodb.sh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: start-redis.sh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: start-mosca.sh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/`start-subscriber.sh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publisher/`start-publisher.sh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/`build.sh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publisher/`build.sh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`subscriber/`push.sh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`publisher/`push.sh'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of having to invoke each of these as separate commands, we can make
    a single start-all.sh script that invokes them all:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The start-all.sh script is presented for informational purposes. We will not
    be using it going forward!
  prefs: []
  type: TYPE_NORMAL
- en: This approach works, but the information about what ports are open and other
    container-specific access information is hidden within those `.sh` scripts. For
    example, the mongodb.sh script starts MongoDB and binds port `27017` of the container
    to port `27017` of the host.
  prefs: []
  type: TYPE_NORMAL
- en: Making changes to the configuration may require editing each of those `.sh`
    scripts, and maybe even the start-all.sh script itself, as well as its counterpart,
    stop-sll.sh. We have several additional scripts as well for building and publishing
    the containers and to perform other housekeeping tasks. This approach is both
    inconvenient and error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Compose tool solves most of the issues with `.sh` scripts, although
    we might still want to use `.sh` scripts to invoke the `docker-compose` command
    with its various command-line arguments.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Configuration for Docker Compose is done via `.yml` files, the contents of which
    are YAML.  YAML is a markup language that allows data serialization. It is similar
    to JSON format but is much more human-friendly in its syntax.
  prefs: []
  type: TYPE_NORMAL
- en: A file named `docker-compose.yml` is Docker Compose's default configuration
    file. You may have multiple configuration files, and you can tell Docker Compose
    which configuration files to use via a command-line switch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `docker-compose-example.yml` file in the `chapter4/` directory
    in the repository. The Docker Compose tool can replace the shell script methodology
    we''ve used so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Docker Compose supports different versions of the `docker-compose.yml` format.
    Newer versions have higher version numbers and add additional `docker-compose`
    features. In the `services` section, we describe each of the containers that are
    to be built and run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have our `redis` container under the `services` section. The `image` field
    specifies that we will be using the `redis` image from Docker Hub. We persist
    the database in `/tmp/redis` so that the data is not lost when the container is
    stopped and restarted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We expose port `6379`, the default Redis port, on the host. Exposing this port
    allows the host and other containers to access the Redis server.
  prefs: []
  type: TYPE_NORMAL
- en: 'After Redis, we have our MongoDB container. We are going to use the `mongo`
    image from Docker Hub. We persist the data in the host''s `/tmp/mongo` directory
    so that the database''s contents are retained between stopping and restarting
    the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The default TCP port for MongoDB is `27017`, and we expose it to map port `27017`
    in the container to port `27017` on the host. Tools on the host and within our
    containers can access MongoDB via `localhost`, and we don't need to specify a
    port on the command lines since the default is configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next is the Mosca container. We are using the `matteocollina/mosca` image from
    Docker Hub. We set the `/db` volume in the container to `/tmp/mosca` on the host
    to persist Mosca''s state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We expose ports `1883` and `80` as the same ports on the host. Port `1883` is
    the default MQTT port. Port `80` is provided to support MQTT over WebSocket, so
    you can use MQTT in JavaScript programs in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `publisher` container, the `build:` line tells `docker-compose` that
    we need to build the container specified in the `publisher/` directory. The Dockerfile
    in the `publisher` directory is used to define how the container is to be built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We expose port `3000` so that we can access the web server that is running in
    the container using a web browser on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `subscriber` container, the `build:` line tells `docker-compose` that
    we need to build the container specified in the `subscriber/` directory. The Dockerfile
    in the `subscriber` directory is used to define how the container is to be built:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We don't expose anything—the subscriber performs all of its I/O operations via
    direct API calls for MongoDB and Redis, as well as accepting commands and reporting
    status via MQTT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some things to note are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All the containers are described neatly within the single configuration file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The containers still expose the same ports on the host as with the `.sh` scripts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The containers must still find the database and MQTT broker containers via the
    `HOSTIP` environment variable. This variable must still be set as explained in
    the previous chapter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use our `docker-compose-example.yml` script to bring up all five microservices,
    we use the `docker-compose up` command. The `-f` switch tells `docker-compose`
    which Docker Compose `.yml` file to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: By default, `docker-compose` runs all the containers in the configuration file
    in debug mode. They will print their output to the Terminal/console in the order
    that the lines are printed. You may see lines printed by the subscriber, then
    lines printed by the publisher, then lines printed by subscriber again. If you
    hit *Ctrl* + *C*, it will terminate all of the containers and return you to Command
    Prompt.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want the containers to run in detached or daemon mode, use the `-d`
    switch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In detached or daemon mode, the containers will not print output to the Terminal/console
    and you will be returned to the prompt right away.
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop all five microservices, we use a similar `docker-compose` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If we do not specify the Docker Compose configuration file to use (`-f docker-compose-example.yml`),
    then the `docker-compose` command will look for and use a file named `docker-compose.yml`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker-compose up`/`down` commands allow us to start and stop one or more
    of our services as well. For example, we can start only the `mongodb` and `redis`
    containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The existing `mongodb` and/or `redis` containers will be stopped and new ones
    started. It is up to your programs to detect whether the connections to these
    services were stopped and to handle the error accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can build any or all of our services using `docker-compose`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command builds our publisher container but does not start any containers.
  prefs: []
  type: TYPE_NORMAL
- en: The key takeaway from the ability to specify none (none means *all*) or one
    or more of our containers (by name) replaces several of our old `.sh` scripts.
    We don't need start scripts anymore because we can use `docker-compose up`; we
    don't need stop scripts because we can use `docker-compose down`; we don't need
    build scripts because we can use `docker-compose build`; and more! See [https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)
    for details on other `docker-compose` command functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We are likely to have different setups for development and production, if not
    additional scenarios. With `.sh` scripts, we have a debug.sh and run.sh script
    for development and production. The problem with this `.sh` file scheme is that
    we have almost identical `docker run` commands in each, with only minor differences.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose has an inheritance feature where multiple configuration files
    can be specified on the `docker-compose` command line.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance using multiple configuration files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can implement a base `docker-compose.yml` file and then override the settings
    in that file with our own override configuration files. This feature is called
    `docker-compose` file and override the settings for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Compose starts with the first configuration file on the command line,
    then merges the second one into it, then merges the third (if there is one), and
    so on. To merge means to apply settings in the second (or third) configuration
    file to the current state of the configuration, which will ultimately be used.
    Any settings in the second configuration file will replace the ones in the first
    configuration file, if they exist, or will add new services or settings if they
    don't already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at the `docker-compose.yml` base file, which we''ll use from now
    on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like the `docker-compose-example.yml` file from the previous section,
    but you may notice a couple of differences:'
  prefs: []
  type: TYPE_NORMAL
- en: There are two `depends_on` options—one for the publisher and one for the subscriber.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are no longer exposing or binding the container's ports to the host's ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a look at them in detail in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The depends_on option
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `depends_on` option allows us to control the start-up order of the containers
    (refer to [https://docs.docker.com/compose/startup-order/](https://docs.docker.com/compose/startup-order/)).
    Additionally, `depends_on` expresses an interdependency between containers. Refer
    to https://docs.docker.com/compose/compose-file/#depends-on#depends_on for more
    information about the `depends_on` option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Service dependencies cause the following behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-compose up` starts services in dependency order. In our example, `redis`,
    `mongo`, and the `mosca` services are started before the `subscriber` container,
    and both `mosca` and `subscriber` are started before `publisher`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose up SERVICE` automatically includes dependencies under `SERVICE`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`docker-compose stop` stops services in dependency order (`mosca`, then `mongodb`,
    then `redis` in our `docker-compose.yml` file).'
  prefs: []
  type: TYPE_NORMAL
- en: The order in which the services are started is important because if we start
    `publisher` before `mosca` is running, the logic to connect to the MQTT broker
    in the `publisher` program will fail. Similarly, starting `subscriber` before
    the database and MQTT broker services would likely cause the logic in `subscriber`
    to connect to the databases and the MQTT broker to fail. It doesn't make sense
    to start `publisher` before `subscriber` is running because anything `publisher`
    sends via MQTT will fall on deaf ears, so to speak.
  prefs: []
  type: TYPE_NORMAL
- en: Even though a container has started, there is no guarantee that the container's
    program will have completed its initialization by the time the microservices that
    use them try to connect.  In our publisher and subscriber code, we created a `wait_for_services()`
    method that ensures that we can connect to the services only when they are up
    and ready.
  prefs: []
  type: TYPE_NORMAL
- en: We call `wait_for_services()` first thing in our publisher and subscriber programs
    to ensure we have waited just long enough for the dependent services to be up
    and ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wait_for_services()` method in `publisher/`index.js is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Our `publisher` microservice only connects to the MQTT broker, so the `wait_for_services()`
    method only waits for our MQTT broker's TCP port to be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `wait_for_services()` method in `subscriber/`index.js is a bit more complicated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `subscriber` microservice needs to connect to the MQTT broker, the `redis`
    server, and the `mongo` server. We wait for the TCP ports of those servers to
    be accessible.
  prefs: []
  type: TYPE_NORMAL
- en: There are other ways to wait for services to be available that involve installing
    command-line programs/scripts in the container and running them before starting
    our publisher or subscriber service. For example, you might use this handy wait-for-it.sh
    script, which can be found at [https://github.com/vishnubob/wait-for-it](https://github.com/vishnubob/wait-for-it).
  prefs: []
  type: TYPE_NORMAL
- en: The lack of options in the `docker-compose.yml` file to expose container ports
    is not an oversight. We are fully able to specify those options in an override
    file that can provide options to existing containers.
  prefs: []
  type: TYPE_NORMAL
- en: Adding port bindings using overrides
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the `chapter4/` directory in the code repository, we have a `docker-compose-simple.yml`
    file that is an example of an override file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we specify the ports for each container. We are inheriting the options
    from our `docker-compose.yml` file and adding options to expose the ports for
    each of our containers.
  prefs: []
  type: TYPE_NORMAL
- en: We don't expose any ports for the `subscriber` microservice because it never
    exposes any ports to the host's ports.
  prefs: []
  type: TYPE_NORMAL
- en: We also define three environment variables to be used by the publisher and subscriber
    containers to access the `MQTT_HOST` (`mosca`), `REDIS_HOST` (`redis`), and `MONGO_HOST`
    (`mongodb`) services.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker-compose` command to bring up our services using the two configuration
    files (inheritance) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Since we are not using the `-d` switch, our containers are not detached but
    print their console/debug output to the Terminal. You cannot enter more commands
    until you hit *Ctrl*+ *C*. Doing this will stop all the containers in reverse
    `depends_on` order and return you to Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Adding the `-d` switch causes all the containers to be started in daemon mode.
    They run in the background and you immediately get a command-line prompt. No further
    output is sent to the Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'If containers are running in daemon mode, you can stop them using the `docker-compose
    down` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can use three or more configuration files as well. Each additional file specified
    on the command line further extends the containers and options specified within.
  prefs: []
  type: TYPE_NORMAL
- en: What we have so far is effectively a production that is set up using inheritance.
    Debugging using this is particularly painful because your only means of diagnosing
    errors is to add `debug()` calls to the publisher and/or subscriber, then rebuilding
    the container(s), and then rerunning the whole application.
  prefs: []
  type: TYPE_NORMAL
- en: To improve our development and debugging cycles, we can bind/mount our `publisher/`
    and `subscriber/` directories to the `/home/app` directory in the containers.
    The Dockerfiles for both containers use the nodemon ([https://nodemon.io/](https://nodemon.io/))
    utility to start the application within the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nodemon utility does a bit more than just starting our program:'
  prefs: []
  type: TYPE_NORMAL
- en: It also monitors the state of the program, and if it stops, nodemon will restart
    it.  This is useful because our Node.js programs might detect an error from which
    they cannot easily be recovered, so they just exit and allow nodemon to restart
    them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For development, nodemon also monitors the timestamps of the files in the code
    directory and will restart the program if any of the files change.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since we can bind/mount our source code directly in the container, any changes
    we make to the files using our editor or IDE on the host will immediately affect
    the changes in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a `docker-compose-simple-dev.yml` file, which adds our bind/mounts
    to publisher and subscriber:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We run this using the `docker-compose up` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we edit, say, the `publisher/`index.js file on the host, we can see that
    nodemon sees the change and restarts the publisher program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We now have a good handle on `docker-compose`, but we are binding ports from
    our containers to the host's ports. This is problematic if you have a container
    that wants to bind to port `80` on the host but the host is running a web server
    or another container for another project that also wants to bind to port `80`.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Docker provides a facility to only expose our ports to our containers!
  prefs: []
  type: TYPE_NORMAL
- en: Using Docker local networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Both Docker and Docker Compose have command-line options to specify a Docker
    local network that the application will use. Using this Docker local network allows
    our containers to access another container's ports without having to bind/expose
    these ports to the host's ports.
  prefs: []
  type: TYPE_NORMAL
- en: Networking using .sh scripts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You use the `docker network create` command to create a named network that
    your containers can use to privately communicate with one another. You can have
    as many of these private networks defined as you like—you might want to work on
    multiple unrelated projects simultaneously and each needs its own network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This command creates a network named `chapter4` that we can use for our microservices
    example programs. We can destroy networks we have created using the `docker network
    rm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command removes our `chapter4` network from the system.
  prefs: []
  type: TYPE_NORMAL
- en: The start-mongodb.sh, start-redis.sh, start-mosca.sh, `publisher/`run.sh, and
    `subscriber/`run.sh scripts are used by the up.sh script to bring up our application's
    containers using the `docker run` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine our up.sh script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We run the `docker network create` command to create our `chapter4` network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We start our three servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We also run `./`start-redis.sh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we start the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The start-mongodb.sh and start-redis.sh scripts are roughly the same as the
    start-mosca.sh script. The relevant lines in the start-mosca.sh script are the
    ones for the `docker run` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Only the service name, which third-party/Docker Hub container to use, and any
    container to host directory bindings are specific to `mongodb`, `mosca`, or `redis`.
    They all share the `chapter4` network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `docker run` command in the `subscriber/`run.sh script looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We are no longer defining the `HOSTIP` environment variable because the Docker
    local networking system provides a DNS function that allows the programs in our
    containers to look up the other containers by name. The name is the name of the
    container, which is specified in the `docker run` commands scripts with the `–name`
    command-line option.
  prefs: []
  type: TYPE_NORMAL
- en: 'The relevant lines in `subscriber/`index.js are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The code is designed to accept the `MONGO_HOST` environment variable; otherwise,
    it will use the `mongodb` container name. The same is the case for `MQTT_HOST`/`mosca`
    and `REDIS_HOST`/`redis`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We have been defining the `HOSTIP`, `MONGO_HOST`, `MQTT_HOST`, and `REDIS_HOST`
    environment variables, especially in the `.sh` script examples. Since we've been
    naming our containers using the `--name` switch on our `docker run` commands,
    Docker's local DNS will work with `.sh` scripts. That is, we don't need to define
    those environment variables if we name our containers. We still need to bind container
    ports to the host's ports, unless we also add the `--network` switch and `docker
    network create` to the Docker local network.
  prefs: []
  type: TYPE_NORMAL
- en: 'The down.sh script stops all the containers and removes the `chapter4` network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We can use these `.sh` scripts, but we've already learned that Docker Compose
    is the superior method for managing our microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Networking with Docker Compose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker-compose.yml` configuration file that we created is still enough
    to use as the base for using the `docker-compose` commands to manage our containers.  However,
    we no longer need to expose or bind container ports to the host's ports; the only
    exception is we'll continue to bind port `3000` so that we can access the publisher
    web pages using our browser on the host. The base `docker-compose.yml` file does
    not bind port `3000`, so we will continue to bind ports using the override file.
  prefs: []
  type: TYPE_NORMAL
- en: By default, if you specify no configuration files on the command line, `docker-compose`
    looks for `docker-compose.yml` and uses it, and then looks for `docker-compose.override.yml`
    and uses that.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to specify a third configuration file, you must use the `-f` command-line
    switch for each configuration file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `docker-compose.override.yml` file handles our production case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This file adds the `chapter4` network, assigns it to each of the containers,
    and binds port `3000` in the publisher container to port `3000` on the host.
  prefs: []
  type: TYPE_NORMAL
- en: 'All we need to do to use `docker-compose.yml` and `docker-compose.override.yml`
    is run a simple `docker-compose` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, our five containers are up and running and we can access
    the application with our browser on the host. We can see it is all working. We
    can also do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the `-d` switch to run the containers in detached/daemon mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `docker-compose` to stop and start any one or more containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `docker-compose` to build any one or more containers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use `docker-compose logs` to show the logs of any of our containers running
    in daemon mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What we now have is a pair of configuration files that work for production mode.
    We now need a way to work in development mode by binding our source code to the
    container's home directory.
  prefs: []
  type: TYPE_NORMAL
- en: Binding a host filesystem within containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we used a third `docker-compose` configuration file to specify bindings
    so that our source code directory would be overlaid within the container (in place
    of the app's home directory). We will do the same for the latest incarnation of
    our Docker Compose setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first create a `docker-compose-dev.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This override file simply maps the publisher and subscriber source code directory
    over `/home/app` in the related container. Now, we can freely edit sources on
    the host and, thanks to nodemon, our changes will take effect almost immediately
    within the running containers. There is no need to stop, rebuild, or restart any
    containers.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, `docker-compose` has no facility to remove options using inheritance;
    we can only modify existing ones or add new ones. If we could remove options,
    we would bind the source in our `docker-compose.override.yml` file and remove
    them in a `docker-compose-production.yml` file. This would allow us to use the
    short `docker-compose up` form for development and to use a command line with
    three `-f` switches for production. This would be handy because we would use development
    most of the time and rarely use production.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it is, we must specify the three `-f` switches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: There are other uses for volumes, which we will explore.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing our container size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can examine our container images using the `docker images` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our publisher image is `987` megabytes! All that for an almost-250-line
    JavaScript program. We can try to shrink this size by moving our `node_modules`
    directory out of the container and into a named volume. This will also speed up
    the building of our container since `node_modules` will be persisted in this named
    volume from build to build, and using the `yarn` command to install the modules
    will only install anything that is new.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We renamed the Dockerfile to `Dockerfile.chapter3` in the `publisher/` directory.  The
    new Dockerfile has been modified to build a very small image.
  prefs: []
  type: TYPE_NORMAL
- en: A smaller image can be created by optimizing our Dockerfile. What we're going
    to do is build a base image and our result image. The base image will have `node_modules`
    installed.  The base image is only rebuilt when something changes that requires
    one of its layers to be rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an optimized Dockerfile for the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We inherit from the alpine OS node v12 image. This image is much lighter than
    the Debian flavor default node container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting image is built without installing or updating `node_modules`.
    We will install the modules in another step. This saves us from having to use
    `yarn` install every time we build our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We use `yarn start` to launch our publisher app.
  prefs: []
  type: TYPE_NORMAL
- en: After we run `docker-compose build publisher`, we can see we have greatly reduced
    the size of our container!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before our optimizations, the container was `987` megabytes. After the optimizations,
    `89.5` megabytes, which is almost a 900-megabyte reduction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We still need to install our `node_modules/` modules, which will be done within
    a named volume and defined in the `docker-compose-overrides.yml` file. This is
    done once, and then again only if you add packages to the `packages.json` file
    in the `publisher/` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: This command installs the `node_modules/` packages using `yarn install` within
    the publisher container. The named volume is mounted correctly because it is specified
    within the `docker-compose` configuration (`.yml`) files.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We did not optimize the subscriber build.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can verify that the volume was created and does contain the installed `node_modules`
    modules by examining the `_data` directory of our volume, which on Linux should
    be in `/var/lib/docker/volumes`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The location of the volumes is significantly different for macOS.  You will
    need to use the following command to get a shell in the Linux virtual machine
    that is running Docker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: You might have to hit `^C` a few times to get a shell prompt. This prompt is
    a shell running in the virtual machine. Within the virtual machine, the volume
    for the `node_modules/` directory in the container is at `/var/lib/docker/volumes`,
    as with Docker on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the speedup of our build. The initial build of the publisher, after
    completely removing all of the images from the system, takes around 16 seconds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'A subsequent build without `node_modules` installed takes around a half a second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'After editing index.js and doing a rebuild, it takes less than 1 second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we were able to reduce the size and build time of our containers!
  prefs: []
  type: TYPE_NORMAL
- en: Using the build.sh script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is a build.sh script provided in the `chapter4/` directory of the GitHub
    repository. It just contains a few lines of actual shell commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'The build.sh script builds all five containers and runs `yarn install` in both
    the publisher and subscriber containers to install the `node_modules` modules
    in their respective named volumes. The command-line switches to the `docker-compose
    build` command are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--force-rm`: Forces Docker to remove all the intermediate container images
    as it builds'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--no-cache`: Forces Docker to use no cached/downloaded/built versions of anything'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can drop these two switches to greatly improve the build speed. They are
    provided here to demonstrate a way of forcibly rebuilding everything from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: That's a decent overview of Docker Compose. It is one of the first, if not the
    first, composition tools for describing, building, and running Docker applications.
    But there are also other alternatives out there.
  prefs: []
  type: TYPE_NORMAL
- en: Other composition tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how we can compose and build a multiple service application
    using `docker-compose` and `.sh` scripts. But there are some other options that
    you may want to consider.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Swarm is a cluster management system. It allows you to deploy containers
    that are defined with `docker-compose` to a cluster of nodes or servers. There
    are some limitations to what you can do with `docker-compose.yml` if you want
    to use Docker Swarm. For example, you cannot use volumes with Docker Swarm, and
    binding container ports to the host should be carefully planned.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Kubernetes is a feature-rich alternative to `docker-compose`. It allows containers
    to be deployed to a cluster of Docker container servers and uses a configuration
    file format similar to `docker-compose.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Packer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Packer is a tool that generates several output formats, including Docker containers.
    You define your containers using JSON files and the tool reads from them. Packer
    uses builders to generate output files. The output can be (but is not limited
    to) the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Azure machine images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DigitalOcean machine images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker container images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google cloud images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallels (for macOS) images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VirtualBox images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VMware images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The composition tool that you choose should make your job easier. Be sure to
    choose one that truly suits your needs. Docker Compose is the official Docker
    composition tool. The others may be more modern and solve additional problems
    that Docker Compose does not.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced Docker Compose as a superior management tool
    for managing and running a complex system of containers. We described several
    useful `docker-compose` configuration file options that allow us to specify ports
    to expose, local networking, and local volumes. We exploited the `docker-compose`
    tool's inheritance capabilities as well.
  prefs: []
  type: TYPE_NORMAL
- en: A critical part of using Docker is the development cycle. We typically edit,
    build, run, and test each cycle—then repeat. The size of images, as well as the
    time spent building, publishing, and downloading them, can be strategically reduced.
  prefs: []
  type: TYPE_NORMAL
- en: We also explored some alternatives to using `.sh` scripts and `docker-compose`.
    These are a natural next step in your Docker education as they provide facilities
    for deploying your orchestrations to swarms or clusters of servers in production
    or for testing.
  prefs: []
  type: TYPE_NORMAL
- en: The next few chapters go into detail about how to deploy your applications and
    how to implement continuous integration and automated testing. After that, we
    will cover security considerations for containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following URLs for more information on the topics covered
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The official Docker documentation: [https://docs.docker.com](https://docs.docker.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The official Docker Compose documentation: [https://docs.docker.com/compose/](https://docs.docker.com/compose/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Dockerfile reference:[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Hub site:[https://hub.docker.com/](https://hub.docker.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for Docker Hub:[https://docs.docker.com/docker-hub/](https://docs.docker.com/docker-hub/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for the `Node.js` containers on Docker Hub:[https://hub.docker.com/_/node](https://hub.docker.com/_/node)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for the Redis containers on Docker Hub:[https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for the MongoDB containers on Docker Hub:[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The documentation for the Mosca containers on Docker Hub:[https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
