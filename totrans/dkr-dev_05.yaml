- en: '*Chapter 4*: Composing Systems Using Containers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第4章*: 使用容器组合系统'
- en: 'In the previous chapter, we created a server-side application using microservices
    architecture. The application was made up of five separate containers: three official
    images and two custom images. The official images were for MongoDB, Redis, and
    Mosca (MQTT).'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们使用微服务架构创建了一个服务器端应用程序。该应用程序由五个独立的容器组成：三个官方镜像和两个自定义镜像。官方镜像分别用于 MongoDB、Redis
    和 Mosca（MQTT）。
- en: For the most part, communication between containers is done via MQTT message
    passing. The subscriber container carries out the database `localhost` (`127.0.0.1`)
    and both subscriber and publisher programs to access Mosca/MQTT at `localhost`,
    too.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，容器之间的通信是通过 MQTT 消息传递进行的。订阅者容器执行数据库 `localhost`（`127.0.0.1`）的操作，且订阅者和发布者程序都可以访问位于
    `localhost` 的 Mosca/MQTT。
- en: In this chapter, we are going to discuss composing systems—specifically, Docker
    Compose.  We are also going to learn how to keep network access private so that
    services can be accessed from within our containers but not be accessible from
    the host. We will learn how we can share volumes in the filesystem between containers.
    There are alternatives to Docker Compose, and we will look at some of them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何组合系统——具体来说是 Docker Compose。我们还将学习如何保持网络访问的私密性，以便服务可以从容器内部访问，但无法从主机访问。我们将了解如何在容器之间共享文件系统中的卷。Docker
    Compose 也有替代方案，我们将看看其中的一些。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Introduction to Docker Compose
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Compose 介绍
- en: Using Docker local networking
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 本地网络
- en: Local volumes
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地卷
- en: Other composition tools
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他组合工具
- en: To recap, we have three official image containers for MongoDB, Mosca, and Redis.
    We have an additional two containers created for this book—publisher and subscriber
    microservices.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们有三个官方 MongoDB、Mosca 和 Redis 的镜像容器。我们还为本书创建了两个额外的容器——发布者和订阅者微服务。
- en: 'The publisher microservice has been modified to present a form in a web browser.
    The fields in the form and the submit buttons allow us to exercise the various
    operations supported by the subscriber microservice:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 发布者微服务已修改为在 web 浏览器中呈现一个表单。表单中的字段和提交按钮使我们能够执行由订阅者微服务支持的各种操作：
- en: '![Figure 4.1 – The form generated by our updated publisher program](img/B11641_04_001.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – 我们更新后的发布程序生成的表单](img/B11641_04_001.jpg)'
- en: Figure 4.1 – The form generated by our updated publisher program
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 我们更新后的发布程序生成的表单
- en: You can choose which database to perform CRUD operations on. You can also set
    a value that is to be used for the **List**, **Count**, **Add**, and **Remove**
    operations. There is a button for each of the CRUD operations, as well as a **Flush**
    button, which removes all the records from the selected database. The return value/result
    of the operation is shown beneath the form under the **Result** heading.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择执行 CRUD 操作的数据库。您还可以设置一个值，用于**列表**、**计数**、**添加**和**移除**操作。每个 CRUD 操作都有一个按钮，还有一个**刷新**按钮，用于从所选数据库中删除所有记录。操作的返回值/结果显示在表单下方的**结果**标题下。
- en: Technical requirements
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The prerequisite software for this chapter includes Docker, Docker Compose (see
    [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)),
    Git, and a web browser, such as Google Chrome or Safari.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前提软件包括 Docker、Docker Compose（参见 [https://docs.docker.com/compose/install/](https://docs.docker.com/compose/install/)）、Git
    以及一种 web 浏览器，如 Google Chrome 或 Safari。
- en: The Docker and Docker Compose documentation use the term *service*, whereas
    we use the term *microservice*. For the purposes of this chapter, the terms are
    interchangeable.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Docker Compose 文档使用“*服务*”这个术语，而我们使用“*微服务*”这个术语。对于本章来说，这两个术语可以互换使用。
- en: In the GitHub repository ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers)),
    there is a `chapter4/` directory that accompanies this chapter. It contains a
    modified version of the microservices architecture code used in the previous chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 仓库中 ([https://github.com/PacktPublishing/Docker-for-Developers](https://github.com/PacktPublishing/Docker-for-Developers))，有一个
    `chapter4/` 目录，包含本章的相关内容。该目录包含了上章中使用的微服务架构代码的修改版本。
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：
- en: '[https://bit.ly/3iRWqoH](https://bit.ly/3iRWqoH)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://bit.ly/3iRWqoH](https://bit.ly/3iRWqoH)'
- en: Introduction to Docker Compose
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker Compose 介绍
- en: A composing system for containers is a tool that allows us to describe the whole
    microservices architecture program in a configuration file and then perform operations
    on the system described. Docker Compose is one such tool. Before we get into what
    Docker Compose is and does, let's look at the reason why we need a tool like this.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的编排系统是一种工具，允许我们在配置文件中描述整个微服务架构程序，然后对所描述的系统进行操作。Docker Compose就是这样的工具。在我们深入了解Docker
    Compose是什么以及它能做什么之前，让我们先来看一下我们为什么需要这样一个工具。
- en: The problem with .sh scripts
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .sh脚本的问题
- en: 'So far, we''ve been using `.sh` scripts to make working with our microservices
    application easy. We have used the following scripts:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用`.sh`脚本来简化我们的微服务应用的工作。我们已经使用了以下脚本：
- en: start-mongodb.sh
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: start-mongodb.sh
- en: start-redis.sh
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: start-redis.sh
- en: start-mosca.sh
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: start-mosca.sh
- en: '`subscriber/`start-subscriber.sh'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/`start-subscriber.sh'
- en: '`publisher/`start-publisher.sh'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publisher/`start-publisher.sh'
- en: '`subscriber/`build.sh'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/`build.sh'
- en: '`publisher/`build.sh'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publisher/`build.sh'
- en: '`subscriber/`push.sh'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`subscriber/`push.sh'
- en: '`publisher/`push.sh'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`publisher/`push.sh'
- en: 'Instead of having to invoke each of these as separate commands, we can make
    a single start-all.sh script that invokes them all:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要将这些命令分别调用，可以通过编写一个单独的start-all.sh脚本来依次执行它们：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The start-all.sh script is presented for informational purposes. We will not
    be using it going forward!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: start-all.sh脚本仅供参考。接下来我们将不再使用它！
- en: This approach works, but the information about what ports are open and other
    container-specific access information is hidden within those `.sh` scripts. For
    example, the mongodb.sh script starts MongoDB and binds port `27017` of the container
    to port `27017` of the host.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是可行的，但关于哪些端口开放以及其他容器特定的访问信息都隐藏在这些`.sh`脚本中。例如，mongodb.sh脚本启动MongoDB并将容器的`27017`端口绑定到主机的`27017`端口。
- en: Making changes to the configuration may require editing each of those `.sh`
    scripts, and maybe even the start-all.sh script itself, as well as its counterpart,
    stop-sll.sh. We have several additional scripts as well for building and publishing
    the containers and to perform other housekeeping tasks. This approach is both
    inconvenient and error-prone.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 修改配置可能需要编辑这些`.sh`脚本中的每一个，甚至可能需要修改start-all.sh脚本本身以及它的对应脚本stop-sll.sh。我们还有一些额外的脚本，用于构建和发布容器，并执行其他管理任务。这个方法既不方便，也容易出错。
- en: The Docker Compose tool solves most of the issues with `.sh` scripts, although
    we might still want to use `.sh` scripts to invoke the `docker-compose` command
    with its various command-line arguments.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose工具解决了大部分`.sh`脚本的问题，尽管我们仍然可能希望使用`.sh`脚本来调用带有各种命令行参数的`docker-compose`命令。
- en: Docker Compose configuration files
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Compose配置文件
- en: Configuration for Docker Compose is done via `.yml` files, the contents of which
    are YAML.  YAML is a markup language that allows data serialization. It is similar
    to JSON format but is much more human-friendly in its syntax.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose的配置通过`.yml`文件完成，文件内容是YAML。YAML是一种标记语言，允许数据序列化。它类似于JSON格式，但语法上对人类更友好。
- en: A file named `docker-compose.yml` is Docker Compose's default configuration
    file. You may have multiple configuration files, and you can tell Docker Compose
    which configuration files to use via a command-line switch.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一个名为`docker-compose.yml`的文件是Docker Compose的默认配置文件。你可以拥有多个配置文件，并且可以通过命令行参数告诉Docker
    Compose使用哪些配置文件。
- en: 'Let''s look at the `docker-compose-example.yml` file in the `chapter4/` directory
    in the repository. The Docker Compose tool can replace the shell script methodology
    we''ve used so far:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下仓库中`chapter4/`目录下的`docker-compose-example.yml`文件。Docker Compose工具可以取代我们迄今为止使用的shell脚本方法：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Docker Compose supports different versions of the `docker-compose.yml` format.
    Newer versions have higher version numbers and add additional `docker-compose`
    features. In the `services` section, we describe each of the containers that are
    to be built and run.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose支持不同版本的`docker-compose.yml`格式。新版的版本号较高，并添加了额外的`docker-compose`功能。在`services`部分，我们描述了要构建和运行的每个容器。
- en: 'We have our `redis` container under the `services` section. The `image` field
    specifies that we will be using the `redis` image from Docker Hub. We persist
    the database in `/tmp/redis` so that the data is not lost when the container is
    stopped and restarted:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`services`部分下有一个`redis`容器。`image`字段指定我们将使用来自Docker Hub的`redis`镜像。我们将数据库持久化到`/tmp/redis`，以便在容器停止和重新启动时不会丢失数据：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We expose port `6379`, the default Redis port, on the host. Exposing this port
    allows the host and other containers to access the Redis server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主机上暴露`6379`端口，这是默认的 Redis 端口。暴露该端口可以让主机和其他容器访问 Redis 服务器。
- en: 'After Redis, we have our MongoDB container. We are going to use the `mongo`
    image from Docker Hub. We persist the data in the host''s `/tmp/mongo` directory
    so that the database''s contents are retained between stopping and restarting
    the container:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Redis 之后，我们有 MongoDB 容器。我们将使用来自 Docker Hub 的`mongo`镜像。我们将数据保存在主机的`/tmp/mongo`目录中，这样在停止和重启容器时，数据库的内容可以被保留：
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The default TCP port for MongoDB is `27017`, and we expose it to map port `27017`
    in the container to port `27017` on the host. Tools on the host and within our
    containers can access MongoDB via `localhost`, and we don't need to specify a
    port on the command lines since the default is configured.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的默认 TCP 端口是`27017`，我们将其暴露出来，将容器中的`27017`端口映射到主机上的`27017`端口。主机和容器中的工具可以通过`localhost`访问
    MongoDB，我们无需在命令行中指定端口，因为默认端口已配置。
- en: 'Next is the Mosca container. We are using the `matteocollina/mosca` image from
    Docker Hub. We set the `/db` volume in the container to `/tmp/mosca` on the host
    to persist Mosca''s state:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 Mosca 容器。我们使用来自 Docker Hub 的`matteocollina/mosca`镜像。我们将容器中的`/db`卷设置为主机上的`/tmp/mosca`，以持久化
    Mosca 的状态：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We expose ports `1883` and `80` as the same ports on the host. Port `1883` is
    the default MQTT port. Port `80` is provided to support MQTT over WebSocket, so
    you can use MQTT in JavaScript programs in the browser.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将`1883`和`80`端口暴露为与主机上相同的端口。端口`1883`是默认的 MQTT 端口。端口`80`用于支持 WebSocket 上的 MQTT，因此您可以在浏览器中的
    JavaScript 程序中使用 MQTT。
- en: 'In our `publisher` container, the `build:` line tells `docker-compose` that
    we need to build the container specified in the `publisher/` directory. The Dockerfile
    in the `publisher` directory is used to define how the container is to be built:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`publisher`容器中，`build:`行告诉`docker-compose`我们需要构建位于`publisher/`目录中的容器。`publisher`目录中的
    Dockerfile 用于定义容器的构建方式：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We expose port `3000` so that we can access the web server that is running in
    the container using a web browser on the host.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们暴露`3000`端口，以便我们能够使用主机上的 Web 浏览器访问容器中运行的 Web 服务器。
- en: 'In our `subscriber` container, the `build:` line tells `docker-compose` that
    we need to build the container specified in the `subscriber/` directory. The Dockerfile
    in the `subscriber` directory is used to define how the container is to be built:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`subscriber`容器中，`build:`行告诉`docker-compose`我们需要构建位于`subscriber/`目录中的容器。`subscriber`目录中的
    Dockerfile 用于定义容器的构建方式：
- en: '[PRE6]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We don't expose anything—the subscriber performs all of its I/O operations via
    direct API calls for MongoDB and Redis, as well as accepting commands and reporting
    status via MQTT.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不暴露任何内容——订阅者通过直接的 API 调用来执行所有 I/O 操作，访问 MongoDB 和 Redis，同时通过 MQTT 接受命令并报告状态。
- en: 'Some things to note are as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的几点如下：
- en: All the containers are described neatly within the single configuration file.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有的容器都在单一的配置文件中进行简洁描述。
- en: The containers still expose the same ports on the host as with the `.sh` scripts.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器仍然暴露与`.sh`脚本相同的端口到主机。
- en: The containers must still find the database and MQTT broker containers via the
    `HOSTIP` environment variable. This variable must still be set as explained in
    the previous chapter.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器仍然需要通过`HOSTIP`环境变量找到数据库和 MQTT 经纪人容器。该变量仍然需要像前一章中解释的那样进行设置。
- en: 'To use our `docker-compose-example.yml` script to bring up all five microservices,
    we use the `docker-compose up` command. The `-f` switch tells `docker-compose`
    which Docker Compose `.yml` file to use:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用我们的`docker-compose-example.yml`脚本启动所有五个微服务，我们使用`docker-compose up`命令。`-f`选项告诉`docker-compose`使用哪个
    Docker Compose `.yml` 文件：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By default, `docker-compose` runs all the containers in the configuration file
    in debug mode. They will print their output to the Terminal/console in the order
    that the lines are printed. You may see lines printed by the subscriber, then
    lines printed by the publisher, then lines printed by subscriber again. If you
    hit *Ctrl* + *C*, it will terminate all of the containers and return you to Command
    Prompt.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`docker-compose`以调试模式运行配置文件中的所有容器。它们会按照打印行的顺序将输出打印到终端/控制台。你可能会看到首先是订阅者的输出，接着是发布者的输出，然后再是订阅者的输出。如果按下*Ctrl*
    + *C*，它将终止所有容器并返回到命令提示符。
- en: 'If you want the containers to run in detached or daemon mode, use the `-d`
    switch:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望容器以分离模式或守护进程模式运行，可以使用`-d`选项：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In detached or daemon mode, the containers will not print output to the Terminal/console
    and you will be returned to the prompt right away.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在分离模式或守护模式下，容器不会向终端/控制台输出信息，你将立即返回到命令提示符。
- en: 'To stop all five microservices, we use a similar `docker-compose` command:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了停止所有五个微服务，我们使用类似的`docker-compose`命令：
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: If we do not specify the Docker Compose configuration file to use (`-f docker-compose-example.yml`),
    then the `docker-compose` command will look for and use a file named `docker-compose.yml`
    instead.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有指定要使用的Docker Compose配置文件（`-f docker-compose-example.yml`），则`docker-compose`命令会查找并使用名为`docker-compose.yml`的文件。
- en: 'The `docker-compose up`/`down` commands allow us to start and stop one or more
    of our services as well. For example, we can start only the `mongodb` and `redis`
    containers:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose up`/`down`命令还允许我们启动和停止一个或多个服务。例如，我们可以只启动`mongodb`和`redis`容器：'
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The existing `mongodb` and/or `redis` containers will be stopped and new ones
    started. It is up to your programs to detect whether the connections to these
    services were stopped and to handle the error accordingly.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现有的`mongodb`和/或`redis`容器将被停止并启动新的容器。由你的程序来检测这些服务的连接是否被停止，并相应地处理错误。
- en: 'We can build any or all of our services using `docker-compose`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`docker-compose`构建任何或所有的服务：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This command builds our publisher container but does not start any containers.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令构建了我们的发布者容器，但不会启动任何容器。
- en: The key takeaway from the ability to specify none (none means *all*) or one
    or more of our containers (by name) replaces several of our old `.sh` scripts.
    We don't need start scripts anymore because we can use `docker-compose up`; we
    don't need stop scripts because we can use `docker-compose down`; we don't need
    build scripts because we can use `docker-compose build`; and more! See [https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)
    for details on other `docker-compose` command functionality.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 能够指定一个或多个容器（通过名称）的能力，替代了我们许多旧的`.sh`脚本。我们不再需要启动脚本，因为可以使用`docker-compose up`；我们不再需要停止脚本，因为可以使用`docker-compose
    down`；我们不再需要构建脚本，因为可以使用`docker-compose build`；等等！更多详细信息请参见[https://docs.docker.com/compose/reference/](https://docs.docker.com/compose/reference/)。
- en: We are likely to have different setups for development and production, if not
    additional scenarios. With `.sh` scripts, we have a debug.sh and run.sh script
    for development and production. The problem with this `.sh` file scheme is that
    we have almost identical `docker run` commands in each, with only minor differences.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很可能会为开发和生产环境设置不同的配置，甚至可能有额外的场景。在`.sh`脚本中，我们为开发和生产环境分别设置了debug.sh和run.sh脚本。这个`.sh`文件方案的问题在于，我们在每个脚本中几乎有相同的`docker
    run`命令，只有细微的差异。
- en: Docker Compose has an inheritance feature where multiple configuration files
    can be specified on the `docker-compose` command line.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose有一个继承功能，允许在`docker-compose`命令行中指定多个配置文件。
- en: Inheritance using multiple configuration files
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个配置文件进行继承
- en: We can implement a base `docker-compose.yml` file and then override the settings
    in that file with our own override configuration files. This feature is called
    `docker-compose` file and override the settings for our purposes.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以实现一个基础的`docker-compose.yml`文件，然后使用我们自己的覆盖配置文件来覆盖该文件中的设置。这个功能被称为`docker-compose`文件及其设置覆盖功能。
- en: Docker Compose starts with the first configuration file on the command line,
    then merges the second one into it, then merges the third (if there is one), and
    so on. To merge means to apply settings in the second (or third) configuration
    file to the current state of the configuration, which will ultimately be used.
    Any settings in the second configuration file will replace the ones in the first
    configuration file, if they exist, or will add new services or settings if they
    don't already exist.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Compose从命令行上的第一个配置文件开始，然后将第二个文件合并到其中，再将第三个（如果有的话）合并进去，依此类推。合并意味着将第二个（或第三个）配置文件中的设置应用到当前的配置状态中，这最终将被使用。如果第二个配置文件中的设置存在，它们将替换第一个配置文件中的设置；如果不存在，它们将添加新的服务或设置。
- en: 'Let''s look at the `docker-compose.yml` base file, which we''ll use from now
    on:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看从现在开始将使用的`docker-compose.yml`基础文件：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This looks like the `docker-compose-example.yml` file from the previous section,
    but you may notice a couple of differences:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来像前一节中的`docker-compose-example.yml`文件，但你可能会注意到几个不同点：
- en: There are two `depends_on` options—one for the publisher and one for the subscriber.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有两个`depends_on`选项——一个用于发布者，另一个用于订阅者。
- en: We are no longer exposing or binding the container's ports to the host's ports.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不再将容器的端口暴露或绑定到主机的端口。
- en: Let's take a look at them in detail in the following sections.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将详细查看它们。
- en: The depends_on option
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`depends_on` 选项'
- en: The `depends_on` option allows us to control the start-up order of the containers
    (refer to [https://docs.docker.com/compose/startup-order/](https://docs.docker.com/compose/startup-order/)).
    Additionally, `depends_on` expresses an interdependency between containers. Refer
    to https://docs.docker.com/compose/compose-file/#depends-on#depends_on for more
    information about the `depends_on` option.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`depends_on` 选项允许我们控制容器的启动顺序（参考 [https://docs.docker.com/compose/startup-order/](https://docs.docker.com/compose/startup-order/)）。此外，`depends_on`
    表示容器之间的相互依赖。更多关于 `depends_on` 选项的信息，请参考 https://docs.docker.com/compose/compose-file/#depends-on#depends_on。'
- en: 'Service dependencies cause the following behaviors:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 服务依赖关系会导致以下行为：
- en: '`docker-compose up` starts services in dependency order. In our example, `redis`,
    `mongo`, and the `mosca` services are started before the `subscriber` container,
    and both `mosca` and `subscriber` are started before `publisher`.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose up` 按照依赖顺序启动服务。在我们的示例中，`redis`、`mongo` 和 `mosca` 服务会在 `subscriber`
    容器之前启动，且 `mosca` 和 `subscriber` 都会在 `publisher` 之前启动。'
- en: '`docker-compose up SERVICE` automatically includes dependencies under `SERVICE`.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker-compose up SERVICE` 会自动包含 `SERVICE` 下的依赖项。'
- en: '`docker-compose stop` stops services in dependency order (`mosca`, then `mongodb`,
    then `redis` in our `docker-compose.yml` file).'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-compose stop` 按照依赖顺序停止服务（首先是 `mosca`，然后是 `mongodb`，再是 `redis`，这些服务在我们的
    `docker-compose.yml` 文件中定义）。'
- en: The order in which the services are started is important because if we start
    `publisher` before `mosca` is running, the logic to connect to the MQTT broker
    in the `publisher` program will fail. Similarly, starting `subscriber` before
    the database and MQTT broker services would likely cause the logic in `subscriber`
    to connect to the databases and the MQTT broker to fail. It doesn't make sense
    to start `publisher` before `subscriber` is running because anything `publisher`
    sends via MQTT will fall on deaf ears, so to speak.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 启动服务的顺序很重要，因为如果我们在 `mosca` 启动之前启动 `publisher`，`publisher` 程序中连接 MQTT 代理的逻辑将失败。同样，若在数据库和
    MQTT 代理服务启动之前启动 `subscriber`，则 `subscriber` 中的连接数据库和 MQTT 代理的逻辑也可能失败。在 `subscriber`
    启动之前启动 `publisher` 是没有意义的，因为 `publisher` 通过 MQTT 发送的任何内容都不会被接收，可以说是“白费力气”。
- en: Even though a container has started, there is no guarantee that the container's
    program will have completed its initialization by the time the microservices that
    use them try to connect.  In our publisher and subscriber code, we created a `wait_for_services()`
    method that ensures that we can connect to the services only when they are up
    and ready.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 即使容器已经启动，也不能保证在使用它们的微服务尝试连接时，容器中的程序已经完成初始化。在我们的发布者和订阅者代码中，我们创建了一个 `wait_for_services()`
    方法，确保只有在服务启动并准备好后，我们才尝试连接。
- en: We call `wait_for_services()` first thing in our publisher and subscriber programs
    to ensure we have waited just long enough for the dependent services to be up
    and ready.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在发布者和订阅者程序中首先调用 `wait_for_services()`，以确保我们等待足够长的时间，直到依赖服务启动并准备好。
- en: 'The `wait_for_services()` method in `publisher/`index.js is as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`publisher/`index.js 中的 `wait_for_services()` 方法如下：'
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Our `publisher` microservice only connects to the MQTT broker, so the `wait_for_services()`
    method only waits for our MQTT broker's TCP port to be accessible.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `publisher` 微服务仅连接到 MQTT 代理，因此 `wait_for_services()` 方法只等待我们的 MQTT 代理的 TCP
    端口可访问。
- en: 'The `wait_for_services()` method in `subscriber/`index.js is a bit more complicated:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriber/`index.js 中的 `wait_for_services()` 方法稍微复杂一些：'
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `subscriber` microservice needs to connect to the MQTT broker, the `redis`
    server, and the `mongo` server. We wait for the TCP ports of those servers to
    be accessible.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriber` 微服务需要连接到 MQTT 代理、`redis` 服务器和 `mongo` 服务器。我们等待这些服务器的 TCP 端口可访问。'
- en: There are other ways to wait for services to be available that involve installing
    command-line programs/scripts in the container and running them before starting
    our publisher or subscriber service. For example, you might use this handy wait-for-it.sh
    script, which can be found at [https://github.com/vishnubob/wait-for-it](https://github.com/vishnubob/wait-for-it).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他方法可以等待服务可用，其中包括在容器中安装命令行程序/脚本，并在启动发布者或订阅者服务之前运行它们。例如，您可以使用这个方便的 `wait-for-it.sh`
    脚本，详情请见 [https://github.com/vishnubob/wait-for-it](https://github.com/vishnubob/wait-for-it)。
- en: The lack of options in the `docker-compose.yml` file to expose container ports
    is not an oversight. We are fully able to specify those options in an override
    file that can provide options to existing containers.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在`docker-compose.yml`文件中没有暴露容器端口选项并非疏忽。我们完全可以在重写文件中指定这些选项，从而为现有容器提供选项。
- en: Adding port bindings using overrides
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用重写文件添加端口绑定
- en: 'In the `chapter4/` directory in the code repository, we have a `docker-compose-simple.yml`
    file that is an example of an override file:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码库中的`chapter4/`目录下，我们有一个`docker-compose-simple.yml`文件，它是一个重写文件的示例：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we specify the ports for each container. We are inheriting the options
    from our `docker-compose.yml` file and adding options to expose the ports for
    each of our containers.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了每个容器的端口。我们正在从`docker-compose.yml`文件中继承选项，并添加暴露每个容器端口的选项。
- en: We don't expose any ports for the `subscriber` microservice because it never
    exposes any ports to the host's ports.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有为`subscriber`微服务暴露任何端口，因为它从不将任何端口暴露到主机的端口。
- en: We also define three environment variables to be used by the publisher and subscriber
    containers to access the `MQTT_HOST` (`mosca`), `REDIS_HOST` (`redis`), and `MONGO_HOST`
    (`mongodb`) services.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还定义了三个环境变量，供发布者和订阅者容器访问`MQTT_HOST`（`mosca`）、`REDIS_HOST`（`redis`）和`MONGO_HOST`（`mongodb`）服务。
- en: 'The `docker-compose` command to bring up our services using the two configuration
    files (inheritance) is as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这两个配置文件（继承）的`docker-compose`命令来启动我们的服务，如下所示：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since we are not using the `-d` switch, our containers are not detached but
    print their console/debug output to the Terminal. You cannot enter more commands
    until you hit *Ctrl*+ *C*. Doing this will stop all the containers in reverse
    `depends_on` order and return you to Command Prompt:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有使用`-d`开关，我们的容器没有被分离，而是将其控制台/调试输出打印到终端。直到你按下*Ctrl*+*C*，你才能输入更多命令。这样做将按反向`depends_on`顺序停止所有容器，并将你带回命令提示符：
- en: '[PRE17]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Adding the `-d` switch causes all the containers to be started in daemon mode.
    They run in the background and you immediately get a command-line prompt. No further
    output is sent to the Terminal.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 添加`-d`开关会使所有容器以守护进程模式启动。它们在后台运行，你会立即得到一个命令行提示符。不会再有进一步的输出发送到终端。
- en: 'If containers are running in daemon mode, you can stop them using the `docker-compose
    down` command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果容器以守护进程模式运行，你可以使用`docker-compose down`命令来停止它们：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can use three or more configuration files as well. Each additional file specified
    on the command line further extends the containers and options specified within.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用三个或更多配置文件。每个在命令行中指定的附加文件都会进一步扩展容器和选项。
- en: What we have so far is effectively a production that is set up using inheritance.
    Debugging using this is particularly painful because your only means of diagnosing
    errors is to add `debug()` calls to the publisher and/or subscriber, then rebuilding
    the container(s), and then rerunning the whole application.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们实际上是通过继承设置的生产环境。使用这种方式调试特别痛苦，因为你诊断错误的唯一方法就是向发布者和/或订阅者添加`debug()`调用，然后重新构建容器，并重新运行整个应用程序。
- en: To improve our development and debugging cycles, we can bind/mount our `publisher/`
    and `subscriber/` directories to the `/home/app` directory in the containers.
    The Dockerfiles for both containers use the nodemon ([https://nodemon.io/](https://nodemon.io/))
    utility to start the application within the container.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善我们的开发和调试周期，我们可以将`publisher/`和`subscriber/`目录绑定/挂载到容器中的`/home/app`目录。两个容器的
    Dockerfile 使用 nodemon（[https://nodemon.io/](https://nodemon.io/)）工具来启动容器内的应用程序。
- en: 'The nodemon utility does a bit more than just starting our program:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: nodemon 工具做的事情远不止启动我们的程序：
- en: It also monitors the state of the program, and if it stops, nodemon will restart
    it.  This is useful because our Node.js programs might detect an error from which
    they cannot easily be recovered, so they just exit and allow nodemon to restart
    them.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它还会监控程序的状态，如果程序停止，nodemon 会重新启动它。这非常有用，因为我们的 Node.js 程序可能会遇到一些无法轻易恢复的错误，然后直接退出，让
    nodemon 重启它们。
- en: For development, nodemon also monitors the timestamps of the files in the code
    directory and will restart the program if any of the files change.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于开发，nodemon 还会监控代码目录中文件的时间戳，如果任何文件发生变化，它将重新启动程序。
- en: Since we can bind/mount our source code directly in the container, any changes
    we make to the files using our editor or IDE on the host will immediately affect
    the changes in the container.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们可以将源代码直接绑定/挂载到容器中，因此我们在主机上使用编辑器或 IDE 对文件进行的任何更改将立即影响容器中的变化。
- en: 'We can create a `docker-compose-simple-dev.yml` file, which adds our bind/mounts
    to publisher and subscriber:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建一个 `docker-compose-simple-dev.yml` 文件，将我们的绑定/挂载添加到发布者和订阅者：
- en: '[PRE19]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We run this using the `docker-compose up` command:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `docker-compose up` 命令来运行此命令：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we edit, say, the `publisher/`index.js file on the host, we can see that
    nodemon sees the change and restarts the publisher program:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在主机上编辑，比如 `publisher/`index.js 文件，我们可以看到 nodemon 检测到更改并重新启动发布者程序：
- en: '[PRE21]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We now have a good handle on `docker-compose`, but we are binding ports from
    our containers to the host's ports. This is problematic if you have a container
    that wants to bind to port `80` on the host but the host is running a web server
    or another container for another project that also wants to bind to port `80`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经很好地掌握了 `docker-compose`，但是我们正在将容器的端口绑定到主机的端口。如果你有一个容器需要绑定主机的 `80` 端口，而主机上已经在运行一个
    Web 服务器或另一个项目的容器，也想绑定到 `80` 端口，那么这会带来问题。
- en: Fortunately, Docker provides a facility to only expose our ports to our containers!
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Docker 提供了一种功能，只将我们的端口暴露给我们的容器！
- en: Using Docker local networking
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 本地网络
- en: Both Docker and Docker Compose have command-line options to specify a Docker
    local network that the application will use. Using this Docker local network allows
    our containers to access another container's ports without having to bind/expose
    these ports to the host's ports.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和 Docker Compose 都有命令行选项来指定应用将使用的 Docker 本地网络。使用该 Docker 本地网络可以让我们的容器访问另一个容器的端口，而无需将这些端口绑定/暴露到主机的端口上。
- en: Networking using .sh scripts
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 .sh 脚本进行网络配置
- en: 'You use the `docker network create` command to create a named network that
    your containers can use to privately communicate with one another. You can have
    as many of these private networks defined as you like—you might want to work on
    multiple unrelated projects simultaneously and each needs its own network:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `docker network create` 命令来创建一个命名网络，供你的容器彼此私密通信。你可以定义任意数量的这些私有网络——你可能希望同时处理多个不相关的项目，每个项目都需要自己的网络：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This command creates a network named `chapter4` that we can use for our microservices
    example programs. We can destroy networks we have created using the `docker network
    rm` command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令创建了一个名为 `chapter4` 的网络，我们可以在微服务示例程序中使用它。我们可以使用 `docker network rm` 命令销毁我们创建的网络：
- en: '[PRE23]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This command removes our `chapter4` network from the system.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令将 `chapter4` 网络从系统中移除。
- en: The start-mongodb.sh, start-redis.sh, start-mosca.sh, `publisher/`run.sh, and
    `subscriber/`run.sh scripts are used by the up.sh script to bring up our application's
    containers using the `docker run` command.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: start-mongodb.sh、start-redis.sh、start-mosca.sh、`publisher/`run.sh 和 `subscriber/`run.sh
    脚本被 up.sh 脚本用来通过 `docker run` 命令启动我们的应用容器。
- en: 'Let''s examine our up.sh script:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的 up.sh 脚本：
- en: '[PRE24]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We run the `docker network create` command to create our `chapter4` network:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们运行 `docker network create` 命令来创建我们的 `chapter4` 网络：
- en: '[PRE25]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We start our three servers:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动我们的三台服务器：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We also run `./`start-redis.sh:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还运行 `./`start-redis.sh：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Finally, we start the publisher:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们启动发布者：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The start-mongodb.sh and start-redis.sh scripts are roughly the same as the
    start-mosca.sh script. The relevant lines in the start-mosca.sh script are the
    ones for the `docker run` command:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: start-mongodb.sh 和 start-redis.sh 脚本大致与 start-mosca.sh 脚本相同。start-mosca.sh 脚本中的相关行是用于
    `docker run` 命令的：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Only the service name, which third-party/Docker Hub container to use, and any
    container to host directory bindings are specific to `mongodb`, `mosca`, or `redis`.
    They all share the `chapter4` network.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 只有服务名称、要使用的第三方/Docker Hub 容器以及任何容器到主机目录的绑定是特定于 `mongodb`、`mosca` 或 `redis` 的。它们都共享
    `chapter4` 网络。
- en: 'The `docker run` command in the `subscriber/`run.sh script looks as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriber/`run.sh 脚本中的 `docker run` 命令如下所示：'
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: We are no longer defining the `HOSTIP` environment variable because the Docker
    local networking system provides a DNS function that allows the programs in our
    containers to look up the other containers by name. The name is the name of the
    container, which is specified in the `docker run` commands scripts with the `–name`
    command-line option.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再定义 `HOSTIP` 环境变量，因为 Docker 本地网络系统提供了一个 DNS 功能，允许容器中的程序通过名称查找其他容器。这个名称就是容器的名称，它是在
    `docker run` 命令脚本中通过 `–name` 命令行选项指定的。
- en: 'The relevant lines in `subscriber/`index.js are as follows:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscriber/`index.js中的相关代码如下：'
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The code is designed to accept the `MONGO_HOST` environment variable; otherwise,
    it will use the `mongodb` container name. The same is the case for `MQTT_HOST`/`mosca`
    and `REDIS_HOST`/`redis`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设计接受`MONGO_HOST`环境变量；否则，它将使用`mongodb`容器名称。`MQTT_HOST`/`mosca`和`REDIS_HOST`/`redis`也是同样的情况。
- en: Note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We have been defining the `HOSTIP`, `MONGO_HOST`, `MQTT_HOST`, and `REDIS_HOST`
    environment variables, especially in the `.sh` script examples. Since we've been
    naming our containers using the `--name` switch on our `docker run` commands,
    Docker's local DNS will work with `.sh` scripts. That is, we don't need to define
    those environment variables if we name our containers. We still need to bind container
    ports to the host's ports, unless we also add the `--network` switch and `docker
    network create` to the Docker local network.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在定义`HOSTIP`、`MONGO_HOST`、`MQTT_HOST`和`REDIS_HOST`环境变量，特别是在`.sh`脚本示例中。由于我们使用`--name`选项在`docker
    run`命令中为容器命名，Docker的本地DNS将在`.sh`脚本中工作。也就是说，如果我们给容器命名，就不需要定义这些环境变量。我们仍然需要将容器端口绑定到主机端口，除非我们还添加`--network`选项和`docker
    network create`到Docker本地网络。
- en: 'The down.sh script stops all the containers and removes the `chapter4` network:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: down.sh脚本停止所有容器并移除`chapter4`网络：
- en: '[PRE32]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We can use these `.sh` scripts, but we've already learned that Docker Compose
    is the superior method for managing our microservices.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用这些`.sh`脚本，但我们已经了解到，Docker Compose是管理微服务的更优方法。
- en: Networking with Docker Compose
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用Docker Compose进行网络配置
- en: The `docker-compose.yml` configuration file that we created is still enough
    to use as the base for using the `docker-compose` commands to manage our containers.  However,
    we no longer need to expose or bind container ports to the host's ports; the only
    exception is we'll continue to bind port `3000` so that we can access the publisher
    web pages using our browser on the host. The base `docker-compose.yml` file does
    not bind port `3000`, so we will continue to bind ports using the override file.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`docker-compose.yml`配置文件仍然足够用作执行`docker-compose`命令来管理容器的基础。然而，我们不再需要将容器端口暴露或绑定到主机的端口；唯一的例外是，我们会继续绑定端口`3000`，以便可以通过主机上的浏览器访问发布者网页。基础的`docker-compose.yml`文件并没有绑定端口`3000`，因此我们将继续使用覆盖文件来绑定端口。
- en: By default, if you specify no configuration files on the command line, `docker-compose`
    looks for `docker-compose.yml` and uses it, and then looks for `docker-compose.override.yml`
    and uses that.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果命令行中没有指定配置文件，`docker-compose`会查找`docker-compose.yml`并使用它，然后查找`docker-compose.override.yml`并使用它。
- en: If you need to specify a third configuration file, you must use the `-f` command-line
    switch for each configuration file.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要指定第三个配置文件，必须为每个配置文件使用`-f`命令行选项。
- en: 'Our `docker-compose.override.yml` file handles our production case:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`docker-compose.override.yml`文件处理我们的生产场景：
- en: '[PRE33]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This file adds the `chapter4` network, assigns it to each of the containers,
    and binds port `3000` in the publisher container to port `3000` on the host.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件添加了`chapter4`网络，将其分配给每个容器，并将发布者容器的端口`3000`绑定到主机上的端口`3000`。
- en: 'All we need to do to use `docker-compose.yml` and `docker-compose.override.yml`
    is run a simple `docker-compose` command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是运行一个简单的`docker-compose`命令来使用`docker-compose.yml`和`docker-compose.override.yml`：
- en: '[PRE34]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'After a few seconds, our five containers are up and running and we can access
    the application with our browser on the host. We can see it is all working. We
    can also do the following:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 几秒钟后，我们的五个容器已经启动并运行，我们可以通过主机上的浏览器访问应用程序。我们可以看到一切正常工作。我们还可以执行以下操作：
- en: Use the `-d` switch to run the containers in detached/daemon mode.
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`-d`选项以分离/守护进程模式运行容器。
- en: Use `docker-compose` to stop and start any one or more containers.
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker-compose`停止和启动一个或多个容器。
- en: Use `docker-compose` to build any one or more containers.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker-compose`构建一个或多个容器。
- en: Use `docker-compose logs` to show the logs of any of our containers running
    in daemon mode.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`docker-compose logs`查看运行在守护进程模式下的任何容器的日志。
- en: What we now have is a pair of configuration files that work for production mode.
    We now need a way to work in development mode by binding our source code to the
    container's home directory.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有一对适用于生产模式的配置文件。接下来，我们需要一种在开发模式下工作的方式，通过将源代码绑定到容器的主目录。
- en: Binding a host filesystem within containers
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内绑定主机文件系统
- en: Previously, we used a third `docker-compose` configuration file to specify bindings
    so that our source code directory would be overlaid within the container (in place
    of the app's home directory). We will do the same for the latest incarnation of
    our Docker Compose setup.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们使用了第三个 `docker-compose` 配置文件来指定绑定，以便将源代码目录映射到容器内（替换应用的主目录）。我们将为最新版本的 Docker
    Compose 设置做同样的事情。
- en: 'We first create a `docker-compose-dev.yml` file:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个 `docker-compose-dev.yml` 文件：
- en: '[PRE35]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This override file simply maps the publisher and subscriber source code directory
    over `/home/app` in the related container. Now, we can freely edit sources on
    the host and, thanks to nodemon, our changes will take effect almost immediately
    within the running containers. There is no need to stop, rebuild, or restart any
    containers.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个重载文件只是将发布者和订阅者源代码目录映射到相关容器中的 `/home/app`。现在，我们可以自由地在主机上编辑源代码，且得益于 nodemon，我们的更改几乎能立即在运行中的容器内生效。无需停止、重建或重启任何容器。
- en: Unfortunately, `docker-compose` has no facility to remove options using inheritance;
    we can only modify existing ones or add new ones. If we could remove options,
    we would bind the source in our `docker-compose.override.yml` file and remove
    them in a `docker-compose-production.yml` file. This would allow us to use the
    short `docker-compose up` form for development and to use a command line with
    three `-f` switches for production. This would be handy because we would use development
    most of the time and rarely use production.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`docker-compose` 没有提供通过继承移除选项的功能；我们只能修改现有选项或添加新选项。如果可以移除选项，我们可以在 `docker-compose.override.yml`
    文件中绑定源代码，并在 `docker-compose-production.yml` 文件中移除它们。这将使我们能够在开发时使用简短的 `docker-compose
    up` 命令，并在生产环境中使用带有三个 `-f` 开关的命令行。这将很方便，因为我们大部分时间都使用开发模式，而很少使用生产模式。
- en: 'As it is, we must specify the three `-f` switches:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 按目前的情况，我们必须指定三个 `-f` 开关：
- en: '[PRE36]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: There are other uses for volumes, which we will explore.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 卷还有其他用途，我们将进一步探索。
- en: Optimizing our container size
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化我们的容器大小
- en: 'We can examine our container images using the `docker images` command:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `docker images` 命令查看我们的容器镜像：
- en: '[PRE37]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As you can see, our publisher image is `987` megabytes! All that for an almost-250-line
    JavaScript program. We can try to shrink this size by moving our `node_modules`
    directory out of the container and into a named volume. This will also speed up
    the building of our container since `node_modules` will be persisted in this named
    volume from build to build, and using the `yarn` command to install the modules
    will only install anything that is new.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们的发布者镜像是 `987` 兆字节！这只是一个几乎 250 行的 JavaScript 程序。我们可以尝试通过将 `node_modules`
    目录移出容器并放入一个命名卷中来缩小这个大小。这还可以加速容器的构建，因为 `node_modules` 会在这个命名卷中从构建到构建地被保存，并且使用 `yarn`
    命令安装模块时，只会安装新的模块。
- en: Note
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We renamed the Dockerfile to `Dockerfile.chapter3` in the `publisher/` directory.  The
    new Dockerfile has been modified to build a very small image.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 Dockerfile 重命名为 `Dockerfile.chapter3`，并放置在 `publisher/` 目录下。新 Dockerfile
    已被修改为构建一个非常小的镜像。
- en: A smaller image can be created by optimizing our Dockerfile. What we're going
    to do is build a base image and our result image. The base image will have `node_modules`
    installed.  The base image is only rebuilt when something changes that requires
    one of its layers to be rebuilt.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 通过优化我们的 Dockerfile，可以创建一个更小的镜像。我们将构建一个基础镜像和我们的结果镜像。基础镜像将安装 `node_modules`。只有当某些内容发生变化并需要重新构建其层时，基础镜像才会重新构建。
- en: 'Let''s look at an optimized Dockerfile for the publisher:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下发布者的优化 Dockerfile：
- en: '[PRE38]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We inherit from the alpine OS node v12 image. This image is much lighter than
    the Debian flavor default node container:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 Alpine OS 的 Node v12 镜像继承。这个镜像比 Debian 风味的默认 Node 容器要轻得多：
- en: '[PRE39]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The resulting image is built without installing or updating `node_modules`.
    We will install the modules in another step. This saves us from having to use
    `yarn` install every time we build our container:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的镜像在构建时不会安装或更新 `node_modules`。我们将在另一个步骤中安装这些模块。这使我们避免了每次构建容器时都需要使用 `yarn`
    安装模块：
- en: '[PRE40]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use `yarn start` to launch our publisher app.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `yarn start` 启动我们的发布应用。
- en: After we run `docker-compose build publisher`, we can see we have greatly reduced
    the size of our container!
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行 `docker-compose build publisher` 后，我们可以看到容器的大小大大减少了！
- en: 'Before our optimizations, the container was `987` megabytes. After the optimizations,
    `89.5` megabytes, which is almost a 900-megabyte reduction:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在优化之前，容器大小为 `987` 兆字节。优化后，容器为 `89.5` 兆字节，几乎减少了 900 兆字节：
- en: '[PRE41]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We still need to install our `node_modules/` modules, which will be done within
    a named volume and defined in the `docker-compose-overrides.yml` file. This is
    done once, and then again only if you add packages to the `packages.json` file
    in the `publisher/` directory:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们仍然需要安装我们的 `node_modules/` 模块，这将在一个命名卷中完成，并在 `docker-compose-overrides.yml`
    文件中定义。只需完成一次，之后如果你向 `publisher/` 目录下的 `packages.json` 文件添加包，则需要重新执行：
- en: '[PRE42]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This command installs the `node_modules/` packages using `yarn install` within
    the publisher container. The named volume is mounted correctly because it is specified
    within the `docker-compose` configuration (`.yml`) files.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令在发布者容器内使用 `yarn install` 安装 `node_modules/` 包。命名卷被正确挂载，因为它在 `docker-compose`
    配置（`.yml`）文件中指定。
- en: Note
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We did not optimize the subscriber build.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有优化订阅者的构建。
- en: 'We can verify that the volume was created and does contain the installed `node_modules`
    modules by examining the `_data` directory of our volume, which on Linux should
    be in `/var/lib/docker/volumes`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查卷的 `_data` 目录来验证卷是否已创建并包含已安装的 `node_modules` 模块，在 Linux 上该目录应位于 `/var/lib/docker/volumes`：
- en: '[PRE43]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The location of the volumes is significantly different for macOS.  You will
    need to use the following command to get a shell in the Linux virtual machine
    that is running Docker:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 macOS，卷的位置有显著不同。你需要使用以下命令获取运行 Docker 的 Linux 虚拟机中的 shell：
- en: '[PRE44]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: You might have to hit `^C` a few times to get a shell prompt. This prompt is
    a shell running in the virtual machine. Within the virtual machine, the volume
    for the `node_modules/` directory in the container is at `/var/lib/docker/volumes`,
    as with Docker on Linux.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能需要按 `^C` 几次才能得到 shell 提示符。这个提示符是在虚拟机中运行的 shell。在虚拟机内，容器中 `node_modules/`
    目录的挂载点是 `/var/lib/docker/volumes`，就像在 Linux 上的 Docker 一样。
- en: 'We can see the speedup of our build. The initial build of the publisher, after
    completely removing all of the images from the system, takes around 16 seconds:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到构建的加速效果。在完全删除系统中所有镜像后，发布者的初始构建大约需要 16 秒：
- en: '[PRE45]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'A subsequent build without `node_modules` installed takes around a half a second:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有安装 `node_modules`，随后的构建大约需要半秒钟：
- en: '[PRE46]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'After editing index.js and doing a rebuild, it takes less than 1 second:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑 index.js 并重新构建后，时间不到 1 秒：
- en: '[PRE47]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: As you can see, we were able to reduce the size and build time of our containers!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们成功地减少了容器的大小和构建时间！
- en: Using the build.sh script
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 build.sh 脚本
- en: 'There is a build.sh script provided in the `chapter4/` directory of the GitHub
    repository. It just contains a few lines of actual shell commands:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 仓库的 `chapter4/` 目录中提供了一个 build.sh 脚本。它仅包含几行实际的 shell 命令：
- en: '[PRE48]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'The build.sh script builds all five containers and runs `yarn install` in both
    the publisher and subscriber containers to install the `node_modules` modules
    in their respective named volumes. The command-line switches to the `docker-compose
    build` command are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: build.sh 脚本构建了所有五个容器，并在发布者和订阅者容器中运行 `yarn install`，以便在各自的命名卷中安装 `node_modules`
    模块。命令行开关切换到 `docker-compose build` 命令如下：
- en: '`--force-rm`: Forces Docker to remove all the intermediate container images
    as it builds'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--force-rm`：强制 Docker 在构建过程中移除所有中间容器镜像'
- en: '`--no-cache`: Forces Docker to use no cached/downloaded/built versions of anything'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`--no-cache`：强制 Docker 不使用任何缓存的/已下载的/已构建的版本'
- en: You can drop these two switches to greatly improve the build speed. They are
    provided here to demonstrate a way of forcibly rebuilding everything from scratch.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以省略这两个开关，显著提高构建速度。它们在此提供，目的是演示一种从头强制重建所有内容的方法。
- en: That's a decent overview of Docker Compose. It is one of the first, if not the
    first, composition tools for describing, building, and running Docker applications.
    But there are also other alternatives out there.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 Docker Compose 的一个不错的概述。它是描述、构建和运行 Docker 应用程序的第一个工具之一，甚至可能是第一个。但是，市场上也有其他的替代工具。
- en: Other composition tools
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他组合工具
- en: We have already seen how we can compose and build a multiple service application
    using `docker-compose` and `.sh` scripts. But there are some other options that
    you may want to consider.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何使用 `docker-compose` 和 `.sh` 脚本来组合并构建一个多服务应用程序。但还有其他一些你可能想要考虑的选项。
- en: Docker Swarm
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker Swarm
- en: Docker Swarm is a cluster management system. It allows you to deploy containers
    that are defined with `docker-compose` to a cluster of nodes or servers. There
    are some limitations to what you can do with `docker-compose.yml` if you want
    to use Docker Swarm. For example, you cannot use volumes with Docker Swarm, and
    binding container ports to the host should be carefully planned.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Docker Swarm 是一个集群管理系统。它允许你将通过 `docker-compose` 定义的容器部署到一组节点或服务器上。如果你想使用 Docker
    Swarm，`docker-compose.yml` 的使用有一些限制。例如，你不能在 Docker Swarm 中使用卷，并且绑定容器端口到主机时需要仔细规划。
- en: Kubernetes
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kubernetes
- en: Kubernetes is a feature-rich alternative to `docker-compose`. It allows containers
    to be deployed to a cluster of Docker container servers and uses a configuration
    file format similar to `docker-compose.yml`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 是 `docker-compose` 的一种功能丰富的替代方案。它允许将容器部署到一组 Docker 容器服务器上，并使用类似于
    `docker-compose.yml` 的配置文件格式。
- en: Packer
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Packer
- en: 'Packer is a tool that generates several output formats, including Docker containers.
    You define your containers using JSON files and the tool reads from them. Packer
    uses builders to generate output files. The output can be (but is not limited
    to) the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Packer 是一个生成多种输出格式的工具，包括 Docker 容器。你通过 JSON 文件定义容器，并且该工具从这些文件中读取。Packer 使用构建器来生成输出文件。输出可以是（但不限于）以下内容：
- en: Azure machine images
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 虚拟机镜像
- en: DigitalOcean machine images
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DigitalOcean 虚拟机镜像
- en: Docker container images
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 容器镜像
- en: Google cloud images
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google 云镜像
- en: Parallels (for macOS) images
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Parallels（用于 macOS）镜像
- en: VirtualBox images
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VirtualBox 镜像
- en: VMware images
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: VMware 镜像
- en: The composition tool that you choose should make your job easier. Be sure to
    choose one that truly suits your needs. Docker Compose is the official Docker
    composition tool. The others may be more modern and solve additional problems
    that Docker Compose does not.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 你选择的编排工具应该使你的工作更轻松。务必选择一个真正适合你需求的工具。Docker Compose 是官方的 Docker 编排工具，其他工具可能更加现代，并解决
    Docker Compose 无法解决的附加问题。
- en: Summary
  id: totrans-252
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced Docker Compose as a superior management tool
    for managing and running a complex system of containers. We described several
    useful `docker-compose` configuration file options that allow us to specify ports
    to expose, local networking, and local volumes. We exploited the `docker-compose`
    tool's inheritance capabilities as well.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Docker Compose 作为管理和运行复杂容器系统的优越管理工具。我们描述了几个有用的 `docker-compose` 配置文件选项，使我们能够指定需要暴露的端口、本地网络和本地卷。我们还利用了
    `docker-compose` 工具的继承能力。
- en: A critical part of using Docker is the development cycle. We typically edit,
    build, run, and test each cycle—then repeat. The size of images, as well as the
    time spent building, publishing, and downloading them, can be strategically reduced.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Docker 的关键部分是开发周期。我们通常在每个周期中编辑、构建、运行和测试——然后重复。可以通过策略性地减少镜像的大小，以及构建、发布和下载镜像的时间，来优化开发过程。
- en: We also explored some alternatives to using `.sh` scripts and `docker-compose`.
    These are a natural next step in your Docker education as they provide facilities
    for deploying your orchestrations to swarms or clusters of servers in production
    or for testing.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了使用 `.sh` 脚本和 `docker-compose` 的一些替代方案。这些是你 Docker 学习过程中自然而然的下一步，因为它们提供了将你的编排部署到生产或测试中服务器群集的功能。
- en: The next few chapters go into detail about how to deploy your applications and
    how to implement continuous integration and automated testing. After that, we
    will cover security considerations for containerized applications.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几章将详细介绍如何部署应用程序以及如何实现持续集成和自动化测试。之后，我们将讨论容器化应用程序的安全性考虑。
- en: Further reading
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can refer to the following URLs for more information on the topics covered
    in this chapter:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以参考以下网址，获取本章所涉及主题的更多信息：
- en: 'The official Docker documentation: [https://docs.docker.com](https://docs.docker.com)'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Docker 文档：[https://docs.docker.com](https://docs.docker.com)
- en: 'The official Docker Compose documentation: [https://docs.docker.com/compose/](https://docs.docker.com/compose/)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方 Docker Compose 文档：[https://docs.docker.com/compose/](https://docs.docker.com/compose/)
- en: The Dockerfile reference:[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile 参考：[https://docs.docker.com/engine/reference/builder/](https://docs.docker.com/engine/reference/builder/)
- en: The Docker Hub site:[https://hub.docker.com/](https://hub.docker.com/)
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub 网站：[https://hub.docker.com/](https://hub.docker.com/)
- en: The documentation for Docker Hub:[https://docs.docker.com/docker-hub/](https://docs.docker.com/docker-hub/)
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Hub 文档：[https://docs.docker.com/docker-hub/](https://docs.docker.com/docker-hub/)
- en: The documentation for the `Node.js` containers on Docker Hub:[https://hub.docker.com/_/node](https://hub.docker.com/_/node)
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Node.js` 容器的文档在 Docker Hub：[https://hub.docker.com/_/node](https://hub.docker.com/_/node)'
- en: The documentation for the Redis containers on Docker Hub:[https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis 容器的文档在 Docker Hub：[https://hub.docker.com/_/redis](https://hub.docker.com/_/redis)
- en: The documentation for the MongoDB containers on Docker Hub:[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB 容器的文档在 Docker Hub：[https://hub.docker.com/_/mongo](https://hub.docker.com/_/mongo)
- en: The documentation for the Mosca containers on Docker Hub:[https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca)
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mosca 容器的文档在 Docker Hub：[https://hub.docker.com/r/matteocollina/mosca](https://hub.docker.com/r/matteocollina/mosca)
