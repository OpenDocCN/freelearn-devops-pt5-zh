- en: Chapter 2. Optimizing Docker Images
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：优化 Docker 镜像
- en: Now that we have built and deployed our Docker containers, we can start reaping
    the benefits of using them. We have a standard package format that lets developers
    and sysadmins work together to simplify the management of our application's code.
    Docker's container format allows us to rapidly iterate the versions of our application
    and share it with the rest of our organization. Our development, testing, and
    deployment time has decreased because of the lightweight feature and speed of
    Docker containers. The portability of Docker containers allows us to scale our
    applications from physical servers to virtual machines in the cloud.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经构建并部署了 Docker 容器，可以开始享受使用它们的好处。我们拥有一个标准的软件包格式，允许开发人员和系统管理员合作，简化我们应用程序代码的管理。Docker
    的容器格式使我们能够快速迭代应用程序的版本，并与组织中的其他成员共享。由于 Docker 容器的轻量级特性和速度，我们的开发、测试和部署时间都大大减少。Docker
    容器的可移植性使我们能够将应用程序从物理服务器扩展到云中的虚拟机。
- en: However, we will start noticing that the same reasons for which we used Docker
    in the first place are losing their effect. Development time is increasing because
    we have to always download the newest version of our application's Docker image
    runtime library. Deployment takes a lot of time because Docker Hub is slow. At
    worst, Docker Hub may be down, and we would not be able to do any deployment at
    all. Our Docker images are now so big, in the order of gigabytes, that simple
    single-line updates take the whole day.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将开始注意到，最初使用 Docker 的原因正失去其效力。开发时间增加，因为我们必须每次都下载应用程序最新版本的 Docker 镜像运行时库。部署花费大量时间，因为
    Docker Hub 很慢。最糟糕的是，Docker Hub 可能会宕机，我们根本无法进行任何部署。我们的 Docker 镜像现在变得非常大，达到几个 GB，简单的一行更新也需要整整一天。
- en: 'This chapter will cover the following scenarios of how Docker containers get
    out of hand and suggest steps to remediate the problems mentioned earlier:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下几种情况，说明 Docker 容器如何失控，并提出前面提到的问题的解决步骤：
- en: Reducing image deployment time
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少镜像部署时间
- en: Reducing image build time
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少镜像构建时间
- en: Reducing image size
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少镜像大小
- en: Reducing deployment time
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少部署时间
- en: 'As time goes by while we build our Docker container, its size gets bigger and
    bigger. Updating running containers in our existing Docker hosts is not a problem.
    Docker takes advantage of the Docker image layers that we build over time as our
    application grows. However, consider a case in which we want to scale out our
    application. This requires deploying more Docker containers to additional Docker
    hosts. Each new Docker host has to then download all the large image layers that
    we built over time. This section will show you how a *large* Docker application
    affects deployment time on new Docker hosts. First, let''s build this problematic
    Docker application by carrying out the following steps:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 随着构建 Docker 容器的时间推移，它的大小越来越大。更新我们现有 Docker 主机上的运行容器并不成问题。Docker 利用我们随着应用程序增长而逐步构建的
    Docker 镜像层。然而，假设我们想要扩展应用程序。这就需要在额外的 Docker 主机上部署更多的 Docker 容器。每个新的 Docker 主机都必须下载我们随着时间推移构建的所有大镜像层。本节将展示一个
    *大型* Docker 应用程序如何影响新 Docker 主机上的部署时间。首先，按照以下步骤构建这个问题 Docker 应用程序：
- en: 'Write the following `Dockerfile` to create our "large" Docker image:'
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写以下 `Dockerfile` 来创建我们的 "大型" Docker 镜像：
- en: '[PRE0]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, build the `Dockerfile` as `hubuser/largeapp` using the following command:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令构建 `Dockerfile` 为 `hubuser/largeapp`：
- en: '[PRE1]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Take note of how large the created Docker image is. In the following illustrated
    output, the size is `662 MB`:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意记录创建的 Docker 镜像的大小。在下面的输出示例中，大小为 `662 MB`：
- en: '[PRE2]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Using the `time` command, record how long it takes to push and pull it from
    Docker Hub, as follows:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `time` 命令，记录从 Docker Hub 推送和拉取的时间，如下所示：
- en: '[PRE3]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: As we can note in the preceding time values highlighted, it takes a lot of time
    when we perform `docker push` to upload an image to Docker Hub. Upon deployment,
    `docker pull` takes just as long in order to propagate our newly created Docker
    image to our new production Docker hosts. These upload and download time values
    also depend on the network connection between Docker Hub and our Docker hosts.
    Ultimately, when Docker Hub goes down, we will lose the ability to deploy new
    Docker containers or scale out to additional Docker hosts on demand.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前面突出显示的时间值所看到的，执行 `docker push` 将镜像上传到 Docker Hub 时需要花费大量时间。部署时，`docker
    pull` 也需要同样长的时间来将我们新创建的 Docker 镜像传播到新的生产 Docker 主机。这些上传和下载的时间值还取决于 Docker Hub
    与我们的 Docker 主机之间的网络连接。最终，当 Docker Hub 出现故障时，我们将失去部署新的 Docker 容器或按需扩展到更多 Docker
    主机的能力。
- en: 'In order to take advantage of Docker''s fast delivery of applications and ease
    of deployment and scaling, it is important that our method of pushing and pulling
    Docker images is reliable and fast. Fortunately, we can run our own Docker registry
    to be able to host and distribute our Docker images without relying on the public
    Docker Hub. The next few steps describe how to set this up to confirm the improvement
    in performance:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用 Docker 快速交付应用程序、简化部署和扩展的优势，我们推送和拉取 Docker 镜像的方法必须可靠且快速。幸运的是，我们可以运行自己的 Docker
    注册中心，能够托管和分发 Docker 镜像，而无需依赖公共 Docker Hub。接下来的几步将描述如何设置这一过程，以确认性能的提升：
- en: 'Let''s run our own Docker registry by typing the following command. This gives
    us a local one running at `tcp://dockerhost:5000`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过输入以下命令来运行我们自己的 Docker 注册中心。这将使我们在 `tcp://dockerhost:5000` 上运行本地注册中心：
- en: '[PRE4]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, let''s confirm how our Docker image deployments have improved. First,
    create a tag for the image we created earlier in order to push it to the local
    Docker registry via the following:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们确认 Docker 镜像部署的改进。首先，为之前创建的镜像创建一个标签，以便通过以下命令将其推送到本地 Docker 注册中心：
- en: '[PRE5]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Observe how much faster it is to push the same Docker image over our newly
    running Docker registry. The following tests show that pushing Docker images is
    now at least 10 times faster:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察通过我们新运行的 Docker 注册中心推送相同 Docker 镜像时有多快。以下测试表明，推送 Docker 镜像的速度现在至少提高了 10 倍：
- en: '[PRE6]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, confirm the new performance of the pulling of our Docker images before
    testing that of the pulling of images from our local Docker registry. Let''s make
    sure we remove the image we built earlier. The following tests show that the downloading
    of Docker images is now 30 times faster:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在测试从本地 Docker 注册中心拉取镜像之前，先确认我们 Docker 镜像拉取的新性能。我们先确保删除之前构建的镜像。以下测试表明，Docker
    镜像的下载速度现在提高了 30 倍：
- en: '[PRE7]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The main cause of these improvements is that we uploaded and downloaded the
    same images from our local network. We saved on the bandwidth of our Docker hosts,
    and our deployment time got shorter. The best part of all is that we no longer
    have to rely on the availability of Docker Hub in order to deploy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些改进的主要原因是我们从本地网络上传和下载了相同的镜像。我们节省了 Docker 主机的带宽，部署时间也缩短了。最重要的是，我们不再需要依赖 Docker
    Hub 的可用性来进行部署。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In order to deploy our Docker images to other Docker hosts, we need to set up
    security for our Docker registry. Details on how to set this up are outside the
    scope of this book. However, more details on how to set up a Docker registry are
    available at [https://docs.docker.com/registry/deploying](https://docs.docker.com/registry/deploying).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Docker 镜像部署到其他 Docker 主机，我们需要为 Docker 注册中心设置安全性。本书的范围之外会涉及如何设置 Docker 注册中心的细节。然而，更多关于如何设置
    Docker 注册中心的信息可以在 [https://docs.docker.com/registry/deploying](https://docs.docker.com/registry/deploying)
    获取。
- en: Improving image build time
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 改善镜像构建时间
- en: Docker images are the main resulting artifacts that developers work on all the
    time. The simplicity of Docker files and speed of container technology allows
    us to enable rapid iteration on the application that we are working on. However,
    these advantages of using Docker start to diminish once the time it takes to build
    Docker images starts to grow uncontrollably. In this section, we will discuss
    some cases of building Docker images that take some time to run. Then, we will
    give you a few tips on how to remediate these effects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 镜像是开发人员一直在处理的主要成果物。Docker 文件的简单性和容器技术的速度使我们能够对正在开发的应用程序进行快速迭代。然而，一旦构建
    Docker 镜像所需的时间开始失控，这些 Docker 的优势就会开始减弱。在本节中，我们将讨论一些构建 Docker 镜像需要较长时间的案例，然后我们将给出一些提升这些效果的建议。
- en: Using registry mirrors
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用镜像仓库
- en: 'A big contributor to image build time is the time spent in fetching upstream
    images. Suppose we have a `Dockerfile` with the following line:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像构建时间的一个大因素是获取上游镜像所花费的时间。假设我们有一个 `Dockerfile`，其中有以下一行：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This image will have to download `java:8u45-jre` to be built. When we move to
    another Docker host, or if the `java:8u45-jre` image is updated in Docker Hub,
    our build time will increase momentarily. Configuring a local registry mirror
    will reduce such image build time instances. This is very useful in an organization
    setting, where each developer has his/her own Docker hosts at their workstations.
    The organization's network only downloads the image from Docker Hub once. Each
    workstation Docker host in the organization can now directly fetch the images
    from the local registry mirror.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该镜像需要下载 `java:8u45-jre` 以进行构建。当我们迁移到另一个 Docker 主机，或当 `java:8u45-jre` 镜像在 Docker
    Hub 上更新时，我们的构建时间会暂时增加。配置本地注册表镜像可以减少这种镜像构建时间的情况。这在组织环境中非常有用，每个开发人员在其工作站上都有自己的 Docker
    主机。组织的网络只需从 Docker Hub 下载一次镜像。现在，组织中每个工作站的 Docker 主机都可以直接从本地注册表镜像获取镜像。
- en: 'Setting up a registry mirror is as simple as setting up a local registry in
    the previous section. However, in addition, we need to configure the Docker host
    to be aware of this registry mirror by passing the `--registry-mirror` option
    to the Docker daemon. Here are the steps to perform this setup:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 设置一个注册表镜像就像在前一节中设置本地注册表一样简单。然而，除此之外，我们还需要配置 Docker 主机，使其能够识别这个注册表镜像，通过向 Docker
    守护进程传递 `--registry-mirror` 选项来完成。以下是进行此设置的步骤：
- en: 'In our Debian Jessie Docker host, configure the Docker daemon by updating and
    creating a Systemd drop-in file at `/etc/systemd/system/docker.service.d/10-syslog.conf
    to contain the following line`:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Debian Jessie Docker 主机上，通过更新并创建一个位于 `/etc/systemd/system/docker.service.d/10-syslog.conf`
    的 Systemd drop-in 文件，配置 Docker 守护进程，该文件应包含以下行：
- en: '[PRE9]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we will reload Systemd to pick up the new drop-in configuration for the
    `docker.service` unit, as follows:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将重新加载 Systemd，以便加载 `docker.service` 单元的新 drop-in 配置，如下所示：
- en: '[PRE10]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, restart the Docker daemon to start it with the newly configured Systemd
    unit via the following command:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，重启 Docker 守护进程，以通过以下命令启动它并加载新的 Systemd 单元：
- en: '[PRE11]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, run the registry mirror Docker container. Run the following command:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行注册表镜像 Docker 容器。运行以下命令：
- en: '[PRE12]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To confirm that the registry mirror works as expected, perform the following
    steps:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确认注册表镜像按预期工作，请执行以下步骤：
- en: 'Build the `Dockerfile` described at the start of this subsection and take note
    of its build time. Note that most of the time needed to build the Docker image
    is taken up by the time to download the upstream `java:8u45-jre` Docker image,
    as shown in the following command:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建开头部分所描述的 `Dockerfile` 并注意它的构建时间。请注意，构建 Docker 镜像所需的大部分时间都花在了下载上游 `java:8u45-jre`
    Docker 镜像上，如下所示的命令：
- en: '[PRE13]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, remove the image and its upstream dependency and rebuild the image again
    using the following commands:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，删除镜像及其上游依赖，并使用以下命令重新构建镜像：
- en: '[PRE14]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When the `java:8u45-jre` Docker image was downloaded for the second time, it
    was retrieved from the local registry mirror instead of being connected to Docker
    Hub. Setting up a Docker registry mirror improved the time of downloading the
    upstream image by almost two times the usual. If we have other Docker hosts pointed
    at this same registry mirror, it will do the same thing: skip the downloading
    from Docker Hub.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当第二次下载 `java:8u45-jre` Docker 镜像时，它是从本地注册表镜像中获取的，而不是连接到 Docker Hub。设置 Docker
    注册表镜像使得下载上游镜像的时间几乎减少了两倍。如果我们有其他 Docker 主机指向同一个注册表镜像，它也会做相同的事情：跳过从 Docker Hub 下载。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This guide on how to set up a registry mirror is based on the one on the Docker
    documentation website. More details can be found at [https://docs.docker.com/articles/registry_mirror](https://docs.docker.com/articles/registry_mirror).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 本指南关于如何设置注册表镜像，基于 Docker 官方文档网站上的内容。更多细节可以在 [https://docs.docker.com/articles/registry_mirror](https://docs.docker.com/articles/registry_mirror)
    找到。
- en: Reusing image layers
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重用镜像层
- en: As we already know, a Docker image consists of a series of layers combined using
    the union filesystem of a single image. When we work on building our Docker image,
    the preceding instructions in our `Dockerfile` are examined by Docker to check
    whether there is an existing image in its build cache that can be reused instead
    of creating a similar or duplicate image for these instructions. By finding out
    how the build cache works, we can greatly increase the speed of the subsequent
    builds of our Docker images. A good example of this is when we develop our application's
    behavior; we will not add dependencies to our application all the time. Most of
    the time, we will just want to update the core behavior of the application itself.
    Knowing this, we can design the way we will build our Docker images around this
    in our development workflow.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Docker 镜像由一系列层组成，这些层通过单个镜像的联合文件系统进行组合。当我们构建 Docker 镜像时，Docker 会检查 `Dockerfile`
    中的前置指令，查看是否有现有的镜像可以复用，而不是为这些指令创建类似或重复的镜像。如果了解了构建缓存的工作原理，我们可以大大提高后续 Docker 镜像构建的速度。一个好的例子是，当我们开发应用程序的行为时，我们并不会一直添加依赖项。大多数时候，我们只需要更新应用程序本身的核心行为。了解这一点后，我们可以在开发工作流中围绕这一点设计
    Docker 镜像的构建方式。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Detailed rules on how `Dockerfile` instructions are cached can be found at [http://docs.docker.com/articles/dockerfile_best-practices/#build-cache](http://docs.docker.com/articles/dockerfile_best-practices/#build-cache).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `Dockerfile` 指令缓存的详细规则，可以参阅 [http://docs.docker.com/articles/dockerfile_best-practices/#build-cache](http://docs.docker.com/articles/dockerfile_best-practices/#build-cache)。
- en: 'For example, suppose we are working on a Ruby application whose source tree
    looks similar to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在开发一个 Ruby 应用程序，它的源代码树看起来像下面这样：
- en: '![Reusing image layers](img/00003.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![复用镜像层](img/00003.jpeg)'
- en: 'The `config.ru` would be as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`config.ru`的内容如下：'
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `Gemfile` would be as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gemfile`的内容如下：'
- en: '[PRE16]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `Dockerfile` would be as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dockerfile`的内容如下：'
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following steps will show you how to build the Ruby application we wrote
    earlier as a Docker image:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的步骤将向您展示如何将我们之前编写的 Ruby 应用程序构建为 Docker 镜像：
- en: 'First, let''s build this Docker image through the following command. Note that
    the time it took to build is around one minute:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过以下命令构建这个 Docker 镜像。请注意，构建所用的时间大约为一分钟：
- en: '[PRE18]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, update `config.ru` to change the application''s behavior, as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新 `config.ru` 来改变应用程序的行为，如下所示：
- en: '[PRE19]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s now build again the Docker image and note the time it takes to finish
    the build. Run the following command:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们重新构建 Docker 镜像，并记录构建完成所花费的时间。运行以下命令：
- en: '[PRE20]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can note that even with a single-line change to our application, we have
    to run `bundle install` for each iteration of the Docker image that we are building.
    This can be very inefficient, and it disrupts the flow of our development because
    it takes one minute to build and run our Docker application. For impatient developers
    such as us, this feels like an eternity!
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以注意到，即使只是对应用程序进行了单行更改，我们也需要在每次构建 Docker 镜像时都运行 `bundle install`。这非常低效，而且会中断我们的开发流程，因为构建和运行
    Docker 应用程序需要一分钟。对于像我们这样的急性子开发者来说，这简直就像度日如年！
- en: 'In order to optimize this workflow, we can separate the phase in which we prepare
    our application''s dependencies from that in which we prepare its actual artifacts.
    The next steps show us how to do this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为了优化这一工作流，我们可以将准备应用程序依赖项的阶段与准备实际工件的阶段分开。接下来的步骤展示了如何做到这一点：
- en: 'First, update our `Dockerfile` with the following changes:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，更新我们的 `Dockerfile`，进行如下更改：
- en: '[PRE21]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, build the newly refactored Docker image via this command:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过以下命令构建重新构建的 Docker 镜像：
- en: '[PRE22]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The build time is still the same at first, but note the image ID generated
    in `Step 3`. Now, try updating `config.ru` again and rebuilding the image, as
    follows:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始构建时间仍然相同，但请注意在 `Step 3` 生成的镜像 ID。现在，再次尝试更新 `config.ru` 并重建镜像，如下所示：
- en: '[PRE23]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As we can note in the preceding output, `docker build` reused the cache until
    `Step 3` as there was no change in `Gemfile`. Note that our Docker image's build
    time decreased by 80 times the usual!
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的输出中我们可以看到，`docker build` 在 `Step 3` 之前复用了缓存，因为 `Gemfile` 没有发生变化。请注意，我们 Docker
    镜像的构建时间比通常减少了 80 倍！
- en: This kind of refactoring for our Docker image is also useful to reduce deployment
    time. As our Docker hosts in production already have image layers until `Step
    3` of our Docker image in the previous version of our container, having a new
    version of our Docker application will only require the Docker host to pull new
    image layers for `Step 4` to `Step 6` in order to update our application.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这种对Docker镜像的重构同样有助于减少部署时间。因为我们的生产环境中的Docker主机已经包含了Docker镜像在上一版本容器中`Step 3`的镜像层，所以在应用新版本时，Docker主机只需拉取`Step
    4`到`Step 6`的新镜像层即可更新我们的应用。
- en: Reducing the build context size
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少构建上下文大小
- en: 'Let''s suppose that we have a `Dockerfile` in the Git version control similar
    to the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们在Git版本控制中有一个类似于以下的`Dockerfile`：
- en: '![Reducing the build context size](img/00004.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![减少构建上下文大小](img/00004.jpeg)'
- en: 'At some point, we will notice that our `.git` directory is too big. This is
    probably the result of having more and more code committed into our source tree:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些时候，我们会注意到我们的`.git`目录太大。这可能是由于我们的源代码树中提交了越来越多的代码：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, when we build our Docker application, we will notice that the time taken
    to build our Docker application is very big as well. Take a look at the following
    output:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们构建我们的Docker应用时，我们会注意到构建Docker应用所需的时间也非常长。请看以下输出：
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: If we look closely at the preceding output, we will see that the Docker client
    uploaded the whole `.git` directory of 1 GB onto the Docker daemon because it
    is a part of our build context. Also, as this is a large build context, it takes
    time for the Docker daemon to receive it before being able to start building our
    Docker image.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仔细查看前面的输出，我们会看到Docker客户端将整个1GB的`.git`目录上传到Docker守护进程，因为它是我们构建上下文的一部分。而且，由于这是一个大型构建上下文，在Docker守护进程能够开始构建我们的Docker镜像之前，它需要花时间接收这些数据。
- en: 'However, these files are not necessary to build our application. Moreover,
    these Git-related files are not at all needed when we run our application in production.
    We can set Docker to ignore a specific set of files that are not needed to build
    our Docker image. Follow the next few steps to perform this optimization:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些文件在构建我们的应用时并不是必需的。而且，当我们在生产环境中运行应用时，这些与Git相关的文件完全不需要。我们可以设置Docker忽略一组特定的文件，这些文件在构建Docker镜像时并不需要。按照接下来的几个步骤进行优化：
- en: 'Create a `.dockerignore` file with the following content in the same directory
    as our `Dockerfile`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与我们的`Dockerfile`相同的目录中创建一个`.dockerignore`文件，内容如下：
- en: '[PRE26]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, build our Docker image again by executing the following command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过执行以下命令重新构建我们的Docker镜像：
- en: '[PRE27]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Note now that the build time is improved by over 500 times the usual just by
    decreasing the size of the build context!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在构建时间仅通过减小构建上下文的大小就提高了500倍以上！
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on how to use .`dockerignore` files can be found at [https://docs.docker.com/reference/builder/#dockerignore-file](https://docs.docker.com/reference/builder/#dockerignore-file).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何使用`.dockerignore`文件的更多信息，请参见[https://docs.docker.com/reference/builder/#dockerignore-file](https://docs.docker.com/reference/builder/#dockerignore-file)。
- en: Using caching proxies
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用缓存代理
- en: Another common source causing the long runtime in building Docker images are
    instructions that download dependencies. For example, a Debian-based Docker image
    needs to fetch packages from APT repositories. Depending on how large these packages
    are, the build time for an `apt-get install` instruction may be long. A useful
    technique to reduce the time for these build instructions is to introduce proxies
    that cache such dependency packages. A popular caching proxy is `apt-cacher-ng`.
    This section will describe running and setting it up to improve our Docker image
    building workflow.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的导致Docker镜像构建时间过长的原因是下载依赖项的指令。例如，基于Debian的Docker镜像需要从APT仓库获取包。根据这些包的大小，`apt-get
    install`指令的构建时间可能会很长。为了减少这些构建指令的时间，可以使用代理来缓存这些依赖包。一个流行的缓存代理是`apt-cacher-ng`。本节将描述如何运行和设置它，以改进我们的Docker镜像构建工作流。
- en: 'The following is an example `Dockerfile` that installs a lot of Debian packages:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例`Dockerfile`，它安装了大量的Debian包：
- en: '[PRE28]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Note that its build time in the following output is quite long because this
    `Dockerfile` file downloads a lot of dependencies and packages related to Java
    (`openjdk-8-jre-headless`). Run the following command:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，下面输出中的构建时间非常长，因为这个`Dockerfile`文件下载了很多与Java（`openjdk-8-jre-headless`）相关的依赖和包。运行以下命令：
- en: '[PRE29]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to improve the workflow for building this Docker image, we will set
    up a caching proxy with `apt-cacher-ng`. Fortunately, it is already available
    as a ready-to-run container from Docker Hub. Follow the next few steps to prepare
    `apt-cacher-ng`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了改善构建这个 Docker 镜像的工作流程，我们将使用 `apt-cacher-ng` 设置一个缓存代理。幸运的是，它已经作为一个即插即用的容器在
    Docker Hub 上提供。请按照以下几步准备 `apt-cacher-ng`：
- en: 'Run the following command in our Docker host to start `apt-cacher-ng`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的 Docker 主机上运行以下命令以启动 `apt-cacher-ng`：
- en: '[PRE30]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After this, we will use the caching proxy we ran earlier, as described in the
    following `Dockerfile`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，我们将使用之前运行的缓存代理，如以下 `Dockerfile` 所示：
- en: '[PRE31]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Build the `Dockerfile` we created earlier as a Docker image tagged as `hubuser/debian:jessie`
    via the following command line:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下命令行构建我们之前创建的 `Dockerfile`，将其标记为 `hubuser/debian:jessie` 的 Docker 镜像：
- en: '[PRE32]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Finally, make `hubuser/debian:jessie` our new base Docker image by updating
    our `Dockerfile` that installs a lot of Debian packages for dependencies such
    as the following:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，通过更新我们的 `Dockerfile` 来使 `hubuser/debian:jessie` 成为新的基础 Docker 镜像，该文件安装了许多
    Debian 包作为依赖，例如以下内容：
- en: '[PRE33]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'To confirm the new workflow, run an initial build to warm up the cache using
    the following command:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确认新的工作流程，运行初始构建以使用以下命令预热缓存：
- en: '[PRE34]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Finally, execute the following commands to build the image again. However,
    make sure to remove the image first:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，执行以下命令再次构建镜像。但请确保先删除该镜像：
- en: '[PRE35]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note how the subsequent build is faster even though we do not use Docker's build
    cache. This technique is useful when we develop base Docker images for our team
    or organization. Team members that try to rebuild our Docker image will run their
    builds 6.5 times faster because they can download packages from our organization's
    cache proxy that we prepared earlier. Builds on our continuous integration server
    will also be faster upon check-in because we already warmed up the caching server
    during development.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管我们没有使用 Docker 的构建缓存，但后续的构建速度更快。这种技术对于我们为团队或组织开发基础 Docker 镜像时非常有用。团队成员在尝试重新构建我们的
    Docker 镜像时，将会比之前快 6.5 倍，因为他们可以从我们之前准备的组织缓存代理中下载包。我们在持续集成服务器上的构建也将更快，因为在开发过程中我们已经预热了缓存服务器。
- en: 'This section gave a glance at how to use a very specific caching server. Here
    are a few others that we can use and their corresponding pages of documentation:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要介绍了如何使用一个非常具体的缓存服务器。以下是我们可以使用的其他几个缓存服务器及其相应的文档页面：
- en: '**apt-cacher-ng**: This supports caching Debian, RPM, and other distribution-specific
    packages and can be found at [https://www.unix-ag.uni-kl.de/~bloch/acng](https://www.unix-ag.uni-kl.de/~bloch/acng).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**apt-cacher-ng**：该工具支持缓存 Debian、RPM 以及其他特定于发行版的包，并可以在 [https://www.unix-ag.uni-kl.de/~bloch/acng](https://www.unix-ag.uni-kl.de/~bloch/acng)
    找到。'
- en: '**Sonatype Nexus**: This supports Maven, Ruby Gems, PyPI, and NuGet packages
    out of the box. It is available at [http://www.sonatype.org/nexus](http://www.sonatype.org/nexus).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sonatype Nexus**：该工具支持 Maven、Ruby Gems、PyPI 和 NuGet 包，并且开箱即用。它可以在 [http://www.sonatype.org/nexus](http://www.sonatype.org/nexus)
    上找到。'
- en: '**Polipo**: This is a generic caching proxy useful for development that can
    be found at [http://www.pps.univ-paris-diderot.fr/~jch/software/polipo](http://www.pps.univ-paris-diderot.fr/~jch/software/polipo).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Polipo**：这是一款通用缓存代理工具，适用于开发，详情请访问 [http://www.pps.univ-paris-diderot.fr/~jch/software/polipo](http://www.pps.univ-paris-diderot.fr/~jch/software/polipo)。'
- en: '**Squid**: This is another popular caching proxy that can work with other types
    of network traffic as well. You can look this up at [http://www.squid-cache.org](http://www.squid-cache.org).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Squid**：这是另一个流行的缓存代理，能够与其他类型的网络流量一起工作。你可以在 [http://www.squid-cache.org](http://www.squid-cache.org)
    查找相关信息。'
- en: Reducing Docker image size
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减小 Docker 镜像大小
- en: As we keep working on our Docker applications, the size of images tends to get
    bigger and bigger if we are not careful. Most people using Docker observe that
    their team's custom Docker images increase in size to at least 1 GB or more. Having
    larger images means that the time to build and deploy our Docker application increases
    as well. As a result, the feedback we get to determine the result of the application
    we're deploying gets reduced. This diminishes the benefits of Docker, enabling
    us to develop and deploy our applications in rapid iterations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续开发 Docker 应用程序，如果不加以注意，镜像的大小往往会变得越来越大。大多数使用 Docker 的人都会发现，团队定制的 Docker
    镜像大小至少会增加到 1 GB 或更多。镜像增大意味着构建和部署 Docker 应用程序所需的时间也会增加。因此，我们获取的反馈，尤其是关于我们部署的应用程序结果的反馈，会减少。这削弱了
    Docker 的优势，即使我们能够快速迭代开发和部署应用程序。
- en: This section examines some further details of how Docker's image layers work
    and how they affect the size of the resulting image. Next, we will learn how to
    optimize these image layers by exploiting how Docker images work.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 本节探讨了Docker镜像层如何工作以及它们如何影响最终镜像的大小。接下来，我们将学习如何通过利用Docker镜像的工作方式来优化这些镜像层。
- en: Chaining commands
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 链接命令
- en: 'Docker images get big because some instructions are added that are unnecessary
    to build or run an image. A popular use case is packaging metadata and cache.
    After installing the packages necessary to build and run our application, such
    downloaded packages are no longer needed. The following patterns of instructions
    in a `Dockerfile` are commonly found in the wild (such as in Docker Hub) to *clean*
    the images of such unnecessary files from Docker images:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像变大是因为一些指令被添加，而这些指令对于构建或运行镜像并不必要。一个常见的用例是打包元数据和缓存。在安装了构建和运行我们应用程序所需的包之后，这些已下载的包就不再需要。以下是`Dockerfile`中常见的指令模式（例如在Docker
    Hub中），用于*清理*Docker镜像中此类不必要的文件：
- en: '[PRE36]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, a Docker image''s size is basically the sum of each individual layer
    image; this is how union filesystems work. Hence, the *clean* steps do not really
    delete the space. Take a look at the following commands:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Docker镜像的大小基本上是每个单独层的镜像大小之和；这就是联合文件系统的工作原理。因此，*清理*步骤并不真正删除空间。请看以下命令：
- en: '[PRE37]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There is no such thing as "negative" layer size. Hence, each instruction in
    a Dockerfile can only keep the image size constant or increase it. Also, as each
    step also introduces some metadata, the total size keeps increasing.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 没有所谓的“负”层大小。因此，Dockerfile中的每条指令只能保持镜像大小不变或增加它。而且，由于每个步骤还会引入一些元数据，最终的大小会不断增加。
- en: 'In order to reduce the total image size, the cleaning steps should be performed
    in the same image layer. Hence, the solution is to chain commands from the previously
    multiple instructions into a single one. As Docker uses `/bin/sh` to run each
    instruction, we can use the Bourne shell''s `&&` operator to perform the chaining,
    as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少总镜像大小，清理步骤应在同一镜像层中执行。因此，解决方案是将先前多个指令的命令链接成一个。由于Docker使用`/bin/sh`来运行每条指令，我们可以使用Bourne
    shell的`&&`运算符来执行链式操作，如下所示：
- en: '[PRE38]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Note how each individual layer is much smaller now. As the individual layers''
    sizes were reduced, the total image size also decreased. Now, run the following
    commands and take a look at the output:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，现在每个单独层的大小都小得多。随着各个层的大小减少，总镜像大小也随之减小。现在，运行以下命令并查看输出：
- en: '[PRE39]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Separating build and deployment images
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分离构建和部署镜像
- en: Another source of unnecessary files in Docker images are build time dependencies.
    Source libraries, such as compilers and source header files, are only necessary
    when building an application inside a Docker image. Once the application is built,
    these files are no longer necessary as only the compiled binary and related shared
    libraries are needed to run the application.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Docker镜像中的另一个不必要文件来源是构建时依赖项。源代码库，例如编译器和源头头文件，只有在Docker镜像内构建应用程序时才是必要的。一旦应用程序构建完成，这些文件就不再需要，因为运行应用程序只需要编译后的二进制文件和相关的共享库。
- en: 'For example, build the following application that is now ready to be deployed
    to a Docker host that we prepared in the cloud. The following source tree is a
    simple web application written in Go:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，构建以下应用程序，现已准备好部署到我们在云端准备的Docker主机。以下源代码树是一个用Go编写的简单Web应用程序：
- en: '![Separating build and deployment images](img/00005.jpeg)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![分离构建和部署镜像](img/00005.jpeg)'
- en: 'The following is the content of `hello.go` describing the application:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是描述应用程序的`hello.go`文件内容：
- en: '[PRE40]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The following corresponding `Dockerfile` shows how to build the source code
    and run the resulting binary:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下对应的`Dockerfile`展示了如何构建源代码并运行生成的二进制文件：
- en: '[PRE41]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In the next few steps, we will show you how this Docker application''s image
    size gets big:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几个步骤中，我们将展示Docker应用程序镜像如何变得越来越大：
- en: 'First, build the Docker image and note its size. We will run the following
    commands for this:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，构建Docker镜像并注意其大小。我们将运行以下命令：
- en: '[PRE42]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, compare this to the size of the actual application that is run, as follows:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将此与实际运行的应用程序的大小进行比较，如下所示：
- en: '[PRE43]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: One of the advantages of writing Go applications, and compiled code in general,
    is that we can produce a single binary that is easy to deploy. The remaining size
    of the Docker image is made up of the unnecessary files provided by the base Docker
    image. We can note the large overhead coming from the base Docker image that increases
    the total image size by 100 times the usual.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 编写 Go 应用程序以及一般编译代码的一个优点是，我们可以生成一个易于部署的单一二进制文件。Docker 镜像的剩余大小来自基础 Docker 镜像中不必要的文件。我们可以注意到，基础
    Docker 镜像带来的巨大开销将总镜像大小增加了通常的 100 倍。
- en: 'We can also optimize the end Docker image deployed to production by only packing
    the final `hello` binary and some dependent shared libraries. Follow the next
    few steps to perform the optimization:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以通过仅打包最终的 `hello` 二进制文件和一些依赖的共享库，来优化部署到生产环境的 Docker 镜像。按照接下来的步骤进行优化：
- en: 'First, copy the binary from the running container to our Docker host via the
    following command line:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过以下命令将二进制文件从运行中的容器复制到我们的 Docker 主机：
- en: '[PRE44]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If the preceding library were a static binary, we would now be done and would
    proceed with the next step. However, Go tooling builds share binaries by default.
    In order for the binary to run properly, it needs the shared libraries. Run the
    following command to list them:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果前面的库是静态二进制文件，我们现在就完成了，可以继续下一步。然而，Go 工具链默认构建共享二进制文件。为了让二进制文件正常运行，它需要共享库。运行以下命令列出它们：
- en: '[PRE45]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Next, save all required shared libraries to our Docker host. Issuing the following
    `docker cp -L` commands will do this:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将所有必需的共享库保存到我们的 Docker 主机上。执行以下 `docker cp -L` 命令可以完成此操作：
- en: '[PRE46]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Create a new `Dockerfile` to build this "binary-only" image. Note how the `ADD`
    instructions recreate the shared library paths that the `hello` application expects
    in this new Docker image in the following output:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `Dockerfile` 来构建这个“仅二进制”镜像。请注意，`ADD` 指令在以下输出中如何重建 `hello` 应用程序期望的共享库路径：
- en: '[PRE47]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Now we have all the necessary files needed to run the new "binary-only" Docker
    image. In the end, the files in our directory tree will look similar to the following
    screenshot:![Separating build and deployment images](img/00006.jpeg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了运行新的“仅二进制”Docker 镜像所需的所有文件。最终，我们目录树中的文件将类似于以下截图：![分离构建和部署镜像](img/00006.jpeg)
- en: 'Now, build the deployable `binary` Docker image with the following `build/Dockerfile`.
    The resulting image will be smaller now:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用以下 `build/Dockerfile` 构建可部署的 `binary` Docker 镜像。构建出来的镜像现在会更小：
- en: '[PRE48]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: The same approach can also be used to make other compiled applications, such
    as the software normally installed using the `./configure && make && make install`
    combinations. We can do the same for interpreted languages such as Python, Ruby,
    or PHP. However, it will need a little more work to create a "runtime" Ruby Docker
    image from a "build" Ruby Docker image. An example of a good time to perform this
    kind of optimization is when the delivery of our applications gets too long because
    the images are too big for a sustainable development workflow.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的方法也可以用来构建其他编译应用程序，如通常使用 `./configure && make && make install` 组合安装的软件。我们也可以对
    Python、Ruby 或 PHP 等解释型语言做同样的事情。然而，从“构建”Ruby Docker 镜像创建“运行时”Ruby Docker 镜像需要稍微多一些工作。进行这种优化的一个好时机是，当我们的应用程序交付时间太长，因为镜像太大，不适合可持续的开发工作流。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned more about how Docker builds images and applied
    it to improve several factors, such as the deploy time, build time, and image
    size. The techniques specified in this chapter are not comprehensive; there will
    surely be more ways on how to achieve these objectives as more people discover
    how to use Docker for their applications. More techniques will also arise as Docker
    itself matures and develops more features. The most important guiding factor for
    these optimizations is to ask ourselves whether we are really getting the benefits
    of using Docker. Some good example questions to ask are as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了 Docker 如何构建镜像，并将其应用于改善多个因素，如部署时间、构建时间和镜像大小。本章所述的技术并不全面；随着越来越多的人发现如何将
    Docker 用于他们的应用程序，肯定会出现更多的方式来实现这些目标。随着 Docker 本身的成熟和更多功能的开发，也会有更多的技术出现。进行这些优化时，最重要的指导因素是问问自己，我们是否真正获得了使用
    Docker 的好处。一些值得提问的好问题如下：
- en: Is deploy time improving?
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署时间是否得到了改善？
- en: Is the development team getting feedback fast enough from what the operations
    team learned when running our application?
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发团队是否能从运营团队运行我们应用程序时学到的经验中快速获得反馈？
- en: Are we able to iterate on new features fast enough to incorporate the new feedback
    that we discovered from customers using our application?
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们是否能够足够快速地迭代新功能，以便纳入我们从客户使用应用程序中发现的新反馈？
- en: By keeping in mind our motivation and objective of using Docker, we can come
    with our own ways to improve our workflows.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 牢记我们使用 Docker 的动机和目标，我们可以找到自己改进工作流的方法。
- en: Using some of the preceding optimizations will require updating the configuration
    of our Docker hosts. To be able to manage several Docker hosts at a scale, we
    will need some form of automation for their provisioning and configuration. In
    the next chapter, we will talk about how to automate setting up Docker hosts with
    configuration management software.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一些前述的优化将需要更新我们的 Docker 主机配置。为了能够在大规模上管理多个 Docker 主机，我们需要某种形式的自动化来进行它们的配置和提供。在下一章中，我们将讨论如何使用配置管理软件自动化设置
    Docker 主机。
