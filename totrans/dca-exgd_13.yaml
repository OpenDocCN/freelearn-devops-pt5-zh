- en: Introduction to the Docker Enterprise Platform
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapters, we talked about Docker's features and Docker environments.
    We introduced the concepts of containers and looked at how we can deploy applications
    to orchestrated environments. All the features we saw were based on Docker Community
    Edition. In this chapter, we will learn about all the various Docker editions
    and their differences before introducing the Docker Enterprise platform.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will introduce the different Docker editions and tools.
    We will also review the concept of **Container as a Service** (**CaaS**) and learn
    about what we need in these kinds of environments. Docker provides an enterprise-ready
    CaaS platform and we will review all of its components.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Docker editions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CaaS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Docker Enterprise platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning your Docker Enterprise deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start this chapter by learning about all the different Docker editions
    and their specific features.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the Docker editions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will have a quick review of the different Docker editions.
    We have been using Docker Community in previous chapters, but now, it is time
    to learn about Docker Enterprise. This is because it is very important for the
    Docker Certified Associate exam. In fact, it could relate to more than 50% of
    the knowledge required for the exam because all of the concepts you'll be learning
    about will relate to this platform.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Community is the Docker platform we use while developing container-based
    applications. It is free to use and is supported on GitHub ([https://github.com/docker/docker-ce](https://github.com/docker/docker-ce))
    and Docker Forums ([https://forums.docker.com/](https://forums.docker.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Docker Enterprise is an enterprise-ready solution. Docker/Mirantis provides
    *24/7* support and is licensed by subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Community
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we talk about Docker Community Edition, also known as **docker-ce**, we
    are just referring to Docker Engine (daemon), although there are other community
    software products made by Docker''s team:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Toolbox**: This was the first approach available for Microsoft Windows
    and Apple Mac users. Before Windows containers, this was the only way of using
    Docker on Windows nodes. It provides a desktop environment with many tools and
    shortcuts for most components and actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Machine**: Docker Machine allows us to provision Docker hosts. It
    comes with some predefined provisioners and we can extend this list with external
    binaries to deploy nodes with the most popular cloud providers and on-premises
    infrastructures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Desktop**: This was an evolution of the Docker Toolbox environment
    on Windows Professional environments. Developers were very happy with the experience
    they had with Docker Toolbox. In response, Docker created a desktop environment
    capable of launching a small Kubernetes environment, while also including application
    templates to help developers create simple applications with just a few mouse
    clicks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Community Edition provides a complete Docker Engine platform. Hence,
    we can create a cluster with either Docker Swarm or Kubernetes. All Community
    Edition features have been covered in previous chapters â€“ we have never talked
    about any Enterprise-specific integrations. Docker Swarm does not provide **role-based
    access control** (**RBAC**) for user management. We also have to provide a solution
    for publishing applications securely. Remember that Docker just provides a router
    mesh and host publishing features and that they are not secure. For many users,
    Docker Swarm, with a couple of tweaks, is more than enough. It is easy to learn
    and manage and also provides resilience and high availability for core components.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes can be deployed on top of Docker Community Edition. We will just
    use Docker Engine as the runtime for the Kubernetes cluster. This is quite common
    as it's the most-used solution nowadays. Kubernetes provides a rich ecosystem
    and comes with some out-of-the-box features required for production. But, on the
    other hand, some details, such as networking, require third-party solutions. Kubernetes
    has a different approach to the world of containers. Docker follows the "*batteries
    included but interchangeable"* approach, providing everything required to work
    out of the box, although we can change most of its components. On the other hand,
    Kubernetes was made with the "*everything should be pluggable"* mindset. Kubernetes
    has a richer ecosystem because there are many solutions around its core pieces.
    These help it grow faster and bigger than Docker.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Enterprise
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker Enterprise has everything that''s missing from Docker Swarm. It provides
    a full CaaS platform that''s based on two components: Docker **Universal Control
    Plane** (**UCP**) and **Docker Trusted Registry** (**DTR**). During the last European
    DockerCon, in December 2018, Docker Desktop Enterprise was announced and it was
    stated that it would include desktop functionality for developers. Docker Desktop
    Enterprise allows developers to create applications easily using Docker. They
    can also test their developed containers on Kubernetes locally or even choose
    which production environment they want to test in to ensure that their applications
    will run smoothly in production. Docker Desktop was created with developers in
    mind and Enterprise helps them avoid friction between development and production.'
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book, Docker can be found under two different product
    brands. Mirantis bought the Docker Enterprise product, while Docker maintains
    Docker Community software and their desktop product. The complete Enterprise platform
    will be part of the Mirantis catalog.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, Docker Enterprise Edition covers the following products:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Enterprise Engine**: Docker Engine is required for the Docker Enterprise
    platform; it provides all the required runtime features. There are slight differences
    between the Community and Enterprise editions. In fact, the most important one
    is to do with support. Docker Enterprise provides an enterprise *24/7* support
    subscription option and a working hours support subscription option. The Docker
    Community edition does not provide such support. This slight difference will probably
    persuade enterprise users to use Docker Enterprise Edition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker UCP**: The control plane for the cluster is also included in Docker
    Enterprise Edition. This product is called Docker UCP. It also provides a Kubernetes
    production-ready platform out of the box, on top of a production-ready Docker
    Swarm cluster. It is probably the best option for getting a Kubernetes cluster
    with minimal effort. This cluster distribution is also supported by Docker, which
    means that all Kubernetes integrations have been fully tested on the Docker Enterprise
    platform. The bad thing about this is that Kubernetes releases have to be frozen
    during a product''s lifetime. At the time of writing this book, the currently
    supported and distributed Kubernetes release is 1.14, while it is generally available
    as 1.17 in the Community edition. This is normal for enterprise products. Everything
    must be tested and verified before moving to a newer release, and this takes time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Trusted Registry**: A registry is always required to work with containers.
    Although Docker developed **Docker Registry**and it is open source, it is not
    enough for production. It provides neither authentication nor authorization, which
    are fundamental to ensure secure access to images. We can integrate **Docker Trusted
    Content***,*but this is not easy. We will need to include Notaryservices and integrate
    them into the rest of the deployed platform. Believe me, this is not easy. I have
    done it in the past and it was hard to implement and even harder to maintain.
    DTR includes authentication and authorization based on the RBAC model. We can
    have organizations, teams, and different access for different users, and we can
    make some of our images publicly available. We get fully featured access and image
    publishing control. It also includes a Docker Trusted Content implementation,
    with all the required components and integrations. It includes CI/CD workflow
    integrations for different stages and security image scanning. These features
    will allow us to ensure that only approved images that are free from vulnerabilities
    run in our production CaaS platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Desktop Enterprise**: This is the most recently added feature at the
    time of writing this book. The Docker Certified Associate exam does not include
    any questions about it right now. Due to this, we will just provide a basic Docker
    Desktop introduction. This is a desktop application that provides developers with
    full Docker Swarm and Kubernetes environments so that they can develop and test
    their applications on their laptops before moving their artifacts to other stages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As we can see, there''s a number of different components that are packaged
    in a Docker Enterprise release. If we go to [https://success.docker.com/article/compatibility-matrix](https://success.docker.com/article/compatibility-matrix),
    we can review which component releases are verified and are supported to work
    together. At the time of writing this book, these are the latest supported releases
    of each component for Docker Enterprise Edition 3.0:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine 19.03.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Universal Control Plane 3.2.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Trusted Registry 2.7.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker Engine is supported on many Linux distributions (such as Red Hat/CentOS,
    SUSE SLES, Oracle Linux, and Ubuntu) and Windows (2016 and 2019 releases).
  prefs: []
  type: TYPE_NORMAL
- en: Windows nodes are only supported as worker nodes and they will only be part
    of a Docker Swarm orchestration. Kubernetes is not available on the Windows platform
    on Docker Enterprise 3.0.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss what a CaaS platform is and how Docker
    provides all the expected features.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CaaS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A CaaS platform is a platform that can be used to provide container services
    to users. The term *as a Service* is usually associated with cloud providers and
    their solutions. We will extend this terminology to on-premises environments here.
    We will talk about CaaS as a framework or compound of applications designed to
    provide a complete container-based solution to users. A CaaS solution must provide
    the full container workflow (build, ship, and run). There is also another new
    term these days: **KaaS** solutions. This terminology refers to **Kubernetes as
    a Service** platforms, where Kubernetes is the core of the environment. These
    solutions add some facilities that are not included with Kubernetes out of the
    box, such as monitoring, logging, and CI/CD.'
  prefs: []
  type: TYPE_NORMAL
- en: CaaS and KaaS environments are aimed at users that require a complete solution.
    There will be administrators of the solution and clients that will consume the
    services provided in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'These platforms must provide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**: Users accessing the platform should be authenticated so
    as to only allow approved users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authorization**: Roles will provide different access to different users.
    There should be administrators and users. Each should have different levels of
    access and views within the platform. Actions that can be performed on containers
    should be inaccessible to non-authorized users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Runtime**: All containers will run on container engines. This is a requirement.
    There are different engines, but Docker Engine is still the most common nowadays.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Publishing**: We use these platforms to create and run applications based
    on containers, but people have to be able to consume our deployed services. CaaS/KaaS
    platforms must provide a component that allows us to publish applications that
    are deployed inside our environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registry**: All images must be stored somewhere. Remember, images are always
    required. There are no containers without images, and versioning them alongside
    code changes will help you track issues and new functionalities. Having a registry
    included in your CaaS/KaaS platform is vital.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Status**: We need to have a complete view of the statuses of all our platform
    components. If there''s a failure, we need to know which components will be affected,
    whether we''ll be able to push new images, and whether our services work, for
    instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integrations**: Although, in my opinion, logging and monitoring are not strictly
    required, it is good to at least provide integrations to external platforms for
    these features. Some CaaS platforms include these services in their deployment
    (such as Red Hat''s OpenShift, among others), but it should be easy to integrate
    our logging and monitoring environments. Sometimes, operations teams will have
    their own monitoring platforms; a CaaS platform should just forward all required
    events to them. CI/CD workflows are another interesting integration. If a CaaS
    platform can integrate development and test stages within the platform, users
    will be able to just code. Everything else can be automated with CI/CD tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we mentioned previously, these platforms will require some administrators
    to do all the maintenance tasks and configurations, while users will just consume
    the provided services to create and run their applications. There are some cloud
    providers that have taken a different approach. **Azure Kubernetes Service** (**AKS**),
    Amazon's **Elastic Kubernetes Service** (**EKS**), and **Google Kubernetes Service**
    (**GKS**) are the most well-known examples of these environments.
  prefs: []
  type: TYPE_NORMAL
- en: On these platforms, we just select the number of workers to deploy in our cluster.
    All maintenance tasks are managed by the cloud provider; we just configure user
    access and prepare some of the cloud provider's load balancers to route the traffic.
    Everything else is configured and deployed in Kubernetes. This is great because
    we get to just focus on deploying applications. We don't have to care about high
    availability in the environment, backups, or platform upgrades. The cloud provider
    will manage all these tasks for us. Such platforms also include monitoring and
    logging facilities that are integrated into their **Platform as a Service** (**PaaS**)
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed what we need to provide in a CaaS or KaaS platform.
    In the next section, we will learn about how Docker Enterprise implements these
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Enterprise platform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Enterprise provides a CaaS platform. In this section, we will try to
    apply everything we know about CaaS platforms to what we understand about Docker
    Enterprise. We will cover many concepts in order to help you to understand how
    we implement end-to-end container-based solutions with Docker Enterprise. We will
    not cover Docker Desktop Enterprise because it is not part of the Docker Certified
    Associate exam.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker Engine is a core piece of the platform. It provides the runtime for executing
    the platform. Unlike Kubernetes, Docker Swarm requires Docker Engine to work.
    Kubernetes provides the option to use `containerd` directly or a **Container Runtime
    Interface Optimized** (**CRI-O** for OCI-compatible containers). Docker Engine
    includes Swarm mode, and we do not need any other software to implement a fully
    functional distributed orchestration environment. Docker Engine provides the underlying
    layer of execution of all platform components.
  prefs: []
  type: TYPE_NORMAL
- en: On top of Docker Engine, we will create a Docker Swarm cluster, and other Docker
    Enterprise components will run either as Docker Swarm services or multi-container
    applications. This is key because there are a few components that will run as
    agents in the platform, and we will automatically deploy them as **global services**(remember
    these concepts). But there are also some components that must be unique within
    the cluster. They will run as **multi-container**applications on top of some defined
    hosts. These components will use different schemas for their execution.
  prefs: []
  type: TYPE_NORMAL
- en: For Docker Enterprise, we will deploy Docker Enterprise Engine, along with support
    for specific releases. Enterprise releases have to be supported for a long time,
    so this affects release times. As we saw in the *Docker Enterprise Engine* section,
    the currently supported release is 19.03.x (at the time of writing this book),
    while for the Community Edition, the supported release can be different (it's
    currently also 19.03.6, but it was only until recently that there could be big
    differences between releases). This is normal because Docker engineers and support
    teams must verify all components' integrations and solve any issues for current
    Docker Enterprise releases, while at the same time evolving the product by adding
    new features. These features always appear on Docker Community Edition before
    they are fully tested and implemented for Docker Enterprise Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Because we will be working in a cluster environment, we will be able to execute
    maintenance tasks and move workloads between nodes without service interruption.
    Docker Engine updates will be smooth and easy.
  prefs: []
  type: TYPE_NORMAL
- en: Universal Control Plane
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: UCP provides the control plane for the Docker Enterprise platform. It provides
    all the processes and tools you need in order to manage all your cluster components
    and their statuses. UCP will deploy components on master and worker nodes, as
    we will learn in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal
    Control Plane*. It is based on Docker Swarm orchestration, but, as we mentioned
    previously, the core components will run as multi-container applications. The
    master nodes will run the control plane processes. These processes will not run
    on any other node if they fail. It is important to understand that these core
    processes can only run on defined nodes. No other nodes can take these workloads.
    If we have a problem occurring on a master node and we cannot recover the master
    node, we need to create a new master. We will promote a worker node or install
    a new master after removing the old one.
  prefs: []
  type: TYPE_NORMAL
- en: UCP will deploy some distributed databases, and it is important to maintain
    their quorum. We will review a couple of common issues in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*. Remember, UCP manager nodes are very important and
    processes need to run on defined nodes.
  prefs: []
  type: TYPE_NORMAL
- en: All internal cluster communications will be encrypted using TLS. UCP manages
    all nodes, all components, and all their certificates. It will also provide certificates
    for authenticated and authorized users. We can ensure secure client-to-server
    communications by default.
  prefs: []
  type: TYPE_NORMAL
- en: The Kubernetes cluster will also be deployed with the required **Container Network
    Interface** (**CNI**), Calico, by default, and secured configurations. UCP provides
    a production-ready Docker Swarm and Kubernetes platform.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster authentication and authorization will be managed by UCP. We will be
    able to integrate third-party authentication systems, such as **Lightweight Directory
    Access Protocol** (**LDAP**), and Active Directory. All authorization mechanisms
    and implementations are also included in UCP. We can provide a unified login,
    delegating all DTR authentication requests to UCP. This is the usual and preferred
    configuration. UCP provides a complete RBAC system based on resources, roles,
    and grants. We will have high levels of granularity to specify customized access
    to any resource within the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: UCP provides a management web UI and also an API interface to access a cluster's
    resources. We will be able to configure all Docker Swarm and Kubernetes resources.
    For Kubernetes, a simple interface is provided to deploy resources' YAML files.
    We will use the cluster remotely. We will never allow a user access to either
    manager or worker nodes.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to disallow any non-authorized access to cluster nodes.
    Access via SSH to Docker hosts or directly to Docker Engine's daemon will bypass
    all security implementations applied by UCP.
  prefs: []
  type: TYPE_NORMAL
- en: The web UI will also provide some simple monitoring capabilities to verify the
    entire cluster's state. We can review the status of all containers, pods, services,
    and, in general, all resources managed by the cluster. We can also export the
    cluster's metrics using Prometheus' standard integrations. The web UI also provides
    access to container logs, and we can even use them to review the application's
    behavior. All this access will be managed by UCP's RBAC system.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm and Kubernetes will be available through their APIs. Kubernetes
    provides its own RBAC, as we learned in [Chapter 9](abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml),
    *Orchestration Using Kubernetes*. Docker Swarm requires external tools. UCP provides
    these external tools, proxying all API requests to UCP's internal RBAC integration
    and providing appropriate authentication and authorization mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: UCP also provides an integrated component for publishing applications deployed
    within the cluster. This component is Interlock and, at the time of writing this
    book, is based on NGINX. Interlock only works with Docker Swarm deployments, monitoring
    the cluster's API for changes on defined services. We will define which services
    will be published and which headers, names, and routes should be available. All
    changes that are applied to the services will be automatically populated to Interlock's
    reverse proxy component, which will forward requests to the associated backends.
    We will learn about this in more depth in [Chapter 12](ab131f1f-ca6e-4815-9a3a-8c92c93c9dbc.xhtml),
    *Publishing Applications in Docker Enterprise*.
  prefs: []
  type: TYPE_NORMAL
- en: Docker Trusted Registry
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we mentioned when we were talking about CaaS requirements, we need a registry
    to store images. This registry must provide secure access and roles because we
    need some granularity when publishing images. Some users will be owners of their
    images, while others will only use them. We need to ensure image immutability.
    DTR provides this. It is built on top of the open source Docker Registry, but
    many improvements were added to provide an enterprise-ready solution.
  prefs: []
  type: TYPE_NORMAL
- en: DTR provides a secured store for all CaaS/KaaS images. We will be able to ensure
    provenance and immutability. We will also provide different access levels to images.
    Some users will be maintainers of base images, while others will be able to use
    them for their own projects. We also have teams and organizations. We can publish
    images within organizations in a multi-tenant environment, ensuring that all users
    within an organization are able to use their public images. Teams will share image
    maintenance responsibilities, but only some members will be able to modify image
    content.
  prefs: []
  type: TYPE_NORMAL
- en: Because security is key in CaaS environments, DTR will provide image scanning
    and signing. Image scanning will review all images, searching for binary vulnerabilities.
    It will use a **Common Vulnerabilities and Exposures**(**CVE**) database to find
    any vulnerable files. All vulnerable content will be reported and administrators
    will manage these issues within the platform. We can decide to only execute clean
    images; that is, images that are without any reported vulnerabilities. Image signing
    will allow us to forbid any unsigned images into our infrastructure. This ensures
    that we will only execute images that have been created and signed within our
    organization. If an image has been externally modified, it will not be allowed
    to run a container.
  prefs: []
  type: TYPE_NORMAL
- en: DTR can also be integrated into a CI/CD pipeline, along with its image promotion
    features. Image tags can be modified with triggers. This process can also tell
    external applications to track and help us implement special stages in our deployment
    workflow. Images are the new code artifacts for applications and we can integrate
    DTR in our CI/CD pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will describe a minimal environment for production using
    Docker Enterprise Edition.
  prefs: []
  type: TYPE_NORMAL
- en: Planning your Docker Enterprise deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker Enterprise provides a production-ready CaaS platform, as we have been
    discussing throughout this chapter. In this section, we will review the minimum
    logical requirements for deploying Docker Enterprise in production.
  prefs: []
  type: TYPE_NORMAL
- en: We learned that Docker Swarm and Kubernetes require an odd number of master
    nodes to work properly. Docker Swarm does not require an external key-value store,
    while Kubernetes does. Docker Enterprise will deploy this key-value store with
    UCP, so a minimum of three manager nodes will be required to provide high availability.
    All managers will run the same services. In Docker Swarm and Kubernetes, we have
    a leader node that writes cluster changes in the database. Other managers will
    sync their data, but we can also run administration commands on any of them. We
    need to integrate an external load balancer to distribute API requests on all
    manager nodes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, three nodes only protect the cluster if one of them fails. The cluster
    will work fine with two manager nodes, but if another one fails, the cluster will
    become inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: 'UCP requires at least three manager nodes. But what about DTR? This component
    has its own distributed database: it uses **R****ethinkDB**. This database also
    requires an odd number of replicas; therefore, three nodes will be required. DTR
    will be deployed on worker nodes using a multi-container architecture. We can
    then say that we will need at least three worker nodes for DTR. Image scanning
    can consume a lot of CPU resources, and it is recommended to isolate DTR nodes
    from other worker nodes to avoid application impact. A DTR cluster requires shared
    storage between nodes because only the node receiving the application''s requests
    will write changes to the database. But all nodes must write to the same storage
    location, so shared storage is required. We will use an external load balancer
    in front of DTR''s API to distribute requests between service nodes.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will add workers to this platform as needed. In fact, we will start with
    a minimum of two worker nodes for high availability. All application workloads
    must have resilience; hence, a minimum of two nodes for Windows and Linux workloads
    will be required if we deploy on both architectures. The following diagram represents
    the described scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8cc0a9be-946f-468e-b835-0f84e645bb24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will use fixed IP addresses for the manager and worker nodes. This is preferred,
    although worker nodes can be deployed using DHCP. We will isolate the control
    plane from the data plane, as we discussed in [Chapter 8](78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml),
    *Orchestration Using Docker Swarm*. The data plane will be used for applications,
    while the control plane will be used for internal cluster communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Calico will be used by default as the Kubernetes CNI, and it is important to
    check for any possible IP range conflicts. The following table shows the default
    IP addresses used for Docker Engine, Docker Swarm, and Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Component** | **Subnet** | **Range** | **Default IP address** |'
  prefs: []
  type: TYPE_TB
- en: '| Engine | `fixed-cidr` | CIDR range for the `docker0` interface and local
    containers | `172.17.0.0/16` |'
  prefs: []
  type: TYPE_TB
- en: '| Engine | `default-address-pools` | CIDR range for the `docker_gwbridge` interface
    and bridge networks | `172.18.0.0/16` |'
  prefs: []
  type: TYPE_TB
- en: '| Swarm | `default-addr-pool` | CIDR range for Docker Swarm overlay networks
    | `10.0.0.0/8` |'
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes | `pod-cidr` | CIDR range for Kubernetes pods | `192.168.0.0/16`
    |'
  prefs: []
  type: TYPE_TB
- en: '| Kubernetes | `service-cluster-ip-range` | CIDR range for Kubernetes services
    | `10.96.0.0/16` |'
  prefs: []
  type: TYPE_TB
- en: 'To avoid any firewall issues, take a look at the following link, which describes
    some of the configurations required on some Linux platforms: [https://docs.docker.com/ee/ucp/admin/install/plan-installation](https://docs.docker.com/ee/ucp/admin/install/plan-installation).'
  prefs: []
  type: TYPE_NORMAL
- en: We will use **Fully Qualified Domain Names** (**FQDNs**) for the virtual IP
    addresses associated with UCP/Kubernetes and DTR APIs.
  prefs: []
  type: TYPE_NORMAL
- en: We will review all required ports in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*, and [Chapter 13](108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml),
    *Implementing an Enterprise-Grade Registry with DTR*. But clients consume cluster
    services using specific exposed ports. By default, UCP and DTR will expose their
    APIs and web UI on port `443`, while Kubernetes will be exposed on port `6443`.
  prefs: []
  type: TYPE_NORMAL
- en: We will usually require internet access during product installation, although
    we can execute an offline installation. Internet access is needed for DTR if we
    need to provide automatic image-scanning database synchronization. We can download
    a compressed database file from Docker's site once a week, for example, to avoid
    this required connectivity.
  prefs: []
  type: TYPE_NORMAL
- en: Licensing processes can also be automated, and subscription renewal can synchronize
    product licenses before they expire.
  prefs: []
  type: TYPE_NORMAL
- en: This was a brief description of the deployment of Docker Enterprise components
    to production. We will cover these components in more depth in the following chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we provided an introduction to the Docker Enterprise platform.
    We reviewed the main differences between Docker Community tools and Docker Enterprise
    products.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the concepts of the CaaS and KaaS platforms. We looked at what
    we should expect from these platforms and how different manufacturers and cloud
    providers deploy their implementations.
  prefs: []
  type: TYPE_NORMAL
- en: We also described the most important features of Docker Enterprise, namely Docker
    Enterprise Engine, UCP, and DTR. These components provide Docker's CaaS solution.
    With that, we've covered the most important things to consider when planning a
    Docker Enterprise production environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore UCP in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of these components is not part of the Docker Enterprise platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) DTR.
  prefs: []
  type: TYPE_NORMAL
- en: b) Docker Enterprise Engine.
  prefs: []
  type: TYPE_NORMAL
- en: c) Docker Machine.
  prefs: []
  type: TYPE_NORMAL
- en: d) All of these are part of the Docker Enterprise platform.
  prefs: []
  type: TYPE_NORMAL
- en: Which of these statements are true about Docker Community and Docker Enterprise?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Docker Enterprise provides an enterprise-ready platform.
  prefs: []
  type: TYPE_NORMAL
- en: b) We cannot deploy Docker Swarm to production.
  prefs: []
  type: TYPE_NORMAL
- en: c) Kubernetes is not supported in Docker Enterprise; only Docker Swarm is supported.
  prefs: []
  type: TYPE_NORMAL
- en: d) Docker Registry is an enterprise-ready registry.
  prefs: []
  type: TYPE_NORMAL
- en: Which Docker components are required to deploy a KaaS solution?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Docker Enterprise Engine.
  prefs: []
  type: TYPE_NORMAL
- en: b) UCP.
  prefs: []
  type: TYPE_NORMAL
- en: c) Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: d) DTR.
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following statements are true for deploying a Docker Enterprise
    environment?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We use fixed IP addresses for manager nodes only.
  prefs: []
  type: TYPE_NORMAL
- en: b) We just route traffic to one of the manager nodes.
  prefs: []
  type: TYPE_NORMAL
- en: c) We need to deploy a CNI after UCP completes the Kubernetes installation.
  prefs: []
  type: TYPE_NORMAL
- en: d) None of the above.
  prefs: []
  type: TYPE_NORMAL
- en: What is the minimum number of nodes required to execute Linux workloads on a
    Docker Enterprise platform with high availability?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We need to deploy three managers, three workers with DTR, and one Linux worker
    with enough resources to run all workloads.
  prefs: []
  type: TYPE_NORMAL
- en: b) We need to deploy three managers with DTR running on them and two Linux workers.
  prefs: []
  type: TYPE_NORMAL
- en: c) We need to deploy three managers, three workers with DTR, and two Linux workers.
  prefs: []
  type: TYPE_NORMAL
- en: d) All these options are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can refer to the following references for more information about the topics
    that were covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Introduction to Docker Enterprise: [https://docs.docker.com/ee/](https://docs.docker.com/ee/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Docker Enterprise components: [https://docs.docker.com/ee/docker-ee-architecture/](https://docs.docker.com/ee/docker-ee-architecture/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mirantis Docker Enterprise website: [https://www.mirantis.com/software/docker/docker-enterprise/](https://www.mirantis.com/software/docker/docker-enterprise/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Mirantis Docker acquisition: [https://www.mirantis.com/company/press-center/company-news/mirantis-acquires-docker-enterprise/](https://www.mirantis.com/company/press-center/company-news/mirantis-acquires-docker-enterprise/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
