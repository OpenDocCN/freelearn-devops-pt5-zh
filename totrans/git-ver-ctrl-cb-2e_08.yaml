- en: Recovering from Mistakes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Undo – Remove a commit completely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo – Remove a commit and retain changes to files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo – Remove a commit and retain changes in the staging area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo – Working with a dirty area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redo – Recreate the latest commit with new changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Revert – Undo the changes introduced by a commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reverting a merge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing past Git actions with git reflog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finding lost changes with git fsck
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to correct mistakes made in Git with git push context (without
    exposing them if the mistake is found before sharing or publishing the change).
    If the mistake has already been pushed, it is still possible to undo the changes
    made to the commit that introduced the mistake.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the `reflog` command and how we can use that and `git fsck`
    to recover lost information.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no git undo command in core Git, one of the reasons being ambiguity
    on what needs to be undone, for example, and the last commit, the added file.
    If you want to undo the last commit, how should that be done? Should the changes
    introduced to the files by the commit be deleted? For instance, do you just roll
    back to the last known good commit, or should they be kept so that it could be
    changed for a better commit? Should the commit message simply be reworded? In
    this chapter, we''ll explore the possibilities for undoing a commit in several
    ways, depending on what we want to achieve. We''ll explore four ways to undo a
    commit:'
  prefs: []
  type: TYPE_NORMAL
- en: Undo everything, just remove the last commit as if it never happened
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo the commit and unstage the files; this takes us back to where we were before
    we started to add the files
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo the commit, but keep the files in the index or staging area so that we
    can just perform some minor modifications and then complete the commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Undo the commit with the dirty work area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `undo` and `redo` commands in this chapter are performed on commits that
    are already published in the example repository. You should usually not perform
    the undo and redo commands on commits that are already published in a public repository,
    as you will be rewriting history. However, in the following recipes, we'll use
    an example repository and execute the operations on published commits so that
    everyone has the same experience.
  prefs: []
  type: TYPE_NORMAL
- en: Undo – Remove a commit completely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this example, we'll learn how we can undo a commit as if it had never happened.
    We'll learn how we can use the reset command to effectively discard the commit
    and thereby reset our branch to the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we''ll use the example of the `Git-Version-Control-Cookbook-Second-Edition_hello_world_cookbook` repository,
    clone the repository, and change our working directory to the cloned one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll try to undo the latest commit in the repository as though it
    never happened:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll make sure that our working directory is clean, no files are in the modified
    state, and nothing is added to the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, check what is in our working tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If all works well, we''ll check the log to see the history of the repository.
    We''ll use the `--oneline` switch to limit the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The most recent commit is the `3061dc6 Adds Java version of ''hello world''`
    commit. We will now undo the commit as though it never happened, and the history
    won''t show it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the log, status, and filesystem, so that you can see what actually happened:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The commit is now gone, along with all the changes it introduced (`Makefile`
    and `HelloWorld.java`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the last output of the `git status` command, you can see that our master
    branch is one behind `origin/master`. This is similar to what we mentioned at
    the beginning of the chapter, because we are removing and undoing commits that
    are already published. Also, as mentioned, you should only perform the undo and
    redo (`git reset`) operations on commits that are not shared yet. Here, we only
    show it on the published commits to make the example easy to reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Effectively, we are just changing the pointer of the master branch to point
    to the previous commit **HEAD**, which means the first parent of **HEAD**. Now,
    the branch will point to **9c7532f**, instead of the commit we removed, **35b29ae**.
    This is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6bc11ec6-a125-4d99-8567-48ab1e4e0b93.png)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram also shows that the original **3061dc6** commit is still
    present in the repository, but new commits on the master branch will start from
    **9c7532f**; the **3061dc6** commit is called a dangling commit.
  prefs: []
  type: TYPE_NORMAL
- en: You should only perform this undo operation on commits you haven't shared (pushed)
    yet, since when you create new commits following undo or reset, those commits
    form a new history that will diverge from the original history of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: When the reset command is executed, Git looks at the commit pointed to by **HEAD** and
    finds the parent commit from this. The current branch, master, and the **HEAD** pointer,
    are then reset to the parent commit, as are the staging area and working tree.
  prefs: []
  type: TYPE_NORMAL
- en: Undo – Remove a commit and retain changes to files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of performing the hard reset and thereby losing all the changes the
    commit introduced, the reset can be performed so that the changes are retained
    in the working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll again use the example of the hello world repository. Make a fresh clone
    of the repository, or reset the master branch if you have already cloned one.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can make a fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can reset the existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll check whether we have made any changes to files in the working
    tree (just for the clarity of the example) and the history of the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we''ll undo the commit and retain the changes introduced to the working
    tree:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our commit has been undone, but the changes to the file are
    preserved in the working tree, so more work can be done in order to create a proper
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From the parent commit pointed to by the commit at **HEAD**, Git resets the
    branch pointer and **HEAD** to point to the parent commit. The staging area is
    reset, but the working tree is kept as it was before the reset, so the files affected
    by the `undone` commit will be in a modified state. This is illustrated in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e13784eb-69eb-47d4-8e68-60a67c7ce54f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `--mixed` option is the default behavior of `git reset`, so it can be omitted:
    `git reset HEAD^`'
  prefs: []
  type: TYPE_NORMAL
- en: Undo – Remove a commit and retain changes in the staging area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, it is also possible to undo the commit, but keep the changes to the
    files in the index or the staging area so that you are ready to recreate the commit
    with, for example, some minor modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll still use the example of the hello world repository. Make a fresh clone
    of the repository, or reset the master branch if you have already cloned one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset the existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Check whether we have any files in the modified state and check the log:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can undo the commit, while retaining the changes in the index:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can now make minor (or major) changes to the files you need, add them to
    the staging area, and create a new commit.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, Git will reset the branch pointer and **HEAD** to point to the previous
    commit. However, with the `--soft` option, the index and working directories are
    not reset, that is, they have the same state as they had before we created the
    now undone commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the Git state before and after the undo:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bc521cd-e084-4f77-a755-a04c4fcb7677.png)'
  prefs: []
  type: TYPE_IMG
- en: Undo – Working with a dirty area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, we assumed that the working tree was clean, that is,
    no tracked files were in the modified state. However, this is not always the case,
    and if a hard reset is carried out, the changes to the modified files will be
    lost. Fortunately, Git provides a smart way to quickly put stuff away so that
    it can be retrieved later using the `git stash` command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we'll use the example of the hello world repository. Make a fresh clone
    of the repository, or reset the master branch if you have already cloned one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset the existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also need to have some files in the working condition, so we''ll change
    `hello_world.c` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to not accidentally delete any changes you have in your working tree
    when you are about to undo a commit, you can have a look at the current state
    of your working directory with `git status` command (as we already saw). If you
    have changes and you want to keep them, you can stash them away before undoing
    the commit and retrieve them afterward. Git provides a stash command that can
    put unfinished changes away, so it is easy to make quick context switches without
    losing work. The stash functionality is described further in [Chapter 11](ea1a1df3-bda4-4d35-b7de-67e38d18bcb0.xhtml),
    *Tips and Tricks*. For now, you can think of the stash command as a stack where
    you can put your changes and pop them later.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `hello_world.c` file in the working directory modified to the preceding
    state, we can try to do a hard reset on the `HEAD` commit, keeping our changes
    to the file by stashing them away before the reset and applying them again later:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check the history:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, check the status:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'As expected, `hello_world.c` was in the modified state; so, stash it away,
    check the status, and perform the reset:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The reset is done, and we got rid of the commit we wanted. Let''s resurrect
    the changes we stashed away and check the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, the file is back to the state it was in before the reset, and we got rid
    of the unwanted commit.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The reset command works as explained in the previous examples but, combined
    with the stash command, it forms a very useful tool that corrects mistakes even
    though you have already starting working on something else. The stash command
    works by saving the current state of your working directory and the staging area.
    Then, it reverts your working directory to a clean state.
  prefs: []
  type: TYPE_NORMAL
- en: Redo – Recreate the latest commit with new changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with undo, redo can mean a lot of things. In this context, redoing a commit
    will mean creating almost the same commit again with the same parent(s) as the
    previous commit, but with different content and/or different commit messages.
    This is quite useful if you've just created a commit, but have perhaps forgotten
    to add a necessary file to the staging area before you committed, or if you need
    to reword the commit message.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we'll use the hello world repository. Make a fresh clone of the repository,
    or reset the master branch if you have already cloned one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset an existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's pretend we need to redo the latest commit because we need to reword the
    commit message to include a reference to the issue tracker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first take a look at the latest commit and make sure the working directory
    is clean:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can redo the commit and update the commit message with the git commit
    `--amend` command. This will bring up the default editor, and we can add a reference
    to the issue tracker in the commit message (`Fixes: RD-31415`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check the log again to see whether everything worked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see that the commit message has changed, but we can''t verify from the
    log output that the parent of the commit is the same as in the original commit,
    and so on, as we saw in the first commit we did. To check this, we can use the `git
    cat-file` command we learned about in [Chapter 1](b475c6bd-71df-4b49-8062-57d065b83f51.xhtml),
    *Navigating Git*. First, let''s see how the original commit looked:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The parent commit is `b8c39bb35c4c0b00b6cfb4e0f27354279fb28866`, and the root
    tree is `d3abe70c50450a4d6d70f391fcbda1a4609d151f`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the data from the new commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The parent is the same, that is, `9c7532f5e788b8805ffd419fcf2a071c78493b23`
    and the root tree is also the same, that is, `d3abe70c50450a4d6d70f391fcbda1a4609d151f`.
    This is what we expected as we only changed the commit message. If we had added
    some changes to the staging area and executed `git commit--amend`, we would have
    included those changes in the commit and the root-tree SHA1 ID would have been
    different, but the parent commit ID still the same.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `--amend` option to git commit is roughly equivalent to performing `git
    reset --soft HEAD^`, followed by fixing the files needed and adding those to the
    staging area. Then, we will run git commit reusing the commit message from the
    previous commit (`git commit -c ORIG_HEAD`).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also use the `--amend` method to add missing files to our latest commit.
    Let's say you needed to add the `README.md` file to your latest commit in order
    to get the documentation up to date, but you have already created the commit,
    though you have not pushed it yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'You then add the file to the index as you would while starting to craft a new
    commit. You can check with git status that only the `README.md` file is added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can amend the latest commit with `git commit --amend`. The command
    will include files in the index in the new commit and you can, as with the last
    example, reword the commit message if needed. It is not needed in this example,
    so we''ll pass the `--no-edit` option to the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the output of the commit command that three files were changed
    and `README.md` was one of them.
  prefs: []
  type: TYPE_NORMAL
- en: You can also reset the author information (name, email, and timestamp) with
    the commit `--amend` command. Just pass along the `--reset-author` option and
    Git will create a new timestamp and read author information from the configuration
    or environment, instead of the using information from the old commit object.
  prefs: []
  type: TYPE_NORMAL
- en: Revert – Undo the changes introduced by a commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Revert can be used to undo a commit in history that has already been published
    (pushed), whereas this can't be done with the amend or reset options without rewriting
    history.
  prefs: []
  type: TYPE_NORMAL
- en: Revert works by applying the anti-patch introduced by the commit in question.
    A revert will, by default, create a new commit in history with a commit message
    that describes which commit has been reverted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we'll use the hello world repository. Make a fresh clone of the repository,
    or reset the master branch if you have already cloned one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset the existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll list the commits in the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll revert the second commit, `9c7532f`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'When we check the log, we can see that a new commit has been made:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We can take a closer look at the two commits with `git show` if we want a closer
    investigation of what happened.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git revert` command applies the anti-patch of the commit in question to
    the current `HEAD` pointer. It will generate a new commit with the anti-patch
    and a commit message that describes the reverted commit(s).
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's possible to revert more than one commit in a single revert, for example,
    `git revert master~6..master~2` will revert the commits from the sixth commit
    from the bottom in the master to the third commit from the bottom in the master
    (both included).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible not to create a commit while reverting; passing the `-n`
    option to `git revert` will apply the needed patched, but only to the working
    tree and the staging area.
  prefs: []
  type: TYPE_NORMAL
- en: Reverting a merge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Merge commits are a special case when it comes to revert. In order to be able
    to revert a merge commit, you'll have to specify which parent side of the merge
    you want to keep. However, when you revert a merge commit, you should keep in
    mind that though reverting will undo changes to files, it doesn't undo history.
    This means that when you revert a merge commit, you declare that you will not
    have any of the changes introduced by the merge in the target branch.
  prefs: []
  type: TYPE_NORMAL
- en: The effect of this is that the subsequent merges from the other branch will
    only bring in changes of commits that are not ancestors of the reverted merge
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e5563b1-ec5c-4e9f-a13b-89d952260338.png)'
  prefs: []
  type: TYPE_IMG
- en: In this example, we will learn how to revert a merge commit, and we'll learn
    how we can merge the branch again, merging all of the changes by reverting to
    the reverted merge commit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we'll use the hello world repository. Make a fresh clone of the repository,
    or reset the master branch if you have already cloned one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset the existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we also need to use some of the other branches in the repository,
    so we need to create them locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On the develop branch, we have just checked that there is a merge commit that
    introduces hello world programs from languages that start with P.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unfortunately, the Perl version doesn''t run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The following steps will help you revert a merge:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the history, the latest five commits, and find the merge
    commit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The commit we are looking for is `5ae3beb Merge branch ''feature/p-lang'' into
    develop`; this adds the commits for hello world in Perl and PHP to the develop
    branch. We would like the fix of the Perl version to happen on the feature branch,
    and then merge it to develop when ready. In order to keep `develop` stable, we
    need to revert the merge commit that introduced the faulty Perl version. Before
    we perform the merge, let''s just have a look at the content of `HEAD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Revert the merge, keeping the history of the first parent:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the content of our new `HEAD` state:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Perl and PHP files introduced in the merge are gone, so the revert did its
    job.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The revert command will take the patches introduced by the commit you want to
    revert and apply the reverse/anti-patch to the working tree. If all goes well,
    that is, there are no conflicts, a new commit will be made. While reverting a
    merge commit, only the changes introduced in the mainline (the `-m` option) will
    be kept, and all the changes introduced in the other side of the merge will be
    reverted.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Though it is easy to revert a merge commit, you might run into issues if you
    later want to the branch again because the issues on the merge have not been fixed.
    While reverting the merge commit, you actually tell Git that you do not want any
    of the changes that the other branch introduced in this branch. So, when you try
    to merge in the branch again, you will only get the changes from the commits that
    are not ancestors of the reverted merge commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will see this in action by trying to merge the `feature/p-lang` branch with
    the develop branch again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can solve the conflict just by adding `hello_world.pl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the tree to see whether everything seems alright:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The `hello_world.php` file is missing, but this makes sense as the change that
    introduced it was reverted in the reverted merge commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform a proper re-merge, we first have to revert the reverting merge commit;
    this might seem a bit weird, but it is the way to get the changes from before
    the revert back into our tree. Then, we can perform another merge of the branch,
    and we''ll end up with all the changes introduced by the branch we''re merging
    in. However, we first have to discard the merge commit we just made with a hard
    reset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can revert the reverting merge and re-merge the branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check the tree for the Perl and PHP files, and see whether the Perl
    file has been fixed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For more information on reverting merges, refer to the following articles:'
  prefs: []
  type: TYPE_NORMAL
- en: The *How To Revert a Faulty Merge* article at [https://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.html](https://www.kernel.org/pub/software/scm/git/docs/howto/revert-a-faulty-merge.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Undoing Merges* article at [http://git-scm.com/blog/2010/03/02/undoing-merges.html](http://git-scm.com/blog/2010/03/02/undoing-merges.html)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Viewing past Git actions with git reflog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `reflog` command stores information on updates to the tip of the branches
    in Git, where the normal `git log` command shows the ancestry chain from `HEAD`,
    and the `reflog` command shows what `HEAD` has pointed to in the repository. This
    is your history in the repository, which tells you how you have moved between
    branches, created your commits and resets, and so on. Basically, anything that
    makes `HEAD` point to something new is recorded in the `reflog`. This means that,
    by going through the `reflog` command, you can find lost commits that none of
    your branches or other commits point to. This makes the `reflog` command a good
    starting point for trying to find a lost commit.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we'll use the hello world repository. If you make a fresh clone, make
    sure to run the scripts for this chapter so that there will be some entries in
    the `reflog` command.
  prefs: []
  type: TYPE_NORMAL
- en: The scripts can be found on the book's home page. If you just reset the master
    branch to `origin/master` after performing the recipes in this chapter, everything
    will be ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset an existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s try to run the `reflog` command and limit ourselves to just the latest seven
    entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: In your repository, the commits will have different SHA-1 hashes due to the
    fact that the commits generated in the examples will have slightly different content,
    specifically your username and email address, but the order should be approximately
    the same.
  prefs: []
  type: TYPE_NORMAL
- en: We can see the actions we performed in the last example by reverting, committing,
    and resetting. We can see the merge commit, `2804731`, that we abandoned. It didn't
    merge in all the changes we wanted it to due to the previous merge and its revert.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take a closer look at the commit with `git show`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Indeed, this was the commit we chose to abandon in the previous example. We
    can also look at the tree of the commit, just as we did in the previous example,
    and check whether they are the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: From here, there are various ways to resurrect the changes. You can either check
    out the commit and create a branch; then, you'll have a pointer so that you can
    easily find it again. You can also check out specific files from the commit with
    `git checkout` – `path/to/file SHA-1`, or you can use the `git show` or `git cat-file`
    commands to view the files.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For every movement of the `HEAD` pointer in the repository, Git stores the commit
    pointed to and the action for getting there. This can be commit, checkout, reset,
    revert, merge, rebase, and so on. The information is local to the repository and
    is not shared on pushes, fetches, and clones. Using the `reflog` command to find
    the lost commits is fairly easy if you know what you are searching for and the
    approximate time when you created the commit you are searching for. If you have
    a lot of reflog history, many commits, switching branches, and so on, it can be
    hard to search through the `reflog` command due to the amount of noise from the
    many updates to `HEAD`. The output of the `reflog` command can be a lot of options
    and, among them, there are options you can also pass on to the normal `git log`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Finding lost changes with git fsck
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another tool exists in Git that can help you find and recover lost commits and
    even blobs (files), which is `git fsck`. The `fsck` command tests the object database
    and verifies the SHA-1 ID of the objects and the connections they make. This command
    can also be used to find objects that are not reachable from any named reference,
    as it tests all the objects found in the database, which are in the `.git/objects`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, we'll use the hello world repository. If you make a fresh clone, make
    sure to run the scripts for this chapter (`04_undo_dirty.sh`), so there will be
    some objects for `git fsck` to consider. The scripts can be found on the book's
    home page. If you just reset the master branch after performing the other recipes
    in the chapter, everything will be ready.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create the fresh clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reset an existing clone as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look for the unreachable objects in the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The object's ID, the SHA-1 hash, will not be the same if you perform the example
    on your computer, as the committer, author, and timestamp will be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'We found two commits and one blob. Let''s take a closer look at each of them;
    the blob first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: So, the blob is the `hello_world.c` file from the example, which stashes away
    your changes before resetting a commit. Here, we stashed away the file, performed
    a reset, and resurrected the file from the stash, but we never actually performed
    a commit. The stash command, however, did add the file to the database, so it
    could find it again, and the file will continue to be there until the garbage
    collection kicks in, or forever if it is referenced by a commit in the general
    history.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look more closely at the two commits:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Both of the commits are actually commits we made when we stashed away our changes
    in the previous example. The stash command creates a commit object with the content
    of the staging area, and a merge commit merging `HEAD` and the commit with the
    index with the content of the working directory (tracked files only). As we resurrected
    our stashed changes in the previous example, we no longer have any reference pointing
    at the preceding commits; therefore, they are found by `git fsck`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git fsck` command will test all the objects found in the `.git/objects`
    folder. When the `--unreachable` option is given, it will report the objects found
    that can't be reached from another reference; a reference can be a branch, a tag,
    a commit, a tree, the `reflog`, or changes that have been stashed away.
  prefs: []
  type: TYPE_NORMAL
