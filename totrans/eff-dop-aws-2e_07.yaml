- en: Running Containers in AWS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 AWS 上运行容器
- en: In [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your Infrastructure*,
    our architecture changed quite a bit. We explored different ways to scale our
    applications in AWS, but one of the major technologies that we left out was containers.
    Containers are at the heart of the **software development life cycle** (**SDLC**)
    of many major technology companies.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第六章](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml)《**扩展你的基础架构**》中，我们的架构发生了很大的变化。我们探索了在
    AWS 中扩展应用程序的不同方法，但我们遗漏的一个主要技术就是容器。容器是许多大型科技公司**软件开发生命周期**（**SDLC**）的核心。
- en: So far, we have used our personal computers to develop our applications. This
    works well for simple projects, such as our Hello World application. However,
    when it comes to more complex projects with many dependencies, it's a different
    story. Have you ever heard of situations in which a certain feature works on a
    developer's laptop but does not work for the rest of the organization-or-even
    worse, *does not work in production?* A lot of these issues stem from the differences
    between environments. When we build our staging and production environments, we
    rely on CloudFormation, Terraform, and Ansible, to keep those environments consistent.
    Unfortunately, we can't easily replicate that to our local development environment.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直使用个人电脑来开发应用程序。这对于简单的项目，如我们的 Hello World 应用程序，效果很好。然而，当涉及到有许多依赖关系的复杂项目时，情况就不同了。你是否听说过某些功能在开发者的笔记本电脑上运行正常，但在其他组织成员那里却无法运行——甚至更糟的是，*在生产环境中无法运行*？这些问题中的很多源于环境之间的差异。当我们构建我们的预发布和生产环境时，我们依赖
    CloudFormation、Terraform 和 Ansible 来保持这些环境的一致性。不幸的是，我们无法轻松地将其复制到本地开发环境中。
- en: Containers address this issue. With them, we can package an application and
    include the operating system, the application code, and everything in between.
    Containers can also help at a later stage, when it's time to break out the monolithic
    approach.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 容器解决了这个问题。通过容器，我们可以打包一个应用程序，并包括操作系统、应用程序代码以及中间所有的内容。容器还可以在稍后的阶段提供帮助，当需要突破单体架构时尤为重要。
- en: 'In this chapter, we will look at **Docker**, the most popular container technology.
    After a brief explanation of what Docker is and how to use its basic functionalities,
    we will Dockerize our application. This will help us to understand the value of
    using Docker as a developer. In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**Docker**，最受欢迎的容器技术。在简要说明 Docker 是什么以及如何使用其基本功能后，我们将对我们的应用程序进行 Docker
    化。这将帮助我们理解作为开发者使用 Docker 的价值。本章将涵盖以下主题：
- en: Dockerizing our Hello World application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的 Hello World 应用程序 Docker 化
- en: Using the EC2 container service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 EC2 容器服务
- en: Updating our CI/CD pipeline to utilize ECS
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新我们的 CI/CD 管道以使用 ECS
- en: This book covers ECS, but also offers further options for using Docker in AWS.
    You can also take a look at CoreOS Tectonic ([https://tectonic.com/](https://tectonic.com/)),
    Mesosphere DC/OS ([https://mesosphere.com](https://mesosphere.com/)), or Docker
    Datacenter ([https://www.docker.com/products/docker-datacenter](https://www.docker.com/products/docker-datacenter)).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本书涵盖了 ECS，但还提供了在 AWS 中使用 Docker 的更多选项。你还可以查看 CoreOS Tectonic（[https://tectonic.com/](https://tectonic.com/)）、Mesosphere
    DC/OS（[https://mesosphere.com](https://mesosphere.com/)）或 Docker Datacenter（[https://www.docker.com/products/docker-datacenter](https://www.docker.com/products/docker-datacenter)）。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The technical requirements for this chapter are as follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的技术要求如下：
- en: Docker
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker
- en: Dockerfile
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dockerfile
- en: '**EC2 Container Registry** (**ECR**)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**EC2 容器注册表**（**ECR**）'
- en: '**Elastic Container Service** (**ECS**)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**弹性容器服务**（**ECS**）'
- en: '**Application Load Balancer** (**ALB**)'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用负载均衡器**（**ALB**）'
- en: CodeBuild
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodeBuild
- en: CodePipeline
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CodePipeline
- en: 'The GitHub links for the code used in this chapter are as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中使用的代码的 GitHub 链接如下：
- en: '[https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)'
- en: '[https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json)'
- en: '[https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile)'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py)'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py)'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py)'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py)'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py)'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py)'
- en: '[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py](https://raw.githubusercontent.com/yogeshraheja/EffectiveDevOpsTemplates/master/helloworld-ecs-service-cf-template.py)'
- en: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py)'
- en: Dockerizing our Hello World application
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的 Hello World 应用程序 Docker 化
- en: Docker, and containers in general, are very powerful tools, worth exploring.
    By combining resource isolation features, including **union capable filesystem**
    (**UCF**), Docker allows for the creation of packages called **containers**, which
    include everything that is needed to run an application. Containers, like virtual
    machines, are self-contained, but they virtualize the OS itself, instead of virtualizing
    the hardware. In practice, this makes a huge difference. As you have probably
    noticed by now, starting a virtual machine, such as an EC2 instance, takes time.
    This comes from the fact that in order to start a virtual machine, the hypervisor
    (that's the name of the technology that creates and runs virtual machines) has
    to simulate all of the motions involved in starting a physical server, loading
    an operating system, and going through the different run-levels. In addition,
    virtual machines have a much larger footprint on the disk and in the memory. With
    Docker, the added layer is hardly noticeable, and the size of the containers can
    stay very small. In order to better illustrate this, we will first install Docker
    and explore its basic usage a bit.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 和容器总体来说是非常强大的工具，值得深入探索。通过结合资源隔离功能，包括**联合能力文件系统**（**UCF**），Docker 允许创建称为**容器**的包，这些容器包含运行应用程序所需的所有内容。容器像虚拟机一样是自包含的，但它们虚拟化的是操作系统本身，而不是硬件。实际上，这带来了巨大的差异。正如你现在可能已经注意到的那样，启动虚拟机（例如
    EC2 实例）需要一定的时间。这是因为为了启动虚拟机，虚拟机监控器（这是创建和运行虚拟机的技术名称）必须模拟启动物理服务器、加载操作系统并通过不同运行级别所涉及的所有动作。此外，虚拟机在磁盘和内存上占据更大的空间。使用
    Docker 时，附加的层几乎不可察觉，而且容器的大小可以保持非常小。为了更好地说明这一点，我们将首先安装 Docker，并稍微了解其基本用法。
- en: Getting started with Docker
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门 Docker
- en: Before we start to use Docker, it might be useful to better understand Docker's
    concept and architecture. First, we will discuss Docker's fundamental changes
    with regards to the SDLC. Following that introduction, we will install Docker
    on our computers and look at some of the most common commands needed to use Docker.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始使用 Docker 之前，最好先更好地理解 Docker 的概念和架构。首先，我们将讨论 Docker 在 SDLC 中的基本变化。介绍之后，我们将在计算机上安装
    Docker，并学习一些使用 Docker 时最常用的命令。
- en: Docker fundamentals
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 基础
- en: 'The best way to understand how Docker works is to compare how using Docker
    differs from what we''ve done so far:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Docker 工作原理的最好方法是比较使用 Docker 与我们迄今为止所做的事情有什么不同：
- en: '![](img/c68877c6-26c3-4a77-a641-937b0f365231.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c68877c6-26c3-4a77-a641-937b0f365231.png)'
- en: 'The preceding diagram can be explained as follows:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的图示可以解释如下：
- en: The first stack on the left represents what we did so far. Using the EC2 service,
    we picked an AMI providing AWS Linux, and, with the help of the user data field,
    we installed Ansible to configure our system. When Ansible kicks in, it installs
    and configures the system, so that later, CodeDeploy can deploy and run our application.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 左侧的第一个堆栈表示我们迄今为止所做的工作。使用 EC2 服务，我们选择了提供 AWS Linux 的 AMI，并借助用户数据字段安装了 Ansible
    来配置我们的系统。当 Ansible 启动时，它会安装并配置系统，以便稍后 CodeDeploy 可以部署并运行我们的应用程序。
- en: The middle stack represents what it means to use Docker on top of EC2\. The
    process starts the same way with an AMI running AWS Linux. However, this time,
    instead of relying on Ansible and CodeDeploy, we will simply install the Docker
    server application. After that, we will deploy Docker containers, which will have
    everything that was previously provided by Ansible and CodeDeploy.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间的堆栈表示在 EC2 上使用 Docker 的含义。这个过程的开始方式与使用运行 AWS Linux 的 AMI 相同。然而，这次，我们不再依赖 Ansible
    和 CodeDeploy，而是直接安装 Docker 服务器应用程序。之后，我们将部署 Docker 容器，这些容器将包含之前由 Ansible 和 CodeDeploy
    提供的所有内容。
- en: Finally, the big win of that architecture is what we see on the last stack on
    the right. No matter what the underlying technology is, as long as we can run
    a Docker server, we can run the exact same container. This means that we can easily
    test what we will deploy on EC2\. Similarly, if an issue happens in a container
    running on an EC2 instance, we can pull the exact same container and run it locally
    to possibly troubleshoot the issue.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，这种架构的巨大优势在于我们在右侧最后一个堆栈中看到的内容。无论底层技术是什么，只要我们能运行 Docker 服务器，就能运行完全相同的容器。这意味着我们可以轻松地测试将要部署到
    EC2 上的内容。类似地，如果一个 EC2 实例上的容器出现问题，我们可以拉取完全相同的容器并在本地运行，以便可能排除问题。
- en: 'In order to make that happen, Docker relies on a couple of key concepts, as
    shown in the following diagram:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，Docker 依赖于几个关键概念，如下图所示：
- en: '![](img/87dc7058-dd1d-4f80-a35d-4ac2568dce89.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87dc7058-dd1d-4f80-a35d-4ac2568dce89.png)'
- en: At its core, Docker runs a daemon that loads images (templates describing the
    stack of the application, including the operating system, application code, and
    everything in between) and runs them in self-contained directories called containers.
    When working in Docker, as a developer, your work mostly consists of building
    new images by layering new commands on top of pre-existing images. Images are
    stored in external registries. Those registries can be public or private. Finally,
    all the interaction is done through a RESTful API, usually using the command-line
    interface.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，Docker 运行一个守护进程，该进程加载镜像（描述应用栈的模板，包括操作系统、应用代码以及中间的一切）并在名为容器的自包含目录中运行它们。在
    Docker 中工作时，作为开发人员，你的工作主要是通过在现有镜像上叠加新命令来构建新的镜像。镜像存储在外部注册表中，这些注册表可以是公共的，也可以是私有的。最终，所有的交互都通过
    RESTful API 完成，通常使用命令行界面。
- en: Docker in action
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Docker 实践
- en: 'To see Docker in action, we will start by installing it on our computer. The
    installation of Docker is very straightforward; you can follow the instructions
    found at [http://dockr.ly/2iVx6yG](http://dockr.ly/2iVx6yG) to install and start
    Docker on Mac, Linux, and Windows. Docker provides two offerings: Docker **Community
    Edition** (**CE**) and Docker **Enterprise Edition** (**EE**). Throughout this
    book, we are going to focus on open source tools, as well as using Docker CE,
    which is free of cost. Again, we will be demonstrating the following examples
    on a Linux based Centos 7.x distribution. If you are also following the same operating
    system then follow the instructions available at [https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
    to set up Docker locally on your system. When you are done with the installation
    of Docker CE, verify the installed Docker version using the `docker` utility.
    At the time of writing this book, `18.06` is the latest version of Docker, although
    you might see a newer version on your system now:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到 Docker 的实际操作，我们将从在我们的计算机上安装 Docker 开始。Docker 的安装非常简单；你可以按照 [http://dockr.ly/2iVx6yG](http://dockr.ly/2iVx6yG)
    上的说明，安装并启动适用于 Mac、Linux 和 Windows 的 Docker。Docker 提供了两个版本：Docker **社区版** (**CE**)
    和 Docker **企业版** (**EE**)。在本书中，我们将专注于开源工具，并使用免费的 Docker CE 版本。再次声明，我们将演示的示例是在基于
    Linux 的 Centos 7.x 发行版上进行的。如果你也使用相同的操作系统，请按照 [https://docs.docker.com/install/linux/docker-ce/centos/](https://docs.docker.com/install/linux/docker-ce/centos/)
    上的说明，在本地系统上设置 Docker。当 Docker CE 安装完成后，使用 `docker` 工具验证安装的 Docker 版本。在编写本书时，`18.06`
    是 Docker 的最新版本，尽管你现在在系统上可能会看到更新的版本：
- en: '[PRE0]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once Docker is up and running, we can start using it as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 Docker 启动并运行，我们可以如下使用它：
- en: 'The first thing that we will do is pull an image from a registry. By default,
    Docker points to Docker Hub ([https://hub.docker.com](https://hub.docker.com/)),
    which is the official Docker registry from the company Docker Inc. In order to
    pull an image, we will run the following command:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是从注册表中拉取一个镜像。默认情况下，Docker 会指向 Docker Hub ([https://hub.docker.com](https://hub.docker.com/))，这是
    Docker 公司官方的 Docker 注册表。为了拉取一个镜像，我们将运行以下命令：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We will use the `latest` default tag, as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `latest` 默认标签，如下所示：
- en: '[PRE2]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In a matter of seconds, Docker will download the image called `alpine` from
    the registry, which is a minimal Docker image based on Alpine Linux with a complete
    package index. This is only `4.41 MB` in size:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几秒钟之内，Docker 会从注册表下载名为`alpine`的镜像，这是一个基于 Alpine Linux 的最小 Docker 镜像，包含完整的软件包索引。这个镜像的大小只有`4.41
    MB`：
- en: '[PRE3]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When working with Docker, the size of a container matters. Consequently, working
    with smaller base images, such as Alpine Linux, is highly recommended.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Docker 时，容器的大小很重要。因此，推荐使用较小的基础镜像，如 Alpine Linux。
- en: 'We can now run our container. In order to do this, we will start with the following
    simple command:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以运行我们的容器。为了做到这一点，我们将从以下简单命令开始：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: On the surface, not a lot seems to have happened here, and we were left with
    the same output as we had when running echo `Hello World` without Docker. What
    really happened behind the scenes is a lot more interesting; Docker loaded the
    `alpine` Linux image that we previously pulled, and used the Alpine operating
    system `echo` command to print `Hello World`. Finally, because the `echo` command
    completed, the container was terminated.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 表面上看，似乎并没有什么变化，我们得到的输出与没有 Docker 时运行 `echo Hello World` 得到的输出相同。实际上，幕后发生的事情更有趣；Docker
    加载了我们之前拉取的 `alpine` Linux 镜像，并使用 Alpine 操作系统的 `echo` 命令打印出 `Hello World`。最后，由于
    `echo` 命令完成，容器也被终止。
- en: 'Containers can also be used in a more interactive way, as follows:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 容器也可以以更交互的方式使用，如下所示：
- en: 'We can, for example, start a shell and interact with it by using the following
    command:'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 例如，我们可以启动一个 shell 并通过以下命令与其互动：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `-i` option means interactive; this allows us to type commands in our container
    while the `-t` option allocates a pseudo TTY to see what we are typing as well
    as the output of our commands.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`-i` 选项表示交互式；它允许我们在容器中输入命令，而 `-t` 选项分配一个伪 TTY，既能看到我们输入的内容，也能看到命令的输出。'
- en: 'Containers can also be run in the background by using the `-d` option, which
    will detach our container from the Terminal:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器也可以通过使用 `-d` 选项在后台运行，这样可以将我们的容器从终端分离出来：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This command returns a 64-bit long ID of the container running the `alpine`
    image and the sleep `1000` command.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 该命令返回一个 64 位的容器 ID，表示正在运行 `alpine` 镜像和 `sleep 1000` 命令的容器。
- en: 'We can keep track of the different running containers running by using the
    following command:'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过使用以下命令跟踪不同的运行容器：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述命令的输出如下：
- en: '![](img/1bd7bd33-00e4-4266-aae0-fe91c4a52faf.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1bd7bd33-00e4-4266-aae0-fe91c4a52faf.png)'
- en: 'Running containers can be stopped using the `stop` option followed by the container
    name or ID (adapt the ID and name based on the output of your `docker ps` command):'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行中的容器可以通过`stop`选项停止，后面跟上容器的名称或ID（根据`docker ps`命令的输出调整ID和名称）：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You can also use the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用以下命令：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Stopped containers can be started again with the `start` option, as follows:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止的容器可以通过`start`选项重新启动，如下所示：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, containers can be removed by using the the `rm` command, but always
    stop the container before removing them:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，容器可以通过使用`rm`命令删除，但在删除之前请务必先停止容器：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前述命令的输出如下：
- en: '![](img/110220a2-1d44-4f16-b631-f7ad7c814dfa.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/110220a2-1d44-4f16-b631-f7ad7c814dfa.png)'
- en: 'This brief overview should provide us with the knowledge we need when reading
    this chapter. We will discover a few more commands along the way, but for a complete
    list of options, you can use the `docker help` command or consult the Docker CLI
    documentation at [http://dockr.ly/2jEF8hj](http://dockr.ly/2jEF8hj). Running simple
    commands through containers is sometimes useful but, as we know, the real strength
    of Docker is its ability to handle any code, including our web application. In
    order to make that happen, we will use another key concept of Docker: a Dockerfile.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简要概述应能为我们提供在阅读本章时所需的知识。我们将沿途发现更多命令，但要查看完整的选项列表，你可以使用`docker help`命令，或查阅Docker
    CLI文档，网址为[http://dockr.ly/2jEF8hj](http://dockr.ly/2jEF8hj)。通过容器运行简单命令有时很有用，但正如我们所知，Docker的真正优势在于其能够处理任何代码，包括我们的Web应用程序。为了实现这一点，我们将使用Docker的另一个关键概念：Dockerfile。
- en: Creating our Dockerfile
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的Dockerfile
- en: 'Dockerfiles are text files that are usually collocated with applications that
    instruct Docker on how to build a new Docker image. Through the creation of those
    files, you have the ability to tell Docker which Docker image to start from, what
    to copy on the container filesystem, what network port to expose, and so on. You
    can find the full documentation of the Dockerfile at [http://dockr.ly/2jmoZMw](http://dockr.ly/2jmoZMw).
    We are going to create a Dockerfile for our Hello World application, at the root
    of the `helloworld` project that we created in our GitHub repository, using the
    following commands:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile是文本文件，通常与应用程序一起存放，指示Docker如何构建新的Docker镜像。通过创建这些文件，你可以告诉Docker从哪个Docker镜像开始、要复制到容器文件系统中的内容、要公开的网络端口等等。你可以在[http://dockr.ly/2jmoZMw](http://dockr.ly/2jmoZMw)找到Dockerfile的完整文档。我们将为我们的Hello
    World应用程序创建一个Dockerfile，位于我们在GitHub仓库中创建的`helloworld`项目的根目录，使用以下命令：
- en: '[PRE12]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The first instruction of a Dockerfile is always a `FROM` instruction. This
    tells Docker which Docker image to start from. We could use the Alpine image,
    as we did, but we can also save some time by using an image that has more than
    just an operating system. Through Docker Hub, the official Docker registry, Docker
    provides a number of curated sets of Docker repositories called **official**.
    We know that in order to run our application, we need Node.js and `npm`. We can
    use the Docker CLI to look for an official `node` image. To do that, we will use
    the `docker search` command and filter only on official images:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Dockerfile的第一条指令始终是`FROM`指令。这告诉Docker从哪个Docker镜像开始。我们可以使用Alpine镜像，正如我们所做的那样，但我们也可以通过使用一个不仅仅是操作系统的镜像来节省一些时间。通过Docker
    Hub，Docker的官方注册表，Docker提供了许多经过精心策划的Docker仓库集，这些仓库被称为**官方**。我们知道，为了运行我们的应用程序，我们需要Node.js和`npm`。我们可以使用Docker
    CLI查找官方的`node`镜像。为此，我们将使用`docker search`命令，并仅筛选官方镜像：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Alternatively, we can also search for this using our browser. As a result,
    we would end up with that same image, [https://hub.docker.com/_/node/](https://hub.docker.com/_/node/).
    As we can see, the following screenshot comes in a variety of versions:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以使用浏览器进行搜索。结果，我们将看到相同的镜像，[https://hub.docker.com/_/node/](https://hub.docker.com/_/node/)。正如我们所见，以下截图有多个版本：
- en: '![](img/ea4202d1-ce5c-474e-a493-1bc16c06733a.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea4202d1-ce5c-474e-a493-1bc16c06733a.png)'
- en: 'Docker images are always made up of a name and a tag, using the syntax `name:tag`.
    If the tag is omitted, Docker will default to `latest`. From the preceding `docker
    pull` command, we can see how the output says `Using default tag: latest`. When
    creating a Dockerfile, it is best practice to use an explicit tag that doesn''t
    change over time (unlike the `latest` tag).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker镜像总是由名称和标签组成，使用语法`name:tag`。如果省略标签，Docker将默认使用`latest`标签。从前面的`docker
    pull`命令中，我们可以看到输出显示`Using default tag: latest`。在创建Dockerfile时，最佳实践是使用一个不会随着时间改变的显式标签（不同于`latest`标签）。'
- en: If you are trying to migrate an application currently running on AWS Linux and
    make a certain number of assumptions based on that OS, you may want to look into
    using the official AWS Docker image. You can read more about this at [http://amzn.to/2jnmklF](http://amzn.to/2jnmklF).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在尝试迁移一个当前运行在AWS Linux上的应用程序，并基于该操作系统做出一些假设，你可能想要使用官方的AWS Docker镜像。你可以在[http://amzn.to/2jnmklF](http://amzn.to/2jnmklF)上了解更多信息。
- en: 'On the first line of our file, we will add the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件的第一行，我们将添加如下内容：
- en: '[PRE14]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This will tell Docker that we want to use that specific version of the `node`
    image. This means that we won''t have to install `node` or `npm`. Since we have
    the OS and runtime binaries needed by our application, we can start looking into
    adding our application to this image. First, we will want to create a directory
    on top of the `node:carbon` image''s filesystem, to hold our code. We can do that
    using the `RUN` instruction, as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将告诉Docker我们想要使用特定版本的`node`镜像。这意味着我们不需要安装`node`或`npm`。因为我们已经有了应用程序所需的操作系统和运行时二进制文件，所以我们可以开始考虑将我们的应用程序添加到这个镜像中。首先，我们需要在`node:carbon`镜像的文件系统上创建一个目录，用来存放我们的代码。我们可以使用`RUN`指令来完成，具体如下：
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We now want to copy our application files onto the image. We will use the `COPY`
    directive to do that:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要将应用程序文件复制到镜像中。我们将使用`COPY`指令来实现：
- en: '[PRE16]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure that you copy the `helloworld.js` and `package.json` files inside
    the `/helloworld` project directory where you are locally developing Dockerfile.
    The files are placed at [https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)
    and [https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你将`helloworld.js`和`package.json`文件复制到你本地开发Dockerfile的`/helloworld`项目目录中。这些文件位于[https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js](https://github.com/yogeshraheja/helloworld/blob/master/helloworld.js)和[https://github.com/yogeshraheja/helloworld/blob/master/package.json](https://github.com/yogeshraheja/helloworld/blob/master/package.json)。
- en: 'We will now use the `WORKDIR` instruction to set our new working directory
    to be that `helloworld` directory:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`WORKDIR`指令将我们的新工作目录设置为`helloworld`目录：
- en: '[PRE17]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We can now run the `npm install` command to download and install our dependencies.
    Because we won''t use that container to test our code, we can just install the
    `npm` packages needed for production, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行`npm install`命令来下载并安装我们的依赖项。因为我们不会使用这个容器来测试我们的代码，我们可以只安装生产环境所需的`npm`包，如下所示：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Our application uses port `3000`. We need to make this port accessible to our
    host. In order to do that, we will use the `EXPOSE` instruction:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序使用`3000`端口。我们需要让这个端口对主机可访问。为此，我们将使用`EXPOSE`指令：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we can start our application. For that, we will use the `ENTRYPOINT`
    instruction:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以启动我们的应用程序。为此，我们将使用`ENTRYPOINT`指令：
- en: '[PRE20]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We can now save the file. It should look like the template at [https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile).
    We can now build our new image.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以保存文件。它应该看起来像[https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile](https://github.com/yogeshraheja/helloworld/blob/master/Dockerfile)模板那样。我们现在可以构建我们的新镜像。
- en: 'Back in the Terminal, we will again use the `docker` command, but this time
    with the `build` argument. We will also use the `-t` option to provide the name
    `helloworld` to our image, followed by a (`.`) dot that indicates the location
    of our Dockerfile:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 回到终端，我们将再次使用`docker`命令，但这次使用`build`参数。我们还将使用`-t`选项为我们的镜像提供名称`helloworld`，并在后面加上一个（`.`）点，表示Dockerfile的位置：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see, each command produces a new intermediary container with the
    changes triggered by that step.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每个命令都会生成一个新的中间容器，并带有该步骤所触发的更改。
- en: 'We can now run our newly created image to create a container with the following
    command:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行我们新创建的镜像，以以下命令创建一个容器：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we are adding the`-p` option to our command to map the exposed port of
    our container to a port on our host. There are a few ways to validate that our
    container is working correctly. We can start by looking at the logs produced by
    our container (replace the container ID with the output of the previous command):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在命令中添加了`-p`选项，将容器的暴露端口映射到主机的端口。有几种方法可以验证我们的容器是否正常工作。我们可以首先查看容器生成的日志（将容器ID替换为之前命令的输出）：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can also use the `docker ps` command to see the status of our container:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`docker ps`命令查看我们容器的状态：
- en: '[PRE24]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output of the preceding command is as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令的输出如下：
- en: '![](img/e2440413-c06d-48aa-a81d-6b7da5fd9448.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e2440413-c06d-48aa-a81d-6b7da5fd9448.png)'
- en: 'And, of course, we can simply test the application with the `curl` command:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们还可以简单地使用`curl`命令来测试应用：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, if your host has a public IP then you can even verify the outputs on
    the browser with `<ip:exposedport>`, which in my case is `54.205.200.149:3000`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，如果你的主机有公共IP，你甚至可以通过浏览器使用`<ip:exposedport>`来验证输出，在我的例子中是`54.205.200.149:3000`：
- en: '![](img/b3adc093-30ac-418d-ba0a-0e7e057a5f76.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3adc093-30ac-418d-ba0a-0e7e057a5f76.png)'
- en: 'Finally, kill the container using the `docker kill` command and container ID:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用`docker kill`命令和容器ID来停止容器：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since our image is working correctly, we can commit the code to GitHub:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的镜像运行正常，我们可以将代码提交到GitHub：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition, you can now create an account (for free) on Docker Hub and upload
    that new image. If you want to give it a try, you can follow the instructions
    at [http://dockr.ly/2ki6DQV](http://dockr.ly/2ki6DQV).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你现在可以在Docker Hub上创建一个帐户（免费）并上传这个新镜像。如果你想尝试，你可以按照[http://dockr.ly/2ki6DQV](http://dockr.ly/2ki6DQV)上的说明进行操作。
- en: 'Having the ability to easily share containers makes a big difference when collaborating
    on projects. Instead of sharing code and asking people to compile or build packages,
    you can actually share a Docker image. For instance, this can be done by running
    the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 能够轻松分享容器，在协作项目中带来很大的不同。你无需分享代码并要求别人编译或构建包，而是可以直接分享Docker镜像。例如，可以通过运行以下命令来实现：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令的输出如下：
- en: '![](img/8bdb0d8a-8b89-48e9-8e3c-e0ae88bb3309.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8bdb0d8a-8b89-48e9-8e3c-e0ae88bb3309.png)'
- en: You can experience the Hello World application, the exact way I see it, no matter
    what your underlying architecture is. This new way of running applications makes
    Docker a very strong solution for sharing work or collaborating on projects. Docker's
    strengths do not end with work collaboration, however. As we are about to see,
    using containers in production is also a very interesting option. In order to
    easily implement such solutions, AWS created the EC2 container service. We are
    going to use it to deploy our newly created `helloworld` image.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以体验Hello World应用，正如我所看到的一样，无论你的底层架构是什么。通过这种新的应用运行方式，Docker成为了一个非常强大的工作分享或项目协作解决方案。然而，Docker的优势不仅限于工作协作。正如我们即将看到的，使用容器进行生产部署也是一个非常有趣的选择。为了便于实现这些解决方案，AWS创建了EC2容器服务。我们将使用它来部署我们新创建的`helloworld`镜像。
- en: Using the EC2 container service
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用EC2容器服务
- en: 'We just went over creating a Docker image for our application. Here, we saw
    how easy and fast it is to start a container using Docker. This is a very transformative
    experience compared to using only virtual machine technologies such as EC2\. One
    possibility that we haven''t explicitly mentioned so far is that you can start
    multiple containers with the same image. We can, for example, start our `helloworld`
    container five times, binding five different ports using the following command
    (adapt the ID based on the image ID you built. If needed, run Docker images to
    find its ID):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚讲解了如何为我们的应用创建一个Docker镜像。在这里，我们看到使用Docker启动容器是多么简单和快速。这与仅使用虚拟机技术（如EC2）相比，带来了非常有变革性的体验。我们至今没有明确提到的一种可能性是，你可以使用相同的镜像启动多个容器。例如，我们可以启动五次`helloworld`容器，并使用以下命令绑定五个不同的端口（根据你构建的镜像ID调整ID。如果需要，可以运行Docker
    images来查找镜像ID）：
- en: '[PRE29]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We can validate that everything is working using the `ps` and `curl` commands:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`ps`和`curl`命令验证一切是否正常：
- en: '[PRE30]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The output of running the preceding command is as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行上述命令的输出如下：
- en: '![](img/6bc2a770-1f61-41fa-b8aa-be32f8b55a01.png)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6bc2a770-1f61-41fa-b8aa-be32f8b55a01.png)'
- en: 'Cleaning up containers:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 清理容器：
- en: 'We can clean up everything by stopping and removing all containers with these
    two handy one-line commands:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过停止并删除所有容器来清理一切，使用以下两个便捷的一行命令：
- en: '**`$ docker stop $(docker ps -a -q)`**'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`$ docker stop $(docker ps -a -q)`**'
- en: '**`$ docker system prune`**'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`$ docker system prune`**'
- en: 'The output of running the preceding commands is as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 执行前面命令的输出结果如下：
- en: '![](img/f26a7e76-daad-43cd-bac0-4b92cec1cb45.png)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f26a7e76-daad-43cd-bac0-4b92cec1cb45.png)'
- en: This ability to start multiple containers on a single host with almost no overhead
    or latency makes Docker an ideal candidate for production. In addition, more and
    more companies are deciding to take the service-oriented architecture approach
    to an all-new level by breaking out each business function into a separate service.
    This is often called a **microservices** approach. Docker is a natural fit for
    microservices and for managing microservice architecture. This is because it provides
    a platform that is language agnostic (you can start any type of application written
    in any language inside your container), able to scale horizontally and vertically
    with ease, and a common story around deployment as we deploy containers instead
    of a variety of services. We will implement our container architecture using the
    **Infrastructure as Code** (**IaC**) best practices and use CloudFormation through
    the intermediary of Troposphere. The first service we are going to look at is
    AWS's ECR.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这种几乎没有开销或延迟的单主机多容器启动能力，使 Docker 成为生产环境中的理想选择。此外，越来越多的公司决定通过将每个业务功能拆分为独立服务，将面向服务的架构方法提升到一个全新的水平。这通常被称为
    **微服务** 方法。Docker 非常适合微服务及其管理。这是因为它提供了一个与语言无关的平台（您可以在容器中启动任何语言编写的应用程序），能够轻松地进行横向和纵向扩展，并且围绕部署有一个共同的故事——我们部署的是容器，而不是多种服务。我们将使用
    **基础设施即代码**（**IaC**）最佳实践来实现我们的容器架构，并通过 Troposphere 中介使用 CloudFormation。我们将要查看的第一个服务是
    AWS 的 ECR。
- en: Creating an ECR repository to manage our Docker image
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 ECR 仓库来管理我们的 Docker 镜像
- en: In the first part of this chapter, we used the Docker Hub public registry. AWS
    provides a similar service to this called ECR. This allows you to keep your images
    in a private registry called a **repository**. ECR is fully compatible with the
    Docker CLI but also integrates deeply with the remaining ECS services. We are
    going to use this to store our `helloworld` images.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们使用了 Docker Hub 公共注册表。AWS 提供了一个类似的服务，叫做 ECR。这使您能够将镜像保存在一个名为 **repository**
    的私有注册表中。ECR 完全兼容 Docker CLI，并且与其他 ECS 服务深度集成。我们将使用它来存储我们的 `helloworld` 镜像。
- en: As mentioned, we will rely heavily on CloudFormation to make our changes. Unlike
    what we saw previously, because of its nature, the ECS infrastructure we are going
    to build needs to be very modular. This is because, in practice, we will want
    to share some of those components with other services. Consequently, we will create
    a number of templates and link them to one another. One good way to do that is
    to rely on CloudFormation's export ability, which allows us to do cross-stack
    referencing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将主要依赖 CloudFormation 来进行我们的更改。与之前看到的不同，由于其性质，我们将要构建的 ECS 基础设施需要非常模块化。这是因为在实际操作中，我们希望将其中一些组件与其他服务共享。因此，我们将创建多个模板，并将它们相互链接。实现这一点的一个好方法是依赖
    CloudFormation 的导出功能，这使我们能够进行跨堆栈引用。
- en: One of the added bonuses that export provides is a fail-safe mechanism. You
    can't delete or edit a stack if another stack references an exported output.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的一个附加优势是其故障保护机制。如果另一个堆栈引用了导出的输出，您就无法删除或编辑该堆栈。
- en: To generate our template, we will create a new Troposphere script. To do this,
    go to the `EffectiveDevOpsTemplates` repository and create a new script named
    `ecr-repository-cf- template.py`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了生成我们的模板，我们将创建一个新的 Troposphere 脚本。为此，进入 `EffectiveDevOpsTemplates` 仓库，并创建一个名为
    `ecr-repository-cf-template.py` 的新脚本。
- en: 'We will start by importing a number of modules, including the `Export` mentioned
    earlier and the `ecr` module, in order to create our repository. We will also
    create our template variable, `t`, as we did in previous chapters:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先导入多个模块，包括前面提到的 `Export` 模块和 `ecr` 模块，以便创建我们的仓库。我们还将像前几章一样创建我们的模板变量 `t`：
- en: '[PRE31]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since we are going to create a number of CloudFormation templates in this chapter,
    we will add a description so that it''s easier to understand which template does
    what when looking at them in the AWS console:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在本章中创建多个 CloudFormation 模板，因此我们将添加描述，以便在 AWS 控制台中查看这些模板时更容易理解每个模板的功能：
- en: '[PRE32]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'We will create a parameter for the name of the repository so that we will be
    able to reuse that CloudFormation template for every repository we create:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now create our repository as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are keeping the code very simple here and not enforcing any particular permissions.
    If you need to restrict who can access your repository and see more complex configurations,
    you can refer to the AWS documentation and, in particular, [http://amzn.to/2j7hA2P](http://amzn.to/2j7hA2P). Lastly,
    we will output the name of the repository we created and export its value through
    a template variable `t`:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can save our script now. It should look like this: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecr-repository-cf-template.py).
    We will now generate the CloudFormation template and create our stack as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'After a few minutes, our stack will be created. We can validate that the repository
    was correctly created as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can see our exported output with the following command:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our repository can now be used to store our `helloworld` image. We will use
    the Docker CLI to do that. The first step of that process is to log in to the
    `ecr` service. You can do this with the following handy one-line command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The output of running the preceding command can be shown as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/805706d0-cfab-4e33-a0ae-de6edbd3a93c.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: 'Back in our `helloworld` directory where the Dockerfile is, we will tag our
    image as follows:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'It is a common practice to use the `latest` tag to designate the most recent
    version of an image. In addition, you need to adapt the following command based
    on the output of the `aws ecr describe-repositories` output (we assume here that
    you have already built your image):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We can now push that image to our registry as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'We can see how each layer of our image is pushed in parallel to our registry.
    Once the operation completes, we can validate that the new image is present in
    our registry as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: At this point, our image is now available to the rest of our infrastructure.
    We are going to move on to the next step of our process, which is the creation
    of the ECS cluster.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ECS cluster
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an ECS cluster is a very similar process to the one in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, when we created an Auto Scaling Group to run our
    Hello World application. The main difference is that there is one more level of
    abstraction. ECS will run a number of services called **task**s.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Each of those tasks may exist multiple times in order to handle the traffic:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/328a29f3-4714-484d-b04b-b22d0d86e9a3.png)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
- en: In order to do that, the ECS service provides an orchestration layer. That orchestration
    layer is in charge of managing the life cycle of containers, including upgrading
    or downgrading and scaling your containers up or down. The orchestration layer
    also distributes all containers for every service across all instances of the
    cluster optimally. Finally, it also exposes a discovery mechanism that interacts
    with other services such as ALB and ELB to register and deregister containers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Task placement strategies:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: By default, the entire orchestration system is managed by AWS. However, you
    also have the ability to customize it through the creation of a task placement
    strategy. This will let you configure the orchestration to optimize for instance
    count, for load distribution, to add constraints, and make sure that certain tasks
    are launched on the same instances.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new script to generate our ECS cluster. The filename will
    be `ecs-cluster-cf-template.py`. This template starts almost exactly like the
    template we created in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, for the Auto Scaling Group:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The only new import is the cluster one from the ECS module. Just like we did
    in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your Infrastructure*,
    we will extract our IP address in order to use it later for the SSH security group,
    create our template variable, and add a description to the stack:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We will now proceed with adding our parameters, which are the the same parameters
    as used in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your
    Infrastructure*. This includes the SSH key-pair, the VPC ID, and its subnets:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, we will look at creating our security group resources:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: There is one important difference here. In [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, we opened up port `3000` since that's what our
    application is using. Here, we are opening every port to the CIDR 1 `72.16.0.0/12`,
    which is the private IP space of our internal network. This will give our ECS
    cluster the ability to run multiple `helloworld` containers on the same hosts,
    binding different ports.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create our cluster resource. This can simply be done with the following
    command:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Next, we will focus on configuring instances of the cluster, starting with
    their IAM role. Overall, this is one of the more complex resources to create in
    ECS as the cluster will need to perform a number of interactions with other AWS
    services. We can create a complete custom policy for it or import the policies
    AWS created as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can now tie our role with the instance profile as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The next step is to create our launch configuration. The following code snippet
    shows what it looks like:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In this example, we don't install Ansible like we did before. Instead, we are
    using an ECS- optimized AMI (you can read more about this at [http://amzn.to/2jX0xVu](http://amzn.to/2jX0xVu))
    that lets us use the `UserData` field to configure the ECS service, and then starting
    it. Now that we have our launch configuration, we can create our Auto Scaling
    Group resources.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with ECS, scaling is needed at two levels:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: The containers level, as we will need to run more containers of a given service
    if the traffic spikes
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The underlying infrastructure level
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Containers, through the intermediary of their task definitions, set a requirement
    for CPU and memory. They will require, for example, 1024 CPU units, which represents
    one core, and 256 memory units, which means 256 MB of RAM. If the ECS instances
    are close to being filled up on one of those two constraints, the ECS Auto Scaling
    Group needs to add more instances:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a4a4d06-7d7b-46d5-88f7-dfe4d3e19d6e.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
- en: 'In terms of implementation, the process is very similar to what we did in [Chapter
    6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml), *Scaling Your Infrastructure*.
    Here, we first create the Auto Scaling Group resource, as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, we will create scaling policies and alarms to monitor the CPU and memory
    reservation metrics. In order to accomplish that, we will take advantage of Python
    to generate our stack and create for loops as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Finally, we will provide a small amount of resource information, namely the
    stack ID, the VPC ID, and the public subnets:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: CloudFormation provides a number of pseudo-parameters, such as `AWS::StackName`.
    Throughout the chapter, we will rely on it to make our template generic enough
    to be used across different environments and services. In the preceding code,
    we created an ECR repository for our `helloworld` container. The name was generated
    by the stack creation command. If required, we can reuse that exact same template
    to create another repository for another container.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: 'The script is now complete, and should look like the script at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/ecs-cluster-cf-template.py).'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, we can now commit our script and create our stack by first generating
    our template, as follows:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: To create our stack, we need three parameters; the key-pair, the VPC ID, and
    the subnets. In the previous chapters, we used the web interface to create those
    stacks. Here, we will look at how to get that information using the CLI.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the VPC ID and the subnet IDs, we can use the following commands:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'We can now create our stack by combining the preceding outputs. Since ECS clusters
    can run a variety of containers and a number of applications and services, we
    will aim for one ECS cluster per environment, starting with staging. In order
    to differentiate each environment, we will rely on the stack names. Consequently,
    it is important to call your `staging-cluster` stack, as shown here:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: We will now add a load balancer. In the previous chapter, we used an ELB for
    our Auto Scaling Group. Later, we also mentioned the existence of the ALB service.
    This time, we will create an ALB instance to proxy our application traffic.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ALB
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, ECS provides an orchestrator that takes care of allocating
    the containers across our Auto Scaling Group. It also keeps track of which port
    each container uses and integrates with ALB so that our load balancer can correctly
    route the incoming traffic to all containers running a given service. ECS supports
    both the ELB and ALB services but the ALB gives more flexibility when working
    with containers. We will demonstrate how to create an ALB using CloudFormation
    through Troposphere.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by creating a new file and calling it `helloworld-ecs-alb-cf-template.py`.
    We will then put our usual import, and will create our template variable and add
    a description, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'We are now going to create our security group. No surprises here; we are opening
    `TCP/3000` to the world, as we did in [Chapter 6](c54f64c9-e8a3-4eed-b68d-087ff40f8b1d.xhtml),
    *Scaling Your Infrastructure*, with the ELB:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The main difference from what we did previously is that instead of starting
    with a parameter section and requesting, yet again, to provide the VPC ID and
    public subnets, we are taking advantage of the value that we exported before.
    When we launch this stack, we will call it `staging-alb`. The block of code inside
    the `ImportValue` parameter does the following:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: First, we get the name of our stack. We will launch that stack under the name
    `staging-alb`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Split` function breaks the stack name on the character `-`, meaning that
    we end up with [`staging`, `alb`].
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Select` function takes the first element of the list: staging.'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Join` function concatenates that element with the string `cluster-vpc-id`.
    In the end, we get `Import("staging-cluster-vpc-id")`, which is the name of the
    key we defined to export the VPC ID when we created our ECS cluster:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c1f4d0bf-28f4-4c35-8f74-9a0faf3f1924.png)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
- en: 'We will now create our ALB. ALB, being more flexible and feature-rich than
    ELB, requires a bit more effort when it comes to configuration. ALB works through
    the intermediary of three different resources. The first one is the ALB resource,
    which handles incoming connections. On the opposite side, we can find the target
    groups, which are the resources used by the ECS clusters registered to those ALBs.
    Finally, in order to tie the two, we find the listener''s resources. We will first
    define our load balancer resource, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We use a very similar series of calls to the function to import our subnet as
    we did just before for the VPC ID.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create our target group and configure our health check, as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, we will add the listener to connect our target group to our load balancer:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Lastly, we will want to create two outputs. The first output is the target
    group. We will export its value so that our application can register to the group.
    The second output is the DNS record of the ALB. This will be the entry point to
    our application:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The file is now ready, and should look like the file at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-alb-cf-template.py).
    We can now generate our template and create our stack, as follows:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: As mentioned, it is important to call the stack `staging-alb`, and that first
    word is used to import the VPC ID and subnets. The last stack we need is the creation
    of our container service.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: Creating our ECS hello world service
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have an ECS cluster and a load balancer ready to take on traffic on one
    side and an ECR repository containing the image of our application on the other
    side. We now need to tie the two together. This is done by creating an ECS service
    resource. We will create a new file called `helloworld-ecs-service-cf-template.py`
    and start as usual with its imports, template variable creation, and template
    description:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Our template will take one argument, which is the tag of the image we want
    to deploy. Our repository currently only has one image tagged as the latest, but
    in the next section we will update our deployment pipeline and automatize the
    deployment of our service to ECS:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In ECS, applications are defined by their task definitions. This is where we
    declare which repository to use to get our image, how much CPU and memory the
    application needs, and all other system properties such as port mapping, environment
    variables, mount points, and so on. We will keep our task definition minimal;
    in order to select the proper image, we will utilize the `ImportValue` function
    (we previously exported the repository name) combined with a `Join` function to
    craft the repository URL. We will require 32 MB of RAM and one-quarter of a core
    to run our application. Finally, we will specify that port `3000` needs to be
    mapped onto the system:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'As for most of the AWS managed services, the ECS service needs a certain set
    of permissions provided by the intermediary of a role. We will create that role
    and use the vanilla policy for the ECS service role, as follows:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'We will complete the creation of our template with the addition of the ECS
    service resource, which ties the task definition, the ECS cluster, and the ALB
    together:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Finally, as always, we will output the template generated by our code using
    the following command:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The script is now ready and should look like the script at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-ecs-service-cf-template.py).'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now generate the template and create our stack, as follows:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'After a few minutes, the stack should be created. We can circle back to the
    output of the ALB stack to get the URL of our newly deployed application and test
    its output, as follows:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This can also be confirmed from the browser, as shown in the following screenshot:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3386d1b4-0477-4392-a767-430badf63775.png)'
  id: totrans-266
  prefs: []
  type: TYPE_IMG
- en: 'We have completed the creation of our staging ECS environment. At this point,
    we can easily manually deploy new code to our staging, as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the changes in the `helloworld` code, locally. For example, change `Hello
    World` to `Hello From Yogesh Raheja`, as shown in the following screenshot:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/32772faa-db7f-42ee-ad93-f0b38472839f.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: 'Log in to the `ecr` registry, as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Build your Docker container, as follows:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Pick a new unique tag, and use it to tag your image. For example, let''s suppose
    that your new tag is `foobar`, as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Push the image to the `ecr` repository, as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Update the ECS service CloudFormation stack, as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Check the outputs after it updates, as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'The browser output also reflects the updated image response:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f8c34e6-dd67-438f-a599-6502944443a1.png)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
- en: Using this sequence of events, we are going to automate the deployment process
    and create a new continuous integration/continuous deployment pipeline.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CI/CD pipeline to deploy to ECS
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we know, having the ability to continuously deploy code across our environments
    is a very powerful tool as it helps to break out those traditional Dev versus
    Ops silos and improve the velocity at which new code is being released. We created
    a pipeline that allows us to automatically deploy new changes from our Hello World
    application to our Auto Scaling Groups for staging and production. We will create
    a similar pipeline but, this time, it will deploy changes to ECS. Our ECS infrastructure
    will be as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf0104de-f636-4398-a66e-f602ed354865.png)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
- en: Reusing the CloudFormation templates produced in the previous section will create
    a production environment identical to the staging one. Note that the `ecr` repository
    is meant to be unique for a given application, and therefore will share it across
    our environments. In addition, we will follow the best practices learned in [Chapter
    3](8a74da7b-0748-4b90-a3bc-58e853e820ec.xhtml), *Treating Your Infrastructure
    As Code*, and create our pipeline through a CloudFormation stack. Our first step
    will be to create an ECS cluster for production.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Creating our production ECS cluster
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Thanks to the upfront work we did with our CloudFormation templates, adding
    a new environment will be trivial. We will start by launching a production ECS
    cluster:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'We need to wait for the creation of the stack to complete as we need to get
    some of the exported values from the cluster creation. We can run the following
    command to get our Terminal to hang until we can create our next stack:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'In the meantime, we create our ALB and wait for the creation process to complete:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Finally, we can create our service with the following code:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'At this point, our production environment should be working. We can get its
    URL by looking at the output of the ALB stack creation, and we can CURL the endpoint
    to ensure that the application is up and running:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'The output will be as follows:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2b95d0e1-3bb8-4ee5-a297-99d55463d50e.png)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
- en: Now that our production environment is ready, we will look into automating the
    creation of containers. In order to accomplish that, we will rely on the CodeBuild
    service.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Automating the creation of containers with CodeBuild
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AWS CodeBuild is a managed service geared toward compiling source code. It is
    comparable to Jenkins but since it's a managed service that conforms to AWS standards,
    it presents a different set of features and benefits. In our case, using CodeBuild
    over Jenkins will allow us to create containers without needing to spin up and
    manage an extra EC2 instance. The service also integrates well with CodePipeline,
    which, as before, will drive our process.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: We will use CloudFormation through the intermediary of Troposphere to create
    our CodeBuild project.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also create a new script and call it `helloworld-codebuild-cf-template.py`.
    We will start with our usual import, template variable creation, and description,
    shown as follows:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'We will now define a new role to grant the proper permissions to our CodeBuild
    project. The CodeBuild project will interact with a number of AWS services such
    as ECR, CodePipeline, S3, and CloudWatch logs. To speed up the process, we will
    rely on the AWS vanilla policies to configure the permissions. This gives us the
    following code:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'CodeBuild projects require defining a number of elements. The first one we
    will define is the environment. This tells CodeBuild what type of hardware and
    OS we need to build our project, and what needs to be preinstalled. It will also
    let us define extra environment variables. We will use a Docker image provided
    by AWS, which will give us everything we need to get our work done. The Docker
    image comes with the AWS and Docker CLI preinstalled and configured. We will also
    define an environment variable to find our `ecr` repository endpoint:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: In CodeBuild, most of the logic is defined in a resource called a `buildspec`.
    The `buildspec` section defines the different phases of the build and what to
    run during those phases. It is very similar to the Jenkins file we created in
    Chapter 5, *Adding Continuous Integration and Continuous Deployment*. The `buildspec`
    section can be created as part of the CodeBuild project or added as a YAML file
    to the root directory of the projects that are being built. We will opt for the
    first option and define `buildspec` inside our CloudFormation template. We will
    create a variable and store a YAML string into it. Since it's going to be a multiline
    variable, we will use the Python triple quote syntax.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'The first key-pair we need to specify is the version of the template. The current
    version of CodeBuild templates is `0.1`:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'The goal of our build process is to generate a new container image, tag it,
    and push it to the `ecr` repository. This will be done in three phases:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '**Pre-build**: This will generate the container image tag and log in to ECR'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: This will build the new container image'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post-build**: This will push the new container image to ECR and update the
    `latest` tag to point to the new container'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to easily understand what is in each container, we will tag them with
    the SHA of the most recent Git commit in the `helloworld` project. This will help
    in understanding what is in each container, as we will be able to run commands
    such as `git checkout <container tag>` or `git log <container tag>`. Due to how
    CodeBuild and CodePipeline are architected, getting this tag in CodeBuild requires
    a bit of work. We will need to run two complex commands as follows:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: The first one will extract the execution ID of the current code pipeline execution.
    This is achieved by combining the AWS CLI and the environment variables `CODEBUILD_BUILD_ID`
    and `CODEBUILD_INITIATOR`, which are defined by the CodeBuild service when a build
    starts.
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will use that execution ID to extract the artifact revision ID, which
    happens to be the commit SHA we are looking for.
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These commands use some of the most advanced features of the `--query` filter
    option. You can read more about this at the following link: [http://amzn.to/2k7SoLE](http://amzn.to/2k7SoLE).'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: In CodeBuild, each command runs in its own environment, and therefore the easiest
    way to share data across steps is to use temporary files.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: 'Right after the `buildspec` version definition, add the following to generate
    the first part of our pre-build phase and extract the tag:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'Our tag is now present in the `/tmp/tag.txt` file. We now need to generate
    two files as follows:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: The first one will contain the argument for the `docker tag` command (this will
    be something like `<AWS::AccountId>.dkr.ecr.us-east-1.amazonaws.com/helloworld:<tag>`).
    To do that, we will take advantage of the environment variable defined earlier
    in our template.
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second file will be a JSON file that will define a key-value pair with the
    tag. We will use that file a bit later when we work on deploying our new containers
    to ECS.
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After the previous commands, add the following commands to generate those files:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'To conclude the `pre_build` section, we will log in to our `ecr` repository:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'We will now define our build phase. Thanks to the `build_tag` file created
    earlier, the build phase will be straightforward. We will call the `docker build`
    command in a similar way to how we did in the first section of this chapter:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'We will now add the `post_build` phase to complete the build. In this section,
    we will push the newly built container to our `ecr` repository as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In addition to the phases, one of the sections that is also defined in a `buildspec`
    is the `artifacts` section. This section is used to define what needs to be uploaded
    to S3 after the build succeeds, as well as how to prepare it. We will export the
    `build.json` file and set the `discard-paths` variable to true so we don''t preserve
    the `/tmp/` directory information. Finally, we will close our triple quote string
    as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Now that our `buildspec` variable is defined, we can add our CodeBuild project
    resource. Through the instantiation of the project, we will set a name for our
    project, set its environment by calling the variable previously defined, set the
    service role, and configure the source and artifact resources, which define how
    to handle the build process and its output:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'As always, we will conclude the creation of the script with the following `print`
    command:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Our script is now complete and should look like this: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codebuild-cf-template.py).'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: 'We can save the file, add it to git, generate the CloudFormation template,
    and create our stack as follows:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: In a matter of minutes, our stack will be created. We will now want to take
    advantage of it. To do so, we will turn to CodePipeline once again and create
    a brand new, container-aware pipeline.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: Creating our deployment pipeline with CodePipeline
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use AWS CodePipeline to build a pipeline very similar to the one we
    created in Chapter 5, *Adding Continuous Integration and Continuous Deployment*:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22a0888a-7630-48da-9601-20035de62882.png)'
  id: totrans-349
  prefs: []
  type: TYPE_IMG
- en: We will start with a Source step where we will connect to GitHub and trigger
    new pipelines that run automatically when the code changes. After this, we will
    build a new container and push it to our `ecr` repository rely upon the CodeBuild
    project we just created. We will then deploy the new container to staging. To
    do that, we will use the CloudFormation integration provided by CodePipeline,
    combined with the `build.json` file produced in the `buildspec` section of our
    CodeBuild project. You may recall that our `helloworld` service templates take
    the tag to deploy as an argument. We will trigger a stack update action and override
    the default value for that parameter with what's defined in the `build.json` file.
    After that, we will add a manual approval step before triggering the same deployment
    again, but this time for production.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
- en: Deploying and updating CloudFormation templates through CodePipeline will require
    specifying the location of the template within the inputs. In order to easily
    provide it, we will first start by adding the CloudFormation template to our source.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: Adding the CloudFormation template to our code base
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ECS changes are driven by the task definition present in our `helloworld-ecs-service-
    cf.template` file. So far we have only stored our Python script in GitHub. We
    will have to make a special case for that template and store the JSON output of
    it so that CodePipeline can interact with our stack. We will add this file to
    our Git repository in a new directory as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Now that our template is present in our source, we can create our CloudFormation
    template for our pipeline.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
- en: Creating a CloudFormation template for CodePipeline
  id: totrans-356
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start by creating a file called `helloworld-codepipeline-cf- template.py`
    inside EffectiveDevOpsTemplates locally.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start the script with our boilerplates:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'The first resource we will create is the S3 bucket that the pipeline will use
    to store all the artifacts produced by each stage. We will also turn on versioning
    on that bucket:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We will now create the IAM roles needed as follows:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
- en: 'The first role we are going to define will be for the CodePipeline service:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'The second role will be used by the deploy stages to perform CloudFormation
    changes:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'We can now create our pipeline resource. We will first configure its name and
    specify the role **Amazon Resource Name** (**ARN**) of the role we just created:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'After this, we will reference the S3 bucket created earlier so that we have
    a place to store the different artifacts produced through the pipeline execution:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-370
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'We will now define each stage of the pipeline. The CloudFormation structure
    reflects what we did previously using the web interface. Each stage has a unique
    name and is composed of actions. Each action is defined by a name, a category,
    a configuration, and, optionally, input and output artifacts:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our first stage will be the GitHub stage, as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: We will create a first artifact called `App` with the content of the repository.
    In order to avoid hardcoding any `OAuthToken`, we will configure the GitHub integration
    after creating the CloudFormation stack.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our next step will be to configure our build. As mentioned, we will simply
    call out to the CodeBuild stack we spawned up in the last section. We will store
    the output artifact under the name `BuildOutput`, meaning that we now have two
    artifacts: the `App` artifact and `BuildOutput`, which contains the `tag.json`
    file produced by CodeBuild:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: We will now create our staging deployment. Unlike before, we won't use CodeDeploy
    but will directly update our CloudFormation template. In order to accomplish that,
    we will need to provide the location of the template to the configuration of our
    action. Since we added it to our `helloworld` GitHub repository, we can reference
    it with the help of the `App` artifact. Our template is present under `<directory
    root>/templates/helloworld-ecs-service- cf.template`, which in turn means for
    CodePipeline `App::templates/helloworld-ecs-service-cf.template`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next trick in configuring our CloudFormation action relies on the fact
    that we can override the parameters provided for the stack. CloudFormation provides
    a couple of functions to help with dynamic parameters. You can read more about
    those at [http://amzn.to/2kTgIUJ](http://amzn.to/2kTgIUJ). We will focus on a
    particular one here: `Fn::GetParam`. This function returns a value from a key-value
    pair file present in an artifact. This is where we take advantage of the file
    we created in CodeBuild, as it will contain a JSON string in the format `{ "tag":
    "<latest git commit sha>" }`:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'After the staging deployment completes, we will request a manual approval,
    as follows:'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Finally, we will create a last stage to run the production deployment. The
    code is exactly the same here as it is for staging, except for the name of the
    stage and the stack targeted by our configuration:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Our pipeline resource has now been created. We can conclude the creation of
    our script by printing out our template:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The script is now ready to be used. It should look like the script at: [https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py](https://github.com/yogeshraheja/EffectiveDevOpsTemplates/blob/master/helloworld-codepipeline-cf-template.py).'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
- en: We can now create our pipeline.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
- en: Starting and configuring our CloudFormation stack
  id: totrans-388
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will proceed as usual for the first part of our pipeline''s creation, as
    follows:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: We are using the `CAPABILITY_NAMED_IAM` capability in this case, as we are defining
    custom names at the IAM level.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create our pipeline. However, a small catch is that we didn''t specify
    the GitHub credentials in the pipeline. This is because we don''t want to store
    it in clear text in GitHub. AWS offers a service within IAM to do encryption,
    but we won''t cover that in this book. Consequently, we will simply edit the pipeline
    the first time around, as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
- en: Open [https://console.aws.amazon.com/codepipeline](https://console.aws.amazon.com/codepipeline)
    in your browser
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your newly created pipeline
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Edit at the top
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the pen icon on the GitHub action:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/506252fb-0441-4a3c-9b01-ee48aac15212.png)'
  id: totrans-397
  prefs: []
  type: TYPE_IMG
- en: Click on Connect to GitHub on the right-hand-side menu and follow the steps
    to authorize AWS CodePipeline
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select your `helloworld` project in the repository step and the master branch
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Update, save the pipeline changes, and finally, Save and Continue
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After a few seconds, your pipeline will trigger, and you should see your first
    deployment going through. This concludes the creation of our CI/CD pipeline:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5852e5b1-5dc4-4346-814f-96a5c982093c.png)'
  id: totrans-402
  prefs: []
  type: TYPE_IMG
- en: 'You will also be able to see all of the CloudFormation stack details on the
    AWS console with the `CREATE_COMPLETE` status, as shown in the following screenshot:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcd718ba-f6e2-4acc-90ec-f5d648d0aa71.png)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
- en: Summary
  id: totrans-405
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the concept of containers, using Docker and ECS.
    After exploring the basics of how Docker works, we created a container for our
    application. After running it locally, we created a new set of resources to run
    Docker containers on AWS. We did that using the DevOps best practices and used
    CloudFormation to generate our resources, treating our infrastructure as code.
    This allows us to keep those changes under source control. Resource-wise, we created
    an ECR repository to manage the different revisions of our containers. We also
    created two ECS clusters with auto scaling capabilities for staging and production,
    two ALBs to proxy the traffic to our containers, a set of tasks, and an ECS service,
    to configure and deploy our application.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we re-implemented a CI/CD pipeline. We did that by using CodeBuild,
    CodePipeline, and their integrations with CloudFormation.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: We will continue improving our systems and we will implement one of the last
    key characteristics of DevOps; measuring everything. By taking advantage of a
    number of features that are present in the different services that we use, and
    by coupling them with other AWS services (such as CloudWatch), we will be able
    to implement a monitoring strategy for our infrastructure and services.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is Docker? List the important components of Docker Engine.
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you install and configure the latest Docker CE on any supported platform/OS
    of your choice?
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you create a Docker image and use the same image to create a web server
    container?
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you create ECR and ECS using AWS webconsole to get familiar with ECS terminologies?
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-414
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Refer to the following links for further information:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Documentation**: [https://docs.docker.com](https://docs.docker.com)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Hub**: [https://hub.docker.com](https://hub.docker.com)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodeBuild**: [https://aws.amazon.com/codebuild/](https://aws.amazon.com/codebuild/)'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS CodePipeline**: [https://aws.amazon.com/codepipeline/](https://aws.amazon.com/codepipeline/)'
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**AWS Elastic Container Service**: [https://aws.amazon.com/ecs/](https://aws.amazon.com/ecs/)'
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
