- en: Chapter 5.  Going Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will see how to use Ansible for provisioning infrastructures
    in a matter of minutes. In my opinion, this is one of the most interesting and
    powerful capabilities of Ansible, since it allows you to (re-)create environments
    in a quick and consistent way. This is very important when you have multiple environments
    for the various stages of your deployment pipeline. In fact, it allows you to
    create equal environments and to keep them aligned when you need to make changes
    without any pain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Letting Ansible provision your machines also has other advantages, and for
    those reasons I always suggest to do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Audit trail**: In the last few years, the IT sector swallowed a huge number
    of other sectors and as a consequence of this, the auditing processes are now
    looking at IT as a critical part of the process. When an auditor comes to the
    IT department asking for the history of a server, from its creation to the present
    moment, having Ansible playbooks for the whole process helps a lot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiple staging environments**: As we mentioned before, if you have multiple
    environments, provisioning servers with Ansible will help you a lot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Moving servers**: When a company uses a global cloud provider (like AWS or
    DigitalOcean) they often choose the region closest to their offices or customers
    at the moment they create the first servers. Those providers often open new regions
    and if their new region is close to you; you may want to move or extend your infrastructure
    to the new region. This would be a nightmare if you had provisioned every resource
    manually.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, at a broad level, we''ll cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning of machines in **Amazon Web Services** (**AWS**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning of machines in DigitalOcean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provisioning Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Most of the new machine creations have two phases:'
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning a new machine or a new set of machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running playbooks to ensure the new machines are configured properly to play
    their role in your infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We've looked at the configuration management aspect in the initial chapters.
    We'll focus a lot more on provisioning new machines in this chapter with a lesser
    focus on configuration management.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning resources in the cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With that, let''s jump to the first topic. Teams managing infrastructures have
    a lot of choices today for running their builds, tests, and deployments. Providers
    such as Amazon, Rackspace, and DigitalOcean primarily provide **Infrastructure
    as a Service** (**IaaS**). When we speak about IaaS, it''s better to speak about
    resources not virtual machines for different reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The majority of the products that those companies allow you to provision are
    not machines but other critical resources such as networking and storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lately, many of those companies have started to provide many different kind
    of compute instances ranging from bare-metal machines to containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up machines with no networking (or storage) could be all you need for
    some very simple environments, but might not be enough in production environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those companies usually provide API, CLI, GUI, and SDK utilities to create and
    manage cloud resources throughout their whole lifecycle. We're more interested
    in using their SDK as it will play an important part in our automation effort.
    Setting up new servers and provisioning them is interesting at first but at some
    stage it can become boring as it's quite repetitive in nature. Each provisioning
    step will involve several similar steps to get them up-and-running.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine one fine morning you receive an e-mail asking for three new customer
    setups, where each customer setup has three to four instances and a bunch of services
    and dependencies. This might be an easy task for you, but would require running
    the same set of repetitive commands multiple times, followed by monitoring the
    servers once they come up to confirm that everything went well. In addition, anything
    you do manually has a chance of introducing problems. What if two of the customer
    setups come up correctly but, due to fatigue, you miss out a step for the third
    customer and hence introduce a problem? To deal with such situations, there exists
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: Cloud provisioning automation makes it easy for an engineer to build up a new
    server as quickly as possible, allowing her to concentrate on other priorities.
    Using Ansible, you can easily perform these actions and automate cloud provisioning
    with minimal effort. Ansible provides you with the power to automate various different
    cloud platforms, such as Amazon, Azure, DigitalOcean, Google Cloud, Rackspace,
    and many more, with modules for different services available in the Ansible core
    or extended module packages.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As mentioned earlier, bringing up new machines is not the end of the game. We
    also need to make sure we configure them to play the required role.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next sections we will provision the environment that we have used in
    the previous chapters (two web servers and one database server) in the following
    environments:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Simple Amazon Web Service deployment**: Where all machines will be placed
    in the same Availability Zone and same network'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Complex Amazon Web Service deployment**: Where the machines will be split
    in multiple Availability Zones as well as networks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DigitalOcean**: DigitalOcean does not allow us to do many networking tweaks
    so it will be similar to the first one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker**: We will create a simple deployment in this case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon Web Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Amazon Web Service is the most used public cloud by a fair amount and it's often
    chosen due to their huge amount of available services as well as the huge amount
    of documentation, answered questions, and articles that can be expected from such
    a popular product.
  prefs: []
  type: TYPE_NORMAL
- en: Since AWS' goal is to be a complete virtual data center provider (and much more)
    we will need to create and manage our network as we would do if we had to set
    up a real data center. Obviously, we will not need to cable stuff since it's a
    virtual data center. Due to this, a few lines of an Ansible playbook will be enough.
  prefs: []
  type: TYPE_NORMAL
- en: AWS global infrastructure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amazon has always been pretty discrete about sharing the location or the exact
    number of data centers that their cloud is actually composed of. While I'm writing
    this, AWS counts 13 regions (with 4 more regions already planned) with a total
    of 35 **Availability Zones** (**AZ**) and more than 50 edge locations. Amazon
    defines a region as a physical location in the world where we (Amazon) have multiple
    Availability Zones. Looking at Amazon's definition of Availability Zones, it says
    that an AZ consists of one or more discrete data centers, each with redundant
    power, networking, and connectivity, housed in separate facilities. For edge location,
    there is no official definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, from a real life point of view, those definitions do not help
    you much. When I try to explain those concepts I usually use different definitions,
    created by myself:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Region**: Group of AZs that are physically close'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Availability Zone**: A data center in a region (Amazon says that it could
    be more than one data center, but since there is no document listing the specific
    layout of every AZ, I assume the worst-case scenario)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Edge location**: Internet exchanges or 3rd party data centers where Amazon
    has S3 and Route 53 endpoints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though I tried to make those definitions as easy and as useful as possible,
    some of them are very cloudy. When we start to speak about real world differences,
    the definitions will become immediately clear. For instance, from a network speed
    perspective, when you move content within the same AZ, the bandwidth is very high.
    When you do the same operation with two AZs in the same region you get high bandwidth,
    while if you use two AZs from two different regions, the bandwidth will be much
    lower. Also, there is a price difference, since all traffic within the same region
    is free, while traffic between different regions is not free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Simple Storage Service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Amazon S3 is the first AWS service to be launched and it's also one of the most
    well-known AWS services. Amazon S3 is an object storage service with public endpoints
    as well as private endpoints. It uses the concept of a bucket to allow you different
    kinds of files and to manage them in a simple way. Amazon S3 also gives the user
    more advanced features such as the capability of serving a bucket's contents using
    a built-in web server. This is one of the reasons why many people decide to host
    their website, or the pictures on their websites, on Amazon S3.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages of S3 are mainly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Price schema**: You are billed by used gigabyte/month and by gigabyte transferred.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reliability**: Amazon affirms that the objects on AWS S3 have a 99.999999999%
    probability to survive any given year. This is orders of magnitude higher than
    any hard disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tooling**: Since S3 is a service that has been out there for many years now,
    a lot of tools have been implemented to leverage this service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AWS Elastic Compute Cloud (EC2)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second service launched by AWS is the EC2 service. This service allows you
    to spin up virtual machines on AWS infrastructure. You can think of those EC2
    instances as OpenStack compute instances or VMware virtual machines. Initially,
    those machines were very similar to VPS, but after a while, Amazon decided to
    give much more flexibility on those machines introducing a very advanced networking
    option. The old kind of machines are still available in the oldest data centers
    with the name **EC2 Classic**, while the new kind is the current default and is
    just called **EC2**.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Virtual Private Cloud (VPC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The VPC is Amazon''s networking implementation which we mentioned in the previous
    paragraph. The VPC is more a set of tools than a single tool, in fact, the capabilities
    it offers were offered by multiple metal boxes in the classic data center. The
    main things you can create with VPC are:'
  prefs: []
  type: TYPE_NORMAL
- en: Switches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: DHCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gateways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firewalls
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual Private Networks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An important thing to understand when you use VPC is that the layout of your
    network is not completely arbitrary, since Amazon has created a few limitations
    to simplify their networking. The basic limitations are:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot spawn a subnetwork between AZ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot spawn a network between regions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot route networks in different regions directly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While, for the first two, the only solution is creating multiple networks and
    subnetworks, for the third, you can actually implement a workaround using a VPN
    service which could be self-provisioned or be provisioned using the official AWS
    VPN service.
  prefs: []
  type: TYPE_NORMAL
- en: We will be mainly using the switching and routing capabilities of VPC.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Route 53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like many other cloud services, Amazon offers a **DNS as a Service** (**DNSaaS**)
    feature and in Amazon case, it's called **Route 53**. Route 53 is a distributed
    DNS service with more than 50 endpoints worldwide (Route 53 is present in all
    AWS edge locations).
  prefs: []
  type: TYPE_NORMAL
- en: Route 53 allows you to create different zones for a domain allowing split-horizon
    situations in which, based on the fact that the client asking for a DNS resolution
    is inside or outside your VPC, will receive different responses. This is very
    useful when you want your applications to be easily moved in and out of your VPC
    without changes but at the same time, you want your traffic to stay on a private
    (virtual) network whenever possible.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Elastic Block Storage (EBS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: AWS **EBS** is a block storage provider for allowing your EC2 instances to keep
    data that will survive reboots and is very flexible. From a user perspective,
    EBS seems a lot like any other SAN product with a simpler interface, since you
    only need to create the volume and tell EBS to which machine it needs to be attached,
    and EBS does the rest. You can attach multiple volumes to a single server, but
    every volume can be connected to only one server at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: AWS Identity and Access Management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To allow you to manage users and access methods, Amazon provides the **IAM**
    service. The main features of the IAM service are:'
  prefs: []
  type: TYPE_NORMAL
- en: Create, edit, and delete users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change user password
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create, edit, and delete groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage users and group association
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage two-factor authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manage SSH keys
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using this service to set up our users and their permissions.
  prefs: []
  type: TYPE_NORMAL
- en: Amazon relational database service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Setting up and maintaining relational databases is complex and very time-consuming.
    To simplify this, Amazon provides some widely used DBaaS, more specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: Aurora
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MariaDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MySQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Oracle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PostgreSQL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For each one of those engines, Amazon offers different features and price models
    but the specifics of each is beyond the goal of this book.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an account with AWS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we will need before starting to work on our Amazon Web Service
    is an account. Creating an account on Amazon Web Services is pretty straightforward
    and very well-documented by Amazon official documentation as well as by multiple
    independent sites and therefore it will not be covered in these pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have created your AWS account, you need to go into the AWS and do
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Upload your SSH key in **EC2** | **Keypairs**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create a new user in **Identity & Access Management** | **Users** | **Create
    new user** and create a file in `~/.aws/credentials` with the following lines:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'After you have created your AWS Keys and uploaded your SSH key, you need to
    set up Route53\. In Route53 you need to create two zones for your domain (you
    can also use a subdomain if you don''t have an unused domain): one **public**
    and one **private**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you create only the public zone, Route53 will propagate this zone everywhere,
    but if you create a public and a private zone, Route53 will serve your public
    zone everywhere but in the VPC you specified when creating the private zone. If
    you query those DNS entries from within that VPC, the private zone will be used.
    This approach has multiple advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Only publicize the IP addresses of public machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Always use DNS names instead of IP addresses, even for internal traffic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that your internal machines communicate directly without your traffic
    ever passing through the public web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the external IPs in Amazon Web Services are virtual IPs managed by Amazon
    and associated to your instances using NATs, this approach grants the least amount
    of hops and therefore latency
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you declared an entry for your public zone but not in the private one, the
    machines in the VPC will not be able to resolve that entry.
  prefs: []
  type: TYPE_NORMAL
- en: After you have created the public zone, Amazon Web Services will give you a
    few name server IP addresses and you need to put those in your register/root zone
    DNS so that you can actually resolve those DNS.
  prefs: []
  type: TYPE_NORMAL
- en: Simple AWS deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we said previously, the first thing that we will need is the networking up.
    For this example, we will need just one single network in one AZ and all our machines
    will stay there.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will be working in the `playbooks/aws_simple_provision.yaml`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first two lines are just used to declare the host that will perform the
    commands (`localhost`) and the beginning of the `tasks` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In AWS, we need to have a VPC network and subnetwork, but in case you need
    it, you can do the following to create the VPC network:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have all the information we need on the network and subnetwork, we can
    move to **security groups**. We can do this with the `ec2_group` module. In the
    Amazon Web Service world, security groups are used for firewalling. Security groups
    are very similar to groups of firewall rules that share the same destination (for
    ingress rules) or same destination (for egress rules). Three differences with
    standard firewalls rules are actually worth mentioning:'
  prefs: []
  type: TYPE_NORMAL
- en: Multiple security groups can be applied to the same EC2 instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As source (for ingress rules) or destination (for egress rules), you can specify
    one of the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An instance ID
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Another security group
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An IP range
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: You don't have to specify a default deny rule at the end of the chain because
    AWS will add it by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in my case, the following code will be added to `playbooks/aws_simple_provision.yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We are now going to create another security group for our database. In this
    case, we only need to open port `3036` to the servers in the web security group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, we allow all egress traffic to flow. This is not what security
    best practices suggest, and therefore you may need to regulate egress traffic
    as well. A case that frequently forces you to regulate egress traffic is if you
    want your target machine to be PCI-DSS compliant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the VPC, the subnet into the VPC, and the needed security
    groups, we can now move on to actually creating the EC2 instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we created the `db` machine we did not specify the `assign_public_ip`:
    `True` line. In this case, the machine will not receive a public IP and therefore
    it will not be reachable from outside our VPC. Since we used a very strict security
    group for this server, it would not be reachable from any machine outside the
    `wssg` anyway.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can guess, the piece of code we have just seen will create our three
    instances (two web servers and one database server).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now proceed to add those newly created instances to our Route 53 account
    so that we can resolve those machines'' FQDN. To interact with AWS Route 53, we
    will be using the `route53` module, which allows us to create entries, query entries,
    and delete entries. To create a new entry, we will be using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So to create the entries for our servers, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since the database server does not have a public address, it makes no sense
    to publish this machine in the public zone, so we have created this machine entry
    only in the internal zone.
  prefs: []
  type: TYPE_NORMAL
- en: 'Putting it all together, the `playbooks/aws_simple_provision.yaml` will be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Running it with `ansible-playbook playbooks/aws_simple_provision.yaml`, we
    will have an output similar to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Complex AWS deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this paragraph, we will slightly change the previous example to move one
    of the web servers to another AZ within the same region. To do so, we are going
    to make a new file in `playbooks/aws_complex_provision.yaml` which will be very
    similar to the previous one, with one difference located in the part that helps
    us provision the machines. In fact, we will use the following code instead of
    the one we used on the previous run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have put the `vpc_subnet_id` in a variable, so that we can
    use a different one for the `ws02` machine. Due to the fact that AWS already provides
    two subnets by default (and every subnet is tied to a different AZ), it's enough
    to use the following AZ. Security groups and Route 53 code does not need to be
    changed since it does not work at a subnet/AZ level, but at a VPC level (for security
    groups and internal Route 53 zone) or global level (for public Route 53).
  prefs: []
  type: TYPE_NORMAL
- en: DigitalOcean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compared to Amazon Web Services, DigitalOcean seems to be very incomplete.
    DigitalOcean, until a few months ago only provided droplets, SSH key management,
    and DNS management. At the time of writing this, DigitalOcean has very recently
    launched an additional block storage service. The advantages of DigitalOcean compared
    to many competitors are:'
  prefs: []
  type: TYPE_NORMAL
- en: Lower prices than AWS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very easy APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Very well documented APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The droplets are very similar to standard virtual machines (they don't do weird
    customization)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The droplets are very quick to go up and down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since DigitalOcean has a very simple networking stack, it's way more efficient
    than the AWS one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Droplets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Droplets are the main service offered by DigitalOcean and are compute instances
    which are very similar to Amazon EC2 classic. DigitalOcean relies on the **Kernel
    Virtual Machine** (**KVM**) to virtualize the machines, assuring very high performance
    and security. Since they do not change KVM in any sensible way, and since KVM
    is open source and available on any Linux machine, this allows system administrators
    to create identical environments on private and public clouds. DigitalOcean droplets
    will have one external IP and they can be eventually added to a virtual network
    that will allow your machines to use internal IPs.
  prefs: []
  type: TYPE_NORMAL
- en: Different from many other comparable services, DigitalOcean allows your droplets
    to have IPv6 IPs in addition to the IPv4 ones. This service is free of charge.
  prefs: []
  type: TYPE_NORMAL
- en: SSH key management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time you want to create a droplet, you have to specify if you want a specific
    SSH key assigned to the `root` user or if you want a password (which will have
    to be changed at the first login). To be able to choose an SSH key, you need an
    interface to upload it. DigitalOcean allows you to do this using a very simple
    interface which allows you to list the current keys, as well as create and delete
    keys.
  prefs: []
  type: TYPE_NORMAL
- en: Private networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned in the droplet paragraph, DigitalOcean allows us to have a private
    network where our machine can communicate with another. This allows segregation
    of services (like a database service) only on the internal network to allow a
    higher level of security. Since by default, MySQL binds on all available interfaces,
    we will need to tweak the database role a little bit to only bind on the internal
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'To recognize the internal network from the external one there are many ways,
    due to some DigitalOcean peculiarities:'
  prefs: []
  type: TYPE_NORMAL
- en: Private networks are always in the `10.0.0.0/8` network, while public IPs are
    never in that network
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The public network is always `eth0` while the private network is always `eth1`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Based on your portability needs, you can use either one of those strategies
    to understand where to bind your services.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an SSH key in DigitalOcean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You need to have a DigitalOcean user with the credit card set up, and have
    obtained API key. To perform those operations, you can use DigitalOcean web interface.
    We can now start to use Ansible to add our SSH key to our DigitalOcean cloud.
    To do so, we need to create a file called `playbooks/do_provision.yaml` with the
    following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In my case, this is my file content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can execute it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'and you will have a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This task is idempotent so we can execute it multiple times. In case the key
    has already been uploaded, the SSH key ID will be returned at every run.
  prefs: []
  type: TYPE_NORMAL
- en: Deployment in DigitalOcean
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the time of writing, the only way to create a droplet in Ansible is by using
    the `digital_ocean` module which could be soon deprecated since many of its features
    are now done in a better, cleaner way by other modules and there is already a
    bug on Ansible bug tracker to track its complete rewrite and possible deprecation.
    My guess is that the new module will be called `digital_ocean_droplet` and will
    have a similar syntax, but at the moment there is no code so it's just my guess.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the droplets, we will have to use the `digital_ocean` module with
    a syntax similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To make sure that all our provisioning is done completely and in a sane way,
    I always suggest creating one single provision file for the whole infrastructure.
    So, in my case, I''ll add the following task to the `playbooks/do_provision.yaml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'After this, we can add the domain with the `digital_ocean_domain` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, putting all this together, our `playbooks/do_provision.yaml` will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So we can now run it with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We will see a result similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how we can provision our machines in both the
    AWS cloud and the DigitalOcean one. In the case of the AWS cloud, we have seen
    two different examples, one very simple and one slightly more complex.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will talk about getting notified by Ansible if something
    went wrong.
  prefs: []
  type: TYPE_NORMAL
