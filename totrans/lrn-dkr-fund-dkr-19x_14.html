<html><head></head><body>
        

                            
                    <h1 class="header-title">Docker Compose</h1>
                
            
            
                
<p>In the previous chapter, we learned a lot about how container networking works on a single Docker host. We introduced the <strong>Container Network Model</strong> (<strong>CNM</strong>), which forms the basis of all networking between Docker containers, and then we dove deep into different implementations of the CNM, specifically the bridge network. Finally, we introduced Traefik, a reverse proxy, to enable sophisticated HTTP application-level routing between containers.</p>
<p>This chapter introduces the concept of an application consisting of multiple services, each running in a container, and how Docker Compose allows us to easily build, run, and scale such an application using a declarative approach.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Demystifying declarative versus imperative</li>
<li>Running a multi-service application</li>
<li>Scaling a service</li>
<li>Building and pushing an application</li>
<li>Using Docker Compose overrides</li>
</ul>
<p>After completing this chapter, the reader will be able to do the following:</p>
<ul>
<li>Explain in a few short sentences the main differences between an imperative and declarative approach for defining and running an application</li>
<li>Describe in their own words the difference between a container and a Docker Compose service</li>
<li>Author a Docker Compose YAML file for a simple multi-service application</li>
<li>Build, push, deploy, and tear down a simple multi-service application using Docker Compose</li>
<li>Use Docker Compose to scale an application service up and down</li>
<li>Define environment-specific Docker Compose files using overrides</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>The code accompanying this chapter can be found at <a href="https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch11" target="_blank">https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch11</a>.</p>
<p>You need to have <kbd>docker-compose</kbd> installed on your system. This is automatically the case if you have installed Docker for Desktop or Docker Toolbox on your Windows or macOS computer. Otherwise, you can find detailed installation instructions here: <a href="https://docs.docker.com/compose/install/" target="_blank">https://docs.docker.com/compose/install/</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Demystifying declarative versus imperative</h1>
                
            
            
                
<p>Docker Compose is a tool provided by Docker that is mainly used where you need to run and orchestrate containers running on a single Docker host. This includes, but is not limited to, development, <strong>continuous integration</strong> (<strong>CI</strong>), automated testing, manual QA, or demos.</p>
<p>Docker Compose uses files formatted in YAML as input. By default, Docker Compose expects these files to be called <kbd>docker-compose.yml</kbd>, but other names are possible. The content of a <kbd>docker-compose.yml</kbd> is said to be a <em>declarative</em> way of describing and running a containerized application potentially consisting of more than a single container.</p>
<p>So, <em>what is the meaning of declarative?</em></p>
<p>First of all, <em>declarative</em> is the antonym of <em>imperative</em>. Well, that doesn't help much. Now that I have introduced another definition, I need to explain both of them:</p>
<ul>
<li><strong>Imperative: </strong>This is a way in which we can solve problems by specifying the exact procedure that has to be followed by the system.</li>
</ul>
<p style="padding-left: 60px">If I tell a system such as the Docker daemon imperatively how to run an application, then that means that I have to describe step by step what the system has to do and how it has to react if some unexpected situation occurs. I have to be very explicit and precise in my instructions. I need to cover all edge cases and how they need to be treated.</p>
<ul>
<li><strong>Declarative:</strong> This is a way in which we can solve problems without requiring the programmer to specify an exact procedure to be followed.</li>
</ul>
<p style="padding-left: 60px">A declarative approach means that I tell the Docker engine what my desired state for an application is and it has to figure out on its own how to achieve this desired state and how to reconcile it if the system deviates from it.</p>
<p>Docker clearly recommends the declarative approach when dealing with containerized applications. Consequently, the Docker Compose tool uses this approach. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running a multi-service app</h1>
                
            
            
                
<p>In most cases, applications do not consist of only one monolithic block, but rather of several application services that work together. When using Docker containers, each application service runs in its own container. When we want to run such a multi-service application, we can, of course, start all the participating containers with the well-known <kbd>docker container run</kbd> command, and we have done this in previous chapters. But this is inefficient at best. With the Docker Compose tool, we are given a way to define the application in a declarative way in a file that uses the YAML format.</p>
<p>Let's have a look at the content of a simple <kbd>docker-compose.yml</kbd> file:</p>
<pre style="padding-left: 30px">version: "2.4"<br/>services:<br/> web:<br/>    image: fundamentalsofdocker/ch11-web:2.0<br/>    build: web<br/>    ports:<br/>    - 80:3000<br/> db:<br/>    image: fundamentalsofdocker/ch11-db:2.0<br/>    build: db<br/>    volumes:<br/>    - pets-data:/var/lib/postgresql/data<br/><br/>volumes:<br/> pets-data:</pre>
<p>The lines in the file are explained as follows:</p>
<ul>
<li><kbd>version</kbd>: In this line, we specify the version of the Docker Compose format we want to use. At the time of writing, this is version 2.4.</li>
<li><kbd>services</kbd>: In this section, we specify the services that make up our application in the <kbd>services</kbd> block. In our sample, we have two application services and we call them <kbd>web</kbd> and <kbd>db</kbd>:</li>
<li><kbd>web</kbd>: The <kbd>web</kbd> service is using an image called <kbd>fundamentalsofdocker/ch11-web:2.0</kbd>, which, if not already in the image cache, is built from the <kbd>Dockerfile</kbd> found in the <kbd>web</kbd> folder . The service is also publishing container port <kbd>3000</kbd> to the host port <kbd>80</kbd>.</li>
<li><kbd>db</kbd>: The <kbd>db</kbd> service, on the other hand, is using the image name <kbd>fundamentalsofdocker/ch11-db:2.0</kbd>, which is a customized PostgreSQL database. Once again, if the image is not already in the cache, it is built from the <kbd>Dockerfile</kbd> found in the <kbd>db</kbd> folder . We are mounting a volume called <kbd>pets-data</kbd> into the container of the <kbd>db</kbd> service.</li>
</ul>
<ul>
<li><kbd>volumes</kbd>: The volumes used by any of the services have to be declared in this section. In our sample, this is the last section of the file. The first time the application is run, a volume called <kbd>pets-data</kbd> will be created by Docker and then, in subsequent runs, if the volume is still there, it will be reused. This could be important when the application, for some reason, crashes and has to be restarted. Then, the previous data is still around and ready to be used by the restarted database service.</li>
</ul>
<p>Note that we are using version 2.x of the Docker Compose file syntax. This is the one targeted toward deployments on a single Docker host. There exists also a version 3.x of the Docker Compose file syntax. This version is used when you want to define an application that is targeted either at Docker Swarm or Kubernetes. We will discuss this in more detail starting with <a href="27c0d9ce-fab6-4ce9-9034-4f2fb62931e8.xhtml" target="_blank">Chapter 12</a>, <em>Orchestrators</em>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building images with Docker Compose</h1>
                
            
            
                
<p>Navigate to the <kbd>ch11</kbd> subfolder of the <kbd>fods</kbd> folder and then build the images:</p>
<pre><strong>$</strong> <strong>cd ~/fod/ch11</strong><br/><strong>$</strong> <strong>docker-compose build</strong></pre>
<p>If we enter the preceding command, then the tool will assume that there must be a file in the current directory called <kbd>docker-compose.yml</kbd> and it will use that one to run. In our case, this is indeed the case and the tool will build the images.</p>
<p>In your Terminal window, you should see an output similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/9c627297-4997-47b2-804b-19cc63213e24.png" style="width:39.83em;height:43.58em;"/></p>
<p>Building the Docker image for the web service</p>
<p>In the preceding screenshot, you can see that <kbd>docker-compose</kbd> first downloads the base image <kbd>node:12.12-alpine</kbd>, for the web image we're building from Docker Hub. Subsequently, it uses the <kbd>Dockerfile</kbd> found in the <kbd>web</kbd> folder to build the image and names it <kbd>fundamentalsofdocker/ch11-web:2.0</kbd>. But this is only the first part; the second part of the output should look similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3fe4b4e5-ab79-4dbe-ae7a-46388ff69cd4.png" style="width:39.17em;height:32.75em;"/></p>
<p>Building the Docker image for the db service</p>
<p>Here, once again, <kbd>docker-compose</kbd> pulls the base image, <kbd>postgres:12.0-alpine</kbd>, from Docker Hub and then uses the <kbd>Dockerfile</kbd> found in the <kbd>db</kbd> folder to build the image we call <kbd>fundamentalsofdocker/ch11-db:2.0</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Running an application with Docker Compose</h1>
                
            
            
                
<p>Once we have built our images, we can start the application using Docker Compose:</p>
<pre><strong>$ docker-compose up</strong></pre>
<p>The output will show us the application starting. We should see the following:</p>
<div><img src="img/ac776f44-7157-4362-afa0-9cc470ee5b4b.png" style="width:40.08em;height:31.58em;"/></div>
<p>Running the sample application, part 1</p>
<p>In this first part of the output, we see how Docker Compose does the following:</p>
<ul>
<li>Creates a bridge network called <kbd>ch11_default</kbd></li>
<li>Creates a volume called <kbd>ch11_pets-data</kbd></li>
<li>Creates the two services, <kbd>ch11_web_1</kbd> and <kbd>ch11_db_1</kbd>, and attaches them to the network</li>
</ul>
<p>Docker Compose then also shows log output generated by the database (blue) and by the web service (yellow) that are both stating up. The third last line in the output shows us that the web service is ready and listens at port <kbd>3000</kbd>. Remember though that this is the container port and not the host port. We have mapped container port <kbd>3000</kbd> to host port <kbd>80</kbd>, and that is the port we will be accessing later on.</p>
<p>Now let's look at the second part of the output:</p>
<div><img src="img/c7d558d6-4970-4696-a92c-6bd8fc46128e.png" style="width:50.33em;height:39.42em;"/></div>
<p>Running the sample application, part 2</p>
<p>We have shortened the second part of the output a bit. It shows us how the database finalizes its initialization. We can specifically see how our initialization script, <kbd>init-db.sql</kbd>, is applied, which defines a database and seeds it with some data.</p>
<p>We can now open a browser tab and navigate to <kbd>localhost/animal</kbd>. We should be greeted by a wild animal whose picture I took at the Masai Mara national park in Kenya:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-945 image-border" src="img/fa80d99d-40f4-45af-99d6-ec013f32cdba.png" style="width:43.50em;height:35.00em;"/></p>
<p>The sample application in the browser</p>
<p>Refresh the browser a few times to see other cat images. The application selects the current image randomly from a set of 12 images whose URLs are stored in the database.</p>
<p>As the application is running in interactive mode and, thus, the Terminal where we ran Docker Compose is blocked, we can cancel the application by pressing <em>Ctrl </em>+ <em>C</em>. If we do so, we will see the following:</p>
<pre><strong>^CGracefully stopping... (press Ctrl+C again to force)</strong><br/><strong>Stopping ch11_web_1 ... done</strong><br/><strong>Stopping ch11_db_1 ... done</strong></pre>
<p>We will notice that the database and the web services stop immediately. Sometimes, though, some services will take about 10 seconds to do so. The reason for this is that the database and the web service listen to, and react to, the <kbd>SIGTERM</kbd> signal sent by Docker while other services might not, and so Docker kills them after a predefined timeout interval of 10 seconds.</p>
<p>If we run the application again with <kbd>docker-compose up</kbd>, the output will be much shorter:</p>
<div><img src="img/24c4d502-363e-4c41-a0c7-f441ac0e6cee.png"/></div>
<p>Output of docker-compose up</p>
<p>This time, we didn't have to download the images and the database didn't have to initialize from scratch, but it was just reusing the data that was already present in the <kbd>pets-data</kbd> volume from the previous run.</p>
<p>We can also run the application in the background. All containers will run as daemons. For this, we just need to use the <kbd>-d</kbd> parameter, as shown in the following code:</p>
<pre><strong>$ docker-compose up -d</strong></pre>
<p>Docker Compose offers us many more commands than just <kbd>up</kbd>. We can use the tool to list all services that are part of the application:</p>
<div><img src="img/4de77740-ac1d-4bb2-9f8f-0c0b203897d4.png" style="width:28.67em;height:4.67em;"/></div>
<p>Output of docker-compose ps</p>
<p>This command is similar to <kbd>docker container ls</kbd>, with the only difference being that <kbd>docker-compose</kbd> only lists containers or services that are part of the application.</p>
<p>To stop and clean up the application, we use the <kbd>docker-compose down</kbd> command:</p>
<pre><strong>$ docker-compose down</strong><br/>Stopping ch11_web_1 ... done<br/>Stopping ch11_db_1 ... done<br/>Removing ch11_web_1 ... done<br/>Removing ch11_db_1 ... done<br/>Removing network ch11_default</pre>
<p>If we also want to remove the volume for the database, then we can use the following command:</p>
<pre><strong>$ docker volume rm ch11_pets-data</strong></pre>
<p>Alternatively, instead of using the two commands, <kbd>docker-compose down</kbd> and <kbd>docker volume rm &lt;volume name&gt;</kbd>, we can combine them into a single command:</p>
<pre><strong>$ docker-compose down -v</strong></pre>
<p>Here, the argument <kbd>-v</kbd> (or <kbd>--volumes</kbd>) removes named volumes declared in the <kbd>volumes</kbd> section of the <kbd>compose</kbd> file and anonymous volumes attached to containers.</p>
<p>Why is there a <kbd>ch11</kbd> prefix in the name of the volume? In the <kbd>docker-compose.yml</kbd> file, we have called the volume to use <kbd>pets-data</kbd>. But, as we have already mentioned, Docker Compose prefixes all names with the name of the parent folder of the <kbd>docker-compose.yml</kbd> file plus an underscore. In this case, the parent folder is called <kbd>ch11</kbd>. If you don't like this approach, you can define a project name explicitly, for example, as follows:</p>
<pre><strong>$ docker-compose -p my-app up</strong></pre>
<p>which uses a project name my-app for the application to run under.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scaling a service</h1>
                
            
            
                
<p>Now, let's, for a moment, assume that our sample application has been live on the web and become very successful. Loads of people want to see our cute animal images. So now we're facing a problem, since our application has started to slow down. To counteract this problem, we want to run multiple instances of the web service. With Docker Compose, this is readily done.</p>
<p>Running more instances is also called scaling up. We can use this tool to scale our <kbd>web</kbd> service up to, say, three instances:</p>
<pre><strong>$ docker-compose up --scale web=3</strong></pre>
<p>If we do this, we are in for a surprise. The output will look similar to the following screenshot:</p>
<div><img src="img/6c367f83-aae2-4c84-b5bb-6547f80846ae.png"/></div>
<p>Output of docker-compose --scale</p>
<p>The second and third instances of the web service fail to start. The error message tells us why: we cannot use the same host port <kbd>80</kbd> more than once. When instances 2 and 3 try to start, Docker realizes that port <kbd>80</kbd> is already taken by the first instance. <em>What can we do?</em> Well, we can just let Docker decide which host port to use for each instance.</p>
<p>If, in the <kbd>ports</kbd> section of the <kbd>compose</kbd> file, we only specify the container port and leave out the host port, then Docker automatically selects an ephemeral port. Let's do exactly this:</p>
<ol>
<li>First, let's tear down the application:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker-compose down</strong></pre>
<ol start="2">
<li>Then, we modify the <kbd>docker-compose.yml</kbd> file to look as follows:</li>
</ol>
<pre style="padding-left: 60px">version: "2.4"<br/>services:<br/>  web:<br/>    image: fundamentalsofdocker/ch11-web:2.0<br/>    build: web<br/>    ports:<br/>      - 3000<br/>  db:<br/>    image: fundamentalsofdocker/ch11-db:2.0<br/>    build: db<br/>    volumes:<br/>      - pets-data:/var/lib/postgresql/data<br/><br/>volumes:<br/>  pets-data:</pre>
<ol start="3">
<li>Now, we can start the application again and scale it up immediately after that: </li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker-compose up -d</strong><br/><strong>$ docker-compose up -d --scale web=3</strong><br/>Starting ch11_web_1 ... done<br/>Creating ch11_web_2 ... done<br/>Creating ch11_web_3 ... done</pre>
<ol start="4">
<li>If we now do <kbd>docker-compose ps</kbd>, we should see the following screenshot:</li>
</ol>
<div><img src="img/608fb23b-b615-4b34-b389-37d014004c77.png" style="width:31.50em;height:6.75em;"/></div>
<p>Output of docker-compose ps</p>
<ol start="5">
<li>As we can see, each service has been associated to a different host port. We can try to see whether they work, for example, using <kbd>curl</kbd>. Let's test the third instance, <kbd>ch11_web_3</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ curl -4 localhost:32772</strong><br/>Pets Demo Application</pre>
<p>The answer, <kbd>Pets Demo Application</kbd>, tells us that, indeed, our application is still working as expected. Try it out for the other two instances to be sure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building and pushing an application</h1>
                
            
            
                
<p>We have seen earlier that we can also use the <kbd>docker-compose build</kbd> command to just build the images of an application defined in the underlying <kbd>docker-compose</kbd> file. But to make this work, we'll have to add the build information to the <kbd>docker-compose</kbd> file. In the folder, we have a file, <kbd>docker-compose.dev.yml</kbd>, which has those instructions already added. It is basically a copy of the <kbd>docker-compose.yml</kbd> file we have used so far:</p>
<pre>version: "2.4"<br/>services:<br/>  web:<br/>    build: web<br/>    image: fundamentalsofdocker/ch11-web:2.0<br/>    ports:<br/>      - 80:3000<br/>  db:<br/>    build: db<br/>    image: fundamentalsofdocker/ch1-db:2.0<br/>    volumes:<br/>      - pets-data:/var/lib/postgresql/data<br/><br/>volumes:<br/>  pets-data:</pre>
<p>Please note the <kbd>build</kbd> key for each service. The value of that key indicates the context or folder where Docker is expecting to find the <kbd>Dockerfile</kbd> to build the corresponding image. If we wanted to use a <kbd>Dockerfile</kbd> that is named differently, say <kbd>Dockerfile-dev</kbd>, for the <kbd>web</kbd> service, then the <kbd>build</kbd> block in the <kbd>docker-compose</kbd> file would look like this:</p>
<pre>build:<br/>    context: web<br/>    dockerfile: Dockerfile-dev</pre>
<p>Let's use that alternative <kbd>docker-compose-dev.yml</kbd> file now:</p>
<pre><strong>$ docker-compose -f docker-compose.dev.yml build</strong></pre>
<p>The <kbd>-f</kbd> parameter will tell the Docker Compose application which <kbd>compose</kbd> file to use.</p>
<p>To push all images to Docker Hub, we can use <kbd>docker-compose push</kbd>. We need to be logged in to Docker Hub so that this succeeds, otherwise we get an authentication error while pushing. Thus, in my case, I do the following:</p>
<pre><strong>$ docker login -u fundamentalsofdocker -p &lt;password&gt;</strong></pre>
<p>Assuming the login succeeds, I can then push the following code:</p>
<pre><strong>$ docker-compose -f docker-compose.dev.yml push</strong></pre>
<p>This may take a while, depending on the bandwidth of your internet connection. While pushing, your screen may look similar to this:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/3add68f8-5a90-4edb-96a4-68743bff811b.png" style="width:33.67em;height:9.50em;"/></p>
<p>Pushing images with docker-compose to Docker Hub</p>
<p>The preceding command pushes the two images to the <kbd>fundamentalsofdocker</kbd> account on Docker Hub. You can find these two images at the following URL: <a href="https://hub.docker.com/u/fundamentalsofdocker/" target="_blank">https://hub.docker.com/u/fundamentalsofdocker/</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Docker Compose overrides</h1>
                
            
            
                
<p>Sometimes, we want to run our applications in different environments that need specific configuration settings. Docker Compose provides a handy capability to address exactly this issue.</p>
<p>Let's make a specific sample. We can define a base Docker Compose file and then define environment-specific overrides. Let's assume we have a file called <kbd>docker-compose.base.yml</kbd> with the following content:</p>
<pre>version: "2.4"<br/>services:<br/>  web:<br/>    image: fundamentalsofdocker/ch11-web:2.0<br/>  db:<br/>    image: fundamentalsofdocker/ch11-db:2.0<br/>    volumes:<br/>      - pets-data:/var/lib/postgresql/data<br/><br/>volumes:<br/>  pets-data:</pre>
<p>This only defines the part that should be the same in all environments. All specific settings have been taken out.</p>
<p>Let's assume for a moment that we want to run our sample application on a CI system, but there we want to use different settings for the database. The <kbd>Dockerfile</kbd> we used to create the database image looked like this:</p>
<pre>FROM postgres:12.0-alpine<br/>COPY init-db.sql /docker-entrypoint-initdb.d/<br/>ENV POSTGRES_USER dockeruser<br/>ENV POSTGRES_PASSWORD dockerpass<br/>ENV POSTGRES_DB pets</pre>
<p>Notice the three environment variables we define on lines 3 through 5. The <kbd>Dockerfile</kbd> of the <kbd>web</kbd> service has similar definitions. Let's say that on the CI system, we want to do the following:</p>
<ul>
<li>Build the images from code</li>
<li>Define <kbd>POSTGRES_PASSWORD</kbd> as <kbd>ci-pass</kbd></li>
<li>Map container port <kbd>3000</kbd> of the web service to host port <kbd>5000</kbd></li>
</ul>
<p>Then, the corresponding override file would look like this:</p>
<pre>version: "2.4"<br/>services:<br/>  web:<br/>    build: web<br/>    ports:<br/>      - 5000:3000<br/>    environment:<br/>      POSTGRES_PASSWORD: ci-pass<br/>  db:<br/>    build: db<br/>    environment:<br/>      POSTGRES_PASSWORD: ci-pass</pre>
<p>And we can run this application with the following command:</p>
<pre><strong>$</strong> <strong>docker-compose -f docker-compose.yml -f docker-compose-ci.yml up -d --build</strong></pre>
<p>Note that with the first <kbd>-f</kbd> parameter, we provide the base Docker Compose file, and with the second one, we provide the override. The <kbd>--build</kbd> parameter is used to force <kbd>docker-compose</kbd> to rebuild the images.</p>
<p>When using environment variables, note the following precedence:<br/>
<ul>
<li>Declaring them in the Docker file defines a default value</li>
<li>Declaring the same variable in the Docker Compose file overrides the value from the Dockerfile</li>
</ul>
</p>
<p>Had we followed the standard naming convention and called the base file just <kbd>docker-compose.yml</kbd> and the override file <kbd>docker-compose.override.yml</kbd> instead, then we could have started the application with <kbd>docker-compose up -d</kbd> without explicitly naming the compose files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we introduced the <kbd>docker-compose</kbd> tool. This tool is mostly used to run and scale multi-service applications on a single Docker host. Typically, developers and CI servers work with single hosts and those two are the main users of Docker Compose. The tool is using YAML files as input that contain the description of the application in a declarative way.</p>
<p>The tool can also be used to build and push images, among many other helpful tasks. The code accompanying this chapter can be found in <kbd>fod/ch11</kbd>.</p>
<p>In the next chapter, we are going to introduce <strong>orchestrators</strong>. An orchestrator is an infrastructure software that is used to run and manage containerized applications in a cluster while making sure that these applications are in their desired state at all times. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<p>To assess your learning progress, please answer the following questions:</p>
<ol>
<li style="font-weight: 400">How will you use <kbd>docker-compose</kbd> to run an application in daemon mode?</li>
<li style="font-weight: 400">How will you use <kbd>docker-compose</kbd> to display the details of the running service?</li>
<li>How will you scale up a particular web service to, say, three instances?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>The following links provide additional information on the topics discussed in this chapter:</p>
<ul>
<li>The official YAML website: <a href="http://www.yaml.org/" target="_blank">http://www.yaml.org/</a></li>
<li>Docker Compose documentation: <a href="http://dockr.ly/1FL2VQ6" target="_blank">http://dockr.ly/1FL2VQ6</a></li>
<li>Compose file version 2 reference: <a href="https://docs.docker.com/compose/compose-file/compose-file-v2/" target="_blank">http://dohttps://docs.docker.com/compose/compose-file/compose-file-v2/</a></li>
<li>Share Compose configurations between files and projects: <a href="https://docs.docker.com/compose/extends/" target="_blank">https://docs.docker.com/compose/extends/</a></li>
</ul>


            

            
        
    </body></html>