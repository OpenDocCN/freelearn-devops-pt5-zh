- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Testing Applications Running in Containers
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试运行在容器中的应用程序
- en: In the previous chapters, we have learned how we can containerize our applications
    written in any language, such as Node.js, Python, Java, C#, and .NET. We all know
    that just writing code and then shipping it to production is not enough. We also
    need to guarantee that the code is error-free and that it does what it is supposed
    to do. This is commonly subsumed under the term **quality assurance**, or **QA**
    for short.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经学习了如何将用任何语言编写的应用程序容器化，例如 Node.js、Python、Java、C# 和 .NET。我们都知道，仅仅编写代码并将其部署到生产环境是不够的。我们还需要确保代码没有错误，并且能够按预期执行。这通常被归纳为**质量保证**，简称
    **QA**。
- en: It has been proven in practice over and over again that fixing a bug in an application
    that has been discovered in production as opposed to during development is very
    costly. We want to avoid this. The most cost-effective way to do so is to have
    the developer who writes the code also write automated tests that make sure the
    new or changed code is of high quality and performs exactly as specified in the
    acceptance criteria of the business requirement or feature specification.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 实践中反复证明，修复生产中发现的应用程序 bug 要比在开发过程中发现并修复 bug 成本高昂。我们希望避免这种情况。最具成本效益的方法是让编写代码的开发人员同时编写自动化测试，确保新代码或修改后的代码具有高质量，并且能够完全按照业务需求或功能规格中的验收标准执行。
- en: 'Here is a list of the topics we are going to discuss in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是我们将在本章中讨论的主题列表：
- en: The benefits of testing applications running in containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行应用程序的测试好处
- en: Different types of testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同类型的测试
- en: Commonly used tools and technologies
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 常用的工具和技术
- en: Best practices for setting up a testing environment
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置测试环境的最佳实践
- en: Tips for debugging and troubleshooting issues
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和排查问题的技巧
- en: Challenges and considerations when testing applications running in containers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行应用程序时测试的挑战和注意事项
- en: Case studies
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'After reading this chapter, you will be able to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你将能够做以下事情：
- en: Explain the benefits of testing applications running in containers to an interested
    layperson
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向对容器中运行的应用程序感兴趣的外行解释测试的好处
- en: Set up a productive environment that allows you to write and execute tests for
    applications or services running in containers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置一个生产环境，允许你为运行在容器中的应用程序或服务编写和执行测试
- en: Develop unit and integration tests for code running in a container
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为运行在容器中的代码开发单元测试和集成测试
- en: Run your unit and integration tests in a container with the application code
    under test
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行单元测试和集成测试，测试目标是应用程序代码
- en: Run a dedicated container with functional tests that act on your application
    as a black box
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行一个专门的容器，进行功能测试，作为黑盒作用于你的应用程序
- en: Manage application dependencies and create test data
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理应用程序的依赖关系并创建测试数据
- en: Technical requirements
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, you need Docker Desktop, a terminal, and VS Code installed
    on your Mac, Windows, or Linux machine. As we will work with code, you should
    prepare a chapter folder in the code repository you cloned from GitHub:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你需要在你的 Mac、Windows 或 Linux 机器上安装 Docker Desktop、终端和 VS Code。因为我们将与代码进行交互，所以你应该在你从
    GitHub 克隆的代码仓库中准备一个章节文件夹：
- en: 'Navigate to the folder to which you cloned the GitHub repository accompanying
    this book. Normally, you do this as follows:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到你克隆的与本书配套的 GitHub 仓库所在的文件夹。通常，你可以按以下方式操作：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a chapter folder in this directory and navigate to it:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在该目录中创建一个章节文件夹并导航到它：
- en: '[PRE1]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As always, you can find complete sample solutions for all the exercises we will
    do in this chapter in the `sample-solutions/ch07` subfolder.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以在 `sample-solutions/ch07` 子文件夹中找到本章所有练习的完整示例解决方案。
- en: Benefits of testing applications in containers
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中测试应用程序的好处
- en: In this section, we are discussing the benefits of testing applications in containers,
    including the ability to replicate production environments, ease of configuration
    and setup, and faster test execution.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论在容器中测试应用程序的好处，包括能够复制生产环境、配置和设置的简便性以及更快的测试执行速度。
- en: But before we start, let’s pause for a second and ask ourselves, why do we care
    to test at all?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们开始之前，让我们稍微停一下，问问自己，为什么我们要进行测试？
- en: Why do we test?
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们要进行测试？
- en: Every person working in any role in software development is aware that one needs
    to implement and ship new or changed application features at a fast cadence. There
    is constant pressure to implement new code and ship it as quickly as possible
    to production. But business analysts that write the feature specifications and
    software engineers that write the actual code implementing the specifications
    are just human beings. Human beings working under a lot of pressure tend to make
    mistakes. These mistakes can be subtle, or they can be quite substantial. Those
    mistakes will manifest themselves in the application running in production. Our
    customers will discover them, and this will have consequences.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 每个在软件开发领域工作的人员都知道，需要以快速的节奏实施和发布新的或更改过的应用功能。总是有持续的压力要求快速实现新代码并将其发布到生产环境中。但编写功能规格的业务分析师和编写实际代码来实现这些规格的软件工程师，毕竟也是普通人。在巨大的压力下工作的人容易犯错误。这些错误可能是微妙的，也可能是相当严重的。这些错误最终会在生产环境中运行的应用程序中表现出来。我们的客户将会发现这些问题，这将产生后果。
- en: Manual versus automated testing
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动测试与自动化测试
- en: Most companies that write commercial applications will have a team of manual
    software testers. These people will take the newest version of the application
    that product engineering has prepared for them and execute a suite of manual regression
    tests against this application. If a manual tester discovers a bug, they will
    report it in a tool such as Jira as a bug ticket, where they will ideally write
    down all the necessary details that matter for the developer who will have to
    fix the bug. This includes the exact version of the application tested, the steps
    that the tester took before the bug was detected, and some evidence of the bug,
    such as screenshots, error messages, stack traces, and log entries. These tickets
    written by manual testers will become part of the backlog of product engineering.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编写商业应用程序的公司都会有一支手动软件测试团队。这些人员会拿到产品工程团队为他们准备的最新版本的应用程序，并对该应用程序执行一套手动回归测试。如果手动测试人员发现缺陷，他们会在类似Jira的工具中报告这个缺陷，并理想地写下所有开发人员修复该缺陷时需要的详细信息。这包括被测试应用程序的确切版本、测试人员发现缺陷之前所做的步骤，以及缺陷的一些证据，例如截图、错误信息、堆栈跟踪和日志条目。这些由手动测试人员编写的缺陷报告将成为产品工程团队的待办事项的一部分。
- en: Product engineering will then, together with the testers, triage all the new
    bug tickets on a regular basis, say daily, and decide how quickly a particular
    bug needs to be addressed. Usually, the classification of P1, P2, P3, and P4 is
    used, where P1 is a defect of the highest severity that needs to be fixed immediately,
    and P4 is a bug that is of low priority and can be dealt with whenever the team
    has time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，产品工程团队会与测试人员一起，定期（例如每日）对所有新的缺陷报告进行筛查，并决定需要多快解决某个特定的缺陷。通常会使用P1、P2、P3和P4的分类，其中P1是需要立即修复的最高严重性缺陷，P4则是优先级较低、可以在团队有空时处理的缺陷。
- en: If the application is a typical enterprise application consisting of many services
    all running in the cloud, then the testers need a special environment where they
    can perform their regression testing. This environment is often called **user
    acceptance testing**, or **UAT** for short. A full test suite for such an enterprise
    application usually consists of several hundred test cases. To perform a single
    test case takes a manual tester a considerable amount of time. It is not unheard
    of that a team of dedicated manual testers needs a couple of weeks to perform
    a full test run. During this time, the UAT environment is blocked. No new version
    can be deployed to this environment, because otherwise the testers would have
    to restart their regression testing. Each change in the application can introduce
    new bugs, and we can only be certain to catch them all if we execute the whole
    suite of regression tests on each new version.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序是典型的企业应用，包含多个在云端运行的服务，那么测试人员就需要一个特殊的环境来进行回归测试。这个环境通常被称为**用户验收测试**，简称**UAT**。这种企业应用的完整测试套件通常包含几百个测试用例。执行一个单独的测试用例需要手动测试人员花费相当多的时间。并且并不罕见，专门的手动测试团队需要几周时间才能完成一次完整的测试。在此期间，UAT环境会被占用。无法将新版本部署到此环境，因为否则测试人员将不得不重新开始他们的回归测试。应用程序中的每一个变更都可能引入新的缺陷，只有在每个新版本上执行完整的回归测试套件，我们才能确保捕捉到所有问题。
- en: Only after the manual testers have run through all regression tests, and only
    if no more severe bugs have been discovered, can the current version of the application
    be shipped to production.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 只有在手动测试人员完成所有回归测试，并且没有发现更严重的bug后，当前版本的应用程序才能发布到生产环境。
- en: I bet you can imagine that having UAT blocked for several weeks at a time can
    introduce some significant problems in the software development process. Your
    many product engineering teams will have accumulated a lot of new code in the
    form of new features and bug fixes that are blocked from being shipped to production
    since the manual testers are still testing the previous version. But accumulating
    a lot of code changes does, at the same time, increase risk. To ship a piece of
    software that has undergone many changes is riskier than if we continuously ship
    new versions with minimal changes to production.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我敢打赌，你可以想象，UAT（用户验收测试）被阻塞好几周会给软件开发过程带来一些重大问题。你的许多产品工程团队将积累大量新的代码，包括新功能和修复的漏洞，而这些代码由于手动测试人员还在测试旧版本，导致无法发布到生产环境。但是，积累大量代码变更的同时，也增加了风险。发布一段经历过许多变更的软件，比起我们持续发布包含最小变更的新版本，风险要大得多。
- en: 'The only real solution to this problem is to shorten the regression test cycle.
    We need to shorten it from weeks to minutes or a small number of hours. This way,
    we can test and ship small batches of changes in a continuous fashion. But no
    human being is able to test so fast. The solution is to exclusively use automated
    testing. And yes, I mean it: we should rely exclusively on automated regression
    and acceptance testing.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的唯一真正方法是缩短回归测试周期。我们需要将其从几周缩短到几分钟或几个小时。这样，我们就可以以持续的方式测试和发布小批量的变更。但没有人类能测试得这么快。解决方案就是完全依赖自动化测试。没错，我是这么说的：我们应该完全依赖自动化的回归和验收测试。
- en: What did we learn? Manual testing is not scalable, it is super boring, since
    the testers have to repeat the same tests over and over again, and it is error
    prone, since everything humans do is not automated and thus not exactly repeatable
    every time.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学到了什么？手动测试不可扩展，且非常枯燥，因为测试人员必须一遍又一遍地重复相同的测试，并且容易出错，因为人类所做的一切并非自动化，因此每次都无法做到完全重复。
- en: Does this mean we have to fire all manual testers? Not necessarily. Manual testers
    should not perform acceptance and regression tests but rather exploratory tests.
    Manual testers are human beings, and they should leverage that fact and their
    creativity to discover yet undiscovered potential defects in the application.
    As the term *exploratory testing* implies, these tests are not following a particular
    script, but are rather random and only guided by the professional experience of
    the tester and their understanding of the business domain for which the application
    has been written. If the tester discovers a bug, they write a ticket for it, which
    then will be triaged and flown into the backlog of the development teams.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着我们必须解雇所有的手动测试人员？不一定。手动测试人员不应该执行验收测试和回归测试，而应执行探索性测试。手动测试人员是人类，他们应该利用这一事实以及他们的创造力，去发现应用程序中尚未被发现的潜在缺陷。正如*探索性测试*一词所暗示的那样，这些测试并不遵循特定的脚本，而是随机进行，仅由测试人员的专业经验和他们对应用程序所在业务领域的理解所指导。如果测试人员发现了一个
    bug，他们会为其写一个工单，之后这个工单将被整理并加入开发团队的待办事项中。
- en: Why do we test in containers?
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们要在容器中测试？
- en: 'There are several reasons why it is often useful to run tests in containers:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 运行容器中测试有几个常见的好处：
- en: '**Isolation**: Running tests in containers can provide a level of isolation
    between the test environment and the host system, which can be useful for ensuring
    that the test results are consistent and repeatable.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：在容器中运行测试可以为测试环境与主机系统之间提供一定的隔离级别，这对于确保测试结果的一致性和可重复性非常有用。'
- en: '**Environment consistency**: Containers allow you to package the entire test
    environment (including dependencies, libraries, and configuration) in a self-contained
    unit, which can help to ensure that the test environment is consistent across
    different development environments.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境一致性**：容器允许你将整个测试环境（包括依赖、库和配置）打包成一个独立的单元，这可以帮助确保测试环境在不同的开发环境中保持一致。'
- en: '**Ease of use**: Containers can make it easier to set up and run tests, as
    you don’t have to manually install and configure all of the required dependencies
    and libraries on the host system.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**易用性**：容器可以简化设置和运行测试的过程，因为你不必手动在主机系统上安装和配置所有必要的依赖和库。'
- en: '**Portability**: Containers can be easily moved between different environments,
    which can be useful for running tests in different environments or on different
    platforms.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：容器可以轻松地在不同环境之间迁移，这对于在不同环境或平台上运行测试非常有用。'
- en: '**Scalability**: Containers can make it easier to scale up your test infrastructure
    by allowing you to run tests in parallel or on multiple machines.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：容器通过允许并行运行测试或在多台机器上运行测试，使得扩展测试基础设施变得更加容易。'
- en: Overall, running tests in containers can help to improve the reliability, consistency,
    and scalability of the testing process and can make it easier to set up and maintain
    a testing environment that is isolated from the host system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，在容器中运行测试有助于提高测试过程的可靠性、一致性和可扩展性，并使得设置和维护与主机系统隔离的测试环境变得更加容易。
- en: Different types of testing
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不同类型的测试
- en: This section gives an overview of different types of testing that can be performed
    on applications running in containers, including unit tests, integration tests,
    and acceptance tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了在容器中运行的应用程序上可以执行的不同类型的测试，包括单元测试、集成测试和验收测试。
- en: Unit tests
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: A unit test’s primary objective is to validate the functionality of a *unit*,
    or tiny, isolated portion of code. In order to check that the code is accurate
    and operates as expected, developers frequently build unit tests as they create
    or modify the code. These tests are then routinely executed as part of the development
    process.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试的主要目标是验证*单元*，即代码中的一个小的、孤立的部分的功能。为了检查代码是否准确且按预期工作，开发者通常会在创建或修改代码时编写单元测试。这些测试随后会作为开发过程的一部分定期执行。
- en: With no reliance on other resources or components, unit tests are made to test
    distinct pieces of code in isolation. This enables developers to find and quickly
    solve bugs in their code and makes them quick and simple to run.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试不依赖于其他资源或组件，旨在测试代码的独立部分。这使得开发者能够快速发现并解决代码中的错误，同时使得测试运行快速且简单。
- en: Typically, tools and testing frameworks that facilitate the creation, running,
    and reporting of unit tests are used to generate unit tests. These tools frequently
    offer capabilities such as automatic test discovery, test execution, and test
    results reporting, and they enable developers to create unit tests using a particular
    syntax or structure.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，促进单元测试创建、运行和报告的工具和测试框架用于生成单元测试。这些工具通常提供自动测试发现、测试执行和测试结果报告等功能，并使开发者能够使用特定的语法或结构来创建单元测试。
- en: A thorough testing approach should include unit tests, since they enable developers
    to verify that their code is valid and works as intended at the most granular
    level. Normally, they are executed as a part of a **continuous integration** (**CI**)
    process, which is a workflow in which code changes are automatically executed
    each time they are committed to a version control system.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 完善的测试方法应包括单元测试，因为它们使开发者能够验证代码在最细粒度级别上是有效的，并按预期工作。通常，单元测试作为**持续集成**（**CI**）过程的一部分执行，这是一个每次代码变更提交到版本控制系统时自动执行代码变更的工作流程。
- en: Integration tests
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: Software testing called *integration testing* examines how well various systems
    or components function together as a whole. It usually follows unit testing and
    entails examining how various parts of an application or system interact with
    one another.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 被称为*集成测试*的软件测试用于检查不同系统或组件如何作为一个整体协同工作。它通常在单元测试之后进行，涉及检查应用程序或系统的各个部分如何相互交互。
- en: Integration tests are created to examine how well various units or components
    interact together. They are frequently used to confirm that an application’s or
    system’s various components can function as intended. Testing the integration
    of several software components or the integration of a software program with external
    resources such as databases or APIs are examples of this.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试旨在检查不同单元或组件如何协同工作。它们通常用于确认应用程序或系统的各个组件是否能够按预期工作。测试多个软件组件的集成或软件程序与外部资源（如数据库或API）的集成是这类测试的例子。
- en: As many components or systems need to be set up and configured in order to execute
    the tests, integration tests are typically more complicated and time-consuming
    than unit tests. In order to enable the execution and reporting of the tests,
    they could also call for the employment of specialist testing tools and frameworks.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于执行测试需要设置和配置多个组件或系统，因此集成测试通常比单元测试更加复杂和耗时。为了使测试能够执行并生成报告，它们还可能需要使用专门的测试工具和框架。
- en: Integration tests, like unit tests, are a crucial component of a thorough testing
    approach, because they enable developers to confirm that several systems or components
    can function together as intended.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与单元测试一样，集成测试是全面测试方法中的一个重要组成部分，因为它使开发人员能够确认多个系统或组件能够按预期一起工作。
- en: Acceptance tests
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受测试
- en: Software testing of this kind, known as *acceptance testing*, ensures that a
    system or application is suitable for its intended use and that it satisfies all
    of the requirements. It usually comes after all other types of testing (such as
    unit testing and integration testing) and is the last step in the testing procedure.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这种软件测试被称为*接受测试*，它确保系统或应用程序适合其预定用途，并满足所有要求。它通常是在所有其他类型的测试（如单元测试和集成测试）之后进行，是测试过程中的最后一步。
- en: Acceptance tests are typically developed and carried out by a different team
    or group of testers who are tasked with assessing the system or application from
    the viewpoint of the end user. These tests are intended to make sure that the
    system or program is simple to use, fits the demands of the intended users, and
    is user-friendly.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试通常由一个不同的团队或测试小组进行，这个小组的任务是从最终用户的角度评估系统或应用程序。这些测试的目的是确保系统或程序易于使用，符合预期用户的需求，并且具有良好的用户体验。
- en: Functional testing (to ensure that the application or system performs the required
    functions correctly), usability testing (to make sure that the application or
    system is easy to use), and performance testing are just a few examples of the
    different types of testing that may be included in acceptance tests (to verify
    that the application or system performs well under different load conditions).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 功能测试（确保应用程序或系统正确执行所需功能）、可用性测试（确保应用程序或系统易于使用）和性能测试只是接受测试中可能包括的几种测试类型示例（用于验证应用程序或系统在不同负载条件下的表现）。
- en: Acceptance testing is a crucial step in the software development process, since
    it enables developers to confirm that the system or application is ready for deployment
    and satisfies the needs of the intended customers. Although it is highly recommended
    to employ automated acceptance testing technologies to assist the testing process,
    it is often carried out manually by testers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 接受测试是软件开发过程中的一个关键步骤，因为它使开发人员能够确认系统或应用程序已经准备好部署，并满足预定客户的需求。尽管强烈建议采用自动化的接受测试技术来辅助测试过程，但通常它是由测试人员手动进行的。
- en: In this chapter, we will look at a special type of acceptance test called *black
    box tests*. The main differentiator compared to unit and integration tests is
    that these black box tests look at the system under tests from a decidedly business-oriented
    perspective. Ideally, acceptance tests, and with it black box tests, reflect the
    acceptance criteria to be found in the feature specifications written by business
    analysts or product owners. Most often, acceptance tests are written in a way
    that they look at the component to be tested as a black box. The internals of
    this component do not and should not matter. The test code only ever accesses
    the component or system under test via its public interfaces. Typically, public
    interfaces are APIs or messages that the component consumes or produces.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论一种特殊类型的接受测试，称为*黑盒测试*。与单元测试和集成测试相比，黑盒测试的主要区别在于，它们从一个明显以业务为导向的角度来审视被测试系统。理想情况下，接受测试，以及其中的黑盒测试，应该反映出由业务分析师或产品负责人编写的功能规格中的接受标准。通常，接受测试的编写方式是将要测试的组件视为一个黑盒。该组件的内部实现不重要，也不应当重要。测试代码只能通过组件的公共接口访问该组件或系统。通常，公共接口是API或组件消费或生成的消息。
- en: '![Figure 7.1 – Acceptance test interacting with the system under test](img/B19199_07_01.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.1 – 接受测试与被测试系统交互](img/B19199_07_01.jpg)'
- en: Figure 7.1 – Acceptance test interacting with the system under test
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – 接受测试与被测试系统交互
- en: In the preceding figure, we can see how the test code is structured in the popular
    format of **Arrange-Act-Assert**, or **AAA**. First, we set up the boundary conditions
    (arrange). Next, we specify the action to exercise on the system under test (act).
    Finally, we verify that the outcome of the action is as expected (assert). The
    **system under test** (**SUT**) is the component that has a public interface in
    the form of either a REST API and/or messages that it consumes from a message
    bus. The SUT, in most cases, also has a database where it stores it state.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述图中，我们可以看到测试代码是如何以流行的**Arrange-Act-Assert**（**AAA**）格式组织的。首先，我们设置边界条件（arrange）。接下来，我们指定要在被测试系统上执行的操作（act）。最后，我们验证操作的结果是否符合预期（assert）。**被测试系统**（**SUT**）是具有公共接口的组件，可以是REST
    API，或者是它从消息总线中消费的消息。大多数情况下，SUT还有一个数据库，用于存储其状态。
- en: In the next section, we will present tools and technologies used for testing.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍用于测试的工具和技术。
- en: Commonly used tools and technologies
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常用工具和技术
- en: Let’s now discuss the tools and technologies that are commonly used for testing
    applications running in containers, such as Docker, Kubernetes, and **continuous
    integration and delivery** (**CI/CD**) platforms.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一些常用的工具和技术，这些工具和技术用于测试运行在容器中的应用程序，如Docker、Kubernetes和**持续集成与交付**（**CI/CD**）平台。
- en: Implementing a sample component
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现示例组件
- en: In this section, we want to implement a sample component that we are later going
    to use to demonstrate how we can write and execute tests for, and, specifically,
    how we can combine the advantage of automated tests and the use of Docker containers.
    We will implement the sample component using recent versions of Java and Spring
    Boot.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现一个示例组件，稍后我们将使用它来演示如何编写和执行测试，特别是如何结合自动化测试和使用Docker容器的优势。我们将使用最新版本的Java和Spring
    Boot来实现该示例组件。
- en: 'This sample component represents a simple REST API with some CRUD logic behind
    it. The tasks of creating and managing lists of animal species and associated
    races are simple enough to not warrant more complicated modeling. For simplicity,
    we are working with the in-memory database H2\. This means that upon each restart
    of the component, the previous data is wiped out. If you want to change this,
    you can configure H2 to use a backing file for persistence instead:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例组件代表了一个简单的REST API，背后有一些CRUD逻辑。创建和管理动物物种及相关种群的任务相对简单，不需要更复杂的建模。为了简单起见，我们使用内存数据库H2。这意味着每次组件重启时，之前的数据会被清除。如果你想改变这一点，可以配置H2使用后备文件来进行持久化：
- en: 'Use the **spring initializr** page at [https://start.spring.io](https://start.spring.io)
    to bootstrap the Java project. After configuring everything, the page should look
    like this:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**spring initializr**页面 [https://start.spring.io](https://start.spring.io)
    来启动Java项目。配置完成后，页面应该如下所示：
- en: '![Figure 7.2 – Bootstrapping the library project](img/B19199_07_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.2 – 启动图书馆项目](img/B19199_07_02.jpg)'
- en: Figure 7.2 – Bootstrapping the library project
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 启动图书馆项目
- en: Note how we have added the four dependencies listed on the right-hand side of
    the preceding figure.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们已在前述图右侧添加了四个依赖项。
- en: Download the bootstrap code and unzip the file into the chapter folder, `.../ch07`.
    You should now have a subfolder called `library` containing the code we can use
    as a starting point to implement our API.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载启动代码并将文件解压到章节文件夹`.../ch07`中。现在，你应该能看到一个名为`library`的子文件夹，里面包含我们可以用来实现API的代码起始点。
- en: Open the project in VS Code.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code中打开该项目。
- en: Locate the `LibraryApplication.java` file in the `src/main/java/com/example/library`
    folder. It’s the typical start class containing the `main` function for a Spring
    Boot-based Java application.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/java/com/example/library`文件夹中找到`LibraryApplication.java`文件。它是一个典型的启动类，包含Spring
    Boot基础的Java应用程序的`main`函数。
- en: Inside this folder, create three subfolders called `controllers`, `models`,
    and `repositories`, respectively. They will contain the logic for our library.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹内，分别创建三个子文件夹，命名为`controllers`、`models`和`repositories`。它们将包含我们图书馆的逻辑。
- en: '![Figure 7.3 – Project structure of the library API](img/B19199_07_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 图书馆API的项目结构](img/B19199_07_03.jpg)'
- en: Figure 7.3 – Project structure of the library API
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 图书馆API的项目结构
- en: 'Let’s first define the models we’re using in our application. To the `models`
    folder, add the following simple data classes:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们定义应用程序中使用的模型。向`models`文件夹添加以下简单数据类：
- en: 'To a file called `Race.java`, add the following content:'
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向名为`Race.java`的文件中添加以下内容：
- en: '![Figure 7.4 – The Race data class](img/B19199_07_04.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 种族数据类](img/B19199_07_04.jpg)'
- en: Figure 7.4 – The Race data class
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 种族数据类
- en: 'To a file called `Species.java`, add this content:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向名为`Species.java`的文件中添加以下内容：
- en: '![Figure 7.5 – The Species data class](img/B19199_07_05.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – 种类数据类](img/B19199_07_05.jpg)'
- en: Figure 7.5 – The Species data class
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – 种类数据类
- en: Note how we use the `@Entity` annotation to mark these classes as (database)
    entities, and we decorate their respective `id` properties with the `@Id` annotation
    to tell Spring Boot that this property represents the unique ID of each entity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`@Entity`注解来标记这些类为（数据库）实体，并且我们用`@Id`注解装饰它们各自的`id`属性，以告诉Spring Boot该属性表示每个实体的唯一ID。
- en: 'Next, we are going to implement the repositories we’re going to use to persist
    data to and retrieve data from our database. To the `repositories` folder, add
    the following:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实现用于持久化数据和从数据库中检索数据的仓库。向`repositories`文件夹中添加以下内容：
- en: 'A file called `RaceRepository.java` with this content:'
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为`RaceRepository.java`的文件，内容如下：
- en: '![Figure 7.6 – Code for the race repository](img/B19199_07_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.6 – 种族仓库的代码](img/B19199_07_06.jpg)'
- en: Figure 7.6 – Code for the race repository
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.6 – 种族仓库的代码
- en: Note how on line 10, we add a custom `findBySpeciesId` method, which will allow
    us to retrieve all races assigned to a given `speciesId`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意第10行，我们添加了一个自定义的`findBySpeciesId`方法，它将允许我们检索所有分配给特定`speciesId`的种族。
- en: 'A file called `SpeciesRepository.java` with the following content:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为`SpeciesRepository.java`的文件，内容如下：
- en: '![Figure 7.7 – Code for the species repository](img/B19199_07_07.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.7 – 种族仓库的代码](img/B19199_07_07.jpg)'
- en: Figure 7.7 – Code for the species repository
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 种族仓库的代码
- en: 'Then, we define the two REST controllers through which we can interact with
    the application. To the `controllers` folder, add the following:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们定义了两个REST控制器，通过这些控制器我们可以与应用程序进行交互。向`controllers`文件夹中添加以下内容：
- en: 'A file called `RacesController.java` with this content:'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为`RacesController.java`的文件，内容如下：
- en: '![Figure 7.8 – Code for the races controller](img/B19199_07_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.8 – 种族控制器的代码](img/B19199_07_08.jpg)'
- en: Figure 7.8 – Code for the races controller
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.8 – 种族控制器的代码
- en: 'You can find the full code here: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/RacesController.java](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/RacesController.java).'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的代码：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/RacesController.java](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/RacesController.java)。
- en: 'A file called `SpeciesController.java` with this code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个名为`SpeciesController.java`的文件，代码如下：
- en: '![Figure 7.9 – Code for the species controller](img/B19199_07_09.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.9 – 种族控制器的代码](img/B19199_07_09.jpg)'
- en: Figure 7.9 – Code for the species controller
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – 种族控制器的代码
- en: 'You can find the full code here: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/SpeciesController.java](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/SpeciesController.java).'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到完整的代码：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/SpeciesController.java](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/blob/main/sample-solutions/ch07/library/src/main/java/com/example/library/controllers/SpeciesController.java)。
- en: 'Finally, we need to do some application configuration. We can do so in the
    `application.properties` file, which you can find in the `src/main/resources`
    folder. Add this content to it, which configures the database we are going to
    use for this example:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要进行一些应用程序配置。我们可以在`application.properties`文件中进行配置，你可以在`src/main/resources`文件夹中找到此文件。将以下内容添加到该文件中，这将配置我们在本示例中将使用的数据库：
- en: '![Figure 7.10 – Application configuration](img/B19199_07_10.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.10 – 应用程序配置](img/B19199_07_10.jpg)'
- en: Figure 7.10 – Application configuration
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.10 – 应用程序配置
- en: We are using the H2 in-memory database with a username of `sa` and no password.
    We are also making sure to enable the H2 console in our application to have an
    easy way to inspect the data from our browser (line 6).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是H2内存数据库，用户名为`sa`，没有密码。我们还确保在应用程序中启用了H2控制台，以便通过浏览器轻松检查数据（第6行）。
- en: 'Now open the `LibraryApplication` class and click the **Run** link above the
    main method to start the application. Observe the output generated in the terminal:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`LibraryApplication`类，并点击主方法上方的**Run**链接以启动应用程序。观察终端中生成的输出：
- en: '![Figure 7.11 – Logging the output of the running library application](img/B19199_07_11.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.11 – 记录运行中库应用程序的输出](img/B19199_07_11.jpg)'
- en: Figure 7.11 – Logging the output of the running library application
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.11 – 记录运行中库应用程序的输出
- en: Read through the log output and try to make sense of each line. The second-to-last
    line of the preceding output is telling us that the application can be accessed
    at port `8080`, which is the default for Spring Boot applications. Also note the
    line where it says `H2 console available at ‘/h2-console’. Database available
    at ‘jdbc:h2:mem:inventory’`. This indicates that we can now open a browser at
    `localhost:8080/h2-console` to open the H2 console and, through it, access our
    in-memory database.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读日志输出并尽量理解每一行。前述输出的倒数第二行告诉我们，应用程序可以通过端口`8080`访问，这是Spring Boot应用程序的默认端口。还请注意有一行显示`H2
    console available at ‘/h2-console’. Database available at ‘jdbc:h2:mem:inventory’`，这表明我们现在可以在浏览器中打开`localhost:8080/h2-console`来访问H2控制台，并通过它访问我们的内存数据库。
- en: 'Use the Thunder client in VS Code, Postman, or the `curl` command in the terminal
    to add a species to the database. Here we are using `curl`:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用VS Code中的Thunder客户端、Postman，或者终端中的`curl`命令向数据库添加物种。这里我们使用`curl`：
- en: '[PRE2]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The response should look like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 响应应如下所示：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Use `curl` (or any other tool) again to list the species stored in the system:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次使用`curl`（或任何其他工具）列出存储在系统中的物种：
- en: '[PRE4]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output should look like this:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应如下所示：
- en: '[PRE5]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is a JSON array with exactly one element.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个包含一个元素的JSON数组。
- en: Try all the other `REST` calls that the two controllers we implemented support,
    such as `PUT` to update an existing species and `GET`, `POST`, and `PUT` for the
    `/``races` endpoint.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试所有我们实现的两个控制器支持的其他`REST`调用，例如使用`PUT`更新现有物种，以及`GET`、`POST`和`PUT`用于`/races`端点。
- en: When done, make sure to stop the application.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，确保停止应用程序。
- en: 'Next, we need to package the application into a container and run it:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将应用程序打包成容器并运行：
- en: 'Add a Dockerfile to the root of the library project with this content:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在库项目的根目录下添加一个Dockerfile，内容如下：
- en: '![Figure 7.12 – Dockerfile for the library component](img/B19199_07_12.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.12 – 库组件的Dockerfile](img/B19199_07_12.jpg)'
- en: Figure 7.12 – Dockerfile for the library component
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.12 – 库组件的Dockerfile
- en: 'Create a Docker image using this Dockerfile with this command executed from
    within the `ch07` folder:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在`ch07`文件夹中创建一个Docker镜像：
- en: '[PRE6]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Run a container with this command:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行容器：
- en: '[PRE7]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Test that the component now running inside a container still works as expected
    by using the same commands as in the previous section.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过使用与上一节相同的命令，测试当前在容器中运行的组件是否仍按预期工作。
- en: When done, stop the container with the library component. We suggest that you
    use the Docker plugin of VS Code to do so or the dashboard of Docker Desktop.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，停止包含库组件的容器。我们建议使用VS Code的Docker插件来操作，或者使用Docker Desktop的仪表板。
- en: Now that we have a working example application, we can continue and discuss
    how we can test this REST API using unit, integration, and black box tests. Let’s
    start with the unit and/or integration tests.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了一个可工作的示例应用程序，可以继续讨论如何使用单元测试、集成测试和黑盒测试来测试这个REST API。我们从单元测试和/或集成测试开始。
- en: Implementing and running unit and integration tests
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现和运行单元测试与集成测试
- en: 'Now that we have a working component, it is time to write some tests for it.
    In this section, we concentrate on unit and integration tests. Spring Boot makes
    it really simple to get started:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了一个可以工作的组件，是时候为它编写一些测试了。在这一部分，我们重点关注单元测试和集成测试。Spring Boot使得入门变得非常简单：
- en: 'To the `src/test/java/com/example/library` folder, add a `LibraryUnitTests.java`
    file with the following content:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/test/java/com/example/library`文件夹中，添加一个`LibraryUnitTests.java`文件，内容如下：
- en: '![Figure 7.13 – Sample unit test written for the library project](img/B19199_07_13.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.13 – 为库项目编写的示例单元测试](img/B19199_07_13.jpg)'
- en: Figure 7.13 – Sample unit test written for the library project
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.13 – 为库项目编写的示例单元测试
- en: Note how we have added a private `Calculator` class to our `Test` class. This
    is for demonstration purposes only and makes it easier to show how to write a
    unit test. Normally, one would test classes and their methods that are part of
    the code base.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在我们的 `Test` 类中添加了一个私有的 `Calculator` 类。这仅用于演示目的，并且更容易展示如何编写单元测试。通常，应该测试代码库中的类和方法。
- en: Tip
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: It is a good idea to always structure your tests in a similar way and make it
    easier for others (and yourself) to read and comprehend those tests. In this case,
    we have chosen the triple-A (AAA) syntax consisting of Arrange, Act, and Assert.
    Alternatively, you could use the Given-When-Then syntax.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 始终建议按照类似的方式组织您的测试，这样可以更轻松地让其他人（包括自己）阅读和理解这些测试。在这种情况下，我们选择了由 Arrange、Act 和 Assert
    组成的 AAA 语法。或者，您也可以使用 Given-When-Then 语法。
- en: 'If you have the **Test Runner for Java** extension installed on your VS Code
    editor, you should now see a green triangle next to the test method (line 19 in
    the preceding figure). Click it to run the test. As a result, you should see something
    like this:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您在 VS Code 编辑器上安装了 **Test Runner for Java** 扩展程序，现在应该在测试方法旁边看到一个绿色的三角形（上述图像中的第
    19 行）。单击它来运行测试。结果应该如下所示：
- en: '![Figure 7.14 – Results of a first test run](img/B19199_07_14.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.14 – 第一次测试运行的结果](img/B19199_07_14.jpg)'
- en: Figure 7.14 – Results of a first test run
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.14 – 第一次测试运行的结果
- en: Note
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Alternatively, you can run the tests from the command line with this command:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下命令从命令行运行测试：
- en: '`$ ./``mvnw test`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ ./``mvnw test`'
- en: 'Now let’s add a sample integration test. For this, add a file called `LibraryIntegrationTests.java`
    in the same folder as where you have put the unit tests. We will implement a test
    using the `MockMvc` helper class provided by Spring Boot to simulate that our
    application runs on a web server and we’re accessing it through its REST endpoints.
    Add the following content to the test class:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们添加一个示例集成测试。为此，在放置单元测试的同一文件夹中添加一个名为 `LibraryIntegrationTests.java` 的文件。我们将使用
    Spring Boot 提供的 `MockMvc` 辅助类来模拟我们的应用程序运行在 web 服务器上，并通过其 REST 端点进行访问。向测试类中添加以下内容：
- en: '![Figure 7.15 – Sample Integration Test written for the library project](img/B19199_07_15.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.15 – 为库项目编写的示例集成测试](img/B19199_07_15.jpg)'
- en: Figure 7.15 – Sample Integration Test written for the library project
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.15 – 为库项目编写的示例集成测试
- en: Run the preceding test the same way as you did with the unit test. Make sure
    the test passes.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以与单元测试相同的方式运行上述测试。确保测试通过。
- en: 'We have finished our preparation and are now ready to package the component
    into a container and run the unit and integration tests inside the same container.
    To do this, follow these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经完成了准备工作，现在可以将组件打包到一个容器中，并在同一个容器中运行单元测试和集成测试。为此，请按照以下步骤操作：
- en: 'Let’s add a Dockerfile with the following content to the root of our library
    project. The content is the same that we already used in the previous Java example:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在我们的库项目根目录下添加一个 Dockerfile，并加入以下内容。这个内容和我们之前的 Java 示例中使用的是一样的：
- en: '![Figure 7.16 – Dockerfile for the library project](img/B19199_07_16.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.16 – 用于库项目的 Dockerfile](img/B19199_07_16.jpg)'
- en: Figure 7.16 – Dockerfile for the library project
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.16 – 用于库项目的 Dockerfile
- en: 'Then, let’s build an image using this Dockerfile:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们使用这个 Dockerfile 构建一个镜像：
- en: '[PRE8]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run the tests in the container with the following command:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在容器中运行测试：
- en: '[PRE9]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note the volume mapping we are using. We are sharing our local Maven repository
    at `$HOME/.m2` with the container, so when building the application, Maven does
    not have to download all dependencies first as they are already in our local cache.
    This improves the overall experience massively.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意我们使用的卷映射。我们正在将本地 Maven 仓库（位于 `$HOME/.m2`）与容器共享，因此在构建应用程序时，Maven 不必首先下载所有依赖项，因为它们已经存在于我们的本地缓存中。这显著改善了整体体验。
- en: Also note how we override the `CMD` command in our Dockerfile (line 8 in the
    preceding figure) with `./mvnw test` to run the tests instead of running the application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 还请注意，我们在 Dockerfile 中覆盖了 `CMD` 命令（在上述图像中的第 8 行），使用 `./mvnw test` 来运行测试，而不是运行应用程序。
- en: 'Observe the output generated. The last few lines of the output should look
    like this, indicating that tests were run:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 观察生成的输出。输出的最后几行应该像这样，表明已经运行了测试：
- en: '![Figure 7.17 – Output of a test run inside the container](img/B19199_07_17.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.17 – 容器内部测试运行的输出](img/B19199_07_17.jpg)'
- en: Figure 7.17 – Output of a test run inside the container
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.17 – 容器内测试运行的输出
- en: In the same way that you have now run the unit and integration tests inside
    a container locally on your laptop, you can also run it during the CI phase of
    your CI/CD pipeline. A simple shell script is enough to automate what you just
    did manually.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你现在在本地笔记本电脑上在容器内运行单元测试和集成测试一样，你也可以在 CI/CD 管道的 CI 阶段运行它。一个简单的 Shell 脚本就足以自动化你刚才手动做的事情。
- en: Implementing and running black box tests
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现并运行黑盒测试
- en: Since black box tests have to deal with the SUT as a closed system, the tests
    should not run inside the same container as the component itself. It is instead
    recommended to run the test code in its own dedicated test container.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 由于黑盒测试必须将被测试单元（SUT）视为一个封闭系统，因此测试不应在与组件相同的容器内运行。建议将测试代码放入自己的专用测试容器中运行。
- en: It is also recommended to not intermingle the code of black box tests and the
    component but to keep them strictly separate. We will demonstrate this by writing
    the tests in a different language than the component. This time, we will use C#.
    Any language will do such as Kotlin, Node.js, or Python.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 还建议不要将黑盒测试和组件的代码混合在一起，而是严格分开。我们将通过使用与组件不同的语言来编写测试来展示这一点。这次，我们将使用C#。任何语言都可以，例如Kotlin、Node.js或Python。
- en: 'In this example, we will use .NET and C# to implement the component tests:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将使用.NET和C#来实现组件测试：
- en: 'From within the `ch07` folder, execute the following command to create a test
    project:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ch07`文件夹中，执行以下命令来创建测试项目：
- en: '[PRE10]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will create a test project in the `library-component-tests` subfolder using
    the popular `xunit` test library.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使用流行的`xunit`测试库在`library-component-tests`子文件夹中创建一个测试项目。
- en: 'Try to run the tests with the following command:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用以下命令运行测试：
- en: '[PRE11]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The (shortened) output should look like this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: （缩短后的）输出应如下所示：
- en: '[PRE12]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This indicates that all tests passed. Of course, by default, there exists only
    an empty sample test in the project at this time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明所有测试都通过了。当然，默认情况下，项目中此时只有一个空的示例测试。
- en: 'Open this project in VS Code with the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令在 VS Code 中打开该项目：
- en: '[PRE13]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Locate the `UnitTest1.cs` file and open it. At the top of the file, add this
    statement:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并打开`UnitTest1.cs`文件。在文件顶部，添加以下语句：
- en: '[PRE14]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Right after the `namespace` declaration, add this record definition:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`namespace`声明后，添加以下记录定义：
- en: '[PRE15]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now add a new method called `can_add_species`, looking like this:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个名为`can_add_species`的新方法，如下所示：
- en: '![Figure 7.18 – Component test to add a species](img/B19199_07_18.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.18 – 添加物种的组件测试](img/B19199_07_18.jpg)'
- en: Figure 7.18 – Component test to add a species
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.18 – 添加物种的组件测试
- en: Here we are using the `HttpClient` class to post a data object of type `Species`
    to the `/species` endpoint. We are then asserting that the HTTP response code
    for the operation is `OK (200)`. Note how we are using the AAA convention to structure
    our test.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`HttpClient`类将类型为`Species`的数据对象发布到`/species`端点。然后，我们断言操作的 HTTP 响应代码为`OK
    (200)`。注意我们是如何使用AAA规范来构造我们的测试的。
- en: 'Add another method called `can_get_a_species_by_id` with the following content:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个名为`can_get_a_species_by_id`的方法，内容如下：
- en: '![Figure 7.19 – Component test to read a species by ID](img/B19199_07_19.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.19 – 按 ID 读取物种的组件测试](img/B19199_07_19.jpg)'
- en: Figure 7.19 – Component test to read a species by ID
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.19 – 按 ID 读取物种的组件测试
- en: 'Before you proceed and run the tests, make sure the `library` component is
    running and listening at port `8080`. Otherwise, the tests will fail, since nobody
    is listening at the expected endpoints. Use this command:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在继续并运行测试之前，请确保`library`组件正在运行并监听端口`8080`。否则，测试将失败，因为预期的端点没有人监听。使用以下命令：
- en: '[PRE16]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the tests with this command:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行测试：
- en: '[PRE17]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Make sure the two tests pass.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 确保两个测试都通过。
- en: '`library` component.'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`library`组件。'
- en: When done, stop the `library` component.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，停止`library`组件。
- en: 'Next, we are going to show how we can run the tests in a container:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何在容器中运行测试：
- en: 'Add a Dockerfile with the following content to the root of the .NET test project:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 .NET 测试项目的根目录添加一个包含以下内容的 Dockerfile：
- en: '![Figure 7.20 – Dockerfile for the component tests](img/B19199_07_20.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.20 – 组件测试的 Dockerfile](img/B19199_07_20.jpg)'
- en: Figure 7.20 – Dockerfile for the component tests
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 组件测试的 Dockerfile
- en: 'Create an image with this Dockerfile. From within the `ch07` folder, use this
    command:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此 Dockerfile 创建一个镜像。在`ch07`文件夹内，使用以下命令：
- en: '[PRE18]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Double-check that we already have a Docker image created for the library component.
    If not, use this command to do so from within the `ch07` folder:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次检查是否已经为库组件创建了 Docker 镜像。如果没有，可以在 `ch07` 文件夹中使用以下命令来创建：
- en: '[PRE19]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now that we have a Docker image for the library component and one for the component
    tests, we need to run a container of each:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为库组件和组件测试分别创建了 Docker 镜像，接下来需要分别运行它们的容器：
- en: 'To run the library component, use this:'
  id: totrans-213
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行库组件，请使用以下命令：
- en: '[PRE20]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To run the component tests, use this command:'
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要运行组件测试，请使用以下命令：
- en: '[PRE21]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Observe that the tests are executed and are all passing.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，测试已经执行并且全部通过。
- en: When done, remove the two containers. Use your Docker plugin in VS Code or the
    dashboard of Docker Desktop to do so.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，移除这两个容器。可以使用 VS Code 中的 Docker 插件或 Docker Desktop 的仪表板来执行此操作。
- en: Well, that was quite a run. We have shown how to write unit and integration
    tests for a component written in Java and using Spring Boot 3\. We ran the tests
    natively on our laptop and also inside a container. Then we showed how to create
    some black box tests in .NET 7, C# and ran them against our library component.
    We did this again natively on our laptop and then ran the component and the black
    box tests each in their own container.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这真是一次很棒的操作。我们展示了如何为使用 Spring Boot 3 编写的 Java 组件编写单元测试和集成测试。我们在本地笔记本电脑上以及在容器内运行了这些测试。然后我们展示了如何在
    .NET 7 中创建一些黑盒测试，使用 C# 编写并在我们的库组件上运行它们。我们同样在本地笔记本电脑上执行了这些操作，然后将组件和黑盒测试分别运行在各自的容器中。
- en: Next, we are going to discuss how to best set up a testing environment.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何最佳地设置测试环境。
- en: Best practices for setting up a testing environment
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置测试环境的最佳实践
- en: 'In this section, we want to list a few best practices for setting up a testing
    environment for applications running in containers, including considerations for
    network isolation, data management, and resource constraints:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们希望列出一些设置容器中应用程序测试环境的最佳实践，包括网络隔离、数据管理和资源约束等方面的考虑：
- en: '**Use a separate testing environment**: It is generally a good idea to use
    a separate testing environment for running tests in containers rather than running
    tests on the same host as your production environment. This can help to prevent
    any potential issues or disruptions from affecting your production environment.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用独立的测试环境**：一般来说，使用独立的测试环境来运行容器中的测试，而不是在与生产环境相同的主机上运行测试，是个好主意。这样可以避免潜在的问题或中断影响生产环境。'
- en: '**Isolate the testing network**: To ensure that your testing environment is
    isolated from your production environment, it is a good idea to use a separate
    network for testing. This can be achieved by using a separate virtual network
    or by using network namespaces or overlays in your container runtime.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离测试网络**：为了确保测试环境与生产环境相互隔离，使用独立的网络进行测试是一个好主意。可以通过使用独立的虚拟网络，或者在容器运行时使用网络命名空间或覆盖网络来实现。'
- en: '**Manage test data carefully**: When testing applications in containers, it
    is important to manage test data carefully to ensure that your tests are reliable
    and repeatable. This can involve using test data generation tools, snapshotting
    the test data, or using a separate test database.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**谨慎管理测试数据**：在容器中测试应用程序时，重要的是要小心管理测试数据，以确保测试的可靠性和可重复性。这可以通过使用测试数据生成工具、快照测试数据或使用独立的测试数据库来实现。'
- en: '**Use resource constraints**: To ensure that your tests are reliable and consistent,
    it is a good idea to use resource constraints (e.g., CPU, memory) to limit the
    resources available to your containers. This can help to prevent resource contention
    and ensure that your tests are not impacted by external factors such as the load
    on the host system.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用资源约束**：为了确保测试的可靠性和一致性，使用资源约束（例如 CPU、内存）来限制容器可用资源是一个好主意。这有助于防止资源争用，并确保测试不受外部因素（如主机系统的负载）影响。'
- en: '**Use a container orchestration tool**: To manage a large number of containers
    and ensure that they are deployed and scaled consistently, it is a good idea to
    use a container orchestration tool such as Kubernetes or Docker Swarm. These tools
    can help to automate the process of deploying and scaling containers and can provide
    features such as automatic rollbacks and self-healing.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用容器编排工具**：为了管理大量容器并确保它们的一致部署和扩展，使用如 Kubernetes 或 Docker Swarm 等容器编排工具是一个好主意。这些工具可以帮助自动化容器的部署和扩展过程，并提供自动回滚和自愈等功能。'
- en: '**Monitor the testing environment**: To ensure that your testing environment
    is running smoothly and to identify any issues that may arise, it is a good idea
    to use monitoring tools to track the performance and resource usage of your containers.
    This can help you to identify and fix any issues that may affect the reliability
    of your tests.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控测试环境**：为了确保你的测试环境运行顺利，并发现可能出现的问题，使用监控工具来跟踪容器的性能和资源使用情况是一个好主意。这可以帮助你识别并修复可能影响测试可靠性的问题。'
- en: Now when testing, you may face some troubles and hard-to-explain test failures.
    In the next section, we’re going to provide a few tips about what you can do in
    such a situation.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试过程中，你可能会遇到一些麻烦和难以解释的测试失败情况。在接下来的部分，我们将提供一些在这种情况下可以采取的应对措施。
- en: Tips for debugging and troubleshooting issues
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和排除故障的技巧
- en: 'As we are running automated tests in our containerized environments, we may
    from time to time face seemingly weird behaviors and mysteriously failing tests.
    Here are some tips for debugging and troubleshooting issues that may arise when
    testing applications in containers:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们容器化环境中运行自动化测试时，可能会时不时遇到一些看似奇怪的行为和神秘失败的测试。以下是一些调试和排除故障的技巧，用于解决测试应用程序时可能出现的问题：
- en: '`docker container logs` to view the logs for a specific container.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker container logs` 查看特定容器的日志。'
- en: '**Use a debugger**: If the error message or log output is not sufficient to
    diagnose the problem, you can use a debugger to inspect the state of the application
    at runtime. Many IDEs, such as VS Code, which we use all the time, Visual Studio,
    and IntelliJ, have built-in support for debugging applications running in containers.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用调试器**：如果错误信息或日志输出不足以诊断问题，你可以使用调试器在运行时检查应用程序的状态。许多集成开发环境（IDE），如我们常用的 VS
    Code、Visual Studio 和 IntelliJ，都内置了对在容器中运行应用程序调试的支持。'
- en: '`docker container exec` to run commands inside the container and inspect its
    environment.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`docker container exec` 在容器内运行命令并检查其环境。'
- en: '**Use a container runtime debugger**: Some container runtimes, such as Docker,
    provide tools for debugging issues with the container itself (e.g., resource usage
    and networking issues). These tools can be helpful for diagnosing issues that
    are specific to the container runtime.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用容器运行时调试器**：一些容器运行时（如 Docker）提供了调试容器本身问题的工具（例如资源使用和网络问题）。这些工具对于诊断容器运行时特定的问题非常有帮助。'
- en: '**Use a containerized debugging environment**: If you are having difficulty
    reproducing the issue in a local development environment, you can use a containerized
    debugging environment (e.g., a debugger container) to replicate the production
    environment more closely.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用容器化调试环境**：如果你在本地开发环境中难以复现问题，可以使用容器化的调试环境（例如调试器容器）来更接近地复制生产环境。'
- en: '**Check for known issues**: If you are using third-party libraries or dependencies
    in your application, it is worth checking whether there are any known issues or
    bugs that could be causing the problem. Many libraries and dependencies maintain
    lists of known issues and workarounds on their website or in their documentation.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查已知问题**：如果你在应用程序中使用了第三方库或依赖项，值得检查是否存在任何已知问题或错误，这些问题可能会导致出现问题。许多库和依赖项在其网站或文档中维护已知问题和解决方法的列表。'
- en: '**Get help**: If you are unable to diagnose the issue on your own, don’t hesitate
    to seek help from the community, for example, from Stack Overflow or the maintainers
    of the libraries and tools you are using. There are many resources available online.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**寻求帮助**：如果你无法自行诊断问题，不要犹豫，向社区寻求帮助，例如 Stack Overflow 或你使用的库和工具的维护者。网上有许多资源可以利用。'
- en: Now let’s discuss a few challenges that may occur during testing and what we
    should consider when testing.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们讨论一下测试过程中可能出现的一些挑战，以及我们在测试时应该考虑的事项。
- en: Challenges and considerations when testing applications running in containers
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试在容器中运行的应用程序时的挑战和注意事项
- en: 'Next to all the many advantages that testing applications running in containers
    brings to the table, we need to also have a brief discussion of the challenges
    and considerations involved in this type of testing, such as dealing with dependencies
    and managing test data:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 除了测试在容器中运行的应用程序所带来的诸多优势，我们还需要简要讨论一下这种测试方式中涉及的挑战和注意事项，例如如何处理依赖关系和管理测试数据：
- en: '**Isolation**: Testing applications in containers can provide a level of isolation
    between the test environment and the host system, which can be useful for ensuring
    that the test results are consistent and repeatable. However, this isolation can
    also make it more difficult to debug issues and identify the root cause of problems,
    as you may not have access to the host system and its resources.'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：在容器中测试应用程序可以提供一定程度的隔离，将测试环境与主机系统分开，这有助于确保测试结果的一致性和可重复性。然而，这种隔离也可能使调试问题和识别根本原因变得更加困难，因为你可能无法访问主机系统及其资源。'
- en: '**Environment consistency**: Ensuring that the test environment is consistent
    across different development environments can be a challenge when using containers.
    Differences in the host system, container runtime, and network configuration can
    all impact the behavior of the application and the test results.'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境一致性**：在使用容器时，确保不同开发环境之间的测试环境一致性可能是一个挑战。主机系统、容器运行时和网络配置的差异都会影响应用程序的行为和测试结果。'
- en: '**Data management**: Managing test data in a containerized environment can
    be challenging, as you may need to ensure that the test data is consistent and
    available to all containers, or that it is properly isolated and not shared between
    tests.'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据管理**：在容器化环境中管理测试数据可能是一个挑战，因为你可能需要确保测试数据在所有容器之间一致并可用，或者确保数据得到适当的隔离，且在测试之间不被共享。'
- en: '**Resource constraints**: Testing applications in containers can be resource-intensive,
    as you may need to run multiple containers in parallel to test different scenarios.
    This can lead to resource contention and may require careful resource management
    to ensure that your tests are reliable and consistent.'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源限制**：在容器中测试应用程序可能会消耗大量资源，因为你可能需要同时运行多个容器以测试不同的场景。这可能导致资源竞争，并可能需要仔细的资源管理，以确保测试的可靠性和一致性。'
- en: '**Integration testing**: Testing the integration between multiple containers
    can be challenging, as you may need to coordinate the startup and shutdown of
    multiple containers and ensure that they can communicate with each other.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：测试多个容器之间的集成可能具有挑战性，因为你可能需要协调多个容器的启动和关闭，并确保它们能够相互通信。'
- en: '**Performance testing**: Testing the performance of applications running in
    containers can be difficult, as the performance may be impacted by the host system,
    the container runtime, and the network configuration.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能测试**：测试运行在容器中的应用程序的性能可能会很困难，因为性能可能会受到主机系统、容器运行时和网络配置的影响。'
- en: Overall, testing applications running in containers requires careful planning
    and consideration to ensure that the test environment is consistent and reliable,
    and to ensure that the test results are meaningful and actionable.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，在容器中测试应用程序需要精心规划和考虑，以确保测试环境的一致性和可靠性，并确保测试结果具有意义且可操作。
- en: Before we end this chapter, let’s look at a few case studies where companies
    are using containerized tests.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束之前，让我们来看几个公司使用容器化测试的案例研究。
- en: Case studies
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 案例研究
- en: 'In this last section of the chapter, we present a few case studies and examples
    of organizations that have successfully implemented testing strategies for applications
    running in containers:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后一部分，我们展示了一些成功实施容器中应用程序测试策略的组织的案例研究和实例：
- en: An automated testing technique was introduced by a well-known online shop to
    boost the effectiveness and efficiency of its software development process. The
    company was able to considerably reduce the time and effort needed to test its
    applications by automating the execution of functional, integration, and acceptance
    tests. As a result, it was able to provide customers with new features and upgrades
    more rapidly and reliably.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家知名在线商店引入了一种自动化测试技术，以提高其软件开发过程的有效性和效率。通过自动化执行功能测试、集成测试和验收测试，该公司显著减少了测试应用程序所需的时间和精力。因此，它能够更迅速且可靠地为客户提供新功能和升级。
- en: Automated testing was used by a financial services company to enhance the dependability
    and stability of their trading platform. The business was able to find and fix
    problems early in the development process by automating the execution of unit,
    integration, and acceptance tests, minimizing the risk of downtime and enhancing
    customer satisfaction.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家金融服务公司使用自动化测试来提高其交易平台的可靠性和稳定性。通过自动执行单元、集成和验收测试，该公司能够在开发初期发现并修复问题，从而减少了停机风险并提升了客户满意度。
- en: Automated testing was used by a healthcare organization to guarantee the precision
    and dependability of its **electronic medical record** (**EMR**) system. The business
    was able to swiftly identify and address problems by automating the execution
    of functional and acceptability tests, increasing the EMR system’s dependability
    and trustworthiness, and lowering the risk of mistakes and patient harm.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一家医疗保健组织使用自动化测试来确保其**电子病历**（**EMR**）系统的准确性和可靠性。通过自动执行功能性和可接受性测试，该公司能够快速识别并解决问题，提高了
    EMR 系统的可靠性和可信度，并降低了错误和患者伤害的风险。
- en: The advantages of automated testing, such as better quality, quicker development
    and deployment cycles, increased reliability, and higher customer happiness, are
    illustrated by these case studies.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化测试的优势，如更好的质量、更快的开发和部署周期、更高的可靠性和更高的客户满意度，都是通过这些案例研究来说明的。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned about the benefits of testing applications running
    in containers, discussed the different types of testing, presented some of the
    tools and technologies commonly used for testing, as well as best practices for
    setting up a testing environment. We also presented a list of tips for debugging
    and troubleshooting issues, talked about challenges and considerations when testing
    applications running in containers, and concluded the chapter with a list of case
    studies.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了容器中运行应用程序的测试的好处，讨论了不同类型的测试，介绍了一些常用的测试工具和技术，并提供了设置测试环境的最佳实践。我们还列出了调试和故障排除的技巧，讨论了在容器中测试应用程序时的挑战和注意事项，并以案例研究总结本章内容。
- en: In the next chapter, we will introduce miscellaneous tips, tricks, and concepts
    useful when containerizing complex distributed applications or when using Docker
    to automate sophisticated tasks.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些在容器化复杂分布式应用程序时，或使用 Docker 自动化复杂任务时，有用的杂项技巧、窍门和概念。
- en: Questions
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess your learning, please try to answer the following questions before
    you proceed to the next chapter:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估你的学习，请在继续下一章之前尝试回答以下问题：
- en: How do we run unit tests for an application inside a container?
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在容器内运行单元测试？
- en: Should the Docker images that we use in production contain test code? Justify
    your answer.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在生产环境中使用的 Docker 镜像是否应该包含测试代码？请给出理由。
- en: Where do we typically run unit and integration tests that run inside a container?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通常在哪些地方运行容器内的单元测试和集成测试？
- en: List a few advantages of running unit and integration tests in containers.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举在容器中运行单元测试和集成测试的一些优势。
- en: What are a few challenges you may face if running tests in containers?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在容器中运行测试，你可能会遇到哪些挑战？
- en: Answers
  id: totrans-266
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are sample answers to the questions of this chapter:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的示例答案：
- en: 'We have learned how to run an application in a container. We have seen examples
    written in Node.js, Python, Java, and .NET C#. We have learned how the Dockerfile
    must look to create an image. Specifically, we have learned how to define the
    startup command to execute when a container is created from such an image. In
    the case of a Java application, this could be as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在容器中运行应用。我们看到了用 Node.js、Python、Java 和 .NET C# 编写的示例。我们了解了如何构建 Dockerfile
    来创建镜像。具体来说，我们已经学习了如何定义在从该镜像创建容器时要执行的启动命令。对于 Java 应用，这可能如下所示：
- en: '[PRE22]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For a Node.js application, it could be as follows:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个 Node.js 应用，可能如下所示：
- en: '[PRE23]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To run the unit tests for the application, we just have to use a different startup
    command.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行应用的单元测试，我们只需要使用不同的启动命令。
- en: 'We strongly advise against shipping test code to a production environment.
    Tests bloat the Docker image, which has several negative side effects, such as
    the following:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们强烈建议不要将测试代码发布到生产环境中。测试会膨胀 Docker 镜像，带来一些负面副作用，例如：
- en: Providing a bigger surface for hacker attacks
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供了更大的攻击面，容易遭受黑客攻击
- en: Longer startup times for the container since it takes longer to load an image
    from storage into the memory of the container host
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器启动时间较长，因为从存储加载镜像到容器主机的内存需要更长时间。
- en: Longer download times and higher network usage due to the increased size of
    the image
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于镜像的体积增大，下载时间较长，网络使用量也更高。
- en: Unit and integration tests are typically run on the developer’s local machine
    before they push code to a code repository such as GitHub. Once the code is pushed
    to GitHub or any other remote code repository, usually the CI/CD pipeline kicks
    in and the CI stage is executed. Part of this stage is the execution of all unit
    and integration tests against the application. Usually, this is performed on a
    so-called build agent. In many cases, this is a sandbox environment where Docker
    containers can be run. Thus, the CI stage uses the same technique to run the tests
    in the build agent as a developer would do locally. It is important to note that
    tests other than some special smoke tests are never run in a production environment,
    since this could have undesired side effects.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 单元测试和集成测试通常在开发者将代码推送到如 GitHub 这样的代码仓库之前，在开发者的本地机器上运行。一旦代码被推送到 GitHub 或任何其他远程代码仓库，通常
    CI/CD 管道就会启动，并执行 CI 阶段。该阶段的一部分是对应用程序执行所有单元测试和集成测试。通常，这些测试是在所谓的构建代理上执行的。在许多情况下，这是一个沙盒环境，可以运行
    Docker 容器。因此，CI 阶段使用与开发者在本地运行测试相同的技术来在构建代理中运行测试。需要注意的是，除了某些特殊的冒烟测试外，其他测试绝不会在生产环境中运行，因为这样可能会产生不良的副作用。
- en: One of the most important advantages of running tests in containers is the isolation
    aspect. We can run the tests on any environment able to run containers and do
    not have to worry about installing frameworks or libraries on the hosting machine
    first.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在容器中运行测试的最重要优势之一是隔离性。我们可以在任何能够运行容器的环境中运行测试，无需担心首先在主机上安装框架或库。
- en: Another important advantage is that running tests in containers makes them repeatable
    out of the box. Each time a container containing the application code and the
    tests are started, the boundary conditions are the same. With this, we guarantee
    consistency in the test execution. Were we to run the tests natively on the host,
    we would have a harder time guaranteeing this consistency.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的优势是，容器中的测试本身是开箱即用的可重复的。每次启动包含应用代码和测试的容器时，边界条件都是相同的。通过这种方式，我们保证了测试执行的一致性。如果我们在主机上本地运行测试，我们将更难保证这一点。
- en: 'Some challenges we may face when running our tests inside containers are as
    follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在容器中运行测试时可能面临的挑战如下：
- en: It may be harder to troubleshoot and debug failing tests
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 排查和调试失败的测试可能更加困难。
- en: Integration testing can be more challenging when several containers are involved
    in the necessary setup
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要多个容器进行必要的设置时，集成测试可能更加具有挑战性。
- en: Resources such as CPU, RAM, and network bandwidth can be limited in a containerized
    environment (via cgroup settings) and thus negatively impact your test runs
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 容器化环境中的资源（如 CPU、内存和网络带宽）可以受到限制（通过 cgroup 设置），从而对测试运行产生负面影响。
