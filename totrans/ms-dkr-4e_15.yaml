- en: '*Chapter 15*'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By now, you should already be thinking about how you can start to introduce
    Docker into your everyday workflow. In this chapter, we'll put all the pieces
    together so you can start using Docker in your local development environment.
    We'll also look at some of the considerations that you need to take when planning
    your production environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter, all of which will
    build on what we have learned in the previous chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker for development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring Docker and Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What does production look like?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be using Docker on the desktop. As with previous chapters,
    I will be using my preferred operating system, which is macOS. The Docker commands
    we will be running will work on all three of the operating systems we have installed
    Docker on so far; however, some of the supporting commands, which will be few
    and far between, may only apply to macOS- and Linux- based operating systems.
  prefs: []
  type: TYPE_NORMAL
- en: Docker for development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to start our look at the workflows by discussing how Docker can
    be used to aid developers. Right back at the start of [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046),
    *Docker Overview*, one of the first things we discussed in the *Understanding
    Docker* section was developers and the, works on my machine, problem. So far,
    we have not really fully addressed this, so let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we are going to look at how a developer could develop their
    WordPress project on their local machine using Docker for macOS or Docker for
    Windows, along with Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: 'The aim of this is for us to launch a WordPress installation, which is what
    you will do by going through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download and install WordPress.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow access to the WordPress files from desktop editors—such as Atom, Visual
    Studio Code, or Sublime Text—on your local machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure and manage WordPress using the **WordPress command-line** tool (**WPCLI**).
    This allows you to stop, start, and even remove containers without losing your
    work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Before we launch our WordPress installation, let''s take a look at the Docker
    Compose file, which you can find in the `chapter14/docker-wordpress` folder of
    the accompanying repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be launching four different services, starting with `web`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Followed by the `wordpress` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we have the `mysql` database service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we have a supporting service simply called `wp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We can visualize the Docker Compose file using the `docker-compose-viz` tool
    from `PMSIpilot`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run the following command in the same folder as the `docker-compose.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output a file called `docker-compose.png`, and you should get something
    that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1: Output of the running docker-compose-viz against our WordPress
    Docker Compose file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.01_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.1: Output of the running docker-compose-viz against our WordPress
    Docker Compose file'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first service is called web. This service is the only one of the four services
    that is exposed to the host network, and it acts as a frontend to our WordPress
    installation. It runs the official NGINX image from [https://store.docker.com/images/nginx/](https://store.docker.com/images/nginx/)
    and it performs two roles. Take a look at the NGINX configuration and see if you
    can guess what they are:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You can see that we are serving all content, apart from PHP, using the NGINX
    from `/var/www/html/`, which we are mounting from our host machine using NGINX,
    and all requests for PHP files are being proxied to our second service, which
    is called `wordpress`, on port `9000`. The NGINX configuration itself is being
    mounted from our host machine to `/etc/nginx/conf.d/default.conf`.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that our NGINX container is acting as a web server for the
    static content, the first role, and also as a proxy through to the WordPress container
    for the dynamic content, which is the second role the container takes on—did you
    guess right?
  prefs: []
  type: TYPE_NORMAL
- en: The second service is `wordpress`. This is the official WordPress image from
    [https://hub.docker.com/images/wordpress](https://hub.docker.com/images/wordpress),
    and I am using the `php7.2-fpm-alpine` tag. This gives us a WordPress installation
    running on PHP 7.2 using `PHP-FPM` built on top of an Alpine Linux base.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**PHP FastCGI Process Manager** (**PHP-FPM**) is a PHP FastCGI implementation
    with some great features. For us, it allows PHP to run as a service that we can
    bind to a port and pass requests to; this fits in with the Docker method of running
    a single service on each container.'
  prefs: []
  type: TYPE_NORMAL
- en: We are mounting the same web root as we are using for the web service, which
    on the host machine is `wordpress/web` and on the service is `/var/www/html/`.
    To start off with, the folder on our host machine will be empty; however, once
    the WordPress service starts, it will detect that there isn't a core WordPress
    installation and copy one to that location, effectively bootstrapping our WordPress
    installation and copying it to our host machine, ready for us to start working
    on it.
  prefs: []
  type: TYPE_NORMAL
- en: The third service is MySQL, which uses the official MySQL image, which can be
    found at [https://hub.docker.com/images/mysql](https://hub.docker.com/images/mysql)
    and is the only image out of the four we are using that doesn't use Alpine Linux
    (come on MySQL; pull your finger out and publish an Alpine Linux-based image!).
    Instead, it uses `debian:buster-slim`.
  prefs: []
  type: TYPE_NORMAL
- en: We are passing a few environment variables so that a database, username, and
    password are all created when the container first runs; the password is something
    you should change if you ever use this as a base for one of your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Like the web and `wordpress` containers, we are mounting a folder from our host
    machine. In this case, it is `wordpress/mysql`, and we are mounting it to `/var/lib/mysql/`,
    which is the default folder where MySQL stores its databases and associated files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fourth and final service is simply called `wp`. It differs from the other
    three services: this service will immediately exit when executed because there
    is no long-running process within the container. Instead of a long-running process,
    we have a single process that is used to interact with and manage our WordPress
    installation.'
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of running this tool in a container is that the environment we
    are running the command-line tool in exactly matches our main `wordpress` container.
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that we are mounting the web root as we have done on the web
    and WordPress, meaning that the container has full access to our WordPress installation
    as well as a second mount called `/export`; we will look at this in more detail
    once we have WordPress configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start WordPress, we just need to run the following command to pull the images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This will pull the images and start the web, `wordpress`, and `mysql` services,
    as well as readying the `wp` service. Before the services start, our `wordpress`
    folder looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2: Before launching WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.02_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.2: Before launching WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we only have **nginx.conf** in there, which is part of the
    Git repository. Then we can use the following commands to start the containers
    and check their status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Your Terminal output should look similar to the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3: Launching and checking the status of our WordPress installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.03_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.3: Launching and checking the status of our WordPress installation'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see that three folders have been created in the `wordpress` folder:
    `export`, `mysql`, and `web`. Also, remember that we are expecting `dockerwordpress_wp_1`
    to have an exit state of `Exit 1`, so that''s fine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4: Checking the folders created by launching WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.04_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.4: Checking the folders created by launching WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening a browser and going to `http://localhost:8080/` should show you the
    standard WordPress preinstallation welcome page, where you can select the language
    you wish to use for your installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5: The WordPress setup screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.05_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.5: The WordPress setup screen'
  prefs: []
  type: TYPE_NORMAL
- en: Do not click on **Continue**, as it will take you to the next screen of the
    GUI-based installation. Instead, return to your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rather than using the GUI to complete the installation, we are going to use
    `wp-cli`. There are two steps to this. The first step is to create a `wp-config.php`
    file. To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you will see in the following Terminal output, before I ran the command,
    I just had the `wp-config-sample.php` file, which ships with core WordPress. Then,
    after running the command, I had my own `wp-config.php` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6: Creating the wp-config.php file using wp-cli'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.06_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.6: Creating the wp-config.php file using wp-cli'
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that in the command, we are passing the database details that
    we defined in the Docker Compose file and telling WordPress that it can connect
    to the database service at the address of `mysql`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have configured database connection details, we need to configure
    our WordPress site, as well as create an admin user and set a password. To do
    this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Running this command will produce an error in the email service; do not worry
    about this message, as this is only a local development environment. We are not
    too worried about emails leaving our WordPress installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.7: Configuring WordPress using cp-cli'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.07_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.7: Configuring WordPress using cp-cli'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have used wp-cli to configure the following in WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: Our URL is **http://localhost:8080**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our site title should be **Blog Title**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our admin username is **admin** and our password is **password**, and the user
    has the email address **email@domain.com**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Going back to your browser and entering `http://localhost:8080/` should present
    you with a vanilla WordPress site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8: A default WordPress site'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.08_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.8: A default WordPress site'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we do anything further, let''s customize our installation a little,
    first by installing and enabling the **JetPack** plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9: Installing the JetPack plugin'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.09_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.9: Installing the JetPack plugin'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, `install` and enable the **Sydney** theme:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10: Installing the Sydney theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.10_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.10: Installing the Sydney theme'
  prefs: []
  type: TYPE_NORMAL
- en: 'Refreshing our WordPress page at `http://localhost:8080/` should show something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11: Viewing our site with the updated theme'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.11_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.11: Viewing our site with the updated theme'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we open our IDE, let''s destroy the containers running our WordPress
    installation using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12: Stopping and removing the containers that are running WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.12_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.12: Stopping and removing the containers that are running WordPress'
  prefs: []
  type: TYPE_NORMAL
- en: 'As our entire WordPress installation, including all of the files and the database,
    is stored on our local machine, we should be able to run the following command
    to return our WordPress site where we left it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Once you have confirmed that it is up and running as expected by going to `http://
    localhost:8080/`, open the `docker-wordpress` folder in your desktop editor. I
    used Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'In your editor, open the `wordpress/web/wp-blog-header.php` file, add the following
    line to the opening PHP statement, and save it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The file should look something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15\. 13: Editing wp-blog-header.php in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.13_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15\. 13: Editing wp-blog-header.php in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once saved, refresh your browser. You should see the message **Testing editing
    in the IDE** at the very bottom of the page (the following screen is zoomed; it
    may be more difficult to spot if you are following along on screen, as the text
    is quite small):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14: Viewing our edit on the page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.14_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.14: Viewing our edit on the page'
  prefs: []
  type: TYPE_NORMAL
- en: The final thing we are going to look at is why we had the `wordpress/export`
    folder mounted on the `wp` container.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned earlier in the chapter, you shouldn't really be touching
    the contents of the `wordpress/mysql` folder; this also includes sharing it. While
    it would probably work if you were to zip up your project folder and pass it to
    a colleague, this is not considered best practice. Because of this, we have mounted
    the export folder to allow us to use WPCLI to make a database dump and import
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Depending on the version of Docker you are running, you may receive a permission-denied
    error when running the preceding command; if you do, then run the following command
    instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will copy the database dump to `wordpress/wordpress` rather than `wordpress/export`.
    The reason for this is that different host operating systems handle the creation
    of local files differently, which can cause permission issues within the container
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following Terminal output shows the export and also the contents of `wordpress/export`
    before and after the command being run, and lastly, the top few lines of the MySQL
    dump file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15: Dumping the WordPress database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.15_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.15: Dumping the WordPress database'
  prefs: []
  type: TYPE_NORMAL
- en: 'If I had, say, made a mistake during development and accidently trashed part
    of my database, I could roll back to the backup of the database I made by running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16: Importing the WordPress database'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.16_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.16: Importing the WordPress database'
  prefs: []
  type: TYPE_NORMAL
- en: As you can seen, we have installed WordPress, interacted with it using both
    the WordPress command-line tool, `wp-cli`, and also in a web browser, edited the
    code, and backed up and restored the database, all without having to install or
    configure `NGINX`, `PHP`, `MySQL`, or `wp-cli` on our local machine. Nor did we
    have to log in to a container. By mounting volumes from our host machine, our
    content was safe when we tore our WordPress containers down and we didn't lose
    any work.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if needed, we could have easily passed a copy of our project folder to
    a colleague who has Docker installed, and with a single command, they could be
    working on our code, knowing that it is running in the same exact environment
    as our own installation.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you like, you can stop and remove your WordPress containers by running `docker-compose`
    down. If you are following along, you might want to keep WordPress for the next
    section so that you have running containers to monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, as we're using official images from the Docker Hub, we know we can
    safely ask to have them deployed into production, as they have been built with
    Docker's best practices in mind.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that you may find really useful is how well Docker can be integrated
    in your IDE of choice. A few pages back, when we edited the `wp-blog-header.php`
    file, you may have noticed a Docker icon on the left-hand side of the screen.
    Before we finish this section of the chapter, let's quickly discuss how Microsoft
    have integrated Docker support into Visual Studio Code, or VS Code, as we will
    be calling it from now on.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to do is install VS Code, which you can find at [https://code.visualstudio.com/](https://code.visualstudio.com/),
    and the Microsoft Docker extension, which can found in the Visual Studio Market
    place at [https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker](https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker).
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that the extension is not in your face. This is because it
    integrates quite deeply with VS Code—for example, if you were to right-click over
    the `docker-compose.yml` file in the explorer, you will notice that the menu has
    some options that allow you to interact with Docker Compose:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17: Running Docker Compose from VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.17_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.17: Running Docker Compose from VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Docker** icon on the left-hand side will bring up a list
    running Containers, available Images, Registries that you are connected to, Networks,
    and Volumes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.18: Viewing your running containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.18_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.18: Viewing your running containers'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-clicking over a container gives you the option to attach to the running
    container using the terminal that is built into VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.19: Attaching to a container using the built-in terminal'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.19_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.19: Attaching to a container using the built-in terminal'
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening the folder from the Git repository that accompanies this title in VS
    Code and then pressing *CMD +Shift + P* will open the command prompt in VS Code.
    From here, type `Dockerfile` files and ask you which one you want to build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.20: Choosing a Dockerfile to build'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.20_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.20: Choosing a Dockerfile to build'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once built, your image will be listed in the Docker section, and you can right-click
    over the tag to push it to any of the registries you are connected to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.21: Pushing our newly built image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.21_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.21: Pushing our newly built image'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also run the container. Once it is running, you can then right-click
    on it and select **Open in browser** to go straight to the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.22: Opening a running container in your browser'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.22_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.22: Opening a running container in your browser'
  prefs: []
  type: TYPE_NORMAL
- en: The final trick up the VS Code Docker extension's sleeve that we are going to
    cover is an extremely useful one. Let's say that you have a repository with no
    `Dockerfile`—for example, the Go Training `helloworld` repository, which can be
    found at [https://github.com/go-training/helloworld/](https://github.com/go-training/helloworld/),
    has no `Dockerfile` or `docker-compose.yml` files. Grab a copy of it and open
    it in VS Code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once open, press *CMD +Shift + P*, type in `Add Docker`, and then select `3000`.
    Once you hit `Dockerfile`, which looks like the following, will be opened:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.23: A VS-Code-generated, multistage Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.23_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.23: A VS-Code-generated, multistage Dockerfile'
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also notice that a `docker-compose.yml` file along with a `.dockerignore`
    and a few other files have been generated. From here, you can build the image,
    and then run it. I recommend using the **Run interactive** option as all the application
    does is print **Hello World!** and then exit, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.24: Running the application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.24_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.24: Running the application'
  prefs: []
  type: TYPE_NORMAL
- en: As I am sure you have seen, the Docker integration with VS Code is extremely
    powerful, and enables you to run pretty much every Docker command that we have
    covered in previous chapters from within VS Code. There are similar extensions
    for other IDEs. These are linked in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Azure DevOps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 3*](B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109)*, Storing and
    Distributing Images* in the *Reviewing third-party registries* section, we looked
    at how we can use GitHub to both host and also build our container images. We
    also discussed Azure Container Registry.
  prefs: []
  type: TYPE_NORMAL
- en: To close this section of the chapter, we are going to quickly look at getting
    an Azure DevOps pipeline configured that builds the multistage Dockerfile that
    we covered in [*Chapter 2*](B15659_02_Final_JM_ePub.xhtml#_idTextAnchor068)*,
    Building Container Images*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we configure our pipeline, let''s discuss what Azure DevOps is. It is
    a service offered by Microsoft that provides the following capabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requirements management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Project management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That might seem like a lot of different services, and it is, but Azure DevOps
    is the glue that can bind together various Microsoft services in both the Microsoft
    Azure ecosystem and their programming languages, such as .NET, and tools, such
    as Visual Studio. Covering everything would take up an entire book; in fact, there
    are several on the subject, so we will only be touching upon the basic functionality
    needed to build our container and push it to the Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: The only requirement you need to get started with Azure DevOps is an account—to
    sign up for free, go to [https://dev.azure.com/](https://dev.azure.com/%20) and
    follow the on-screen prompts. Once you have created your account, click on the
    **+ New project** button.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are on the **Create new project** page, you will find the option to
    fill in a **Project****Name** and **Description** and choose the **Visibility**;
    by default, projects are **Private**, but you can also make them **Public**.
  prefs: []
  type: TYPE_NORMAL
- en: Fill in the details and then click on **Create**. I would recommend making your
    project **Private**.
  prefs: []
  type: TYPE_NORMAL
- en: Once your project has been created, click on the **Project Settings** option,
    which can be found at the very bottom of the left-hand side menu. Once the **Project
    Settings** page loads, click on **Service connections**, which can be found under
    **Pipelines**.
  prefs: []
  type: TYPE_NORMAL
- en: From there, click the **Create Service** connection button and select **Docker
    Registry** from the list of services you are presented with.
  prefs: []
  type: TYPE_NORMAL
- en: 'From here, select the radio icon next to **Docker Hub**, enter your Docker
    ID, and then enter your **Docker password**. If your Docker Hub account is protected
    by multifactor authentication, which I really recommend you configure, then you
    will need a user access token—we covered this in the Docker Hub section of [*Chapter
    3*](B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109)*, Storing and Distributing
    Images*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.25: Setting up the service connection to Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.25_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.25: Setting up the service connection to Docker Hub'
  prefs: []
  type: TYPE_NORMAL
- en: Once you have entered your details, click on the **Verify** button, and if the
    details you entered are correct, you will get a green tick. Before you click on
    the **Verify and save** button, you need to enter a **Service connection name**;
    I entered **Docker**, but you can use whatever you like—just make a note of it
    as we will need it shortly.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, you will need a Git repository that contains the `Dockerfile` as well
    as a file called `azure-pipelines.yml`—there is an example repository at [https://github.com/russmckendrick/DevOpsContainerBuild](https://github.com/russmckendrick/DevOpsContainerBuild)
    that you can fork.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have your repository, return to your Azure DevOps project and then
    click on **Pipelines** in the left-hand side menu—here, you will be presented
    with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.26: Viewing the Pipelines page for the first time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.26_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.26: Viewing the Pipelines page for the first time'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, you need to click on **Create Pipeline**, this will
    ask you for several pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Where is your code?** Select GitHub. You will notice that YAML is next to
    it. We will be talking about the YAML file once we have the pipeline configured.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Follow the onscreen instructions to link Azure DevOps to your GitHub account.
    Once it is linked, you will be asked to **Select a repository**. Select the repository
    that you forked earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the `azure-pipelines.yml` file is not automatically selected and you stay
    on the **Configure** screen, click on the **Existing Azure Pipelines YAML file**
    option, select the file from the drop-down list, and then click on **Continue**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Review** page gives you the option to **Review your pipeline YAML** file,
    as well as the option to **Run** it; however, before we do, click on **Variables**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to add two variables. The first will let the pipeline know the name
    of the service connection to Docker Hub that we configured earlier in this section
    and the second one will let the pipeline know the name of the Docker Hub repository
    we would like our Azure DevOps pipeline to push the image to once it has been
    built.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on the `targetRegistry` in the `Docker`. Click on the `targetRepo`, then
    for the `russmckendrick/AzureDevOpsBuild`. Click on **OK** and then **Save**.
    Once saved, click on the **Run** button to trigger your build.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `azure-pipeline.yml` file looks like the following. First, we have the
    **trigger** configuration; this is set to **master**, which means that a build
    is triggered every time that the master branch is updated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we have **pool**. This tells Azure DevOps which virtual image to launch
    when the pipeline is being executed; as you can see, we are using Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The remainder of the `azure-pipeline.yml` file is the build `Docker@2` task
    to log in to Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We are using the variable that we defined when setting up the pipeline by entering
    `$(targetRegistry)`. This lets the task know which service connection to use.
    The next task builds and pushes our container image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax is easy to follow. We are also using the second
    variable `$(targetRepo)` to define the target for our image to be pushed to. The
    final task logs out of Docker Hub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: While the last task is probably not really needed, as, while Azure DevOps spins
    up to build our image, the virtual machine is terminated once the build finishes,
    it will also be terminated if there are any errors, so we do not have to worry
    about the virtual machine being reused or our login being accessed by a third
    party.
  prefs: []
  type: TYPE_NORMAL
- en: 'A completed pipeline run looks something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.27: A completed pipeline run'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.27_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.27: A completed pipeline run'
  prefs: []
  type: TYPE_NORMAL
- en: Once finished, you should see the newly built container in your Docker Hub account.
    As mentioned before we started to configure our Azure DevOps pipeline, we have
    hardly scratched the surface of what Azure DevOps can do; see the *Further reading*
    section of this chapter for some interesting links on Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to take a look at how to monitor our containers and Docker
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring Docker and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B15659_04_Final_JM_ePub.xhtml#_idTextAnchor133), *Managing
    Containers*, we discussed the `docker container top` and `docker container stats`
    commands. You may recall that both of these commands show real-time information
    only—there is no historical data that is kept.
  prefs: []
  type: TYPE_NORMAL
- en: This is great if you are trying to debug a problem as it is running or want
    to quickly get an idea of what is going on inside your containers; however, it
    is not too helpful if you need to look back at a problem. For example, you may
    have configured your containers to restart if they have become unresponsive. While
    that will help with the availability of your application, it isn't much of a help
    if you need to look at why your container became unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the GitHub repository in the `/chapter14` folder, there is a folder called
    `prometheus` in which there is a Docker Compose file that launches three different
    containers on two networks. Rather than looking at the Docker Compose file itself,
    let''s take a look at a visualization:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.28: Visualization of the Prometheus Docker Compose file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.28_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.28: Visualization of the Prometheus Docker Compose file'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can generate this yourself by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, there is a lot going on. The three services that we are running
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Cadvisor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prometheus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grafana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we launch and configure our Docker Compose services, we should talk
    about why each one is needed, starting with `cadvisor`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cadvisor` service is a project that was released by Google. As you can
    see from the Docker Hub username in the image we are using, the service section
    in the Docker Compose file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We are mounting the various parts of our host's filesystem to allow `cadvisor`
    access to our Docker installation in much the same way as we did in [*Chapter
    9*](B15659_09_Final_JM_ePub.xhtml#_idTextAnchor261), *Portainer* – *A GUI for
    Docker*. The reason for this is that, in our case, we are going to be using `cadvisor`
    to collect statistics on our containers. While it can be used as a standalone
    container-monitoring service, we do not want to publicly expose the `cadvisor`
    container. Instead, we are just making it available to other containers within
    our Docker Compose stack on the back network.
  prefs: []
  type: TYPE_NORMAL
- en: The `cadvisor` service is a self-contained web frontend to the Docker container
    stat command, displaying graphs and allowing you to drill down from your Docker
    host into your containers using an easy-to-use interface; however, it doesn't
    keep more than five minutes' worth of metrics.
  prefs: []
  type: TYPE_NORMAL
- en: As we are attempting to record metrics that can be available hours or even days
    later, having no more than five minutes' worth of metrics means that we are going
    to have to use additional tools to record the metrics it processes. The `cadvisor`
    service exposes the information that we want to record in our containers as structured
    data at `http://cadvisor:8080/metrics/`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will look at why this is important in a moment. The `cadvisor` endpoint
    is being scraped automatically by our next service, `prometheus`. This is where
    most of the heavy lifting happens. The `prometheus` is a monitoring tool that
    is written and open sourced by SoundCloud:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the preceding service definition, we are mounting a configuration
    file called `./prometheus/prometheus.yml` and a volume called `prometheus_data`.
    The configuration file contains information about the sources we want to scrape,
    as you can see from the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are instructing Prometheus to scrape data from our endpoints every 15 seconds.
    The endpoints are defined in the `scrape_configs` section, and as you can see,
    we have `cadvisor` defined in there, as well as Prometheus itself. The reason
    we are creating and mounting the `prometheus_data` volume is that Prometheus is
    going to be storing all of our metrics, so we need to keep it safe.
  prefs: []
  type: TYPE_NORMAL
- en: At its core, Prometheus is a time-series database. It takes the data it has
    scraped, processes it to find the metric name and value, and then stores it along
    with a timestamp.
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus also comes with a powerful query engine and API, making it the perfect
    database for this kind of data. While it does come with basic graphing capabilities,
    it is recommended that you use *Grafana*, which is our final service, and also
    the only one to be exposed publicly.
  prefs: []
  type: TYPE_NORMAL
- en: '*Grafana* is an open source tool for displaying monitoring graphs and metric
    analytics, which allows you to create dashboards using time-series databases,
    such as Graphite, InfluxDB, and also Prometheus. There are also further backend
    database options that are available as plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Compose definition for Grafana follows a similar pattern to our
    other services:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `grafana_data` volume to store Grafana's own internal configuration
    database, and rather than storing the environment variables in the Docker Compose
    file, we are loading them from an external file called `./grafana/grafana.config`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The variables are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are setting the username and password here, so having them
    in an external file means that you can change these values without editing the
    core Docker Compose file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know the role that each of the three services fulfills, let's launch
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, simply run the following commands from the `prometheus` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create a network and the volumes and pull the images from the Docker
    Hub. It will then go about launching the three services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.29: Running docker-compose up -d to launch our Prometheus application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.29_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.29: Running docker-compose up -d to launch our Prometheus application'
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be tempted to go immediately to your Grafana dashboard. If you did,
    you would not see anything, as Grafana takes a few minutes to initialize itself.
    You can follow its progress by looking at the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of the command is given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.30: Checking the logs to see if Grafana is ready'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.30_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.30: Checking the logs to see if Grafana is ready'
  prefs: []
  type: TYPE_NORMAL
- en: Once you see the `HTTP Server Listen` message, Grafana will be available. From
    Grafana version `5`, you can import data sources and dashboards, which is why
    we are mounting the `./grafana/provisioning/` folder from our host machine to
    `/etc/grafana/provisioning/`.
  prefs: []
  type: TYPE_NORMAL
- en: This folder contains the configuration that automatically configures Grafana
    to talk to our Prometheus service and imports the dashboard, which will display
    the data that Prometheus is scraping from `cadvisor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your browser and enter [http://localhost:3000/](http://localhost:3000/);
    you should be greeted with a login screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.31: The Grafana login page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.31_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.31: The Grafana login page'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `admin` with a `password`. Once logged in, if you have configured
    the data source, you should see the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.32: Logging into Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.32_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.32: Logging into Grafana'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the initial steps of **Add your first data source** and **Create
    your first dashboard** have all been completed. Clicking on the **Home** button
    in the top left will bring up a menu that lists the available dashboards:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.33: Viewing the available dashboards'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.33_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.33: Viewing the available dashboards'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have one called **Docker Monitoring**. Clicking on it will
    take you to the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.34: The Docker Monitoring dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.34_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.34: The Docker Monitoring dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the timing information in the top right of the screen,
    by default, it displays the last five minutes'' worth of data. Clicking on it
    will allow you to change the time frame displays. For example, the following screen
    shows the last 15 minutes, which is obviously more than the five minutes that
    `cadvisor` is recording:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.35: Viewing 15 minutes of data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_15.35_B15659.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 15.35: Viewing 15 minutes of data'
  prefs: []
  type: TYPE_NORMAL
- en: I have already mentioned that this is a complex solution; eventually, Docker
    will expand the recently built-in Prometheus endpoint, which currently only exposes
    information about Docker Engine and not the containers themselves. For more information
    on the built-in endpoint, check out the official Docker documentation, which can
    be found at [https://docs.docker.com/config/daemon/prometheus/](https://docs.docker.com/config/daemon/prometheus/).
  prefs: []
  type: TYPE_NORMAL
- en: There are other monitoring solutions out there; most of them take the form of
    third-party **software as a service** (**SaaS**). As you can see from the list
    of services in the *Further reading* section, there are a few well-established
    monitoring solutions out there. In fact, you may already be using them, so it
    would be easy for you when expanding your configuration to take this into account
    when monitoring your containers.
  prefs: []
  type: TYPE_NORMAL
- en: '*What about Kubernetes?* you may be asking yourself. I have already mentioned
    that Prometheus was originally developed by *SoundCloud*, but it was also one
    of the first projects outside of Kubernetes to be donated to the **Cloud Native
    Computing Foundation** (**CNCF**).'
  prefs: []
  type: TYPE_NORMAL
- en: This means that there is support for Prometheus within Kubernetes and external
    services, such as Azure AKS—for example, Azure Monitor has seamless integration
    with Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: For a demonstration of this, see the Azure Friday presentation *How to use Prometheus
    to monitor containers in Azure Monitor* by *Keiko Harada with Scott Hanselman*,
    which can be found at the Microsoft Azure YouTube channel at [https://www.youtube.com/watch?v=5ARJ6DzqTYE](https://www.youtube.com/watch?v=5ARJ6DzqTYE).
  prefs: []
  type: TYPE_NORMAL
- en: What does production look like?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For the final section of this chapter, we are going to discuss what production
    should look like. This section isn't going to be as long as you think it will
    be, as the sheer number of options that are available means that it would be impossible
    to cover them all. You should also already have a good idea of what would work
    best for you based on the previous sections and chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, we are going to be looking at some questions that you should be asking
    yourself when planning your environments.
  prefs: []
  type: TYPE_NORMAL
- en: Your Docker hosts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker hosts are the key component of your environment. Without these, you won't
    have anywhere to run your containers. As we have already seen in previous chapters,
    there are a few considerations to bear in mind when it comes to running your Docker
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to take into account is that, if your hosts are running
    Docker, they should not run any other services.
  prefs: []
  type: TYPE_NORMAL
- en: Mixing of processes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should resist the temptation of quickly installing Docker on an existing
    host and launching a container. This might not only have implications for security,
    with you having a mixture of isolated and nonisolated processes on a single host,
    but it can also cause performance issues as you are not able to add resource limits
    to your noncontainerized applications, meaning that, potentially, they can also
    have a negative impact on your running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple isolated Docker hosts
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you have more than a few Docker hosts, how are you going to manage them?
    Running a tool, such as Portainer, is great, but it can become troublesome when
    attempting to manage more than a few hosts. Also, if you are running multiple
    isolated Docker hosts, you do not have the option of moving containers between
    hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, you can use tools such as Weave Net to span the container network across
    multiple individual Docker hosts. Depending on your hosting environment, you may
    also have the option of creating volumes on external storage and presenting them
    to Docker hosts as needed, but you are very much creating a manual process to
    manage the migration of containers between hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Routing to your containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You need to consider how you are going to route requests among your containers
    if you have multiple hosts.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have an external load balancer, such as an ELB in AWS, or
    a dedicated device in front of an on-premise cluster, do you have the ability
    to dynamically add routes for traffic hitting port **x** on your load balancer
    to port **y** on your Docker hosts, at which point the traffic is then routed
    through to your container?
  prefs: []
  type: TYPE_NORMAL
- en: If you have multiple containers that all need to be accessible on the same external
    port, how are you going handle that?
  prefs: []
  type: TYPE_NORMAL
- en: Do you need to install a proxy, such as Traefik, HAProxy, or NGINX to accept
    and then route your requests based on virtual hosts based on domains or subdomains,
    rather than just using port-based routing?
  prefs: []
  type: TYPE_NORMAL
- en: Clustering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of what we have discussed in the previous section can be solved by introducing
    clustering tools, such as Docker Swarm and Kubernetes.Let's quickly discuss some
    of the things that you should be asking yourself when assessing clustering technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Compatibility
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though an application might work fine on a developer's local Docker installation,
    you need to be able to guarantee that if you take the application and deploy it
    to, for example, a Kubernetes cluster, it works in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Nine times out of ten, you will not have a problem, but you do need to consider
    how the application is communicating internally with other containers within the
    same application set.
  prefs: []
  type: TYPE_NORMAL
- en: Reference architectures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Are there reference architectures available for your chosen clustering technology?
    It is always best to check when deploying a cluster. There are best-practice guides
    that are close to or match your proposed environment. After all, no one wants
    to create one big single point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: Also, what are the recommended resources? There is no point in deploying a cluster
    with five management nodes and a single Docker host, just like there is little
    point in deploying five Docker hosts and a single management server, as you have
    quite a large single point of failure.
  prefs: []
  type: TYPE_NORMAL
- en: What supporting technologies does your cluster technology support (for example,
    remote storage, load balancers, and firewalls)?
  prefs: []
  type: TYPE_NORMAL
- en: Cluster communication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What are the requirements when it comes to the cluster communicating with either
    management or Docker hosts? Do you need an internal or separate network to isolate
    the cluster traffic?
  prefs: []
  type: TYPE_NORMAL
- en: Can you easily lock a cluster member down to only your cluster? Is the cluster
    communication encrypted? What information about your cluster could be exposed?
    Does this make it a target for hackers?
  prefs: []
  type: TYPE_NORMAL
- en: What external access does the cluster need to APIs, such as your public cloud
    providers? How securely are any API/access credentials stored?
  prefs: []
  type: TYPE_NORMAL
- en: Image registries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How is your application packaged? Have you baked the code into the image? If
    so, do you need to host a private local image registry or are you okay with using
    an external service, such as Docker Hub, **Docker Trusted Registry** (**DTR**),
    or Quay?
  prefs: []
  type: TYPE_NORMAL
- en: If you need to host your own private registry, where in your environment should
    it sit? Who has or needs access? Can it hook into your directory provider, such
    as an Active Directory installation?
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a few different workflows for Docker, along with
    how to get some monitoring for your containers and Docker hosts up and running.
  prefs: []
  type: TYPE_NORMAL
- en: The best thing you can do when it comes to your own environment is build a proof
    of concept and try as hard as you can to cover every disaster scenario you can
    think of. You can get a head start by using the container services provided by
    your cloud provider or by looking for a good reference architecture, which should
    both reduce your trial and error rates.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a look at what your next step in the
    world of containers could be.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which container serves our WordPress website?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why doesn't the `wp` container remain running?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In minutes, how long does `cadvisor` keep metrics for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What Docker Compose command can be used to remove everything to do with the
    application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find details on the software we have used in this chapter at the following
    sites:'
  prefs: []
  type: TYPE_NORMAL
- en: 'WordPress: [http://wordpress.org/](http://wordpress.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'WP-CLI: [https://wp-cli.org/](https://wp-cli.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PHP-FPM: [https://php-fpm.org/](https://php-fpm.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cadvisor: [https://github.com/google/cadvisor/](https://github.com/google/cadvisor/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana: [https://grafana.com/](https://grafana.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prometheus data model: [https://prometheus.io/docs/concepts/data_model/](https://prometheus.io/docs/concepts/data_model/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Traefik: [https://containo.us/traefik/](https://containo.us/traefik/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'HAProxy: [https://www.haproxy.org/](https://www.haproxy.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NGINX: [https://nginx.org/](https://nginx.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on Docker and Azure DevOps, go to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Azure DevOps Docker Build Task: [https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/build/docker?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/build/docker?view=azure-devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure DevOps Docker Compose Build Task: [https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/build/docker-compose?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/tasks/build/docker-compose?view=azure-devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure DevOps and Azure Container Registry: [https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/containers/acr-template?view=azure-devops](https://docs.microsoft.com/en-us/azure/devops/pipelines/ecosystems/containers/acr-template?view=azure-devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Azure DevOps titles at Packt Publishing: [https://www.packtpub.com/catalogsearch/result/?q=Azure%20DevOps](https://www.packtpub.com/catalogsearch/result/?q=Azure%20DevOps)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Other externally hosted Docker monitoring platforms include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sysdig Cloud: [https://sysdig.com/](https://sysdig.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Datadog: [https://docs.datadoghq.com/agent/docker/?tab=standard](https://docs.datadoghq.com/agent/docker/?tab=standard%20)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'SignalFx: [https://signalfx.com/docker-monitoring/](https://signalfx.com/docker-monitoring/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'New Relic: [https://newrelic.com/partner/docker](https://newrelic.com/partner/docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sematext: [https://sematext.com/docker/](https://sematext.com/docker/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also other self-hosted options, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Elastic Beats: [https://www.elastic.co/products/beats](https://www.elastic.co/products/beats)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sysdig: [https://sysdig.com/opensource/](https://sysdig.com/opensource/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Zabbix: [https://github.com/monitoringartist/zabbix-docker-monitoring](https://github.com/monitoringartist/zabbix-docker-monitoring)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following list shows some extensions for other IDEs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Atom Docker Package: [https://atom.io/packages/docker](https://atom.io/packages/docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sublime Text Docker Plugin: [https://github.com/domeide/sublime-docker](https://github.com/domeide/sublime-docker)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jetbrains Docker support: [https://www.jetbrains.com/help/idea/docker.html](https://www.jetbrains.com/help/idea/docker.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
