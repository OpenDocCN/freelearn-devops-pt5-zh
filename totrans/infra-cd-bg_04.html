<html><head></head><body>
<div><div><div><h1 id="_idParaDest-60" class="chapter-number"><a id="_idTextAnchor151"/>4</h1>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor152"/>Deploying to Microsoft Azure</h1>
			<p>In this fourth chapter, we are going to look at getting our project deployed with the first of the two major public cloud providers we are going to cover in this book, <strong class="bold">Microsoft Azure</strong>.</p>
			<p>We are going to cover the following topics:</p>
			<ul>
				<li><a id="_idTextAnchor153"/>Introducing Microsoft Azure</li>
				<li><a id="_idTextAnchor154"/>Preparing our cloud environment for deployment</li>
				<li><a id="_idTextAnchor155"/>Producing the low-level design</li>
				<li>Terraform – writing the code and deploying our infrastructure</li>
				<li><a id="_idTextAnchor156"/><a id="_idTextAnchor157"/>Ansible – reviewing the code and deploying our infrastructure</li>
			</ul>
			<p>We will delve into the world of Microsoft Azure, beginning with an introduction to the platform, its key features, and the benefits it offers for cloud-based application deployment. We will also explore the different services available within Azure and how they fit into our architectural design for our WordPress workload.</p>
			<p>Following this, we will build on our Terraform knowledge and work through the code needed to provision and manage our Azure cloud infrastructure. Lastly, we will explore Ansible, another essential tool for automating infrastructure deployment and configuration management.</p>
			<p>By the end of this chapter, you will have gained an understanding of Microsoft Azure and its various components and be equipped with the skills necessary to deploy and manage your applications on this cloud platform using Terraform and Ansible.</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor158"/>Technical requirement</h1>
			<p>Due to the amount of code needed to deploy our project, when it comes to the Terraform and Ansible sections of the chapter, we will not cover every piece of code needed to deploy the project. The code repository accompanying this title will contain the complete executable code.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor159"/>Introducing and preparing our cloud environment</h1>
			<p>In 2008, Microsoft unveiled Windows Azure, a cloud-based data center service that had been<a id="_idIndexMarker123"/> in development under<a id="_idIndexMarker124"/> the internal project name <em class="italic">Project Red Dog</em>. This service included five core components:</p>
			<ul>
				<li><strong class="bold">Microsoft SQL Data Services</strong>, a cloud version of the SQL database, which<a id="_idIndexMarker125"/> aimed to simplify hosting</li>
				<li><strong class="bold">Microsoft .NET Services</strong>, a <strong class="bold">Platform as a Service</strong> (<strong class="bold">PaaS</strong>), allowed developers<a id="_idIndexMarker126"/> to deploy their .NET-based<a id="_idIndexMarker127"/> applications in a Microsoft-managed runtime</li>
				<li><strong class="bold">Microsoft SharePoint and Dynamics</strong>, <strong class="bold">Software as a Service</strong> (<strong class="bold">SaaS</strong>) versions of the company’s intranet<a id="_idIndexMarker128"/> and customer relationship<a id="_idIndexMarker129"/> management products</li>
				<li><strong class="bold">Windows Azure</strong> is an <strong class="bold">Infrastructure-as-a-Service</strong> (<strong class="bold">IaaS</strong>) offering that enables users<a id="_idIndexMarker130"/> to create virtual <a id="_idIndexMarker131"/>machines, storage, and networking services for their compute workloads</li>
			</ul>
			<p>All the services provided by Microsoft as part of Windows Azure were built upon the Red Dog operating system, a specialized version of their Windows NT operating system, which had been specifically designed to include a cloud layer to support the delivery of data center services.</p>
			<p>In 2014, the company decided to rebrand the service as Microsoft Azure; as they added services, it made sense for them to drop the Windows branding, especially as there was a growing number of Linux-based workloads being hosted on the platform. This trend continued over the following years, and by 2020, it was reported that more than half of Azure’s virtual machine cores and a significant proportion of Azure Marketplace images were Linux-based, demonstrating Microsoft’s increasing embrace of Linux and open source technologies as the building blocks for some of their now core services.</p>
			<p>Now that we have some background knowledge<a id="_idIndexMarker132"/> of Microsoft Azure, let’s start preparing the cloud environment for deployment.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor160"/>Preparing our cloud environment for deployment</h2>
			<p>For the purposes of this chapter, we will run the Terraform<a id="_idIndexMarker133"/> and Ansible scripts locally on our own machine – this makes the deployment a little easier<a id="_idIndexMarker134"/> as we will be able to piggyback off a signed-in session using the Azure <strong class="bold">Command-Line Interface</strong> (<strong class="bold">CLI</strong>). For details on how to install this, please see the official documentation at <a href="https://learn.microsoft.com/en-us/cli/azure/install-azure-cli">https://learn.microsoft.com/en-us/cli/azure/install-azure-cli</a>.</p>
			<p>Once installed, make sure you are signed into the account where you would like the resources to be deployed; you can do this by running the following command:</p>
			<pre class="console">
$ az login</pre>
			<p>Then, follow the on-screen prompts; if you are already logged in, then you can double-check the details of your current login by running this command:</p>
			<pre class="console">
$ az account show</pre>
			<p>Now that we have our environment prepared, we can now look at the services we are going to be deploying.</p>
			<h1 id="_idParaDest-65"><a id="_idTextAnchor161"/>Producing the low-level design</h1>
			<p>Based on the deployment<a id="_idIndexMarker135"/> we discussed in <a href="B19537_03.xhtml#_idTextAnchor130"><em class="italic">Chapter 3</em></a>, <em class="italic">Planning the Deployment</em>, we know we are going to need the following resources to run our workload on Microsoft Azure:</p>
			<div><div><img src="img/Figure_4.01_B19537.jpg" alt="Figure 4.1 – An overview of the resources we are going to launch in Azure" width="1545" height="1302"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – An overview of the resources we are going to launch in Azure</p>
			<p>We will use the following services:</p>
			<ul>
				<li><strong class="bold">Azure Load Balancer</strong>: This is a TCP load balancer as a service – while I would<a id="_idIndexMarker136"/> have preferred to use <strong class="bold">Azure Application Gateway</strong> to terminate our HTTP/HTTPS connections, that would have added<a id="_idIndexMarker137"/> a little too much complexity to our build for this stage of the book.</li>
				<li><strong class="bold">Virtual Network</strong>: The core networking service our services<a id="_idIndexMarker138"/> will be both deployed into or configured to be accessible from.</li>
				<li><strong class="bold">Virtual machine</strong>: We will use a single <strong class="bold">Linux virtual machine</strong> as our WordPress<a id="_idIndexMarker139"/> admin instance – this will be<a id="_idIndexMarker140"/> responsible for the initial bootstrapping of the application.</li>
				<li><strong class="bold">Virtual Machine Scale Set</strong>: This is similar to the Linux virtual machine, but this service is designed to manage<a id="_idIndexMarker141"/> one to many virtual machines from a single resource, allowing us to scale out if needed.</li>
				<li><strong class="bold">Azure Storage A<a id="_idTextAnchor162"/>ccount/Azure Files</strong>: Our WordPress files will be stored in an NFS share, which<a id="_idIndexMarker142"/> is only accessible to trusted IP addresses within our Virtual Network where our virtual machine and Virtual Machine Scale Set instances are running.</li>
				<li><strong class="bold">Azure Database for MySQL - Flexible Server</strong>: Our WordPress installation needs a database<a id="_idIndexMarker143"/> server; as we are running in a public cloud, a <strong class="bold">Dat<a id="_idTextAnchor163"/>abase-as-a-Service</strong> (<strong class="bold">DBaaS</strong>) option makes sense. This service will make a MySQL server and database accessible<a id="_idIndexMarker144"/> within our Virtual Network.</li>
			</ul>
			<p>There are<a id="_idIndexMarker145"/> also other services such as <strong class="bold">Azure Private DNS</strong>, <strong class="bold">private endpoints</strong>, <strong class="bold">network security groups</strong>, and <strong class="bold">public IPs</strong> within the solution to support securely<a id="_idIndexMarker146"/> accessing the core<a id="_idIndexMarker147"/> services we will<a id="_idIndexMarker148"/> launch within the Virtual Network.</p>
			<p>Now that we know the services we are launching, we can dive into writing our code.</p>
			<h1 id="_idParaDest-66"><a id="_idTextAnchor164"/>Terraform – writing the code and deploying our infrastructure</h1>
			<p>Now that we know which services<a id="_idIndexMarker149"/> we are going to deploy, we can make<a id="_idIndexMarker150"/> a start on our Terraform deployment. To make things more manageable, I will split our code into several files; they will be named the following:</p>
			<ul>
				<li><code>001-setu<a id="_idTextAnchor165"/>p.tf</code></li>
				<li><code>002-resource-grou<a id="_idTextAnchor166"/>p.tf</code></li>
				<li><code>003-networking.tf</code></li>
				<li><code>004-storage.tf</code></li>
				<li><code>005-database.tf</code></li>
				<li><code>006-vm-admin.tf</code></li>
				<li><code>007-<a id="_idTextAnchor167"/>vmss-web.tf</code></li>
				<li><code>098-outputs.tf</code></li>
				<li><code>099-variables.tf</code></li>
				<li><code>vm-cloud-init-admin.yml.tftpl</code></li>
				<li><code>vmss-cloud-init-web.tftpl</code></li>
			</ul>
			<p>I have done this to more logically group all the functions around a certain p<a id="_idTextAnchor168"/>art of the deployment code together; for example, all of the networking<a id="_idIndexMarker151"/> elements can be found in the <code>003-networking.tf</code> file an<a id="_idTextAnchor169"/>d the variables<a id="_idIndexMarker152"/> used in the <code>099-variables.tf</code> file.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">As mentioned at the start of this chapter, what follows is not 100% of the code contained within each of the files, and I will be referencing blocks out of the <code>variables</code> file in line with blocks from other files.</p>
			<p>Without further delay, let’s look at the Terraform code, starting with the setup tasks.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor170"/>Setting up the Terraform environment</h2>
			<p>One of the first things<a id="_idIndexMarker153"/> we need to do is set up our Terraform environment for our deployment. To do this, we need to confirm which version of Terraform to use and which providers to download:</p>
			<pre class="source-code">
terraform {
  required_version = "&gt;=1.0"
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~&gt;3.0"
    }
    azurecaf = {
      source = "aztfmod/azurecaf"
    }
    random = {
      source = "hashicorp/random"
    }
    http = {
      source = "hashicorp/http"
    }
  }
}</pre>
			<p>Now, we need to add a configuration<a id="_idIndexMarker154"/> block for one of the providers:</p>
			<pre class="source-code">
provider "azurerm" {
  features {}
}</pre>
			<p>While we are not putting any custom configuration in there, it must be present to progress with the deployment.</p>
			<p>Finally, we come to the first task, which uses a module from the <strong class="bold">Terraform Registry</strong> to come up with all the Microsoft-defined<a id="_idIndexMarker155"/> variations of a region name, fu<a id="_idTextAnchor171"/>ll name, short name, and so on.</p>
			<p>To call the module and pass it is the region variable, use the following code:</p>
			<pre class="source-code">
module "azure_region" {
  source       = "claranet/re<a id="_idTextAnchor172"/>gions/azurerm"
  azure_region = var.location
}</pre>
			<p>The <code>var.location</code> variable we use is defined in the <code>099-variables.tf</code> file as follows:</p>
			<pre class="source-code">
variable "location" {
  description = "Which region in Azure are we launching <a id="_idTextAnchor173"/>the resources"
  default     = "West Europe"
}</pre>
			<p>As you can see, we are setting <code>default</code> as <code>West Europe</code>; don’t worry, if you don’t want to launch your resources in that region, we will cover overriding the variables when executing<a id="_idIndexMarker156"/> the deployment in <a href="B19537_06.xhtml#_idTextAnchor350"><em class="italic">Chapter 6</em></a>, <em class="italic">Building upon </em><em class="italic">the Foundations</em>.</p>
			<p>And that covers the <code>001-setup.tf</code> file, now that we have all the basics in place, we can move on to creating the <strong class="bold">resource group</strong>.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor174"/>Creating a resource group</h2>
			<p>As mentioned in earlier<a id="_idIndexMarker157"/> chapters, my day job sees me doing a lot of work in Microsoft<a id="_idIndexMarker158"/> Azure, and one of the things I adhere to is the <strong class="bold">Cloud Adoption Framework</strong>. This is a sensible documented set of recommendations around deploying resources into Microsoft Azure, which includes a naming scheme. Accordingly, one of the providers we are using helps dynamically create Azure resource names based on the information we pass it; we will use this throughout the deployment, as one of the provider’s goals is to introduce naming consistency for nearly all of the resources we are going to deploy. The code to generate the name of the resource group looks like the following:</p>
			<pre class="source-code">
resource "azurecaf_name" "resource_gro<a id="_idTextAnchor175"/>up" {
  name          = var.name
  resource_type = "azurerm_resource_group"
  suff<a id="_idTextAnchor176"/>ixes      = [var.environment_type, module.azure_region.location_short]
  clean_input   = true
}</pre>
			<p>As you can see, we are passing several bits<a id="_idIndexMarker159"/> of information – three variables and dynamically generated bits of information, namely the following two variables:</p>
			<pre class="source-code">
variable "name" {
  description = "Base name for resources"
  default     = "iac-wordpress"
}
variable "environment_type" {
  description = "type of the environment we are building"
  default     = "prod"
}</pre>
			<p>And also, we are using the output Azure Region module, which will provide a short name of whichever region we define in our <code>variables</code> file at <code>099-variables.tf</code>. This is referenced as follows:</p>
			<pre class="source-code">
module.azure_region.location_short</pre>
			<p>The other important information we are passing is <code>resource_type</code>, which in our case, is <code>azurerm_resource_group</code>. This will give us an output that looks like the following figure, which we can then pas<a id="_idTextAnchor177"/><a id="_idTextAnchor178"/><a id="_idTextAnchor179"/><a id="_idTextAnchor180"/>s on to our next resource block:</p>
			<div><div><img src="img/Figure_4.02_B19537.jpg" alt="Figure 4.2 – Naming our resource group" width="851" height="238"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Naming our resource group</p>
			<p>Now that we have the resource<a id="_idIndexMarker160"/> name, we can go ahead<a id="_idIndexMarker161"/> and define the resource group block:</p>
			<pre class="source-code">
resource "azurerm_resource_gr<a id="_idTextAnchor181"/>oup" "resource_group" {
  name     = azurecaf_nam<a id="_idTextAnchor182"/>e.resource_group.result
  location = module.azure_region.location_cli
  tags     = var.default_tags
}</pre>
			<p>As you can see, we reference <code>azurecaf_name.resource_group.result</code> as the name of the resource, and we also use another variation of the region name by using <code>module.azure_region.location_cli</code>, which will output the name as <code>westeurope</code> rather than <code>West Europe</code> or <code>euw</code>.</p>
			<p>The final variable we pass in is for <code>map</code> rather than <code>string</code>. This looks like the following:</p>
			<pre class="source-code">
variable "default_tags" {
  description = "The default tags to use across all of our resources"
  typ<a id="_idTextAnchor183"/>e        = map(any)
  default = {
<a id="_idTextAnchor184"/>    project     = "iac-wo<a id="_idTextAnchor185"/>rdpress"
    environment = "prod"
    deployed_by = "terraform"
  }
}</pre>
			<p>This is used throughout the deployment and will add three different tags, <code>project</code>, <code>environment</code>, and <code>deployed_by</code>, to each of the resources that use them. This is the simplest form of map we will use and is simply a list of keys and values.</p>
			<p>Things will get a little more complicated<a id="_idIndexMarker163"/> with maps as we move on to the next section, which is <em class="italic">Networking</em>, as we start to use maps to introduce a little logic into our deployment.</p>
			<h2 id="_idParaDest-69"><a id="_idTextAnchor186"/>Networking</h2>
			<p>As well as naming all of the resources using the <code>azurecaf_name</code> provider, we are going to configure and launch the following resources in this section:</p>
			<ul>
				<li><strong class="bold">Azure Virtual Network</strong>, where we will configure the primary network resource, along with three<a id="_idIndexMarker164"/> subnets – which is where things start to get complicated with the maps</li>
				<li><strong class="bold">Azure Load Balancer</strong>, as well as the resource itself, we will configure<a id="_idIndexMarker165"/> a public IP address, backend pool, health probe, and two types of rules – load balancing and NAT; there will be more on this later in the section</li>
				<li><strong class="bold">The network security group</strong>, with two rules to allow secure access<a id="_idIndexMarker166"/> to our services</li>
			</ul>
			<p>Let’s dive int<a id="_idTextAnchor187"/>o something more exciting and look at the Azure Virtual Network.</p>
			<h3>The Azure Virtual Network</h3>
			<p>The first part of configuring our underlying<a id="_idIndexMarker167"/> network is the Virtual Network resource itself. To do this, there are two main variables we are going to use; the first is straightforward:</p>
			<pre class="source-code">
variable "vnet_address_space" {
  description = "The address space of vnet"
  type        = list(any)
  default     = ["10.0.0.0/24"]
}</pre>
			<p>As can see, this defines the address<a id="_idIndexMarker168"/> space we are going to use for the Virtual Network as a list containing a single value; this is then called in the following block:</p>
			<pre class="source-code">
resource "azurerm_virtua<a id="_idTextAnchor188"/>l_network" "vnet" {
  resource_group_name = azurerm_resource_group.<a id="_idTextAnchor189"/>resource_group.name
  location            = azurerm_resource_group.resource_group.location
  name                = azurecaf_name.vnet.result
  address_space       = var.vnet_address_space
  tags                = var.default_tags
}</pre>
			<p>Nothing too out of the ordinary on the face of it. To ensure that the Virtual Network is created after the resource group has been created, by passing in the dynamically generated name, the default tags, and the list of address spaces, which in our case only contains a single item, we use the following references:</p>
			<ul>
				<li><code>azurerm_resource_group.resource_group.name</code></li>
				<li><code>azurerm_resource_group.resource_group.location</code></li>
			</ul>
			<p>The second variable is where we define the subnet and is also where things get interesting:</p>
			<pre class="source-code">
variable "vnet_subnets" {
  description = "The subnets to deploy in the vnet"
  type = map(object({
    subnet_name = string
    address_prefix = string
    private_endpoint_network_policies_enabled = bool
    service_endpoints = list(string)
    service_delegations  = map(map(list(string)))
  }))</pre>
			<p>The preceding code defines<a id="_idIndexMarker169"/> what variables are needed for each of the subnets, while the following code sets the default settings that we will use in our deployment, starting with the subnet for the virtual machines:</p>
			<pre class="source-code">
  default = {
    virtual_network_subnets_001 = {
      subnet_name = "vms"
      address_prefix = "10.0.0.0/27"
      private_endpoint_network_policies_enabled = true
      service_endpoints  = ["Microsoft.Storage"]
      service_delegations = {}
    },</pre>
			<p>The second subnet will be used for the private endpoints we will deploy:</p>
			<pre class="source-code">
    virtual_network_subnets_002 = {
      subnet_name  = "endpoints"
      address_prefix = "10.0.0.32/27"
      private_endpoint_network_policies_enabled = true
      service_endpoints = ["Microsoft.Storage"]
      service_delegations = {}
    },</pre>
			<p>The third and final subnet we are going to need is the one used for the <code>database</code> service:</p>
			<pre class="source-code">
    virtual_network_subnets_003 = {
      subnet_name = "database"
      address_prefix = "10.0.0.64/27"
      private_endpoint_network_policies_enabled = true
      service_endpoints = ["Microsoft.Storage"]
      service_delegations = {
        fs = {
          "Microsoft.DBforMySQL/flexibleServers" = ["Microsoft.Network/virtualNetworks/subnets/join/action"]
        }
      }
    },
  }
}</pre>
			<p>As you can see, a lot is happening here, so let’s break it down a little.</p>
			<p>What we are defining<a id="_idIndexMarker170"/> here is a map that contains several objects; those objects are strings, a Boolean, a list, and finally, a map made up of a map, which contains a list of strings!</p>
			<p>Let’s start simple and look at how w<a id="_idTextAnchor190"/>e will name the subnets. To do this, we use a <code>for_each</code> loop:</p>
			<pre class="source-code">
resource "azurecaf_name" "virtual_network_subnets" {
  for_each      = var.vnet_subnets
  name          = each.value.subnet_name
  resource_type = "azurerm_subnet"
  suffixes      = [var.name, var.environment_type, module.azure_region.location_short]
  clean_input   = true
}</pre>
			<p>This takes the <code>subnet_name</code> value from each of our three maps and creates three resource names; the following names<a id="_idIndexMarker171"/> will be generated:</p>
			<ul>
				<li><code>snet-endpoints-iac-word<a id="_idTextAnchor191"/>press-prod-euw</code></li>
				<li><code>snet-vms-iac-wordpress-prod-euw</code></li>
				<li><code>snet-database-iac-wordpress-prod-euw</code></li>
			</ul>
			<p>We will take a similar approach by using a <code>for_each</code> loop to create the subnets, but this time more of the information in the map object. The code block to create the subnets looks like the following<a id="_idTextAnchor192"/>:</p>
			<pre class="source-code">
resource "azurerm_subnet" "vnet_subnets" {
  for_each             = var.vnet_subnets
  name                 = azurecaf_name.virtual_network_subnets[each.key].result
  resource_group_name  = azurerm_resource_group.resource_group.name
  virtual_network_name = azurerm_virtual_network.vnet.name
  address_prefixes     = [each.value.address_prefix]
  service_endpoints = try(each.value.service_endpoints, [])
  private_endpoint_network_policies_enabled = try(each.value.private_endpoint_network_policies_enabled, [])
  dynamic "delegation" {
    for_each = each.value.service_delegations
    content {
      name = delegation.key
      dynamic "service_delegation" {
        for_each = delegation.value
        iterator = item
        content {
          name = item.key
          actions = item.value
        }
      }
    }
  }
}</pre>
			<p>As already mentioned, we use the <code>for_eac<a id="_idTextAnchor193"/>h</code> argument to iterate<a id="_idIndexMarker172"/> over the elements in the <code>vnet_subnets</code> map. We<a id="_idTextAnchor194"/> set the <code>name</code> property using the results of the <code>azurecaf_name</code> loop; each of the three names is referenced using the key, which in the map would be as follows:</p>
			<ul>
				<li><code>virtual_<a id="_idTextAnchor195"/>network_subnets_001</code></li>
				<li><code>virtual_network_subnets_002</code></li>
				<li><code>virtual_network_subnets_003</code></li>
			</ul>
			<p>Although, in this instance, we do not hav<a id="_idTextAnchor196"/>e to hardcode each of these values so we can use <code>azurecaf_name.virtual_network_subnets[each.key].result</code>. The <code>resource_group_name</code> property is set using the output of <code>azurerm_resource_group</code>. The <code>address_prefixes</code> property is set to a list containing the <code>address_prefix</code> value for the current subnet’s <code>vnet_subnets</code> key.</p>
			<p>The <code>service_endpoints</code> property is set to the corresponding value for the current subnet if it is provided. If the value is not provided, an empty list is used instead.</p>
			<p>Similarly, the <code>private_endpoint_network_policies_enabled</code> property is set to the corresponding value for the current subnet if it is provided. If the value is not provided, an empty list is used instead. Finally, the code includes a nested loop over the <code>service_delegations</code> property of the current subnet.</p>
			<p>A <strong class="bold">dynamic block</strong> is a setting block that is evaluated at runtime, allowing<a id="_idIndexMarker173"/> you to add blocks based on the values of input variables and also outputs from other tasks within the Terraform code. Dynamic blocks are helpful when you need to create a variable number of blocks based on data that is known only at runtime.</p>
			<p>The dynamic block<a id="_idIndexMarker174"/> creates a <code>delegation</code> block for each element in the <code>service_delegations</code> map. The <code>iterator</code> argument is set to <code>item</code>, representing the current element being processed, and the <code>content</code> block creates a <code>service_delegation</code> block with the key as the name and the value as the actions.</p>
			<p>To give you an idea of what this looks like, if we were to manually define the <code>virtual_network_subnets_002</code> and <code>virtual_network_subnets_003</code> map objects, they would look like the following:</p>
			<pre class="source-code">
resource "azurerm_subnet" "virtual_network_subnets_002" {
  name                 = "snet-endpoints-iac-wordpress-prod-euw"
  resource_group_name  = "rg-iac-wordpress-prod-euw"
  virtual_network_name = "vnet-iac-wordpress-prod-euw"
  address_prefixes     = ["10.0.0.32/27"]
  service_endpoints    = ["Microsoft.Storage"]
  private_endpoint_network_policies_enabled = true
}
resource "azurerm_subnet" "virtual_network_subnets_003" {
  name                 = "snet-database-iac-wordpress-prod-euw"
  resource_group_name  = "rg-iac-wordpress-prod-euw"
  virtual_network_name = "vnet-iac-wordpress-prod-euw"
  address_prefixes     = ["10.0.0.64/27"]
  service_endpoints    = ["Microsoft.Storage"]
  private_endpoint_network_policies_enabled = true
  delegation {
      name = "fs"
      service_delegation {
          name = "Microsoft.DBforMySQL/flexibleServers"
          actions = ["Microsoft.Network/virtualNetworks/subnets/join/action"]
      }
   }
}</pre>
			<p>As you can see, while it looks complicated, it is an excellent<a id="_idIndexMarker175"/> way of writing less code with hardcoded values, which makes the block easily reusable.</p>
			<p>We will reference the output of the <code>for_each</code> loops when we add our network security group, and also when we start to attach resources to our subnets when we launch resources and place them in the subnets we have just defined.</p>
			<p>The next lot of blocks launch and configure the Azure Load Balancer service; there is not much going on here that we haven’t already covered, but here is a quick o<a id="_idTextAnchor197"/>verview of eac<a id="_idTextAnchor198"/>h of the blocks:</p>
			<ul>
				<li><code>"azurerm_public_ip" "load_balancer"</code> creates a public IP address</li>
				<li><code>"azurerm_lb" "load_balancer"</code> launches the load balancer itself and attaches the public IP address we just launched</li>
				<li><code>"azurerm_lb_backend_address_pool" "load_balancer"</code>, creates a backend pool; when we launch our virtual machine and Virtual Machine Scale Set instances, we will attach them to this backend pool</li>
				<li><code>"azurerm_lb_probe" "http_load_balancer_probe"</code> adds a health probe to check that port <code>80</code> is open and accessible via a simple TCP test</li>
				<li><code>"azurerm_lb_rule" "http_load_balancer_rule"</code> creates a rule to evenly distribute incoming requests on port <code>80</code>, i.e., HTTP requests, across the instances in the backend pool if they are showing as healthy</li>
				<li><code>"azurerm_lb_nat_rule" "sshAccess"</code> creates a rule that dynamically maps <code>2222</code> &gt; <code>2232</code> to port <code>22</code> on the backend instances, giving us SSH to each of the instances in the backend pool</li>
			</ul>
			<p>The final few tasks<a id="_idIndexMarker176"/> t<a id="_idTextAnchor199"/>o do with the network are to create and configure a network security group; there is not much going on with the first few tasks:</p>
			<ul>
				<li><code>"azurerm_network_security_group" "nsg"</code> creates the network security group</li>
				<li><code>"azurerm_network_security_rule" "AllowHTTP"</code> adds a rule to the network security group we just created to allow HTTP access on port <code>80</code>; this will be open to everyone</li>
			</ul>
			<p>Next, we need to add a rule to allow SSH access to our hosts, but SSH is not a service that you would want to expose to the whole of the internet – even if we are going to access the instances using a non-standard port (remember we are using a NAT rule on Azure Load Balancer to map ports <code>2222</code> &gt; <code>2232</code> to port <code>22</code> on the instances). So, we are going to use a data source to get the public IP address of the host that is currently running Terraform.</p>
			<p>The block to get the current IP address uses the HTTP Terraform provider and looks like<a id="_idTextAnchor200"/> the following:</p>
			<pre class="source-code">
data "http" "current_ip" {
  url = "https://api.ipify.org?format=json"
}</pre>
			<p>As you can see, we are calling the <a href="https://api.ipify.org/?format=json">https://api.ipify.org/?format=json</a> URL, which returns a blob of JSON containing your current public IP address.</p>
			<p>We can then take this blob and combine this with the <code>network_trusted_ips</code> variable, which is empty by default, contain<a id="_idTextAnchor201"/>ing a list of other trusted IP addresses:</p>
			<pre class="source-code">
variable "network_trusted_ips" {
  description = "Optional list if IP addresses which need access, your current IP will be added automatically"
  type        = list(any)
  default = [
  ]
}</pre>
			<p>Now that we have the JSON containing<a id="_idIndexMarker177"/> our IP address and an optional list of other IP addresses we want to allow, we can create the rule itself:</p>
			<pre class="source-code">
resource "azurerm_network_security_rule" "AllowSSH" {
  name        = "AllowSSH"
  description = "Allow SSH"
  priority    = 150
  direction   = "Inbo<a id="_idTextAnchor202"/>und"
  access      = "Allow"
  protocol    = "Tcp"
  source_address_prefixes     = setunion(var.network_trusted_ips, ["${jsondecode(data.http.current_ip.response_body).ip}"])
  source_port_range           = "*"
  destination_port_range      = "22"
  destination_address_prefix  = "*"
  resource_group_name         = azurerm_resource_group.resource_group.name
  network_security_group_name = azurerm_network_security_group.nsg.name
}</pre>
			<p>As you can see, everything is happening in the <code>source_address_prefixes</code> entry; here, we use the built-in <code>setunion</code> function, which merges the content of <code>var.network_trusted_ips</code> – in our case, an empty list – and the JSON returned in the <a id="_idTextAnchor203"/>body of the request we made using the HTTP provider.</p>
			<p>I have updated the relevant code s<a id="_idTextAnchor204"/>lig<a id="_idTextAnchor205"/>htly to make it a little <a id="_idTextAnchor206"/>easier<a id="_idTextAnchor207"/> to read:</p>
			<pre class="source-code">
s<a id="_idTextAnchor208"/>etunion(
  var.network_trusted_ips,
 ["${jsondecode(data.http.current_ip.response_body).ip}"]
)</pre>
			<p>We are using <code>var.network_trusted_ips</code> as it is because that is already defined as a list; however, our IP address isn’t, so we create a list using <code>[ ]</code> and then add an inline variable in Terraform; this is defined using <code>${ something here }</code>. <code>something here</code>, in our case, uses the built-in <code>jsondecode</code> function, which takes the body of the response that is held in <code>data.http.current_ip.response_body</code> and the value of the <code>ip</code> key, which is our public IP address.</p>
			<p>Now that we have our network security<a id="_idIndexMarker178"/> group, we need to attach it to the subnet, which will host the virtual machine and Virtual Machine Scale Set instances. To do this, we need the ID of the subnet. To make this simple, I have created three variables with the name of the objects of each of the subnet maps:</p>
			<pre class="source-code">
variable "subnet_for_vms" {
  description = "Reference to put the virtual machines in"
  default     = "virtual_network_subnets_001"
}
variable "subnet_for_endpoints" {
  description = "Reference to put the private endpoints in"
  default     = "virtual_network_subnets_002"
}
variable "subnet_for_database" {
  description = "Reference to put the database in"
  default     = "virtual_network_subnets_003"
}</pre>
			<p>Now that we know the name<a id="_idIndexMarker179"/> of the object, which is the key name, we can use this in the block that associates the network security group with the subnet hosting the instances:</p>
			<pre class="source-code">
resource "azurerm_subnet_network_security_group_association" "nsg_association" {
  subnet_id = azurerm_subnet.vnet_subnets["${var.subnet_for_vms}"].id
  network_security_group_id = azurerm_network_security_group.nsg.id
}</pre>
			<p>That concludes the network portion of the deployment, and we now have the underlying<a id="_idTextAnchor209"/> base to start deploying resources into, starting with storage.</p>
			<h3>Storage</h3>
			<p>We need to create a storage account<a id="_idIndexMarker180"/> with NFS enabled; most of these tasks are pretty straightforward:</p>
			<ul>
				<li><code>"azurecaf_name" "sa"</code> generates the name of the storage account; there is a slight difference in that we are telling it to add a random string – we are doing this because storage account names must be unique across Azure, so if we didn’t add this, the code might error depending on who else has already executed it</li>
				<li><code>"azurecaf_name" "sa_endpoint"</code> takes the previous result and then generates a name for the private endpoint, which will be placed in the Virtual Network</li>
				<li><code>"azurerm_storage_account" "sa"</code> creates the storage account itself</li>
			</ul>
			<p>We now need to lock the storage account down so that only the three subnets in our Virtual Network and our trusted IP addresses have <a id="_idTextAnchor210"/>access – to<a id="_idTextAnchor211"/> do this, <a id="_idTextAnchor212"/>we use a block that looks like the following:</p>
			<pre class="source-code">
resource "azurerm_storage_account_network_rules" "sa" {
  storage_account_id = azurerm_storage_account.sa.id
  default_action     = var.sa_network_default_action
  ip_rules           = setunion(var.network_trusted_ips, ["${jsondecode(data.http.current_ip.response_body).ip}"])
  bypass             = var.sa_<a id="_idTextAnchor213"/>network_bypas<a id="_idTextAnchor214"/>s
  virtual_network_subnet_ids = [
    for subnet_id in azurerm_subnet.vnet_subnets :
    subnet_id.id
  ]
}</pre>
			<p>As you can see, the IP rules use the same logic we employed when adding our public IP address to the network security group rule to allow us access to the instances using SSH access from a trusted IP address.</p>
			<p>The part of the block to get the subnet IDs uses a <code>for</code> loop to iterate over the <code>azurerm_subnet.vnet_subnets</code> list, and for each subnet in the list, it extracts the <code>id</code> attribute of the subnet and adds it to the list of <code>virtual_network_subnet_ids</code>.</p>
			<p>Once we have the network rules<a id="_idIndexMarker181"/> in place for the storage account, we can add the NFS share itself:</p>
			<pre class="source-code">
resource "azurerm_storage_share" "nfs_share" {
  name                 = replace(var.name, "-", "")
  storage_account_name = azurerm_storage_account.sa.name
  quota                = var.nfs_share_q<a id="_idTextAnchor215"/>uota
  enabled_protocol     = var.nfs_enbled_protocol
  depends_on = [
    azurerm_storage_a<a id="_idTextAnchor216"/><a id="_idTextAnchor217"/>ccount_network_rules.sa
  ]
}</pre>
			<p>As you can see, we are use <code>depends_on</code> to ensure that the network<a id="_idIndexMarker182"/> rules are configured. We must declare <code>depends_on</code> as there is no output we can reference from <code>"azurerm_storage_account_network_rules" "sa"</code> when executing <code>"</code><code>azurerm_storage_share" "nfs_share"</code>.</p>
			<p class="callout-heading">Hint</p>
			<p class="callout">We will use small number of <code>depends_on</code> in the deployment. However, it is considered a best practice to keep its usage to a minimum and let Terraform figure out the dependencies as much as possible, as overuse of <code>depends_on</code> can slow down execution.</p>
			<p>The keen-eyed among you may have also noticed that we are doing something different when naming this resource; we use the built-in <code>replace</code> function, taking the contents of the <code>var.name</code> variable and stripping out any hyphens.</p>
			<p>The remaining tasks are all pretty basic:</p>
			<ul>
				<li><code>"azurerm_private_dns_zone" "storage_share_private_zone"</code> creates a private DNS zone for <code>privatelink.file.core.windows.net</code></li>
				<li><code>"azurerm_private_dns_zone_virtual_network_link" "storage_share_private_zone"</code> takes the private DNS zone we created and attaches it to our Virtual Network</li>
				<li><code>"azurerm_private_endpoint" "storage_share_endpoint"</code> creates the private endpoint, putting in the subnet defined in the <code>var.subnet_for_endpoints</code> variable and registering it with the private DNS zone</li>
			</ul>
			<p>That concludes the storage; next up, we have the database service.</p>
			<h3>Database</h3>
			<p>We are now starting<a id="_idIndexMarker183"/> to get into the st<a id="_idTextAnchor218"/>ride of things as we come to launch our<a id="_idTextAnchor219"/> database service:</p>
			<ul>
				<li><code>"az<a id="_idTextAnchor220"/>urec<a id="_idTextAnchor221"/>af_name" "mysql_flexible_server"</code> generates the name of the Azure MySQL Flexible Server</li>
				<li><code>"azurecaf_name" "database"</code> generates the name of the database we will use for WordPress</li>
				<li><code>"azurerm_private_dns_zone" "mysql_flexible_server"</code> adds the private DNS zone we will use for our Azure MySQL Flexible Server</li>
				<li><code>"azurerm_private_dns_zone_virtual_network_link" "mysql_flexible_server"</code> registers the private DNS with our Virtual Network</li>
			</ul>
			<p>Before we launch the <strong class="bold">Azure MySQL Flexible Server</strong>, there is one more thing we need to do, and that is to create<a id="_idIndexMarker184"/> a password. Rather than passing this using a variable, we can use the random provider to generate one based on the parameters we provide programmatica<a id="_idTextAnchor222"/>lly.</p>
			<p>The following block will generate a random password 16 characters long and not use any special characters:</p>
			<pre class="source-code">
resource "random_password" "database_admin_password" {
  length  = 16
  special = false
}</pre>
			<p>There isn’t too much out of the ordinary with the remaining blocks we use to launch and configure our Azure MySQL Flexible Server instance; what follows is a brief summary of what each of the blocks does:</p>
			<ul>
				<li><code>"azurerm_mysql_flexible_server" "mysql_flexible_server"</code> launches the flexible server; we use <code>depends_on</code> here to ensure that the DNS zone is registered with the Virtual Network; otherwise, we could get an error when it came to creating the resource</li>
				<li><code>"azurerm_mysql_flexible_s<a id="_idTextAnchor223"/>erver_configuration" "require_secure_transport"</code> changes the Azure MySQL Flexible Server parameter to allow non-TLS connections</li>
				<li><code>"azurerm_mysql_flexible_database" "wordpress_database"</code> creates a database hosted on the Azure MySQL Flexible Server; once the parameter has been updat<a id="_idTextAnchor224"/>ed, we use <code>depends_on</code> to achieve this</li>
			</ul>
			<p>Now that we have our Azure MySQL Flexible Server<a id="_idIndexMarker185"/> instance configured and connected to the Virtual Network, we are ready to launch our admin virtual machine instance.</p>
			<h3>The admin virtual machine</h3>
			<p>The admin virtual machine<a id="_idIndexMarker186"/> is going to be a single Linux virtual machine instance, which will be used to bootstrap our WordPress installation. Firstly, there are no new techniques used here, so rather than go into detail, here is an overview of what each of the blocks does:</p>
			<ul>
				<li><code>"azurecaf_name" "admin_vm"</code> generates the name of the virtual machine</li>
				<li><code>"azurecaf_name" "admin_vm_nic"</code> generates the name of the network interface</li>
				<li><code>"azurerm_network_interface" "admin_vm"</code> creates the network interface resource, attaching it to the subnet defined in the <code>var.subnet_for_vms</code> variable</li>
				<li><code>"random_password" "wordpress_admin_password"</code> generates a random password for the WordPress admin area – this time, using special characters apart from <code>_%@</code></li>
				<li><code>"random_password" "vm_admin_password"</code> generates the password for the virtual machine instances; this time, it’s a little more complicated as virtual machines have password strength requirements, so we are going to generate a 16-character password with a minimum of two uppercase and two lowercase letters, two special characters, excluding <code>!@#$%&amp;</code>, and also numbers</li>
			</ul>
			<p>The next task, <code>"azurerm_linux_virtual_machine" "admin_vm"</code>, launches the virtual machine<a id="_idIndexMarker187"/> itself, and for the most part, there isn’t much interesting going on with it apart from the section where we pass in <code>user_data</code>, which is where the <code>cloud-init</code> script is generated and passed over to Azure to inject when the virtual machine is launched. This part of the block looks like the following:</p>
			<pre class="source-code">
  user_data = base64encode(templatefile("vm-cloud-init-admin.yml.tftpl", {
    tmpl_database_username = "${var.database_administrator_login}"
    tmpl_database_password = "${random_password.database_admin_password.result}"
    tmpl_database_hostname = "${azurecaf_name.mysql_flexible_server.result}.${replace(var.name, "-", "")}.mysql.database.azure.com"
    tmpl_database_name     = "${azurerm_mysql_flexible_database.wordpress_database.name}"
    tmpl_file_share        = "${azurerm_storage_account.sa.name}.file.core.windows.net:/${azurerm_storage_account.sa.name}/${azurerm_storage_share.nfs_share.name}"
    tmpl_wordpress_url     = "http://${azurerm_public_ip.load_balancer.ip_address}"
    tmpl_wp_title          = "${var.wp_title}"
    tmpl_wp_admin_user     = "${var.wp_admin_user}"
    tmpl_wp_admin_password = "${random_password.wordpress_admin_password.result}"
    tmpl_wp_admin_email    = "${var.wp_admin_email}"
  }))
}</pre>
			<p>Let us dig into what is going on here a lit<a id="_idTextAnchor225"/>tle bit more. First off, we need to pass the <code>cloud-init</code> script as Base64-encoded; luckily, Terraform has the <code>base64encode</code> function we can use to do this.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Base64 is a way to encode<a id="_idIndexMarker188"/> data into a continuous string of ASCII text; it helps post-multi-line scripts or binary data to APIs. It is not a secure way to encode data since it can be easily decoded and does not provide any form of encryption. If we were to encode <code>Hello, world!</code>, it would be encoded as <code>SGVsbG8sIHdvcmxkIQ==</code> in Base64. <code>==</code> at the end is added to pad the string and make it a multiple of four characters since Base64 encoding works with blocks of four characters.</p>
			<p>The next part uses Terraform’s native <code>templatefile</code> function to read a file, which in our case, is called <code>vm-cloud-init-admin.yml.tftpl</code>. Once that has been defined, we pass a list of variables<a id="_idIndexMarker189"/> to use within the template and their values – here we are passing in details of the following:</p>
			<ul>
				<li>The Azure MySQL Flexible Server</li>
				<li>The Azure Files hosted NFS share</li>
				<li>The URL, which is made up of the public IP address of Azure Load Balancer</li>
				<li>Our WordPress installation information, which we have defined as variables in our main <code>variables</code> file</li>
			</ul>
			<p>To save confusion, I am prefixing each of the variables we are passing into the template file with <code>tmpl</code>; this is not a requirement, but I find it helpful to distinguish between variables I can use in the main Terraform blocks and ones used within the templates.</p>
			<p>An abridged version of the <code>cloud-init</code> template file is given in the following code block; it contains the bits that mount the NFS share:</p>
			<pre class="source-code">
#cloud-config
package_update: true
package_upgrade: true
packages:
  - nfs-common
runcmd:
  - sudo mount -t nfs ${tmpl_fil<a id="_idTextAnchor226"/>e_share} /var/www/html -o vers=4,minorversion=1,sec=sys
  - echo "${tmpl_file_share} /var/www/html nfs vers=4,minorversion=1,sec=sys" | sudo tee --append /etc/fstab</pre>
			<p>As you can see, the syntax<a id="_idIndexMarker190"/> for referencing the variables is slightly different from the main Terrafo<a id="_idTextAnchor227"/>rm blocks, as we do not have to reference them as a variable with <code>${var.something}</code> and instead can just use <code>${something}</code>.</p>
			<p>The fully rendered file is then passed to the virtual machine, and the script executes once the virtual machine boots. The full <code>cloud-init</code> file performs the following tasks:</p>
			<ul>
				<li>Updates all installed packages</li>
				<li>Installs the packages we need to run WordPress – for example, Apache2, PHP, and the NFS and MySQL client software</li>
				<li>Mounts the NFS share and adds a line to <code>/etc/fstab</code> so it mounts automatically after the instance reboots</li>
				<li>Installs the WordPress command-line client</li>
				<li>Sets up the correct permissions on the folders where we will be installing WordPress</li>
				<li>Downloads the latest version of WordPress</li>
				<li>Creates a <code>wp-config.php</code> file populated with the details of our Azure MySQL Flexible Server</li>
				<li>Installs WordPress itself using the variables we passed in</li>
				<li>Tweaks the Apache configuration and restarts the service</li>
			</ul>
			<p>Once these steps<a id="_idIndexMarker191"/> have been completed, we should have a working WordPress installation.</p>
			<h3>A Web Virtual Machine Scale Set</h3>
			<p>Now that we have our admin virtual machine<a id="_idIndexMarker192"/> instance bootstrapped, we can launch a Virtual Machine Scale Set to act as web servers. As we already have a WordPress installation running and all the files needed to serve the website on the NFS share, these instances only need to have the basic software stack configured.</p>
			<p>Also, as most of the heavy lifting has already been co<a id="_idTextAnchor228"/>mpleted, this should be straightforward:</p>
			<ul>
				<li><code>"azurecaf_name" "web_vmss"</code> generates the name of the Virtual Machine Scale Set.</li>
				<li><code>"azurecaf_name" "web_vmss_nic"</code> generates the name of the network interface used by the virtual machine scale set.</li>
				<li><code>"azurerm_linux_virtual_machine_scale_set" "web"</code> creates the virtual machine scale set itself; this is in line with the admin virtual machine we launched, and we are reusing many of the same variables, with the notable addition of <code>var.number_of_web_servers</code>, which defines the number of server instances to launch. We are also using a cutdown version of the <code>cloud-init</code> script called <code>vmss-cloud-init-web.tftpl</code>.</li>
			</ul>
			<p>That concludes launching and configuring our Azure resource; there is just a small number of blocks left before we are finished.</p>
			<h3>Output</h3>
			<p>The final file outputs some helpful information<a id="_idIndexMarker193"/> about our deployment. As some of the output includes information, for example, the results of <code>random_password</code>, we will need to mark that part of the output as <code>sensitive</code>, as we don’t want our randomly generated password to be visible when logging our output, which is being printed to the screen, for example:</p>
			<pre class="source-code">
output "wp_password" {
  value     = "Wordpress Admin Password: ${random_password.wordpress_admin_password.result}"
  sensitive = true
}
output "wp_url" {
  value     = "Wordpress URL: http://${azurerm_public_ip.load_balancer.ip_address}/"
  sensitive = false
}</pre>
			<p>Now that we have an understanding of what the Terraform code is going to do, we can now run it.</p>
			<h3>Deploying the environment</h3>
			<p>To d<a id="_idTextAnchor229"/>eploy the environment, we simply<a id="_idIndexMarker194"/> need to run the following commands:</p>
			<pre class="console">
$ terraform init
$ terraform plan</pre>
			<p>When you run the <code>terraform plan</code> command, it will give you an overview of what resources are going to be deployed, as well as some very basic error-checking to make sure that everything is in order.</p>
			<p>If you have the output of the plan, then you can proceed wi<a id="_idTextAnchor230"/>th the deployment by running the following command:</p>
			<pre class="console">
$ terraform apply</pre>
			<p>Up<a id="_idTextAnchor231"/>on completion, you should see something like the following screen:</p>
			<div><div><img src="img/Figure_4.03_B19537.jpg" alt="Figure 4.3 – The finished Azure deployment" width="1650" height="746"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – The finished Azure deployment</p>
			<p>As you can see, the two password<a id="_idIndexMarker195"/> outputs have been marked as <code>sensitive</code>, but we have the URL of the WordPress installation. Now, let’s dive straight into the WordPress admin portal, open the URL you have been given in your browser, and append <code>wp-admin</code> at the end of the URL. For example, for me, the URL was <code>http://20.23.249.255/wp-admin</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All URLs and passwords used in this chapter have long since been terminated and are not valid; please use the details from your own deployment<a id="_idTextAnchor232"/>.</p>
			<p>This should give you a login page that looks like the following:</p>
			<div><div><img src="img/Figure_4.04_B19537.jpg" alt="Figure 4.4 – The WordPress login screen" width="1650" height="970"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – The WordPress login screen</p>
			<p>We know that the username<a id="_idIndexMarker196"/> for WordPress is <code>admin</code>, as we have that set as a variable, but how about that password? Well, by default, Terraform will always display <code>sensitive</code> when you run the <code>terraform output</code> command; however, appending <code>-json</code> at the end of that will give you the full output.</p>
			<p>You can see the output <a id="_idTextAnchor233"/>of me running <code>terraform output -json</code> in the following screenshot:</p>
			<div><div><img src="img/Figure_4.05_B19537.jpg" alt="Figure 4.5 – Accessing the passwords" width="1650" height="746"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Accessing the passwords</p>
			<p>Upon entering the usernam<a id="_idTextAnchor234"/>e<a id="_idIndexMarker197"/> and password, you should be greeted by the WordPress dashboard:</p>
			<div><div><img src="img/Figure_4.06_B19537.jpg" alt="Figure 4.6 – The WordPress dashboard" width="1650" height="970"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – The WordPress dashboard</p>
			<p>You can also go to the Azure portal and check the resources there; you should be able to find them in the <code>rg-iac-wordpress-prod-euw</code> resource group (assuming that you have kept the variables at their defaults and have not updated them; if you have, then you will need to find the group that matches your updates).</p>
			<p>Once you have finished, please don’t forget to run the following command:</p>
			<pre class="console">
$ terraform destroy</pre>
			<p>Otherwise, you will incur costs<a id="_idIndexMarker198"/> for running resources if you have followed along and launched the environment in your own account.</p>
			<h1 id="_idParaDest-70"><a id="_idTextAnchor235"/>Ansible – reviewing the code and deploying our infrastructure</h1>
			<p>While we have covered Terraform<a id="_idIndexMarker199"/> in detail in this chapter, we will only quickly<a id="_idIndexMarker200"/> review the Ansible code here as we wil<a id="_idTextAnchor236"/>l go into a lot more detail on an Ansible deployment in the next chapter, <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon </em><em class="italic">Web Services</em>.</p>
			<p>Like Terraform, the Ansible code is split into roles; this makes our <code>site.yml</code> file look like the following:</p>
			<pre class="source-code">
- name: Deploy and configure the Azure Environment
  hosts:<a id="_idTextAnchor237"/> localhost
  connection: local
  gather_facts: true<a id="_idTextAnchor238"/>
  vars_files:
    - group_vars/azure.yml
    - group_vars/common.yml
  roles:
    - roles/create-randoms
    - roles/azure-rg
    - roles/azure-virtualnetwork
    - roles/azure-storage
    - roles/azure-mysql
    - roles/azure-vm-admin
    - roles/azure-vmss-web
    - roles/output</pre>
			<p>Here, we load two variable files from the <code>group_vars</code> folder and calling eight different roles. As we have<a id="_idIndexMarker201"/> already discussed, Ansible will execute its tasks in the order<a id="_idIndexMarker202"/> we call them, so the ordering of the roles is essential.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor239"/>Ansible Playbook roles overview</h2>
			<p>Let’s dive straight<a id="_idIndexMarker203"/> in and look at the first role that is called in the <code>site.yml</code> file. The <strong class="bold">randoms</strong> role has a single function: randomly<a id="_idIndexMarker204"/> generating all the variables we will need for the deployment. However, this is where we hit our first significant difference between Ansible and Terraform. As Ansible is stateless, once it has generated a random value and the Ansible execution has stopped, it will instantly forget about it. This means that when we next execute our playbook, it will regenerate the random values, which, as we are using them in resource definitions, could cause a new resource to be launched.</p>
			<p>What we need to do is create a file that contains all the random values, but if there is already a file there, then continue without updating them <a id="_idTextAnchor240"/>– the process we need to follow is visualized in the following workflow:</p>
			<div><div><img src="img/Figure_4.07_B19537.jpg" alt="Figure 4.7 – Do we need to create a secrets.yml variable file?" width="864" height="580"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Do we need to create a secrets.yml variable file?</p>
			<p>So, what does this look<a id="_idIndexMarker205"/> like as Ansible tasks?</p>
			<pre class="source-code">
- na<a id="_idTextAnchor241"/>me: Check i<a id="_idTextAnchor242"/>f the file secrets.yml ex<a id="_idTextAnchor243"/>ists
  ansible.builtin.stat:
    path: "group_vars/secrets.yml"
  register: secrets_file</pre>
			<p>As you can see, we use the built-<a id="_idTextAnchor244"/>in <code>stat</code> module to check for the presence of a file in the <code>group_vars</code> called <a id="_idTextAnchor245"/><code>secrets.yml</code>. We then register the results of this task as a variable called<a id="_idTextAnchor246"/> <code>secrets_file</code>.</p>
			<p>The contents of the <code>secrets_file</code> variable we registered when the <code>secrets.yml</code> file doesn’t exist on your filesystem, which it should do, as we are going to create the file shortly, look like the following:</p>
			<pre class="console">
TASK [roles/create-randoms : print the secrets_file variable] **************************************
ok: [localhost] =&gt; {
    "msg": {
      <a id="_idTextAnchor247"/>  "changed": false,
        "failed": false,
        "stat": {
            "exist<a id="_idTextAnchor248"/>s": false
        }
    }
}</pre>
			<p>As you can see, there is a single outpu<a id="_idTextAnchor249"/>t called <code>exists</code>, which is set to <code>false</code>.</p>
			<p>So, our next task<a id="_idIndexMarker206"/> will generate the <code>secrets.yml</code> file if <code>exists</code> is set to <code>false</code> and looks like the following:<a id="_idTextAnchor250"/></p>
			<pre class="source-code">
- name: Generate the secrets.yml file using a template file if<a id="_idTextAnchor251"/> not exists
  ansible.builtin.te<a id="_idTextAnchor252"/>mplate:
    src: "secrets.yml.j2"
    dest: "group_vars/secrets.yml"
  when: secrets_file.stat.exists == false</pre>
			<p>As you can see from the last line, the task will only run when <code>secrets_file.stat.exists</code> is equal to <code>false</code>; if it returns <code>true</code>, then the task will be skipped, as we do not need to generate the <code>secrets.yml</code> file again.</p>
			<p>The task itself uses the <code>template</code> function to take the source template, which looks like the following, process it, and then output the rendered output to <code>group_vars/secrets.yml</code>:</p>
			<pre class="source-code">
short_random_hash: "{{ lookup('community.general.random_string', length=5, upper=false, special=false, numbers=false) }}"
db_password: "{{ lookup('community.general.random_string', length=20, upper=true, special=true, override_special="@-&amp;*", min_special=2, numbers=true) }}"
vm_password: "{{ lookup('community.general.random_string', length=20, upper=true, special=true, override_special="@-&amp;*",<a id="_idTextAnchor253"/> min_special=2, numbers=true) }}"
wp_password: "{{ lookup('community.general.random_string', length=20, upper=true, special=true, override_special="@-&amp;*", min_special=2, numbers=true) }}"</pre>
			<p>The template uses the <code>lookup</code> function to call the <code>random_string</code> module to generate a short random hash for resource names and various passwords.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">While this method works for our deployment, you should look at something more secure for a production environment – for example, dynamically loading the secret values from a remote key management store.</p>
			<p>Now that we know the file is there, as we have just generated it, we can load the contents of the file in as variables:</p>
			<pre class="source-code">
- name: Load the variables defined in the secrets.yml file
  ansible.builtin.include_vars:
    file: "group_vars/secrets.yml"</pre>
			<p>Now that our variables<a id="_idIndexMarker207"/> are loaded, we can progress with the rest of the playbook run.</p>
			<h3>The resource group role</h3>
			<p>The <code>azurecaf_name</code> provider we used in Terraform. Because of this, we have defined all the resource names in the <code>group_var/azure.yml</code> file using various variables and hardcoded values.</p>
			<h3>The Virtual Network role</h3>
			<p>There are several tasks<a id="_idIndexMarker210"/> in this role, a lot of which<a id="_idIndexMarker211"/> use some concepts we have yet to cover but will go into more detail in <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon </em><em class="italic">Web<a id="_idTextAnchor254"/> Services</em>:</p>
			<ul>
				<li><code>azure.azcollection.azure_rm_virtualnetwork</code> creates the Virtual Network</li>
				<li><code>azure.azcollection.azure_rm_subnet</code> loops through and creates the subnets that don’t have <code>database</code> in the name</li>
				<li><code>azure.azcollection.azure_rm_subnet</code> loops through and creates the subnets that have <code>database</code> in the name</li>
				<li><code>community.general.ipify_facts</code> gets the current IP address</li>
				<li><code>ansible.builtin.set_fact</code> takes the preceding output and registers it as a fact</li>
				<li><code>ansible.builtin.tempfile</code> cr<a id="_idTextAnchor255"/>eates an empty temporary file</li>
				<li><code>ansible.builtin.template</code> dynamically generates the network security group tasks from a template file</li>
				<li><code>ansible.builtin.include_tasks</code> loads and executes the network security group tasks we just generated</li>
				<li><code>azure.azcollection.azure_rm_publicipaddress</code> creates a public IP address for use with the load balancer</li>
				<li><code>azure.azcollection.azure_rm_loadbalancer</code> creates a load balancer</li>
			</ul>
			<p>Now that we have<a id="_idIndexMarker212"/> all the underlying<a id="_idIndexMarker213"/> networking, we can launch the rest of the resources.</p>
			<h3>Storage roles</h3>
			<p>The tasks executed<a id="_idIndexMarker214"/> by this role<a id="_idIndexMarker215"/> are as follows:</p>
			<ul>
				<li><code>azure.azcollection.azure_rm_resourcegroup_info</code> gets information on the resource group we have created</li>
				<li><code>ansible.builtin.set_fact</code> uses some regular expressions to extract the subscription ID from the resource group ID and set a fact</li>
				<li><code>ansible.builtin.tempfile</code> generates a temporary file, which will be used for the variables for the storage account rules</li>
				<li><code>ansible.builtin.template</code> dynamically generates the variables containing the storage account network rules</li>
				<li><code>ansible.builtin.include_vars</code> loads the variables we <a id="_idTextAnchor256"/>just generated</li>
				<li><code>azure.azcollection.azure_rm_storageaccount</code> creates the storage account</li>
				<li><code>azure.azcollection.azure_rm_resource</code> creates the NFS share</li>
				<li><code>azure.azcollection.azure_rm_privatednszone</code> creates a private DNS zone</li>
				<li><code>azure.azcollection.azure_rm_privatednszonelink</code> links the private DNS zone to our Virtual Network</li>
				<li><code>azure.azcollection.azure_rm_subnet_info</code> gets information on the endpoint subnet</li>
				<li><code>azure.azcollection.azure_rm_storageaccount_info</code> gets info on the storage account we just created</li>
				<li><code>azure.azcollection.azure_rm_privateendpoint</code> creates a private endpoint using all of the information we have just gathered</li>
				<li><code>azure.azcollection.azure_rm_privateendpointdnszonegroup</code> attaches the private endpoint to the private DNS zone</li>
			</ul>
			<p>While that all seems<a id="_idIndexMarker216"/> straightforward, the keen-eyed among<a id="_idIndexMarker217"/> you may have noticed something which appears a l<a id="_idTextAnchor257"/>ittle out of place.</p>
			<p>When it came to creating the NFS share, the task we use<a id="_idTextAnchor258"/>d was called <code>azure.azcollection.azure_rm_resource</code>, even though there is a module called <code>azure.azcollection.azure_rm_storageshare</code>; what gives?</p>
			<p>At the time of writing, the <code>azure.azcollection.azure_rm_storageshare</code> module does not support the creation of NFS file shares on an Azure Storage account. So instead, we dynamically generate a payload<a id="_idIndexMarker218"/> and send it to the Azure Resource Manager REST API to create the<a id="_idTextAnchor259"/> resource. We will look<a id="_idIndexMarker219"/> at this in a little more detail in the next role.</p>
			<h3>The MySQL role</h3>
			<p>Azure Flexible Server for MySQL<a id="_idIndexMarker220"/> is another Azure service that doesn’t have a native Ansible module, so we are<a id="_idIndexMarker221"/> going to have to use the REST API to not only create the server but also set the <code>require_secure_transport</code> parameter and create our WordPress database.</p>
			<p>Before doing any of that, though, we need to create the DNS resources and gather a few bits of information on the networking resources we have already launched; the following tasks do so:</p>
			<ul>
				<li><code>azure.azcollection.azure_rm_privatednszone</code> creates the private DNS zone for the database</li>
				<li><code>azure.azcollection.azure_rm_privatednszonelink</code> attaches the DNS zone we just created to the Virtual Network</li>
				<li><code>azure.azcollection.azure_rm_privatednszone_info</code> gets information on the private DNS we just created</li>
				<li><code>azure.azcollection.azure_rm_subnet_info</code> gets information on the subnet we have created purely for use with the Azure Flexible Server for MySQL</li>
			</ul>
			<p>We now have all the resources and information we need to create the Azure Flexible Server for MySQL. The task for doing this looks like the following:</p>
			<pre class="source-code">
- name: Create an Azure Flexible Server for MySQL using the REST API
  azure.azcollection.azure_rm_resource:
    api_version: "2021-05-01"
    resource_group: "{{ resource_group_name }}"
    provider: "DBforMySQL"
    resource_type: "flexibleServers"
    resource_name: "{{ database_server_name }}"
    body:
      location: "{{ location }}"
      properties:
        administratorLogin: "{{ database_config.admin_username }}"
        administratorLoginPassword: "{{ db_password }}"
        Sku:
          name: "{{ database_config.sku.name }}"
          tier: "{{ database_config.sku.tier }}"
        Network:
          delegatedSubnetResourceId: "{{ database_subnet_output.subnets[0].id }}"
          privateDnsZoneResourceId: "{{ database_private_dns_zone_output.privatednszones[0].id<a id="_idTextAnchor260"/> }}"
        tags: "{{ common_tags }}"</pre>
			<p>The first part<a id="_idIndexMarker222"/> of the task, from <code>api_version</code> down to <code>body</code>, is used to construct the URL that we will call. The keys<a id="_idIndexMarker223"/> listed under <code>body</code> are the parameters and options that will be posted to the API endpoint URL, which we have dynamically created. The URL we will be posting to looks something like <code>https://management.azure.com/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DBforMySQL/flexibleServers/{serverName}?api-version=2021-05-01</code>.</p>
			<p>Simple enough, you may think, but there is quite a large piece of logic that Ansible would typically take care of, which we now have to consider for ourselves.</p>
			<p>As Ansible is just posting<a id="_idIndexMarker224"/> to the REST API, assuming the request is valid, it will get a <code>200</code> response<a id="_idIndexMarker225"/> back to say that the request was successful; it doesn’t wait until the resource has been launched before <code>200</code> is returned, meaning that Ansible will happily move on to the next task, which will fail in our deployment because we are immediately making changes to the resource, which will have a state of <code>Creating</code>. To get around, this we have the following task:</p>
			<pre class="source-code">
- name: Wait for Azure Flexible Server for MySQL to be ready
  azure.azcollection.azure_rm_resource_info:
    api_version: "2021-05-01"
    resource_group: "{{ resource_group_name }}"
    provider: "DBforMySQL"
    resource_type: "flexibleServers"
    resource_name: "{{ database_server_name }}"
  register: database_wait_output
  delay: 15
  retries: 50
  until: database_wait_output.response[0] is defined and database_wait_out<a id="_idTextAnchor261"/>put.response[0].properties is defined and database_wait_output.response[0].properties.state == "Ready"</pre>
			<p>This task will poll the REST API for information on our server every 15 seconds a maximum of 50 times until the REST API reports that the server <code>state</code> is <code>Ready</code>, and then it moves on to the next task:</p>
			<ul>
				<li><code>azure.azcollection.azure_rm_resource</code> – now the server is ready, we can update the <code>require_secure_transport</code> parameter</li>
				<li><code>azure.azcollection.azure_rm_resource</code> – finally, we can create the WordPress database</li>
			</ul>
			<p>Now that we<a id="_idIndexMarker226"/> have launched<a id="_idIndexMarker227"/> and conf<a id="_idTextAnchor262"/>igured the database resources, we can launch some virtual machines – starting with the admin one.</p>
			<h3>The Admin Virtual Machine role</h3>
			<p>Compared to the Azure Flexible Server<a id="_idIndexMarker228"/> for MySQL role, this is quite<a id="_idIndexMarker229"/> straightforward and uses all Ansible-native Azure modules:</p>
			<ul>
				<li><code>azure.azcollection.azure_rm_networkinterface</code> creates the network interface for use with the Virtual Machine</li>
				<li><code>azure.azcollection.azure_rm_publicipaddress_info</code> gets information on the pu<a id="_idTextAnchor263"/>blic IP address attached to the load balancer we launched – we need this for the <code>cloud-init</code> script</li>
				<li><code>ansible.builtin.tempfile</code> creates a temporary file, which will store the <code>cloud-init</code> script</li>
				<li><code>ansible.builtin.template</code> generates the <code>cloud-init</code> script for the admin server; like our Terraform deployment, this will install the packages and bootstrap WordPress</li>
				<li><code>azure.azcollection.azure_rm_virtualmachine</code> launches the virtual machine using the resources created and configured previously</li>
			</ul>
			<p>Now that we have our admin virtual machine, let’s look at the web servers.</p>
			<h3>The Web Virtual Machine Scale Set role</h3>
			<p>This role<a id="_idIndexMarker230"/> contains<a id="_idIndexMarker231"/> three tasks:</p>
			<ul>
				<li><code>ansible.builtin.tempfile</code> creates a temporary file, which will store the <code>cloud-init</code> script</li>
				<li><code>ansible.builtin.template</code> generates the <code>cloud-init</code> script for the admin server, like our Terraform deployment; this will install the packages and not touch WordPress as it’s already installed on our admin virtual machine</li>
				<li><code>azure.azcollection.azure_rm_virtualmachinescaleset</code> creates<a id="_idIndexMarker232"/> the virtual machine<a id="_idIndexMarker233"/> scale set</li>
			</ul>
			<h3>The output role</h3>
			<p>This role simply outputs<a id="_idIndexMarker234"/> the details we need<a id="_idIndexMarker235"/> to access our WordPress installation; unlike Terraform, this information is visible when it runs.</p>
			<p>This simple role, which just displays some text when running our playbook, is the final role, and we are now ready to run our playbook.</p>
			<h2 id="_idParaDest-72">Running th<a id="_idTextAnchor264"/>e Ansible Playbook</h2>
			<p>Now that we know what everything<a id="_idIndexMarker236"/> does, you can run the Ansible Playbook by running the following command:</p>
			<pre class="console">
$ ansible-playbook site.yml</pre>
			<p>Once finished, you should see something like the following output:</p>
			<div><div><img src="img/Figure_4.08_B19537.jpg" alt="Figure 4.8 – The completed playbook run" width="1651" height="1062"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – The completed playbook run</p>
			<p>Once you have looke<a id="_idTextAnchor265"/>d at WordPress and the Azure resource, you can run the following command to remove the resource group and everything contained within it:</p>
			<pre class="console">
$ ansible-playbook destroy.yml</pre>
			<p>Remember to make sure that all of the resources have been removed by checking to see whether they are still listed<a id="_idIndexMarker237"/> in the Azure portal, as you could incur unexpected costs if the playbook failed for any reason.</p>
			<h1 id="_idParaDest-73"><a id="_idTextAnchor266"/>Summary</h1>
			<p>In this chapter, we did a deep dive into using Terraform to deploy our WordPress environment in Microsoft Azure. We discussed the Terraform providers and worked through the Terraform code before finally executing it.</p>
			<p>Also, as part of this walkthrough, we discussed some of the considerations you need to make when looping through resources, when it’s appropriate to use <code>depends_on</code>, and how we can use templates to generate content.</p>
			<p>Next up, we walked through the Ansible code, which deploys the same set of resources. This time, rather than a deep dive, we only went into detail on the Azure-specific details, as we will take a closer look at Ansible in <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon </em><em class="italic">Web Services</em>.</p>
			<p>Everything we covered so far should hopefully start to get you thinking about how you can apply some of the subjects we have covered to your own Infrastructure-as-Code deployments and you should already be starting to get a feel for which of the two tools you prefer.</p>
			<p>In the next chapter, we will look at deploying our WordPress installation to Amazon Web Services, as well as doing a deeper dive into Ansible.</p>
			<h1 id="_idParaDest-74"><a id="_idTextAnchor267"/>Further reading</h1>
			<p>You can find more d<a href="https://azure.microsoft.com/">etails on the services and d</a>ocumentation we have mentioned in this chapter at the following URLs:</p>
			<ul>
				<li>Microsoft Azure: <a href="https://azure.microsoft.com/">https://azure.microsoft.com/</a></li>
				<li>The Azure REST documentation: <a href="https://learn.microsoft.com/en-us/rest/api/azure/">https://learn.microsoft.com/en-us/rest/api/azure/</a></li>
			</ul>
			<p>Terraform providers and modules:</p>
			<ul>
				<li>azurerm: <a href="https://registry.terraform.io/providers/hashicorp/azurerm/latest">https://registry.terraform.io/providers/hashicorp/azurerm/latest</a></li>
				<li>azurecaf: <a href="https://registry.terraform.io/providers/aztfmod/azurecaf/latest">https://registry.terraform.io/providers/aztfmod/azurecaf/latest</a></li>
				<li>random: <a href="https://registry.terraform.io/providers/hashicorp/random/latest">https://registry.terraform.io/providers/hashicorp/random/latest</a></li>
				<li>HTTP: <a href="https://registry.terraform.io/providers/hashicorp/http/latest">https://registry.terraform.io/providers/hashicorp/http/latest</a></li>
				<li>The Claranet Azure Region module: <a href="https://registry.terraform.io/modules/claranet/regions/azurerm/latest">https://registry.terraform.io/modules/claranet/regions/azurerm/latest</a></li>
			</ul>
			<p>A reference for Ansible collections is as follows:</p>
			<ul>
				<li>The Azure collection: <a href="https://galaxy.ansible.com/azure/azcollection">https://galaxy.ansible.com/azure/azcollection</a></li>
			</ul>
		</div>
	</div>
</div>
</body></html>