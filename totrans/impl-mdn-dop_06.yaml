- en: Server Provisioning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned how to create the infrastructure that is
    going to hold our applications. As we saw, the infrastructure automation is something
    that's new, and we used Terraform for it. The problem with Terraform is that it
    can only be used to build the infrastructure, but in order to provision the software,
    we need something different.
  prefs: []
  type: TYPE_NORMAL
- en: Through this chapter, we are going to dive deep into Ansible as, together with
    Puppet and Chef, it is the most predominant server provisioning tool in the market
    right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the main topics that will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Server provisioning software
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chef
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Puppet
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible configuration
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible variables
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote facts
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Flow control
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible roles
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Ansible tower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see, it is quite an extensive chapter with many examples that will
    enable you to learn the most important features of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that you need to be aware while reading through this chapter is the
    fact that it is impossible to showcase all the features from Ansible in a single
    chapter. In fairness, it would take us over a book to master all the features
    up to a proficient level. As you can guess by now, when I need to deal with Ansible,
    the first thing I do is open the official documentation and have it side by side
    with the code so that I can always refer to it for examples and features that
    I have either never dealt with or it has been a long time since I did not work
    with it.
  prefs: []
  type: TYPE_NORMAL
- en: We will also explore a section Ansible Tower, which is a software used to run
    Ansible playbooks on a bastion host mode from within your infrastructure instead
    of running it from a workstation.
  prefs: []
  type: TYPE_NORMAL
- en: Server provision software
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, there are few options for software provisioning. Through
    this chapter, you will learn how to use Chef and Ansible, focusing on the latter
    as it is widely used across many companies and is easier to master than Chef.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other options in the market that are valid and good solutions,
    but we are going to take a special interest in Ansible, which, to me, seems the
    easiest to learn and extend out of all of them.
  prefs: []
  type: TYPE_NORMAL
- en: Chef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Chef is a very interesting software that follows the bastion host principle
    to run configurations on our servers. A bastion host is a server placed in our
    private network that is able to reach our servers directly or via proxy in order
    to execute the actions needed to set them up with the desired state. This is an
    option not to be overlooked, as one of the biggest challenges that server provisioning
    presents is the management of secrets and authorization that, for example, Ansible
    needs to improve via third-party software such as Ansible Tower from Red Hat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Chef uses recipes to configure parts of the server. A recipe is basically a
    set of declarative instructions that define what needs to happen in order to get
    the server to the desired status. For example, take a look at this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will upgrade our system and then install the Apache2 web
    server.
  prefs: []
  type: TYPE_NORMAL
- en: 'This recipe, once finished, gets uploaded into the Chef server from a workstation,
    and here is the key: in Chef, there are three actors:'
  prefs: []
  type: TYPE_NORMAL
- en: Server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nodes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The server is where the recipes and configuration live. It needs to be installed
    prior to doing any work, and the instructions can be found at [https://docs.chef.io/install_server.html](https://docs.chef.io/install_server.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three modalities of the Chef server:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Enterprise:** This can be installed inside your infrastructure and it is
    licensed, so you need to pay depending on the numbers of nodes that it is managing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open source:** This can also be installed in your infrastructure but **it
    does not have any support**. It is free and has to be configured and maintained
    by your company. It is also a cut-down version of the Enterprise Chef.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hosted:** The Chef server is hosted on third-party hardware and you don''t
    need to worry about maintaining and upgrading it. It might not be an option depending
    on the setup of your company.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The nodes are the target hosts. Every node is registered in the Chef server
    and has a run list: a list of recipes that are going to be run on a host when
    the `chef-client` command is executed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The workstation is the computer used to configure and upload the Chef server.
    This computer uses a software called knife that can do everything on the Chef
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking for VMs depending on the roles and other parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring run lists
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knife uses cryptographic keys to communicate with the Chef server so all the
    communication happens in a trusted way.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we want to picture everything, it looks like that is shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82bdd4ea-1c7d-4309-b637-22350469cded.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, even though the setup is quite complex (you need to set up
    a couple of software components) there are obvious benefits: our Chef server is
    behind the firewall in the demilitarized zone of our infrastructure, but it is
    managed via a CLI tool so all our secrets and configuration are safe inside our
    infrastructure.'
  prefs: []
  type: TYPE_NORMAL
- en: Chef has a steep learning curve that, once we have gone through the initial
    learning phase, gets very familiar and easy to add new features and extend the
    DSL with the power of Ruby and a very well-thought-out interface.
  prefs: []
  type: TYPE_NORMAL
- en: Puppet
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Puppet has been around for a while and is widely used in the DevOps world.
    Puppet comes in two flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: Open source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enterprise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The open source version comes as is, offering a good set of features that allow
    you to fully automate the configuration management of your infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: The enterprise edition, aside from support, comes with an extended set of features
    that make the life of the engineers in your company a lot easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the same way as Chef, Puppet follows the bastion host architecture: the
    server is installed within your infrastructure in the demilitarized zone and the
    nodes (your servers), via the puppet agent, will execute the specified tasks to
    reach the desired status.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main difference between Chef and Puppet is the fact that puppet is declarative
    whereas Chef is more imperative:'
  prefs: []
  type: TYPE_NORMAL
- en: In Puppet, you specify which state you want your servers on and Puppet takes
    care of keeping them there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In Chef, you declare a number of steps that will get your server to the desired
    state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That said, Chef also allows you to declare guards, which are conditions for
    steps to be executed.
  prefs: []
  type: TYPE_NORMAL
- en: Through my experience, I've found that people coming from an DevOps background
    feel more comfortable with Puppet as it is similar to what they have done through
    the years, whereas writing Chef recipes is similar to software development.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is what we are going to be using to develop the contents of the rest
    of the book. In my opinion, it is the easiest to learn and extend. It is also
    easy to understand and offers a fairly comprehensive open source version that
    works with all the features from Ansible. You can also buy a license of Ansible
    Tower (or similar) to run Ansible Playbooks in a bastion host configuration as
    Chef or Puppet.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible is basically a **domain-specific language** (**DSL**) for executing
    operations on remote hosts that are defined in an inventory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible works by running playbooks in the desired servers via SSH, so unlike
    Chef or Puppet, we don''t need to install anything in the remote hosts; we should
    just be able to SSH into them. A playbook is basically a **Yet Another Markup
    Language** (**YAML**) with a set of instructions to get the server into the desired
    state in the same way as if we were executing a Bash script. A Playbook looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Reading through the file will make you understand how easy and straightforward
    it is to understand what the Playbook doing.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, in the second line, we are specifying that we want to run this
    Playbook in the hosts called `webservers`. This can be defined in the other part
    of Ansible: the inventory. The Ansible inventory is basically a file with the
    list of hosts in your infrastructure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This file is very straightforward but can get really complicated as well:'
  prefs: []
  type: TYPE_NORMAL
- en: The names between brackets are groups
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The groups contain hosts that can be defined with generators or they can just
    be listed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Groups can have configuration specific to them or even override variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the preceding example, we have two groups: `webservers` and `dbservers`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Web servers are only two hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Host1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Host2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dbservers use a generator and we have three hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`192.168.0.1`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.0.2`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`192.168.0.3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we can also define variables in the inventory. These
    variables can be scoped on the group and the host. Let''s take a look at the following
    inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`timezone`: This is applied to all the hosts of the group `dbservers`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`role`: This is applied to the host `host1` of the group `webservers`*.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This variable can be used in `playbooks` in order to have a specific configuration
    for specific hosts, as we will see later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Groups can also be combined into bigger groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding inventory, we can find the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`dbservers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mongoservers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`webservers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dataservers`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`all`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ungrouped`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Even though we did not specify it, Ansible always has two default groups called
    `all` and `ungrouped` that are self-descriptive: `all` is all the hosts in the
    inventory and `ungrouped` is all the hosts that are not specified in any group.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As stated earlier, Ansible does not follow the bastion host architecture as
    Chef or Puppet, but it follows the client/server architecture: our host needs
    to be able to reach the destination hosts (the ones on the inventory) in order
    to work.'
  prefs: []
  type: TYPE_NORMAL
- en: This can be inconvenient depending on your infrastructure architecture, but
    it can be worked around using Ansible Tower or Rundeck to execute Ansible playbooks
    from inside your demilitarized zone.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we are going to use Ansible to build real production-ready
    examples in combination with Terraform so that we get a grasp of the real usage
    of the tools.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to take our first steps toward a more comprehensive
    example in Ansible. For now, we are going to install and configure NGINX, a very
    popular web server so we can showcase the main concepts of Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we are going to create a VM in Google Cloud Platform with an associated
    static IP so we can target it from our inventory. We are going to use Terraform
    in order to do it. First, we''ll look at our resources file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, we''ll look at our vars file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we are reusing the project from the previous chapter as it is
    convenient to shut down everything once we are done. Now we run our plan so we
    can see what resources are going to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, everything looks right. We are creating two resources:'
  prefs: []
  type: TYPE_NORMAL
- en: The static IP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we can apply our infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'And everything works as expected. If we check Google Cloud Platform, we can
    see that our VM has been created and has associated a public IP:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/53521020-4335-4113-aae4-c560054b691c.png)'
  prefs: []
  type: TYPE_IMG
- en: In this case, the associated public IP is `35.187.81.127`. It is important to
    verify that we can reach the server via SSH. In order to do it, just click on
    the SSH button on the right-hand side of your instance row and it should open
    a Cloud Console window with terminal access.
  prefs: []
  type: TYPE_NORMAL
- en: If SSH access fails, you need to add an ingress allow rule in the firewall to
    the port `22`. For this example, just allow the traffic from any IP into any port,
    but don't do this in your real infrastructure as it is a security threat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once everything is up and running, it is time to start with Ansible. First,
    we are going to create our inventory file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very simple: a group with our public IP address that is connected to
    our VM. Save the file with the name `inventory` in a new folder named, for example,
    `ansible-nginx`. Once the inventory is created, we need to verify that all the
    hosts can be reached. Ansible provides you the tool to do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: If you execute the preceding command, Ansible will `ping` (actually, it does
    not use the ping command but tries to issue a connection to the server) all the
    hosts in your inventory specified in the parameter `-i`. If you change everything
    for the name of a group, Ansible will try to reach only the hosts in that group.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the output of the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We are experiencing problems in connecting to our remote host and the cause
    is that we don''t have any key that the host can validate to verify our identity.
    This is expected as we did not configure it, but now, we are going to solve it
    by creating a key pair and installing it on the remote host using the Google Cloud
    SDK:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will do three things:'
  prefs: []
  type: TYPE_NORMAL
- en: Generate a new key pair
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the key pair in our remote VM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Open a shell in our VM in GCP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The new key generated can be found under `~/.ssh/` with the name `google_compute_engine
    and google_compute_engine.pub` (private and public key).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the command finishes, our shell should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1dc53067-fb7b-4dc8-a40c-995e3a8d1bdd.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a terminal connected to our VM and we can execute commands. `gcloud`
    configures a user by default; in my case, `davidgonzalez` that can use `sudo`
    without password. In this case, we are going to execute the playbook as the root,
    so we need to be able to login as root into the VM. Copy the file `~/.ssh/authorized_keys`
    into `/root/.ssh/authorized_keys` and we should be able to do it. So, we have
    copied the public key that we generated earlier to the set of authorized keys
    of the root user.
  prefs: []
  type: TYPE_NORMAL
- en: In general, root access should be avoided as much as possible, but in this case,
    we will be executing the playbook as the root for convenience.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order for Ansible to be able to use the key, we need to add it to the daemon
    on our server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This command should output the success, stating that the identity was added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can run our pin command again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be very different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This means that now, Ansible is able to reach our server; therefore, it will
    be able to execute the playbook against it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to start writing our first `ansible` playbook. Inside the same
    folder, `ansible-nginx`, create a file called `tasks.yml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is simple to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: Our playbook is going to affect all the hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user running the playbook is going to be root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And then we are going to execute two tasks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the `apt cache`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade all the packages
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once we have the two files (inventory and playbook), we can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We should produce output similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8be2660-7d43-42ad-a448-bcad349dae1c.png)'
  prefs: []
  type: TYPE_IMG
- en: We are going to run few playbooks along the chapter, so I would recommend that
    you keep the same VM alive and run all of them against it in order to save time
    and resources. The trial account from Google Cloud Platform will give you enough
    room to run them across several days or weeks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain the output:'
  prefs: []
  type: TYPE_NORMAL
- en: First, it specifies against which group we are going to execute the playbook.
    In this case, we specified that the group is `all`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Then, we can see three tasks being executed. As you can see, the description
    matches the description specified in `tasks.yml`. This is very helpful in order
    to understand the output of your playbooks, especially when they fail.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And then we get a recap:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three tasks were executed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Two of them produced changes on the server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Zero failed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simple and effective. This is the closest to executing a script in the server
    that we can get: a set of instructions, a target host, and its output.'
  prefs: []
  type: TYPE_NORMAL
- en: In Ansible, instead of plain bash instructions, the actions are encapsulated
    into modules. A module is a component of the DSL, which allows you to do something
    special. In the playbook from earlier, apt is a module included in the core of
    Ansible. Documentation for it can be found at [http://docs.ansible.com/ansible/apt_module.html](http://docs.ansible.com/ansible/apt_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take another look to one of our usages of the `apt` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This, as you can guess, would be the equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'So, in this case, Ansible provide us with a different module called command,
    which allows us to execute commands in the hosts of our inventory. Take a look
    at the following `yaml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This is equivalent to the `yaml` from earlier, and both do the same: update
    `apt-cache`.'
  prefs: []
  type: TYPE_NORMAL
- en: In general, if there is a module for a given task, it is recommended that you
    use it as it will handle (or at least you can expect it to) the errors and the
    outputs better than executing the equivalent command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, once our playbook has succeeded, we can expect our system to be up to
    date. You can check it by running the playbook again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/277e8ee6-2d9a-46e6-9e09-adb4f360b02f.png)'
  prefs: []
  type: TYPE_IMG
- en: Now you can see that only one task has produced changes in the server (updating
    the apt sources).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features of Ansible is the ability to override the defaults per project.
    In order to do it that, we just need to create a file called `ansible.cfg` in
    the root of our project and Ansible will read it and apply the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: There is a big number of parameters that can be configured, and all of them
    can be found in the official documentation at [http://docs.ansible.com/ansible/intro_configuration.html](http://docs.ansible.com/ansible/intro_configuration.html).
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the documentation for Ansible is quite good, and the majority
    of the time, it will provide an answer to your problems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how the configuration can help us. If you remember from the previous
    example, we have specified the flag `-i` in order to tell Ansible where our inventory
    file lives. Ansible has a default for this value, which is `/etc/ansible/hosts`.
    In our little project, our inventory is in the same folder as our code, and in
    order to specify it to Ansible, we need to create a configuration file with the
    following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we run our `playbook` again with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We did not specify the host list, but Ansible, after reading `ansible.cfg` knows
    that the inventory file can be located at `./inventory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible has a hierarchy of precedence to find the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ANSIBLE_CONFIG` environment variable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible.cfg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`.ansible.cfg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/etc/ansible/ansible.cfg`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, if we define an environment variable called `ANSIBLE_CONFIG` pointing to
    a file, the Ansible configuration will be read from that location and the rest
    of the options will be ignored. This is particularly helpful in segregating environments:
    our CI server can define its own configuration in the environment file, whereas
    developers can have the `ansible.cfg` file checked in into the source control
    so that is shared across everyone.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few sections that can be specified in `ansible.cfg`. Sections control
    several aspects of of Ansible, such as connections. Under certain circumstances,
    we might need to add special parameters for `ssh` to work, and it is as easy as
    adding the following lines to your `ansible.cfg` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Ansible variables, remote facts and templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Variables and templates are an important part of Ansible. They allow us to override
    values in our configuration (servers and playbooks) so that we can write generic
    playbooks that can be reused across different configurations with minor tweaks.
    With templates, we can render configuration files from our host so we could potentially
    use Ansible to manage the configuration of remote servers with little to no effort.
    It also can be used to generate and install SSL certificates for different hosts
    transparently to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Both of them (variables and templates) use a template engine called Jinja2,
    which allows logic and interpolation to be embedded in our configurations.
  prefs: []
  type: TYPE_NORMAL
- en: In general, there are several ways of defining variables, but we are only going
    to visit the most common ones (under my criteria), as otherwise, it would take
    us the size of several chapters to document them properly. If you want to explore
    further different ways of defining variables, the official documentation provides
    a fairly comprehensive guide at [http://docs.ansible.com/ansible/playbooks_variables.html](http://docs.ansible.com/ansible/playbooks_variables.html).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variables are the most simple of the potential customizations. With variables,
    we can define values that are going to be replaced in our playbooks. Let''s take
    a look at the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Replace the content of `tasks.yml` with the snippet from earlier. There are
    two new symbols in our task. Also, our task is new: debug is used to output values
    from our variables into the terminal while executing the playbook. Let''s take
    a look at the execution (we will use the same configuration as the example from
    earlier):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fec26755-e784-48b5-8948-6cfbcb096ab7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The reason for the failure can be seen in in the message: we have a variable
    defined called `name` that does not have a value associated. Ansible will fail
    if there is a value that cannot be interpolated, aborting the execution of the
    task.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another interesting piece of information here: Ansible gives you a
    parameter to retry the playbook only on the hosts that were not successful. If
    we wanted to retry the playbook only on the failed hosts, we could run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The new parameter, `tasks.retry` is a file with a list of hosts that are okay
    to rerun the playlist as they failed before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our missing variables, we need to define the variable called
    `myName`. There are a few ways of doing that; the first is via the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And you can see that the output of the playbook is looking better now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0cfc28ac-bc49-4244-8166-417cdb1f7d49.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the variables got interpolated and we can see the message `Hello
    David! I am 35.187.81.127`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way of defining variables is via inventory, as we have seen earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'If we modify our inventory to match the preceding snippet, the value of our
    variable will be `DavidInventory` and we don''t need to pass a value in the command
    line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This will produce the message `Hello DavidInventory! I am 35.187.81.127`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third way to define variables in Ansible is by defining them in the playbook
    itself. Take a look at the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: As simple as it sounds, once you define the variable in the `vars` section of
    your playbook, it becomes available; therefore, there is no need to specify the
    value anywhere else.
  prefs: []
  type: TYPE_NORMAL
- en: The fourth way to define variables is via files. Ansible is designed to be a
    self-documented component that can be easily understood by someone with not much
    experience in it. One of the ways in which Ansible facilitates the task of understanding
    playbooks is the possibility of writing every single configuration piece in a
    file. Variables are not the exemption, so Ansible will let you define variables
    in files or playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the files. Create a file called `vars.yml` in the same folder
    in which you are working (where your playbook and inventory are) with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can run the following command in order to use the variables file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: And if you check the output, it would be the same as the one from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we have defined a new variable that we are not using (`yourName`),
    but that is fine. I just wanted to show you that Ansible won't complain if there
    are free variables, but it will raise an error if there are unbound interpolations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we have included `vars.yml` in our playbook via the command line,
    referencing your local file with `@` in the beginning, but there is another possibility
    for using variable files in Ansible: including them from within the playbook.
    Let''s take a look at how it is done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, we have used the `include_vars` module in our playbook. Now execute
    the playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11991723-9f2a-4980-98fb-f6932730d6da.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, there is an extra task that takes a file and injects the variables
    in the context.
  prefs: []
  type: TYPE_NORMAL
- en: This module is quite flexible and there are several options to include variable
    files in our playbook. We have used the most straightforward one, but you can
    check out other options in the official documentation at [http://docs.ansible.com/ansible/include_vars_module.html](http://docs.ansible.com/ansible/include_vars_module.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another possibility for including a variable file into our playbook,
    and it is using the `vars_files` directive in our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will take the `vars.yml` file and inject all the defined variables into
    the context, making them available for use.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Ansible is quite flexible around the definition of variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another interesting way of setting up variables in Ansible that helps
    us further customize our playbooks: `set_fact`. Setting facts allows us to set
    variables dynamically in our playbooks. `Set_fact` can be used in combination
    with another interesting instruction called register. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is basically setting a variable to true if the configuration
    folder of our app is empty (hypothetic configuration folder) so that we can regenerate
    it only when it is not present. This is done by making use of the instruction
    when that allows us to execute instructions conditionally. We will come back to
    it during this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have visited the most common ways of defining variables, but there is one
    question pending: what is the precedence of the different methods for creating
    variables?'
  prefs: []
  type: TYPE_NORMAL
- en: This is something that I have to query myself whenever I am working in a playbook,
    and the truth is that at the end of the day, you will use only a couple of methods
    to create variables so that it is not as important as it should be. In my case,
    I tend to create a file with variables (when not working with roles), and if I
    want to override a value, I do that on the command line (or environment variable),
    which is the highest priority in the chain. The complete list of variable precedence
    can be found at [http://docs.ansible.com/ansible/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](http://docs.ansible.com/ansible/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible remote facts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Remote facts in Ansible are a way to specify configuration on remote hosts either
    by an explicit configuration file or by a script that returns data about the server.
    In general, this feature is very useful for operations such as maintenance, setting
    up flags that specifically mark the host as out of the pool so that our playbooks
    have no effect in the hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following command (assuming the inventory from the previous
    example is present in the folder and the VM is running on Google Cloud Platform):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This will output an enormous amount of data (JSON-formatted data). This data
    is all the known facts about the remote host, such as the CPU type, machine ID,
    network interfaces, kernel version, and so on. They can be used within our playbooks,
    but they can also be extended to add more data that is controlled by the remote
    host without any local configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to set up custom remote facts, we have several options, but at the
    end of the day, the custom facts are defined in JSON files by default under `/etc/ansible/facts.d/`.
    It is also possible to create an executable (a script) under the same folder so
    that Ansible will execute it and take the output as facts and add them to the
    facts scope. Take a look at the following file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Put into the remote box (the one used in all the examples from earlier) and
    create a file in `/etc/ansible/facts.d/example.facts` with the content from earlier*.*
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is done, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'It almost looks magical, but the output of your command should now include
    the facts that you created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now they can be used in your playbook in the `ansible_local` variable, for example,
    to access `my_name`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, Ansible can also gather facts from a script placed in
    the facts path. This script should have the `x` flag present, which indicates
    that it can be executed and have the extension `fact`. Let's look at a very interesting
    trick that I find quite useful. When I try to diagnose a failure in our systems,
    the first thing I tend to check is the CPU usage. The majority of the time, our
    systems are highly observable (monitored) so it is easy to check the CPU load,
    but sometimes, monitoring might not be in place.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, go to the server that we have been using in the preceding examples and
    create a file in `/etc/ansible/facts.d/cpuload.fact` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a simple script that will output JSON with information about the CPU
    load in your system. Once the file is created, give it execution permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`chmod u+x /etc/ansible/facts.d/cpuload.fact`'
  prefs: []
  type: TYPE_NORMAL
- en: 'And we are done. Before disconnecting the SSH session, make sure that the script
    works as expected by executing it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to test our scripted facts. What we are going to do is create
    a playbook that gets the CPU load and outputs it to the terminal with a debug
    message. This is the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the preceding playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'You should get an output very similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5b4ec6b5-a321-4c38-b1f7-b98547d4afa4.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have a rudimentary tool to check the CPU load on our servers with a simple
    command, leveraging the host groups to Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we have not explained is the first task that Ansible outputs in every
    playbook: gathering facts.'
  prefs: []
  type: TYPE_NORMAL
- en: This task gets all those facts that we have been talking about in this section
    and creates the context for the playbook to run, so in this case, the CPU load
    that we get is the CPU load gathered at the execution of that task.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Templates are another powerful tool from Ansible. They allow us to render configuration
    files, application properties, and anything that can be stored in a human readable
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Templates rely heavily on variables and a template engine called Jinja2 , which
    is used by Ansible to render the templates. First, we are going to install `ngnix`
    on our server with a simple playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the `apt cache`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upgrade the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install `nginx`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, just run the preceding playbook using the VM created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible-playbook -i inventory tasks.yaml`'
  prefs: []
  type: TYPE_NORMAL
- en: And when the playbook is finished, you should have `nginx` running in your remote
    server. In order to verify it, just open the browser and use the IP of your VM
    as URL. You should see the `nginx` welcome screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create a template with the `nginx` configuration, where
    we can add or remove servers with templates in a fairly easy manner. Create a
    folder called `nginx-servers` in your current directory (where the playbook is)
    and add a file called `nginx.yml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain the file a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: The system is upgraded using `apt`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using apt as well, `nginx` is installed. Note that Ansible uses a declarative
    approach to install packages: you state the name of the package and the state
    that the package should be in after the playbook is executed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The playbook renders the configuration for a virtual server in `nginx` from
    a template called `nginx-one.conf.j2`. We will come back to this in a second.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The playbook reloads the `nginx` service so that the new configuration takes
    effect.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have a few blocks missing in the preceding playbook. The first block is
    the file called `nginx-one.conf.j2`. This file is a template that is used to render
    the `nginx` configuration for a virtual host in the server. Let''s look at the
    content of that file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a folder called `sites-enabled` and add the `nginx-one.conf.j2` file
    to it with the preceding content. This file is a standard `nginx` server block
    but with one particularity: we have a *server_one_port* as a placeholder for the
    port so that we can control the port where the `nginx` virtual host is exposed.
    This is very familiar to us: we are using the variables to render the templates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second block is the file called `vars.yml ()` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very simple: it just defines the variables required to render the template
    from earlier. One thing that you need to be aware when using templates is that
    all the variables in the context can be accessed in it, from the facts gathered
    from the remote server to the variables defined everywhere.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have everything in place (the two files from earlier, the playbook
    from earlier, and the inventory from the previous example), we can run the playbook
    as usual and verify that everything works as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If everything worked as expected, you should have a fully functional `nginx`
    server (serving the default page) in your VM in Google Cloud Platform on the port
    `3000`.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Platform has a deny by default policy in order to enhance security,
    so you might need to adjust the firewall to allow inbound traffic to certain ports.
  prefs: []
  type: TYPE_NORMAL
- en: Flow control
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Ansible, it is possible to use flow control statements such as loops or
    conditionals using variables as input. This can be used to repeat tasks on a certain
    dataset and avoid executing some tasks if a few conditions are not met: we might
    want to use different commands depending on the underlying system of our server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen an example of conditionals using the `when` clause in
    our previous examples, but let''s explain it a bit more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is very easy to read: a command is executed (ignoring the
    potential errors so our playbook continues), and it registers a variable called
    result. Then, we have two debug tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The first one will only be executed only if the `/bin/false` command fails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second one will be executed only if the `/bin/false` command succeeds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this playbook, we are using two new tricks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ignore_errors`: With this clause, if the task fails, the playbook will continue
    executing the following tasks. This is very helpful if we want to test for assumptions
    in the system, for example, if some files are present or a certain network interface
    is configured.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Pipe symbol (|)`: This symbol is called `pipe`. It is a Jinja2 expression
    used to filter values. In this case, we are using the failed and succeeded filters
    to return true or false depending on the outcome of the command. There are many
    filters that can be used on Jinja2 to work in a similar way as Unix pipes transforming
    the data that goes through them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another type of control flow structure are loops. Let''s look at how loops
    work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are using something new that we did not see at the time of explaining
    variables: they can have a structure such as lists and dictionaries. In this case,
    we are defining a list with a few names and outputting a message for each of them.
    Now it is time to run the playbook. Save the preceding content in a file called
    `loops.yml` and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We will assume that the inventory is the same as the one used in the preceding
    examples. After finishing, you should see something similar to the following output
    in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/65c1b778-c1cd-45a4-9a34-cc2dbe8bdcaf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'It is also possible to define a list using the compact version of the declaration.
    Take a look at the following statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be redefined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: And it is totally equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to define dictionaries in Ansible and use them as variables.
    They can also be used as iterable elements, which enable us to give structure
    to our data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are familiar with software development, the preceding snippet will make
    perfect sense to you: a list of structured data (an array of objects) that holds
    information to be accessed by the key.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the rest of the book, we will be using more advanced features of flow control
    structures in Ansible, and we will explain them as we go, but if you want to learn
    more about it, the following links might be useful for you:'
  prefs: []
  type: TYPE_NORMAL
- en: Conditionals ([http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loops ([http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jinja2 Templating ([http://docs.ansible.com/ansible/playbooks_templating.html](http://docs.ansible.com/ansible/playbooks_templating.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have been working on few Ansible playbooks, and as you can imagine, there
    is a lot that can be abstracted from them into generic units of work. As of now,
    with our current knowledge of Ansible, the best thing we can do is use a naming
    convention for playbooks and files so that we don''t mix them, but Ansible provides
    a better approach to this: roles.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Think of roles as common reusable capabilities as you do with modules in software:
    a highly cohesive set of playbooks, variables, and resources that work together
    for one purpose. For example, if we are managing `nginx`, it makes sense to have
    all the related resources in a single module (role, in this case) in order to
    improve the reusability as well as clarity of the code.'
  prefs: []
  type: TYPE_NORMAL
- en: 'One option would be including playbooks using Ansible features. Although we
    did not talk about it, with Ansible, it is possible to include YAML files with
    tasks to create dependencies, as shown in the following snippets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s explain what is going on. We can see two files included:'
  prefs: []
  type: TYPE_NORMAL
- en: The first include is what Ansible calls a play include. It is a fully functional
    playbook as is, which gets included in another playbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second include is what Ansible calls a task include. It only includes a
    list of tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be explained easily by looking at the content of the two files. First,
    look at the content of `play-include.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Second, look at the content of `tasks-include.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are going to execute the playbooks from earlier and see what the output
    is. Save the content of the first playbook on a file called `tasks.yml` and use
    the same inventory as on all the examples from earlier. Now run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the execution has finished, let''s examine the output, which should be
    very similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/12934b55-e2fe-40e2-81d0-23881833bda6.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s explain this:'
  prefs: []
  type: TYPE_NORMAL
- en: The play include (`play-include.yml`) gets executed by outputting the debug
    message in there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The debug task in the main playbook gets executed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The task includes (`tasks-include.yml`) gets executed by executing the two debug
    messages included there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is not very complicated, but it gets easier if you play around a bit with
    the playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although the preceding example can lead to a very clean and reusable set of
    files, there is a much better way of doing this: using roles. Roles are isolated
    sets of functionalities that allow an easy maintenance cycle like any other software
    component.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the preceding example, we can rewrite it using three roles:'
  prefs: []
  type: TYPE_NORMAL
- en: The play include (`play-include.yml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main tasks (`tasks.yml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The tasks include (`tasks-include.yml`)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In order to start creating roles, first, create a new folder called `ansible-roles`
    and a folder called `roles` inside the same one. One thing that was not mentioned
    earlier is the fact that it is a good practice to create a set of folders to hold
    Ansible resources: tasks folders to hold the tasks, files folder to store all
    the files that need to be transferred to the remote hosts, and so on. In general,
    I agree with this setup, but for the examples, we just simplified it in order
    to make everything easier. For roles, this setup is mandatory. We need to create
    the folders as appropriated. In this case, as we are only going to use tasks to
    demonstrate how roles work; we will create the folder tasks inside of every role
    because otherwise, we won''t execute the tasks from the role.'
  prefs: []
  type: TYPE_NORMAL
- en: Inside the **roles** folder, we are going to create another folder called `play-include`,
    which is going to be the equivalent to `play-include.yml` from the preceding example
    but in the form of a role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it is time to create our first role playbook: create a file called `main.yml`
    and place it inside the `play-include/tasks/` folder. This is the content of the
    `main.yml file`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it is time to add a second role called `main-tasks` by creating a folder
    in *roles* and adding a file called `main.yml` inside of `roles/main-tasks/tasks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'And our third and last role is called `tasks-include`. Just create the folder
    as earlier (inside the roles folder) and add a file called `main.yml` to it inside
    of the tasks folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'And that''s it. You have created three roles that can be reused across different
    Ansible projects. Now it is time to use them. Create a file called `tasks.yml`
    in the root folder of your project (in my case, `ansible-roles`) and add the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how your project should look after adding all the files from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a102ec6-ec22-41d5-b132-a6e04eeb9f40.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The inventory is the same one as the previous examples (remember, the recommendation
    was to reuse the same VM). Now it is time to run our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce output similar to the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3806e54-7c42-4bcc-8f57-45a36f9dfc07.png)'
  prefs: []
  type: TYPE_IMG
- en: If we compare the output from the previous example, we can see that it is virtually
    the same except for the legend of the task, which indicates the role that the
    task is coming from.
  prefs: []
  type: TYPE_NORMAL
- en: In roles, we can also define variables and access to the variables defined in
    the global scope as well as many other features. As stated earlier, Ansible is
    big enough to write an entire book just on it, so we are scratching the surface
    of the important parts (under my criteria). As usual, the documentation in Ansible
    is pretty good, and if you want to learn more about roles, the information can
    be found at [https://docs.ansible.com/ansible-container/roles/index.html](https://docs.ansible.com/ansible-container/roles/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: If I can give you some advice regarding Ansible, it would be that you should
    always try to use roles. It doesn't matter how big or simple your project is;
    you will find out very soon that the isolation and reusability that roles provide
    at pretty much no cost are quite beneficial.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Tower
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen an extensive number of features from Ansible that are very useful
    to any DevOps engineer wanting to automate tasks in any IT department.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is one design challenge with Ansible, and it is the fact that the playbooks
    are run from your own computer against remote servers, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/87876d7f-92ee-419a-a0cb-943074ec6508.png)'
  prefs: []
  type: TYPE_IMG
- en: This can be a problem because as you are aware by now, Ansible uses secrets
    (ansible-vault secrets) and, potentially, some sensible information that can be
    intercepted or stolen from a workstation. This is not a problem in Chef or Puppet
    as they follow the bastion host approach, but it might be a problem for companies
    to choose Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the solutions for it comes from Red Hat with the name Ansible Tower.
    This software gets installed in your IT infrastructure (in this case, Google Cloud
    Platform) and offers a UI to be operated in the same way as if a CI server was,
    enabling the role access control to Ansible playbooks as well as a security layer
    that is not present in plain Ansible: the secrets are kept in a server (Ansible
    Tower) inside your infrastructure and they never leave it.'
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Tower offers all the features present in Ansible so that you don't need
    to rewrite any playbook,; just adjust them to the new infrastructure geometry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e4ab03c-1813-4397-8004-cb74ec6e933e.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, now our Ansible host is inside of our infrastructure; therefore,
    it can be operated through a web interface enhancing the security of our IT operations.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Tower also offers an API that can be used to build integration points
    with our software or CI server.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Tower is licensed by Red Hat, so if you want to use it in your company,
    a license needs to be purchased. At the time of writing this, there are not that
    many alternatives in the market and the ones that are available are not as feature-full
    as Ansible Tower. Also, the UI (as shown in the next screenshot) is very sleek,
    which, even though not a killer, is always something to be considered.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8397aec5-e5b8-4dd7-8134-a32cc5d7eada.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, you learned about the main Ansible features, but obviously,
    we have not covered every single possibility, as it would take us a couple of
    books to master them. Also, there is another catch here: DevOps tools are evolving
    constantly.'
  prefs: []
  type: TYPE_NORMAL
- en: When you are working on the DevOps side of the IT world, you always need to
    be willing to learn new things on the fly.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible was originally created to fully provision VMs in the cloud (and on premises),
    but slowly, it is gravitating toward configuration management as more modern tools,
    such as Kubernetes or Docker Swarm, are increasing their market share, leveraging
    Docker into the full software development life cycle in a continuous delivery
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn more about Kubernetes and Docker Swarm as
    they are the next big things in DevOps. Kubernetes, particularly, is an orchestration
    tool that I think will take over all the others in the next few months or years
    as it offers all the resources needed by any IT company leveraging the experience
    that Google has accumulated through years of running software in containers.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, container engines such as Docker are about to surpass the break-even
    and become the norm for all the software components and architectures of the main
    software companies around the world.
  prefs: []
  type: TYPE_NORMAL
