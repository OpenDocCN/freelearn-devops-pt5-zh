- en: Server Provisioning
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器提供
- en: In the previous chapter, you learned how to create the infrastructure that is
    going to hold our applications. As we saw, the infrastructure automation is something
    that's new, and we used Terraform for it. The problem with Terraform is that it
    can only be used to build the infrastructure, but in order to provision the software,
    we need something different.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，你学习了如何创建将承载我们应用程序的基础设施。正如我们所见，基础设施自动化是一个新兴的领域，我们使用了 Terraform 来实现它。Terraform
    的问题在于它只能用于构建基础设施，但为了提供软件，我们需要其他工具。
- en: Through this chapter, we are going to dive deep into Ansible as, together with
    Puppet and Chef, it is the most predominant server provisioning tool in the market
    right now.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨 Ansible，因为它与 Puppet 和 Chef 一起，是目前市场上最为流行的服务器提供工具。
- en: 'Here are the main topics that will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Server provisioning software
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器提供软件
- en: Chef
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef
- en: Puppet
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Puppet
- en: Ansible
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Ansible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible
- en: Ansible configuration
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 配置
- en: Ansible variables
  id: totrans-10
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 变量
- en: Variables
  id: totrans-11
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量
- en: Remote facts
  id: totrans-12
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 远程事实
- en: Templates
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板
- en: Flow control
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流程控制
- en: Ansible roles
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible 角色
- en: Ansible tower
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ansible Tower
- en: As you can see, it is quite an extensive chapter with many examples that will
    enable you to learn the most important features of Ansible.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，这是一章非常广泛的内容，包含了许多示例，帮助你学习 Ansible 的最重要功能。
- en: One thing that you need to be aware while reading through this chapter is the
    fact that it is impossible to showcase all the features from Ansible in a single
    chapter. In fairness, it would take us over a book to master all the features
    up to a proficient level. As you can guess by now, when I need to deal with Ansible,
    the first thing I do is open the official documentation and have it side by side
    with the code so that I can always refer to it for examples and features that
    I have either never dealt with or it has been a long time since I did not work
    with it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，你需要注意的一点是，无法在单一章节中展示 Ansible 的所有功能。公平地说，掌握所有功能并达到熟练水平可能需要一本书的内容。正如你现在可以猜到的那样，当我需要处理
    Ansible 时，第一件事就是打开官方文档，并将其与代码并排放置，这样我可以随时参考它，获取我之前没有接触过或已经很久没有使用过的功能和示例。
- en: We will also explore a section Ansible Tower, which is a software used to run
    Ansible playbooks on a bastion host mode from within your infrastructure instead
    of running it from a workstation.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨 Ansible Tower 部分，它是一款用于在堡垒主机模式下运行 Ansible playbook 的软件，可以在你的基础设施内运行，而不是在工作站上运行。
- en: Server provision software
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务器提供工具
- en: As mentioned earlier, there are few options for software provisioning. Through
    this chapter, you will learn how to use Chef and Ansible, focusing on the latter
    as it is widely used across many companies and is easier to master than Chef.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，软件提供的选项很少。在本章中，你将学习如何使用 Chef 和 Ansible，重点介绍 Ansible，因为它在许多公司中广泛使用，而且比 Chef
    更容易掌握。
- en: There are also other options in the market that are valid and good solutions,
    but we are going to take a special interest in Ansible, which, to me, seems the
    easiest to learn and extend out of all of them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 市场上还有其他有效且优秀的解决方案，但我们将特别关注 Ansible，因为对我而言，它是所有工具中最容易学习和扩展的。
- en: Chef
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chef
- en: Chef is a very interesting software that follows the bastion host principle
    to run configurations on our servers. A bastion host is a server placed in our
    private network that is able to reach our servers directly or via proxy in order
    to execute the actions needed to set them up with the desired state. This is an
    option not to be overlooked, as one of the biggest challenges that server provisioning
    presents is the management of secrets and authorization that, for example, Ansible
    needs to improve via third-party software such as Ansible Tower from Red Hat.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 是一款非常有趣的软件，它遵循堡垒主机原则，在我们的服务器上运行配置。堡垒主机是一台放置在私有网络中的服务器，它能够直接或通过代理访问我们的服务器，从而执行必要的操作，将它们设置为所需的状态。这是一个不容忽视的选项，因为服务器提供过程中的最大挑战之一是管理密钥和授权，例如
    Ansible 就需要通过第三方软件（如 Red Hat 的 Ansible Tower）来改进这方面的功能。
- en: 'Chef uses recipes to configure parts of the server. A recipe is basically a
    set of declarative instructions that define what needs to happen in order to get
    the server to the desired status. For example, take a look at this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 使用食谱来配置服务器的各个部分。食谱基本上是一组声明性指令，定义了为了让服务器达到所需状态需要执行的操作。例如，看看这个：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code will upgrade our system and then install the Apache2 web
    server.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码将升级我们的系统，然后安装 Apache2 网络服务器。
- en: 'This recipe, once finished, gets uploaded into the Chef server from a workstation,
    and here is the key: in Chef, there are three actors:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成此食谱，它将从工作站上传到 Chef 服务器，关键点是：在 Chef 中，有三个角色：
- en: Server
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器
- en: Workstation
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工作站
- en: Nodes
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 节点
- en: The server is where the recipes and configuration live. It needs to be installed
    prior to doing any work, and the instructions can be found at [https://docs.chef.io/install_server.html](https://docs.chef.io/install_server.html).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器是存放食谱和配置的地方。在进行任何工作之前需要先安装，安装说明可以在 [https://docs.chef.io/install_server.html](https://docs.chef.io/install_server.html)
    上找到。
- en: 'There are three modalities of the Chef server:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 服务器有三种模式：
- en: '**Enterprise:** This can be installed inside your infrastructure and it is
    licensed, so you need to pay depending on the numbers of nodes that it is managing.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**企业版**：这可以安装在你的基础设施内部，并且需要许可证，所以你需要根据管理的节点数量支付费用。'
- en: '**Open source:** This can also be installed in your infrastructure but **it
    does not have any support**. It is free and has to be configured and maintained
    by your company. It is also a cut-down version of the Enterprise Chef.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开源**：这也可以在你的基础设施中安装，但**没有任何支持**。它是免费的，必须由你公司配置和维护。它也是企业版 Chef 的简化版本。'
- en: '**Hosted:** The Chef server is hosted on third-party hardware and you don''t
    need to worry about maintaining and upgrading it. It might not be an option depending
    on the setup of your company.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**托管**：Chef 服务器托管在第三方硬件上，你无需担心其维护和升级。根据你公司设置的不同，这可能不是一个可选项。'
- en: 'The nodes are the target hosts. Every node is registered in the Chef server
    and has a run list: a list of recipes that are going to be run on a host when
    the `chef-client` command is executed.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是目标主机。每个节点都在 Chef 服务器上注册，并有一个运行列表：一旦执行 `chef-client` 命令，这个列表上的食谱将在主机上运行。
- en: 'The workstation is the computer used to configure and upload the Chef server.
    This computer uses a software called knife that can do everything on the Chef
    server:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 工作站是用来配置和上传 Chef 服务器的计算机。此计算机使用一个名为 knife 的软件，可以在 Chef 服务器上执行所有操作：
- en: Configuring roles
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置角色
- en: Looking for VMs depending on the roles and other parameters
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据角色和其他参数查找虚拟机
- en: Configuring run lists
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置运行列表
- en: Managing secrets
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理机密
- en: Knife uses cryptographic keys to communicate with the Chef server so all the
    communication happens in a trusted way.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Knife 使用加密密钥与 Chef 服务器进行通信，因此所有通信都是以受信方式进行的。
- en: 'Now, if we want to picture everything, it looks like that is shown in the following
    diagram:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们想把一切都形象化，看起来会像下面的图示：
- en: '![](img/82bdd4ea-1c7d-4309-b637-22350469cded.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82bdd4ea-1c7d-4309-b637-22350469cded.png)'
- en: 'As you can see, even though the setup is quite complex (you need to set up
    a couple of software components) there are obvious benefits: our Chef server is
    behind the firewall in the demilitarized zone of our infrastructure, but it is
    managed via a CLI tool so all our secrets and configuration are safe inside our
    infrastructure.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，尽管设置相当复杂（你需要设置几个软件组件），但也有明显的好处：我们的 Chef 服务器位于基础设施的防火墙后，在隔离区中，但它通过 CLI 工具进行管理，因此我们所有的机密和配置都安全地保存在我们的基础设施内。
- en: Chef has a steep learning curve that, once we have gone through the initial
    learning phase, gets very familiar and easy to add new features and extend the
    DSL with the power of Ruby and a very well-thought-out interface.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 有一个陡峭的学习曲线，一旦我们度过了初学阶段，就会变得非常熟悉，添加新功能和使用 Ruby 强大的功能扩展 DSL 变得非常容易，且界面设计非常合理。
- en: Puppet
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Puppet
- en: 'Puppet has been around for a while and is widely used in the DevOps world.
    Puppet comes in two flavors:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Puppet 已经存在一段时间，并且在 DevOps 世界中被广泛使用。Puppet 有两个版本：
- en: Open source
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开源
- en: Enterprise
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 企业版
- en: The open source version comes as is, offering a good set of features that allow
    you to fully automate the configuration management of your infrastructure.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 开源版本原封不动地提供，提供了一套完整的功能，可以让你完全自动化基础设施的配置管理。
- en: The enterprise edition, aside from support, comes with an extended set of features
    that make the life of the engineers in your company a lot easier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 企业版除了支持外，还附带一套扩展的功能，使得你公司中的工程师工作更加轻松。
- en: 'In the same way as Chef, Puppet follows the bastion host architecture: the
    server is installed within your infrastructure in the demilitarized zone and the
    nodes (your servers), via the puppet agent, will execute the specified tasks to
    reach the desired status.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 和Chef一样，Puppet也遵循堡垒主机架构：服务器安装在你的基础设施中的非军事区内，节点（你的服务器）通过Puppet代理执行指定的任务，以达到所需状态。
- en: 'The main difference between Chef and Puppet is the fact that puppet is declarative
    whereas Chef is more imperative:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Chef和Puppet之间的主要区别在于，Puppet是声明性的，而Chef更像是命令式的：
- en: In Puppet, you specify which state you want your servers on and Puppet takes
    care of keeping them there
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Puppet中，你指定希望服务器处于什么状态，Puppet会负责保持它们在该状态。
- en: In Chef, you declare a number of steps that will get your server to the desired
    state
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Chef中，你声明一系列步骤，旨在将服务器引导到所需的状态。
- en: That said, Chef also allows you to declare guards, which are conditions for
    steps to be executed.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，Chef还允许你声明守卫条件，这些是执行步骤的前提条件。
- en: Through my experience, I've found that people coming from an DevOps background
    feel more comfortable with Puppet as it is similar to what they have done through
    the years, whereas writing Chef recipes is similar to software development.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我的经验，我发现来自DevOps背景的人更容易接受Puppet，因为它类似于他们多年来做过的事情，而编写Chef的食谱更像是软件开发。
- en: Ansible
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible
- en: Ansible is what we are going to be using to develop the contents of the rest
    of the book. In my opinion, it is the easiest to learn and extend. It is also
    easy to understand and offers a fairly comprehensive open source version that
    works with all the features from Ansible. You can also buy a license of Ansible
    Tower (or similar) to run Ansible Playbooks in a bastion host configuration as
    Chef or Puppet.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible是我们将在本书其余部分开发内容时使用的工具。依我看，它是最容易学习和扩展的。它也容易理解，并提供了一个功能非常全面的开源版本，涵盖了Ansible的所有特性。你还可以购买Ansible
    Tower（或类似工具）的许可证，以便在堡垒主机配置下运行Ansible Playbooks，就像Chef或Puppet一样。
- en: Ansible is basically a **domain-specific language** (**DSL**) for executing
    operations on remote hosts that are defined in an inventory.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible基本上是一个**领域特定语言**（**DSL**），用于在清单中定义的远程主机上执行操作。
- en: 'Ansible works by running playbooks in the desired servers via SSH, so unlike
    Chef or Puppet, we don''t need to install anything in the remote hosts; we should
    just be able to SSH into them. A playbook is basically a **Yet Another Markup
    Language** (**YAML**) with a set of instructions to get the server into the desired
    state in the same way as if we were executing a Bash script. A Playbook looks
    like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible通过通过SSH在目标服务器上运行playbooks来工作，因此与Chef或Puppet不同，我们不需要在远程主机上安装任何东西；只需能够通过SSH连接即可。Playbook基本上是一个**另一种标记语言**（**YAML**），它包含一系列指令，用于将服务器引导到所需状态，就像我们执行一个Bash脚本一样。Playbook看起来像这样：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Reading through the file will make you understand how easy and straightforward
    it is to understand what the Playbook doing.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过阅读文件，你会理解如何轻松直观地明白Playbook正在做什么。
- en: 'As you can see, in the second line, we are specifying that we want to run this
    Playbook in the hosts called `webservers`. This can be defined in the other part
    of Ansible: the inventory. The Ansible inventory is basically a file with the
    list of hosts in your infrastructure, as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在第二行中，我们指定了希望在名为`webservers`的主机上运行此Playbook。这个定义也可以在Ansible的另一部分：清单中进行。Ansible清单基本上是一个包含你基础设施中主机列表的文件，如下所示：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This file is very straightforward but can get really complicated as well:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件非常简洁，但也可能变得相当复杂：
- en: The names between brackets are groups
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方括号中的名称是组名。
- en: The groups contain hosts that can be defined with generators or they can just
    be listed
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组包含可以用生成器定义的主机，或者它们可以只是列出。
- en: Groups can have configuration specific to them or even override variables
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组可以拥有特定于它们的配置，甚至覆盖变量。
- en: 'In the preceding example, we have two groups: `webservers` and `dbservers`.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们有两个组：`webservers` 和 `dbservers`。
- en: 'Web servers are only two hosts:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器只有两个主机：
- en: '`Host1`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host1`'
- en: '`Host2`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Host2`'
- en: 'Dbservers use a generator and we have three hosts:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Dbservers使用生成器，我们有三个主机：
- en: '`192.168.0.1`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.1`'
- en: '`192.168.0.2`'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.2`'
- en: '`192.168.0.3`'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`192.168.0.3`'
- en: 'As mentioned earlier, we can also define variables in the inventory. These
    variables can be scoped on the group and the host. Let''s take a look at the following
    inventory:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们还可以在清单中定义变量。这些变量可以作用于组和主机。让我们看看以下清单：
- en: '[PRE3]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As you can see, we have two variables:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们有两个变量：
- en: '`timezone`: This is applied to all the hosts of the group `dbservers`.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`timezone`：这适用于 `dbservers` 组中的所有主机。'
- en: '`role`: This is applied to the host `host1` of the group `webservers`*.*'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`role`：这适用于 `webservers`*组*中的主机`host1`。'
- en: This variable can be used in `playbooks` in order to have a specific configuration
    for specific hosts, as we will see later on in this chapter.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这个变量可以在 `playbooks` 中使用，以便为特定主机提供特定的配置，正如我们稍后在本章中看到的那样。
- en: 'Groups can also be combined into bigger groups:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 组也可以组合成更大的组：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding inventory, we can find the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的清单中，我们可以找到以下内容：
- en: '`dbservers`'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dbservers`'
- en: '`mongoservers`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mongoservers`'
- en: '`webservers`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`webservers`'
- en: '`dataservers`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dataservers`'
- en: '`all`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`all`'
- en: '`ungrouped`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ungrouped`'
- en: 'Even though we did not specify it, Ansible always has two default groups called
    `all` and `ungrouped` that are self-descriptive: `all` is all the hosts in the
    inventory and `ungrouped` is all the hosts that are not specified in any group.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们没有指定，但 Ansible 总是有两个默认的组，分别是 `all` 和 `ungrouped`，这两个组名称具有自描述性：`all` 是清单中的所有主机，`ungrouped`
    是未在任何组中指定的所有主机。
- en: 'As stated earlier, Ansible does not follow the bastion host architecture as
    Chef or Puppet, but it follows the client/server architecture: our host needs
    to be able to reach the destination hosts (the ones on the inventory) in order
    to work.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ansible 不遵循像 Chef 或 Puppet 那样的堡垒主机架构，而是遵循客户端/服务器架构：我们的主机需要能够到达目标主机（清单中的主机）才能工作。
- en: This can be inconvenient depending on your infrastructure architecture, but
    it can be worked around using Ansible Tower or Rundeck to execute Ansible playbooks
    from inside your demilitarized zone.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会根据您的基础设施架构带来不便，但可以通过使用 Ansible Tower 或 Rundeck 从您的隔离区内执行 Ansible playbooks
    来解决。
- en: In this chapter, we are going to use Ansible to build real production-ready
    examples in combination with Terraform so that we get a grasp of the real usage
    of the tools.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用 Ansible 与 Terraform 结合构建真实的生产级示例，以便更好地理解这些工具的实际应用。
- en: Ansible
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible
- en: In this section, we are going to take our first steps toward a more comprehensive
    example in Ansible. For now, we are going to install and configure NGINX, a very
    popular web server so we can showcase the main concepts of Ansible.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将迈出使用 Ansible 进行更全面示例的第一步。现在，我们将安装和配置 NGINX，这是一个非常流行的 Web 服务器，以便展示 Ansible
    的主要概念。
- en: 'First, we are going to create a VM in Google Cloud Platform with an associated
    static IP so we can target it from our inventory. We are going to use Terraform
    in order to do it. First, we''ll look at our resources file:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 Google Cloud Platform 创建一个虚拟机，并为其分配一个静态 IP，以便我们可以从清单中进行定位。我们将使用 Terraform
    来完成这个操作。首先，我们来看一下我们的资源文件：
- en: '[PRE5]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And now, we''ll look at our vars file:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们来看一下我们的 vars 文件：
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this case, we are reusing the project from the previous chapter as it is
    convenient to shut down everything once we are done. Now we run our plan so we
    can see what resources are going to be created:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将重用前一章节的项目，因为一旦完成，我们可以方便地关闭所有内容。现在，我们运行我们的计划，看看将要创建哪些资源：
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So far, everything looks right. We are creating two resources:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切看起来都正确。我们正在创建两个资源：
- en: The static IP
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态 IP
- en: The VM
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟机
- en: 'Now, we can apply our infrastructure:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以应用我们的基础设施：
- en: '[PRE8]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'And everything works as expected. If we check Google Cloud Platform, we can
    see that our VM has been created and has associated a public IP:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一切按预期工作。如果我们检查 Google Cloud Platform，我们可以看到我们的虚拟机已创建并关联了一个公共 IP：
- en: '![](img/53521020-4335-4113-aae4-c560054b691c.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/53521020-4335-4113-aae4-c560054b691c.png)'
- en: In this case, the associated public IP is `35.187.81.127`. It is important to
    verify that we can reach the server via SSH. In order to do it, just click on
    the SSH button on the right-hand side of your instance row and it should open
    a Cloud Console window with terminal access.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，关联的公共 IP 是 `35.187.81.127`。重要的是验证我们是否可以通过 SSH 访问该服务器。为此，只需点击实例行右侧的 SSH
    按钮，它应该会打开一个带有终端访问权限的 Cloud Console 窗口。
- en: If SSH access fails, you need to add an ingress allow rule in the firewall to
    the port `22`. For this example, just allow the traffic from any IP into any port,
    but don't do this in your real infrastructure as it is a security threat.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 SSH 访问失败，您需要在防火墙中为端口`22`添加一个入站允许规则。以这个例子为例，允许任何 IP 访问任何端口，但在您的实际基础设施中请不要这么做，因为这会带来安全隐患。
- en: 'Once everything is up and running, it is time to start with Ansible. First,
    we are going to create our inventory file:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一切启动并运行，就可以开始使用 Ansible。首先，我们将创建我们的清单文件：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is very simple: a group with our public IP address that is connected to
    our VM. Save the file with the name `inventory` in a new folder named, for example,
    `ansible-nginx`. Once the inventory is created, we need to verify that all the
    hosts can be reached. Ansible provides you the tool to do that:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单：一个包含我们公有 IP 地址的组，该组连接到我们的虚拟机。将文件保存为 `inventory`，并放置在一个新的文件夹中，例如命名为 `ansible-nginx`。创建好
    inventory 后，我们需要验证所有主机是否可达。Ansible 为此提供了一个工具：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you execute the preceding command, Ansible will `ping` (actually, it does
    not use the ping command but tries to issue a connection to the server) all the
    hosts in your inventory specified in the parameter `-i`. If you change everything
    for the name of a group, Ansible will try to reach only the hosts in that group.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你执行上述命令，Ansible 将 `ping`（实际上，它并没有使用 ping 命令，而是尝试发起与服务器的连接）所有在参数 `-i` 中指定的
    inventory 主机。如果你将所有内容替换为一个组的名称，Ansible 只会尝试访问该组中的主机。
- en: 'Let''s take a look at the output of the command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看命令的输出：
- en: '[PRE11]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We are experiencing problems in connecting to our remote host and the cause
    is that we don''t have any key that the host can validate to verify our identity.
    This is expected as we did not configure it, but now, we are going to solve it
    by creating a key pair and installing it on the remote host using the Google Cloud
    SDK:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在连接远程主机时遇到了问题，原因是我们没有任何密钥可以供主机验证以确认我们的身份。这是预期的，因为我们没有进行配置，但现在，我们将通过创建一个密钥对并使用
    Google Cloud SDK 安装到远程主机来解决这个问题：
- en: '[PRE12]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This command will do three things:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将做三件事：
- en: Generate a new key pair
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成一个新的密钥对。
- en: Install the key pair in our remote VM
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的远程虚拟机上安装密钥对。
- en: Open a shell in our VM in GCP
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GCP 中打开我们的虚拟机 shell。
- en: The new key generated can be found under `~/.ssh/` with the name `google_compute_engine
    and google_compute_engine.pub` (private and public key).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的新密钥可以在 `~/.ssh/` 目录下找到，名称为 `google_compute_engine` 和 `google_compute_engine.pub`（私钥和公钥）。
- en: 'Once the command finishes, our shell should look like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦命令执行完成，我们的 shell 应该像这样：
- en: '![](img/1dc53067-fb7b-4dc8-a40c-995e3a8d1bdd.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1dc53067-fb7b-4dc8-a40c-995e3a8d1bdd.png)'
- en: Now we have a terminal connected to our VM and we can execute commands. `gcloud`
    configures a user by default; in my case, `davidgonzalez` that can use `sudo`
    without password. In this case, we are going to execute the playbook as the root,
    so we need to be able to login as root into the VM. Copy the file `~/.ssh/authorized_keys`
    into `/root/.ssh/authorized_keys` and we should be able to do it. So, we have
    copied the public key that we generated earlier to the set of authorized keys
    of the root user.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个连接到虚拟机的终端，并且可以执行命令。`gcloud` 默认配置了一个用户；在我的案例中是 `davidgonzalez`，该用户可以在不输入密码的情况下使用
    `sudo`。在这种情况下，我们将以 root 用户身份执行 playbook，因此我们需要能够以 root 用户身份登录虚拟机。将 `~/.ssh/authorized_keys`
    文件复制到 `/root/.ssh/authorized_keys` 中，这样我们就可以做到这一点。因此，我们已经将之前生成的公钥复制到了 root 用户的授权密钥集中。
- en: In general, root access should be avoided as much as possible, but in this case,
    we will be executing the playbook as the root for convenience.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，应尽量避免使用 root 权限，但在这种情况下，为了方便，我们将以 root 用户身份执行 playbook。
- en: 'In order for Ansible to be able to use the key, we need to add it to the daemon
    on our server:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Ansible 能够使用该密钥，我们需要将它添加到服务器上的守护进程中：
- en: '[PRE13]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This command should output the success, stating that the identity was added.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令应该输出成功信息，说明身份验证已添加。
- en: 'Now we can run our pin command again:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以再次运行我们的 pin 命令：
- en: '[PRE14]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output should be very different:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该会有很大不同：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This means that now, Ansible is able to reach our server; therefore, it will
    be able to execute the playbook against it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在 Ansible 可以访问我们的服务器；因此，它将能够在该服务器上执行 playbook。
- en: 'Now it is time to start writing our first `ansible` playbook. Inside the same
    folder, `ansible-nginx`, create a file called `tasks.yml` with the following content:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候开始编写我们的第一个 `ansible` playbook 了。在同一个文件夹 `ansible-nginx` 中，创建一个名为 `tasks.yml`
    的文件，内容如下：
- en: '[PRE16]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This is simple to understand:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易理解：
- en: Our playbook is going to affect all the hosts
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 playbook 将影响所有主机。
- en: The user running the playbook is going to be root
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行 playbook 的用户将是 root。
- en: 'And then we are going to execute two tasks:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们将执行两个任务：
- en: Update the `apt cache`
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 `apt cache`。
- en: Upgrade all the packages
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级所有软件包。
- en: 'Once we have the two files (inventory and playbook), we can run the following
    command:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们拥有了两个文件（inventory 和 playbook），我们可以运行以下命令：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We should produce output similar to the following one:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该生成类似如下的输出：
- en: '![](img/b8be2660-7d43-42ad-a448-bcad349dae1c.png)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b8be2660-7d43-42ad-a448-bcad349dae1c.png)'
- en: We are going to run few playbooks along the chapter, so I would recommend that
    you keep the same VM alive and run all of them against it in order to save time
    and resources. The trial account from Google Cloud Platform will give you enough
    room to run them across several days or weeks.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将运行几个 playbook，所以我建议你保持相同的虚拟机处于运行状态，并将它们全部执行，以节省时间和资源。Google Cloud Platform
    的试用账户会为你提供足够的空间，可以在几天或几周内运行它们。
- en: 'Let''s explain the output:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下输出：
- en: First, it specifies against which group we are going to execute the playbook.
    In this case, we specified that the group is `all`.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它指定了我们要在哪个组上执行 playbook。在这个例子中，我们指定了组为`all`。
- en: Then, we can see three tasks being executed. As you can see, the description
    matches the description specified in `tasks.yml`. This is very helpful in order
    to understand the output of your playbooks, especially when they fail.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们可以看到三个任务被执行。如你所见，描述与`tasks.yml`中指定的描述相匹配。这在理解你的 playbook 输出时非常有用，尤其是在它们失败时。
- en: 'And then we get a recap:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后我们得到一个总结：
- en: Three tasks were executed
  id: totrans-159
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行了三个任务
- en: Two of them produced changes on the server
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中两个在服务器上产生了变化
- en: Zero failed
  id: totrans-161
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 零个失败
- en: 'Simple and effective. This is the closest to executing a script in the server
    that we can get: a set of instructions, a target host, and its output.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 简单有效。这是最接近在服务器上执行脚本的方式：一组指令，一个目标主机及其输出。
- en: In Ansible, instead of plain bash instructions, the actions are encapsulated
    into modules. A module is a component of the DSL, which allows you to do something
    special. In the playbook from earlier, apt is a module included in the core of
    Ansible. Documentation for it can be found at [http://docs.ansible.com/ansible/apt_module.html](http://docs.ansible.com/ansible/apt_module.html).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中，动作被封装到模块中，而不是使用简单的 bash 指令。模块是 DSL 的一个组件，允许你执行特殊的操作。在之前的 playbook
    中，apt 是一个包含在 Ansible 核心中的模块。有关它的文档可以在[http://docs.ansible.com/ansible/apt_module.html](http://docs.ansible.com/ansible/apt_module.html)找到。
- en: 'Let''s take another look to one of our usages of the `apt` module:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再看看我们使用`apt`模块的一个例子：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This, as you can guess, would be the equivalent to the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜测，这相当于以下内容：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'So, in this case, Ansible provide us with a different module called command,
    which allows us to execute commands in the hosts of our inventory. Take a look
    at the following `yaml`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，Ansible 提供了一个名为 command 的不同模块，允许我们在我们的清单主机上执行命令。请看下面的`yaml`：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is equivalent to the `yaml` from earlier, and both do the same: update
    `apt-cache`.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当于之前的`yaml`，两者执行相同的操作：更新`apt-cache`。
- en: In general, if there is a module for a given task, it is recommended that you
    use it as it will handle (or at least you can expect it to) the errors and the
    outputs better than executing the equivalent command.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，如果给定任务有模块可用，建议使用它，因为它比执行等效命令更好地处理（或至少能期望它处理）错误和输出。
- en: 'Now, once our playbook has succeeded, we can expect our system to be up to
    date. You can check it by running the playbook again:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，一旦我们的 playbook 成功执行，我们可以预期我们的系统已更新。你可以通过再次运行 playbook 来检查它：
- en: '![](img/277e8ee6-2d9a-46e6-9e09-adb4f360b02f.png)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![](img/277e8ee6-2d9a-46e6-9e09-adb4f360b02f.png)'
- en: Now you can see that only one task has produced changes in the server (updating
    the apt sources).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以看到，只有一个任务在服务器上产生了变化（更新了 apt 源）。
- en: Ansible configuration
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 配置
- en: One of the features of Ansible is the ability to override the defaults per project.
    In order to do it that, we just need to create a file called `ansible.cfg` in
    the root of our project and Ansible will read it and apply the configuration.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 的一个特点是能够为每个项目覆盖默认设置。为了实现这一点，我们只需在项目根目录创建一个名为`ansible.cfg`的文件，Ansible
    会读取该文件并应用配置。
- en: There is a big number of parameters that can be configured, and all of them
    can be found in the official documentation at [http://docs.ansible.com/ansible/intro_configuration.html](http://docs.ansible.com/ansible/intro_configuration.html).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 有大量可以配置的参数，所有这些参数都可以在官方文档中找到，网址是[http://docs.ansible.com/ansible/intro_configuration.html](http://docs.ansible.com/ansible/intro_configuration.html)。
- en: As you can see, the documentation for Ansible is quite good, and the majority
    of the time, it will provide an answer to your problems.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，Ansible 的文档非常好，大多数时候，它能为你的问题提供答案。
- en: 'Let''s see how the configuration can help us. If you remember from the previous
    example, we have specified the flag `-i` in order to tell Ansible where our inventory
    file lives. Ansible has a default for this value, which is `/etc/ansible/hosts`.
    In our little project, our inventory is in the same folder as our code, and in
    order to specify it to Ansible, we need to create a configuration file with the
    following content:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看配置是如何帮助我们的。如果你还记得前面的例子，我们已经指定了`-i`标志，用于告诉 Ansible 库存文件的位置。Ansible 对此有默认值，即`/etc/ansible/hosts`。在我们的小项目中，库存文件与代码放在同一文件夹中，为了让
    Ansible 知道这一点，我们需要创建一个如下内容的配置文件：
- en: '[PRE21]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, we run our `playbook` again with the following command:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们使用以下命令再次运行我们的`playbook`：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We did not specify the host list, but Ansible, after reading `ansible.cfg` knows
    that the inventory file can be located at `./inventory`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有指定主机列表，但 Ansible 在读取了`ansible.cfg`后知道库存文件可以位于`./inventory`。
- en: 'Ansible has a hierarchy of precedence to find the configuration:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 有一套配置优先级的层级结构：
- en: The `ANSIBLE_CONFIG` environment variable
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ANSIBLE_CONFIG` 环境变量'
- en: '`ansible.cfg`'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ansible.cfg`'
- en: '`.ansible.cfg`'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.ansible.cfg`'
- en: '`/etc/ansible/ansible.cfg`'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/etc/ansible/ansible.cfg`'
- en: 'So, if we define an environment variable called `ANSIBLE_CONFIG` pointing to
    a file, the Ansible configuration will be read from that location and the rest
    of the options will be ignored. This is particularly helpful in segregating environments:
    our CI server can define its own configuration in the environment file, whereas
    developers can have the `ansible.cfg` file checked in into the source control
    so that is shared across everyone.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们定义一个名为`ANSIBLE_CONFIG`的环境变量指向一个文件，Ansible 将从该位置读取配置文件，其他选项将被忽略。这在环境隔离时特别有用：我们的
    CI 服务器可以在环境文件中定义自己的配置，而开发者则可以将`ansible.cfg`文件提交到源代码控制中，以便在团队中共享。
- en: 'There are a few sections that can be specified in `ansible.cfg`. Sections control
    several aspects of of Ansible, such as connections. Under certain circumstances,
    we might need to add special parameters for `ssh` to work, and it is as easy as
    adding the following lines to your `ansible.cfg` file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible.cfg` 文件中可以指定几个部分。各个部分控制 Ansible 的不同方面，如连接。在某些情况下，我们可能需要为 `ssh` 添加特殊的参数，只需在
    `ansible.cfg` 文件中添加以下几行：'
- en: '[PRE23]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Ansible variables, remote facts and templates
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 变量、远程事实和模板
- en: Variables and templates are an important part of Ansible. They allow us to override
    values in our configuration (servers and playbooks) so that we can write generic
    playbooks that can be reused across different configurations with minor tweaks.
    With templates, we can render configuration files from our host so we could potentially
    use Ansible to manage the configuration of remote servers with little to no effort.
    It also can be used to generate and install SSL certificates for different hosts
    transparently to the user.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 变量和模板是 Ansible 中非常重要的一部分。它们允许我们覆盖配置中的值（如服务器和剧本），使得我们可以编写通用的剧本，通过少量修改即可在不同的配置中重用。通过模板，我们可以从主机渲染配置文件，这样我们就可以利用
    Ansible 来管理远程服务器的配置，几乎不需要任何额外的工作。它还可以用来为不同的主机生成和安装 SSL 证书，且对用户透明。
- en: Both of them (variables and templates) use a template engine called Jinja2,
    which allows logic and interpolation to be embedded in our configurations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 它们（变量和模板）都使用一个名为 Jinja2 的模板引擎，它允许在我们的配置中嵌入逻辑和插值。
- en: In general, there are several ways of defining variables, but we are only going
    to visit the most common ones (under my criteria), as otherwise, it would take
    us the size of several chapters to document them properly. If you want to explore
    further different ways of defining variables, the official documentation provides
    a fairly comprehensive guide at [http://docs.ansible.com/ansible/playbooks_variables.html](http://docs.ansible.com/ansible/playbooks_variables.html).
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，有几种方式来定义变量，但我们只会探讨最常见的几种（根据我的标准），否则我们需要几个章节来详细记录这些方法。如果你想深入了解定义变量的不同方式，官方文档提供了一个相当全面的指南，地址是
    [http://docs.ansible.com/ansible/playbooks_variables.html](http://docs.ansible.com/ansible/playbooks_variables.html)。
- en: Ansible variables
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 变量
- en: 'Variables are the most simple of the potential customizations. With variables,
    we can define values that are going to be replaced in our playbooks. Let''s take
    a look at the following playbook:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是最简单的自定义选项。通过变量，我们可以定义将在剧本中替换的值。让我们看看以下的剧本：
- en: '[PRE24]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Replace the content of `tasks.yml` with the snippet from earlier. There are
    two new symbols in our task. Also, our task is new: debug is used to output values
    from our variables into the terminal while executing the playbook. Let''s take
    a look at the execution (we will use the same configuration as the example from
    earlier):'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 用之前的代码片段替换 `tasks.yml` 的内容。我们的任务中有两个新的符号。此外，我们的任务是新的：debug 用于在执行 playbook 时将变量的值输出到终端。让我们看看执行情况（我们将使用与之前示例相同的配置）：
- en: '[PRE25]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'It fails:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 它失败了：
- en: '![](img/fec26755-e784-48b5-8948-6cfbcb096ab7.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fec26755-e784-48b5-8948-6cfbcb096ab7.png)'
- en: 'The reason for the failure can be seen in in the message: we have a variable
    defined called `name` that does not have a value associated. Ansible will fail
    if there is a value that cannot be interpolated, aborting the execution of the
    task.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 失败的原因可以从信息中看到：我们定义了一个名为 `name` 的变量，但没有为其指定值。如果存在无法插值的值，Ansible 将失败并中止任务的执行。
- en: 'There is another interesting piece of information here: Ansible gives you a
    parameter to retry the playbook only on the hosts that were not successful. If
    we wanted to retry the playbook only on the failed hosts, we could run the following
    command:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个有趣的信息：Ansible 给了你一个参数，允许你仅在那些未成功的主机上重试 playbook。如果我们只想在失败的主机上重试 playbook，可以运行以下命令：
- en: '[PRE26]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The new parameter, `tasks.retry` is a file with a list of hosts that are okay
    to rerun the playlist as they failed before.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 新的参数 `tasks.retry` 是一个包含可重新运行失败主机列表的文件。
- en: 'Going back to our missing variables, we need to define the variable called
    `myName`. There are a few ways of doing that; the first is via the command line:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们缺失的变量，我们需要定义一个名为 `myName` 的变量。定义变量的方式有几种；第一种是在命令行中定义：
- en: '[PRE27]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And you can see that the output of the playbook is looking better now:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，现在 playbook 的输出看起来更好了：
- en: '![](img/0cfc28ac-bc49-4244-8166-417cdb1f7d49.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0cfc28ac-bc49-4244-8166-417cdb1f7d49.png)'
- en: As you can see, the variables got interpolated and we can see the message `Hello
    David! I am 35.187.81.127`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，变量已经被插值，我们可以看到信息 `Hello David! I am 35.187.81.127`。
- en: 'The second way of defining variables is via inventory, as we have seen earlier:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量的第二种方式是通过库存，如我们之前所见：
- en: '[PRE28]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we modify our inventory to match the preceding snippet, the value of our
    variable will be `DavidInventory` and we don''t need to pass a value in the command
    line:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们修改库存以匹配前面的代码片段，那么变量的值将是 `DavidInventory`，我们就不需要在命令行中传递值：
- en: '[PRE29]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This will produce the message `Hello DavidInventory! I am 35.187.81.127`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出信息 `Hello DavidInventory! I am 35.187.81.127`。
- en: 'The third way to define variables in Ansible is by defining them in the playbook
    itself. Take a look at the following playbook:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中定义变量的第三种方式是在 playbook 本身中定义。请看下面的 playbook：
- en: '[PRE30]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As simple as it sounds, once you define the variable in the `vars` section of
    your playbook, it becomes available; therefore, there is no need to specify the
    value anywhere else.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来很简单，一旦你在 playbook 的 `vars` 部分定义了变量，它就会变得可用；因此，其他地方不需要指定值。
- en: The fourth way to define variables is via files. Ansible is designed to be a
    self-documented component that can be easily understood by someone with not much
    experience in it. One of the ways in which Ansible facilitates the task of understanding
    playbooks is the possibility of writing every single configuration piece in a
    file. Variables are not the exemption, so Ansible will let you define variables
    in files or playbooks.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 定义变量的第四种方式是通过文件。Ansible 旨在成为一个自文档化的组件，便于没有太多经验的人理解。Ansible 让理解 playbook 任务变得更容易的一个方法就是可以将每一段配置写入文件。变量也不例外，因此
    Ansible 允许你在文件或 playbook 中定义变量。
- en: 'Let''s start with the files. Create a file called `vars.yml` in the same folder
    in which you are working (where your playbook and inventory are) with the following
    content:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从文件开始。在你工作的同一文件夹中（即包含 playbook 和库存的文件夹）创建一个名为 `vars.yml` 的文件，并添加以下内容：
- en: '[PRE31]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we can run the following command in order to use the variables file:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以运行以下命令来使用变量文件：
- en: '[PRE32]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: And if you check the output, it would be the same as the one from earlier.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看输出，它将与之前的输出相同。
- en: In this case, we have defined a new variable that we are not using (`yourName`),
    but that is fine. I just wanted to show you that Ansible won't complain if there
    are free variables, but it will raise an error if there are unbound interpolations.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们定义了一个新的变量（`yourName`），但我们并没有使用它，这也没关系。我只是想向你展示，如果存在未绑定的插值，Ansible 会报错，但如果有未使用的变量，它是不会抱怨的。
- en: 'In this case, we have included `vars.yml` in our playbook via the command line,
    referencing your local file with `@` in the beginning, but there is another possibility
    for using variable files in Ansible: including them from within the playbook.
    Let''s take a look at how it is done:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们通过命令行在剧本中包含了`vars.yml`，并且在文件名前面加上了`@`符号，然而在 Ansible 中还有另一种使用变量文件的方式：从剧本内部包含它们。让我们来看一下如何操作：
- en: '[PRE33]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In this case, we have used the `include_vars` module in our playbook. Now execute
    the playbook with the following command:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们在我们的剧本中使用了`include_vars`模块。现在，使用以下命令执行剧本：
- en: '[PRE34]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'You will get the following output:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 你将得到以下输出：
- en: '![](img/11991723-9f2a-4980-98fb-f6932730d6da.png)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11991723-9f2a-4980-98fb-f6932730d6da.png)'
- en: As you can see, there is an extra task that takes a file and injects the variables
    in the context.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，有一个额外的任务，它接受一个文件并将变量注入到上下文中。
- en: This module is quite flexible and there are several options to include variable
    files in our playbook. We have used the most straightforward one, but you can
    check out other options in the official documentation at [http://docs.ansible.com/ansible/include_vars_module.html](http://docs.ansible.com/ansible/include_vars_module.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模块非常灵活，有多种方式可以将变量文件包含到我们的剧本中。我们使用的是最直接的一种，但你可以在官方文档中查看其他选项：[http://docs.ansible.com/ansible/include_vars_module.html](http://docs.ansible.com/ansible/include_vars_module.html)。
- en: 'There is another possibility for including a variable file into our playbook,
    and it is using the `vars_files` directive in our playbook:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种将变量文件包含到剧本中的方法是使用剧本中的`vars_files`指令：
- en: '[PRE35]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will take the `vars.yml` file and inject all the defined variables into
    the context, making them available for use.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这将获取`vars.yml`文件，并将所有定义的变量注入到上下文中，使它们可以在后续使用。
- en: As you can see, Ansible is quite flexible around the definition of variables.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，Ansible 在定义变量方面非常灵活。
- en: 'There is another interesting way of setting up variables in Ansible that helps
    us further customize our playbooks: `set_fact`. Setting facts allows us to set
    variables dynamically in our playbooks. `Set_fact` can be used in combination
    with another interesting instruction called register. Let''s look at an example:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中，还有一种有趣的设置变量的方式，它帮助我们进一步自定义剧本：`set_fact`。设置事实允许我们在剧本中动态地设置变量。`set_fact`
    可以与另一个有趣的指令`register`结合使用。让我们看一个例子：
- en: '[PRE36]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: What we are doing here is basically setting a variable to true if the configuration
    folder of our app is empty (hypothetic configuration folder) so that we can regenerate
    it only when it is not present. This is done by making use of the instruction
    when that allows us to execute instructions conditionally. We will come back to
    it during this chapter.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的基本上是，如果我们应用的配置文件夹为空（假设的配置文件夹），就将变量设置为`true`，以便只有在它不存在时才会重新生成。这是通过使用`when`指令来实现的，它允许我们根据条件执行指令。我们将在本章后面回到这个话题。
- en: 'We have visited the most common ways of defining variables, but there is one
    question pending: what is the precedence of the different methods for creating
    variables?'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了最常见的定义变量的方法，但还有一个问题待解答：不同定义变量方法的优先级是什么？
- en: This is something that I have to query myself whenever I am working in a playbook,
    and the truth is that at the end of the day, you will use only a couple of methods
    to create variables so that it is not as important as it should be. In my case,
    I tend to create a file with variables (when not working with roles), and if I
    want to override a value, I do that on the command line (or environment variable),
    which is the highest priority in the chain. The complete list of variable precedence
    can be found at [http://docs.ansible.com/ansible/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](http://docs.ansible.com/ansible/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable).
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我在使用 playbook 时必须自问的问题，实际上，最终你只会使用几种方法来创建变量，因此它的重要性并不像它应该有的那样高。在我个人的做法中，当不使用角色时，我倾向于创建一个包含变量的文件，如果我需要覆盖某个值，我会在命令行（或环境变量）中进行设置，这也是链条中优先级最高的地方。完整的变量优先级列表可以在[http://docs.ansible.com/ansible/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable](http://docs.ansible.com/ansible/playbooks_variables.html#variable-precedence-where-should-i-put-a-variable)找到。
- en: Ansible remote facts
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 远程事实
- en: Remote facts in Ansible are a way to specify configuration on remote hosts either
    by an explicit configuration file or by a script that returns data about the server.
    In general, this feature is very useful for operations such as maintenance, setting
    up flags that specifically mark the host as out of the pool so that our playbooks
    have no effect in the hosts.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible 中的远程事实是一种通过显式配置文件或脚本来指定远程主机配置的方式，脚本返回有关服务器的数据。一般来说，这个功能对于执行诸如维护、设置专门标记主机为不在池中的标志等操作非常有用，以确保我们的
    playbook 对这些主机没有任何影响。
- en: 'Take a look at the following command (assuming the inventory from the previous
    example is present in the folder and the VM is running on Google Cloud Platform):'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下以下命令（假设之前示例中的清单文件已经在文件夹中，且虚拟机正在 Google Cloud Platform 上运行）：
- en: '[PRE37]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This will output an enormous amount of data (JSON-formatted data). This data
    is all the known facts about the remote host, such as the CPU type, machine ID,
    network interfaces, kernel version, and so on. They can be used within our playbooks,
    but they can also be extended to add more data that is controlled by the remote
    host without any local configuration.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出大量数据（JSON 格式的数据）。这些数据包含了关于远程主机的所有已知事实，例如 CPU 类型、机器 ID、网络接口、内核版本等。它们可以在我们的
    playbook 中使用，但也可以扩展，添加更多由远程主机控制的数据，而无需任何本地配置。
- en: 'In order to set up custom remote facts, we have several options, but at the
    end of the day, the custom facts are defined in JSON files by default under `/etc/ansible/facts.d/`.
    It is also possible to create an executable (a script) under the same folder so
    that Ansible will execute it and take the output as facts and add them to the
    facts scope. Take a look at the following file:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置自定义的远程事实，我们有几个选项，但最终，自定义事实默认是通过 JSON 文件在`/etc/ansible/facts.d/`下定义的。也可以在同一个文件夹中创建一个可执行文件（脚本），这样
    Ansible 会执行它并将输出作为事实，添加到事实范围内。来看一下下面的文件：
- en: '[PRE38]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Put into the remote box (the one used in all the examples from earlier) and
    create a file in `/etc/ansible/facts.d/example.facts` with the content from earlier*.*
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 将它放入远程主机（前面所有示例中使用的主机）中，并在`/etc/ansible/facts.d/example.facts`中创建一个包含之前内容的文件*。
- en: 'Once this is done, run the following command:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，运行以下命令：
- en: '[PRE39]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It almost looks magical, but the output of your command should now include
    the facts that you created earlier:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来几乎像是魔法一样，但现在你的命令输出应该包括你之前创建的事实：
- en: '[PRE40]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now they can be used in your playbook in the `ansible_local` variable, for example,
    to access `my_name`*:*
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 现在它们可以在你的 playbook 中通过`ansible_local`变量使用，例如，访问`my_name`*：
- en: '[PRE41]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: As mentioned earlier, Ansible can also gather facts from a script placed in
    the facts path. This script should have the `x` flag present, which indicates
    that it can be executed and have the extension `fact`. Let's look at a very interesting
    trick that I find quite useful. When I try to diagnose a failure in our systems,
    the first thing I tend to check is the CPU usage. The majority of the time, our
    systems are highly observable (monitored) so it is easy to check the CPU load,
    but sometimes, monitoring might not be in place.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Ansible 还可以从放置在事实路径中的脚本中收集事实。这个脚本应该有`x`标志，表示它是可执行的，并且应该有`.fact`扩展名。让我们来看一个我觉得非常有用的有趣技巧。当我尝试诊断我们系统中的故障时，我首先检查的就是
    CPU 使用率。大多数时候，我们的系统都是高度可观测的（已经在监控中），因此很容易检查 CPU 负载，但有时候，监控可能并未部署。
- en: 'First, go to the server that we have been using in the preceding examples and
    create a file in `/etc/ansible/facts.d/cpuload.fact` with the following content:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，进入我们在前面例子中使用的服务器，并在 `/etc/ansible/facts.d/cpuload.fact` 路径下创建一个文件，内容如下：
- en: '[PRE42]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is a simple script that will output JSON with information about the CPU
    load in your system. Once the file is created, give it execution permissions:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的脚本，它将输出包含系统 CPU 负载信息的 JSON 格式数据。文件创建后，给它执行权限：
- en: '`chmod u+x /etc/ansible/facts.d/cpuload.fact`'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod u+x /etc/ansible/facts.d/cpuload.fact`'
- en: 'And we are done. Before disconnecting the SSH session, make sure that the script
    works as expected by executing it:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 完成了。在断开 SSH 会话之前，确保通过执行脚本来验证它是否按预期工作：
- en: '[PRE43]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'This should output something like the following:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该输出类似以下内容：
- en: '[PRE44]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now it is time to test our scripted facts. What we are going to do is create
    a playbook that gets the CPU load and outputs it to the terminal with a debug
    message. This is the content:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候测试我们编写的事实了。我们将创建一个 playbook，获取 CPU 负载并通过调试消息将其输出到终端。内容如下：
- en: '[PRE45]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Run the preceding playbook:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 运行之前的 playbook：
- en: '[PRE46]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'You should get an output very similar to the following one:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会得到如下类似的输出：
- en: '![](img/5b4ec6b5-a321-4c38-b1f7-b98547d4afa4.png)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5b4ec6b5-a321-4c38-b1f7-b98547d4afa4.png)'
- en: Now we have a rudimentary tool to check the CPU load on our servers with a simple
    command, leveraging the host groups to Ansible.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了一个基础工具，可以通过一个简单的命令检查服务器上的 CPU 负载，利用主机组来管理 Ansible。
- en: 'One thing we have not explained is the first task that Ansible outputs in every
    playbook: gathering facts.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 有一件事我们还没解释，就是 Ansible 在每个 playbook 中输出的第一个任务：收集事实。
- en: This task gets all those facts that we have been talking about in this section
    and creates the context for the playbook to run, so in this case, the CPU load
    that we get is the CPU load gathered at the execution of that task.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务获取我们在本节中提到的所有事实，并为 playbook 执行创建上下文，因此在这种情况下，我们得到的 CPU 负载是执行该任务时收集到的 CPU
    负载。
- en: Ansible templates
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible 模板
- en: Templates are another powerful tool from Ansible. They allow us to render configuration
    files, application properties, and anything that can be stored in a human readable
    file.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 模板是 Ansible 的另一项强大工具。它们允许我们渲染配置文件、应用程序属性和任何可以存储在人类可读文件中的内容。
- en: 'Templates rely heavily on variables and a template engine called Jinja2 , which
    is used by Ansible to render the templates. First, we are going to install `ngnix`
    on our server with a simple playbook:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 模板高度依赖变量和模板引擎 Jinja2，Ansible 使用 Jinja2 渲染模板。首先，我们将使用一个简单的 playbook 在服务器上安装 `nginx`：
- en: '[PRE47]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'As you can see, it is very simple:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，这非常简单：
- en: Update the `apt cache`
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新 `apt 缓存`
- en: Upgrade the system
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 升级系统
- en: Install `nginx`
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 `nginx`
- en: 'Now, just run the preceding playbook using the VM created earlier:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只需运行之前创建的 VM 上的 playbook：
- en: '`ansible-playbook -i inventory tasks.yaml`'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '`ansible-playbook -i inventory tasks.yaml`'
- en: And when the playbook is finished, you should have `nginx` running in your remote
    server. In order to verify it, just open the browser and use the IP of your VM
    as URL. You should see the `nginx` welcome screen.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 当 playbook 执行完成后，你应该在远程服务器上看到 `nginx` 正在运行。为了验证这一点，只需打开浏览器，并使用你的 VM 的 IP 地址作为
    URL。你应该能看到 `nginx` 的欢迎页面。
- en: 'Now, we are going to create a template with the `nginx` configuration, where
    we can add or remove servers with templates in a fairly easy manner. Create a
    folder called `nginx-servers` in your current directory (where the playbook is)
    and add a file called `nginx.yml` with the following content:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个包含 `nginx` 配置的模板，在这个模板中我们可以轻松地添加或移除服务器。请在当前目录（即 playbook 所在的目录）下创建一个名为
    `nginx-servers` 的文件夹，并添加一个名为 `nginx.yml` 的文件，内容如下：
- en: '[PRE48]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let''s explain the file a bit:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们稍微解释一下这个文件：
- en: The system is upgraded using `apt`.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 系统通过 `apt` 进行升级。
- en: 'Using apt as well, `nginx` is installed. Note that Ansible uses a declarative
    approach to install packages: you state the name of the package and the state
    that the package should be in after the playbook is executed.'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样使用 `apt` 安装，`nginx` 被成功安装。请注意，Ansible 使用声明式方法来安装软件包：你声明软件包的名称以及执行 playbook
    后软件包的目标状态。
- en: The playbook renders the configuration for a virtual server in `nginx` from
    a template called `nginx-one.conf.j2`. We will come back to this in a second.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook 会从名为 `nginx-one.conf.j2` 的模板渲染虚拟服务器的 `nginx` 配置。我们稍后会详细讲解这一部分。
- en: The playbook reloads the `nginx` service so that the new configuration takes
    effect.
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Playbook 会重新加载 `nginx` 服务，使新配置生效。
- en: 'We have a few blocks missing in the preceding playbook. The first block is
    the file called `nginx-one.conf.j2`. This file is a template that is used to render
    the `nginx` configuration for a virtual host in the server. Let''s look at the
    content of that file:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 playbook 中我们缺少了几个模块。第一个模块是名为 `nginx-one.conf.j2` 的文件。这个文件是一个模板，用于渲染服务器中虚拟主机的
    `nginx` 配置。让我们来看一下该文件的内容：
- en: '[PRE49]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create a folder called `sites-enabled` and add the `nginx-one.conf.j2` file
    to it with the preceding content. This file is a standard `nginx` server block
    but with one particularity: we have a *server_one_port* as a placeholder for the
    port so that we can control the port where the `nginx` virtual host is exposed.
    This is very familiar to us: we are using the variables to render the templates.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `sites-enabled` 的文件夹，并将 `nginx-one.conf.j2` 文件添加到其中，内容如前所述。这个文件是一个标准的
    `nginx` 服务器块，但有一个特殊之处：我们将 *server_one_port* 作为端口的占位符，以便控制 `nginx` 虚拟主机暴露的端口。这对我们来说很熟悉：我们正在使用变量来渲染模板。
- en: 'The second block is the file called `vars.yml ()` with the following content:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个模块是名为 `vars.yml ()` 的文件，内容如下：
- en: '[PRE50]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This is very simple: it just defines the variables required to render the template
    from earlier. One thing that you need to be aware when using templates is that
    all the variables in the context can be accessed in it, from the facts gathered
    from the remote server to the variables defined everywhere.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常简单：它只是定义了渲染之前模板所需的变量。使用模板时需要注意的一点是，模板中的所有变量都可以在上下文中访问，从远程服务器收集的事实到各个地方定义的变量。
- en: 'Once we have everything in place (the two files from earlier, the playbook
    from earlier, and the inventory from the previous example), we can run the playbook
    as usual and verify that everything works as expected:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们把所有东西准备好（前面提到的两个文件、前面的 playbook 和之前示例中的清单），我们就可以像往常一样运行 playbook，并验证一切是否按预期工作：
- en: '[PRE51]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: If everything worked as expected, you should have a fully functional `nginx`
    server (serving the default page) in your VM in Google Cloud Platform on the port
    `3000`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，你应该在 Google Cloud Platform 上的虚拟机中拥有一个完全功能的 `nginx` 服务器（提供默认页面），并且运行在
    `3000` 端口。
- en: Google Cloud Platform has a deny by default policy in order to enhance security,
    so you might need to adjust the firewall to allow inbound traffic to certain ports.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: Google Cloud Platform 默认启用拒绝策略以增强安全性，因此你可能需要调整防火墙设置，以允许某些端口的入站流量。
- en: Flow control
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流程控制
- en: 'In Ansible, it is possible to use flow control statements such as loops or
    conditionals using variables as input. This can be used to repeat tasks on a certain
    dataset and avoid executing some tasks if a few conditions are not met: we might
    want to use different commands depending on the underlying system of our server.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中，可以使用流程控制语句，例如使用变量作为输入的循环或条件语句。这可以用来对某些数据集重复执行任务，或者在未满足某些条件时避免执行某些任务：例如，我们可能希望根据服务器的底层系统使用不同的命令。
- en: 'We have already seen an example of conditionals using the `when` clause in
    our previous examples, but let''s explain it a bit more:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们已经看过使用 `when` 子句的条件语句，但让我们再解释一下：
- en: '[PRE52]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The preceding code is very easy to read: a command is executed (ignoring the
    potential errors so our playbook continues), and it registers a variable called
    result. Then, we have two debug tasks:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码非常易读：执行一个命令（忽略可能出现的错误，以便我们的 playbook 继续执行），并注册一个名为 result 的变量。接下来，我们有两个调试任务：
- en: The first one will only be executed only if the `/bin/false` command fails
  id: totrans-309
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个技巧只有在 `/bin/false` 命令失败时才会被执行。
- en: The second one will be executed only if the `/bin/false` command succeeds
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个技巧只有在 `/bin/false` 命令成功执行后才会被执行。
- en: 'In this playbook, we are using two new tricks:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 playbook 中，我们使用了两个新技巧：
- en: '`ignore_errors`: With this clause, if the task fails, the playbook will continue
    executing the following tasks. This is very helpful if we want to test for assumptions
    in the system, for example, if some files are present or a certain network interface
    is configured.'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ignore_errors`：使用这个子句时，如果任务失败，playbook 将继续执行后续任务。如果我们想测试系统中的假设，比如某些文件是否存在或某个网络接口是否已配置，这个功能非常有用。'
- en: '`Pipe symbol (|)`: This symbol is called `pipe`. It is a Jinja2 expression
    used to filter values. In this case, we are using the failed and succeeded filters
    to return true or false depending on the outcome of the command. There are many
    filters that can be used on Jinja2 to work in a similar way as Unix pipes transforming
    the data that goes through them.'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`管道符号 (|)`：这个符号叫做 `pipe`。它是一个 Jinja2 表达式，用于过滤值。在这个例子中，我们使用了 failed 和 succeeded
    过滤器，根据命令的执行结果返回 true 或 false。Jinja2 提供了许多过滤器，可以像 Unix 管道一样处理数据。'
- en: 'Another type of control flow structure are loops. Let''s look at how loops
    work:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种控制流结构是循环。让我们来看看循环是如何工作的：
- en: '[PRE53]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we are using something new that we did not see at the time of explaining
    variables: they can have a structure such as lists and dictionaries. In this case,
    we are defining a list with a few names and outputting a message for each of them.
    Now it is time to run the playbook. Save the preceding content in a file called
    `loops.yml` and execute the following command:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了一个我们在解释变量时没有看到的新内容：它们可以具有诸如列表和字典这样的结构。在此示例中，我们定义了一个包含几个名字的列表，并为每个名字输出一条消息。现在是时候运行
    playbook 了。将前面的内容保存到名为 `loops.yml` 的文件中，并执行以下命令：
- en: '[PRE54]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'We will assume that the inventory is the same as the one used in the preceding
    examples. After finishing, you should see something similar to the following output
    in your Terminal:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设库存与前面示例中使用的相同。完成后，你应该在终端中看到类似以下的输出：
- en: '![](img/65c1b778-c1cd-45a4-9a34-cc2dbe8bdcaf.png)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![](img/65c1b778-c1cd-45a4-9a34-cc2dbe8bdcaf.png)'
- en: 'It is also possible to define a list using the compact version of the declaration.
    Take a look at the following statement:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以使用紧凑版本的声明来定义列表。请查看以下语句：
- en: '[PRE55]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'This can be redefined as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以重新定义如下：
- en: '[PRE56]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: And it is totally equivalent.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这完全是等效的。
- en: 'It is also possible to define dictionaries in Ansible and use them as variables.
    They can also be used as iterable elements, which enable us to give structure
    to our data:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Ansible 中也可以定义字典并将其用作变量。它们还可以作为可迭代元素使用，这使得我们能够为数据赋予结构：
- en: '[PRE57]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If you are familiar with software development, the preceding snippet will make
    perfect sense to you: a list of structured data (an array of objects) that holds
    information to be accessed by the key.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉软件开发，前面的代码片段应该能让你完全理解：一个结构化数据的列表（对象数组），它包含需要通过键来访问的信息。
- en: 'In the rest of the book, we will be using more advanced features of flow control
    structures in Ansible, and we will explain them as we go, but if you want to learn
    more about it, the following links might be useful for you:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将使用 Ansible 中更高级的流程控制结构，并在过程中进行解释。如果你想进一步了解，可以参考以下链接：
- en: Conditionals ([http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html))
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 条件语句 ([http://docs.ansible.com/ansible/playbooks_conditionals.html](http://docs.ansible.com/ansible/playbooks_conditionals.html))
- en: Loops ([http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html))
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环 ([http://docs.ansible.com/ansible/playbooks_loops.html](http://docs.ansible.com/ansible/playbooks_loops.html))
- en: Jinja2 Templating ([http://docs.ansible.com/ansible/playbooks_templating.html](http://docs.ansible.com/ansible/playbooks_templating.html))
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jinja2 模板 ([http://docs.ansible.com/ansible/playbooks_templating.html](http://docs.ansible.com/ansible/playbooks_templating.html))
- en: Roles
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色
- en: 'We have been working on few Ansible playbooks, and as you can imagine, there
    is a lot that can be abstracted from them into generic units of work. As of now,
    with our current knowledge of Ansible, the best thing we can do is use a naming
    convention for playbooks and files so that we don''t mix them, but Ansible provides
    a better approach to this: roles.'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直在编写一些 Ansible playbook，正如你可以想象的那样，其中有很多内容可以抽象成通用的工作单元。目前，凭借我们对 Ansible 的了解，我们能做的最好的事情就是为
    playbook 和文件使用命名约定，以免将它们混淆，但 Ansible 提供了一种更好的方法：角色。
- en: 'Think of roles as common reusable capabilities as you do with modules in software:
    a highly cohesive set of playbooks, variables, and resources that work together
    for one purpose. For example, if we are managing `nginx`, it makes sense to have
    all the related resources in a single module (role, in this case) in order to
    improve the reusability as well as clarity of the code.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 把角色想象成软件中常见的可重用功能模块：一组高度内聚的 playbook、变量和资源，它们共同协作，完成一个特定的目的。例如，如果我们在管理 `nginx`，将所有相关资源放在一个单独的模块（在此情况下是角色）中，可以提高代码的重用性和清晰度。
- en: 'One option would be including playbooks using Ansible features. Although we
    did not talk about it, with Ansible, it is possible to include YAML files with
    tasks to create dependencies, as shown in the following snippets:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一个选择是使用 Ansible 特性来包含 playbook。虽然我们之前没有讲过，但使用 Ansible，可以包含带任务的 YAML 文件来创建依赖关系，如下所示：
- en: '[PRE58]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Let''s explain what is going on. We can see two files included:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们解释一下发生了什么。我们可以看到两个包含的文件：
- en: The first include is what Ansible calls a play include. It is a fully functional
    playbook as is, which gets included in another playbook.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个包含的是 Ansible 所谓的 play 包含。它本身就是一个功能完整的 playbook，作为模块被包含到另一个 playbook 中。
- en: The second include is what Ansible calls a task include. It only includes a
    list of tasks.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个包含的是 Ansible 所谓的任务包含。它只包含一组任务列表。
- en: 'This can be explained easily by looking at the content of the two files. First,
    look at the content of `play-include.yml`:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看两个文件的内容，可以轻松地解释这一点。首先，查看 `play-include.yml` 的内容：
- en: '[PRE59]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Second, look at the content of `tasks-include.yml`:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，查看 `tasks-include.yml` 的内容：
- en: '[PRE60]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now we are going to execute the playbooks from earlier and see what the output
    is. Save the content of the first playbook on a file called `tasks.yml` and use
    the same inventory as on all the examples from earlier. Now run the following
    command:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将执行之前的 playbooks，看看输出结果是什么。将第一个 playbook 的内容保存在一个名为 `tasks.yml` 的文件中，并使用与之前所有示例相同的清单。现在运行以下命令：
- en: '[PRE61]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Once the execution has finished, let''s examine the output, which should be
    very similar to the following one:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 执行完成后，让我们检查输出，应该与以下内容非常相似：
- en: '![](img/12934b55-e2fe-40e2-81d0-23881833bda6.png)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![](img/12934b55-e2fe-40e2-81d0-23881833bda6.png)'
- en: 'Let''s explain this:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来解释一下：
- en: The play include (`play-include.yml`) gets executed by outputting the debug
    message in there.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: play 包含（`play-include.yml`）通过输出其中的调试信息来执行。
- en: The debug task in the main playbook gets executed.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 主 playbook 中的调试任务被执行。
- en: The task includes (`tasks-include.yml`) gets executed by executing the two debug
    messages included there.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务包含（`tasks-include.yml`）通过执行其中包含的两个调试信息来执行。
- en: It is not very complicated, but it gets easier if you play around a bit with
    the playbooks.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不复杂，但如果多尝试几次 playbooks，就会变得更容易。
- en: 'Although the preceding example can lead to a very clean and reusable set of
    files, there is a much better way of doing this: using roles. Roles are isolated
    sets of functionalities that allow an easy maintenance cycle like any other software
    component.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管之前的示例能够生成一个非常干净且可重用的文件集合，但有一个更好的方法：使用角色。角色是独立的功能集，允许像其他软件组件一样，轻松进行维护。
- en: 'Following the preceding example, we can rewrite it using three roles:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 根据之前的示例，我们可以使用三个角色重新编写它：
- en: The play include (`play-include.yml`)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: play 包含（`play-include.yml`）
- en: The main tasks (`tasks.yml`)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要任务（`tasks.yml`）
- en: The tasks include (`tasks-include.yml`)
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任务包含（`tasks-include.yml`）
- en: 'In order to start creating roles, first, create a new folder called `ansible-roles`
    and a folder called `roles` inside the same one. One thing that was not mentioned
    earlier is the fact that it is a good practice to create a set of folders to hold
    Ansible resources: tasks folders to hold the tasks, files folder to store all
    the files that need to be transferred to the remote hosts, and so on. In general,
    I agree with this setup, but for the examples, we just simplified it in order
    to make everything easier. For roles, this setup is mandatory. We need to create
    the folders as appropriated. In this case, as we are only going to use tasks to
    demonstrate how roles work; we will create the folder tasks inside of every role
    because otherwise, we won''t execute the tasks from the role.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 为了开始创建角色，首先创建一个名为 `ansible-roles` 的新文件夹，并在其中创建一个名为 `roles` 的文件夹。之前没有提到的一点是，创建一组文件夹来存放
    Ansible 资源是一个好习惯：任务文件夹存放任务，文件夹用于存储需要传输到远程主机的所有文件等等。一般来说，我同意这种设置，但为了示例的简单性，我们简化了配置。对于角色，这种设置是必须的。我们需要根据需要创建适当的文件夹。在这种情况下，由于我们只使用任务来演示角色的工作方式，我们将在每个角色内创建任务文件夹，因为如果不这样做，我们就无法执行角色中的任务。
- en: Inside the **roles** folder, we are going to create another folder called `play-include`,
    which is going to be the equivalent to `play-include.yml` from the preceding example
    but in the form of a role.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **roles** 文件夹内，我们将创建另一个名为 `play-include` 的文件夹，它将是前面示例中 `play-include.yml`
    的等效物，但以角色的形式呈现。
- en: 'Now it is time to create our first role playbook: create a file called `main.yml`
    and place it inside the `play-include/tasks/` folder. This is the content of the
    `main.yml file`:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建我们的第一个角色 playbook 了：创建一个名为 `main.yml` 的文件，并将其放置在 `play-include/tasks/`
    文件夹中。`main.yml` 文件的内容如下：
- en: '[PRE62]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Now it is time to add a second role called `main-tasks` by creating a folder
    in *roles* and adding a file called `main.yml` inside of `roles/main-tasks/tasks`:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候添加第二个角色，名为 `main-tasks`，方法是创建一个名为 *roles* 的文件夹，并在 `roles/main-tasks/tasks`
    文件夹中添加一个名为 `main.yml` 的文件：
- en: '[PRE63]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'And our third and last role is called `tasks-include`. Just create the folder
    as earlier (inside the roles folder) and add a file called `main.yml` to it inside
    of the tasks folder:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第三个也是最后一个角色叫做 `tasks-include`。像之前一样，创建文件夹（在 roles 文件夹内），并在 tasks 文件夹中添加一个名为
    `main.yml` 的文件：
- en: '[PRE64]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'And that''s it. You have created three roles that can be reused across different
    Ansible projects. Now it is time to use them. Create a file called `tasks.yml`
    in the root folder of your project (in my case, `ansible-roles`) and add the following
    content:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，你已经创建了三个可以在不同 Ansible 项目中重用的角色。现在是时候使用它们了。创建一个名为 `tasks.yml` 的文件，放在你项目的根文件夹中（在我的案例中是
    `ansible-roles`），并添加以下内容：
- en: '[PRE65]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'This is how your project should look after adding all the files from earlier:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在添加了之前所有文件后，你的项目应该呈现的样子：
- en: '![](img/8a102ec6-ec22-41d5-b132-a6e04eeb9f40.png)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8a102ec6-ec22-41d5-b132-a6e04eeb9f40.png)'
- en: 'The inventory is the same one as the previous examples (remember, the recommendation
    was to reuse the same VM). Now it is time to run our playbook:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 清单与之前示例中的相同（记住，推荐的是复用相同的虚拟机）。现在是时候运行我们的 playbook 了：
- en: '[PRE66]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'This will produce output similar to the following one:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成类似以下的输出：
- en: '![](img/a3806e54-7c42-4bcc-8f57-45a36f9dfc07.png)'
  id: totrans-373
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a3806e54-7c42-4bcc-8f57-45a36f9dfc07.png)'
- en: If we compare the output from the previous example, we can see that it is virtually
    the same except for the legend of the task, which indicates the role that the
    task is coming from.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们比较之前示例的输出，我们可以看到它几乎相同，唯一的区别是任务的说明，其中指示了任务来自哪个角色。
- en: In roles, we can also define variables and access to the variables defined in
    the global scope as well as many other features. As stated earlier, Ansible is
    big enough to write an entire book just on it, so we are scratching the surface
    of the important parts (under my criteria). As usual, the documentation in Ansible
    is pretty good, and if you want to learn more about roles, the information can
    be found at [https://docs.ansible.com/ansible-container/roles/index.html](https://docs.ansible.com/ansible-container/roles/index.html).
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 在角色中，我们还可以定义变量并访问全局作用域中定义的变量以及许多其他功能。正如之前所说，Ansible 足够庞大，完全可以写一本书，因此我们这里只是简单介绍了一些重要部分（根据我的标准）。如常，Ansible
    的文档相当不错，如果你想深入了解角色，可以访问 [https://docs.ansible.com/ansible-container/roles/index.html](https://docs.ansible.com/ansible-container/roles/index.html)
    查阅相关资料。
- en: If I can give you some advice regarding Ansible, it would be that you should
    always try to use roles. It doesn't matter how big or simple your project is;
    you will find out very soon that the isolation and reusability that roles provide
    at pretty much no cost are quite beneficial.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我能给你关于 Ansible 的一些建议，那就是你应该始终尝试使用角色。无论你的项目多大或多简单，你很快就会发现，角色所提供的隔离性和可重用性几乎不花成本，且非常有益。
- en: Ansible Tower
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Ansible Tower
- en: We have seen an extensive number of features from Ansible that are very useful
    to any DevOps engineer wanting to automate tasks in any IT department.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到 Ansible 提供了许多非常有用的功能，这些功能对任何希望在 IT 部门自动化任务的 DevOps 工程师来说都非常重要。
- en: 'There is one design challenge with Ansible, and it is the fact that the playbooks
    are run from your own computer against remote servers, as shown in the following
    figure:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 时有一个设计挑战，那就是 playbooks 是从你自己的计算机运行到远程服务器的，如下图所示：
- en: '![](img/87876d7f-92ee-419a-a0cb-943074ec6508.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
  zh: '![](img/87876d7f-92ee-419a-a0cb-943074ec6508.png)'
- en: This can be a problem because as you are aware by now, Ansible uses secrets
    (ansible-vault secrets) and, potentially, some sensible information that can be
    intercepted or stolen from a workstation. This is not a problem in Chef or Puppet
    as they follow the bastion host approach, but it might be a problem for companies
    to choose Ansible.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能是一个问题，因为正如你现在所了解的那样，Ansible 使用机密（ansible-vault secrets），并且可能涉及一些敏感信息，这些信息可能会被从工作站上拦截或窃取。在
    Chef 或 Puppet 中没有这个问题，因为它们遵循堡垒主机方法，但这可能是一些公司选择 Ansible 时遇到的问题。
- en: 'One of the solutions for it comes from Red Hat with the name Ansible Tower.
    This software gets installed in your IT infrastructure (in this case, Google Cloud
    Platform) and offers a UI to be operated in the same way as if a CI server was,
    enabling the role access control to Ansible playbooks as well as a security layer
    that is not present in plain Ansible: the secrets are kept in a server (Ansible
    Tower) inside your infrastructure and they never leave it.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个解决方案来自Red Hat，名为Ansible Tower。该软件安装在你的IT基础设施中（在本例中为Google Cloud Platform），并提供一个UI，操作方式类似于CI服务器，能够启用角色访问控制到Ansible剧本，并且添加了一个在普通Ansible中没有的安全层：机密信息保存在基础设施内的一个服务器（Ansible
    Tower）中，从未离开过该基础设施。
- en: Ansible Tower offers all the features present in Ansible so that you don't need
    to rewrite any playbook,; just adjust them to the new infrastructure geometry.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Tower提供了Ansible中所有的功能，因此你不需要重写任何剧本；只需根据新的基础设施几何形状进行调整。
- en: 'Let''s take a look at the following figure:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下以下的图示：
- en: '![](img/8e4ab03c-1813-4397-8004-cb74ec6e933e.png)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8e4ab03c-1813-4397-8004-cb74ec6e933e.png)'
- en: As you can see, now our Ansible host is inside of our infrastructure; therefore,
    it can be operated through a web interface enhancing the security of our IT operations.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，现在我们的Ansible主机已经在我们的基础设施内部；因此，它可以通过网页界面进行操作，从而增强了我们IT操作的安全性。
- en: Ansible Tower also offers an API that can be used to build integration points
    with our software or CI server.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Tower还提供了一个API，可以用来与我们的软件或CI服务器建立集成点。
- en: Ansible Tower is licensed by Red Hat, so if you want to use it in your company,
    a license needs to be purchased. At the time of writing this, there are not that
    many alternatives in the market and the ones that are available are not as feature-full
    as Ansible Tower. Also, the UI (as shown in the next screenshot) is very sleek,
    which, even though not a killer, is always something to be considered.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible Tower由Red Hat授权，因此如果你想在公司中使用它，需要购买许可证。在撰写本文时，市场上还没有太多的替代品，而且现有的替代品在功能上不如Ansible
    Tower。而且，它的UI（如下一张截图所示）非常简洁，虽然这并不是最重要的，但也总是值得考虑的因素。
- en: '![](img/8397aec5-e5b8-4dd7-8134-a32cc5d7eada.png)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8397aec5-e5b8-4dd7-8134-a32cc5d7eada.png)'
- en: Summary
  id: totrans-390
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, you learned about the main Ansible features, but obviously,
    we have not covered every single possibility, as it would take us a couple of
    books to master them. Also, there is another catch here: DevOps tools are evolving
    constantly.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了Ansible的主要功能，但显然，我们并没有覆盖所有的可能性，因为要掌握它们需要写好几本书。此外，还有一个需要注意的地方：DevOps工具正在不断发展。
- en: When you are working on the DevOps side of the IT world, you always need to
    be willing to learn new things on the fly.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在IT世界的DevOps领域工作时，你始终需要随时准备学习新知识。
- en: Ansible was originally created to fully provision VMs in the cloud (and on premises),
    but slowly, it is gravitating toward configuration management as more modern tools,
    such as Kubernetes or Docker Swarm, are increasing their market share, leveraging
    Docker into the full software development life cycle in a continuous delivery
    environment.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: Ansible最初是为了在云端（以及本地）完全配置虚拟机而创建的，但随着Kubernetes或Docker Swarm等现代工具逐渐占据市场份额，它正慢慢转向配置管理，将Docker整合到持续交付环境中的完整软件开发生命周期中。
- en: In the next chapter, you will learn more about Kubernetes and Docker Swarm as
    they are the next big things in DevOps. Kubernetes, particularly, is an orchestration
    tool that I think will take over all the others in the next few months or years
    as it offers all the resources needed by any IT company leveraging the experience
    that Google has accumulated through years of running software in containers.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习更多关于Kubernetes和Docker Swarm的内容，因为它们是DevOps领域中的下一个重要趋势。特别是Kubernetes，它是一个我认为将在未来几个月或几年内超越所有其他工具的编排工具，因为它提供了任何IT公司所需的所有资源，借助Google多年来在容器中运行软件的经验。
- en: In my opinion, container engines such as Docker are about to surpass the break-even
    and become the norm for all the software components and architectures of the main
    software companies around the world.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为，像Docker这样的容器引擎即将突破盈亏平衡点，成为全球主要软件公司所有软件组件和架构的常规工具。
