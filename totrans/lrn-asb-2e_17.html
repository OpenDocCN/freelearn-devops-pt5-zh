<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-245"><a id="_idTextAnchor766"/>17</h1>
<h1 id="_idParaDest-246"><a id="_idTextAnchor767"/>Next Steps with Ansible</h1>
<p>In this, our final chapter, we will discuss how you can integrate Ansible into your day-to-day workflows. We will cover continuous integration tools, monitoring tools, and troubleshooting.</p>
<p>We will discuss the following topics:</p>
<ul>
<li>Integrating with third-party services</li>
<li>How you can use Ansible to troubleshoot problems when they occur</li>
<li>Some real-world examples</li>
</ul>
<p>Let’s dive straight in and look at how we can hook our playbooks into third-party services.</p>
<h1 id="_idParaDest-247"><a id="_idTextAnchor768"/>Technical requirements</h1>
<p>This chapter will differ from previous ones. While code examples are given in the chapter and the GitHub repository, they will not be complete working examples. Instead, we will discuss integrating them into your projects so they are more of the art of the possible rather than fully formed examples.</p>
<h1 id="_idParaDest-248"><a id="_idTextAnchor769"/>Integrating with third-party services</h1>
<p>Although you may be running<a id="_idIndexMarker981"/> the playbooks yourself, it’s a good idea to keep a log of your playbook run or update other team members or departments with the results. Ansible has several modules that allow you to work with third-party services to provide real-time notifications.</p>
<p>Let’s start by looking at Slack.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor770"/>Slack</h2>
<p>Slack has rapidly become the preferred<a id="_idIndexMarker982"/> option for team-based collaboration<a id="_idIndexMarker983"/> services across different IT departments. One key benefit of Slack is its support for third-party applications via its App Directory; Ansible supports Slack Incoming Webhooks via t<a id="_idTextAnchor771"/>he <code>community.general.slack</code> module.</p>
<p>Remember, you can install the <code>community.general</code> collection if you don’t have it installed by running the following command:</p>
<pre class="console">
$ ansible-galaxy collection install community.general</pre> <p>Before we look at the Ansible code, we should quickly discuss how you create a Slack App and enable webhooks.</p>
<p>First, you must make your<a id="_idIndexMarker984"/> own Slack app; you can do this by visiting <a href="https://api.slack.com/apps/new">https://api.slack.com/apps/new</a>. Once there, click the <strong class="bold">Create an App</strong> button and select the <strong class="bold">From Scratch</strong> option. From here, you need to fill in the <strong class="bold">App Name</strong> and <strong class="bold">Pick a workspace to develop your app in</strong>, which for the majority of us will be your primary workspace, as you can see from the following screenshot:<a id="_idTextAnchor772"/></p>
<div><div><img alt="Figure 17.1 – Creating the Slack app" src="img/B21620_11_011.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – Creating the Slack app</p>
<p>Once the Slack App has been created, you will be taken to your new application settings page. In the left-hand menu, you should see an option for <strong class="bold">Incoming Webhooks</strong>. Go to this page and toggle the <strong class="bold">Activate Incoming Webhooks</strong> switch to <strong class="bold">On</strong>. This will extend the options and give you the option to <strong class="bold">Add New Webhook </strong><strong class="bold">to Workspace</strong>.</p>
<p>From here, you will need to select where you would like your Slack App to post; as you can see from the following screenshot, I selected the <strong class="bold">#</strong><strong class="bold">general</strong> channel:</p>
<p class="IMG---Figure"><a id="_idTextAnchor773"/></p>
<div><div><img alt="Figure 17.2 – Choosing where to post" src="img/B21620_11_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – Choosing where to post</p>
<p>Once selected, you <a id="_idIndexMarker985"/>will be taken<a id="_idIndexMarker986"/> back to the <strong class="bold">Incoming Webhooks</strong> page for your application; here, you will be given a Webhook URL, which should look something like the following, and you will need to make a note of this and keep it safe (the following one has been revoke<a id="_idTextAnchor774"/>d):</p>
<pre class="source-code">
https://hooks.slack.com/services/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</pre> <p>Now that we have everything we need to interact with Slack, we can examine the code. As mentioned at the start of the chapter, I will only go into some of the code, as much of it will already be familiar.</p>
<p>There is just a single variable we need to add, and it is the token used to identify and authenticate against the webhook we created: the token is everything after <code>https://hooks.slack.com/services/</code> in the webhook URL from Slack, so in my case, the variable, which I put in <code>group_vars/common.yml</code>, looks like this:</p>
<pre class="source-code">
slack:
  token: "TBCRVDMGA/B06RCMPD6R4/YBTo7ZXZHrRg57fvJXr1sg43"</pre> <p>As this token should be treated as a secret, I recommend also using Ansible Vault to encrypt the value, so to do this, you can run the following:</p>
<pre class="console">
$ ansible-vault encrypt_string 'TBCRVDMGA/B06RCMPD6R4/YBTo7ZXZHrRg57fvJXr1sg43' --name 'token'</pre> <p>The token in the repo<a id="_idIndexMarker987"/> is encrypted using Ansible<a id="_idIndexMarker988"/> Vault, and as it has been revoked, you will need to update it with your own.</p>
<p>By jumping str<a id="_idTextAnchor775"/>aight into <code>roles/slack/tasks/main.yml</code>, you can see that the playbook launches a resource group, virtual network, and subnet in Azure.</p>
<p>There are no changes to the first tasks that launch the Azure resources:</p>
<pre class="source-code">
- name: "Create the resource group"
  azure.azcollection.azure_rm_resourcegroup:
    name: "{{ resource_group_name }}"
    location: "{{ location }}"
    tags: "{{ common_tags }}"
  register: "resource_group_output"</pre> <p>Additionally, the debug task we used in previous chapters is still there; immediately after the debug task, we have the task (well, sort of) which sends the notification to Slack:</p>
<pre class="source-code">
- name: "Notify the team on Slack about the resource group status"
  include_t<a id="_idTextAnchor776"/>asks: slack_notify_generic.yml</pre> <p>As you can see, it triggers another task i<a id="_idTextAnchor777"/>n the <code>slack_notify_generic.yml</code> file, and we pass the registered output’s content as a set of variables, most of the them are self-explanatory:</p>
<pre class="source-code">
  vars:
    resource_changed: "{{ resource_group_output.changed }}"
    resource_type: "Resource Group"
    resource_name: "{{ resource_group_output.state.name }}"
    resource_location: "{{ resource_group_output.state.location }}"</pre> <p>The last two are a little different; this one takes the full resource ID and prefixes it with <code>https://portal.azure.com/#resource</code>, as the resource ID is the URL for the resource in Azure; this, together with the URL prefix, will give us a clickable link that will take the user directly to the resource when they follow it:</p>
<pre class="source-code">
    azure_portal_l<a id="_idTextAnchor778"/>ink: "https://portal.azure.com/#resource{{ resource_group_output.state.id }}"</pre> <p>The final variable generates<a id="_idIndexMarker989"/> a comma-separated<a id="_idIndexMarker990"/> list of tags and values using a Jinja2 template function:</p>
<pre class="source-code">
    resource_tags: &gt;
      {% for key, value in resource_group_output.state.tags.items() %}
      *{{ key }}:* {{ value }}{% if not loop.last %}, {% endif %}
      {% endfor %}</pre> <p>You might also have noticed that the <code>{{ key }}</code> variable has a <code>*</code> on either side; this is not part of the template function; this is the markdown syntax for <strong class="bold">bold</strong>, and it will style the contents as such.</p>
<p>Before we look at what is in <code>roles/slack/tasks/</code> <code>slack_notify_generic.yml</code>, let’s quickly discuss why we are taking this approach.</p>
<p>As we mentioned several times in the title, one of the main goals of automating our deployments is to streamline everything as much as possible. In this case, the task we are calling will be the standard throughout the playbook, and the only changes we need to make are the content.</p>
<p>So rather than repeating the <code>community.general.slack</code> task several times in our playbook, we can define it once and then call it multiple times. This means if we need to change something in the <code>community.general.slack</code> task, we only have to update it in one place.</p>
<p>The task itself has a little bit of logic added, so let’s review that now:</p>
<pre class="source-code">
- name: "Notify the team on Slack about resource cha<a id="_idTextAnchor779"/>nges"
  community.general.slack:
    token: "{{ slack.token }}"
    parse: "none"</pre> <p>As you can see from the preceding code, we are passing our webhook <code>token</code> and setting the <code>parse</code> option to <code>none</code>. This means that <code>community.general.slack</code> will not touch any content we post to the webhook to strip out formatting, etc.</p>
<p>Rather than sending<a id="_idIndexMarker991"/> a simple message, we use<a id="_idIndexMarker992"/> the <code>attachments</code> type. This will nicely format our message into blocks, and we can also set a status color based on whether there has been a change to the content or not:</p>
<pre class="source-code">
    attachments:
      - fallback: "Notification about Azure resource changes"</pre> <p>The logic for setting the color is as follows: here, we use the Boolean value of <code>true</code> or <code>false</code> that is passed by the <code>resource_changed</code> variable. If the variable equals <code>true</code>, it means that the resource has been changed, so we set the color to the pre-defined <code>warning</code> color, which is orange; otherwise, the color is set to <code>good</code>, which is green:</p>
<pre class="source-code">
        colo<a id="_idTextAnchor780"/>r: "{% if resource_changed %}warning{% else %}good{% endif %}"
        title: "Ansible: {{ resource_type }}"</pre> <p>Next, we have the message content: here, we are using a similar logic as we did for setting the color based on whether there has been a change to the resource or not:</p>
<pre class="source-code">
    <a id="_idTextAnchor781"/>    text: "{{ resource_name }} has been {% if resource_changed %}created/updated{% else %}checked (no changes){% endif %}."</pre> <p>Finally, we have the fields; each of these displays the information we are passing to the task in a block, apart from one:</p>
<pre class="source-code">
        fields:
          - title: "Location"
            value: "{{ resource_location }}"
            short: true
          - title: "Azure Portal"
            value: "&lt;{{ azure_portal_link }}|View in Azure Portal&gt;"
            short: true
          - title: "Tags"
            value: "{{ resource_tags }}"
            short: false</pre> <p>The value of the Azure portal link is a little different; Slack uses <strong class="bold">mrkdwn</strong>, a markup language similar<a id="_idIndexMarker993"/> to Markdown but with some differences, especially regarding formatting links. As you can see, we are setting this to the <a id="_idTextAnchor782"/>following:</p>
<pre class="source-code">
&lt;{{ azure_portal_link }}|View in Azure Portal&gt;</pre> <p>This is the mrkdwn syntax for creating a clickable link. It will link to the URL being passed in the <code>{{ azure_portal_link }}</code> variable. The text after the pipe <code>|</code> is the visible text that will appear in the Slack message and act as the clickable link.</p>
<p>When Slack renders<a id="_idIndexMarker994"/> this message, it will <a id="_idIndexMarker995"/>display <code>{{ azure_portal_link }}</code> variable, directing the user to the Azure Portal.</p>
<p>Now that we know what the playbook looks like, l<a id="_idTextAnchor783"/>et’s run it:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --ask-vault-pass</pre> <p>This will prompt you to provide a valuable password and then deploy the resources; in this case, we don’t need to know the output of running the playbook and should, instead, turn our attention to Slac<a id="_idTextAnchor784"/>k itself:</p>
<div><div><img alt="Figure 17.3 – First run of the playbook" src="img/B21620_11_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3 – First run of the playbook</p>
<p>As you can see from<a id="_idIndexMarker996"/> the preceding<a id="_idIndexMarker997"/> output, three resources have been added, so they are referred to as created/updated. The orange bar is on the left-hand side of the message.</p>
<p>Let’s now rerun the playbook using the following:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml --ask-vault-pass</pre> <p>You will see that the message now looks like this:</p>
<div><div><img alt="Figure 17.4 – Running the playbook a second time" src="img/B21620_11_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.4 – Running the playbook a second time</p>
<p>This time, there have been<a id="_idIndexMarker998"/> no changes, which the message<a id="_idIndexMarker999"/> reflects. The status is also showing green, so we can quickly see that there have been no changes.</p>
<p>The only thing I would add is that if you look at the code in the repo, you will notice that for the subnet, we are having to make some allowances:</p>
<ul>
<li><code>resource_location</code>: subnets don’t have a location, so we are using the one from the virtual network the subnet is being created in</li>
<li><code>azure_portal_link</code>: while an ID for the subnet is being returned, it doesn’t precisely match the logic we use to open the resource directly in the Azure portal, so we link to the virtual network where the subnet is configured</li>
<li><code>resource_tags</code>: you can’t add tags to a subnet, so we set the value to <code>N/A</code></li>
</ul>
<p>As you can see from the screens, this is useful for notifying others that your playbook is being run. It also gives you quick access to the resources being created/updated or checked and an audit trail of changes being made to your resources.</p>
<p>While the code we discussed<a id="_idIndexMarker1000"/> only applies to Slack<a id="_idIndexMarker1001"/> and the resources deployed in Microsoft Azure, the concept should apply to any integration supported by Ansible.</p>
<h2 id="_idParaDest-250"><a id="_idTextAnchor785"/>Other integrations</h2>
<p>Dozens of other integrations, both<a id="_idIndexMarker1002"/> community- and vendor-supported, are available on Ansible Galaxy. If you can’t find one for your use case and your target service has an API, you could quite quickly build an integration using the <code>ansible.builtin.uri</code> module, which is designed to interact with web APIs and services.</p>
<p>What follows are some example use cases for other integration modules.</p>
<h3>Say</h3>
<p>Most modern computers<a id="_idIndexMarker1003"/> come with some level of voice synthesis<a id="_idIndexMarker1004"/> built in; by using this module, you can have Ansible verbally inform you of the status of your playbook run:</p>
<pre class="source-code">
    - name: "Speak an update"
      community.general.say:
        msg: "Hello from Ansible running on {{ inventory_hostname }}"
        voice: "Zarvox"
      delegate_to: localhost</pre> <p>While this is fun, it isn’t very useful and could quickly become annoying<a id="_idTextAnchor786"/>, so let’s move on.</p>
<h3>Syslog</h3>
<p>Suppose you ship the <a id="_idTextAnchor787"/>log files<a id="_idIndexMarker1005"/> from your target<a id="_idIndexMarker1006"/> hosts. In that case, you may want to send the results of the playbook run to your target host machine syslog so that it is shipped to your central logging service<a id="_idIndexMarker1007"/> for use in ext<a id="_idTextAnchor788"/>ernal services such as an <strong class="bold">SIEM</strong>, which stands for <strong class="bold">security information and event </strong><strong class="bold">management</strong>, product:</p>
<pre class="source-code">
- name: "Send a message to the hosts syslog"
  community.general.syslogger:
    msg: "The task has completed and all is well"
    priority: "info"
    facility: "daemon"
    log_pid: "true"</pre> <p>This is a great way to register<a id="_idIndexMarker1008"/> that something has happened<a id="_idIndexMarker1009"/> on the target host in a way that logs it along with everything else that is happening on the target operating system.</p>
<h3>ServiceNow</h3>
<p>ServiceNow is enterprise-grade<a id="_idIndexMarker1010"/> IT service management<a id="_idIndexMarker1011"/> software from ServiceNow, Inc.</p>
<p>By using the <code>servicenow.servicenow.snow_record</code> module, your playbook can open incidents within your ServiceNow installation:</p>
<pre class="source-code">
- name: "Cre<a id="_idTextAnchor789"/>ate an incident in SNOW"
  servicenow.servicenow.snow_record:
    username: "{{ snow.username}}"
    password: "{{ snow.passord}}"
    instance: "{{ snow.instance }}"
    state: "present"
    data:
      short_description: "Ansible playbook run on {{ inventory_hostname }}"
      severity: 3
      priority: 2
  register: snow_incident_result</pre> <p>Once open, you can then add notes to them using something like the following:</p>
<pre class="source-code">
- name: "Update the SNOW incident with work notes"
  servicenow.servicenow.snow_record:
    username: "{{ snow.username}}"
    password: "{{ snow.passord}}"
    instance: "{{ snow.instance }}"
    state: present
    number: "{{snow_incident_result['record']['number']}}"
    data:
      work_notes : "{{ resource_name }} has been {% if resource_changed %}created/updated{% else %}checked (no changes){% endif %}."</pre> <p>At the end of the playbook run, you can close the incident, which will permanently record whatever information<a id="_idIndexMarker1012"/> you ship from your playbook<a id="_idIndexMarker1013"/> in your ITSM tool.</p>
<h3>Microsoft Teams</h3>
<p>While we covered Slack<a id="_idIndexMarker1014"/> as the primary example<a id="_idIndexMarker1015"/> in this chapter, Ansible also supports several Microsoft 365 products, including Microsoft Teams, via the <code>community.general.office_365_connector_card</code> module. Microsoft 365 Connector cards are very powerful, and their configuration and, by extension, the Ansible module<a id="_idIndexMarker1016"/> can get quite<a id="_idIndexMarker1017"/> complicated; so rather<a id="_idIndexMarker1018"/> than cover them here, I would recommend the following links as a starting point:</p>
<ul>
<li><a href="https://docs.ansible.com/ansible/latest/collections/community/general/office_365_connector_card_module.html">https://docs.ansible.com/ansible/latest/collections/community/general/office_365_connector_card_module.html</a></li>
<li><a href="https://learn.microsoft.com/en-us/microsoftteams/platform/task-modules-and-cards/what-are-cards">https://learn.microsoft.com/en-us/microsoftteams/platform/task-modules-and-cards/what-are-cards</a></li>
<li><a href="https://adaptivecards.io/">https://adaptivecards.io/</a></li>
</ul>
<p>As you can see from the preceding<a id="_idIndexMarker1019"/> links, connector<a id="_idIndexMarker1020"/> cards can be as simple or complicated as you want. However, configuring them is probably worth a chapter all by itself, so let’s move on.</p>
<h2 id="_idParaDest-251"><a id="_idTextAnchor790"/>Summary of third-party services</h2>
<p>One of the key takeaways <a id="_idIndexMarker1021"/>I hope you get from this book is that automation is great; it is not only a real time saver, but using tools such as the ones we covered in the previous chapter, <a href="B21620_16.xhtml#_idTextAnchor716"><em class="italic">Chapter 16</em></a>, <em class="italic">Introducing Ansible AWX and Red Hat Ansible Automation Platform</em>, can enable people who are not sys-admins or developers to execute their playbooks from a friendly web interface. We will look at this further in the final section of the chapter, where I will cover some real-world examples of how Ansible has been implemented in organizations I have worked with.</p>
<p>The modules we have covered in this section allow you to take your automation to the next level by not only allowing you to record the results but also automatically doing some housekeeping during your playbook run and having it notify your users.</p>
<p>For example, you need to deploy a new configuration to your server. Your service desk has made a change request for you to take action on the work within your ServiceNow installation.</p>
<p>Your playbook could be written so that before the change is actioned, it uses the fetch module to copy the configuration file to your Ansible Controller. The playbook could then use the <code>servicenow.servicenow.snow_record</code> module to attach a copy of the existing configuration file to the change request, proceed to make the changes, and then automatically update the change request with the results.</p>
<p>Before we look at some real-world examples, let’s take a look at how you can debug your playbooks as they are running.</p>
<h1 id="_idParaDest-252"><a id="_idTextAnchor791"/>The Ansible playbook debugger</h1>
<p>Ansible has a debugger <a id="_idIndexMarker1022"/>built in. Let’s look at how you can build this into your playbook by creating a simple playbook with an error. As we have just mentioned, we are going to write a playbook that uses the <code>community.general.say</code> module. The playbook itself looks like this:</p>
<pre class="source-code">
- name: "A simple playbook with<a id="_idTextAnchor792"/> a mistake"<a id="_idTextAnchor793"/>
  hosts:<a id="_idTextAnchor794"/> "localhost"
  debugger: "on_failed"
  vars:
    message: "The task has completed and all is well"
    voice: "Daniel"
  tasks:
    - name: "Say a message on your Ansible host"
      community.general.say:
        msg: "{{ massage }}"
        voice: "{{ voice }}"</pre> <p>There are two things to point out: the first is the mistake. As you can see, we are defining a variable named <code>message</code>, but when I came to use it in the task, I made a typo and entered <code>massage</code> instead. Luckily, as I developed the playbook, I instructed Ansible to use the interactive debugger whenever a task fails by setting the <code>debugger</code> option to <code>on_failed</code>.</p>
<h2 id="_idParaDest-253"><a id="_idTextAnchor795"/>Debugging the task</h2>
<p>Let’s run the playbook<a id="_idIndexMarker1023"/> and see what happens:</p>
<pre class="console">
$ ansible-playbook playbook.yml</pre> <p>The first problem is that we are not passing a host inventory file, so there will be warnings that only the localhost is available; this is fine, as we want to run the <code>Say</code> module only on our Ansible Controller anyway:</p>
<pre class="console">
[WARNING]: No inventory was parsed, only implicit localhost is available
[WARNING]: provided hosts list is empty, only localhost is available. Note that the implicit localhost does not match 'all'</pre> <p>Next, Ansible runs the play<a id="_idIndexMarker1024"/> itself; this should result in a fatal error:</p>
<pre class="console">
PLAY [A simple playbook with a mistake] *******************
TASK [Gathering Facts] ************************************
ok: [localhost]
TASK [Say a message on your Ansible host] *****************
fatal: [localhost]: FAILED! =&gt; {"msg": "The task includes an option with an undefined variable. The error was: 'massage' is undefined. 'massage' is undefined\n\nThe error appears to be in '/Users/russ.mckendrick/Code/Learn-Ansible-Second-Edition/Chapter17/debugger/playbook.yml': line 12, column 7, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n  tasks:\n    - name: \"Say a message on your Ansible host\"\n      ^ here\n"}</pre> <p>Typically, the playbook run will stop, and you will be returned to your shell; however, because we have instructed Ansible to drop into the interactive debugger, we now see the following prompt:</p>
<pre class="console">
[localhost] TASK: Say a message on your Ansible host (debug)&gt;</pre> <p>From here, we can start to investigate the problem a little more; for example, we can review the error by typing the following command:</p>
<pre class="console">
p result._result</pre> <p>In Ansible, when using the debug module, the <code>p</code> command is used to prettify the output of a variable or expression. It stands for <code>p result._result</code> in an Ansible debug<a id="_idIndexMarker1025"/> task, it will display the value of <code>result._result</code> in a more readable and formatted way. The <code>p</code> command uses the <code>pprint</code> (<strong class="bold">pretty-print</strong>) function from the Python standard library to format the output.</p>
<p>Once you hit the <em class="italic">Enter</em> key, the results <a id="_idIndexMarker1026"/>of the failed task will be returned:</p>
<pre class="console">
{'_ansible_no_log': False,
 'failed': True,
 'msg': 'The task includes an option with an undefined variable. The error was: \'massage\' is undefined. \'massage\' is undefined\n\nThe error appears to be in \'/Users/russ.mckendrick/Code/Learn-Ansible-Second-Edition/Chapter17/debugger/playbook.yml\': line 12, column 7, but may\nbe elsewhere in the file depending on the exact syntax problem.\n\nThe offending line appears to be:\n\n  tasks:\n    - name: "Say a message on your Ansible host"\n      ^ here\n'}</pre> <p>Let’s take a closer look at the variables used in the task by typing the following:</p>
<pre class="console">
p task.args</pre> <p>This will return the two arguments we are using in the task:</p>
<pre class="console">
{'msg': '{{ massage }}', 'voice': '{{ voice }}'}</pre> <p>Now, let’s look at the variables that are available to the task using the following:</p>
<pre class="console">
p task_vars</pre> <p>You may have noted that we instructed Ansible to execute the setup module as part of the playbook run, so the list of variables available to the task is very long:</p>
<pre class="console">
          'inventory_hostname': 'localhost',
          'inventory_hostname_short': 'localhost',
          'message': 'The task has completed and all is well',
          'module_setup': True,
          'omit': '__omit_place_holder__7da4853be448a08d857e98fbabe7afe1b7c97d00',
          'play_hosts': ['localhost'],
          'playbook_dir': '/Users/russ.mckendrick/Code/Learn-Ansible-Second-Edition/Chapter17/debugger',
          'voice': 'Daniel'},</pre> <p>As you can see, there is much information<a id="_idIndexMarker1027"/> about the environment in which our playbook is being executed. In the list of variables, you will notice that all the information gathered by the setup modules starts with <code>ansible_</code>, and our two variables are listed at the bottom.</p>
<p>We can find out more about these two variables by running the following commands:</p>
<pre class="console">
p task_vars['message']
p task_vars['voice']</pre> <p>This will display the contents of the variable:</p>
<pre class="console">
[localhost] TASK: Say a message on your Ansible host (debug)&gt; p task_vars['message']
'The task has completed and all is well'
[localhost] TASK: Say a message on your Ansible host (debug)&gt; p task_vars['voice']
'Daniel'</pre> <p>We know we are passing a misspelled variable to the <code>msg</code> argument, so we will make some changes on the fly and continue the playbook run. To do this, <a id="_idTextAnchor796"/>we are going to run the following command:</p>
<pre class="console">
task.args['msg'] = '{{ message }}'</pre> <p>This will update the argument to use the correct variable; we can now rerun the task by issuing the following command:</p>
<pre class="console">
redo</pre> <p>This will immediately rerun the task with the correct argument and, with any luck, you should hear, “<em class="italic">The task has completed, and all </em><em class="italic">is well</em>:”</p>
<pre class="console">
changed: [localhost]
PLAY RECAP ************************************************
localhost: ok=1  changed=1  unreachable=0  failed=0. skipped=0  rescued=0. ignored=0</pre> <p>As you can see from the preceding output, because we only have a single task, the playbook is completed. If we had more, it would carry on from where it left off. You can now update your playbook with the correct spelling and proceed with the rest of your day. Additionally, if we wanted to, we could<a id="_idIndexMarker1028"/> have typed either <code>continue</code> or <code>quit</code> to proceed or stop, respectively.</p>
<h2 id="_idParaDest-254"><a id="_idTextAnchor797"/>Summary of the Ansible debugger</h2>
<p>The Ansible debugger is a handy <a id="_idIndexMarker1029"/>option to enable when you are working on creating complex playbooks; for example, imagine that you have a playbook that takes about 20 minutes to run, but it throws an error somewhere toward the end, say, 18 minutes after you first run the playbook.</p>
<p>Having Ansible drop into the interactive debugger shell not only means you can see precisely what is and isn’t defined, but it also means you don’t have to blindly make changes to your playbook and then wait another 18 minutes to see whether those changes resolved the fatal error.</p>
<h1 id="_idParaDest-255"><a id="_idTextAnchor798"/>Some real-world examples</h1>
<p>Before we finish the chapter and the book, I will give a few examples of how I have used and interacted with Ansible over the last few years.</p>
<h2 id="_idParaDest-256"><a id="_idTextAnchor799"/>Automating a complex deployment</h2>
<p>In this example, an application<a id="_idIndexMarker1030"/> was distributed across several dozen servers in a public cloud. Each application component was installed on at least three different hosts and required updates in a specific order.</p>
<p>The application developers collaborated with the operations team to streamline the deployment process to create an Ansible Playbook. The playbook automated the following steps for each component of the application:</p>
<ol>
<li>Put the application into maintenance mode by connecting to the targeted hosts and executing a specific command.</li>
<li>Create snapshots of all the costs involved in the deployment, ensuring a rollback point if needed.</li>
<li>Initiate the deployment process by pulling the latest code from the designated GitHub repository and executing a series of commands to update the application.</li>
<li>Verify the deployment’s success by connecting to the application’s API and running a set of health checks on each targeted host.</li>
<li>If the deployment and health checks pass successfully, take the application out of maintenance mode and proceed to the next component. However, if any tests fail, halt the deployment immediately and execute commands to revert the hosts to the previously taken snapshots, ensuring a safe rollback.</li>
</ol>
<p>Prior to implementing Ansible<a id="_idIndexMarker1031"/> automation, the manual execution of these deployment steps took several hours, as the application and operations teams had to co-ordinate and follow the process meticulously. This manual approach made deployments challenging and prone to human errors.</p>
<p>By automating the deployment tasks using Ansible, the teams could focus on handling the exceptions that arose due to genuine issues rather than mistakes caused by manual execution. Before the automation was put in place, errors were common during almost every release, with many hosts and complex manual steps involved.</p>
<p>The introduction of Ansible automation significantly improved the deployment process, reducing the time required and minimizing the risk of human errors. The playbook ensured consistency, reliability, and repeatability across multiple deployments, enabling the teams to deploy the application components more frequently and with greater confidence.</p>
<p>This example demonstrates how Ansible can tackle complex deployment scenarios, streamline processes, and enhance collaboration between development and operations teams in a public cloud<a id="_idIndexMarker1032"/> environment.</p>
<h2 id="_idParaDest-257"><a id="_idTextAnchor800"/>Combining Ansible and other tools</h2>
<p>In this real-world scenario, we collaborated<a id="_idIndexMarker1033"/> with a team that had invested significant effort in developing their infrastructure automation using Terraform. Their Terraform code successfully deployed the infrastructure and performed basic host bootstrapping using a simple <code>cloud-init</code> script.</p>
<p>However, as the application requirements grew more complex, it became evident that additional automation was needed to effectively manage the application on the provisioned hosts. Instead of replacing the existing Terraform code, we introduced Ansible to complement the infrastructure automation.</p>
<p>To integrate Ansible with the existing Terraform workflow, we utilized the <code>community.general.terraform</code> module. This module allowed us to execute the Terraform deployment directly from within an Ansible playbook.</p>
<p>By leveraging this integration, we took the output generated by the Terraform deployment and passed the relevant information back to Ansible. This enabled Ansible to gather detailed information about the provisioned hosts and perform the necessary application bootstrapping tasks.</p>
<p>The combination of Terraform and Ansible proved to be a powerful solution:</p>
<ul>
<li>Terraform handled the infrastructure provisioning, ensuring the required resources were created and configured correctly in the target environment.</li>
<li>Ansible took over the application management, utilizing the host information provided by Terraform to configure and deploy the application components seamlessly.</li>
</ul>
<p>This approach allowed the team to maintain their existing Terraform codebase while extending the automation capabilities with Ansible. The integration between the two tools provided a seamless workflow, enabling the team to manage both the infrastructure and the application more effectively without having to throw away the code that they already had.</p>
<p>The team achieved a more comprehensive and efficient automation solution by choosing the right tools for specific tasks and leveraging their strengths. Terraforms infrastructure-as-code capabilities, combined<a id="_idIndexMarker1034"/> with Ansible’s application management and orchestration features, resulted in a robust and flexible automation pipeline.</p>
<h3>Deploying Ansible AWX</h3>
<p>As discussed in <a href="B21620_16.xhtml#_idTextAnchor716"><em class="italic">Chapter 16</em></a>, <em class="italic">Introducing Ansible AWX and Red Hat Ansible Automation Platform</em>, Ansible AWX<a id="_idIndexMarker1035"/> is a powerful tool that offers a wide range of features beyond the basics. In addition to the core functionalities, Ansible AWX provides capabilities such as surveys, integration with identity services such as Microsoft Entra, and <strong class="bold">role-based access controls</strong> (<strong class="bold">RBACs</strong>) that enable granular access <a id="_idIndexMarker1036"/>management for projects and templates.</p>
<p>Surveys in Ansible AWX allow you to create interactive forms that gather input from users before running a playbook. This feature is particularly useful when you need to collect specific information or parameters from end-users without exposing them to the underlying playbook complexities.</p>
<p>Integration with identity services, such as Microsoft Entra, enables seamless authentication and authorization for Ansible AWX users. This integration allows you to leverage existing user accounts and access controls, simplifying user management and ensuring secure access to Ansible AWX resources.</p>
<p>RBAC in Ansible AWX provides a flexible and granular way to manage user permissions. With RBAC, you can define roles and associate them with specific projects, templates, and other resources. This allows you to control who can access and execute specific playbooks, ensuring that users have the appropriate level of access based on their responsibilities and expertise.</p>
<p>In the following examples, we’ll explore how Ansible AWX has been utilized in various organizations that I have worked with to streamline processes, automate tasks, and empower teams to perform their duties effectively while maintaining security and governance.</p>
<h3>Provisioning virtual machines</h3>
<p>In this scenario, the IT team<a id="_idIndexMarker1037"/> needed to provide a self-service portal for developers to provision <strong class="bold">virtual machines</strong> (<strong class="bold">VMs</strong>) across different environments, such as development, staging, and production. Each environment had specific requirements and configurations.</p>
<p>To streamline the process, Ansible AWX was deployed, and a survey was created to capture the necessary information from the developers. The survey included fields for specifying the desired operating system, VM size, environment, and other relevant parameters.</p>
<p>Upon submitting the survey, Ansible AWX triggered a playbook that automated the provisioning process. Based on the survey responses, the playbook dynamically generated the appropriate VM configurations and provisioned the VMs in the specified environment.</p>
<p>Additionally, the playbook integrated with the organization’s ticketing system, automatically creating a ticket with the VM details and linking it to the change management process for tracking and auditing purposes.</p>
<p>By leveraging Ansible AWX and surveys, the IT team empowered developers to provision VMs on-demand while maintaining control and governance over the process.</p>
<h3>Managing application deployments</h3>
<p>In another use case, a software<a id="_idIndexMarker1038"/> development team needed to deploy their application across multiple environments, including development, QA, and production. Each environment had its own set of configurations and dependencies.</p>
<p>To simplify the deployment process, Ansible AWX was utilized. A survey was created to capture the necessary deployment parameters, such as the application version, target environment, and any specific configuration options.</p>
<p>The survey responses were then passed as variables to an Ansible playbook that was responsible for executing the deployment. The playbook handled the entire deployment process, including the following:</p>
<ul>
<li>Retrieving the specified application version from the artifact repository</li>
<li>Configuring the target environment based on the provided parameters</li>
<li>Deploying the application components and dependencies</li>
<li>Running post-deployment tests and health checks</li>
<li>Updating the deployment status in the organization’s project management tool</li>
</ul>
<p>By using Ansible AWX and surveys, the development team could initiate deployments through a user-friendly interface, ensuring consistency and reducing the risk of manual errors. The playbook automated the complex deployment steps, saving time and effort for the team who needed the deployment while freeing up the time of the team who would have done<a id="_idIndexMarker1039"/> the deployment.</p>
<h3>Updating DNS records</h3>
<p>In this example, the organization<a id="_idIndexMarker1040"/> managed multiple <strong class="bold">DNS</strong> (or, to give it its full name, <strong class="bold">domain name system</strong>) zones across different providers, and they needed to allow front-line support teams to update DNS records without granting them direct access to the providers’ management consoles.</p>
<p>To achieve this, Ansible AWX was used. A survey was created to capture the necessary information for updating DNS records. The survey included<a id="_idIndexMarker1041"/> fields specifying the domain name, record type (e.g., A, CNAME, MX), record value, and <strong class="bold">time to </strong><strong class="bold">live</strong> (<strong class="bold">TTL</strong>).</p>
<p>Upon submitting the survey, Ansible AWX triggered a playbook that automated the DNS record update process. The playbook performed the following steps:</p>
<ol>
<li>Validated the provided survey inputs to ensure data integrity and prevent invalid entries</li>
<li>Determined the appropriate DNS provider based on the domain name specified in the survey</li>
<li>Connected to the DNS provider’s API using the necessary credentials securely stored in Ansible Vault</li>
<li>Retrieved the existing DNS records for the specified domain and record type</li>
<li>Updated the DNS record with the new value and TTL provided in the survey</li>
<li>Saved the updated DNS record using the provider’s API</li>
<li>Logged the change in the organization’s change management system, such as ServiceNow, for tracking and auditing purposes</li>
</ol>
<p>By using Ansible AWX, the front-line support teams could easily update DNS records without requiring direct access to the DNS providers’ management consoles. The playbook automated the complex steps involved in updating DNS records across multiple providers, ensuring consistency and reducing the risk of errors.</p>
<p>Additionally, the integration with the change management system provided a centralized record of all DNS changes, enabling easy tracking, auditing, and compliance with the organization’s change control processes.</p>
<p>These examples demonstrate how Ansible AWX can be leveraged to run tasks and simplify processes for end-users across different domains, such as infrastructure provisioning and application deployment. By combining Ansible AWX with surveys and integrating with existing tools and processes, organizations can enable self-service capabilities while maintaining control<a id="_idIndexMarker1042"/> and governance over critical operations.</p>
<h1 id="_idParaDest-258"><a id="_idTextAnchor801"/>Summary</h1>
<p>We have reached the end of the chapter and our book. I have been trying to think of a way to summarize Ansible; I believe the summary from the first edition of <em class="italic">Learn Ansible</em> still stands.</p>
<p>In response to a technical recruiter who reached out to him with a job role that required at least three years of Ansible experience when the tool had only been available for a short time, Ansible creator Michael DeHaan said the following in a now-deleted Tweet:</p>
<p><em class="italic">“Anyone using Ansible for a few months is as good as anyone using Ansible for three years. It’s a simple tool </em><em class="italic">on purpose.”</em></p>
<p>That perfectly sums up my experience of Ansible and hopefully yours.</p>
<p>Once you know the basics, it is straightforward to move on and start building more complex playbooks quickly. These playbooks can assist with deploying basic code and applications as well as complex cloud and even physical architectures.</p>
<p>Reusing your roles and accessing an extensive collection of community-contributed roles and modules via Ansible Galaxy means you have many examples or quick starting points for your next project. So, you can roll your sleeves up and get stuck in a lot sooner than you would with other tools. Additionally, if Ansible cannot do something, the odds are that there is a tool it can integrate with to provide the missing functionality.</p>
<p>Going back to what we discussed back in <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing and Running Ansible</em>, being able to define your infrastructure and deployment in code in a repeatable and shareable way that encourages others to contribute to your playbooks should be the aim of starting to introduce Ansible into your day-to-day workflows.</p>
<p>Through this book, I hope you have begun to think of day-to-day tasks where Ansible could help you and save you time, and I wish you luck with developing your own playbooks.</p>
</div>
</body></html>