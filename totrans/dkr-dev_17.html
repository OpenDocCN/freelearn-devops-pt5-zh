<html><head></head><body>
		<div><h1 id="_idParaDest-296"><em class="italic"><a id="_idTextAnchor316"/>Chapter 14</em>: Advanced Docker Security – Secrets, Secret Commands, Tagging, and Labels</h1>
			<p>We've seen several examples so far of the need to use files that contain secrets. We can think of secrets as a generic term for the types of sensitive data that would typically be stored in config and ENV files, such as database access credentials or API tokens. Docker provides a handy method for securing this type of data and sharing it. For legacy systems using swarm mode instead of Kubernetes, having an understanding of how to apply security to these environments is important, as you may have to retroactively fix environments in your career.</p>
			<p>Along with managing secret data, we can also use labels and tags to help ensure we are working with security in mind. You've seen tags already in the previous chapter and we will explore these further later in this chapter.</p>
			<p>Additionally, we will explore how metadata labels can be used to provide extra information about a container and how to use the <code>security.txt</code> file.</p>
			<p>In this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>An introduction to securely storing secrets in Docker</li>
				<li>What secrets are and why we need them</li>
				<li>A walk through the Raft log file</li>
				<li>Adding, editing, and removing secrets from a swarm</li>
				<li>Using tags more effectively to ensure we use secure images</li>
				<li>Implementing metadata labels and the secrets.txt file</li>
			</ul>
			<p>Let's get started by looking at what Docker secrets are and why they are beneficial.</p>
			<h1 id="_idParaDest-297"><a id="_idTextAnchor317"/>Technical requirements</h1>
			<p>For this chapter, you will need to have access to a Linux machine running Docker. We recommend that you use the setup you have been using so far in this book.</p>
			<p>In addition to this, you will need an account on Docker Hub in order to access images located there. If you have not already set one up, you can do so via the following link:</p>
			<p><a href="https://hub.docker.com">https://hub.docker.com</a></p>
			<p>Finally, in order to explore using Docker secrets, you will need to set up at least two containers and use Docker's swarm feature. You can read more about swarm mode here: <a href="https://docs.docker.com/engine/swarm/">https://docs.docker.com/engine/swarm/</a></p>
			<p>Check out the following video to see the Code in Action:</p>
			<p><a href="https://bit.ly/3iDsjkA">https://bit.ly/3iDsjkA</a></p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor318"/>Securely storing secrets in Docker </h1>
			<p>An inevitable part of working with complex, networked software projects is having to deal with secret data. This can be a range of things such as private keys for SSH access, SSL certificates, passwords, and API keys.</p>
			<p>In order to share <a id="_idIndexMarker1062"/>secrets securely with multiple containers, you will, of course, need to avoid attempts to store the secret in the container itself in a fashion that allows a potential attacker to access it. This layer of abstraction is not only useful for managing different sets of credentials based upon the environment, but also provides an extra layer of security should the container be compromised in some fashion.</p>
			<p>Thankfully, Docker comes with a useful feature for achieving this goal. It is simply called Docker secrets. In <a id="_idIndexMarker1063"/>order to use this feature or the Kubernetes equivalent, you will need to implement swarm services or Kubernetes itself. As we have recommended elsewhere in this book, you may wish to avoid swarm services if possible, in favor of Kubernetes. However, you may have to work with legacy systems where they are in use, so understanding secrets in this case is important. With this in mind, containers should, therefore, run as a service.</p>
			<p>Mirantis, having purchased Docker, has pledged open-ended support for Docker Swarm <a id="_idIndexMarker1064"/>as of February 2020 (<a href="https://www.mirantis.com/blog/mirantis-will-continue-to-support-and-develop-docker-swarm/">https://www.mirantis.com/blog/mirantis-will-continue-to-support-and-develop-docker-swarm/</a>). You may be familiar with this concept from <a href="B11641_05_Final_NM_ePub.xhtml#_idTextAnchor080"><em class="italic">Chapter 5</em></a>, <em class="italic">Alternatives for Deploying and Running Containers in Production</em>; however, if you need a refresher you can follow the steps provided on the Docker website for getting started with swarm <a id="_idIndexMarker1065"/>mode as an alternative to Kubernetes if you wish:</p>
			<p><a href="https://docs.docker.com/engine/swarm/swarm-tutorial/">https://docs.docker.com/engine/swarm/swarm-tutorial/</a></p>
			<p>The secrets feature in both swarms and Kubernetes allows you to manage data such as passwords and API keys centrally and then securely share it with the containers of your choice. This avoids <a id="_idIndexMarker1066"/>having to hardcode values in an insecure fashion within the container, or having to allow all containers access to the sensitive data.</p>
			<p>Additionally, secrets, when shared with other containers in a swarm by Docker secrets, for example, are transferred over a secure connection encrypted via SSL/TLS. Let's now take a deeper look at how Docker secrets work at a fundamental level, including an important feature called the Raft log.</p>
			<h2 id="_idParaDest-299"><a id="_idTextAnchor319"/>The Raft log</h2>
			<p>In order to share content between swarm nodes, we need to ensure there is both consensus <a id="_idIndexMarker1067"/>and fault tolerance. In short, this means that all nodes in the network agree on some set of values to maintain a consistent state.</p>
			<p>The algorithm <a id="_idIndexMarker1068"/>that Docker Swarm uses <a id="_idIndexMarker1069"/>is called Raft. You can read more about the technical details in the paper <em class="italic">In Search of an Understandable Consensus Algorithm</em>, available at the Raft GitHub account:</p>
			<p><a href="https://raft.github.io/raft.pdf">https://raft.github.io/raft.pdf</a></p>
			<p>Docker Swarm <a id="_idIndexMarker1070"/>uses a file known as the Raft log file as part of its implementation of the algorithm. The benefit of this file is that it can be used for storing secrets, which subsequently have to be shared across 1 to <em class="italic">n</em> nodes. When a secret is added via the <code>docker secret</code> command, a value is added to the Raft log file and is then made available via a temporary filesystem, as seen in this example:</p>
			<pre>/run/secrets/apikey</pre>
			<p>And this in essence is how a secret can be shared between multiple Docker containers in a swarm. Reading the secret in an application will depend on what language you are using. For example, if you were modifying the ShipIt Clicker application you would be using JavaScript. If we had a secret such as an API key file, we could access it directly in the JavaScript source code using the <code>fs</code> module, as the following example demonstrates:</p>
			<pre>fs.readFile('/run/secrets/apikey', 'utf8')</pre>
			<p> As you <a id="_idIndexMarker1071"/>can see, this is a fairly simple approach. </p>
			<p>Although this file is encrypted, we can also add an extra layer of security through locking. </p>
			<p>Swarms can <a id="_idIndexMarker1072"/>be locked using the <code>--autolock</code> flag in order to prevent an attacker from decrypting the Raft log file.</p>
			<p>Refer to <a id="_idIndexMarker1073"/>the Docker documentation for more details:</p>
			<p><a href="https://docs.docker.com/engine/swarm/swarm_manager_locking/">https://docs.docker.com/engine/swarm/swarm_manager_locking/</a></p>
			<p>Now you have a basic understanding of how the Docker secrets feature works, let's look at how we use it.</p>
			<h1 id="_idParaDest-300"><a id="_idTextAnchor320"/>Adding, inspecting, and removing secrets  </h1>
			<p>We will now begin exploring the various commands associated with secrets.</p>
			<p>Feel free to <a id="_idIndexMarker1074"/>also substitute the commands in this section with <a id="_idIndexMarker1075"/>their Kubernetes equivalent if you wish to try those instead. You <a id="_idIndexMarker1076"/>can find the list of <code>kubectl</code> commands at <a href="https://kubernetes.io/docs/concepts/configuration/secret/">https://kubernetes.io/docs/concepts/configuration/secret/</a>.</p>
			<p>Or you <a id="_idIndexMarker1077"/>can refer back to <a href="B11641_08_Final_AM_ePub.xhtml#_idTextAnchor157"><em class="italic">Chapter 8</em></a>, <em class="italic">Deploying Docker Apps to Kubernetes</em>, where we created, described, retrieved, and edited secrets via <code>kubectl</code>.</p>
			<p>In relation to Docker, we will start by creating secrets first.</p>
			<h2 id="_idParaDest-301"><a id="_idTextAnchor321"/>Creating</h2>
			<p>The <code>create</code> command is <a id="_idIndexMarker1078"/>how we add a new secret to the Raft log file. Its basic format is the following:</p>
			<pre>docker secret create [OPTIONS] SECRET [file|-]</pre>
			<p>You may notice this is similar to the command in <code>kubectl</code>, which is <code>kubectl create secret</code>.</p>
			<p>When creating a secret, we can use the <code>-l</code> flag to add a label to the secret, such as the following:</p>
			<pre>docker secret create -l key=val api_key -</pre>
			<p>This allows <a id="_idIndexMarker1079"/>us to label values, so we know which environment <a id="_idIndexMarker1080"/>they are destined for. For example, we can add a key value for the environment such as <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>), <strong class="bold">Development</strong> (<strong class="bold">DEV</strong>), and <strong class="bold">Production </strong>(<strong class="bold">PROD</strong>).</p>
			<p>A secret <a id="_idIndexMarker1081"/>can also be a file. For example, if we want to add a private key, we might do the following:</p>
			<pre>docker secret create my_key ./id_rsa</pre>
			<p>If you wish to add/update a secret to a running service, you will need to use the <code>--secret-add</code> flag on the <code>update</code> command. See the following, for example:</p>
			<pre>docker service update --secret-add &lt;secret&gt; &lt;service&gt;</pre>
			<p>Having added a secret, let's explore how we can now review it.</p>
			<h2 id="_idParaDest-302"><a id="_idTextAnchor322"/>Inspecting</h2>
			<p>There are a <a id="_idIndexMarker1082"/>number of techniques we can use to examine Docker secrets. To list any secrets that have been added to the Raft log file, we can use the <code>ls</code> command:</p>
			<pre>$ docker secret ls.</pre>
			<p>On running this command, the current secrets will be displayed, as shown in the following example:</p>
			<pre>ID             NAME      CREATED         UPDATED
123345         my_key    2 weeks ago     2 weeks ago </pre>
			<p>We can gather more information about this secret using the <code>inspect</code> command.</p>
			<p>The format for this is the following:</p>
			<pre>docker secret inspect [OPTIONS] SECRET [SECRET...]</pre>
			<p>So, using the preceding example, we could run the command as follows:</p>
			<pre>$ docker secret inspect my_key</pre>
			<p>This will then <a id="_idIndexMarker1083"/>return a JSON object containing the ID, version created and updated dates, and the <code>spec</code> object containing the labels and name. An example of this output is now provided:</p>
			<pre>[
    {
        "ID": "ae4kfwe6s56sgop7vn1kxap59",
        "Version": {
            "Index": 10
        },
        "CreatedAt": "2020-01-26T07:15:29.674382561Z",
        "UpdatedAt": "2020-01-26T07:15:29.674382561Z",
        "Spec": {
            "Name": "my_key",
            "Labels": {
                "env": "dev",
                "rev": "20200126"
            }
        }
    }
]</pre>
			<p>We've added and inspected secrets, so now we shall explore how to delete them when we no longer need them.</p>
			<h2 id="_idParaDest-303"><a id="_idTextAnchor323"/>Deleting</h2>
			<p>Removing a <a id="_idIndexMarker1084"/>secret is as easy as adding one, and uses the same syntax as its Linux equivalent for removing files, that being <code>rm</code>.</p>
			<p>The format of the command is as follows:</p>
			<pre>docker secret rm SECRET [SECRET...]</pre>
			<p>In Kubernetes, the equivalent would be <code>kubectl delete secret</code>.</p>
			<p>To remove our example secret from earlier, we would run the command as follows:</p>
			<pre>docker secret rm my_key</pre>
			<p>If you wish to remove a secret being used by a current service, you will need to use the <code>--secret-rm</code> flag with the <code>update</code> command, such as in the following example:</p>
			<pre>docker service update --secret-rm &lt;secret&gt; &lt;service&gt;</pre>
			<p>As you can see, adding, removing, and inspecting secrets is simple. Let's now try the preceding commands out using the SSH file from <a href="B11641_13_Final_NM_ePub.xhtml#_idTextAnchor299"><em class="italic">Chapter 13</em></a>, <em class="italic">Docker Security Fundamentals and Best Practices</em>.</p>
			<h1 id="_idParaDest-304"><a id="_idTextAnchor324"/>Secrets in action – examples </h1>
			<p>It's now time <a id="_idIndexMarker1085"/>to try out the commands we just reviewed (<code>create</code>/<code>inspect</code>/<code>ls</code>/<code>rm</code>). Make sure your setup is configured to use swarms. You can also re-use the image from the previous chapter for this section. This can be obtained using the following command:</p>
			<pre>$ docker pull docker pull dockerfordevelopers/shipitclicker@ sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef 69804dbf01</pre>
			<p class="callout-heading">Important note</p>
			<p class="callout">Remember, you can use the <code>docker swarm init</code> command to initialize the swarm. Use the <code>--advertise-addr</code> flag with the IP address of your initial container as well.</p>
			<p>Previously, we used the following command to add an SSH private key for use with SCP to a single container:</p>
			<pre>$ docker build --build-arg ssh_prv_key="$(cat ~/.ssh/id_rsa_test)" .</pre>
			<p>To add this key to our swarm, we would use the following command:</p>
			<pre>$ docker secret create -l env=dev ssh_prv_key ~/.ssh/id_rsa_test</pre>
			<p>Here, we have <a id="_idIndexMarker1086"/>created a new secret with the same name as the build argument we used previously, and we output the content of our private key to it. We also included a label, which has a <code>key=val</code> pair denoting the environment we are working in. In this case, it is the development environment.</p>
			<p>Let's now check that we have added it correctly. We can do this by running the <code>ls</code> command:</p>
			<pre>$ docker secret ls
ID         NAME          CREATED        UPDATED
To5jj...   ssh_prv_key   1 minutes ago  1minutes ago</pre>
			<p>Here, we see the ID of the secret and the name. This looks good! Now let's execute the <code>inspect</code> command on the key using the <code>NAME</code> value:</p>
			<pre>$ docker secret inspect ssh_prv_key</pre>
			<p>You should now see a JSON object displayed, similar to the following:</p>
			<pre>[
    {
        "ID": "to5jjgshjqaddhf56ty89rss42",
        "Version": {
            "Index": 17
        },
        "CreatedAt": "2019-11-25T07:11:03.335174723Z",
        "UpdatedAt": "2019-11-25T07:11:03.335174723Z",
        "Spec": {
            "Name": "ssh_prv_key",
            "Labels": {
                "env": "dev",
                "rev": "20181125"
            }
        }
    }
]</pre>
			<p>If you have multiple containers in your swarm, then you can grant them access to this secret. The following <a id="_idIndexMarker1087"/>example demonstrates how we can send the secret we just created to a new container that uses our example image:</p>
			<pre>$ docker service create --name second_container --secret source=ssh_prv_key,target=second_ssh_prv_key,mode=0400 dockerfordevelopers/shipitclicker@ sha256:39eda93d15866957feaee28f8fc5adb545276a64147445c64992ef 69804dbf01</pre>
			<p>Here, the <code>--secret source</code> value is set to the name of the Docker secret we created. We are then going to store it in the variable defined in the target value. For clarity, we have called this <code>second_ssh_prv_key</code>.  The mode has been set to <code>0400</code> to make the secret accessible and then chosen our tagged image as the source image for the <code>create</code> command.</p>
			<p>To confirm the secret is available, we can check the temporary filesystem we discussed earlier. For this, you will need to grab the container ID of the new container. You can use the <code>docker ps</code> command for this.</p>
			<p>Next, use the container ID as follows:</p>
			<pre>$ docker exec -it &lt;id&gt; cat /run/secrets/second_ssh_prv_key</pre>
			<p>You should see that the contents of the secret are the same as those you passed into the first container, namely the private SSH key we have been testing with so far.</p>
			<p class="callout-heading">Other options</p>
			<p class="callout">In addition to using native Docker and Kubernetes tools, a variety of other options exist for storing secrets in cloud-based systems. AWS, GCP, and Azure offer native support, and HashiCorp <a id="_idIndexMarker1088"/>provides a comprehensive cloud-agnostic secrets-managing mechanism in the form of HashiCorp Vault, at <a href="https://www.vaultproject.io/">https://www.vaultproject.io/</a>.</p>
			<p>We are <a id="_idIndexMarker1089"/>now going to build upon our knowledge of Docker secrets by understanding how tags can be used.</p>
			<h1 id="_idParaDest-305"><a id="_idTextAnchor325"/>Docker tags for security</h1>
			<p>We've just seen how we can make sure we are sharing secrets securely between containers in a swarm. In <a href="B11641_12_Final_NM_ePub.xhtml#_idTextAnchor278"><em class="italic">Chapter 12</em></a>, <em class="italic">Introduction to Container Security</em>, we gained an appreciation <a id="_idIndexMarker1090"/>for how to use tags combined with other security features, to ensure we use the correct image.</p>
			<p>Now, we'll see how these two worlds can intersect by using tags with secrets and labels so we can annotate which environment a given secret and tag are used in.</p>
			<p>As a good security practice, we should always use different secrets for different environments. For example, the passwords for database access in your development, staging, and production instances should not be the same. Typically, as part of your development process, you will likely be using newer versions of containers in research, development, and QA environments compared to production.</p>
			<p>We can use Docker tags to help ensure that once we have credentials/secrets set up for a development environment, we are also pulling in the right image as well; that is, the one we intended to use for development purposes with the development credentials we created. Using fixed tags provides a layer of security through immutability and prevents an experimental image that may contain security flaws from accidentally being used outside of the development environment.</p>
			<p>Typically, a methodology such as semantic versioning (<a href="https://semver.org/">https://semver.org/</a>) should be in place. This will result in tags using a format that communicates the level of change you should expect when using the release. Major version numbers indicate a backward-incompatible set of changes. A minor release is usually a new feature to an existing release. Finally, we have a patch release, which could be a small security fix or similar. A typical format might be the following:</p>
			<pre>1.1.2</pre>
			<p>When choosing the tag, in line with your versioning system, choose the one that most closely matches the environment you want to deploy in. For example, choose <code>:1.1.2-dev</code> over <code>:1</code>.</p>
			<p>In this instance, you know you will be pulling the patch release. You can then deploy credentials via <code>docker secret</code>, specifically for this build and for the environment you are deploying it to. One useful <a id="_idIndexMarker1091"/>method is to pair up the secret label with the tag version you are using, as in the following code, for example:</p>
			<pre>$docker secret create  --label ver=1.1.2-dev \
                       --label env=dev \
                       ssh_prv_key ~/.ssh/id_rsa_test</pre>
			<p>In this example, a secret has been created (an SSH key) and we know it should be used with tag version <code>1.1.2</code> and that this is a development environment. Here, the labels provide annotations to give us the context of the secret. Simple techniques like this can help to provide more information to an engineering team and avoid a production credential from accidentally being used with an experimental development container or in the wrong environment.</p>
			<p>We've seen how we can combine tags, secrets, and labels. Let's now look at other labeling options.</p>
			<h1 id="_idParaDest-306"><a id="_idTextAnchor326"/>Using labels for metadata application </h1>
			<p>Metadata labels <a id="_idIndexMarker1092"/>are a way of annotating your containers with extra information to provide development teams with useful facts. This can be useful for other developers on your team when they need to understand key features of the image, such as its version and a description.</p>
			<p>We saw with the <code>docker secrets</code> command how we could add labels via the command line. With metadata labels, we can also add labels to the Dockerfile so that when we build out a new container, this information is baked in.</p>
			<p>A label takes the following format:</p>
			<pre>LABEL key=value</pre>
			<p>Building upon our preceding example, we can set the version inside of our container via the Dockerfile as follows:</p>
			<pre>LABEL "version"="1.1.2-test"
LABEL "description"=" Development environment container for testing the newest security patch. Not for produ<a id="_idTextAnchor327"/>ction release yet"</pre>
			<p>Once you've <a id="_idIndexMarker1093"/>built out a container, you can view any of the metadata you have added using the <code>docker inspect</code> command:</p>
			<pre>"Labels" :{
       "version"="1.1.2-test",
       "description"=" Development environment container for testing the newest security patch. Not for production release yet"
}</pre>
			<p>When releasing software for public consumption, you should consider also linking to a <code>security.txt</code> file. Like a code of conduct or contributors' guide, this provides a mechanism to alert security researchers on how to responsibly disclose any security issues they may find with your software.</p>
			<p>You can <a id="_idIndexMarker1094"/>automatically generate a <code>security.txt</code> file from the following website:</p>
			<p><a href="https://securitytxt.org/">https://securitytxt.org/</a></p>
			<p>Save this file to your code repository, and then link it via <code>LABEL</code> in your Dockerfile as in the following example:</p>
			<pre>LABEL "security.txt"="https://respository.example.com/my_project/security.txt"</pre>
			<p>That wraps up our guide to secrets, tags, and labels. Let's recap what we have learned so far.</p>
			<h1 id="_idParaDest-307"><a id="_idTextAnchor328"/>Summary</h1>
			<p>In this chapter, we learned all about Docker secrets, the counterpart to Kubernetes secrets. We saw how this feature can be used to securely share sensitive data between containers in a swarm if you need to work with this technology instead of Kubernetes. We also learned this can be useful for segmenting sets of credentials based upon the environment you are working in. Finally, we walked through how we can create, inspect, and delete them. </p>
			<p>Following this, we looked at tags once again and discussed how these can be used to ensure the right image is being pulled from the right environment. A combination of environment-based secrets and tags were shown to help you secure your development processes further.</p>
			<p>Finally, we discussed how containers can be annotated with metadata labels. This also included using the <code>security.txt</code> file.</p>
			<p>In the next chapter, we will explore how third-party tools can be used to help secure our containers and enforce some of the practices we have learned so far.</p>
		</div>
	</body></html>