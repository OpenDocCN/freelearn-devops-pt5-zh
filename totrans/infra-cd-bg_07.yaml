- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Leveraging CI/CD in the Cloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have discovered that **Infrastructure as Code** (**IaC**) has become an essential
    practice for modern development, enabling developers to manage infrastructure
    through code rather than manually configuring it.
  prefs: []
  type: TYPE_NORMAL
- en: However, deploying our infrastructure from a local machine, which we have been
    doing until now, is no longer sufficient for large-scale systems.
  prefs: []
  type: TYPE_NORMAL
- en: This is where **Continuous Integration/Continuous Deployment** (**CI/CD**) comes
    into play; it automates the deployment process and provides consistent and reliable
    infrastructure deployment.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explore leveraging CI/CD in the cloud to deploy our IaC. We
    will focus on the popular CI/CD tool, **GitHub Actions**, which can run workflows
    triggered by different events, such as pull requests or code commits. We will
    explore how to use GitHub Actions to run Terraform and Ansible code in both public
    clouds we covered in [*Chapter 4*](B19537_04.xhtml#_idTextAnchor151), *Deploying
    to Microsoft Azure*, and [*Chapter 5*](B19537_05.xhtml#_idTextAnchor268), *Deploying
    to Amazon* *Web Services*.
  prefs: []
  type: TYPE_NORMAL
- en: We will also cover essential security practices such as managing secrets in
    GitHub Actions and monitoring and maintaining the deployment once it runs. By
    the end of this chapter, you will understand how to leverage CI/CD in the cloud
    for your IaC projects using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Terraform using GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Ansible using GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we roll our sleeves up and dive into the code, we should discuss the
    CI/CD tool we will use to deploy our infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The source code for this chapter is available here: [https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07](https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, what is GitHub Actions? GitHub Actions is an automation platform that allows
    developers to create workflows to automate software development tasks, which in
    our case, means managing and deploying our IaC workloads.
  prefs: []
  type: TYPE_NORMAL
- en: The beta of GitHub Actions was first launched in mid-2019\. The initial release
    of GitHub Actions allowed a select number of developers to create and share actions
    that could be used to automate repetitive tasks in their development workflow.
    It was launched as a competitor to other popular automation platforms such as
    Jenkins, Travis CI, and CircleCI.
  prefs: []
  type: TYPE_NORMAL
- en: 'GitHub Actions is based on several concepts, and the ones which will be covered
    in detail in this chapter are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Workflows**: These are a series of tasks that are automated using GitHub
    Actions. Workflows are defined in YAML files that are stored in the repository.
    Workflows can be triggered by various events, such as pushing code to the repository,
    creating a pull request, or scheduling a job.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Jobs**: These are the individual units of work performed within a workflow.
    A workflow can have multiple jobs, each running on a different platform or environment.
    Jobs can be run in parallel or sequentially, depending on the workflow requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Steps**: These are the individual tasks that make up a job. Each step can
    be a shell command, a script, or an action. Actions are pre-built units of work
    that can be used to automate everyday development tasks, such as building and
    testing code, deploying applications, and sending notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Events**: The trigger workflows and GitHub Actions support many event types,
    including pushes to the repository, pull requests, scheduled events, and manual
    triggers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub Actions is a powerful automation platform that allows developers to automate
    many tasks in their development workflow. With its flexible and customizable workflows,
    support for various events, and pre-built actions, GitHub Actions has become an
    essential tool for many teams.
  prefs: []
  type: TYPE_NORMAL
- en: With its continued development and new features, GitHub Actions is set to establish
    itself as the leading CI/CD automation platform.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than talking any more about GitHub Actions, let’s roll up our sleeves
    and look at how to run Terraform using it.
  prefs: []
  type: TYPE_NORMAL
- en: Running Terraform using GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last four chapters, we have talked about Terraform a lot – however, we
    are yet to address the elephant in the room – state files.
  prefs: []
  type: TYPE_NORMAL
- en: As we have been running Terraform locally, we haven’t really needed to talk
    about state files in too much detail yet, so let’s look at them now before we
    discuss how we can run Terraform using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform state files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every time we run Terraform, a file called `terraform.tfstate` is either created,
    updated, or read. It is a JSON formatted file containing information about the
    resources created or modified by Terraform. It includes details such as the IDs,
    IP addresses, and other metadata associated with each resource we manage with
    Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform uses this file to keep track of the current state of the infrastructure
    to determine what changes must be made when you modify your infrastructure code.
  prefs: []
  type: TYPE_NORMAL
- en: The state file is absolutely critical to the correct operation of Terraform.
    It ensures that Terraform can accurately determine what changes need to be made
    to the infrastructure when you run the `terraform` `apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: Without a state file, Terraform would be unable to determine what changes to
    make to your infrastructure, which could result in errors or unexpected behaviors
    – for example, the termination and redeployment of a resource.
  prefs: []
  type: TYPE_NORMAL
- en: It is also important to note that a Terraform state file should be treated as
    sensitive information; it contains details about your infrastructure resources
    and also potentially sensitive information, such as passwords if you have used
    Terraform to generate them.
  prefs: []
  type: TYPE_NORMAL
- en: This means we must ensure that the state file is securely stored and only accessible
    to authorized users.
  prefs: []
  type: TYPE_NORMAL
- en: So why are we only talking about this now?
  prefs: []
  type: TYPE_NORMAL
- en: Well, services such as GitHub Actions are designed to provide compute resources
    for a short amount of time to execute a workflow, making them ephemeral, which
    means that there is no fixed underlying storage, so once the workflow has been
    completed, the compute resource is terminated, and everything is lost.
  prefs: []
  type: TYPE_NORMAL
- en: To support this, Terraform allows you to use backends to store your state files;
    as you may have already guessed, the default storage option is local storage,
    which will store the file in the same folder as the Terraform code you are executing.
    You can also use external blob storage such as Amazon `s3`) or Azure storage accounts
    (`azurerm`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how you would use an Azure storage account called
    `satfbeiac1234` in a resource group called `rg-terraform-state-uks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `container_name` parameter, in the case of an Azure storage account, is
    the blob container, which, if you were thinking of the Azure storage account as
    a filesystem, then this would be the folder name, and `key` is the name of the
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration for Amazon S3 is not too dissimilar, as you can see from
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here we are letting Terraform know the bucket name, the path to our file, and
    the region in which the Amazon S3 bucket is hosted.
  prefs: []
  type: TYPE_NORMAL
- en: One thing that needs to be added to the preceding code is how the Azure storage
    account or Amazon S3 bucket is created in the first place and how Terraform authenticates
    against the cloud provider to be able to read and write to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than discuss here, let’s dive into an example GitHub action and find
    out.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am going to concentrate on Microsoft Azure in this chapter. So, as we are
    not using our locally installed copy of the Azure **command-line interface** (**CLI**),
    we need to generate some credentials to use and grant access to our Azure subscription.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the **Universally Unique Identifiers** (**UUIDs**) in the following
    list are just examples; please ensure you replace them with your own where prompted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we are going to create a service principal using the following
    command. When you run it, make sure you replace the subscription ID with your
    own subscription ID, which you can find in the Azure portal under **Subscriptions**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will give something similar to the following output, which starts with
    an important message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As per the preceding message, ensure that you make a note of the output in
    a safe place, as it will be the only time you will be able to get the password
    that is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have the details and have granted the newly created `Contributor`
    service principal access to our Azure subscription, we can move on to GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: We first need to enter some secrets and variables in the GitHub repository to
    configure the GitHub action.
  prefs: []
  type: TYPE_NORMAL
- en: I have started with an empty GitHub repository called `Terraform-github-actions-example`;
    if you are following along, I recommend creating a test repo and copying the code
    from the repository accompanying this title across to your repo.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, the first thing we need to do is add the secrets and variables.
    To do this, go to your repo and click on **Settings**. Once the **Settings** page
    is open, you should see **Secrets and variables** in the left-hand side menu;
    when you click on it, it will expand a submenu with **Actions**, **Codespaces**,
    and **Dependabot** listed.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you might have guessed, you need to click on **Actions**. This should present
    you with something that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – The Actions option on the Secrets and variables settings page](img/Figure_7.01_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – The Actions option on the Secrets and variables settings page
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **New repository secret** button and enter the secrets
    detailed in the following table, make sure that you enter the name exactly like
    it is written in the table, as the GitHub action workflow code will reference
    the name when it is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Secret Content** |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_CLIENT_ID` | This is the `appId` value from the output of the command
    that added the service principal. From the example output, this would be `019f16d2-552b-43ff-8eb8-6c87b13d47f9`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_CLIENT_SECRET` | This is the *password* from the output of when we ran
    the command that added the service principal. From the example output, this would
    be `6t3Rq~vT.cL9y7zN_apCvGANvAg7_v6wiBb1eboQ`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM _SUBSCRIPTION_ID` | This is the *subscription ID* you used as the scope
    to add the service principal. From the example output, this would be `3a52ef17-7e42-4f89-9a43-9a23c517cf1a`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_TENANT_ID` | This is the *tenant* from the output of when we ran the
    command that added the service principal. From the example output, this would
    be `8a7e32c4-5732-4e57-8d8c-dfca4b1e4d4a`. |'
  prefs: []
  type: TYPE_TB
- en: 'Once you have entered the four secrets detailed in the preceding table, you
    will use the credentials to authenticate against your Azure account and make changes.
    We can now enter the variables; these detail the storage account and don’t need
    to be stored as secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Value Content** |'
  prefs: []
  type: TYPE_TB
- en: '| `BACKEND_AZURE_RESOURCE_GROUP_NAME` | This is the name of the resource group
    that will be created to host the storage account we will use for the Terraform
    state file, for example; `rg-terraform-state-uks`. |'
  prefs: []
  type: TYPE_TB
- en: '| `BACKEND_AZURE_LOCATION` | The region the resources are going to be launched
    in. For example, `uksouth`. |'
  prefs: []
  type: TYPE_TB
- en: '| `BACKEND_AZURE_STORAGE_ACCOUNT` | The name of the storage account you create
    must be unique across all of Azure; otherwise, you will get an error. For example,
    `satfstate180323`. |'
  prefs: []
  type: TYPE_TB
- en: '| `BACKEND_AZURE_CONTAINER_NAME` | The name of the container where the file
    will be stored, for example, `tfstate`. |'
  prefs: []
  type: TYPE_TB
- en: '| `BACKEND_AZURE_STATE_FILE_NAME` | The name of Terraform state file itself,
    for example, `ghact.tfstate`. |'
  prefs: []
  type: TYPE_TB
- en: So now that we have everything that we need secret- and variable-wise in the
    GitHub repository, we can look at the workflow itself.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub action workflows are **YAML Ain’t Markup Language** or **Yet Another
    Markup Language** (**YAML**) files (depending on the explanation you read).
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: YAML is a human-readable data serialization format that uses indentation to
    convey structure, popular for configuration files, data exchange, and applications
    requiring simple data representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have some basic configuration; here, we use `name` to name the workflow
    and define `on` to specify on what action the workflow should trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the workflow will be triggered as defined in the `on` section
    of the YAML file, on a `push` or `pull_request` to the `main` branch. Now that
    we have defined when the workflow will be triggered, we can now define the three
    jobs that go to make up the workflow, starting with the job that checks the presence
    of the storage account we are going to use for the backend Terraform state file
    – and it if it is not there, create one.
  prefs: []
  type: TYPE_NORMAL
- en: Please note
  prefs: []
  type: TYPE_NORMAL
- en: Indentation is really important when it comes to the structure of the YAML file;
    however, while working through the structure across the following pages, I will
    be removing some of the indentations to make it more readable – please refer to
    the code in the GitHub repository that accompanies this title for the correct
    format and indentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define the jobs and some basic configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here we are giving the job an internal reference, `check_storage_account`, and
    telling it to run on the latest version of Ubuntu and use `bash` as the default
    shell.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `check_storage_account` job is made up of two steps, step one being as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we are using the `Azure/login@v1` task to log in to our Azure account using
    the secrets we defined in GitHub. These are referred to by using `${{ secrets.ARM_CLIENT_ID
    }}`. The next step uses the variables we added to GitHub and the `Azure/CLI@v1`
    task to check for the presence of the storage account.
  prefs: []
  type: TYPE_NORMAL
- en: 'If it is not there, it will be created, and the resources already exist, then
    the task will progress to the next step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As this step is running on the same Ubuntu instance as the first step, which
    logged into Azure, we don’t need to authenticate again – instead, we can just
    run the Azure CLI commands we need:'
  prefs: []
  type: TYPE_NORMAL
- en: Create or check for the presence of the resource group to host our storage account
    using `az` `group create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create or check for the presence of the storage account using `az storage` `account
    create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create or check for the presence of the container in the storage account using
    `az storage` `container create`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we know we have the storage account in place for the Terraform backend
    state file storage, we can proceed with the next job, which runs the `terraform_plan`
    command and stores the output with the workflow run.
  prefs: []
  type: TYPE_NORMAL
- en: 'As per the last job, we need to set up some basic configurations, such as the
    job name and reference, what operating system to use, and also some additional
    bits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we are setting some environment variables containing the credentials
    needed to log in to Azure; why are we doing that again when we already authenticated
    during the last job?
  prefs: []
  type: TYPE_NORMAL
- en: The reason is that once the last task in the last job finished, the compute
    resource running the job was terminated, and when this job started, a new resource
    was spun up, meaning that everything from the last job was lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have defined the basics for the `terraform_plan` job, we can work
    through the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This simple step checks out the repository from which we are running the action;
    the repository contains the Terraform we will execute during the workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the code we need to install Terraform. To do this, we use the `hashicorp/setup-terraform@v2`
    task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, so good; as per when we were running Terraform on our local machine,
    we now need to run the `terraform` `init` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have appended quite a bit to the end of the `terraform init`
    command – this sets up our backend using the variables we defined in GitHub for
    the duration of the job, meaning Terraform will use the remote backend and not
    the local one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up, we need to run the `terraform plan` command to figure out what needs
    to happen during the workflow execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You will have noticed that we are wrapping a little logic around the command
    to figure out the exit code. We need to do this because we need to know whether
    we should stop the execution of the workflow if there is an error, which is what
    the final piece of the code in the step does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So now we know whether there are any obvious errors or everything is OK, and
    we have a copy of the Terraform plan file; what’s next?
  prefs: []
  type: TYPE_NORMAL
- en: 'As we have already mentioned, when we run the next job, we will be starting
    from scratch, and as we need a copy of the Terraform plan file, we should copy
    it from the compute resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `actions/upload-artifact@v3` task to copy the file called `tfplan`
    to the workflow execution as an artifact; in subsequent tasks and jobs, we can
    download the file and use it without committing to the code repo itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next task, at first glance, may seem a little redundant:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]terraform'' >> $GITHUB_OUTPUT'
  prefs: []
  type: TYPE_NORMAL
- en: echo "$TERRAFORM_PLAN" >> $GITHUB_OUTPUT
  prefs: []
  type: TYPE_NORMAL
- en: echo '[PRE17]
  prefs: []
  type: TYPE_NORMAL
- en: The task appears to be doing something with the Terraform plan file, but what?
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages of using a system such as GitHub actions is that you can
    publish artifacts and also publish other outputs – in this case, we are taking
    the list of changes logged within the plan file and formatting it for use as a
    workflow summary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next and final task within this job is to take the summary we have just
    generated and publish it back to GitHub:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, all we have left is to run the `terraform apply` command – this is the
    last job of our workflow, and it shares many of the steps with the previous job.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there are some changes to the configuration that we should highlight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have added the `if` and `needs` statements. The `if` statement
    verifies that we are 100% working with the correct branch, and the `needs` statement
    ensures that the `terraform_plan` job has been successfully executed, meaning
    that we will have the Terraform plan file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first three steps are ones that we have already covered, them being the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the code
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up Terraform
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`terraform init`'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to download the Terraform plan file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With the plan file downloaded, we can now perform the final task of the workflow,
    which is to run the `terraform apply` command and deploy the changes, if any,
    detailed within the plan file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the number of tasks it has taken for us to get to this point, the final
    task is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we run `terraform apply` with the `-auto-approve` flag; if we
    don’t, then Terraform will quite happily sit there for an hour waiting for someone
    to type `Yes`, which will never happen as this is not an interactive terminal.
  prefs: []
  type: TYPE_NORMAL
- en: We are then telling it to load in the file called `tfplan`, which means that
    we do not need to run the `terraform plan` command for a second time as we already
    know what will change/be applied during the execution.
  prefs: []
  type: TYPE_NORMAL
- en: So, what changes to our Terraform code are needed for this to work?
  prefs: []
  type: TYPE_NORMAL
- en: 'Just the one we need to tweak our code to use the `azurerm` backend; this makes
    the top of our `main.tf` file look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The rest of the code remains as is. We then need to take a workflow YAML file
    and place it in a folder called `.github/workflows` at the top level of our repository.
    I have named the file `action.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Please note
  prefs: []
  type: TYPE_NORMAL
- en: In the repo accompanying this title, the folder name purposely has the “`.`”
    removed, so the GitHub action is not registered. When you copy to your repo, please
    ensure you rename the `github` folder to `.github`; otherwise, the action won’t
    be registered, and the workflow will not run.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let’s run it the first time you check in the `action.yml` file. It will
    create the action and run – this can be confirmed by the dot next to the commit
    ID, which in the following example screen is referenced as **b4900e8**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Checking in and running the workflow](img/Figure_7.02_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Checking in and running the workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'If everything has run as expected, clicking the **Actions** tab at the top
    of the repo page should show you something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Viewing the workflow runs](img/Figure_7.03_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Viewing the workflow runs
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the workflow run will take you to the execution **Summary** page;
    for me, this looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Reviewing the workflow execution](img/Figure_7.04_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Reviewing the workflow execution
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we have the three jobs listed and the artifacts and the custom
    summary we published from the `terraform` `plan` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Viewing the output of Terraform Plan](img/Figure_7.05_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Viewing the output of Terraform Plan
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, if you click on any of the job names, it will show the output of each
    of the tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Viewing the output of Terraform Plan](img/Figure_7.06_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Viewing the output of Terraform Plan
  prefs: []
  type: TYPE_NORMAL
- en: I recommend clicking around and reviewing precisely what the GitHub action workflow
    executed, as it gives pretty detailed information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, if you check the Azure portal, you should see the resource group,
    storage account, and container where there should be a single file called `ghact.tfstate`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Checking the Terraform state file in the Azure portal](img/Figure_7.07_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Checking the Terraform state file in the Azure portal
  prefs: []
  type: TYPE_NORMAL
- en: That concludes using GitHub actions to run Terraform; before we finish the chapter,
    let’s look at a workflow that runs Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Running Ansible using GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible doesn’t have a concept of state files, so this will simplify our GitHub
    action workflow. As we are using Microsoft Azure again, you must set up the `ARM_CLIENT_ID`,
    `ARM_CLIENT_SECRET`, `ARM_SUBSCRIPTION_ID`, and `ARM_TENANT_ID` secrets in your
    GitHub repository as we did in the last section before progressing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once they are there, we can move on to the workflow itself; as with the Terraform
    workflow, we start by setting some basic configurations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we define the job; that’s right, there is only one job for this workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, not much is different, so let’s move on to the steps. First, we check
    out the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we hit our first difference; as Ansible is written in Python, we need
    to make sure that Python is installed and reasonably up to date. For this, we
    will use the `actions/setup-python@v4` task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The next step is to log in to Azure, this is an exact copy of the *Log in to
    Azure using a service principal* step from the Terraform workflow in the previous
    section of this chapter, so I will not repeat the code here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to install Ansible itself – we are doing this using the `pip`
    command; the step looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Once Ansible is installed, we can then run the `ansible-galaxy` command to
    install the Azure Collection – this step is not too different from when installed
    it locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you may have guessed, once the Azure Collection is installed, we need to
    install the Python modules needed for the collection to function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Once everything we need to run the playbook is installed, we can run the task;
    this step looks like the *Create String Output* step in the Terraform workflow,
    as we want to capture the output of the `ansible-playbook` command and store it
    within the workflow summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'' >> $GITHUB_OUTPUT'
  prefs: []
  type: TYPE_NORMAL
- en: echo "$ANSIBLE_OUTPUT" >> $GITHUB_OUTPUT
  prefs: []
  type: TYPE_NORMAL
- en: echo '[PRE31]
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step in the workflow is to publish the summary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That is it; as you can see, the workflow has fewer jobs and steps as we don’t
    have to take into consideration either the backend storage or publishing plan
    file as an artifact as we did for the Terraform workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the workflow should give you something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Running the Ansible Playbook using GitHub Actions](img/Figure_7.08_B19537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Running the Ansible Playbook using GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: Again, the folder name of the repo accompanying this title purposely has the
    `.` character removed from the start of the folder name, so the GitHub action
    is not registered. If you are following along in your repo, per the Terraform
    GitHub Action workflow, you must rename this folder to `.github` when committing
    to your repo to register the action.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have run our workflows using Terraform and Ansible, let’s quickly
    discuss some best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Security best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we worked through the Terraform and Ansible workflows, we discussed adding
    repository secrets to our GitHub repository. All sensitive information should
    be stored within secrets outside of using an external source for your secrets,
    such as Azure Key Vault, AWS Secrets Manager, or HashiCorp Vault.
  prefs: []
  type: TYPE_NORMAL
- en: The advantage of this is that the secrets will remain hidden, but the code will
    also be able to consume them. Great, you may think to yourself.
  prefs: []
  type: TYPE_NORMAL
- en: But anyone who has been granted write access to the repo will also be able to
    consume them (though not view the contents), so please be careful when granting
    access to your IaC CI/CD pipelines as they will have a high level of access to
    your cloud resource via your workflows, so please ensure that you only grant access
    to trusted members of your teams.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we finish the chapter, let’s have a quick pop quiz:'
  prefs: []
  type: TYPE_NORMAL
- en: When writing YAML, what is it essential to keep an eye on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it comes to credentials, what should you never do?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the folder name in which the GitHub action should be stored?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we spent a lot of the initial part of the chapter discussing how Terraform
    works, once we got onto working through the GitHub Actions workflows, I am sure
    that you started to see the benefits of running our IaC from a centrally accessible
    location rather than your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: Once we discussed Terraform’s requirements, we configured repository secrets
    and variables in GitHub. Then we worked through the various jobs and steps to
    make up the workflow that manages the storage account, where we stored the Terraform
    state and executed the Terraform deployment.
  prefs: []
  type: TYPE_NORMAL
- en: We then took everything we learned and covered in Terraform and applied it to
    Ansible before finally discussing a vital security point – be careful what access
    you give to your IaC GitHub actions!
  prefs: []
  type: TYPE_NORMAL
- en: There are some points we needed more time to cover, such as monitoring; for
    example, it is relatively straightforward to hook your GitHub Actions into messaging
    services such as Microsoft Teams or Slack to get real-time feedback on workflow
    runs – there are links to the GitHub Actions Marketplace tasks for Microsoft Teams
    and Slack in the further reading section if you want to have a go at hooking your
    workflows into your preferred messaging service.
  prefs: []
  type: TYPE_NORMAL
- en: This is not only a great way of extending your IaC deployments to other team
    members, but it also works as a system that tracks changes as the workflow runs,
    which contains a summary of each execution that will be stored for a while.
  prefs: []
  type: TYPE_NORMAL
- en: In the next and penultimate chapter, we will look at common troubleshooting
    tips and tricks.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more details on the tasks we have used in the steps in this chapter
    at the following URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/](https://github.com/marketplace/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: https://github.com/marketplace/actions/azure-login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/actions/azure-cli-action](https://github.com/marketplace/actions/azure-cli-action)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/actions/checkout](https://github.com/marketplace/actions/checkout)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/actions/upload-a-build-artifact](https://github.com/marketplace/actions/upload-a-build-artifact)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/actions/download-a-build-artifact](https://github.com/marketplace/actions/download-a-build-artifact)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/actions/setup-python](https://github.com/marketplace/actions/setup-python)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/actions/microsoft-teams-deploy-card](https://github.com/marketplace/actions/microsoft-teams-deploy-card)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://github.com/marketplace/actions/slack-notify](https://github.com/marketplace/actions/slack-notify)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to the pop quiz:'
  prefs: []
  type: TYPE_NORMAL
- en: When writing YAML, what is it essential to keep an eye on? Indentation! The
    structure of your YAML file is critical – if you get it wrong, even by a single
    character, you will get errors.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it comes to credentials, what should you never do? Embed them into your
    code! You need to use an external secret management system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the folder name in which the GitHub action should be stored? Your YAML
    files should be stored in the `.``github/workflows` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
