<html><head></head><body>
        

                            
                    <h1 class="header-title">Jinja in Ansible</h1>
                
            
            
                
<p>JINJA was created in 2008 by Armin Ronacher and aims to replace similar template engines with a more modern and structured solution. Jinja was designed for Python (the programming language that Ansible was created with) and, coupled with Ansible, to provide a framework that integrates seamlessly with YAML. Ansible's YAML implementation and programmatic playbook solution incorporates this robust Jinja template engine. Like many other template solutions (Django, Smarty, and so on), Jinja was designed to provide structural support for reusable text with context specific alterations (environments, hosts, and so on) and comprehensive functionality that developers have come to rely on.<br/></p>
<p class="p1">For those who have experience with Smarty or Django-styled tempting solutions, Jinja will indeed be familiar. The design of the Jinja template solution aims to provide support for designers, developers, and operators alike by providing the ability to add conditional logic, iterative behaviors, and logic oriented solutions while adhering to Python best practices. This solution is particularly useful for playbook developers because it provides a highly adaptive programmatic flexibility that can be leveraged by organizations using environments that are similar in nature but have slight differences. Suffice to say, the initial learning curve of Jinja is low and the usefulness of the markup and logic is high.</p>
<p class="p1">In this chapter, we will learn how Ansible integrates with Jinja and how Jinja can be leveraged to provide advanced functionality within Ansible playbook's. We will discover how Jinja came about, see how it can be leveraged to create comprehensive playbook implementations, learn how its syntax cohabitates with Ansible's YAML playbook syntax, and see how Jinja complements Ansible's playbook implementation. By the end of this chapter, we will have covered the following:</p>
<ul>
<li>Introduction to Jinja.</li>
<li>How is Jinja2 used by Ansible?</li>
<li>Jinja programming constructs.</li>
<li>Applying Jinja to Ansible playbooks.</li>
<li>How to create loops and iterators in Jinja2.</li>
<li>How to make and use Jinja2 template files.</li>
<li>How to use data structures with Jinja2.</li>
</ul>
<p>Let's begin, shall we?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing Jinja</h1>
                
            
            
                
<p>Jinja is a templating engine that was developed in 2008 by Armin Ronacher in an effort to provide Python developers with a framework that would supply comprehensive Python-like syntax that could be used within strings and data documents. The solution was designed with similar solutions such as Smarty and Django in mind. Jinja executes its template translations in a sandbox (isolated from the rest of the program execution) so as to prevent the template engine from interfering with the normal operational execution of the Python program.</p>
<p>Jinja2 represents the second major version of the Jinja Python library. Jinja is leveraged to generate string-based documents based on one or more predefined templates (also made of strings). As of the writing of this book, Jinja is in use by numerous open source solutions that are actively developed with Python. Some notable examples of solutions that use Jinja include Salt, Flask, and Ansible.</p>
<p>When coupled with Ansible and YAML, Jinja adds significant amounts of power to the Ansible playbook architecture. Jinja in this context provides Ansible playbook developers with the ability to add programming constructs (including variables, conditional logic, loops, and more) to a playbook and structure it in such a way where it can be leveraged as a complete programming solution for automation. Before we get ahead of ourselves and start looking at all the neat stuff that Jinja can do, let's first understand how it actually works.</p>
<p class="p1">Jinja is a software solution designed to combine templates with a data model to produce result documents. The templates contain special markup tags and logic that are parsed and logically combined during the execution of the template-parsing process.</p>
<p>To better explain the concept of a template engine, the following Python code shows a basic example of string manipulation using Jinja:</p>
<p>Basic Jinja Python implementation:</p>
<pre>
<strong># A Simple Jinja Python Template example from jinja2 import Template</strong><br/><br/>exampleJinjaTemplate = Template('Hello {{ place }}!')<br/>exampleJinjaTemplate.render(place=‘World')<br/><br/>&gt;&gt;&gt;Output: 'Hello World!'
</pre>
<p>From the example we just saw, we can observe that this simple Python script does the following:</p>
<ol>
<li>Imports the Jinja template engine library.</li>
<li>Defines a simple string template, <kbd>['Hello {{ place }] ']</kbd>.</li>
<li>Renders the template and substitutes the <kbd>{{ place }}</kbd> tag with the word <kbd>World</kbd>.</li>
</ol>
<p>If you are planning on implementing Jinja directly within Python, the Python Jinja module must be installed within Python first. This can be performed fairly easily, and the instructions on how to do this are readily available at the following URL:<br/>
<br/>
<a href="http://jinja.pocoo.org/docs/2.9/intro/#installation">http://jinja.pocoo.org/docs/2.9/intro/#installation</a></p>
<p>The output of the previous example is <kbd>Hello World</kbd>. From this example, we can observe that the Jinja template tag <kbd>{{ ... }}</kbd> is translated during the rendering process, whereas the rest of the string-based document is left intact.</p>
<p>Now that we have a pretty good idea of the basic concepts surrounding Jinja, let's take a look at a more realistic example of Jinja in action by looking at a simple Ansible playbook that uses Jinja.</p>
<p>The content of the <kbd>playbook.yml</kbd> is illustrated as follows:</p>
<pre class="p1">
# Example Ansible Jinja2 Template<br/>- hosts:  all<br/>  vars:<br/>    my_var: ‘Hello'<br/>    my_var2: ‘World'<br/>  tasks:<br/>    - name: Simple Ansible MOTD Template Example<br/>      template:<br/>        src: motdexample.j2<br/>        dest: /etc/motd<br/>        mode: 0777
</pre>
<p><kbd>motdexample.j2</kbd>: This is a Jinja2-generated <strong>motd</strong> file also known as <strong>message of the day</strong>. The following content tags will be replaced by the variable data we defined in our playbook (<kbd>my_var</kbd> and <kbd>my_var2</kbd>, respectively):</p>
<pre>
Welcome to your System:<br/>{{ my_var }}<br/>{{ my_var2 }}
</pre>
<p>Can you guess what this example will do when executed using Ansible with the assistance of the Jinja2 templating engine? Ansible in conjunction with Jinja will copy the motd file to the target hosts <em>and</em> replace the <kbd>{{}}</kbd> styled variables at the same time with the contents of <kbd>my_var</kbd> and <kbd>my_var2</kbd>. Let's take a look at the output of the motd file on the target host:</p>
<p><kbd>/etc/motd content</kbd>: This is a Jinja2-generated motd file. The following content tags will be replaced by the variable data we defined in our playbook (<kbd>my_var</kbd> and <kbd>my_var2</kbd>, respectively):</p>
<pre>
Welcome to your System:<br/>Hello<br/>World
</pre>
<p class="p1">In the context of an Ansible playbook, Jinja allows us to add the <kbd>{...}</kbd> style tags within our playbook (or within a templated file as we just saw), and Ansible will tell the Jinja library to translate the tags and generate a new document prior to execution. This means we can add common programming constructs either directly to our playbooks or to templated files and make our automation significantly more intelligent. While this example may not seem all that useful, the Jinja implementation overall provides a significant enhancement when coupled with Ansible and YAML.</p>
<p>Consider this implementation for when it is necessary to generate, say, Apache configuration files or MySQL queries. We could although arduously generate each config manually, <em>or</em> we could template the content of these and have Ansible iterate. In the coming sections, we will take a deep dive into Jinja programming constructs and learn how to leverage Jinja effectively.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jinja2 Programming Constructs</h1>
                
            
            
                
<p>Jinja2 was incorporated into the Ansible architecture back in 2012 when Ansible 0.5 was released. The implementation of Ansible at the time incorporated the concept of Jinja2 filters and supported basic Jinja2 syntax. As ansible evolved, so did its developer support for Jinja. By coupling YAML and Jinja2, Ansible was soon able to provide a comprehensive scripting-oriented solution for Ansible playbook developers.</p>
<p>By the time Ansible 1.0 was released, the Ansible playbook concept (including Jinja and YAML) had evolved enough to support a wide array of syntax implementations. As a result of the integration of YAML, Jinja and Ansible's popularity skyrocketed. After the release of Ansible 1.0, playbooks could be authored to incorporate the following syntaxes:</p>
<p>Jinja tag syntax:</p>
<pre>
{{ .. }} for expressions (including variables)<br/>{% ... %} for control structures<br/>{# ... #}} Comments
</pre>
<p>Each of these tags serves a unique role within the Jinja universe, and it is important to understand each completely (so as not to mix them up). In the coming sections, we will learn about these special tags and learn how they can be leveraged to enhance our playbook logic. By the time we're done, we should have a solid understanding of how to wield Jinja implementations of expressions, control statements, and comments.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Expressions, filters, and variables</h1>
                
            
            
                
<p>Jinja filters (also known as <strong>variable expressions</strong>) are very similar in nature to programming variables, although with a key difference. Filter expressions represent a data value item <em>or</em> the computed value of a data point in conjunction with another data source. Expressions are evaluated at runtime and can provide a level of flexibility for playbook and template developers. The syntax of Jinja2's expression format is shown as follows:</p>
<pre>
# Basic Syntax of a Jinja Filter or Variable<br/>{{ var | operation expression }}
</pre>
<p>The source data for the <kbd>var</kbd> section can be from multiple different places. Within an Ansible playbook, there are presently four unique methods for sourcing variable values and content within the context of Jinja:</p>
<ol class="ol1">
<li class="li1">Pass a YAML or JSON file with the <kbd>--var-file</kbd> option.</li>
<li class="li1">Create environment variables.</li>
<li class="li1">Add a top-level defaults section to the playbook.</li>
<li class="li1">Capture the value from <kbd>stdout</kbd>.</li>
</ol>
<p>As we can see from the example syntax we just looked at, Jinja expressions provide significant power that can be now wielded by Ansible playbook developers. Let's take a look at a more comprehensive playbook example using Ansible and Jinja2 expressions.</p>
<p><kbd>playbook.yml</kbd>:</p>
<pre class="p1">
# Example playbook using simple JINJA2 variable substitution<br/>--<br/>- hosts: 127.0.0.1<br/>  user: root<br/>  vars:<br/>    motd: ‘Welcome to your Linux Box'<br/>  tasks:<br/>    - name: Update the /etc/motd<br/>      copy: content=‘{{motd}}' dest='/etc/motd' force='yes'
</pre>
<p>When we run the playbook, Ansible's output looks like the following screenshot:</p>
<div><strong><img class="image-border" src="img/c0343c61-4d5b-4827-9276-2e83523e3f13.png"/></strong></div>
<p class="mce-root CDPAlignLeft CDPAlign">Output (contents of <kbd>/etc/motd</kbd>):</p>
<pre>
Welcome to your Linux Box
</pre>
<p>In this example, we simply set the content of the MOTD file using a basic variable. Simple enough, right? But the real power of Jinja expressions comes when we realize we can source the variable data from multiple sources and perform operations on the variable inline and in real time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jinja string concatenation and manipulation</h1>
                
            
            
                
<p>Jinja provides an excellent solution for manipulating strings and concatenating text (joining it with other text). For example, we might want to create a unique MOTD file by adding some additional information to the MOTD contents based on perhaps the hostname. This could be easily achieved via the following ansible playbook and Jinja syntax.</p>
<p><kbd>playbook.yml</kbd>:</p>
<pre class="p1">
# Example playbook using simple JINJA2 variable substitution<br/>- hosts: 127.0.0.1<br/>  user: root<br/>  vars:<br/>    motd: "Welcome to your Linux Box! You are connected to {{ inventory_hostname_short }}"<br/>  tasks:<br/>    - name: Update the /etc/motd<br/>      copy: content=‘{{motd}}' dest='/etc/motd' force='yes'
</pre>
<p>As we can see, the example shows how easy it is to concatenate string variables using Jinja. While the example we just looked at is useful, the expression implementation of Jinja is not limited to simple string concatenation. We can also manipulate strings using Jinja. For example, we might use any of the following solutions:</p>
<p>To use <em>regular expressions</em> within a Jinja variables:</p>
<pre>
# convert "ansible" to "able"<br/>{{ 'ansible' | regex_replace('^a.*i(.*)$', 'a\\1') }}<br/><br/># convert "foobar" to "bar"<br/>{{ 'foobar' | regex_replace('^f.*o(.*)$', '\\1') }}<br/><br/># convert "localhost:80" to "localhost, 80" using named groups<br/>{{ 'localhost:80' | regex_replace('^(?P&lt;host&gt;.+):(?P&lt;port&gt;\\d+)$', '\\g&lt;host&gt;, \\g&lt;port&gt;') }}<br/><br/># convert '^f.*o(.*)$' to '\^f\.\*o\(\.\*\)\$'<br/>{{ '^f.*o(.*)$' | regex_escape() }}
</pre>
<p>To convert Jinja variables to <em>upper</em> and <em>lower</em> case:</p>
<pre class="p1">
Uppercase a Variable:<br/><br/>{{ var|upper }}<br/><br/>Lowecase a Variable:<br/><br/>{{ var|lower }}
</pre>
<p>In addition to string manipulation, the Jinja implementation is <em>far</em> more powerful. We can also perform math operations using Jinja. Let's learn how.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic arithmetic operations in Jinja</h1>
                
            
            
                
<p>In addition to basic string concatenation, we can also perform math and computational operations in Jinja. For example, we can add numerical values together using the following syntax:</p>
<pre>
var: 1<br/>incremented_var: "{{ var + 1 }}"
</pre>
<p>The resulting output would have been calculated as <em>1+1 = 2</em>, thus resulting in <em>2</em> as the value of the <kbd>incremented_var</kbd> variable. In conjunction with basic addition, we can also perform multiplication, subtraction, division, and more. A complete list of the basic math operations available is provided next:</p>
<pre>
# Computational operations using Jinja2<br/><br/>Addition Operator: +<br/>Example: {{ var + 1 }}<br/><br/>Subtraction Operator: -<br/>Example: {{ var - 1 }}<br/><br/>Multiplication Operator: *<br/>Example: {{ var * 2 }}<br/><br/>Division Operator: /<br/>Example {{ var / 2 }}
</pre>
<p>From what we just saw, it is easy to see how Jinja can perform basic math operations. But it's not limited to just simple math.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compound math equations and order of operations in Jinja</h1>
                
            
            
                
<p>Basic operations such as adding, subtracting, multiplying, and dividing can also be combined to create more robust calculated results. This is implemented via the <kbd>()</kbd> ordering of operations solution, which is common across many programming languages. It basically states that mathematical operations contained within the parentheses will be performed first with precedence of multiplication, division, addition, and then subtraction. Once the items inside a given set of parentheses are complete, the logic moves outward. An example of this is provided here:</p>
<pre>
Example Math Equation:<br/>2 * (1 + 1)<br/><br/>Order of Operations:<br/>1 + 1 = 2<br/>2 * 2 = 4<br/><br/>Example Math Equation #2:<br/>(( 1 + 2 ) * 3 ) / 2<br/><br/>Order of Operations:<br/>1 + 2 = 3<br/>3 * 3 = 9<br/>9 / 2 = 4.5
</pre>
<p>Within the context of a Jinja expression, this math operation would look something like the following:</p>
<pre>
my_var = "{{ (( 1 + 2 ) * 3) /2 }}"
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Filters available</h1>
                
            
            
                
<p>Jinja2 is not limited to strictly computational operations. It can be leveraged for any number of operational tasks. Ansible has kindly also provided a number of handy filters, which can be applied to our variable implementations.</p>
<p>The following is a table with a set of examples for the more popular operational tasks one might need to perform using Jinja filter expressions:</p>
<table>
<tbody>
<tr>
<td><strong>Expression name</strong></td>
<td><strong>Example</strong></td>
<td><strong>Description of the expression</strong></td>
</tr>
<tr>
<td><kbd>to_json</kbd></td>
<td>
<pre>
{{ some_variable | to_json }}
</pre></td>
<td>Converts the variable data into JSON format and renders it.</td>
</tr>
<tr>
<td><kbd>to_yaml</kbd></td>
<td>
<pre>
{{ some_variable | to_yaml }}
</pre></td>
<td>Converts the variable data into YAML format and renders it.</td>
</tr>
<tr>
<td><kbd>mandatory</kbd></td>
<td>
<pre>
{{ variable | mandatory }}
</pre></td>
<td>Makes the variable declaration and setting mandatory for the playbook to execute properly.</td>
</tr>
<tr>
<td><kbd>default value</kbd></td>
<td>
<pre>
{{ some_variable | default(5) }}
</pre></td>
<td>Sets a default value for the variable if it is not defined.</td>
</tr>
<tr>
<td><kbd>min|max</kbd></td>
<td>
<pre>
{{ [3, 4, 2] | max }}<br/><br/>{{ [3, 4, 2] | min }}
</pre></td>
<td>Fetches the minimum or maximum value from an array. In this case, the values would be <kbd>2</kbd> or <kbd>4</kbd>, respectively.</td>
</tr>
<tr>
<td><kbd>random</kbd></td>
<td>
<pre>
"{{ ['a','b','c']|random }}"


"{{ 59 |random}} * * * * root /script/from/cron"
</pre>
<div><div><div><pre>
"{{ 59 |random(seed=inventory_hostname) }} * * * * root /script/from/cron"
</pre></div>
</div>
</div>
</td>
<td>Fetches a random item from a list, a random number, or seed value, respectively.</td>
</tr>
<tr>
<td>Shuffle</td>
<td>
<pre>
{{ ['a','b','c']|shuffle }}<br/># =&gt; ['c','a','b']<br/>{{ ['a','b','c']|shuffle }}<br/># =&gt; ['b','c','a']
</pre></td>
<td>Generates a new random list from an existing random list.</td>
</tr>
<tr>
<td>Math log</td>
<td>
<pre>
{{ myvar | log }}<br/>{{ myvar | log(10) }}
</pre></td>
<td>Log algorithm math function and log numeric algorithm, respectively.</td>
</tr>
<tr>
<td>Square root</td>
<td>
<pre>
{{ myvar | root }}<br/>{{ myvar | root(5) }}
</pre></td>
<td>Square root math.</td>
</tr>
<tr>
<td>IPV filter</td>
<td>
<pre>
{{ myvar | ipv4 }}<br/>{{ myvar | ipv6 }}
</pre>
<p> </p>
</td>
<td>Tests whether a string is a specific IPV version.</td>
</tr>
<tr>
<td>Quote filter</td>
<td>
<div><div><pre>
- shell: echo {{ string_value | quote }}
</pre></div>
</div>
</td>
<td>Wraps the expression evaluated in quotes.</td>
</tr>
<tr>
<td>Concatenate lists</td>
<td>
<div><div><div><div><pre>
{{ list | join(" ") }}
</pre></div>
</div>
</div>
</div>
</td>
<td>Joins list items into a single unified string.</td>
</tr>
<tr>
<td>Basename</td>
<td>
<div><div><div><div><div><div><pre>
{{ path | basename }}
</pre></div>
</div>
</div>
</div>
</div>
</div>
</td>
<td>Linux path basename. Gets <kbd>foo.txt</kbd> out of <kbd>/etc/bar/foo.txt</kbd>, for example.</td>
</tr>
<tr>
<td>WIN basename</td>
<td>
<div><div><div><div><div><div><div><div><pre>
{{ path | win_basename }}
</pre></div>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
</td>
<td>Same as basename but for MS Windows.</td>
</tr>
</tbody>
</table>
<p>Now that we have a good understanding of how Ansible and Jinja leverage filters, let's move on to control structures.</p>
<p>For a complete list of available filters and expressions, consult the official Ansible 2.0 documentation provided at <a href="http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data">http://docs.ansible.com/ansible/playbooks_filters.html#filters-for-formatting-data</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Conditional logic (if-then-else)</h1>
                
            
            
                
<div><p>Control structures within any programming language provide a way of defining paths for an executing program to flow through based on a condition. In addition to conditional logic, control structures also provide us with a way of repeating like tasks without duplicating code. This is commonly known as <strong>conditional logic and looping</strong>, respectively. Jinja provides us with a set of operators that allow us to loop or conditionally execute code. In this section, we will discuss conditional logic specifically and learn how to leverage it within the context of Jinja.</p>
<p>A conditional statement provides the developer with a way of conditionalizing a sequence of events based on the evaluation of an expression. In most languages, this is accomplished through an <kbd>if...then</kbd>-styled solution. Take for example the following flowchart that illustrates the basic principles of conditional logic:</p>
</div>
<div><img height="360" width="492" class="image-border" src="img/6a6397c9-aeee-4272-84c7-dedb89bc4824.png"/></div>
<p>Conditional logic in code form might look something like the following (Python code):</p>
<pre class="p1">
# Python Conditional Logic Example<br/>x = 0<br/>if x == 0:<br/>    print “Hello X is 0”<br/>else:<br/>    print “Hello X is NOT 0”
</pre>
<p>This Python code presents a simplistic example of conditional logic. It simply says that if <kbd>x</kbd> is equal to <kbd>0</kbd>, then execute the <kbd>print</kbd> statement telling the user so. Within Jinja, we can implement a very similar set of logical operators. The only real difference in context is that within Jinja, all control structures and conditionalizations are wrapped within <kbd>{% %}</kbd> tags. Let's look at the same implementation using Jinja:</p>
<pre class="p1">
{% if condition %}<br/>    execute_this<br/>{% elif condition2 %}<br/>    execute_this<br/>{% else %}<br/>    execute_this<br/>{% endif %} 
</pre>
<p>As we can see, the Jinja implementation also gives us the optional <kbd>else-if</kbd> statement. This provides us with additional capabilities when it comes to implementing conditional logic.</p>
<div><p>In Ansible, Jinja's conditional logic can be used in many different ways. It can be used to wrap entire tasks with a conditional statement (only execute these tasks if a variable is set). This provides a huge amount of flexibility and power to playbook developers. Let's look at a real-world example of implementing conditional logic within an Ansible playbook:</p>
</div>
<pre>
# Conditional Logic Playbook Example<br/>---<br/>- name: Hello World Conditional Logic<br/>  user: root<br/>  hosts: all<br/>  vars:<br/>    hello: true<br/>    say_something: "{% if hello == true %} Hello Jinja {% else %} Goodbye Ansible {% endif %}<br/>  tasks:<br/>    - debug:<br/>        msg: "{{ say_something }}"<br/><br/>
</pre>
<p class="mce-root CDPAlignLeft CDPAlign">When we run this playbook, we get the following output:</p>
<div><img height="248" width="510" class="image-border" src="img/6e3b7ebe-88a8-40be-80c3-0aad9a1d33aa.png"/></div>
<p class="mce-root">Based on the conditional statements we defined within our playbook:</p>
<pre>
 hello: true<br/> say_something: "{% if hello == true %} Hello Jinja {% else %} Goodbye Ansible {% endif %}
</pre>
<p class="mce-root CDPAlignLeft CDPAlign">We can flip the <kbd>hello</kbd> variable to false and get the following output:</p>
<div><img height="261" width="518" class="image-border" src="img/c483724d-fb56-4ad0-bd37-b7e8faa379c4.png"/></div>
<p class="mce-root">It is important to note that Jinja syntax leveraged within an Ansible playbook will need to be inside of quotes and continue to adhere to YAML dictionary formatting standards. Jinja conditional syntax outside of the playbook (inside a Jinja template file) doesn't need to adhere to YAML standards.</p>
<p class="mce-root">Conditional logic can be compounded to provide significantly more flexibility and power within Ansible playbooks. In the example we saw, the <kbd>{% ... %}</kbd> tags were placed within the vars section, but they don't necessarily need to be there.</p>
<p class="mce-root">Aside from placing conditionals within an Ansible playbook directly, we can leverage Jinja conditional logic within a Jinja template file. This is where Jinja's true power can be felt. Let's look at an example of a Jinja template file implemented with conditional logic:</p>
<ul>
<li class="mce-root">Ansible playbook:</li>
</ul>
<pre style="padding-left: 90px">
# Example Ansible playbook &amp; Jinja Template<br/>---<br/>- name: Hello World Conditional Logic within a Jinja template<br/>  user: root<br/>  hosts: all<br/>  vars:<br/>    vhost:<br/>       servername: my.server<br/>       documentroot: /var/www<br/>       serveradmin: bob<br/>  tasks:<br/><br/>    # Jinja template file example<br/>    - template:<br/>        src: /jinjatemplates/httpdconf.j2<br/>        dest: /etc/httpd/httpd.conf<br/>        owner: root<br/>        group: wheel<br/>        mode: "u=rw,g=r,o=r"
</pre>
<ul>
<li><kbd>httpdconf.j2</kbd>:</li>
</ul>
<pre style="padding-left: 90px">
NameVirtualHost *:80<br/><br/>&lt;VirtualHost *:80&gt;<br/>  ServerName {{ vhost.servername }}<br/>  DocumentRoot {{ vhost.documentroot }}<br/>{% if vhost.serveradmin is defined %}<br/>  ServerAdmin {{ vhost.serveradmin }}<br/>{% endif %}<br/>  &lt;Directory "{{ vhost.documentroot }}"&gt;<br/>    AllowOverride All<br/>    Options -Indexes FollowSymLinks<br/>    Order allow,deny<br/>    Allow from all<br/>  &lt;/Directory&gt;<br/>&lt;/VirtualHost&gt;
</pre>
<p>On running this example, Anisble will translate the Jinja template, transfer it over to the remote host, and place it in the <kbd>/etc/httpd/httpd.conf</kbd> directory.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Loops and iterators</h1>
                
            
            
                
<p>No programming language would be complete without the capability of reducing the amount of code implemented by iterating over repetitive tasks, and Jinja is no exception. Jinja offers multiple loop types within its syntax arsenal. Loops can come in many forms within a modern traditional programming language. For example, most modern programming languages support most of the following loop types:</p>
<ul>
<li><kbd>For</kbd> loops</li>
<li><kbd>Foreach</kbd> loops</li>
<li><kbd>While</kbd> loops</li>
<li><kbd>Do...Until</kbd> loops</li>
</ul>
<p>In addition to these loop options, some programming languages support other OOP-oriented loop types. Within Ansible's implementation of Jinja, there is currently only support for the for loop. While the implementation of the types of loops is limited, there is the ability to perform counter-based iterations, list iterations, and compound loop conditionals. In this section, we will discuss loops within Jinja and learn how to implement them within our playbooks and our Jinja templates.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple counters</h1>
                
            
            
                
<p>Counter loops involve the repetitive increment or decrement of a variable until a condition is met. Counter loops can be really useful for code that would only need a minor integer change as part of its iteration loop sequence. To better understand the concept of a counter loop, let's look at a flowchart illustration of a common programming loop that increments a counter:</p>
<div><img height="289" width="123" class="image-border" src="img/b79ab38b-622d-4080-ab92-98d21ffc7179.png"/></div>
<div><p>In this illustration, we basically repeat the increment task until the variable <kbd>X</kbd> is equal to the number <kbd>10</kbd>. Once the evaluation of <kbd>X</kbd> is equal to <kbd>10</kbd>, the iterator stops. The illustrated example of our loop could be represented in basic Python programming via the following syntax:</p>
</div>
<pre class="p1">
# Simple Python Counter Loop <br/><br/>x = 0<br/>while x &lt; 10:<br/>    x+=1<br/>print "The value of X is now" + str(x)
</pre>
<p>Loops don't always need to perform mathematical operations. They can also execute automation, iterate over a list, or do pretty much anything your imagination can dream up. This example of a loop simply increments a counter.</p>
<p class="p1">Now that we have understood the basic concept of a loop, let's look at how we might implement the same type of loop within the context of Jinja and Ansible:</p>
<pre>
# Example Ansible playbook using an iterating loop<br/>---<br/>- name: Hello World Iterator within Ansible<br/>  user: root<br/>  hosts: all<br/>  tasks:<br/>    - debug:<br/>        msg: "{% for x in range (0,10) %} {{x}} {% endfor %}"
</pre>
<p>Simple enough implementation, right? The next obvious question is <em>how would we go about implementing this same type of logic within a Jinja template file</em>? I'm glad you asked! Let's take a look:</p>
<pre class="javascript">
{% for id in range(201,221) %}  <br/>192.168.0.{{ id }} client{{ "%02d"|format(id-200) }}.vpn  <br/>{% endfor %}
</pre>
<p>Simple enough also, right? Beyond counting values within a loop, we can also iterate other data items.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">List iterators</h1>
                
            
            
                
<p>List iterators in programming solutions offer the ability to take a list of items and perform a sequence of operations on them. For example, we might have a list of fruit, <kbd>[apples, oranges, grapes, pears]</kbd>, and want to iterate over this list. In traditional programming languages, we could use a <kbd>foreach</kbd> loop. The basic flow of a <kbd>foreach</kbd> loop might look something like the following:</p>
<div><img height="274" width="333" class="image-border" src="img/a0eaa273-a47d-4c51-926b-50b0c4fbc0ab.jpg"/></div>
<p class="CDPAlignLeft CDPAlign"/>
<p class="CDPAlignLeft CDPAlign">This example simply iterates through each item in the list and executes a code block based on the new list item presented. This type of implementation of looping is very basic within most programming languages, and Jinja is no exception. Based on this flow, we can look at a Python example and map this to the following code fragment:</p>
<pre>
# Simple example of a Python iterative loop<br/><br/>fruits = ['apples', 'oranges', 'pears', 'apricots']<br/># Iterate through a list of fruits<br/>for fruit in fruits:<br/>    print "A fruit of type: %s" % fruit
</pre>
<p>In Jinja, the implementation of the list iterator has the following syntax:</p>
<pre>
{# Example Jinja For iterator loop #}<br/><br/>{% for &lt;item_name&gt; in &lt;list_name&gt; %}<br/>  code block<br/>{% endfor %}
</pre>
<p>Finally, let's look at the translation of this loop sequence into Jinja:</p>
<ul>
<li>Hosts file:</li>
</ul>
<pre style="padding-left: 90px" class="p1">
[webservers]<br/>webhost1.local<br/>webhost2.local<br/><br/>[databaseservers]<br/>dbserver1.local<br/>dbserver2.local
</pre>
<ul>
<li>Playbook:</li>
</ul>
<pre style="padding-left: 90px" class="p2">
# Example of loops using Jinja<br/>--<br/>- name: Simple Ansible Playbook that loops over hosts within Jinja<br/>  vars:<br/>    servers_to_configure: "{{ groups['databaseservers'] }}"<br/>  tasks:<br/>    - template:<br/>      src: configfile.j2<br/>      dest: configfile.conf
</pre>
<ul>
<li>Jinja template:</li>
</ul>
<pre style="padding-left: 90px" class="p1">
# Simple Configuration file based on Jinja templating<br/><br/>all_hosts += [<br/>{% for host in servers_to_configure %}<br/>  "{{ hostvars[host].ansible_default_ipv6.address }}<br/>{% endfor %}<br/>]
</pre>
<p>Thise example will autopopulate a file titled <kbd>configfile.conf</kbd> and upload it to the target hosts with the contents transformed using the Jinja <kbd>for</kbd> iterator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Complex iterators using Jinja</h1>
                
            
            
                
<p>The iterators that we discussed earlier in this chapter are very simple in nature. Jinja also provides a more complex way of operating loops within Jinja. Complex (or compound) iterators are common practice within programming and are what make modern algorithms possible. A complex iterator may take many forms, but often includes adding additional compound conditionals or nested loops within the loop sequence. Let's look at a flowchart illustrating a complex iterator (nested loop):</p>
<div><img height="315" width="204" class="image-border" src="img/c96816bd-c34c-48ea-90b1-798d11a3db48.png"/></div>
<p>Does this flowchart looks pretty complex? It doesn't need to be. Let's look at the same algorithm in Python:</p>
<pre class="p1">
# Nested For Loop with Python<br/><br/>for iterating_var in sequence:<br/>   for iterating_var in sequence:<br/>      statements(s)<br/>   statements(s)
</pre>
<p>In Jinja, implementing nested for loops can be done in much the same way. Let's look at an example:</p>
<pre class="p1">
# Example YAML variable file<br/>var_name:<br/>- group:<br/>    - variable1<br/>    - variable2<br/>- group:<br/>    - variable1<br/>    - variable2
</pre>
<p>The Jinja template would look like the following:</p>
<pre class="p1">
{% for var in var_name %}<br/>&lt;group&gt;<br/>{% for host in var.group %}<br/>    &lt;variable&gt;&lt;host&gt;{{ host }}&lt;/host&gt;&lt;/variable&gt;<br/>{% endfor %}<br/>&lt;/group&gt;<br/>{% endfor %}
</pre>
<p>As we can see, the implementation of this Jinja loop is also pretty simple. Let's take a look at how to make a slightly more complex loop that uses both iterators and conditionals. Following are the code fragments for variables in loops from a <kbd>vars</kbd> file:</p>
<pre class="mce-root">
# Save this as vars.yml<br/>---<br/> places:<br/> - name: USA<br/> capital: Blue<br/> - name: Great Britan<br/> capital: Yellow<br/> - name: Itally<br/> capital: Blue<br/> - name: Mexico<br/> capital: Yellow<br/> - name: Ireland<br/> capital: Yellow<br/> - name: Amsterdam<br/> capital: Orange<br/><br/><strong># Save this as playbook.yml</strong><br/>---<br/> - name: How to use variables in Jinja2 Loops<br/>   hosts: localhost<br/>   connection: local<br/>   vars_files:<br/>     - vars.yml<br/>   gather_facts: no<br/>   tasks:<br/>     - name: This task uses a j2 template which has a series of loops<br/>       template: src=./ourloop.j2 dest=./output.txt<br/><br/><strong># Save this as ourloop.j2</strong><br/>{% for country in places %}<br/> Currently people are visiting {{ country }}.<br/>{% endfor %}
</pre>
<p class="mce-root">Now run it and check the output. Nice right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Applying Jinja in Ansible Playbook's</h1>
                
            
            
                
<p>Jinja can be applied to playbooks in a few specific ways. The most common implementation of Jinja is the use of filters and variables within playbook YAML files. This information must be placed within the quoted context of YAML key/value structures. The key/value structure of YAML <em>does</em> normally support non-quoted values, but within the context of Jinja, we <em>must</em> have it within quotes. For example, let's consider the following:</p>
<pre class="p2">
---<br/>- name: Simple Ansible Playbook that loops over hosts within Jinja<br/>  vars:<br/>    say_hello<br/>    say_something: "{{ say_hello }}"<br/><br/>  tasks:<br/>    - debug:<br/>        msg: "{{ say_something }}"
</pre>
<p>As we can see from this playbook, the implementation of Jinja within the playbook has the <kbd>{{...}}</kbd> tags directly within quotes. The <em>only</em> location that supports non-quoted implementations of Jinja tags is within a Jinja template. Jinja templates are parsed differently from YAML and therefore support loose implementations of Jinja tags. Let's consider the following:</p>
<pre class="p1">
# Simple Configuration file based on Jinja templating<br/><br/>{% for host in servers_to_configure %}<br/>  {{ host }}<br/>{% endfor %}
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we covered how Jinja specifically and uniquely fits within the Ansible world. We learned how Jinja filters work and discovered how these filters can be leveraged within a playbook to provide us with clever playbook implementations. In addition to Jinja filters, we spent time learning how to perform mathematical operations on variables within a Jinja filter context.</p>
<p>In addition to the concept of Jinja filters, we also learned about loops and iterators. These iterators provided us with good insights into iterating over structured data, counting forward and in reverse. We learned also that iterators can be used for iterating through lists (such as the list of fruits that we iterated over in our example). Finally, we learned how to apply Jinja within our playbooks and the specific requirements that surround leveraging Jinja.</p>
<p>In the next chapter, we will cover the Ansible vault. The Ansible vault represents a unique and secure solution for encrypting, storing, and decrypting data with Ansible. This solution is <em>highly</em> useful as it can be used to store password data, usernames, secure database queries, and so much more. Oftentimes within an organization, sensitive user data is needed to configure and deploy software. This sensitive data is often usernames and passwords. Ansible provides an out-of-the-box solution to help encrypt and hide sensitive information. The next chapter will be on the Ansible vault. The next chapter of the book will outline the Ansible way of managing, storing, and deploying sensitive information. We will cover how to best leverage the Ansible vault utility to ensure that sensitive data is kept safe and secret. We will learn (by example) how to best control and manage highly secure information and learn the underpinnings of how Ansible keeps your information secure.</p>
<p>Let's proceed to learning about the Ansible vault.</p>


            

            
        
    </body></html>