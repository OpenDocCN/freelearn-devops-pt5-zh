- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Automation in a DevOps Workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**DevOps** is a combination of practices, tools, and philosophies that can
    help increase the speed, efficiency, and security of software development, application
    delivery, and infrastructure management processes. DevOps practices and methods
    are common in organizations now due to several advantages, such as faster and
    frequent deployments, improvement in quality, fewer errors, and high transparency
    via automation. By combining automation, collaboration, and integration, it is
    possible to develop and implement efficient DevOps practices, ensuring much higher
    quality output from your IT operations team.'
  prefs: []
  type: TYPE_NORMAL
- en: Due to the numerous integrations, supported plugins, and modules, Ansible is
    a great tool for automating the tasks in your DevOps workflows. Ansible can help
    you automate different stages in the **software development life cycle** (**SDLC**),
    such as building applications, scanning the source code, storing artifacts in
    repositories, deploying the application, configuring application services, and
    more. Automating such application life cycle processes is known as **continuous
    integration** and **continuous delivery** (**CI/CD**). There are several choices
    for CI/CD tools and frameworks, such as Jenkins, CircleCI, GitLab, GitHub Actions,
    Bamboo, and others.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will focus on using Ansible inside the CI/CD and DevOps workflow
    to deploy and manage applications rather than using Ansible as a CI/CD tool.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Serving applications using a load balancer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rolling updates using Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible as a provisioning tool in Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, you will learn how to use Ansible to deploy applications to servers,
    including the load balancer configuration. You will also learn how to implement
    rolling updates using Ansible to deploy the application without downtime and interruption.
    Finally, you will learn how to use Ansible as a provisioner and configuration
    management tool with the infrastructure management tool Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following are the technical requirements for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A Linux machine for the Ansible control node (with internet access)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Three Linux machines for installing and configuring applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of DevOps methodologies, CI/CD tools (Jenkins), and the Git
    workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic knowledge of Terraform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the Ansible code, playbooks, commands, and snippets for this chapter can
    be found in this book’s GitHub repository at [https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-09](https://github.com/PacktPublishing/Ansible-for-Real-life-Automation/tree/main/Chapter-09).
  prefs: []
  type: TYPE_NORMAL
- en: A quick introduction to DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In simple words, **DevOps** is the combination of **development** (**Dev**)
    and **operations** (**Ops**), but in reality, DevOps is a combination of ideas,
    tools, and practices that help increase the speed and efficiency of software development,
    delivery, and infrastructure management processes. There are several known best
    practices we can follow and include in the DevOps workflow, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Team collaboration and transparent communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure as code** (**IaC**) and automated infrastructure management'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerization and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Logging, monitoring, and feedback loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: One of the key concepts in DevOps practices is to reduce the time and effort
    required for application life cycle management, such as integration, build, test,
    release, and deployment. Using DevOps methodologies and tools, it is possible
    to automate this process. This is known as CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about DevOps
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the following guides to understand and learn more about DevOps and
    CI/CD processes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'What is DevOps?: [https://aws.amazon.com/devops/what-is-devops/](https://aws.amazon.com/devops/what-is-devops/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'DevOps explained: [https://about.gitlab.com/topics/devops/](https://about.gitlab.com/topics/devops/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Understanding DevOps: [https://www.redhat.com/en/topics/devops](https://www.redhat.com/en/topics/devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In a typical CI/CD workflow, the developer will push code to the central code
    repository (a Git server, for example) and whenever there is a change in the repository’s
    content, a trigger will be sent to the CI/CD tool (such as Jenkins, CircleCI,
    GitHub Actions, and so on). The following diagram shows a typical CI/CD environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – A typical workflow in a CI/CD environment ](img/B18383_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – A typical workflow in a CI/CD environment
  prefs: []
  type: TYPE_NORMAL
- en: Several tasks are involved in the build, test, delivery, and deployment processes,
    depending on the application type, application platform, and other environmental
    factors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the typical manual and automated tasks for CI,
    CD, and continuous deployment processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – Typical tasks in the CI/CD process ](img/B18383_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.2 – Typical tasks in the CI/CD process
  prefs: []
  type: TYPE_NORMAL
- en: The application can be a simple JAR file, a compressed image, a container image,
    or in any other format (we will learn about container management using Ansible
    in [*Chapter 10*](B18383_10.xhtml#_idTextAnchor178), *Managing Containers Using
    Ansible*).
  prefs: []
  type: TYPE_NORMAL
- en: '**CI** helps developers merge the software code changes regularly and complete
    the testing and scanning processes automatically and quickly. The CI process also
    helps detect the defects, bugs, and security issues in the code quicker and more
    effectively.'
  prefs: []
  type: TYPE_NORMAL
- en: The **CD** process involves automated software life cycle operations such as
    testing the application, scanning, and preparing the application so that it’s
    ready for the production environment (release).
  prefs: []
  type: TYPE_NORMAL
- en: Once the application has been built, scanned, and made available in the application
    repository (application artifacts), it needs to be deployed to production (or
    the development environment) as per the process. This is the next **CD** process
    or **continuous deployment** task and depending on the environment, this can be
    implemented as an automated or semi-automated deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous delivery versus continuous deployment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CD helps in the application life cycle by deploying the application to production
    so that the latest change in the application will reach the end users automatically
    as part of the CI/CD process without any manual intervention. The same CI/CD tool
    or a dedicated tool can be used for the continuous deployment process, depending
    on your application’s nature, environment, and dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The deployment can be part of the CI/CD pipelines or a separate trigger for
    the deployment tool, such as **Ansible Automation Platform** (**AAP**) (you will
    learn how to integrate Ansible inside the CI/CD pipeline using Jenkins in [*Chapter
    12*](B18383_12.xhtml#_idTextAnchor213), *Integrating Ansible with Your Tools*).
  prefs: []
  type: TYPE_NORMAL
- en: Ansible inside CI/CD tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible can be used as the tool for most of the tasks in the CI/CD workflows,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Scanning the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building application artifacts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running unit and integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promoting and testing the application in the staging environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing application artifacts in the artifacts repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the application to production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use Ansible to deploy applications
    to production servers as a continuous deployment tool.
  prefs: []
  type: TYPE_NORMAL
- en: AAP as a CI/CD Tool
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to use AAP as a CI/CD tool and manage the full life cycle of
    an application using Ansible playbooks and job templates. You will learn more
    about this in [*Chapter 12*](B18383_12.xhtml#_idTextAnchor213), *Integrating Ansible
    with Your Tools*.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to reduce the software deployment time by using Ansible. Since
    Ansible can manage the application deployment effectively and efficiently, inside
    the CI/CD pipeline, Ansible can be used as the primary tool to deploy applications.
    The following diagram shows how Ansible is used in Jenkins pipeline jobs for deployment
    purposes (continuous deployment):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – Ansible inside a Jenkins pipeline job ](img/B18383_09_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.3 – Ansible inside a Jenkins pipeline job
  prefs: []
  type: TYPE_NORMAL
- en: 'The software build and CI/CD workflow can be triggered by several native Jenkins
    methods and also by using additional plugins. For example, to activate the build
    trigger based on Git repository changes and to execute Ansible playbooks from
    Jenkins, you must perform a few mandatory steps, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you must install and configure the Ansible plugin for Jenkins to use
    Ansible inside the Jenkins pipeline job. Refer to the documentation at [https://www.jenkins.io/doc/pipeline/steps/ansible/](https://www.jenkins.io/doc/pipeline/steps/ansible/)
    to learn more about the Ansible plugin for Jenkins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ansible in Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://plugins.jenkins.io/ansible](https://plugins.jenkins.io/ansible)
    to learn more about the Ansible plugin for Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: Then, you must install and configure Ansible and its required packages on the
    Jenkins server (or the Jenkins agent machine) as the Ansible playbook will be
    executed from the Jenkins machine. (Later, in [*Chapter 12*](B18383_12.xhtml#_idTextAnchor213),
    *Integrating Ansible with Your Tools*, you will learn how to use Jenkins to call
    automation jobs in AAP.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To trigger the Jenkins pipeline job, the build trigger must be configured on
    the Jenkins job, as shown in the following screenshot. Copy the URL (`JENKINS_URL/job/ansible-demo/build?token=TOKEN_NAME`)
    and the `TOKEN` value and use them in the webhook configuration in the Git server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Build trigger configured on the Jenkins pipeline job ](img/B18383_09_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.4 – Build trigger configured on the Jenkins pipeline job
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever there is a change in the application code, you need to trigger the
    Jenkins pipeline job. To do this, we have configured a webhook in the application
    repository in GitHub, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.5 – Webhook configuration in the GitHub repository ](img/B18383_09_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.5 – Webhook configuration in the GitHub repository
  prefs: []
  type: TYPE_NORMAL
- en: Additional configurations are available in the GitHub webhook configuration
    to help you decide on what condition the webhook is to be called. Refer to the
    GitHub webhook documentation ([https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks](https://docs.github.com/en/developers/webhooks-and-events/webhooks/about-webhooks))
    to learn more about webhooks.
  prefs: []
  type: TYPE_NORMAL
- en: Triggering Jobs with a Simple Webhook
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about Jenkins and webhooks, read [https://docs.cloudbees.com/docs/admin-resources/latest/triggering-jobs-simple-webhook](https://docs.cloudbees.com/docs/admin-resources/latest/triggering-jobs-simple-webhook)
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible inside a Jenkins pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the Ansible plugin has been installed and configured, an Ansible playbook
    can be executed from the Jenkins server (or the agent) by calling it inside the
    pipeline stages. The following screenshot shows sample Jenkin pipeline stages
    being used to utilize Ansible to deploy applications:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.6 – Jenkins pipeline job stages with Ansible tasks to deploy applications
    ](img/B18383_09_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.6 – Jenkins pipeline job stages with Ansible tasks to deploy applications
  prefs: []
  type: TYPE_NORMAL
- en: In the following exercise, I will explain how to deploy website content from
    the source repository using Ansible for continuous deployment tasks.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will use simple website content (static website) to avoid any complications
    to help you understand the application deployment concept using Ansible. The playbook
    can be integrated inside the Jenkins pipeline (or whichever CI/CD tool you are
    using) to implement the continuous deployment task. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Chapter-09/hosts` inventory file with `node1` and `node2` as part
    of the web host group, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B18383_09_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.7 – Web hosts in the inventory
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a playbook called `Chapter-09/deploy-web.yaml` and add the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.8 – Playbook for deploying the web application ](img/B18383_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.8 – Playbook for deploying the web application
  prefs: []
  type: TYPE_NORMAL
- en: The variables can be kept in a separate file or passed from your CI/CD tool
    as arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a task that will clean up the application directory and recreate it (this
    is to ensure any old versions of files are removed from the application path),
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.9 – Tasks to housekeep the application directory ](img/B18383_09_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.9 – Tasks to housekeep the application directory
  prefs: []
  type: TYPE_NORMAL
- en: Add tasks to the same playbook to install the required packages and dependencies.
    Even if you are deploying the application on the same server, it is a best practice
    to install and configure dependencies during every deployment. This can include
    services, packages, system libraries, Python packages, or other files, depending
    on your application’s type and framework.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is also possible to mention the specific version of the packages, as shown
    in the following screenshot. Also add tasks to start `firewalld`, open the firewall
    port for the web service, and start the web service, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.10 – Installing the package and starting the necessary services
    ](img/B18383_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.10 – Installing the package and starting the necessary services
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to deploy the website’s content to the application path. (In
    this exercise, we are using static website content and not a dynamic application.)
    To identify the servers, update the `index.xhtml` file as follows (we are replacing
    `SERVER_DETAILS` with custom text that contains node information in the following
    task):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.11 – Deploying the application and updating its content ](img/B18383_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.11 – Deploying the application and updating its content
  prefs: []
  type: TYPE_NORMAL
- en: Add more tasks as needed, such as configuring the web server with more restrictions
    or custom SSL certificates.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is important to add the verification step as part of automation. We will
    add automated website verification here. In this case, this is a simple health
    check to verify whether the website is working or not. Add a new play (not a task)
    in the same playbook, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.12 – Adding a play to verify the web service ](img/B18383_09_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.12 – Adding a play to verify the web service
  prefs: []
  type: TYPE_NORMAL
- en: Note that instead of hardcoding the server names, we are passing the details
    as Ansible *extra variables*, which will help you pass the server details from
    your CI/CD tools while executing the Ansible playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever we make changes in the application repository ([https://github.com/ginigangadharan/website-demo-one-page](https://github.com/ginigangadharan/website-demo-one-page)),
    GitHub will trigger the build job in the Jenkins server and the playbook will
    be executed as part of the pipeline tasks. (We will explore the Jenkins job and
    pipelines using AAP in [*Chapter 12*](B18383_12.xhtml#_idTextAnchor213), *Integrating
    Ansible with Your Tools*.) For demonstration and testing purposes, let’s execute
    the playbook manually from the console, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and verify the success of tasks (you will get a similar
    result in the CI/CD console when you execute the playbook via the CI/CD pipeline):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.13 – Ansible playbook output with a health check ](img/B18383_09_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.13 – Ansible playbook output with a health check
  prefs: []
  type: TYPE_NORMAL
- en: The `Verify application health` task is successful, which means the website
    is working and serving the content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the website’s content from a web browser, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.14 – Website deployed using Ansible ](img/B18383_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.14 – Website deployed using Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'For practicing further, expand the deployment use case as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Deploy other web applications, API applications, or other compressed application
    files from repositories.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Include more validations, test cases, scanning tasks, and more as needed as
    part of the health check.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use roles to deploy web services, load balancers, databases, and more.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will learn about some of these scenarios in [*Chapter 12*](B18383_12.xhtml#_idTextAnchor213),
    *Integrating Ansible with Your Tools*. In the next section, you will learn how
    to handle multi-node web server traffic with a load balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Serving applications using a load balancer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, you have learned how to deploy applications to multiple servers using
    Ansible with all the necessary prerequisites, dependencies, and basic health checks.
    But if the application or website is running on multiple servers, then you will
    need to tell the end user about multiple servers so that they can access the website.
    It is a best practice to serve the application from a single entity such as a
    load balancer, as shown in the following diagram, so that the end user doesn’t
    need to know the actual web or application server IP addresses. It will also help
    you implement high availability and rolling updates for the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.15 – Website hosted on multiple servers with a load balancer ](img/B18383_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.15 – Website hosted on multiple servers with a load balancer
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are handling the application deployment using Ansible inside the CI/CD
    workflow, we can include the load balancer installation and configuration tasks
    inside the pipeline, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.16 – Jenkins pipeline with HA Proxy installation ](img/B18383_09_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.16 – Jenkins pipeline with HA Proxy installation
  prefs: []
  type: TYPE_NORMAL
- en: 'Since you have deployed website content on `node1` and `node2`, in the following
    exercise, you will learn how to deploy a simple load balancer using `haproxy`
    and then configure `node1` and `node2` as backends:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Chapter-09/hosts` inventory file with `node3` under the `loadbalancer`
    host group:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.17 – Load balancer entry in inventory ](img/B18383_09_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.17 – Load balancer entry in inventory
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating a playbook from scratch, use the `haproxy` role by *Jeff
    Geerling* ([https://galaxy.ansible.com/geerlingguy/haproxy](https://galaxy.ansible.com/geerlingguy/haproxy))
    from**Ansible Galaxy**, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.18 – Installing haproxy role from Ansible Galaxy ](img/B18383_09_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.18 – Installing haproxy role from Ansible Galaxy
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `Chapter-09/deploy-haproxy.yaml` playbook and include the `geerlingguy.haproxy`
    role that you installed in the previous step. The following screenshot shows the
    sample playbook for installing the HAProxy load balancer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.19 – Playbook to install the HAProxy load balancer ](img/B18383_09_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.19 – Playbook to install the HAProxy load balancer
  prefs: []
  type: TYPE_NORMAL
- en: Include the necessary variables for the `geerlingguy.haproxy` role, as shown
    in the preceding screenshot. It is possible to customize the execution of the
    role by referring to the role documentation ([https://galaxy.ansible.com/geerlingguy/haproxy](https://galaxy.ansible.com/geerlingguy/haproxy)),
    but in this demonstration, you will only be adding the load balancer backend and
    a few other details. (Change the IP address so that it matches your `node1` and
    `node2` IP addresses, as configured in the inventory.) The role will take care
    of the `haproxy` installation, configuration, and more. Also, remember to add
    a task to allow port `80` in the firewall (if you are using a different firewall
    such as `ufw`, then amend the playbook with the appropriate firewall module).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, add a new play in the same playbook (`Chapter-09/deploy-haproxy.yaml`)
    to automatically validate the load balancer access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.20 – Adding an Ansible play to verify the load balancer ](img/B18383_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.20 – Adding an Ansible play to verify the load balancer
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and verify the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.21 – The HAProxy playbook with a health check success ](img/B18383_09_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.21 – The HAProxy playbook with a health check success
  prefs: []
  type: TYPE_NORMAL
- en: The `Verify load balancer health` task is successful, which means the load balancer
    (`haproxy`) is working and serving the content from the backend web servers –
    that is, `node1` and `node2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the website’s content using the load balancer IP address (for example,
    `http://192.168.56.45`) from a web browser, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.22 – Website accessed using a load balancer IP ](img/B18383_09_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.22 – Website accessed using a load balancer IP
  prefs: []
  type: TYPE_NORMAL
- en: Once the load balancer is ready, it is possible to enable the DNS for the load
    balancer and share it with the end users (for example, `website.example.com`).
    Users don’t need to worry about remembering the IP address of the website or web
    server. When you have a new version of the website or application, it is possible
    to update the content without downtime as the load balancer will serve the website
    from the available web server in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to handle rolling updates for websites
    and applications without downtime using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Rolling updates using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous deployment is a method meant for frequent application deployment
    (together with CI/CD) and frequent updates of your application or website rather
    than you having to wait for scheduled downtime and deployment cycles. But you
    also need to ensure the application will be available during the update process.
    So far, you have learned that application high availability can be achieved using
    a load balancer. In this section, you will learn how to update the application
    on web servers without downtime.
  prefs: []
  type: TYPE_NORMAL
- en: Steps involved in an application update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Depending on your application’s type and the components involved, the update
    process may contain different steps and procedures. The following diagram shows
    the generic steps involved in the application update process, which is running
    behind a load balancer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.23 – Steps involved in an application update ](img/B18383_09_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.23 – Steps involved in an application update
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to automate all such tasks using Ansible, including validating
    and verifying the services, monitoring tasks, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying updates in a batch of managed nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are running the update tasks on all web servers (for example, `node1`
    and `node2`) in parallel, then there will not be any servers to serve the requests
    from the load balancer and the website will be down. This is not the desired behavior,
    so you need to update the web servers in multiple batches instead of all the servers
    in a single batch. It is possible to achieve this by passing specific remote node
    names, such as `extra-variable`, but that is not a best practice or method as
    you need to execute the playbook multiple times to complete the full website update.
  prefs: []
  type: TYPE_NORMAL
- en: CD and Rolling Upgrades Using Ansible
  prefs: []
  type: TYPE_NORMAL
- en: Ansible orchestration features are very useful for managing multi-tier applications.
    Refer to the documentation at [https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml](https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml)
    to learn more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `serial` keyword in Ansible to specify the number of managed nodes
    to be executed at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.24 – Using serial in Ansible playbook ](img/B18383_09_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.24 – Using serial in Ansible playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, `serial: 25%` means that the play will be executed for 25% of the total
    managed nodes at a time.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows the rolling update flow, where only one node will
    be executed with the update task. The load balancer will still serve the traffic
    from another node:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.25 – Rolling update using Ansible ](img/B18383_09_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.25 – Rolling update using Ansible
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to mention the exact number of nodes in a batch by using
    the `serial: 2` or `serial: 5` keyword. The `serial` keyword is very flexible,
    and you can even control different batches with a different number or managed
    nodes, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.26 – Using different serial values for host batches ](img/B18383_09_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.26 – Using different serial values for host batches
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you will learn how to use the `serial` keyword to deploy
    updates on web servers without causing downtime for the application.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying updates on multiple servers without service downtime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that the CI/CD pipeline includes more tasks, let’s replace the application
    deployment playbook with the rolling update playbook, as shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.27 – The CI/CD pipeline performing a rolling update of the application
    ](img/B18383_09_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.27 – The CI/CD pipeline performing a rolling update of the application
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, you will use `serial: 1`, which means the operations will
    be executed only on one managed node at a time. Control this batch size as required
    based on the number of managed nodes or backend servers:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the website’s content with some changes by creating a new branch in the
    repository. (Use the [https://github.com/ginigangadharan/website-demo-one-page](https://github.com/ginigangadharan/website-demo-one-page)
    repository and make a copy for testing purposes.)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone the repository to your local machine and switch to the production branch
    as follows. Also `checkout` a new branch as `v2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.28 – Clone the repository, checkout to production branch, and create
    a new branch ](img/B18383_09_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.28 – Clone the repository, checkout to production branch, and create
    a new branch
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `index.xhtml` file with some modifications, as follows (for example,
    add `v2` on the home page to identify the changes):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.29 – Updating index.xhtml in the application repository ](img/B18383_09_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.29 – Updating index.xhtml in the application repository
  prefs: []
  type: TYPE_NORMAL
- en: After making these changes, save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Commit all changes and push the new branch, `v2`, to the repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.30 – Commit changes and push the v2 branch to origin ](img/B18383_09_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.30 – Commit changes and push the v2 branch to origin
  prefs: []
  type: TYPE_NORMAL
- en: Now, the new branch that contains the new version of the application is available
    in the GitHub repository. This means we can deploy it to the web servers using
    the `Chapter-09/deploy-web.yaml` playbook. But for the rolling update, you will
    create another playbook called `Chapter-09/rolling-update.yaml` and add the rolling
    update tasks inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new playbook called `Chapter-09/rolling-update.yaml` and add the `serial`
    keyword, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.31 – Rolling update playbook ](img/B18383_09_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.31 – Rolling update playbook
  prefs: []
  type: TYPE_NORMAL
- en: 'During the update, the node will not be able to serve the web pages. Therefore,
    you need to inform the load balancer of this. Add a task to disable the host in
    the `haproxy` backend that you configured earlier. Also, add a task to stop the
    web service (`httpd`) on the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.32 – Removing the host entry from the load balancer ](img/B18383_09_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.32 – Removing the host entry from the load balancer
  prefs: []
  type: TYPE_NORMAL
- en: 'Please note the `delegate_to: ‘{{ item }}’` line as this task will be running
    on the load balancer node. The task will loop through the load balancer nodes
    by using the `with_items: ‘{{ groups.loadbalancer }}’` loop. In our case, there
    is only one load balancer node.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you have similar tasks in the deployment playbook, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.33 – Cleaning up the directory and deploying the application ](img/B18383_09_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.33 – Cleaning up the directory and deploying the application
  prefs: []
  type: TYPE_NORMAL
- en: 'The default branch is set to production (`application_branch: production`)
    inside the playbook; we will override the branch name using the `extra-variable`
    later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have the latest application content, start the web service and add
    the host back to the load balancer backend, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.34 – Post-deployment configuration ](img/B18383_09_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.34 – Post-deployment configuration
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, add another play in the same playbook to verify the web server access
    via the load balancer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.35 – Verifying the play ](img/B18383_09_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.35 – Verifying the play
  prefs: []
  type: TYPE_NORMAL
- en: 'Execute the playbook and check its output. Remember to pass the new branch
    information as `application_branch=v2`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.36 – Ansible rolling update on node1 ](img/B18383_09_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.36 – Ansible rolling update on node1
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, the execution is only happening on one node at
    a time (that is, `node1`) and completes all the tasks for that batch of nodes.
    Later, the playbook will start the tasks for the new batch (that is, `node2`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.37 – Ansible rolling update on node2 ](img/B18383_09_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.37 – Ansible rolling update on node2
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding outputs, the update is happening in the `rolling`
    method. This means that at any time, one of the web servers will be available
    to serve the website in the load balancer backend. It is possible to achieve zero
    downtime during your application update.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s verify the website access using the load balancer’s IP address and
    see the changes (notice the `v2` branch):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.38 – Website after the rolling update (v2) ](img/B18383_09_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.38 – Website after the rolling update (v2)
  prefs: []
  type: TYPE_NORMAL
- en: The process is the same for both static websites and dynamic web applications.
    Include the exact steps you want to execute during the rolling update.
  prefs: []
  type: TYPE_NORMAL
- en: CD and Rolling Upgrades
  prefs: []
  type: TYPE_NORMAL
- en: Refer to [https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml](https://docs.ansible.com/ansible/latest/user_guide/guide_rolling_upgrade.xhtml)
    for more details about rolling updates using Ansible. Also, check out application
    deployment ([https://www.ansible.com/use-cases/application-deployment](https://www.ansible.com/use-cases/application-deployment))
    and Ansible CD ([https://www.ansible.com/use-cases/continuous-delivery](https://www.ansible.com/use-cases/continuous-delivery))
    use cases.
  prefs: []
  type: TYPE_NORMAL
- en: The flexibility of Ansible makes it suitable for implementing automation in
    most of your DevOps workflows. Instead of using Ansible alone, it is always possible
    to integrate Ansible with other tools. With AAP and the Ansible API, it is possible
    to implement more powerful integration in the CI/CD workflow using webhooks, job
    templates, and callbacks. You will learn about AAP and integration in [*Chapter
    12*](B18383_12.xhtml#_idTextAnchor213), *Integrating Ansible with Your Tools*.
    In the next section, you will learn how to use Ansible with Terraform as a provisioning
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible as a provisioning tool in Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible can be used as an IaC tool, as you learned in [*Chapter 7*](B18383_07.xhtml#_idTextAnchor125),
    *Managing Your Virtualization and Cloud Platforms*. At the same time, it is a
    common practice in the industry to use the right tool for the right task – for
    example, Terraform for IaC, Ansible for IT automation, Jenkins for CI/CD pipelines,
    and so on. Instead of comparing similar tools, integrate them in the right place
    and achieve better results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Terraform** is an open source tool by **HashiCorp** for implementing IaC
    practices. Terraform can be used to deploy and manage the cloud-based infrastructure
    and applications using infrastructure code written in a declarative configuration
    language called **HashiCorp Configuration Language** (**HCL**). Depending on the
    cloud platform and components, use the provider modules and resources available.
    Refer to [https://registry.terraform.io/browse/providers](https://registry.terraform.io/browse/providers)
    to explore the available and supported providers.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following Terraform code will provide EC2 instances in the
    AWS platform with the specified **Amazon Machine Images** (**AMIs**) and other
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.39 – Terraform code for EC2 provisioning ](img/B18383_09_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.39 – Terraform code for EC2 provisioning
  prefs: []
  type: TYPE_NORMAL
- en: Terraform is good at handling infrastructure changes and tracking the updates
    using its state management mechanism. But if you want to configure the operating
    system-level components, you need to use Terraform provisioners ([https://www.terraform.io/language/resources/provisioners/syntax](https://www.terraform.io/language/resources/provisioners/syntax))
    as such configurations cannot be represented in the declarative code. Terraform
    supports many provisioners such as `file`, `local-exec`, `remote-exec`, and so
    on. Use either the `local-exec` or `remote-exec` provisioner and use Ansible to
    configure your system, which has been provisioned by Terraform. Choose either
    method, depending on your environment and other tool integration options.
  prefs: []
  type: TYPE_NORMAL
- en: Using Terraform’s local-exec provisioner with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use the `local-exec` provisioner with Ansible, the machine you are running
    Terraform on should have Ansible installed and configured since the `ansible-playbook`
    command will be executed on your local machine, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.40 – Using Ansible as local-exec with Terraform ](img/B18383_09_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.40 – Using Ansible as local-exec with Terraform
  prefs: []
  type: TYPE_NORMAL
- en: 'You also need to pass the credential details such as the username and SSH private
    key in the command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.41 – Terraform code for EC2 provisioning with Ansible automation
    ](img/B18383_09_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.41 – Terraform code for EC2 provisioning with Ansible automation
  prefs: []
  type: TYPE_NORMAL
- en: '`ec2-user` in the preceding snippet is the default user account in the AWS
    Linux AMI. This username or credential can be changed, depending on your EC2 AMI
    or another source image. For example, create a custom base image in AWS, GCP,
    Azure, or other cloud platforms, and then use that image to create the instances
    using Terraform and configure them using Ansible.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Terraform’s remote-exec provisioner with Ansible
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your local machine does not support the installation of Ansible (for example,
    running Terraform on a Windows machine), then it is possible to use the `remote-exec`
    provisioner, but you need to ensure that Ansible is installed inside the remote
    machine provisioned by Terraform. You also need to ensure the playbook and required
    files have been copied to the target machine before calling the `ansible-playbook`
    command using the `remote-exec` provisioner. The following diagram shows the high-level
    workflow in Terraform with Ansible `remote-exec` provisioning:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.42 – Ansible remote-exec provisioning in Terraform ](img/B18383_09_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.42 – Ansible remote-exec provisioning in Terraform
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to `Chapter-09/terraform-aws-ansible-lab` for the Terraform code used
    in the following explanation. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `user_data` argument to pass the basic commands to be executed during
    the initialization of the EC2 instance and Ansible installation. These commands
    can be included in the `user_data` script. A typical user data script can be written
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.43 – User data script for installing Ansible inside an EC2 instance
    ](img/B18383_09_43.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.43 – User data script for installing Ansible inside an EC2 instance
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the previous example, the EC2 instance creation code will have
    more components now, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.44 – EC2 resource with the user_data script ](img/B18383_09_44.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.44 – EC2 resource with the user_data script
  prefs: []
  type: TYPE_NORMAL
- en: The `user-data-dbnodes.sh` script will be executed when the new EC2 instance
    is created. All the components, including Ansible, will be installed inside it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is copying the required playbooks to the remote EC2 instance.
    Here, we have used the Terraform `file` provisioner for this. After that, execute
    the playbook using the `remote-exec` provisioner:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 9.45 – Copying and executing the playbook inside the EC2 instance
    using the remote-exec method ](img/B18383_09_45.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.45 – Copying and executing the playbook inside the EC2 instance using
    the remote-exec method
  prefs: []
  type: TYPE_NORMAL
- en: For further practicing and learning, include the system configuration tasks
    inside the `dbnode-config.yaml` file, such as creating new users, installing database
    packages, starting services, mounting disk volumes, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to *Using Ansible with Terraform* ([https://www.techbeatly.com/using-ansible-with-terraform-ansible-real-life-series](https://www.techbeatly.com/using-ansible-with-terraform-ansible-real-life-series))
    to learn more and understand Terraform and Ansible integration.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you explored the basic concepts, processes, and technical terms
    surrounding DevOps, such as CI/CD and continuous deployment. You also learned
    about some of the possibilities of Ansible integration within the DevOps workflow.
    Then, you learned how to use Ansible inside a continuous deployment workflow using
    Jenkins. After that, you learned about how to perform rolling updates without
    downtime while using Ansible as part of continuous application deployment. Finally,
    you learned how to integrate Ansible with Terraform for IaC provisioning.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to build, run, and manage containers
    using Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Use Terraform to Create a FREE Ansible Lab in AWS*: [https://www.techbeatly.com/use-terraform-to-create-a-free-ansible-lab-in-aws](https://www.techbeatly.com/use-terraform-to-create-a-free-ansible-lab-in-aws)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Deep Dive – Automated NetOps – Ansible for Network GitOps*: [https://www.youtube.com/watch?v=JqE13sP2sq8](https://www.youtube.com/watch?v=JqE13sP2sq8)
    (Video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Continuous integration vs. delivery vs. deployment*: [https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment](https://www.atlassian.com/continuous-delivery/principles/continuous-integration-vs-delivery-vs-deployment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Ansible and HashiCorp: Better Together*: [https://www.hashicorp.com/resources/ansible-terraform-better-together](https://www.hashicorp.com/resources/ansible-terraform-better-together)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Manages a Terraform deployment*: [https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.xhtml](https://docs.ansible.com/ansible/latest/collections/community/general/terraform_module.xhtml)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
