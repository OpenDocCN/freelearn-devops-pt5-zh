<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Breathe Easy – Introduction to Version Control System</h1></div></div></div><p>
<em>We might have wondered numerous times if there is a way we could travel back in time to change what had happened in life. Well, as fictional as it sounds, you are going to learn a method to perform this travel when it comes to digitized files! Yes, you read that right; this chapter is going to introduce you to a system that makes this possible. We will begin by giving you a solid conceptual understanding about version control with Git.</em>
</p><p>This chapter will answer the following questions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is a version control system?</li><li class="listitem" style="list-style-type: disc">Where do you need one?</li><li class="listitem" style="list-style-type: disc">How did they evolve?</li><li class="listitem" style="list-style-type: disc">Why is Git your best bet?</li></ul></div><p>By the end of this chapter you would be able to visualize how you can better handle situations where frequent changes happen on different parts of your digitized files. So let's get started right away!</p><div><div><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Do you need help </h1></div></div></div><p>I learned to play computer games even before learning to switch a computer on or off, for which I sought an adult's help. The early computer games, which put us in awe even at that time, had a few frustrating moments when they wouldn't allow us to save our progress. Even if they had a save option it was a single save slot at a time, which meant you could only save your progress at the cost of your earlier save. This was a shame, because your previous save might have been at an exceptionally fun part of the game that you would like to preserve now and revisit later some day, or even worse, your present save might have been at an unwinnable situation that you want to undo.</p><p>Computer games <a id="id0" class="indexterm"/> have evolved from this state while our way of working with digitized files remains the same. Options like <em>undo</em> and <em>redo</em> help us momentarily when the file that we are working with is still open, but fail to go beyond that. You cannot just open a file and start undoing the changes that you have made before your last save to get back to an older state.</p><p>There are also several situations where we would like to maintain multiple versions of the same file. Even the most widely used way of maintaining multiple versions of a file by naming the new files sequentially, for example, <code class="literal">Inventory_product_2011-09-21.doc</code>, <code class="literal">System_requirement_specification_v6.xls</code>, and so on, become a pain as the number of versions increases because of the huge volume of the number of files that has to be maintained.</p><p>Now if you have experienced or thought about any of these situations and wondered whether there is a way to handle this better, you will be rejoicing at the end of this chapter. This is where a <strong>version control system</strong> (<strong>VCS</strong>) comes into play.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>What is a version control system</h1></div></div></div><p>A system <a id="id1" class="indexterm"/> capable of recording the changes made to a file or a set of files over a time period in such a way that it allows us to get back in time from the future to recall a specific version of that file, is called a version control system.</p><p>To give you a more formal explanation, a version control system is a software package that when initiated will monitor your files for changes and allow you to tag the changes at different levels so that you can revisit those tagged stages whenever needed.</p><p>When installed and initiated, this version control system creates a local directory at the same place where your files reside, which it uses to manage the entire history of the changes made to your files.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Why you need a version control system</h1></div></div></div><p>Try answering the following <a id="id2" class="indexterm"/> questions with regards to your present system setup:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Can you maintain multiple versions of the same file under the same name, thus avoiding cluttering of files with small differences in their names mentioning their versions?</li><li class="listitem" style="list-style-type: disc">Do you have any means of marking a specific portion of your content in the file/files that you might need in future before changing them for present needs?</li><li class="listitem" style="list-style-type: disc">Are you satisfied with the existing scenario where your only failsafe plan for getting back your content is copying and pasting the file or group of files in a separate folder that contains the word "backup" in its name? And updating it regularly?</li></ul></div><p>If your answer to any of these questions is a big<strong> </strong>
<em>no</em>, then that's exactly the reason you would probably need a version control system and this book.</p><p>If your answers to these <a id="id3" class="indexterm"/> questions are <em>yes</em>, it means that you have probably managed to find roundabout ways to solve these issues. Simple measures could include creating a restoration point in latest releases of Windows, which internally stores versions of all documents such as your Word, Excel, or PowerPoint files present at that point in time as a part of creating your restoration point.</p><p>As varied as the potential solutions may be, allow me tell you that version control systems will amaze you with their power, simplicity, and ease of use. They will allow you to achieve much better results with less than half the time and effort that you would normally put into your present solutions.</p><p>By using a version control system you have the power to play with the flow of changes happening to your documents. Whenever you have to make considerable amount of changes to the existing content you can mark those changes as a stage (with a tag) that you can revisit later; this serves as a failsafe mechanism just in case things didn't go as per your plan and you want to revert the content of the document back to a particular older state.</p><p>The following figures demonstrate the flow of content creation with and without a version control system:</p><div><img src="img/7522_01_01.jpg" alt="Why you need a version control system"/></div><p>The previous figure shows you the flow of a content creation matrix at different times spread across sessions. As you can observe in a regular constructive context the flow is from <em>left to right</em>, meaning you progress with content creation one way when it comes to building content on different time periods. In this flow you cannot go back to a previous phase from where you can take a different direction altogether when compared to what you have already taken.</p><p>To explain it <a id="id4" class="indexterm"/> using our flow diagram, you cannot go back to any of the intermediate stages from the final stage to write an entirely different third paragraph to serve a new purpose without any data loss. (You cannot use the undo feature as the content was built across time periods, and you cannot undo something once you have saved and closed your file.)</p><p>Presently we achieve this using the "save as" option, giving the file a different name, deleting the third paragraph, and starting to write a new one.</p><p>In contrast, when you use a version control system, it's a <a id="id5" class="indexterm"/> 
<strong>multi-directional free flow context</strong>. You mark each and every change you consider important as a new stage and proceed with your content creation. This allows you to get back to any earlier stages that you have created, without any data loss.</p><div><img src="img/7522_01_02.jpg" alt="Why you need a version control system"/></div><p>And the best part is you are not limited by the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Number of hops</li><li class="listitem" style="list-style-type: disc">Number of stages between the hops</li><li class="listitem" style="list-style-type: disc">Direction of the hop</li></ul></div><p>This means we can, without any concern, jump to and fro between and across stages in any direction without <a id="id6" class="indexterm"/> any data loss. Now doesn't that sound like the need of the hour?</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Types of version control systems</h1></div></div></div><p>There are three types of <a id="id7" class="indexterm"/> version control systems available. These are classified based on their <strong>mode of operation</strong>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Local version control system</li><li class="listitem" style="list-style-type: disc">Centralized version control system</li><li class="listitem" style="list-style-type: disc">Distributed version control system</li></ul></div><p>Let's quickly go through the history in brief.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Local version control system</h2></div></div></div><p>After understanding <a id="id8" class="indexterm"/> that maintaining multiple versions of files by just following a file naming convention is highly error prone, a <strong>local version control system</strong>
 <a id="id9" class="indexterm"/> was the first successful attempt to solve this issue.</p><p>
<strong>Revision control system</strong> (<strong>RCS</strong>) <a id="id10" class="indexterm"/> was one of the most popular version control systems in this cadre.</p><p>This tool basically works by keeping patch sets (that is, the difference between the file's content at progressive stages) using a special format in the version tracker that is stored in your local hard disk.</p><p>It can then recreate the file's contents exactly at any given point in time by adding up all the relevant patches in order and "checking it out" (reproducing the content to the user's workplace).</p><div><img src="img/7522_01_03.jpg" alt="Local version control system"/></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Tidbits</h3></div></div></div><p>Version tracker <a id="id11" class="indexterm"/> is nothing but a file with its own file format <a id="id12" class="indexterm"/> holding structured content format through which it can perform its functionalities.</p><p>When a file is put under RCS it creates a version tracker entry that will hold details such as RCS configuration for that particular file at the top followed by version number, date, time, author, state, branch, and a link to the next stage followed by contents of the file in a specially formatted manner. After this process your file is deleted!</p><p>Retrieval of the file, as stated <a id="id13" class="indexterm"/> previously, is done through reconstruction of patches.</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Centralized version control system</h2></div></div></div><p>As with any other <a id="id14" class="indexterm"/> software <a id="id15" class="indexterm"/> package or concept, as the requirements kept evolving, users felt that local version control systems limited their activities.</p><p>People were not able to work collaboratively on the same project, as the files with their versions are stored in somebody's local computer and were not accessible to other people working on the same files.</p><p>So how do you solve this problem?</p><p>It is solved by <a id="id16" class="indexterm"/> keeping the files in a common place (server) <a id="id17" class="indexterm"/> that everybody has access to from their local machines (clients). Hence, the birth of a <strong>centralized version control system</strong>.</p><div><img src="img/7522_01_04.jpg" alt="Centralized version control system"/></div><p>Whenever people want to <a id="id18" class="indexterm"/> edit single or multiple files only the last version of the files are retrieved.</p><p>This setup not only provides access to the files for people who require them but also offers visibility on what other people are working towards.</p><p>As the files are stored in one single location from which everybody needs to share the files, any changes made to the files are automatically shared with other individuals as well.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec11"/>Distributed version control system</h2></div></div></div><p>Whenever you bet <a id="id19" class="indexterm"/> big <a id="id20" class="indexterm"/> time on one single unit, the probability of losing is also high. Yes, there is a high degree of risk involved in using a centralized version control system because the users only have the last version of files in their system for working purposes; there is a chance you might ultimately lose the entire history of your files if the server gets corrupt and if you don't have fail-safe procedures implemented.</p><p>Now people get confused. You risk everything when you store your entire history in one single place using a centralized version control concept; on the contrary you lose the power to work collaboratively <a id="id21" class="indexterm"/> when you use local version control.</p><p>So what do you do?</p><p>Exactly! You combine the advantages of both and make a <a id="id22" class="indexterm"/> 
<strong>hybrid system</strong>. And that's one of the key reasons why <strong>distributed version control systems</strong> came into the picture.</p><div><img src="img/7522_01_05.jpg" alt="Distributed version control system"/></div><p>Distributed <a id="id23" class="indexterm"/> version control systems <a id="id24" class="indexterm"/> have the advantages of local version control systems, such as the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Making local <a id="id25" class="indexterm"/> changes without any concern of full time connectivity to the server</li><li class="listitem" style="list-style-type: disc">Not relying on a single copy of files stored in the server</li></ul></div><p>These are combined with the advantages of centralized version control systems, such as the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Reusability of work</li><li class="listitem" style="list-style-type: disc">Collaborative working, not relying on history stored on individual machines</li></ul></div><p>A distributed <a id="id26" class="indexterm"/> version control system is designed to act both ways. It stores the entire history of the file/files on each and every machine locally and also syncs the local changes made by the user back to the server whenever required so that the changes can be shared with others providing a collaborative working environment.</p><p>There are several other <a id="id27" class="indexterm"/> advantages in terms of performance, ease of use, and administration. It's a general saying that "you name anything that a centralized version control system can perform; a distributed version control system can handle the same thing and perform much better".</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Falling for Git</h1></div></div></div><p>We came across different types of version control systems in the previous section, from which we clearly understood that a distributed version control system is what will make our lives easy, safe, and secure.</p><p>Now, there are lots of distributed systems available in the market, so which one to choose?</p><p>Git <a id="id28" class="indexterm"/> is a relatively new software package (April 7, 2005 with its first prototype) that was designed from the ground up to avoid flaws that existed in many other version control systems.</p><p>Linus Torvalds, the man who gave us the Linux kernel, is the proud initiator of this project as well. The very architecture of GIT is tailored for better speed, performance, flexibility, and usability. When I first heard the previous sentence I had the same thought that you have in mind right now: "It talks the talk; can it walk the walk?"</p><p>As a matter of fact there are several live case studies; I got convinced when I saw Git handling the complex Linux kernel source code so gracefully.</p><p>For those of you who don't have any idea about Linux kernel or why it's tagged complex, just think about approximately 9 million lines of content spread across 25,000 files subjected to all kinds of content manipulation, travelling back and forth, numerous times every day by several hundred developers across the world. And still the response time of Git's operations are in seconds.</p><p>Why they trust Git for such challenging tasks and how Git meets their expectations is through the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Atomicity</li><li class="listitem" style="list-style-type: disc">Performance</li><li class="listitem" style="list-style-type: disc">Security</li></ul></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Atomicity</h2></div></div></div><p>Atomicity <a id="id29" class="indexterm"/> is nothing <a id="id30" class="indexterm"/> but a property of an operation that appears to occur at a single instant between its invocation and its response.</p><p>As an example let's take a banking system. When you transfer money from your account to another account, the operation is either completed fully or rejected meaning either the money gets debited from your account and gets credited to the recipient's account or the entire operation gets dropped and no money is debited from your account in the first place.</p><p>These systems avoid partial completions such as the amount getting debited from your account but not getting credited to recipient's account.</p><p>Another example would be a seat reservation system in which the following are the possible states:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Both pay and reserve a seat</li><li class="listitem" style="list-style-type: disc">Neither pay nor reserve a seat</li></ul></div><p>Git creators understood the value of our data, and implemented the same when handling content with Git. It ensures there is no data loss or version mismatch happening due to partial operations, which increases reliability.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Performance</h2></div></div></div><p>No matter how good a car's <a id="id31" class="indexterm"/> interiors are, if it isn't quick enough, it isn't fit enough for racing against time. Git is proven to be manyfold faster than its competitors.</p><p>Even when handling several million files, an operation performed using Git takes only seconds to complete. One of the main reasons for this would be the way Git handles your files. Conceptually most other systems <a id="id32" class="indexterm"/> (CVS, <a id="id33" class="indexterm"/> Subversion, <a id="id34" class="indexterm"/> Perforce, <a id="id35" class="indexterm"/> Bazaar, and so on) look at your data as a set of files and changes made to each of them as the version proceeds.</p><p>The following is a pictorial representation of how other systems handle files and their versions:</p><div><img src="img/7522_01_06.jpg" alt="Performance"/></div><p>In contrast, Git sees a relation between your files and works upon it. It takes a <strong>snapshot</strong>
 <a id="id36" class="indexterm"/> of the entire set of files instead of storing the difference between versions of each file; this <a id="id37" class="indexterm"/> contributes to the lightning speed of Git in certain operations like reverting your file's contents to earlier versions (which we will see in later chapters). Each time a version is created, a snapshot is taken. This doesn't mean that Git stores multiple replicas of your files; if Git finds that there is no change in any of your files' content, just a reference to that file that points to the previous snapshot is stored in the new snapshot, as shown in the following figure:</p><div><img src="img/7522_01_07.jpg" alt="Performance"/></div><p>The best part is that <a id="id38" class="indexterm"/> Git tries to occupy as little space (again, several times less when compared to other version control systems) as possible to maintain version histories of your files. A live case study in handling the source code of Mozilla Firefox published by Keith P. (<a class="ulink" href="http://keithp.com/blogs/Repository_Formats_Matter/">http://keithp.com/blogs/Repository_Formats_Matter/</a>) showed how effectively version control systems utilize space when it comes to maintaining the history of your files.</p><p>Mozilla's CVS repository was 2.7 GB in size; when imported to Subversion the size grew to 8.2 GB, and when put under Git the size got shrunk to 450 MB. For a source code of size 350 MB it's fairly nice to have the whole project history (from 1998) with just 100 MB more space.</p></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Security</h2></div></div></div><p>When you use Git, you <a id="id39" class="indexterm"/> can be sure that no one is tampering with your files' content. Everything that goes into Git is check-summed using an SHA-1 hash before it's stored, and after that it is referred to using that checksum.</p><p>This means it's impossible to change the contents of any file or directory without Git knowing about it. The SHA-1 hash <a id="id40" class="indexterm"/> used here is a collection of 40 hexadecimal characters (a-f and 0-9) which is generated based on the contents of a file or directory structure. The following is an example of a hash:</p><p>9e79e3e9dd9672b37ac9412e9a926714306551fe</p><p>For those of you <a id="id41" class="indexterm"/> who would like to know more about it, you can hear from the very creator, Linus Torvalds, who gives a presentation at Google's tech talk event.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter we discussed problems faced in our daily lives when it comes to digitized files, followed by exactly addressing those issues and assuring a solution to those challenging problems with the help of a version control system.</p><p>We also quickly went through the evolution of version control systems and obtained a solid understanding of how a distributed version control system can make our lives easy.</p><p>Then we got introduced to the best-in-class distributed version control system, Git, and discussed a few reasons for such a claim with some interesting statistics and case studies. This was followed by a view on a few of its internals such as atomicity, performance, and security.</p><p>Now that we've done enough ground work, we're ready to get our copy of Git and get it running in our system, which is the topic of the next chapter.</p></div></body></html>