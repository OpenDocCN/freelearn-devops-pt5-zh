<html><head></head><body>
        

                            
                    <h1 class="header-title">Configuration Management Essentials</h1>
                
            
            
                
<p>If you are reading this book, you are most likely looking for a consistent way to provision infrastructure, deploy code, and maintain the operational consistency of environments. These items all fit under Configuration Management, or CM for short. Configuration Management represents a cornerstone of DevOps and is something that Ansible manages very well. Configuration Management represents a way of development where automation can be used to provision and enforce the state, consistency, and accuracy of a set of systems. In a DevOps-oriented environment, Configuration Management will become increasingly critical for maintaining development environments, QA apparatuses and systems, production environments, and more. This is because the need to maintain such environments and keep a level of consistency among them is critical for deployment and operational success when it's time to release a software title or update.</p>
<p>In this chapter, we are going to learn all about Configuration Management. The chapter will cover and review how tools such as Ansible can make developers, testers, and operations personnel efforts easier by eliminating environment drift, automating the provisioning of infrastructure, and providing an easy and consistent way to spin up environments that match production. The goal of this chapter is to learn and understand automated Configuration Management techniques, and existentially these Configuration Management techniques could then be applied to provide value to small- or large-scale organizations. Within this chapter we are going to specifically address the following topics:</p>
<ul>
<li>Understanding Configuration Management</li>
<li>Understanding the origins of Configuration Management</li>
<li>The aims of Configuration Management</li>
<li>Basic principles of Configuration Management</li>
<li>Configuration Management best practices</li>
<li>How Ansible simplifies DevOps implementations</li>
<li>Binary Artifact Management and Ansible</li>
</ul>
<p>Configuration Management is such an important topic (especially when it comes to solutions such as Ansible). Shall we get started?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Understanding Configuration Management</h1>
                
            
            
                
<p>Unless you have been living in a bubble, you will probably have seen that Configuration Management automation has taken the IT world by storm. That is to say that hosts can now be automatically configured and provisioned to be in a specific state via code (Packages Installed, Users Created and so on). The idea that infrastructure can be defined and codified is not only novel but is now the norm. Configuration Management in many ways represents to infrastructure what software development represents to end-user software products. If it's unclear at this point what CM actually is, let's quickly define it:</p>
<p>Configuration Management is the detailed recording and updating of information that describes an enterprise's hardware and software. Such information typically includes the versions and updates that have been applied to installed software packages and the locations and network addresses of hardware devices.</p>
<p>Now that we have a basic idea of the textbook definition of CM, let's look at how the definition fits into modern software organizations.</p>
<p>Rapid delivery systems in software have added a significant amount of pressure to maintaining clean and stateful systems in production. This means that the development and rollout schedules of the past are just that: a thing of the past. No longer can companies and their product development teams rest on their proverbial laurels after the launch of a new version of their product. With the rapid adoption of broadband, mobile devices, SaaS, and internet access, consumers now demand more frequent updates at a faster pace than ever before. With such a strong demand and no sign of it easing, automation is a must for any company wishing to manage distribution channels in order to remain competitive in today's fast-paced digital world.</p>
<p>Configuration Management has in many ways changed the landscape of modern development patterns. It has encouraged teams to work more collaboratively, push incremental changes to a software system or IT infrastructure item, manage change-control processes, and track changes as they move from one logical group in an organization to another. While Configuration Management techniques are continuing to evolve (about as fast as technology stacks change), the core concepts of CM are holding steady. These core traits are illustrated in this diagram:</p>
<div><img height="185" width="456" class="image-border" src="img/c131035d-f466-469e-8d07-0669a03e584f.png"/></div>
<p>From this diagram, we can see there are a few core tenets of <strong>Software Configuration Management</strong>. These are defined as follows:</p>
<ul>
<li><strong>Release Management</strong>: Release management is the practice of creating automation and processes working in harmony to reliably publish a piece of software for consumption by the target end user.</li>
<li><strong>CM Environment</strong>: CM environments represent a set of physical or virtual replications of a production-release environment. As a best practice they should be automatically provisioned through an <strong>Infrastructure as Code</strong> (<strong>IaC</strong>) solution such as Ansible and the infrastructure should be easily replicated using automation.</li>
<li><strong>Continuous Integration and Deployment</strong>: Continuous integration and continuous delivery have taken the DevOps world by storm. They are actually an important set of practices that encourage collaboration and span the entire delivery pipeline. These practices are detailed further in later pages.</li>
<li><strong>Version Control</strong>: Version control is where all source code and development efforts should be stored. This includes any automated Configuration Management scripts, Ansible playbook's, development code, and automated QA tests.</li>
<li><strong>Work item Tracking</strong>: Work item tracking is simply the practice of dividing, tracking, developing, testing and deploying large implementation efforts for a project into smaller, more reasonable chunks that can be worked on individually. Using a work item tracking solution such as JIRA can help small or large teams develop and release solutions more effectively.</li>
<li><strong>Traceability</strong>: As a software system, infrastructure-development effort, or quality-assurance automation becomes more complex, it's important to try as far as possible to shrink each work effort into smaller, more easily accomplished tasks. As a result of breaking work items into smaller, more easily accomplished tasks, it's important that the traceability of each change to a given software system be available throughout the delivery pipeline.</li>
<li><strong>Baselining</strong>: Baselining an infrastructure solution is important because it provides a solid starting point for <em>all</em> future infrastructure implementations. This means that at any given time, you can reimage a system with the known good baseline and build on it from there. In many ways, this also provides a level of consistency.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Origins of Configuration Management</h1>
                
            
            
                
<p>Configuration Management can be traced back in origins to the early 1950s, an era of punch cards and large mainframe computing apparatuses. Punch cards at the time often needed to be organized and delivered to the mainframe, and as a result of this specific ordering, a requirement was mandated by larger organizations to manage the configuration of such punch cards. After the golden days of punch cards, additional management requirements came to light with regard to maintaining the state of a given software system or IT apparatus. Entities capable of managing such a process at the time were limited to the government's <strong>CDC Update</strong> and IBM's <strong>IBM IEBUPDATE</strong>, respectively.</p>
<p>It wasn't until the early to mid 1990s that software Configuration Management (CM for short) began to be taken notice of in mid- to large-scale organizations. Companies and organizations such as IBM and the Department of Defense were among the first adopters of Configuration Management techniques. At this time, Configuration Management was limited in scope to identifying configuration implementations and changes that were added to a given system (or set of systems). This was in an effort to track the steps necessary to recreate the system or deployment if the system were to fail or have some kind of fault. Thus removing the manual efforts that had preceded this innovation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Aims of Configuration Management</h1>
                
            
            
                
<p>Configuration Management's goal is to facilitate the lives of developers, quality assurance personnel, management, and operational personnel by providing them with the tools and automation necessary to track and implement additional changes and configurations for a target system. The general logic flow of Configuration Management goes something like this:</p>
<p>If I spend four hours configuring a given development system for a developer to use, and then the developer quits the next day, and a new developer gets hired, I have just wasted eight hours. Whereas if I spend eight hours writing a single set of automated scripts to automatically provision a development system and the automation takes 20 minutes to run from start to finish, I can now recreate the developer system easily and with minimal fuss and ceremony.</p>
<p>On a very basic level, this is what Configuration Management is all about: saving time, saving money, saving resources, and minimizing waste. Yes, it takes a bit of work up front, but the result of such a solution is that machines can be commoditized, black magic won't be required to provision and deploy a given system, and people won't have to work twice as hard to achieve the same goal that a machine can already achieve. In addition to this value point, it also codifies team knowledge, whereas there may be one guy that knows how to setup apache (for example) and if he leaves then management of the solution could continue. As such, the aims of Configuration Management could be defined as follows:</p>
<ul>
<li>To track changes made to a given system or set of systems</li>
<li>To provide traceability and auditability for defects that may arise as part of a set of changes made to a given system</li>
<li>To help reduce the amount of manual effort made by developers, QA, and operations folks by maintaining a set of automated solutions that can aid in the provisioning and configuration of a given system</li>
<li>To provide a level of repeatability to the organization by clearly defining (in automation form) the steps required to build out a given system</li>
</ul>
<p>In the previous simple example, we saw how Configuration Management can save both time and money. But now that we know the basic benefits of Configuration Management and how it's used, let's take a look at a few more examples of CM and how it could potentially benefit an organization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scenario 1</h1>
                
            
            
                
<p>Bob works in a large IT software organization as a developer. Bob is working on a bug that he needs some help with. With a proper Configuration Management strategy in place, Bob could easily automate the recreation of his bug environment (the virtual machine used for his local testing and bug recreation efforts) so that both he and his coworker can work on the same bug simultaneously and with minimal fuss in recreating the environment.</p>
<p>In this case, Bob managed to effectively use Configuration Management techniques to not only save his coworker a significant amount of time recreating the bug, but also to remove potential human errors from the equation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scenario 2</h1>
                
            
            
                
<p>Taylor is a quality assurance engineer; he has been contacted by Acme Corporation and has been able to successfully recreate a defect on her local machine that is currently plaguing Acme Corporation. Without a proper Configuration Management solution, Taylor would be limited to entering reproduction steps manually into a JIRA ticket and hoping for a speedy remediation of the defect from developers.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scenario 3</h1>
                
            
            
                
<p>The development team has been working very hard at completing this month's release. The release includes a number of infrastructure changes and environment spin-up requirements. As a result of a solid Configuration Management plan and successful automation, the implementation and rollout of this production release will take a matter of minutes instead of the previous month's hours-long rollout.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Scenario 4</h1>
                
            
            
                
<p>Randy is working hard to help the company's documentation efforts by documenting the recipes of their cloud computing infrastructure. This documentation involves painstakingly recreating the individual components of the system to ensure that new hires have the proper information they need to set up a local working copy of the computing infrastructure. As a result of a solid Configuration Management plan and strategy, Randy has been able to save the numerous hours needed to document this setup solution by simply reading the Configuration Management automation already created and stored in the source control.</p>
<p>As you can see, Configuration Management strategies when used correctly have the ability to save an organization copious amounts of time and, as a result, money in wasted infrastructure costs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic Principles of Configuration Management</h1>
                
            
            
                
<p>Configuration Management aims to help engineering organizations manage the infrastructure, create reusable automation, and provide a strategy for managing change within. As such, Configuration Management purports to provide the following basic principles:</p>
<ul>
<li>Automate where automation is possible</li>
<li>Provide traceability within the enterprise</li>
<li>Provide developers, QA, operations, and management with a reproducible infrastructure that is managed through software-development best practices</li>
<li>Develop a strategy for how new hardware will be provisioned and configured (in an automated way)</li>
<li>Manage hardware configurations effectively and with strategy</li>
<li>Develop mechanisms that provide a self-service model for deploying infrastructure changes</li>
<li>Educate the organization on Configuration Management practices</li>
</ul>
<p>Now that we have a basic understanding of the principles of Configuration Management, let's quickly delve into each of these principles and define them in a bit more depth:</p>
<ul>
<li><strong>Automate everything where automation is possible</strong>: This founding principle of Configuration Management provides us with the guideline that, if a computer can do automatically what a human would do manually, it should be made to do so. While the effort of implementing automation of this type would take time and obviously cost man-hours, the time saved by automating repeatable tasks is significant and the investment upfront would be worth it.</li>
<li><strong>Provide traceability in the enterprise</strong>: Most veteran developers have spent time attempting to hunt down a ghost in the machine, whether it's on their local environment or in production. It's equally as frustrating to spend hours trying to determine what specifically changed. The traceability aspect of this concept is important as it provides those who are tasked with determining the fault access to a list of what line of code changed in a given deployment. With a good Configuration Management plan and automation in place, the traceability you seek can be yours.</li>
<li><strong>Reproducible infrastructure</strong>: If you have ever spent time at work trying to recreate the build environment for a given software system or reproducing a deployment environment, you know how important this one is. If you have not spent time doing this in the past, you are a lucky person indeed. Oftentimes, one of the biggest time sinks is trying to recreate a development or delivery environment and get all the proper libraries, packages, or modules configured exactly right so the system functions as expected. With a proper Configuration Management solution in place (like Ansible), this is totally possible.</li>
<li><strong>Develop a strategy for how new hardware and infrastructure will be automatically provisioned</strong>: This one is probably one of the initial tasks that will need to be done as part of a detailed and comprehensive Configuration Management implementation. With a good plan, the rest will follow.</li>
<li><strong>Develop mechanisms for self-service execution of Configuration Management solutions</strong>: In the long run, you don't want to be the gatekeeper of a Configuration Management solution. You will want to plan and create some kind of self-service Configuration Management solution where your customers (developers, QA, operations, and management) can use your solutions via a button click. Some organizations will leverage Jenkins or Circle CI for such tasks. In the end, the solution to use or create is up to you.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration Management Best Practices</h1>
                
            
            
                
<p>Now that we have a basic understanding of Configuration Management's overarching purpose and how it can be leveraged in an enterprise, let's take a look at some best practices involved in Configuration Management. Configuration Management in the modern software enterprise comes in many forms. Some of the more popular tools for Configuration Management are listed as follows:</p>
<ul>
<li>Ansible</li>
<li>Chef</li>
<li>Puppet</li>
<li>CFEngine</li>
</ul>
<p>Solutions such as these are mostly open source options that provide ways to keep and maintain infrastructure in code form, or IaC (Infrastructure as Code). For those unfamiliar with IaC, here is a general definition from Wikipedia:</p>
<p>Infrastructure as Code is the process of managing and provisioning computing infrastructure (processes, bare-metal servers, virtual servers, and so on) and their configuration through machine-processable definition files, rather than physical hardware configuration or the use of interactive configuration tools.</p>
<p>So, from this definition, we can begin to see that <strong>Infrastructure as Code</strong> (<strong>IaC</strong>) plays an important role in Configuration Management. This is one of the key highlights of Ansible and begins to showcase where it fits into the organization. As such, maintaining infrastructure as code is a Configuration Management best practice.</p>
<p>Another key best practice of a sound Configuration Management strategy is change control. This concept really became popular in the early to mid 1990s and provided development resources with the ability to track changes to source code related to product development. As source control management became more and more popular, people began finding new uses for this solution. Eventually, IaC was stored in source control and this became more essential to effectively managing Configuration Management assets.</p>
<p>As a result of IaC, some organizations began simply tying the <strong>source control management</strong> (<strong>SCM</strong>) solution into their deployments. This unfortunately violates a best practice of CI/CD that effectively requires artifacts (including automation) to be versioned appropriately and frozen easily so as to allow easy rollbacks and roll-forwards.</p>
<p>Source control systems have come a long way since their early infusion into the software development industry. Modern implementations such as Git and Mercurial have provided new and creative ways of branching, storing source code, and providing offline access to source-code resources. As Configuration Management specialists, it is our job to encourage good practices within source code and help ensure our infrastructure and automation remains of high integrity.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How Ansible Simplifies DevOps Implementations</h1>
                
            
            
                
<p>Ansible is a relatively new player in the software Configuration Management space. Its initial entry into the space was as an open source software creation managed by the team at Ansible in 2012. The name Ansible is derived from the 1980s novel Ender's Game and was selected by Ansible creator, Michael DeHaan. The main effort behind the solution was to provide a simple-to-use and human-readable implementation of a Configuration Management solution.</p>
<p>The initial implementation of Ansible was derived in 2012 and aimed to fit the following principles:</p>
<ul>
<li><strong>Minimal development required</strong>: Configuration Management systems should be lightweight and simplistic in nature.</li>
<li><strong>Consistent in execution</strong>: Ansible aims to provide a consistent set of rules and expectations in its core implementation.</li>
<li><strong>Secure</strong>: The Ansible platform was developed using SSH as its recommended protocol, which provides a secure transport method for remote execution of Configuration Management code.</li>
<li><strong>Scalable</strong>: Whether it's targeting one server or 1,000, the system needs to be able to scale effectively. Ansible has been built with this in mind.</li>
<li><strong>Highly reliable in nature</strong>: Providing a consistent execution model is the aim of Ansible—a very reliable execution platform with minimal bugs.</li>
<li><strong>Easy to learn</strong>: Eschewing on the complexity of CFEngine and others, Ansible aims to be the easiest-to-learn Configuration Management tool in the industry.</li>
</ul>
<p>Now that we know the principles Ansible was built upon, let's take a look at how it enhances a DevOps implementation specifically.</p>
<p>Ansible (as we mentioned earlier) was designed to be consistent, easy to manage, scalable, secure, and minimal. With these principles in mind, let's take a quick look at a simple DevOps environment diagram and see how Ansible fits in:</p>
<div><img height="222" width="516" class="image-border" src="img/28f4e79e-e9ae-4bed-b9cb-bba962dcb61a.png"/></div>
<p>In the diagram, we can see four unique environments (<strong>Dev</strong>, <strong>Test</strong>, <strong>Stage</strong>, and <strong>Production</strong>). These environments are fairly common across DevOps implementations and cloud computing software organizations. Some organizations may have more, some fewer. In a DevOps environment, there may be one or multiple servers or devices that need to be consistently provisioned and deployed to. The consistency across these environments is critical for the eventual release of a software system to production.</p>
<p>Ansible in many ways helps maintain consistency across environments as it provides an easy-to-use automation solution that can be executed in the following manner:</p>
<ul>
<li>Simultaneously across environments</li>
<li>Consistently across environments</li>
<li>In an idempotent manner that provides a level of congruency across environments</li>
</ul>
<p>Given the diagram, we can see that each environment would be pushed to symmetrically use a Configuration Management tool such as Ansible. This tool would sit on a central location with access to each of the aforementioned environments. As such, it would be in many ways the governor of the systems. The diagram provided next shows the basic architecture of the push-model architecture that Ansible provides:</p>
<div><img height="294" width="492" class="image-border" src="img/8b73a4f7-c087-49df-94ee-872dcd24be37.png"/></div>
<p>From this diagram, we can see a few things that fit into our Configuration Management best practices list we talked about earlier:</p>
<ul>
<li>The Configuration Management resources are stored in a VCS (version control system).</li>
<li>The Ansible provisioning machine has access to both the VCS and the deployment servers. In some cases, this is good, but in some cases it may be useful to bundle your Ansible resources in with your artifacts (we will talk more about that later).</li>
<li>Ansible has the ability to target specific server types and configure and deploy to each in a unique way. No matter whether it is the company's web, application, or main database server, Ansible automates otherwise tedious configurations so that we can concentrate on more valuable tasks. This process is done through the development of <em>playbooks</em>, or prewritten configuration setups, which save both time and money, as will be discussed later.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Binary Artifact Management and Ansible</h1>
                
            
            
                
<p>In a development project of any scale, anywhere from tens to thousands of artifacts are used, produced, and filed. Most of these digital fragments are in-house resources, but most organizations also utilize libraries and other resources licensed from outside companies, licensed for particular uses and, usually, for contract-specified lengths of time. Managing and complying with these requirements by hand, while possible, would take up far more time than the vast majority of organizations are willing to commit. As such, an artifact-management system should exist to manage these limitations and ensure the same version of any given resource is available to each developer, no matter where they might be. With this in mind, the concept of the artifact repository was born. A central location for all things to be used, created, and managed during the development process resides here until called upon for use in any given software project, however great or small in nature.</p>
<p>Managing dependencies is another important aspect of resource management that cannot be downplayed, as very few software development projects are without dependencies of some sort. Without a system to manage versions and dependencies, our developer Bob from the first <em>Aims of Configuration Management</em> scenario might not be able to adequately address a bug that comes up in a ticket. This is due to his lack knowledge of the correct versions of one or more resources that, when combined, cause an issue with how the software functions. These compatibility collisions are common amongst teams who dont maintain a repository for versioned dependencies.</p>
<p>Finally, there is the subject of governance as an important factor in the necessity for a capable binary asset management solution. Since the resources developers use for building software are not only subject to licensing restrictions, and the versions of the resources used are potentially different for each minor/major version of the products being developed, governance is key. Governance requires making sure every resource that sits in our artifact repository has been properly categorized, vetted for quality, and annotated. It ensures that all pertinent licensing and usage requirements have been met and ensures that overall development process flows as smoothly as possible. In addition, governance provides the company with a level of surety that it does not get hit with post-production license issue.</p>
<p>The following is a diagram demonstrating the overall workflow of workstations pulling resources from artifact repository server/machines to use in software development. Once ready to be pushed to production, the completed work is then sent up to the provisioning machine to be paired up with the appropriate playbook. Once paired with the playbook of choice, the change is then sent to the appropriate location for implementation:</p>
<div><img height="308" width="436" class="image-border" src="img/4fdd795a-f972-4e77-8358-e0be060abbb8.png"/></div>
<p>Ansible, a very capable configuration-deployment tool in its own right, is limited in its built-in artifact-management capabilities. Even though many would like Ansible to be a one-stop solution for Configuration Management and deployment, it is but one of many tools in any DevOps team's toolkit to ensure timely deployment of product releases and overall mission success.</p>
<p>Fortunately, all is not lost, as several popular BRM tools are widely used in today's development environments that interface, augment, and complement the capabilities of Ansible while picking up where it leaves off. The following is a list of popular tools that perform well for their respective functions and interface well with Ansible. While popular, the list is neither all-inclusive nor complete, as the market for solutions to this function is always changing, new options being added constantly.</p>
<ul>
<li>JFrog's Artifactory (<a href="https://www.jfrog.com/artifactory/">https://www.jfrog.com/artifactory/</a>)</li>
<li>SonaType's Nexus (<a href="https://www.sonatype.com/nexus-repository-sonatype">https://www.sonatype.com/nexus-repository-sonatype</a>)</li>
<li>Apache's Archiva (<a href="https://archiva.apache.org/">https://archiva.apache.org/</a>)</li>
<li>Inedo's ProGet (<a href="https://inedo.com/proget">https://inedo.com/proget</a>)</li>
</ul>
<p>With applications such as Archiva and other Maven-based artifact repository managers, Ansible already has packages built in or easily obtainable, such as <kbd>maven_artifact</kbd> that attempt to grab the required dependencies/artifacts from Maven-based BRMs. For others, such as Nexus, third-party modules exist that serve to make grabbing artifacts from those systems just as easy and painless.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>So far, we have taken a brief ride into what the world of DevOps entails, where it came from, the core principles that make it revolutionary, and its grand rethinking of the processes behind the planning, development, testing, and release of stable software in today's fast-paced world. We also briefly touched on what role Ansible plays in the grand scheme of it all and what makes it so capable of being an important, if not vital, tool in the modern developer's toolkit.</p>
<p>Next, we get into the meat and potatoes of what this book is truly about, which is the software itself. We will learn about it all, from the initial installation of the software on the platform of your choice to ensuring that Ansible is configured properly to talk and interact with various parts of the installed environment so that it can successfully perform its tasks, using the command line of Ansible to navigate the overall setup; and even exploring what core modules are installed as standard, what they do, and where to find more when the need arises.</p>


            

            
        
    </body></html>