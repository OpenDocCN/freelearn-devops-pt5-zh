- en: Kubernetes Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we discussed container architecture, worked with Docker
    images and containers, took a look at different Docker registries, learned how
    to manage persistent storage for containers, and finally, learned how to build
    our own Docker image with Dockerfile. All these skills will be required in [Chapter
    3](part0093.html#2OM4A0-78aafb146b304cdeb9b3261a70edabde), *CRI-O Overview*, where
    we start working with Kubernetes. Kubernetes is an essential and critical OpenShift
    component. It all works like a snowball: Docker skills are required by Kubernetes,
    and Kubernetes skills are required by OpenShift.'
  prefs: []
  type: TYPE_NORMAL
- en: Container management in a distributed environment is difficult, but not with
    Kubernetes. This brief introduction to Kubernetes will give you an idea of what
    Kubernetes is and how it works. In this chapter, you will learn how to install
    and configure a Kubernetes cluster using a simplified method. We will also explain
    the container management basics, including some theories regarding pods, services,
    and routes. We will show you how to deploy an application in a Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Since, in our lab environment, we have only one Kubernetes node, we are going
    to use the Kubernetes cluster and Minikube VM terms interchangeably in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Container management systems overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between Kubernetes and Docker Swarm
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes key concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes installation and configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with kubectl
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clearing the virtual environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes limitations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to use the following technologies and software:'
  prefs: []
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firefox
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will be required to install Minikube on your laptop or any other virtual
    environment you are going to use. All the instructions for installing Minikube can
    be found at [https://kubernetes.io/docs/tasks/tools/install-minikube/](https://kubernetes.io/docs/tasks/tools/install-minikube/).
  prefs: []
  type: TYPE_NORMAL
- en: All the code for this chapter is located on GitHub at [https://github.com/PacktPublishing/Learn-OpenShift](https://github.com/PacktPublishing/Learn-OpenShift).
  prefs: []
  type: TYPE_NORMAL
- en: Bash Shell will be used as a part of your virtual environment.
  prefs: []
  type: TYPE_NORMAL
- en: Firefox or any other browser can be used to navigate through Docker Hub.
  prefs: []
  type: TYPE_NORMAL
- en: Container management systems overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containers offer unmatched benefits in terms of density, deployment speed, and
    scalability in comparison to virtualization. But containers by themselves are
    not enough to match all the requirements of today's business, which expects the
    infrastructure to be adaptable to dynamic challenges. It is quite simple to start
    and manage a couple dozen containers, but things get complicated when the number
    climbs to hundreds, which is very common for large workloads. This is where **Container
    Orchestration Engines** (**COE**) come in. They bring true power to containers,
    offering various mechanisms to deploy, destroy, and scale multiple containers
    rapidly.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple container management solutions available, with the most
    popular being Kubernetes and Docker Swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes**: First released in July 2015, Kubernetes comes directly from
    Borg—a cluster management and job scheduling system developed by Google. Kubernetes
    was also developed by Google engineers; in fact, many developers who previously
    worked on Borg later moved to working on Kubernetes. Like Docker, it is written
    in Go, the language also designed and implemented by Google in 2007\. It''s built
    around the concept of resources—complex API entities that serve as an interface
    to the underlying mechanisms and serialized in YAML or JSON. All software components
    run on two types of machine: masters and nodes. Masters perform management, dispatching,
    and synchronization functions, while nodes provide a runtime environment for running
    containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Swarm**: Docker Swarm is a native container orchestration solution
    provided by the Docker project. It has many features that Kubernetes provides,
    but does this using different mechanisms and can be used to quickly deploy a single
    service or even a stack of services on worker nodes. Swarm Cluster consists of
    two types of node: managers and workers. Managers control the placement of containers,
    which are referred to as *tasks* in Swarm terminology, and workers do the heavy
    lifting of running containers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes versus Docker Swarm
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes and Docker Swarm are the most commonly used orchestration frameworks.
    They provide a similar set of capabilities and essentially solve the same problem—management
    containers in an unsafe and highly dynamic environment. While some of their features
    overlap, there are also significant differences and the choice of system depends
    on many factors, such as the number of containers, availability requirements,
    and team expertise, to name a few.
  prefs: []
  type: TYPE_NORMAL
- en: 'The table provides an insight into the most important differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Kubernetes** | **Docker Swarm** |'
  prefs: []
  type: TYPE_TB
- en: '| A separate modular design project that has its own dependencies. | Native
    container orchestration solution available out of the box. |'
  prefs: []
  type: TYPE_TB
- en: '| Relatively steep learning curve due to new concepts and complex architecture.
    | Easy to get started; uses familiar terminology; more lightweight. |'
  prefs: []
  type: TYPE_TB
- en: '| A pod is a minimal unit of deployment which represents a group of containers.
    Integration with other applications is accomplished via services that in this
    case represent a consistent `IP:port` pair. | Application deployed in containers
    as services across an entire cluster or a subset of workers using labels. |'
  prefs: []
  type: TYPE_TB
- en: '| Auto-scaling is supported via deployments/replication controllers by specifying
    a desired number of pods. Dynamic auto-scaling that takes CPU utilization into
    account is provided by the `HorizontalPodAutoscaler` resource. | Auto-scaling
    is not supported out of the box; manual scaling is still possible. |'
  prefs: []
  type: TYPE_TB
- en: '| A persistence storage layer is separated into two components, PVs and PVCs,
    which are dynamically bound together on request and can be used to implement shared
    storage. | Storage volumes are mounted directly into containers. |'
  prefs: []
  type: TYPE_TB
- en: '| New masters can join an existing cluster, but promotion/demotion of a node
    is not supported. | Worker nodes can be easily promoted to managers and vice versa.
    |'
  prefs: []
  type: TYPE_TB
- en: '| Services are assigned unique DNS names based on the projects they were created
    in and their names, so each service can reach any other in the same namespace
    by using its name without domains. | Each service is registered in an internal
    DNS with the name based solely on the name of the service itself. |'
  prefs: []
  type: TYPE_TB
- en: Kubernetes key concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any complex system, a Kubernetes cluster can be viewed from multiple perspectives.
    From the infrastructure perspective, it comprises two sets of nodes; they can
    be bare-metal servers as well as VMs:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Masters**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This type of node is responsible for cluster management, network allocation,
    quota enforcement, synchronization, and communication. Master nodes act as the
    main point of contact for clients—be it actual people or some external system.
    In the simplest setup, there can be only one master, but highly available clusters
    require at least two to prevent common fail situations. The most important service
    that masters run is the API.
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nodes do the actual work of hosting Docker containers. More specifically, nodes
    provide a runtime environment for running pods, which are described later in this
    book. These servers run the kubelet service to manage pods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00027.gif)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes architecture
  prefs: []
  type: TYPE_NORMAL
- en: 'Logically, the Kubernetes API provides a number of resources that allow you
    to use various mechanisms provided by Kubernetes while abstracting some low-level
    implementation details. These resources can be defined in either YAML or JSON
    format. Here are some of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Namespaces**: These resources serve the purpose of separating organizational
    units of users and their projects in a multitenant environment. Moreover, they
    are used for more fine-grained access control and quota enforcement. Almost all
    Kubernetes resources, except Volumes and Namespaces themselves, are namespaced,
    which means their names must be unique in any given namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pods**: Pods represent a collection of containers and each pod serves as
    a basic management unit in Kubernetes. All containers in a pod share the same
    storage volumes and network.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Services**: They represent an interface between clients and the actual application
    running in pods. A service is an `IP:port` pair which forwards traffic to backend
    pods in a round-robin fashion. Having a consistent address and port saves clients
    having to keep up with any transient changes in the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replication Controllers** (**RC**): In a nutshell, these resources define
    how many pods must be replicated. Their definitions include pod templates that
    describe pods to be launched, and one of the parameters each RC contains is the
    number of replicas to be maintained. If for some reason one or more of the pods
    go down, Kubernetes will launch new ones to satisfy this number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent Volumes** (**PV**): These resources abstract actual physical storage
    systems, be it NFS, iSCSI, or something else. Typically, they are created by a
    cluster administrator and can be mounted inside a pod using the PVC binding mechanism,
    which is mentioned later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Persistent Volume Claims** (**PVC**): PVC represents a request for storage
    resources. Pod definitions don''t use PVs directly; instead, they rely on binding
    PVs to PVCs, performed by Kubernetes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secrets**: Used for passing sensitive data such as keys, tokens, and passwords
    inside pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Labels**: Labels provide a mechanism for scoping a set of resources using
    selectors. For example, services use selectors to specify what pods to forward
    incoming traffic to. When new pods are started with the same label, they are dynamically
    associated with the service that has their label specified as a selector in its
    definition.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is a sample scenario with two teams residing in Denver and Phoenix, with
    separate namespaces. Selectors, labels, and a number of replicas are specified
    using the same notation as in actual YAML definitions of services, pods, and replication
    controllers, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00028.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes resources
  prefs: []
  type: TYPE_NORMAL
- en: 'From a service point of view, Kubernetes can be represented as a set of interacting
    services:'
  prefs: []
  type: TYPE_NORMAL
- en: 'These services typically run on masters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd`: This is a distributed key-value configuration store that holds all
    metadata and  cluster resources. Due to its quorum model, you are advised to run
    an uneven number of etcd nodes, starting from three in a highly available setup.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-apiserver`: Service that exposes the Kubernetes API to clients. Its stateless
    nature enables it to be deployed in a highly available configuration by scaling
    horizontally.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-scheduler`: Component that governs the placement of newly created pods
    on nodes. This procedure takes into account such factors as hardware/policy limitations,
    data locality, and affinity rules. It is worth noting that from the cluster point
    of view, masters are no different from any other node and thus can be eligible
    for running pods, although best practices suggest not putting additional strain
    on master nodes and dedicating them only to management functions.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-controller-manager`: The component that runs various controllers—some
    of them are replication controllers that maintain the required number of running
    pods, node controllers for discovering nodes that went down, a volume controller
    for binding PVs to PVCs, and an endpoints controller that binds services and pods
    together.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud-controller-manager`: Service that provides integration with underlying
    cloud providers, such as DigitalOcean and Oracle Cloud Infrastructure.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These services typically run on nodes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubelet**: This service uses a pod specification to manage its pods and conduct
    periodic health checks.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**kubeproxy**: This component implements service abstraction by providing TCP
    and UDP forwarding capabilities across a set of backend pods.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Container runtime environment**: This component is represented in Kubernetes
    by an underlying container technology. At the time of writing, Kubernetes supports
    docker and rkt as runtimes:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00029.gif)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes services
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes installation and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will install Minikube—a simple single-node Kubernetes cluster.
    While not suitable for any production-grade workload, it is a useful tool to learn
    the basics of cluster management quickly. Although it supports several drivers
    for VM providers, in this tutorial we will use the KVM2 driver since KVM virtualization
    is available even in a base Linux environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'The easiest method is to go to [https://kubernetes.io/docs/getting-started-guides/minikube/](https://kubernetes.io/docs/getting-started-guides/minikube/) and
    install Minikube on your favorite OS. Then go to [https://kubernetes.io/docs/tasks/tools/install-kubectl/](https://kubernetes.io/docs/tasks/tools/install-kubectl/)
    and install `kubectl`. `kubectl` is a CLI command to manage Kubernetes. Once you
    are done, it is time to start Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Once download and setup stages are complete, check your Kubernetes cluster
    status with the `minikube` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the Kubernetes cluster status with the `kubectl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also open a browser or use the curl command to verify the Kubernetes
    API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a nice dashboard that comes with Kubernetes''s nice-looking GUI, available
    on port `30000` via HTTP (for example, `http://192.168.99.100:30000/`). You can
    open your browser using the same IP we used for cluster verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Kubernetes GUI
  prefs: []
  type: TYPE_NORMAL
- en: At this moment, there is not much to look at, as our simple cluster has only
    one node, one service, and three default namespaces. This is one way to manage
    Kubernetes, but to be able to effectively use all its features and troubleshoot
    issues, you need to get comfortable with using CLI, which is what the next section
    is about.
  prefs: []
  type: TYPE_NORMAL
- en: Working with kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubectl is a command-line interface for managing a Kubernetes cluster and its
    resources. In this section, you will learn about the most common commands and
    their use cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for all the commands follows this convention:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Commands in angle brackets `<>` mean the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COMMAND`: An action to be executed against one or more resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RESOURCE_TYPE`: The type of resource to be acted upon, for example, a pod
    or service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RESOURCE_NAME`: The name of the resource(s) to manage.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: Various flags used to modify the behavior of kubectl commands. They
    have higher priority than default values and environment variables, thus overriding
    them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting help
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'kubectl has hundreds of different subcommands, options, and arguments. Luckily,
    kubectl has really good help options. The first one is man pages. If you are using
    macOS or Linux, you can run the `man-f kubectl` command to check kubectl-related
    man pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If for some reason you do not have man pages available on your system, you
    can just run the `kubectl` command without any options or arguments. It will show
    you a list of available subcommands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to check the list of available resources by running `kubectl <command>` or `kubectl <command>
    --help` commands, for example, `kubectl get`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you can also get `kubectl get` command examples by running `kubectl
    get -h` and a detailed resource explanation by running `kubectl explain pods`.
    The `kubectl` command is very easy to navigate and work with.
  prefs: []
  type: TYPE_NORMAL
- en: Using the kubectl get command
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first essential command to run is `kubectl get nodes`. It gives us the
    number of Kubernetes nodes available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In our case, the number of nodes will be equal to one, since we are using one
    VM for our practice. As we mentioned already, in order for different projects
    to coexist on the same or different nodes, namespaces are used. You may guess
    that the command we should use is `kubectl get namespaces`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It shows you that three default namespaces are available when you install Kubernetes
    with Minikube:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name       **                           | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `default` | The namespace where all resources without other namespaces are
    placed. It is used when the name of a namespace is not specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `kube-public` | Used for resources that must be publicly available even to
    unauthenticated users. |'
  prefs: []
  type: TYPE_TB
- en: '| `kube-system` | As the name implies, it is used internally by Kubernetes
    itself for all system resources. |'
  prefs: []
  type: TYPE_TB
- en: 'The last main missing component here is pods; as previously mentioned, pods
    represent a collection of containers and a pod is a basic management unit in Kubernetes.
    In our case, pods are Docker containers. We do not have any running pods yet,
    which can be easily verified by `kubectl get pods`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It says `No resources found`, all because the pod is a Kubernetes resource,
    similar to other resources we are going to cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly to `kubectl get pods`, you can get the status of any other Kubernetes
    resource. We will discuss other Kubernetes resources later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Running Kubernetes pods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As with Docker, we can run a Kubernetes pod with the `kubectl run` command.
    Let''s start with a simple web server example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the result by getting a list of Kubernetes pods, by running the
    `kubectl get pods` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The first time you run this command, you will probably see that the Kubernetes
    pod status shows up as `ContainerCreating`. What is happening behind the scenes
    is that the Docker httpd image is being downloaded to Minikube VM. Be patient
    and give it some time to download the image. A few minutes later you should be
    able to see the container status is `Running`.
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl run` command does more than just download an image and run a container
    out of it. We are going to cover this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The `8576c89d7-qjd62` part is generated automatically. We are going to discuss
    this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Essentially, this pod is a Docker container inside our Minikube VM, and we
    can easily verify this. First, we need to ssh into Minikube VM with `minikube
    ssh`, and then run the `docker ps` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can try to kill this httpd Docker container, but Kubernetes will automatically
    spawn the new one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the container status one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the httpd container is still up, but with another ID. The initial
    ID was `c52c95f4d241` and it became `5e5460e360b6` (you will have other IDs).
    That is one of the benefits of Kubernetes: if one container dies, Kubernetes will
    bring in a new one automatically. We are going to discuss this in detail later
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Describing Kubernetes resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can quickly take a look at the internals of this pod by running the `kubectl
    describe` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: It gives us enough information to efficiently locate the pod and do the proper
    troubleshooting when necessary. In our case, we can ssh to Minikube VM and run
    the curl command to check if the pod is running the web server properly.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to use another IP address for the `curl` command; in our case it
    is `172.17.0.4`, derived from the `kubectl describe` command output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Note that this pod is accessible only inside the Kubernetes cluster. That is
    the reason why we need to log in to Minikube VM. If we try to access this address
    from our local PC, it will not work. We are going to discuss this in the following
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Editing Kubernetes resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can also edit the properties of a running container with `kubectl edit pod
    httpd-8576c89d7-qjd62`. We are not going to change anything at this point, but
    you can try to change something before we delete the container. We are going to
    work with the edit command while working with OpenShift in further chapters.
  prefs: []
  type: TYPE_NORMAL
- en: The `kubectl edit` command by default uses the vi editor. Learn how to use vi
    first if you are not familiar with this text editor, otherwise you might get into
    trouble.
  prefs: []
  type: TYPE_NORMAL
- en: Another trick that you can do is to change the editor by running `export EDITOR=nano`,
    where nano is your favorite text editor.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, you can edit any other Kubernetes resources. We will discuss other
    Kubernetes resources later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing Kubernetes services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we run a pod using the `kubectl run` command, this pod is accessible only
    inside Kubernetes. In most of cases, we would want this pod to be accessible from
    the outside as well. This is where the `kubectl expose` command comes in handy.
    Let''s create the httpd pod one more time and then expose it to the outside world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s use the `kubectl expose` command and expose the httpd web server
    to the outside of Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'While using the `kubectl expose` command, we specify several options:'
  prefs: []
  type: TYPE_NORMAL
- en: '`port`: Pod (Docker container) port that we are going to expose to the outside
    of the Kubernetes cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`name`: Kubernetes service name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: Kubernetes service type. NodePort uses Kubernetes Node IP.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The command to get a list of exposed Kubernetes services is `kubectl get services`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that port `80` was mapped to dynamic port `31395` on the Minikube VM. The
    port is dynamically chosen in the range `30000–32767`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there is a `ClusterIP` field with the IP address `10.110.40.149` allocated
    for the `httpd-expose` service. Do not pay attention to this at the moment; we
    are going to discuss this later in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, use `curl` to check if the httpd server is available from the outside
    of the Kubernetes cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If you open this link in your web browser, you should see `It works!` on the
    web page.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you have an application that consists of one pod and one service, there
    is no problem operating these resources. But when your application grows, or you
    have tens or hundreds of projects, pods, services and other Kubernetes resources,
    it will get harder to operate and effectively troubleshoot Kubernetes. This is
    where we can use the Kubernetes labels we mentioned earlier in this chapter. We
    are going to run a couple more Kubernetes pods using labels:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the Kubernetes pods we have at the moment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, imagine you have at least 10 or more pods. In order to efficiently filter
    out this output, we can use the `-l` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Filtering out output with Kubernetes labels is not the only use case. Labels
    are also used alongside selectors. You can get more information on both topics
    using the Kubernetes official documentation at [https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/](https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/).
  prefs: []
  type: TYPE_NORMAL
- en: Deleting Kubernetes resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we''ve done something wrong with the pod, or it may have broken for some
    reason, there is a simple way to delete a pod using the `kubectl delete pod` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We can delete all pods using the `--all` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note that if you run `kubectl get pods`, you will see all the containers running
    again. The reason for this is that, when we run the `kubectl run` command, it
    creates several different Kubernetes resources, which we are going to discuss
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can delete Kubernetes resources by running `kubectl delete all` with the `-l`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This command will delete all Kubernetes with a `httpd-demo1` label only. The
    other two pods will be still available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can delete all Kubernetes resources we have created so far
    by running the `kubectl delete all --all` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes advanced resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we create an application with the `kubectl run` command, it takes care
    of several things. Let''s create an httpd pod by running this command one more
    time and take a deeper look at what actually happens behind the scenes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can take a look at the series of events that took place during this process
    by running the `kubectl get events` command. It shows you what Kubernetes did
    behind the scenes to launch this application. You will see quite a long list,
    which may seem confusing at first glance, but we can narrow it down by using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We are using the `kubectl get events` command with the `--sort-by=.metadata.creationTimestamp`
    option to sort our events by timestamp. If you execute this command without this
    option, events will be out of order.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are mostly interested in the last two fields on every line. They are `SOURCE`
    and `MESSAGE` respectively. If we read from top to bottom in the series of events,
    we will see that one Kubernetes component tells the other component to create
    a pod with the name `httpd1-6d8bb9cdf9-thlkg` on Minikube VM, which finally happens.
    Let''s describe some of those components:'
  prefs: []
  type: TYPE_NORMAL
- en: '`replicaset-controller`: Sometimes we need more than one `httpd` pod up and
    running to handle all the load for the application. ReplicaSet makes sure that
    a certain number of pods are up and available. ReplicaSet is controlled by the
    Deployment controller.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`default-scheduler`: Decides which node to run a specific pod on. In our case
    it is Minikube VM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deployment-controller`: Defines the desired state for a Kubernetes resource.
    In our case, it is a state of `httpd` pod. The Deployment controller also instructs
    ReplicaSet to make sure that certain pods are running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As already mentioned, the `kubectl run` command creates other Kubernetes resources
    including ReplicaSet and Deployment. We can verify that by running `kubectl get
    replicaset` and `kubectl get deployment` respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We mentioned that Deployment controller defines how many instances of `httpd`
    pods run. By default, this number is `1`. We can easily change this behavior and
    edit Deployment config with the `kubectl edit deploy httpd1` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have changed the replica value to `3`, save the changes and exit edit
    mode. The Deployment controller will detect the changes in the config and instruct ReplicaSet
    to bring up two more `httpd` pods. Let''s verify that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to delete all the pods, ReplicaSet will run a new set of pods automatically.
    Let''s see how it works one more time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Delete all Kubernetes resources before we move on to the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Creating kubernetes services using YAML and JSON files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can also create Kubernetes resources manually using YAML and JSON files.
    Let''s go ahead and create a simple pod running a httpd web server using the `kubectl
    create` command. We will have to create a YAML-formatted file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Reading YAML and JSON-formatted files is critical for Kubernetes and for later,
    in the OpenShift chapter. If you feel uncomfortable reading YAML or JSON files,
    read up on these subjects. Check the *Further reading* section for more information.
  prefs: []
  type: TYPE_NORMAL
- en: It may look a bit complicated and hard to understand, but as we move on in this
    book, you will see a lot of similarities between these YAML and JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: YAML configuration files are very structured and each resource is a set of keys
    and values. You can use the Kuberentes API documentation to find out what every
    parameter does: [https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a pod using the `httpd-pod.yaml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a pod named `httpd`; it does not create anything else.
    In larger deployments with heavy automation involved, this is the way to deploy
    Kubernetes resources, but this, of course, requires better Kubernetes skills.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, we can create other Kubernetes resources, including ReplicaSet, Deployment,
    and others.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the virtual environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you are done working with Kubernetes, you can easily stop the Minikube
    cluster by running the `minikube stop` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, you can delete the Minikube VM if you want by running the `minikube
    delete` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Verify that the Minikube cluster no longer exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Kubernetes limitations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Although it is a powerful orchestration engine, Kubernetes doesn''t have the
    features that are commonly required by PaaS solutions such as OpenShift and others:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes namespaces are provided mainly for the purpose of resource quota
    enforcement for different groups of users, but they do not provide any security
    constraints or authentication. For example, every user from every namespace can
    see all other namespaces and their resources.
  prefs: []
  type: TYPE_NORMAL
- en: '**Deployments**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes provides the means to create a deployment from an image with a single
    command, but doesn't create a service for external clients.
  prefs: []
  type: TYPE_NORMAL
- en: '**SCM integration**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes doesn't support integration with SCM via webhooks to facilitate deployment.
  prefs: []
  type: TYPE_NORMAL
- en: '**Builds**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes doesn't provide advanced build modes such as **Source-to-Image**
    (**S2I**) and Custom Builder.
  prefs: []
  type: TYPE_NORMAL
- en: '**Authentication**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Support for advanced authentication schemes such as LDAP, Google, GitHub, Keystone,
    or Kerberos is achieved only through a webhook or authenticating proxy.
  prefs: []
  type: TYPE_NORMAL
- en: '**CI/CD**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes has no integrated application life cycle support, which makes it
    difficult to integrate it into a corporate software delivery framework.
  prefs: []
  type: TYPE_NORMAL
- en: All these limitations will be addressed in the OpenShift sections in subsequent
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have briefly discussed Kubernetes concepts and the Kubernetes
    architecture, and the main difference between Kubernetes and Docker Swarm. We
    installed Kubernetes using Minikube, which is a very easy-to-use CLI tool with
    which to set up a Kubernetes lab environment. Then we used the `kubectl` command
    to perform various tasks such as running, editing, describing, and deleting Kubernetes
    pods and other Kubernetes resources. Finally, we finished by listing the main
    Kubernetes limitations, which we are going to address later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to work with CRI-O, which is a universal container
    runtime interface that allows Kubernetes to provide support for different container
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are the two Node types used by Kubernetes?:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Node
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Minikube
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Vagrant
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Master
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which container platforms are supported by Kuberntes? choose two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: OpenShift
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Rkt
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Minishift
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Kubernetes, a pod is a minimal unit of deployment which represents a group
    of containers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What are the main two Kubernetes services running on a Kubernetes Node? choose
    two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: etcd
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kubelet
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kube-proxy
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kube-node
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: kube-apiserver
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What are acceptable file formats for creating Kubernetes resources with the
    `kubectl create -f` command? choose two:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Jinja2
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: CSV
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: YANG
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: YAML
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Kubernetes has a built-in CI/CD toolset to improve corporate software delivery
    frameworks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since we are covering the very basics of Docker containers, you may be interested
    in diving into specific topics. Here''s a list of links that may be helpful to
    look through to learn more about Docker and containers in general:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes concepts**: [https://kubernetes.io/docs/concepts/](https://kubernetes.io/docs/concepts/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes CLI**: [https://kubernetes.io/docs/reference/generated/kubectl/kubectl/](https://kubernetes.io/docs/reference/generated/kubectl/kubectl/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes installation**:[ https://kubernetes.io/docs/setup/pick-right-solution/](https://kubernetes.io/docs/setup/pick-right-solution/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes cheat sheet**: [https://kubernetes.io/docs/reference/kubectl/cheatsheet/](https://kubernetes.io/docs/reference/kubectl/cheatsheet/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes API overview**: [https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/](https://v1-9.docs.kubernetes.io/docs/reference/generated/kubernetes-api/v1.9/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAML wiki page**:[ https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAML syntax check**: [http://www.yamllint.com/](http://www.yamllint.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON Wiki page**:[ https://en.wikipedia.org/wiki/JSON](https://en.wikipedia.org/wiki/JSON)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON syntax check**: [https://jsonlint.com/](https://jsonlint.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
