- en: Advanced OpenShift Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly described basic OpenShift objects such as
    pods, services, and routes. We also gave you an understanding of how to use namespaces
    for resource isolation and how to manage users in OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter deals with advanced OpenShift resources, such as **ImageStreams**
    and **ConfigMaps**, logically continuing on from the previous chapter on OpenShift
    core concepts. The OpenShift API provides dozens of varied resources to control
    different aspects of application deployment, security, and so on. For now, we
    will focus on some of the most important ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will have learned about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Tracking the version history of images using ImageStreams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separating configuration from application code using ConfigMaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Controlling resource consumption using LimitRanges and ResourceQuotas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Autoscaling your application depending on CPU and RAM utilization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will practice with OpenShift deployed on the VM managed
    by Vagrant. The last section on auto-scaling requires Hawkular metrics to be enabled,
    so you will have to install OpenShift with `openshift_metrics_install_metrics`
    Ansible variable. The metrics collector and dashboard are deployed in their own
    pods, so we will also need to provide the VM with more RAM. Use the following
    Vagrantfile to deploy the lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to be able to reach the cluster inside the VM from your host system,
    make sure file `/etc/hosts` on your laptop looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Run `vagrant up` and wait until it finishes all the work. It may take up to
    30 mins depending on your internet connectivity and compute resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s done, open SSH session into the VM and become root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the following inventory for deploying OpenShift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we have specified `openshift_metrics_install_metrics` variable to
    configure metrics for the section on autoscaling.
  prefs: []
  type: TYPE_NORMAL
- en: As of the time of writing, metrics image hasn't been tagged with the correct
    version yet, so we had to provide `openshift_metrics_image_version` variable as
    well to prevent metrics pods going into `ImagePullBackOff` state. More details
    at [https://github.com/openshift/origin/issues/19440](https://github.com/openshift/origin/issues/19440).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to install OpenShift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in as an unprivileged user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Remeber that since this time we didn't configure identity provider explicitly,
    OpenShift defaults to AllowAll, so we can use any password.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a dedicated project for our lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Log in back as `system:admin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have not discussed the concept behind the command above yet, but at this
    point it suffices to understand that it relaxes permissions imposed by OpenShift
    on pods. The concept is known as **Security Context Constraint** (**SCC**) and
    is discussed more thoroughly in Chapter 10, *Security in OpenShift*, section *Security
    context constraints*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, log back in as `alice`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Tracking the version history of images using ImageStreams
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Certain OpenShift resources, such as pods, deployments, DeploymentConfigs, ReplicationControllers,
    and ReplicaSets reference Docker images for deploying containers. Instead of referencing
    images directly, the common approach is to reference them through image streams,
    which serve as a layer of indirection between the internal/external repository
    and client resources, creating a virtual view of available images.
  prefs: []
  type: TYPE_NORMAL
- en: In the official documentation and some blogs, you may come across comparing
    image streams to repositories. While it's true in the sense that resources reference
    images in image streams just like in repositories, this analogy lacks clarity;
    image streams don't store anything by themselves and are only abstractions for
    image management. So, in this chapter, we will talk of them as virtual views to
    give you a more accurate idea of what they actually are.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using image streams has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Your application won't break unexpectedly if the upstream image's update introduced
    errors, because the image stream tags your pod points so that it will still be
    mapped to the working version of the image, effectively protecting you from outages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image-change triggers and periodic reimports of the image can be configured
    at the image stream's level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You more than likely won't have to create ImageStreams from scratch, but it's
    important to understand their structure in order to understand their functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Minishift and OpenShift, when installed by Ansible, include default image streams
    for some of the most popular images, such as PostgreSQL, HTTPD, and Python. They
    reside in the `openshift` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to see what the words indirection layer from the beginning of this
    section mean, let''s take a closer look at the `mongodb` image stream:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Image streams use a particular notation to reference images in repositories.
    Let''s take a reference from the preceding example and break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding image references have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`centos/mongodb-32-centos7`: Path to the image in the Docker repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sha256`: Indicates that the image identifier is generated using the SHA256
    hash algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d4dc006a25db1423caed1dcf0f253f352dbbe0914c20949a6302ccda55af72b1`: The image
    hash/ID itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'ImageStreams are not useful by themselves and only exist to support the life
    cycle of applications. They are usually created behind the scenes in the following
    scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating applications from S2I builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating applications directly from Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manually pushing images into the internal registry
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since S2I builds will be discussed further in this book, we will consider three
    other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Importing images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Image streams can be created by importing images from external registries in
    the internal registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see from the preceding output that the Nginx image was uploaded into
    the internal registry at
  prefs: []
  type: TYPE_NORMAL
- en: '`docker-registry.default.svc:5000/advanced/nginx`. As you will also notice,
    its name corresponds to the image reference structure we provided earlier.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s delete the image stream to provide a clean slate for the next exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating applications directly from Docker images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another way to create an image stream is to use the `new-app` command to create
    an application from a ready-to-use Docker image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Lighttpd is yet another web server, like Nginx or Apache. We used it in this
    example, because both Nginx and Apache image streams are supplied with OpenShift
    out-of-the-box.
  prefs: []
  type: TYPE_NORMAL
- en: This creates a number of resources, one of which is an image stream.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you `describe` the newly created deployment config, you will see that it
    actually references the image stream, not the image itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, DeploymentConfig references a Lighttpd server image
    in the image stream according to the following scheme:'
  prefs: []
  type: TYPE_NORMAL
- en: '`gists/lighttpd`: Image stream name'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sha256`: Indicates that the image identifier is generated using the SHA256
    hash algorithm'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`23c7c16d3c294e6595832dccc95c49ed56a5b34e03c8905b6db6fb8d66b8d950`: The image
    hash/ID itself'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is how deployment configs and replication controllers usually reference
    images in OpenShift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, let''s clean up the environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Manually pushing images into the internal registry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last method of creating image streams we will discuss is pushing images
    directly into the OpenShift internal registry.
  prefs: []
  type: TYPE_NORMAL
- en: 'Log in as `alice` unprivileged account, if you haven''t already done so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, run the following command to login to the internal registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding command, we used a bash feature called **command expansion**,
    which allowed us to supply the `login` command with the username, password/token,
    and registry `IP:port`, from left to right. You can run all these commands (`oc
    whoami` and `oc whoami -t`) separately to see what output they provide.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are authenticated in the internal registry, we can push images
    into it directly, as if it were a general Docker registry. Let''s see what we
    have in our OpenShift internal registry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s delete the Lighttpd image left over from the previous exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use the same Lighttpd image, as in the previous subsection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Tag it with the registry''s address and port included in the tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We used the name of the project to create the image stream as part of the path
    to the image in the registry because the token we used grants developer user permission
    to create image streams in the `myproject` project only. OpenShift expects us
    to find images in particular locations so that it can create image streams from
    images.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if the image with both tags referencing it is there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to push the image into the repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now verify that the `lighttpd` image stream was created in OpenShift:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the image stream was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just as before, we need to delete everything before going on to the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Separating configuration from application code using ConfigMaps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The ConfigMap resource is used to separate data from a pod running an application.
    These kinds of resource contain arbitrary data to be injected into a pod as configuration.
    Injection in this context means that the pod can use it in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Export its key/value pairs as environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Supply its values as command-line arguments to the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mount it as a volume inside the pod to the location where the application expects
    to find its configuration file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before you begin, make sure you are logged in as an unprivileged user for the
    most representative experience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at the process of exporting ConfigMap as an environment variable
    into a container. First, we have to create ConfigMap itself from a list of environment
    variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the following command to see what the actual resource looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to inject it into a pod. Create a simple `Pod` definition
    that references the newly created ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And create the pod using the preceding definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you learned in [Chapter 2](part0071.html#23MNU0-78aafb146b304cdeb9b3261a70edabde),
    *Kubernetes Overview*, OpenShift supports YAML and JSON notations for resource
    definitions; in this book, we rely primarily on the former. As a reminder of the
    YAML syntax, you can refer to the link at [http://www.yaml.org/start.html](http://www.yaml.org/start.html).
  prefs: []
  type: TYPE_NORMAL
- en: No matter if you use YAML or JSON, the OpenShift REST API supports very specific
    fields that vary between resource types and are documented in [https://docs.openshift.org/latest/rest_api/api/](https://docs.openshift.org/latest/rest_api/api/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the command is a simple Linux command, `env`, not a process or listening
    server of any kind, the pod exits right after it''s completed, but you can still
    see its logs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the two environment variables we defined in ConfigMap were successfully
    injected into the container. If we were to run an application inside our container,
    it could read them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same method can be used to supply these variables as command-line arguments
    to the container command. First, let''s delete the old pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, create a new pod definition so that you can use the variables as command-line
    arguments to echo the command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a container from the updated definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'As we mentioned previously, the container will exit right after the command
    returns, but its logs will contain the output of the command, constructed of two
    variables from our ConfigMap:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we will walk-through mounting ConfigMap as a configuration file into
    a pod. Again, let''s delete the pod from the previous exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we will supply the Nginx web server with our custom configuration
    file, which will make its default virtual host listen on port `8888` instead of
    `80`. Here''s the simple configuration to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s go ahead and create a ConfigMap from this configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'If we take a look at the raw resource definition of this ConfigMap, we will
    see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the entire contents of the configuration file was inserted as
    value into the config map definition with the key `nginx_custom_default.conf`,
    which can be used to reference the configuration in a pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to create a pod that will use this ConfigMap. Create yet another
    pod definition with the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: You can specify a path parameter in `configMap.items` to provide the name for
    the file that the configuration will be stored in. Had we not done that in the
    preceding example, the file name would have been the same as the key from the
    `configMap–nginx_custom_default.conf`. We must specify the label for our pod in
    order to be able to create a service for it later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the pod now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In order to see whether the server listens on the port specified in the ConfigMap,
    we could open a bash session inside the pod and see if the configuration file
    is in place, but let's use a better way that will let us practice with OpenShift
    resources more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to create a service for this pod and then expose it. First, create
    a service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: We had to explicitly specify the port in the command because we didn't provide
    it in the `containerPort` parameter in the pod's definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then expose the service itself through `route`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can use the `curl` command to request a default web page from the
    server''s default virtual host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: We could have created a separate record for the route above in `/etc/hosts`,
    pointing to `127.0.0.1`, but in order to keep the environment as clean as possible,
    it's a good practice to use `Host` HTTP header instead to select a particular
    application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding output indicates that Nginx indeed listens on port `8888/tcp`,
    as specified in the ConfigMap. This concludes our exercise with ConfigMaps, so
    let''s clean up our lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: ConfigMaps are not considered similar to other resources such as pods or services
    and must be deleted separately.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling resource consumption using ResourceQuotas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main ideas behind OpenShift projects in multi-tenant environments
    is the need to limit resource consumption at a more granular level than just a
    whole cluster, providing operations with the ability to scope such limitations
    to organizations and departments.
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenShift provides two mechanisms for setting limits on resource consumption
    in a cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ResourceQuota`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LimitRanges`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section is dedicated solely to ResourceQuotas. LimitRanges will be discussed
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'ResourceQuota can be used to control the number of API resources that can be
    created, or the amount of CPU, memory, and storage consumed by pods in the same
    project the quotas were defined in. Essentially, they determine the capacity of
    a project. ResourceQuotas allows you to control the following types of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ReplicationControllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ResourceQuotas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ConfigMaps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ImageStreams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PersistentVolumeClaims
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`requests.storage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: cpu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ephemeral-storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: limits.ephemeral-storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.cpu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.memory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If CPU/memory or `limits.cpu`/`limits.memory` are managed by quotas, then all
    pods in the same project must specify requests/limits for the respective computing
    resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of quotas, all pods belong to the following scopes, to which
    quotas can be applied and that scope a certain set of resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Scope** | **Description** | **Managed resources** |'
  prefs: []
  type: TYPE_TB
- en: '| `BestEffort` | Applies to all pods running with BestEffort quality of service,
    which means pods that have equal requests and limits for CPU, memory, or both.
    These pods can claim any resources they need, but they are most likely to be killed
    when nodes they run on are low on memory. |'
  prefs: []
  type: TYPE_TB
- en: Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `NotBestEffort` | Applies to all pods running without BestEffort quality
    of service. |'
  prefs: []
  type: TYPE_TB
- en: Pods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.cpu`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ephemeral-storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: limits.ephemeral-storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limits.memory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Terminating` | Applies to all pods deployed by jobs with `spec.activeDeadlineSeconds
    >= 0`, which means, for example, build pods that get deployed during S2I builds.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `NotTerminating` | Applies to all pods deployed by jobs with `spec.activeDeadlineSeconds`
    is nil, which means the usual pods with applications. |'
  prefs: []
  type: TYPE_TB
- en: 'Now, let''s see how to create quotas for a project. Like any other resource,
    they can be created through an API, but you can also use CLI, which is what we
    are going to do. Let''s switch back to `system:admin` user since managing quotas
    requires admin privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we will be able to create our first quota:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the quota was successfully created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Interestingly enough, the number of quotas itself per project can be controlled
    by ResourceQuota. Even if you set a limit for quotas to `0`, you will still be
    able to create your first quota, provided there is no other already existing quota
    that limits this number.
  prefs: []
  type: TYPE_NORMAL
- en: By creating this quota, we have set the limits of `500` CPU millicores (half-core),
    `256Mi` requested RAM, `1` pod, and `1` ResourceQuota on the current project.
    Let's see if the quota is in effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a simple pod definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to create a pod from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our definition didn''t pass the check by the quota because
    it explicitly limits the requested amount of CPU and RAM, but we didn''t specify
    them. Let''s modify `nginx-pod.yml` and add `resources` section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Upon creation, the pod will request 1 CPU core and 128 MiB of RAM, which is
    well within the limits set by the quota. Let''s try it again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The pod was created successfully, as expected. At this point, we can take a
    look at how much of our quota was consumed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what happens if we try to create one more pod. Prepare a new
    pod definition from the one used to create the first pod by replacing `nginx`
    with `httpd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'If we try to create the second pod, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Even though the amount of requested memory wouldn't violate the quota, pod creation
    was still denied because the quota limits the total number of pods to `1` for
    the current project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the quota to allow 2 pods and 2 CPU cores:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Try creating the second pod again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: It worked because the quota was set to allow `2` pods in the current project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how many resources are used from the total allowed by the quota
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we have exhausted the entire quota and no new pods can be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that this exercise is over, it''s time to prepare for the next one by cleaning
    up our lab:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: ConfigMaps and ResourceQuotas are considered separate kinds of resource and
    must be deleted as such.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling resource consumption using LimitRanges
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is another way of control resource allocation in OpenShift at the project
    level, but unlike ResourceQuotas, they are different in certain ways:'
  prefs: []
  type: TYPE_NORMAL
- en: They are applied to individual pods, containers, images, or image streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They don't control some resources such as secrets, ConfigMaps, ResourceQuotas,
    services, and ReplicationControllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be created from a raw definition only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Depending on the type of resource they are applied to, LimitRanges control
    various computing resources and objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Resource type** | **Computing resources/attributes controlled** |'
  prefs: []
  type: TYPE_TB
- en: '| Pod |'
  prefs: []
  type: TYPE_TB
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Container |'
  prefs: []
  type: TYPE_TB
- en: CPU
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RAM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| Image | Size of an image pushed into an internal registry |'
  prefs: []
  type: TYPE_TB
- en: '| ImageStream |'
  prefs: []
  type: TYPE_TB
- en: Number of unique image tags as per image stream's spec
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Number of unique image references as per the image stream's status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '| PersistentVolumeClaim | Amount of storage requested |'
  prefs: []
  type: TYPE_TB
- en: Pods and containers can explicitly state the amount of CPU and/or RAM they need
    and their limits, and LimitRanges takes care that they don't fall outside certain
    boundaries. Also, LimitRanges may provide defaults for a requested number of resources
    and their limits if they are not specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the presence of, and differences between, requests and limits
    for computing resources declared by pods, they run with different **Quality of
    Service** (**QoS**) tiers that serve the purpose of prioritizing running pods
    when it comes to resource contention. The following table summarizes the available
    tiers and when they are applied:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **QoS tier** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `BestEffort` | This tier is assigned to pods that don''t specify requests
    and limits explicitly. Such pods can consume as much CPU and RAM as they need,
    but if the node a pod runs on is short on either or both resources, these pods
    are the first to be terminated. |'
  prefs: []
  type: TYPE_TB
- en: '| `Burstable` | Pods that have limits higher than requests get assigned the
    Burstable QoS tier. They run with a lower priority than BestEffort pods, meaning
    that they are only terminated when there are no BestEffort pods to terminate.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Guaranteed` | This tier is applicable to pods that have equal requests and
    limits for computing resources. Each pod running with this QoS is entitled to
    the requested amount of resources, but no more. They have the highest priority,
    which means that they are only killed when there are no BestEffort or Burstable
    pods. |'
  prefs: []
  type: TYPE_TB
- en: 'Just as in the previous section, setting LimitRanges requires administrative
    privileges, so make sure you are logged in as `system:admin` user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s consider an example of creating a `LimitRange` from scratch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Create limits from the preceding definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s describe our newly created limits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There are also the `spec.limits[].default` and `spec.limits[].defaultRequest`
    parameters, which determine the amount of CPU/RAM a container is limited to use
    and the amount it requests by default, respectively. Since we didn't specify them
    explicitly, they default to the same maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a pod that requests a specific amount of computing
    resources and sets limits on their usage for itself. Prepare the following pod
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a pod from the definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: As you might expect after looking at the pod's definition, the operation was
    rejected because the pod's request and limit ranges violate the policy defined
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Minimum boundaries are also enforced.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s edit the pod''s definition to comply with the defined LimitRange:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Try to create it again and observe that it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s clean up the lab to prepare for the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: LimitRanges are considered a separate kind of resource as well, like templates,
    ConfigMaps, and ResourceQuotas, so they must be deleted by issuing a separate
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Creating complex stacks of applications with templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another useful kind of OpenShift resource is a template. Instead of creating
    resources one-by-one – for example, a pod, service, and route – templates allow
    you to create multiple objects at once with a single CLI command. More than that
    —they may include parameters that can be optional, or default to values either
    static or generated in accordance with specific rules. In a sense, they are similar
    to Docker Compose or OpenStack Heat—all of these provide the facility to create
    entire application stacks from the ground up. With templates, the cluster administrator
    can provide developers with the ability to deploy multi-tier applications with
    all dependent services.
  prefs: []
  type: TYPE_NORMAL
- en: By default, OpenShift comes installed with quite a few default templates, called
    **Instant App** and **Quick Start** templates. They can be used to deploy runtime
    environments based on various languages and frameworks, such as Ruby on Rails
    (Ruby), Django (Python), and CakePHP (PHP). They also include templates for SQL
    and NoSQL database engines with persistent storage, which includes `PersistentVolumeClaims`
    as one of the objects to provide persistence of data.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this exercise, you will not require admin privileges, so you can login
    as a regular user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Default templates are created in the `openshift` project during installation.
    You can see them by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: We used the `cut` command to exclude descriptions and other information for
    the sake of brevity, but you can run this command without `cut` to see the full
    output.
  prefs: []
  type: TYPE_NORMAL
- en: Both MiniShift and OpenShift, when installed by the Ansible installer, have
    default templates installed out-of-the-box but, in the case of containerized quick
    installation, you may have to create them manually from YAML definitions located
    in the `roles/openshift_examples/files/examples/` directory of the Ansible installer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get a list of parameters that are supported by a particular template, use
    the `process` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: We left out descriptions of the parameters to make the output more readable.
  prefs: []
  type: TYPE_NORMAL
- en: As you may have noticed, some parameters have dynamic default values, generated
    by expressions loosely based on **Perl Compatible Regular Expressions** (**PCREs**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `process` command generates default values from all dynamic expressions,
    making the template definition ready to be used for creating resources, which
    is done either by piping its output to the `create` command or by running the `new-app`
    command—we will get to that in a few moments. For now, let''s use that command
    to see a `List` of objects to be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The process command allows for an alternate syntax, `<NAMESPACE>//<TEMPLATE>`.
    We used it here for demonstration purposes, but you are free to use the more familiar
    `-n <NAMESPACE>` notation.
  prefs: []
  type: TYPE_NORMAL
- en: The list is quite long, so we only provided an excerpt showing the `Secret`
    resource that contains all generated sensitive values that are to be used for
    template instantiation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make things clearer, let''s take a look at the expressions for generating
    those values in the raw template definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: You may have noticed, for example, that `MYSQL_DATABASE` is `sampledb`, while
    `MYSQL_USER` starts with the string `user` with three alphanumeric characters,
    just as we saw in the previous listing.
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about how to construct regular expressions for dynamic parameters,
    refer to [http://perldoc.perl.org/perlre.html](http://perldoc.perl.org/perlre.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will create our own simple template. Create a new template definition
    with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Though in our case the message parameter is used in quite a rudimentary way,
    in more complex templates, its purpose is to tell the user how to use the template—what
    usernames, passwords, URLs, and so on were generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'This template can be used to create three resources:'
  prefs: []
  type: TYPE_NORMAL
- en: A pod running a web server, which you can choose by supplying the `WEB_SERVER`
    parameter. By default, it's `nginx`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A service proxying incoming traffic to the pod.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A route for external access.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can process that definition right away and pass the resulting list of resources
    to the `create` command, but a common strategy is to create a template from its
    definition first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s try to process it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: You can see the only parameter with the default value and description that you
    defined earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to create a stack of resources from our template. This can
    be done by either piping the output of the `process` command to the `create` command,
    which we mentioned previously, or by using the `new-app` command. Let''s start
    with the former approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `create` command just takes the list of resources and submits
    requests for their creation one-by-one to the API, so the output is similar to
    what you would see if you created three separate resource definitions and created
    resources from them manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'But another way to instantiate a template gives you more information about
    what is going on. Let''s delete the created resources first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'We don''t have to delete the template as it''s not going to change. Now, we
    can use the `new-app` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we created the pod, fronted it with the service, and exposed
    it through the route in just a single command. Notice that you don't need to run
    the `oc get route`  command to find out what URL your application is accessible
    through—it all shows in the output.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see if our web server is reachable through `curl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: We used the `-I` parameter of the `curl` command to see only response headers,
    which is enough to check the responsiveness of the server and ensure that it doesn't
    dump raw HTML into the console. Also, just as before, we used -H option to request
    a specific application from OpenShift's router.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily delete all of the resources and instantiate the template again,
    but this time with another web server image, such as Apache:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: That's it—one parameter and you have a different web server deployed for you
    in a matter of seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also perform a reverse operation—creating a template from existing
    resources. To do that, use the `export` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s delete our resources to prevent any conflicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'And recreate them from the exported template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: You might have noticed that the web server was exposed through the same URL
    as before. This is because the exported template was created from already instantiated
    resources with all parameters resolved to values, so OpenShift has no way of knowing
    which fields were parameterized. You can also infer this from the output of the
    `process` command, which will show you that all the fields are already initialized.
    So, strictly speaking, this isn't a fully reverse operation, but it can be used
    for backups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we are finished, let''s do a clean-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Autoscaling your application depending on CPU and RAM utilization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can scale pods in your application using the `oc scale` command, but it
    has two disadvantages:'
  prefs: []
  type: TYPE_NORMAL
- en: It has to be run manually every time you need to scale a pod up or down
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You have to take into account CPU and RAM utilization yourself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This approach doesn't allow businesses to adapt quickly to constantly changing
    customers demands. There is a better way—`HorizontalPodAutoscaler`.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, autoscaling can only track CPU and RAM usage. Traffic-based
    autoscaling, for instance, isn't supported.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s login as `system:admin` and see if Hawkular, Cassandra, and Heapster
    pods are up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: By the time you get to this section, all metrics pods will be ready, but usually
    it takes 8-10 minutes for them to get started after installation is done.
  prefs: []
  type: TYPE_NORMAL
- en: CPU-based autoscaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CPU-based autoscaling also requires limit ranges to be set on CPU requests for
    the pods being scaled, so we can use the LimitRange definition from one of the
    previous sections.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Depending on your host machine's CPU, you might have to tweak the values in
    the file above in order for autoscaling to work, that is why in the listing above
    they are different than in the beginning of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The autoscaling feature can be applied to deployment configs, so the easiest
    way to create one is to use the already familiar `new-app` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'For demonstration purposes, we used the Apache web server image to create an
    image stream, which, in turn, is used to create the application. Now that the
    `deploymentconfig` is ready to manage pods, we can create a `HorizontalPodAutoscaler`
    to manage the `deploymentconfig` itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: We specified `2` as the minimum number of pods that must be maintained at any
    time so that you can observe the effect of autoscaling quickly without having
    to generate CPU load on pods to trigger it. We will do that in a few moments as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make sure it was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: If you run this command right after creation, you will most likely see unknown
    instead of `0%` in the preceding output. That is expected because `HorizontalPodAutoscaler`
    usually needs a few minutes to collect enough metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a few minutes, you may list running pods and notice that there are two of
    them now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have to simulate a large number of user requests to our pods to increase
    the CPU load so that autoscaling takes effect. But to do that, we need to create
    a route first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have everything we need, so let''s start simulating CPU load
    with the `ab` Apache benchmarking utility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: When `httpd` DeploymentConfig is scaled up, you can just press `Ctrl+C` to stop
    generating the traffic, as is indicated by `^C` in the output above.
  prefs: []
  type: TYPE_NORMAL
- en: 'Login in a separate terminal as `system:admin` and at some point you should
    be able to see that you have 4 pods running :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you press *Ctrl* + *C* and benchmarking stops, then after a while, the
    number of pods will go back to normal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested, you can see the collected metrics and autoscaling taking
    place in the web console. Open the web console in a browser at [https://openshift.example.com:8443/](https://openshift.example.com:8443/),
    confirm the security exception for the self-signed certificate, and login with
    the username `alice` and any password.
  prefs: []
  type: TYPE_NORMAL
- en: 'As our OpenShift cluster uses self-signed TLS certificates for encrypting HTTP
    traffic, Hawkular metrics will not be accessible from the Overview tab of the
    web console at first—you will see an error above the list of pods instead. To
    fix this, click on the provided link to open the Hawkular URL in a separate tab/window
    in your browser and confirm the security exception for the certificate as well.
    After that, refresh the Overview tab and you will see the calculated metrics for
    each pod marked with different colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can also use the Monitoring tab to get a more detailed view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can clearly see the spikes in CPU load and network traffic that correspond
    to the `ab` run.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to delete CPU-based autoscaler before the next exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: Memory-based autoscaling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Unlike autoscaling based on CPU utilization, memory-based autoscaling can only
    be enabled by creating a `HorizontalPodAutoscaler` from a raw YAML/JSON definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s enable autoscaling now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: 'Give it a minute or two to pick up the metrics from Heapster and you will be
    able to see how the current memory utilization is different from the target:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: If you run this command right after creation, you will most likely see unknown
    instead of `7%` in the preceding output. This is expected because `HorizontalPodAutoscaler`
    usually needs a few minutes to collect sufficient metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and generate traffic for the application, just like in the
    previous section, but establish `1000` concurrent connections this time, instead
    of `100`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Laeve  benchmark open for 5-10 minutes, and meanwhile open your browser at [https://hawkular-metrics.openshift.example.com/hawkular/metrics](https://hawkular-metrics.openshift.example.com/hawkular/metrics)
    to make sure that hawkular metrics are running, and then at [https://openshift.example.com:8443/console/project/advanced/overview](https://openshift.example.com:8443/console/project/advanced/overview)
  prefs: []
  type: TYPE_NORMAL
- en: 'You can observe autoscaling taking place from the web console. First it scales
    our web server to 3 replicas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'And shortly after, to 4:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After `ab` is finished generating traffic, the number of pods slowly goes down:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is possible to observe short bursts in the number of replicas if you put
    too much load on the service. This is normal and you may see from events that
    the `deploymentconfig` scales, for example, from 3 to 6 without transient states,
    then quickly detects the anomaly and corrects it by scaling back to the maximum
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the specifics of memory utilization by pods, it's common that the `deploymentconfig`/`replicationcontroller` doesn't
    fully scale back to the minimum number of replicas.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exercise is over, so it''s time to clean-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: It is not advisable to activate CPU- and RAM-based autoscalers at the same time
    as they may conflict with each other. Determine what resources your application
    relies on most of the time and use the appropriate autoscaling.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced you to the concept of image streams and methods
    of creating them, how config maps can be used to manage the configuration of your
    applications, mechanisms for limiting resource consumption per project using resource
    quotas and limit ranges, how to use templates to create multiple dependent resources,
    and how to configure autoscaling for your applications based on CPU or memory
    utilization.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work on security in OpenShift. We will be giving
    you an understanding of OpenShift security implementation, which is mandatory
    for any production environment.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What are ImageStreams used for? choose 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To protect applications from breaking unexpectedly when the image that an ImageStream
    points to changes.
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: To implement rolling updates of applications.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To store build images.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: To implement automatic build and deployments on image change.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What commands can be used to create a ConfigMap? choose 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: oc create configmap my-configmap --from-file=nginx.conf
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: oc create cm --from-env-file=environment.env
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: oc create -f configmap_definition.yaml
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: oc edit configmap/my-configmap
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Which of the following valid commands to create a quota? choose 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: oc create resourcequota example-quota --hard=cpus=2,memory=512Mi
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: oc create quota example-quota --hard=cpu=4,ram=1Gi
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: oc create resourcequota my-quota --hard=cpu=4,services=5
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: oc create quota another-quota --hard=pods=8,secrets=4
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'What resources CAN''T be controlled by a LimitRange? choose 2:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pod
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: ConfigMap
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ImageStream
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Service
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the correct syntax  for referencing the VARIABLE parameter in a template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '#{VARIABLE}'
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: <VARIABLE>
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: ${VARIABLE}
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '%VARIABLE%'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What must be specified by pods for CPU-based autoscaling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Labels
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: Limits
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Requests
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Selectors
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What API version must be used to configure memory-based autoscaling?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: v1
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
- en: v2
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: v2alpha1
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: v1beta1
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered advanced concepts of the OpenShift container platform.
    Here''s a list of links that may be helpful to look through so that you can learn
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenShift documentation on ImageStreams**: [https://docs.openshift.org/latest/architecture/core_concepts/builds_and_image_streams.html](https://docs.openshift.org/latest/architecture/core_concepts/builds_and_image_streams.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenShift documentation on ConfigMaps**: [https://docs.openshift.org/latest/dev_guide/configmaps.html](https://docs.openshift.org/latest/dev_guide/configmaps.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenShift documentation on ResourceQuotas**: [https://docs.openshift.org/latest/admin_guide/quota.html](https://docs.openshift.org/latest/admin_guide/quota.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenShift documentation on LimitRanges**: [https://docs.openshift.org/latest/admin_guide/limits.html](https://docs.openshift.org/latest/admin_guide/limits.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenShift documentation on templates**: [https://docs.openshift.org/latest/dev_guide/templates.html#dev-guide-templates](https://docs.openshift.org/latest/dev_guide/templates.html#dev-guide-templates)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenShift documentation on HorizontalPodAutoscaler**: [https://docs.openshift.org/latest/dev_guide/pod_autoscaling.html](https://docs.openshift.org/latest/dev_guide/pod_autoscaling.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wikipedia article on YAML notation**: [https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAML syntax validator**: [http://www.yamllint.com/](http://www.yamllint.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON notation**: [http://www.json.org](https://www.json.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JSON syntax validator**: [https://jsonlint.com/](https://jsonlint.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**YAML notation specification**: [http://www.yaml.org/start.html](http://www.yaml.org/start.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OpenShift REST API reference**: [https://docs.openshift.org/latest/rest_api/api/](https://docs.openshift.org/latest/rest_api/api/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PCRE reference**: [http://perldoc.perl.org/perlre.html](http://perldoc.perl.org/perlre.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
