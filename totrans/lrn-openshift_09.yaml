- en: Advanced OpenShift Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级 OpenShift 概念
- en: In the previous chapter, we briefly described basic OpenShift objects such as
    pods, services, and routes. We also gave you an understanding of how to use namespaces
    for resource isolation and how to manage users in OpenShift.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要描述了基本的 OpenShift 对象，如 pod、服务和路由。我们还让您了解了如何使用命名空间进行资源隔离，以及如何管理 OpenShift
    中的用户。
- en: This chapter deals with advanced OpenShift resources, such as **ImageStreams**
    and **ConfigMaps**, logically continuing on from the previous chapter on OpenShift
    core concepts. The OpenShift API provides dozens of varied resources to control
    different aspects of application deployment, security, and so on. For now, we
    will focus on some of the most important ones.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讲解了高级 OpenShift 资源，如 **ImageStreams** 和 **ConfigMaps**，逻辑上延续了上一章关于 OpenShift
    核心概念的内容。OpenShift API 提供了数十种不同的资源来控制应用部署、安全性等各个方面。现在，我们将重点介绍一些最重要的资源。
- en: 'After completing this chapter, you will have learned about the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，您将学到以下内容：
- en: Tracking the version history of images using ImageStreams
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ImageStreams 跟踪镜像版本历史
- en: Separating configuration from application code using ConfigMaps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 ConfigMaps 将配置与应用程序代码分离
- en: Controlling resource consumption using LimitRanges and ResourceQuotas
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 LimitRanges 和 ResourceQuotas 控制资源消耗
- en: Autoscaling your application depending on CPU and RAM utilization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 CPU 和 RAM 使用情况自动扩展应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we will practice with OpenShift deployed on the VM managed
    by Vagrant. The last section on auto-scaling requires Hawkular metrics to be enabled,
    so you will have to install OpenShift with `openshift_metrics_install_metrics`
    Ansible variable. The metrics collector and dashboard are deployed in their own
    pods, so we will also need to provide the VM with more RAM. Use the following
    Vagrantfile to deploy the lab:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将在 Vagrant 管理的虚拟机上实践部署的 OpenShift。最后一部分关于自动扩展需要启用 Hawkular 度量，因此您需要通过
    `openshift_metrics_install_metrics` Ansible 变量来安装 OpenShift。度量收集器和仪表板被部署在它们自己的
    pod 中，因此我们还需要为虚拟机提供更多的 RAM。使用以下 Vagrantfile 来部署实验：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In order to be able to reach the cluster inside the VM from your host system,
    make sure file `/etc/hosts` on your laptop looks like this:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从您的主机系统访问 VM 内的集群，请确保您笔记本电脑上的文件 `/etc/hosts` 看起来像这样：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Run `vagrant up` and wait until it finishes all the work. It may take up to
    30 mins depending on your internet connectivity and compute resources:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`vagrant up`并等待它完成所有工作。这可能需要最多 30 分钟，具体取决于您的互联网连接和计算资源：
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once it''s done, open SSH session into the VM and become root:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，打开 SSH 会话连接到 VM 并切换为 root 用户：
- en: '[PRE3]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can use the following inventory for deploying OpenShift:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用以下清单来部署 OpenShift：
- en: '[PRE4]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that we have specified `openshift_metrics_install_metrics` variable to
    configure metrics for the section on autoscaling.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们已经指定了 `openshift_metrics_install_metrics` 变量来配置与自动扩展相关的度量。
- en: As of the time of writing, metrics image hasn't been tagged with the correct
    version yet, so we had to provide `openshift_metrics_image_version` variable as
    well to prevent metrics pods going into `ImagePullBackOff` state. More details
    at [https://github.com/openshift/origin/issues/19440](https://github.com/openshift/origin/issues/19440).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 截至写作时，度量镜像尚未标记正确版本，因此我们不得不提供 `openshift_metrics_image_version` 变量，以防止度量 pod
    进入 `ImagePullBackOff` 状态。更多细节请参见 [https://github.com/openshift/origin/issues/19440](https://github.com/openshift/origin/issues/19440)。
- en: 'Now, it''s time to install OpenShift:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，到了安装 OpenShift 的时候：
- en: '[PRE5]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Log in as an unprivileged user:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 以普通用户身份登录：
- en: '[PRE6]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remeber that since this time we didn't configure identity provider explicitly,
    OpenShift defaults to AllowAll, so we can use any password.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，由于这次我们没有显式配置身份提供者，OpenShift 默认为 AllowAll，因此我们可以使用任何密码。
- en: 'Next, create a dedicated project for our lab:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个专门用于我们实验的项目：
- en: '[PRE7]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Log in back as `system:admin`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `system:admin` 用户身份重新登录：
- en: '[PRE8]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, we will need to run the following command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要运行以下命令：
- en: '[PRE9]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have not discussed the concept behind the command above yet, but at this
    point it suffices to understand that it relaxes permissions imposed by OpenShift
    on pods. The concept is known as **Security Context Constraint** (**SCC**) and
    is discussed more thoroughly in Chapter 10, *Security in OpenShift*, section *Security
    context constraints*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有讨论上面命令背后的概念，但在此时，只需理解它放宽了 OpenShift 对 pod 强加的权限即可。这个概念被称为 **安全上下文约束**（**SCC**），在第
    10 章 *OpenShift 安全性* 中的 *安全上下文约束* 部分会更详细地讨论。
- en: 'Finally, log back in as `alice`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以 `alice` 用户重新登录：
- en: '[PRE10]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tracking the version history of images using ImageStreams
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用镜像流跟踪镜像的版本历史
- en: Certain OpenShift resources, such as pods, deployments, DeploymentConfigs, ReplicationControllers,
    and ReplicaSets reference Docker images for deploying containers. Instead of referencing
    images directly, the common approach is to reference them through image streams,
    which serve as a layer of indirection between the internal/external repository
    and client resources, creating a virtual view of available images.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 某些 OpenShift 资源，如 pods、deployments、DeploymentConfigs、ReplicationControllers
    和 ReplicaSets，引用 Docker 镜像来部署容器。通常的做法是通过镜像流引用这些镜像，而不是直接引用它们，镜像流充当了内部/外部仓库与客户端资源之间的间接层，创建了一个虚拟的镜像视图。
- en: In the official documentation and some blogs, you may come across comparing
    image streams to repositories. While it's true in the sense that resources reference
    images in image streams just like in repositories, this analogy lacks clarity;
    image streams don't store anything by themselves and are only abstractions for
    image management. So, in this chapter, we will talk of them as virtual views to
    give you a more accurate idea of what they actually are.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在官方文档和一些博客中，你可能会看到将镜像流与仓库进行比较。虽然从某种意义上说，资源通过镜像流引用镜像的方式类似于仓库，但这个类比不够清晰；镜像流本身不存储任何东西，它们仅仅是镜像管理的抽象。因此，在本章中，我们将它们视为虚拟视图，以便更准确地理解它们的实际作用。
- en: 'Using image streams has the following advantages:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 使用镜像流有以下优点：
- en: Your application won't break unexpectedly if the upstream image's update introduced
    errors, because the image stream tags your pod points so that it will still be
    mapped to the working version of the image, effectively protecting you from outages
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果上游镜像的更新引入了错误，你的应用程序不会意外崩溃，因为镜像流会标记你的 pod，使其仍然映射到镜像的工作版本，有效保护你免受故障影响
- en: Image-change triggers and periodic reimports of the image can be configured
    at the image stream's level
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以在镜像流级别配置镜像更改触发器和周期性重新导入镜像
- en: You more than likely won't have to create ImageStreams from scratch, but it's
    important to understand their structure in order to understand their functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你很可能不需要从头创建镜像流，但理解它们的结构对于理解它们的功能非常重要。
- en: 'Minishift and OpenShift, when installed by Ansible, include default image streams
    for some of the most popular images, such as PostgreSQL, HTTPD, and Python. They
    reside in the `openshift` project:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Ansible 安装的 Minishift 和 OpenShift 包含一些最流行镜像的默认镜像流，如 PostgreSQL、HTTPD 和 Python。它们位于
    `openshift` 项目中：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In order to see what the words indirection layer from the beginning of this
    section mean, let''s take a closer look at the `mongodb` image stream:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解本节开头提到的“间接层”是什么意思，我们来仔细看看 `mongodb` 镜像流：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Image streams use a particular notation to reference images in repositories.
    Let''s take a reference from the preceding example and break it down:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像流使用特定的符号来引用仓库中的镜像。我们以之前的例子为参考，进行分析：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding image references have the following structure:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 上述镜像引用具有以下结构：
- en: '`centos/mongodb-32-centos7`: Path to the image in the Docker repository'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centos/mongodb-32-centos7`：Docker 仓库中镜像的路径'
- en: '`sha256`: Indicates that the image identifier is generated using the SHA256
    hash algorithm'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sha256`：表示镜像标识符是通过 SHA256 哈希算法生成的'
- en: '`d4dc006a25db1423caed1dcf0f253f352dbbe0914c20949a6302ccda55af72b1`: The image
    hash/ID itself'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`d4dc006a25db1423caed1dcf0f253f352dbbe0914c20949a6302ccda55af72b1`：镜像的哈希/ID
    本身'
- en: 'ImageStreams are not useful by themselves and only exist to support the life
    cycle of applications. They are usually created behind the scenes in the following
    scenarios:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像流本身没有实际用途，只有在支持应用程序生命周期时才存在。它们通常在以下场景中被后台创建：
- en: Creating applications from S2I builds
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 S2I 构建创建应用程序
- en: Importing images
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入镜像
- en: Creating applications directly from Docker images
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接从 Docker 镜像创建应用程序
- en: Manually pushing images into the internal registry
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动将镜像推送到内部注册表
- en: Since S2I builds will be discussed further in this book, we will consider three
    other methods.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书中会进一步讨论 S2I 构建，我们将考虑另外三种方法。
- en: Importing images
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入镜像
- en: 'Image streams can be created by importing images from external registries in
    the internal registry:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过从外部注册表导入镜像到内部注册表来创建镜像流：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You can see from the preceding output that the Nginx image was uploaded into
    the internal registry at
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从前面的输出中看到，Nginx 镜像已经上传到内部注册表
- en: '`docker-registry.default.svc:5000/advanced/nginx`. As you will also notice,
    its name corresponds to the image reference structure we provided earlier.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker-registry.default.svc:5000/advanced/nginx`。如你所见，它的名称与我们之前提供的镜像引用结构相对应。'
- en: 'Let''s delete the image stream to provide a clean slate for the next exercise:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除镜像流，为下一个练习提供一个干净的起点：
- en: '[PRE15]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Creating applications directly from Docker images
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接从 Docker 镜像创建应用程序
- en: 'Another way to create an image stream is to use the `new-app` command to create
    an application from a ready-to-use Docker image:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 创建镜像流的另一种方法是使用 `new-app` 命令从现成的 Docker 镜像创建应用程序：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Lighttpd is yet another web server, like Nginx or Apache. We used it in this
    example, because both Nginx and Apache image streams are supplied with OpenShift
    out-of-the-box.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Lighttpd 是另一个 Web 服务器，类似于 Nginx 或 Apache。我们在这个示例中使用它，因为 Nginx 和 Apache 镜像流都已开箱即用地提供给
    OpenShift。
- en: This creates a number of resources, one of which is an image stream.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建多个资源，其中之一就是镜像流。
- en: 'If you `describe` the newly created deployment config, you will see that it
    actually references the image stream, not the image itself:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你 `describe` 新创建的部署配置，你会看到它实际上引用的是镜像流，而不是镜像本身：
- en: '[PRE17]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding example, DeploymentConfig references a Lighttpd server image
    in the image stream according to the following scheme:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，DeploymentConfig 根据以下方案引用了 Lighttpd 服务器镜像的镜像流：
- en: '`gists/lighttpd`: Image stream name'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gists/lighttpd`：镜像流名称'
- en: '`sha256`: Indicates that the image identifier is generated using the SHA256
    hash algorithm'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sha256`：表示镜像标识符是使用 SHA256 哈希算法生成的'
- en: '`23c7c16d3c294e6595832dccc95c49ed56a5b34e03c8905b6db6fb8d66b8d950`: The image
    hash/ID itself'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`23c7c16d3c294e6595832dccc95c49ed56a5b34e03c8905b6db6fb8d66b8d950`：镜像哈希值/ID'
- en: This is how deployment configs and replication controllers usually reference
    images in OpenShift.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是部署配置和复制控制器通常在 OpenShift 中引用镜像的方式。
- en: 'Again, let''s clean up the environment:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，让我们清理一下环境：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Manually pushing images into the internal registry
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动将镜像推送到内部注册表
- en: The last method of creating image streams we will discuss is pushing images
    directly into the OpenShift internal registry.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将讨论的最后一种创建镜像流的方法是直接将镜像推送到 OpenShift 内部注册表。
- en: 'Log in as `alice` unprivileged account, if you haven''t already done so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还没有登录，请以 `alice` 的非特权账户登录：
- en: '[PRE19]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, run the following command to login to the internal registry:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，运行以下命令以登录到内部注册表：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding command, we used a bash feature called **command expansion**,
    which allowed us to supply the `login` command with the username, password/token,
    and registry `IP:port`, from left to right. You can run all these commands (`oc
    whoami` and `oc whoami -t`) separately to see what output they provide.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令中，我们使用了一个称为 **命令扩展** 的 Bash 特性，它允许我们从左到右提供 `login` 命令所需的用户名、密码/令牌和注册表
    `IP:port`。你可以单独运行所有这些命令（`oc whoami` 和 `oc whoami -t`）来查看它们的输出。
- en: 'Now that we are authenticated in the internal registry, we can push images
    into it directly, as if it were a general Docker registry. Let''s see what we
    have in our OpenShift internal registry:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在内部注册表中完成身份验证，可以像操作一般的 Docker 注册表一样直接推送镜像。让我们看看 OpenShift 内部注册表中有什么：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let''s delete the Lighttpd image left over from the previous exercise:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除上一个练习中遗留下的 Lighttpd 镜像：
- en: '[PRE22]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now use the same Lighttpd image, as in the previous subsection:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在使用与上一小节相同的 Lighttpd 镜像：
- en: '[PRE23]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Tag it with the registry''s address and port included in the tag:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 用包含注册表地址和端口的标签标记它：
- en: '[PRE24]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We used the name of the project to create the image stream as part of the path
    to the image in the registry because the token we used grants developer user permission
    to create image streams in the `myproject` project only. OpenShift expects us
    to find images in particular locations so that it can create image streams from
    images.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用项目的名称来创建镜像流，作为仓库中镜像路径的一部分，因为我们使用的令牌只授予开发者用户在 `myproject` 项目中创建镜像流的权限。OpenShift
    期望我们在特定位置找到镜像，这样它就可以从镜像中创建镜像流。
- en: 'Let''s see if the image with both tags referencing it is there:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下是否存在两个标签引用的镜像：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we need to push the image into the repository:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将镜像推送到仓库中：
- en: '[PRE26]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now verify that the `lighttpd` image stream was created in OpenShift:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在验证一下 `lighttpd` 镜像流是否已在 OpenShift 中创建：
- en: '[PRE27]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As expected, the image stream was created.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，镜像流已创建。
- en: 'Just as before, we need to delete everything before going on to the next section:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 和之前一样，我们需要删除所有内容，然后才能继续下一部分：
- en: '[PRE28]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Separating configuration from application code using ConfigMaps
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ConfigMap 将配置与应用程序代码分离
- en: 'The ConfigMap resource is used to separate data from a pod running an application.
    These kinds of resource contain arbitrary data to be injected into a pod as configuration.
    Injection in this context means that the pod can use it in the following ways:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap 资源用于将数据与运行应用程序的 pod 分离。这类资源包含任意数据，可以作为配置注入到 pod 中。在这个上下文中，“注入”意味着
    pod 可以通过以下方式使用它：
- en: Export its key/value pairs as environment variables
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其键/值对导出为环境变量
- en: Supply its values as command-line arguments to the application
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其值作为命令行参数传递给应用程序
- en: Mount it as a volume inside the pod to the location where the application expects
    to find its configuration file
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其作为卷挂载到 pod 内部，挂载到应用程序期望找到配置文件的位置
- en: 'Before you begin, make sure you are logged in as an unprivileged user for the
    most representative experience:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，确保你以非特权用户登录，以获得最具代表性的体验：
- en: '[PRE29]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s look at the process of exporting ConfigMap as an environment variable
    into a container. First, we have to create ConfigMap itself from a list of environment
    variables:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看将 ConfigMap 导出为容器中的环境变量的过程。首先，我们需要从一系列环境变量创建 ConfigMap 本身：
- en: '[PRE30]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Use the following command to see what the actual resource looks like:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令查看实际资源的样子：
- en: '[PRE31]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now we are ready to inject it into a pod. Create a simple `Pod` definition
    that references the newly created ConfigMap:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好将其注入到 pod 中。创建一个简单的 `Pod` 定义，引用新创建的 ConfigMap：
- en: '[PRE32]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And create the pod using the preceding definition:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用前面的定义创建 pod：
- en: '[PRE33]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As you learned in [Chapter 2](part0071.html#23MNU0-78aafb146b304cdeb9b3261a70edabde),
    *Kubernetes Overview*, OpenShift supports YAML and JSON notations for resource
    definitions; in this book, we rely primarily on the former. As a reminder of the
    YAML syntax, you can refer to the link at [http://www.yaml.org/start.html](http://www.yaml.org/start.html).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在[第二章](part0071.html#23MNU0-78aafb146b304cdeb9b3261a70edabde)《Kubernetes概览》中学到的，OpenShift
    支持 YAML 和 JSON 两种格式用于资源定义；在本书中，我们主要依赖前者。为了提醒你 YAML 语法，可以参考这个链接：[http://www.yaml.org/start.html](http://www.yaml.org/start.html)。
- en: No matter if you use YAML or JSON, the OpenShift REST API supports very specific
    fields that vary between resource types and are documented in [https://docs.openshift.org/latest/rest_api/api/](https://docs.openshift.org/latest/rest_api/api/).
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用 YAML 还是 JSON，OpenShift REST API 都支持非常具体的字段，这些字段在不同的资源类型之间有所不同，且已在 [https://docs.openshift.org/latest/rest_api/api/](https://docs.openshift.org/latest/rest_api/api/)
    中进行了文档化。
- en: 'Since the command is a simple Linux command, `env`, not a process or listening
    server of any kind, the pod exits right after it''s completed, but you can still
    see its logs:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于该命令是一个简单的 Linux 命令 `env`，而不是某种进程或监听服务器，pod 在命令完成后立即退出，但你仍然可以看到其日志：
- en: '[PRE34]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, the two environment variables we defined in ConfigMap were successfully
    injected into the container. If we were to run an application inside our container,
    it could read them.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们在 ConfigMap 中定义的两个环境变量已经成功注入到容器中。如果我们在容器中运行应用程序，它将能够读取这些变量。
- en: 'The same method can be used to supply these variables as command-line arguments
    to the container command. First, let''s delete the old pod:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的方法可以用来将这些变量作为命令行参数传递给容器命令。首先，让我们删除旧的 pod：
- en: '[PRE35]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, create a new pod definition so that you can use the variables as command-line
    arguments to echo the command:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个新的 pod 定义，以便你可以使用这些变量作为命令行参数来回显命令：
- en: '[PRE36]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, create a container from the updated definition:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，使用更新后的定义创建一个容器：
- en: '[PRE37]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'As we mentioned previously, the container will exit right after the command
    returns, but its logs will contain the output of the command, constructed of two
    variables from our ConfigMap:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，容器将在命令返回后立即退出，但其日志将包含由我们 ConfigMap 中的两个变量构成的命令输出：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Lastly, we will walk-through mounting ConfigMap as a configuration file into
    a pod. Again, let''s delete the pod from the previous exercise:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将演示如何将 ConfigMap 作为配置文件挂载到 pod 中。再次，先删除之前练习中的 pod：
- en: '[PRE39]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this example, we will supply the Nginx web server with our custom configuration
    file, which will make its default virtual host listen on port `8888` instead of
    `80`. Here''s the simple configuration to achieve that:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将为 Nginx Web 服务器提供自定义配置文件，这将使其默认虚拟主机监听 `8888` 端口，而不是 `80` 端口。以下是实现这一目标的简单配置：
- en: '[PRE40]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now, let''s go ahead and create a ConfigMap from this configuration:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续从这个配置中创建一个 ConfigMap：
- en: '[PRE41]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'If we take a look at the raw resource definition of this ConfigMap, we will
    see the following:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这个ConfigMap的原始资源定义，将会看到以下内容：
- en: '[PRE42]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As you can see, the entire contents of the configuration file was inserted as
    value into the config map definition with the key `nginx_custom_default.conf`,
    which can be used to reference the configuration in a pod.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，配置文件的全部内容作为值插入到config map定义中的`nginx_custom_default.conf`键下，这样可以在Pod中引用该配置。
- en: 'Now it''s time to create a pod that will use this ConfigMap. Create yet another
    pod definition with the following structure:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候创建一个将使用这个ConfigMap的Pod了。使用以下结构再创建一个Pod定义：
- en: '[PRE43]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: You can specify a path parameter in `configMap.items` to provide the name for
    the file that the configuration will be stored in. Had we not done that in the
    preceding example, the file name would have been the same as the key from the
    `configMap–nginx_custom_default.conf`. We must specify the label for our pod in
    order to be able to create a service for it later on.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`configMap.items`中指定路径参数，以提供配置将被存储的文件名。如果我们在前面的例子中没有这么做，文件名将与`configMap-nginx_custom_default.conf`中的键相同。我们必须为我们的Pod指定标签，以便之后能够为其创建服务。
- en: 'Let''s create the pod now:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来创建Pod：
- en: '[PRE44]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In order to see whether the server listens on the port specified in the ConfigMap,
    we could open a bash session inside the pod and see if the configuration file
    is in place, but let's use a better way that will let us practice with OpenShift
    resources more.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查服务器是否在ConfigMap中指定的端口上监听，我们可以在Pod内部打开一个bash会话，查看配置文件是否到位，但让我们使用一种更好的方法，这样我们可以更多地实践OpenShift资源。
- en: 'We will need to create a service for this pod and then expose it. First, create
    a service:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为这个Pod创建一个服务并暴露它。首先，创建一个服务：
- en: '[PRE45]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We had to explicitly specify the port in the command because we didn't provide
    it in the `containerPort` parameter in the pod's definition.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在命令中明确指定端口，因为我们没有在Pod的定义中的`containerPort`参数中提供端口。
- en: 'Then expose the service itself through `route`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后通过`route`暴露这个服务：
- en: '[PRE46]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, we can use the `curl` command to request a default web page from the
    server''s default virtual host:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`curl`命令从服务器的默认虚拟主机请求一个默认网页：
- en: '[PRE47]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We could have created a separate record for the route above in `/etc/hosts`,
    pointing to `127.0.0.1`, but in order to keep the environment as clean as possible,
    it's a good practice to use `Host` HTTP header instead to select a particular
    application.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本可以在`/etc/hosts`中为上述路由创建一个单独的记录，指向`127.0.0.1`，但是为了保持环境尽可能干净，最好使用`Host` HTTP头来选择特定的应用程序。
- en: 'The preceding output indicates that Nginx indeed listens on port `8888/tcp`,
    as specified in the ConfigMap. This concludes our exercise with ConfigMaps, so
    let''s clean up our lab:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 上述输出表明Nginx确实在`8888/tcp`端口上监听，正如ConfigMap中所指定的。这标志着我们对ConfigMap的练习结束，接下来我们清理实验环境：
- en: '[PRE48]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: ConfigMaps are not considered similar to other resources such as pods or services
    and must be deleted separately.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMap与其他资源（如Pod或服务）不同，必须单独删除。
- en: Controlling resource consumption using ResourceQuotas
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用ResourceQuota控制资源消耗
- en: One of the main ideas behind OpenShift projects in multi-tenant environments
    is the need to limit resource consumption at a more granular level than just a
    whole cluster, providing operations with the ability to scope such limitations
    to organizations and departments.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift项目在多租户环境中的主要思想之一是需要在比整个集群更精细的级别上限制资源消耗，从而为操作提供将这些限制应用于组织和部门的能力。
- en: 'OpenShift provides two mechanisms for setting limits on resource consumption
    in a cluster:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: OpenShift提供了两种机制来设置集群中资源消耗的限制：
- en: '`ResourceQuota`'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResourceQuota`'
- en: '`LimitRanges`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LimitRanges`'
- en: This section is dedicated solely to ResourceQuotas. LimitRanges will be discussed
    in the next section.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本节仅介绍ResourceQuota，LimitRanges将在下一节讨论。
- en: 'ResourceQuota can be used to control the number of API resources that can be
    created, or the amount of CPU, memory, and storage consumed by pods in the same
    project the quotas were defined in. Essentially, they determine the capacity of
    a project. ResourceQuotas allows you to control the following types of resources:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: ResourceQuota可以用来控制可以创建的API资源数量，或者控制在同一项目中定义配额的Pod所消耗的CPU、内存和存储量。本质上，它们决定了一个项目的容量。ResourceQuota允许你控制以下类型的资源：
- en: Pods
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods
- en: ReplicationControllers
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ReplicationControllers
- en: Services
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Secrets
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Secrets
- en: ResourceQuotas
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ResourceQuotas
- en: ConfigMaps
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ConfigMap
- en: ImageStreams
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ImageStreams
- en: PersistentVolumeClaims
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PersistentVolumeClaims
- en: '`requests.storage`'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`requests.storage`'
- en: cpu
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: memory
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: ephemeral-storage
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时存储
- en: limits.ephemeral-storage
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: limits.ephemeral-storage
- en: '`limits.cpu`'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.cpu`'
- en: '`limits.memory`'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.memory`'
- en: If CPU/memory or `limits.cpu`/`limits.memory` are managed by quotas, then all
    pods in the same project must specify requests/limits for the respective computing
    resources.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 CPU/内存或 `limits.cpu`/`limits.memory` 受配额管理，则同一项目中的所有 Pods 必须为相应的计算资源指定请求/限制。
- en: 'In the context of quotas, all pods belong to the following scopes, to which
    quotas can be applied and that scope a certain set of resources:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在配额的背景下，所有 Pods 属于以下范围，配额可以应用于这些范围，并在这些范围内设置一定数量的资源：
- en: '| **Scope** | **Description** | **Managed resources** |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '| **范围** | **描述** | **受管资源** |'
- en: '| `BestEffort` | Applies to all pods running with BestEffort quality of service,
    which means pods that have equal requests and limits for CPU, memory, or both.
    These pods can claim any resources they need, but they are most likely to be killed
    when nodes they run on are low on memory. |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
  zh: '| `BestEffort` | 适用于所有以 BestEffort 服务质量运行的 Pods，这意味着对于 CPU、内存或两者都具有相等请求和限制的
    Pods。这些 Pods 可以申请它们需要的任何资源，但在运行它们的节点内存不足时，它们最有可能被终止。 |'
- en: Pods
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods
- en: '|'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `NotBestEffort` | Applies to all pods running without BestEffort quality
    of service. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| `NotBestEffort` | 适用于所有运行时没有 BestEffort 服务质量的 Pods。 |'
- en: Pods
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Pods
- en: CPU
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: '`limits.cpu`'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.cpu`'
- en: memory
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存
- en: ephemeral-storage
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 临时存储
- en: limits.ephemeral-storage
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: limits.ephemeral-storage
- en: '`limits.memory`'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`limits.memory`'
- en: '|'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `Terminating` | Applies to all pods deployed by jobs with `spec.activeDeadlineSeconds
    >= 0`, which means, for example, build pods that get deployed during S2I builds.
    |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `Terminating` | 适用于所有通过 `spec.activeDeadlineSeconds >= 0` 部署的作业 Pods，例如在
    S2I 构建期间部署的构建 Pods。 |'
- en: '| `NotTerminating` | Applies to all pods deployed by jobs with `spec.activeDeadlineSeconds`
    is nil, which means the usual pods with applications. |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `NotTerminating` | 适用于所有通过 `spec.activeDeadlineSeconds` 为 nil 的作业部署的 Pods，这意味着通常用于应用的
    Pods。 |'
- en: 'Now, let''s see how to create quotas for a project. Like any other resource,
    they can be created through an API, but you can also use CLI, which is what we
    are going to do. Let''s switch back to `system:admin` user since managing quotas
    requires admin privileges:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为项目创建配额。与任何其他资源一样，它们可以通过 API 创建，但您也可以使用 CLI，这正是我们要做的。让我们切换回 `system:admin`
    用户，因为管理配额需要管理员权限：
- en: '[PRE49]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Then we will be able to create our first quota:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将能够创建我们的第一个配额：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'As you can see, the quota was successfully created:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，配额已成功创建：
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Interestingly enough, the number of quotas itself per project can be controlled
    by ResourceQuota. Even if you set a limit for quotas to `0`, you will still be
    able to create your first quota, provided there is no other already existing quota
    that limits this number.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，每个项目本身的配额数量可以由 ResourceQuota 控制。即使您为配额设置限制为 `0`，只要没有其他已存在的限制此数量的配额，您仍然可以创建第一个配额。
- en: By creating this quota, we have set the limits of `500` CPU millicores (half-core),
    `256Mi` requested RAM, `1` pod, and `1` ResourceQuota on the current project.
    Let's see if the quota is in effect.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建这个配额，我们在当前项目上设置了`500` CPU 毫核（半核）、`256Mi` 请求的 RAM、`1` 个 Pod，以及 `1` 个 ResourceQuota。让我们看看配额是否生效。
- en: 'First, create a simple pod definition:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个简单的 Pod 定义：
- en: '[PRE52]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Let''s try to create a pod from it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试从中创建一个 Pod：
- en: '[PRE53]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'As you can see, our definition didn''t pass the check by the quota because
    it explicitly limits the requested amount of CPU and RAM, but we didn''t specify
    them. Let''s modify `nginx-pod.yml` and add `resources` section:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您所见，我们的定义没有通过配额的检查，因为它明确限制了请求的 CPU 和 RAM 量，但我们没有指定它们。让我们修改 `nginx-pod.yml`
    并添加 `resources` 部分：
- en: '[PRE54]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Upon creation, the pod will request 1 CPU core and 128 MiB of RAM, which is
    well within the limits set by the quota. Let''s try it again:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建时，Pod 将请求 1 个 CPU 核心和 128 MiB RAM，这完全在配额设置的限制范围内。让我们再试一次：
- en: '[PRE55]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The pod was created successfully, as expected. At this point, we can take a
    look at how much of our quota was consumed:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，Pod 已成功创建。此时，我们可以查看我们的配额消耗了多少：
- en: '[PRE56]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, let''s see what happens if we try to create one more pod. Prepare a new
    pod definition from the one used to create the first pod by replacing `nginx`
    with `httpd`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果我们尝试创建更多的 Pod 会发生什么。通过将用于创建第一个 Pod 的定义替换 `nginx` 为 `httpd` 来准备一个新的
    Pod 定义：
- en: '[PRE57]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If we try to create the second pod, we will see the following:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试创建第二个 Pod，我们将看到以下内容：
- en: '[PRE58]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Even though the amount of requested memory wouldn't violate the quota, pod creation
    was still denied because the quota limits the total number of pods to `1` for
    the current project.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 即使请求的内存量不会违反配额，pod 创建仍然被拒绝，因为配额限制了当前项目中的 pod 总数为 `1`。
- en: 'Edit the quota to allow 2 pods and 2 CPU cores:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑配额以允许 2 个 pod 和 2 个 CPU 核心：
- en: '[PRE59]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Try creating the second pod again:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试再次创建第二个 pod：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: It worked because the quota was set to allow `2` pods in the current project.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 它之所以有效，是因为配额设置为允许当前项目中最多 `2` 个 pod。
- en: 'Let''s see how many resources are used from the total allowed by the quota
    again:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次查看配额允许的总资源使用情况：
- en: '[PRE61]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: As you can see, we have exhausted the entire quota and no new pods can be created.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们已用尽整个配额，无法创建新的 pod。
- en: 'Now that this exercise is over, it''s time to prepare for the next one by cleaning
    up our lab:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这项练习结束了，是时候通过清理实验室来准备下一项任务：
- en: '[PRE62]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: ConfigMaps and ResourceQuotas are considered separate kinds of resource and
    must be deleted as such.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: ConfigMaps 和 ResourceQuotas 被视为不同种类的资源，必须分别删除。
- en: Controlling resource consumption using LimitRanges
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LimitRanges 控制资源消耗
- en: 'This is another way of control resource allocation in OpenShift at the project
    level, but unlike ResourceQuotas, they are different in certain ways:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在 OpenShift 中按项目级别控制资源分配的方式，但与 ResourceQuotas 不同，它们在某些方面有所不同：
- en: They are applied to individual pods, containers, images, or image streams
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们应用于单个 pod、容器、镜像或镜像流
- en: They don't control some resources such as secrets, ConfigMaps, ResourceQuotas,
    services, and ReplicationControllers
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们无法控制某些资源，如机密、ConfigMaps、ResourceQuotas、服务和 ReplicationControllers。
- en: They can be created from a raw definition only
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们只能从原始定义中创建
- en: 'Depending on the type of resource they are applied to, LimitRanges control
    various computing resources and objects:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 根据它们应用的资源类型，LimitRanges 控制不同的计算资源和对象：
- en: '| **Resource type** | **Computing resources/attributes controlled** |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **资源类型** | **控制的计算资源/属性** |'
- en: '| Pod |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| Pod |'
- en: CPU
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: RAM
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM
- en: '|'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Container |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| Container |'
- en: CPU
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU
- en: RAM
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RAM
- en: '|'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Image | Size of an image pushed into an internal registry |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 镜像 | 推送到内部注册表的镜像大小 |'
- en: '| ImageStream |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| ImageStream |'
- en: Number of unique image tags as per image stream's spec
  id: totrans-248
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据镜像流的规格，唯一镜像标签的数量
- en: Number of unique image references as per the image stream's status
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据镜像流的状态，唯一镜像引用的数量
- en: '|'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| PersistentVolumeClaim | Amount of storage requested |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| PersistentVolumeClaim | 请求的存储量 |'
- en: Pods and containers can explicitly state the amount of CPU and/or RAM they need
    and their limits, and LimitRanges takes care that they don't fall outside certain
    boundaries. Also, LimitRanges may provide defaults for a requested number of resources
    and their limits if they are not specified.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Pod 和容器可以明确声明它们所需的 CPU 和/或 RAM 以及它们的限制，LimitRanges 会确保它们不会超出某些边界。此外，如果未指定，LimitRanges
    还可以为请求的资源数量及其限制提供默认值。
- en: 'Depending on the presence of, and differences between, requests and limits
    for computing resources declared by pods, they run with different **Quality of
    Service** (**QoS**) tiers that serve the purpose of prioritizing running pods
    when it comes to resource contention. The following table summarizes the available
    tiers and when they are applied:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 pod 声明的计算资源请求和限制的存在及差异，它们以不同的 **服务质量**（**QoS**）等级运行，以便在资源争用时优先运行某些 pod。下表总结了可用的等级以及何时应用它们：
- en: '| **QoS tier** | **Description** |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| **QoS 等级** | **描述** |'
- en: '| `BestEffort` | This tier is assigned to pods that don''t specify requests
    and limits explicitly. Such pods can consume as much CPU and RAM as they need,
    but if the node a pod runs on is short on either or both resources, these pods
    are the first to be terminated. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `BestEffort` | 此等级分配给未明确指定请求和限制的 pod。这些 pod 可以根据需要消耗任何 CPU 和 RAM，但如果 pod
    所在的节点缺少这些资源，它们将是首先被终止的 pod。 |'
- en: '| `Burstable` | Pods that have limits higher than requests get assigned the
    Burstable QoS tier. They run with a lower priority than BestEffort pods, meaning
    that they are only terminated when there are no BestEffort pods to terminate.
    |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `Burstable` | 请求的限制高于请求的 pod 被分配到 Burstable QoS 等级。它们的优先级低于 BestEffort pod，意味着只有在没有
    BestEffort pod 可终止时，它们才会被终止。 |'
- en: '| `Guaranteed` | This tier is applicable to pods that have equal requests and
    limits for computing resources. Each pod running with this QoS is entitled to
    the requested amount of resources, but no more. They have the highest priority,
    which means that they are only killed when there are no BestEffort or Burstable
    pods. |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `Guaranteed` | 这个层级适用于计算资源请求和限制相等的 pod。每个使用此 QoS 的 pod 有权获得请求的资源量，但不能更多。它们具有最高优先级，这意味着只有在没有
    BestEffort 或 Burstable pod 时，才会被终止。 |'
- en: 'Just as in the previous section, setting LimitRanges requires administrative
    privileges, so make sure you are logged in as `system:admin` user:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一节所述，设置 LimitRanges 需要管理员权限，因此请确保以 `system:admin` 用户登录：
- en: '[PRE63]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Let''s consider an example of creating a `LimitRange` from scratch:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一个从头创建 `LimitRange` 的示例：
- en: '[PRE64]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create limits from the preceding definition:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的定义创建限制：
- en: '[PRE65]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Now, let''s describe our newly created limits:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们描述一下我们新创建的限制：
- en: '[PRE66]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There are also the `spec.limits[].default` and `spec.limits[].defaultRequest`
    parameters, which determine the amount of CPU/RAM a container is limited to use
    and the amount it requests by default, respectively. Since we didn't specify them
    explicitly, they default to the same maximum value.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 还有 `spec.limits[].default` 和 `spec.limits[].defaultRequest` 参数，它们分别确定容器使用的 CPU/RAM
    限制量以及默认请求的量。由于我们没有明确指定，它们默认与最大值相同。
- en: 'The next step is to create a pod that requests a specific amount of computing
    resources and sets limits on their usage for itself. Prepare the following pod
    definition:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个请求特定计算资源并为自身设置资源使用限制的 pod。准备以下 pod 定义：
- en: '[PRE67]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Next, create a pod from the definition:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，从定义中创建一个 pod：
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: As you might expect after looking at the pod's definition, the operation was
    rejected because the pod's request and limit ranges violate the policy defined
    earlier.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您通过查看 pod 定义可能预料到的那样，操作被拒绝，因为 pod 的请求和限制范围违反了之前定义的策略。
- en: Minimum boundaries are also enforced.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 最小边界也被强制执行。
- en: 'Let''s edit the pod''s definition to comply with the defined LimitRange:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编辑 pod 的定义，使其符合定义的 LimitRange：
- en: '[PRE69]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Try to create it again and observe that it works:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 再次尝试创建并观察它是否正常工作：
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Let''s clean up the lab to prepare for the next section:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们清理实验环境，为下一节做准备：
- en: '[PRE71]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: LimitRanges are considered a separate kind of resource as well, like templates,
    ConfigMaps, and ResourceQuotas, so they must be deleted by issuing a separate
    command.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: LimitRanges 也被视为一种单独的资源，就像模板、ConfigMaps 和 ResourceQuotas 一样，因此它们必须通过单独的命令删除。
- en: Creating complex stacks of applications with templates
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板创建复杂的应用程序堆栈
- en: Another useful kind of OpenShift resource is a template. Instead of creating
    resources one-by-one – for example, a pod, service, and route – templates allow
    you to create multiple objects at once with a single CLI command. More than that
    —they may include parameters that can be optional, or default to values either
    static or generated in accordance with specific rules. In a sense, they are similar
    to Docker Compose or OpenStack Heat—all of these provide the facility to create
    entire application stacks from the ground up. With templates, the cluster administrator
    can provide developers with the ability to deploy multi-tier applications with
    all dependent services.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的 OpenShift 资源是模板。与其逐个创建资源——例如 pod、服务和路由——模板允许您通过单个 CLI 命令一次性创建多个对象。更重要的是，它们可能包含可以是可选的参数，或者根据特定规则生成的静态或默认值。从某种意义上说，它们类似于
    Docker Compose 或 OpenStack Heat——这些都提供了从零开始创建完整应用程序堆栈的功能。通过模板，集群管理员可以为开发人员提供部署多层应用程序及其所有依赖服务的能力。
- en: By default, OpenShift comes installed with quite a few default templates, called
    **Instant App** and **Quick Start** templates. They can be used to deploy runtime
    environments based on various languages and frameworks, such as Ruby on Rails
    (Ruby), Django (Python), and CakePHP (PHP). They also include templates for SQL
    and NoSQL database engines with persistent storage, which includes `PersistentVolumeClaims`
    as one of the objects to provide persistence of data.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，OpenShift 安装了许多默认模板，称为 **Instant App** 和 **Quick Start** 模板。它们可用于部署基于各种语言和框架的运行时环境，例如
    Ruby on Rails（Ruby）、Django（Python）和 CakePHP（PHP）。它们还包括带有持久存储的 SQL 和 NoSQL 数据库引擎模板，其中包括
    `PersistentVolumeClaims` 作为提供数据持久性的对象之一。
- en: 'For this exercise, you will not require admin privileges, so you can login
    as a regular user:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本次练习中，您不需要管理员权限，因此可以作为普通用户登录：
- en: '[PRE72]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Default templates are created in the `openshift` project during installation.
    You can see them by running the following command:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 默认模板在安装期间会在 `openshift` 项目中创建。您可以通过运行以下命令查看它们：
- en: '[PRE73]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: We used the `cut` command to exclude descriptions and other information for
    the sake of brevity, but you can run this command without `cut` to see the full
    output.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `cut` 命令来排除描述和其他信息，目的是简化输出，但您也可以在不使用 `cut` 的情况下运行该命令，以查看完整输出。
- en: Both MiniShift and OpenShift, when installed by the Ansible installer, have
    default templates installed out-of-the-box but, in the case of containerized quick
    installation, you may have to create them manually from YAML definitions located
    in the `roles/openshift_examples/files/examples/` directory of the Ansible installer.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 当 MiniShift 和 OpenShift 通过 Ansible 安装器安装时，默认模板会直接安装。但在容器化快速安装的情况下，您可能需要从位于 `roles/openshift_examples/files/examples/`
    目录中的 YAML 定义手动创建它们。
- en: 'To get a list of parameters that are supported by a particular template, use
    the `process` command:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取特定模板支持的参数列表，请使用 `process` 命令：
- en: '[PRE74]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: We left out descriptions of the parameters to make the output more readable.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了参数的描述，以便让输出更加易读。
- en: As you may have noticed, some parameters have dynamic default values, generated
    by expressions loosely based on **Perl Compatible Regular Expressions** (**PCREs**).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您可能已经注意到的，某些参数具有动态默认值，这些值是由表达式生成的，这些表达式 loosely 基于 **Perl 兼容正则表达式** (**PCREs**)。
- en: 'The `process` command generates default values from all dynamic expressions,
    making the template definition ready to be used for creating resources, which
    is done either by piping its output to the `create` command or by running the `new-app`
    command—we will get to that in a few moments. For now, let''s use that command
    to see a `List` of objects to be created:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`process` 命令会从所有动态表达式中生成默认值，使得模板定义准备好用于创建资源，可以通过将其输出传递给 `create` 命令，或运行 `new-app`
    命令来实现——稍后我们将详细讲解。现在，让我们使用该命令查看要创建的对象的 `List`：'
- en: '[PRE75]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The process command allows for an alternate syntax, `<NAMESPACE>//<TEMPLATE>`.
    We used it here for demonstration purposes, but you are free to use the more familiar
    `-n <NAMESPACE>` notation.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`process` 命令允许使用另一种语法，`<NAMESPACE>//<TEMPLATE>`。我们在此处使用它是为了演示，但您可以自由地使用更熟悉的
    `-n <NAMESPACE>` 语法。'
- en: The list is quite long, so we only provided an excerpt showing the `Secret`
    resource that contains all generated sensitive values that are to be used for
    template instantiation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 列表很长，所以我们只提供了一个摘录，显示包含所有生成的敏感值的 `Secret` 资源，这些值将用于模板实例化。
- en: 'To make things clearer, let''s take a look at the expressions for generating
    those values in the raw template definition:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更清楚地理解，让我们看一下生成这些值的原始模板定义中的表达式：
- en: '[PRE76]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: You may have noticed, for example, that `MYSQL_DATABASE` is `sampledb`, while
    `MYSQL_USER` starts with the string `user` with three alphanumeric characters,
    just as we saw in the previous listing.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，例如，`MYSQL_DATABASE` 是 `sampledb`，而 `MYSQL_USER` 以字符串 `user` 开头，后面跟着三个字母数字字符，正如我们在之前的列表中看到的那样。
- en: To learn more about how to construct regular expressions for dynamic parameters,
    refer to [http://perldoc.perl.org/perlre.html](http://perldoc.perl.org/perlre.html).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解如何为动态参数构造正则表达式，请参考 [http://perldoc.perl.org/perlre.html](http://perldoc.perl.org/perlre.html)。
- en: 'Now, we will create our own simple template. Create a new template definition
    with the following contents:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建我们自己的简单模板。创建一个新的模板定义，内容如下：
- en: '[PRE77]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Though in our case the message parameter is used in quite a rudimentary way,
    in more complex templates, its purpose is to tell the user how to use the template—what
    usernames, passwords, URLs, and so on were generated.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的案例中，`message` 参数的使用方式相当基础，但在更复杂的模板中，它的目的是告诉用户如何使用模板——例如生成了哪些用户名、密码、URL
    等。
- en: 'This template can be used to create three resources:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板可以用来创建三个资源：
- en: A pod running a web server, which you can choose by supplying the `WEB_SERVER`
    parameter. By default, it's `nginx`.
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个运行 Web 服务器的 pod，您可以通过提供 `WEB_SERVER` 参数来选择服务器类型。默认情况下，它是 `nginx`。
- en: A service proxying incoming traffic to the pod.
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个代理服务，用于转发传入流量到 pod。
- en: A route for external access.
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于外部访问的路由。
- en: 'We can process that definition right away and pass the resulting list of resources
    to the `create` command, but a common strategy is to create a template from its
    definition first:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以立即处理该定义，并将生成的资源列表传递给 `create` 命令，但一种常见的策略是先从定义中创建模板：
- en: '[PRE78]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Let''s try to process it:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们试着处理一下：
- en: '[PRE79]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: You can see the only parameter with the default value and description that you
    defined earlier.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到唯一的参数，以及你之前定义的默认值和描述。
- en: 'Now, it''s time to create a stack of resources from our template. This can
    be done by either piping the output of the `process` command to the `create` command,
    which we mentioned previously, or by using the `new-app` command. Let''s start
    with the former approach:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候从我们的模板创建一组资源了。可以通过将 `process` 命令的输出传递给之前提到的 `create` 命令，或者使用 `new-app`
    命令来完成。让我们从前者开始：
- en: '[PRE80]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As you can see, the `create` command just takes the list of resources and submits
    requests for their creation one-by-one to the API, so the output is similar to
    what you would see if you created three separate resource definitions and created
    resources from them manually.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，`create` 命令只是将资源列表传递给 API，并一一提交请求以创建它们，因此输出类似于你手动创建三个单独的资源定义并从中创建资源时看到的输出。
- en: 'But another way to instantiate a template gives you more information about
    what is going on. Let''s delete the created resources first:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 但另一种实例化模板的方法会为你提供更多关于发生了什么的信息。我们先删除已创建的资源：
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'We don''t have to delete the template as it''s not going to change. Now, we
    can use the `new-app` command:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必删除模板，因为它不会发生变化。现在，我们可以使用 `new-app` 命令：
- en: '[PRE82]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: As you can see, we created the pod, fronted it with the service, and exposed
    it through the route in just a single command. Notice that you don't need to run
    the `oc get route`  command to find out what URL your application is accessible
    through—it all shows in the output.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们创建了 pod，前端服务并通过路由暴露出来，仅用一个命令就完成了。请注意，你无需运行 `oc get route` 命令来查找你的应用程序可通过哪个
    URL 访问——这一切都会在输出中显示出来。
- en: 'Let''s see if our web server is reachable through `curl`:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查一下我们的 Web 服务器是否可以通过 `curl` 访问：
- en: '[PRE83]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We used the `-I` parameter of the `curl` command to see only response headers,
    which is enough to check the responsiveness of the server and ensure that it doesn't
    dump raw HTML into the console. Also, just as before, we used -H option to request
    a specific application from OpenShift's router.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了 `curl` 命令的 `-I` 参数来只查看响应头，这足以检查服务器的响应性并确保它不会将原始 HTML 输出到控制台。同时，和之前一样，我们使用了
    `-H` 选项来从 OpenShift 的路由器请求特定的应用程序。
- en: 'You can easily delete all of the resources and instantiate the template again,
    but this time with another web server image, such as Apache:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以轻松删除所有资源并再次实例化模板，但这次使用另一种 Web 服务器镜像，比如 Apache：
- en: '[PRE84]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: That's it—one parameter and you have a different web server deployed for you
    in a matter of seconds.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 就是这样——一个参数，你就可以在几秒钟内部署一个不同的 Web 服务器。
- en: 'You can also perform a reverse operation—creating a template from existing
    resources. To do that, use the `export` command:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以执行逆向操作——从现有资源创建模板。为此，使用 `export` 命令：
- en: '[PRE85]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Let''s delete our resources to prevent any conflicts:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们删除我们的资源，以防发生冲突：
- en: '[PRE86]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And recreate them from the exported template:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 并从导出的模板中重新创建它们：
- en: '[PRE87]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: You might have noticed that the web server was exposed through the same URL
    as before. This is because the exported template was created from already instantiated
    resources with all parameters resolved to values, so OpenShift has no way of knowing
    which fields were parameterized. You can also infer this from the output of the
    `process` command, which will show you that all the fields are already initialized.
    So, strictly speaking, this isn't a fully reverse operation, but it can be used
    for backups.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能注意到 Web 服务器是通过与之前相同的 URL 暴露的。这是因为导出的模板是从已经实例化的资源创建的，所有参数都解析为具体值，因此 OpenShift
    无法知道哪些字段是参数化的。你也可以从 `process` 命令的输出中推断出这一点，它会显示所有字段已经初始化。因此，严格来说，这并不是一个完全的逆向操作，但它可以用于备份。
- en: 'Now that we are finished, let''s do a clean-up:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了，让我们进行清理：
- en: '[PRE88]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Autoscaling your application depending on CPU and RAM utilization
  id: totrans-336
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据 CPU 和 RAM 使用情况自动扩展应用程序
- en: 'You can scale pods in your application using the `oc scale` command, but it
    has two disadvantages:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用 `oc scale` 命令来扩展应用程序中的 pod，但它有两个缺点：
- en: It has to be run manually every time you need to scale a pod up or down
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每次需要扩展 pod 时都必须手动运行此命令
- en: You have to take into account CPU and RAM utilization yourself
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要自己考虑 CPU 和 RAM 使用情况
- en: This approach doesn't allow businesses to adapt quickly to constantly changing
    customers demands. There is a better way—`HorizontalPodAutoscaler`.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方式无法使企业迅速适应不断变化的客户需求。还有一种更好的方式——`HorizontalPodAutoscaler`。
- en: At the time of writing, autoscaling can only track CPU and RAM usage. Traffic-based
    autoscaling, for instance, isn't supported.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，自动扩缩只能跟踪CPU和RAM的使用情况。例如，基于流量的自动扩缩并不被支持。
- en: 'Let''s login as `system:admin` and see if Hawkular, Cassandra, and Heapster
    pods are up and running:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以`system:admin`身份登录，看看Hawkular、Cassandra和Heapster的Pod是否已启动并运行：
- en: '[PRE89]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: By the time you get to this section, all metrics pods will be ready, but usually
    it takes 8-10 minutes for them to get started after installation is done.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 当你到达本节时，所有的指标Pod都会准备就绪，但通常需要8到10分钟才能在安装完成后启动。
- en: CPU-based autoscaling
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于CPU的自动扩缩
- en: CPU-based autoscaling also requires limit ranges to be set on CPU requests for
    the pods being scaled, so we can use the LimitRange definition from one of the
    previous sections.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 基于CPU的自动扩缩还需要为被扩缩的Pod设置CPU请求的限制范围，因此我们可以使用之前章节中的`LimitRange`定义。
- en: '[PRE90]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: Depending on your host machine's CPU, you might have to tweak the values in
    the file above in order for autoscaling to work, that is why in the listing above
    they are different than in the beginning of the chapter.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你的主机CPU，可能需要调整上述文件中的值，以使自动扩缩功能生效。这也是为什么在上面的列表中，它们与章节开头的设置有所不同。
- en: 'The autoscaling feature can be applied to deployment configs, so the easiest
    way to create one is to use the already familiar `new-app` command:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 自动扩缩功能可以应用于部署配置，因此创建一个最简单的方法是使用已经熟悉的`new-app`命令：
- en: '[PRE91]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'For demonstration purposes, we used the Apache web server image to create an
    image stream, which, in turn, is used to create the application. Now that the
    `deploymentconfig` is ready to manage pods, we can create a `HorizontalPodAutoscaler`
    to manage the `deploymentconfig` itself:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 出于演示目的，我们使用了Apache Web服务器镜像来创建镜像流，镜像流又用于创建应用程序。现在`deploymentconfig`已经准备好管理Pod，我们可以创建一个`HorizontalPodAutoscaler`来管理`deploymentconfig`本身：
- en: '[PRE92]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: We specified `2` as the minimum number of pods that must be maintained at any
    time so that you can observe the effect of autoscaling quickly without having
    to generate CPU load on pods to trigger it. We will do that in a few moments as
    well.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我们指定了`2`作为始终必须保持的最小Pod数量，这样你就可以快速观察到自动扩缩的效果，而不必在Pod上生成CPU负载来触发它。我们稍后也会这样做。
- en: 'Let''s make sure it was created:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们确认它已经创建：
- en: '[PRE93]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: If you run this command right after creation, you will most likely see unknown
    instead of `0%` in the preceding output. That is expected because `HorizontalPodAutoscaler`
    usually needs a few minutes to collect enough metrics.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在创建后立即运行此命令，你很可能会在前面的输出中看到"unknown"而不是`0%`。这是预期的，因为`HorizontalPodAutoscaler`通常需要几分钟时间来收集足够的指标。
- en: 'In a few minutes, you may list running pods and notice that there are two of
    them now:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 几分钟后，你可以列出正在运行的Pod，并注意到现在有两个Pod：
- en: '[PRE94]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Now, we have to simulate a large number of user requests to our pods to increase
    the CPU load so that autoscaling takes effect. But to do that, we need to create
    a route first:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要模拟大量用户请求到我们的Pod，以增加CPU负载，使得自动扩缩能够生效。但在此之前，我们需要先创建一个路由：
- en: '[PRE95]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'At this point, we have everything we need, so let''s start simulating CPU load
    with the `ab` Apache benchmarking utility:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们已经准备好了所有所需内容，接下来让我们使用`ab` Apache基准测试工具来模拟CPU负载：
- en: '[PRE96]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: When `httpd` DeploymentConfig is scaled up, you can just press `Ctrl+C` to stop
    generating the traffic, as is indicated by `^C` in the output above.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 当`httpd`的DeploymentConfig被扩展时，你可以按`Ctrl+C`停止生成流量，如上面输出中的`^C`所示。
- en: 'Login in a separate terminal as `system:admin` and at some point you should
    be able to see that you have 4 pods running :'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在另一个终端中以`system:admin`身份登录，之后你应该能看到你有4个Pod在运行：
- en: '[PRE97]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Once you press *Ctrl* + *C* and benchmarking stops, then after a while, the
    number of pods will go back to normal:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你按下*Ctrl* + *C*并停止基准测试，过一会儿，Pod的数量会恢复正常：
- en: '[PRE98]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: If you are interested, you can see the collected metrics and autoscaling taking
    place in the web console. Open the web console in a browser at [https://openshift.example.com:8443/](https://openshift.example.com:8443/),
    confirm the security exception for the self-signed certificate, and login with
    the username `alice` and any password.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣，你可以在Web控制台中查看收集的指标和自动扩缩的情况。在浏览器中打开[https://openshift.example.com:8443/](https://openshift.example.com:8443/)，确认自签名证书的安全异常，并以用户名`alice`和任意密码登录。
- en: 'As our OpenShift cluster uses self-signed TLS certificates for encrypting HTTP
    traffic, Hawkular metrics will not be accessible from the Overview tab of the
    web console at first—you will see an error above the list of pods instead. To
    fix this, click on the provided link to open the Hawkular URL in a separate tab/window
    in your browser and confirm the security exception for the certificate as well.
    After that, refresh the Overview tab and you will see the calculated metrics for
    each pod marked with different colors:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的 OpenShift 集群使用自签名的 TLS 证书来加密 HTTP 流量，初始时，你无法从 web 控制台的 Overview 选项卡访问
    Hawkular 指标——你会在 pod 列表上方看到一个错误信息。为了解决这个问题，点击提供的链接，在浏览器中打开 Hawkular URL 并确认证书的安全例外。之后，刷新
    Overview 选项卡，你就可以看到每个 pod 的计算指标，这些指标会用不同的颜色标出：
- en: '![](img/00054.jpeg)'
  id: totrans-370
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00054.jpeg)'
- en: 'You can also use the Monitoring tab to get a more detailed view:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用 Monitoring 选项卡来获得更详细的视图：
- en: '![](img/00055.jpeg)'
  id: totrans-372
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00055.jpeg)'
- en: You can clearly see the spikes in CPU load and network traffic that correspond
    to the `ab` run.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以清楚地看到与`ab`运行对应的 CPU 负载和网络流量的峰值。
- en: 'We need to delete CPU-based autoscaler before the next exercise:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在下一个练习之前删除基于 CPU 的自动扩展器：
- en: '[PRE99]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Memory-based autoscaling
  id: totrans-376
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于内存的自动扩展
- en: 'Unlike autoscaling based on CPU utilization, memory-based autoscaling can only
    be enabled by creating a `HorizontalPodAutoscaler` from a raw YAML/JSON definition:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 与基于 CPU 使用率的自动扩展不同，基于内存的自动扩展只能通过从原始 YAML/JSON 定义创建 `HorizontalPodAutoscaler`
    来启用：
- en: '[PRE100]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Let''s enable autoscaling now:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们启用自动扩展：
- en: '[PRE101]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Give it a minute or two to pick up the metrics from Heapster and you will be
    able to see how the current memory utilization is different from the target:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 等待一两分钟，以便从 Heapster 收集度量数据，你将能够看到当前的内存使用情况与目标之间的差异：
- en: '[PRE102]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: If you run this command right after creation, you will most likely see unknown
    instead of `7%` in the preceding output. This is expected because `HorizontalPodAutoscaler`
    usually needs a few minutes to collect sufficient metrics.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在创建之后立即运行此命令，你很可能会看到输出中显示“unknown”而不是`7%`。这是预期中的情况，因为`HorizontalPodAutoscaler`通常需要几分钟时间来收集足够的度量数据。
- en: 'Let''s go ahead and generate traffic for the application, just like in the
    previous section, but establish `1000` concurrent connections this time, instead
    of `100`:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续为应用生成流量，就像上一节那样，不过这次我们将建立 `1000` 个并发连接，而不是 `100`：
- en: '[PRE103]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Laeve  benchmark open for 5-10 minutes, and meanwhile open your browser at [https://hawkular-metrics.openshift.example.com/hawkular/metrics](https://hawkular-metrics.openshift.example.com/hawkular/metrics)
    to make sure that hawkular metrics are running, and then at [https://openshift.example.com:8443/console/project/advanced/overview](https://openshift.example.com:8443/console/project/advanced/overview)
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 保持基准测试打开 5-10 分钟，同时在浏览器中打开 [https://hawkular-metrics.openshift.example.com/hawkular/metrics](https://hawkular-metrics.openshift.example.com/hawkular/metrics)，以确保
    Hawkular 指标正在运行，然后再打开 [https://openshift.example.com:8443/console/project/advanced/overview](https://openshift.example.com:8443/console/project/advanced/overview)
- en: 'You can observe autoscaling taking place from the web console. First it scales
    our web server to 3 replicas:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 web 控制台观察到自动扩展的发生。首先，它将我们的 web 服务器扩展到 3 个副本：
- en: '![](img/00056.jpeg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00056.jpeg)'
- en: 'And shortly after, to 4:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 随后转到 4：
- en: '![](img/00057.jpeg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00057.jpeg)'
- en: 'After `ab` is finished generating traffic, the number of pods slowly goes down:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ab`完成生成流量后，pod 数量会慢慢减少：
- en: '![](img/00058.jpeg)'
  id: totrans-393
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00058.jpeg)'
- en: It is possible to observe short bursts in the number of replicas if you put
    too much load on the service. This is normal and you may see from events that
    the `deploymentconfig` scales, for example, from 3 to 6 without transient states,
    then quickly detects the anomaly and corrects it by scaling back to the maximum
    value.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对服务施加过大负载，你可能会观察到副本数出现短暂的激增。这是正常的，你可能会从事件中看到 `deploymentconfig` 从 3 扩展到 6
    而没有过渡状态，然后迅速发现异常并通过缩减副本数恢复到最大值。
- en: Due to the specifics of memory utilization by pods, it's common that the `deploymentconfig`/`replicationcontroller` doesn't
    fully scale back to the minimum number of replicas.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 pods 的内存使用特点，通常`deploymentconfig`/`replicationcontroller` 不会完全缩放回最小副本数。
- en: 'The exercise is over, so it''s time to clean-up:'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 练习结束了，现在是清理的时候了：
- en: '[PRE105]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: It is not advisable to activate CPU- and RAM-based autoscalers at the same time
    as they may conflict with each other. Determine what resources your application
    relies on most of the time and use the appropriate autoscaling.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议同时启用基于 CPU 和内存的自动扩展器，因为它们可能会相互冲突。确定应用程序通常依赖于哪些资源，并使用适当的自动扩展。
- en: Summary
  id: totrans-399
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we introduced you to the concept of image streams and methods
    of creating them, how config maps can be used to manage the configuration of your
    applications, mechanisms for limiting resource consumption per project using resource
    quotas and limit ranges, how to use templates to create multiple dependent resources,
    and how to configure autoscaling for your applications based on CPU or memory
    utilization.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们向您介绍了镜像流的概念以及创建镜像流的方法，如何使用配置映射来管理应用程序的配置，如何通过资源配额和限制范围机制来限制每个项目的资源消耗，如何使用模板创建多个相关的资源，以及如何根据
    CPU 或内存使用情况配置应用程序的自动扩展。
- en: In the next chapter, we will work on security in OpenShift. We will be giving
    you an understanding of OpenShift security implementation, which is mandatory
    for any production environment.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论 OpenShift 中的安全性。我们将帮助您理解 OpenShift 安全性实施，这对于任何生产环境都是必需的。
- en: Questions
  id: totrans-402
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'What are ImageStreams used for? choose 2:'
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ImageStreams 用于什么？选择 2 个：
- en: To protect applications from breaking unexpectedly when the image that an ImageStream
    points to changes.
  id: totrans-404
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保护应用程序不因 ImageStream 指向的镜像发生变化而导致意外崩溃。
- en: To implement rolling updates of applications.
  id: totrans-405
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现应用程序的滚动更新。
- en: To store build images.
  id: totrans-406
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用于存储构建镜像。
- en: To implement automatic build and deployments on image change.
  id: totrans-407
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现镜像更改时的自动构建和部署。
- en: 'What commands can be used to create a ConfigMap? choose 2:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 ConfigMap 时可以使用哪些命令？选择 2 个：
- en: oc create configmap my-configmap --from-file=nginx.conf
  id: totrans-409
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc create configmap my-configmap --from-file=nginx.conf
- en: oc create cm --from-env-file=environment.env
  id: totrans-410
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc create cm --from-env-file=environment.env
- en: oc create -f configmap_definition.yaml
  id: totrans-411
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc create -f configmap_definition.yaml
- en: oc edit configmap/my-configmap
  id: totrans-412
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc edit configmap/my-configmap
- en: 'Which of the following valid commands to create a quota? choose 2:'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪些命令是有效的创建配额命令？选择 2 个：
- en: oc create resourcequota example-quota --hard=cpus=2,memory=512Mi
  id: totrans-414
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc create resourcequota example-quota --hard=cpus=2,memory=512Mi
- en: oc create quota example-quota --hard=cpu=4,ram=1Gi
  id: totrans-415
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc create quota example-quota --hard=cpu=4,ram=1Gi
- en: oc create resourcequota my-quota --hard=cpu=4,services=5
  id: totrans-416
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc create resourcequota my-quota --hard=cpu=4,services=5
- en: oc create quota another-quota --hard=pods=8,secrets=4
  id: totrans-417
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: oc create quota another-quota --hard=pods=8,secrets=4
- en: 'What resources CAN''T be controlled by a LimitRange? choose 2:'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: LimitRange 不能控制哪些资源？选择 2 个：
- en: Pod
  id: totrans-419
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: Pod
- en: ConfigMap
  id: totrans-420
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ConfigMap
- en: ImageStream
  id: totrans-421
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ImageStream
- en: Service
  id: totrans-422
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务
- en: What is the correct syntax  for referencing the VARIABLE parameter in a template?
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模板中引用 VARIABLE 参数的正确语法是什么？
- en: '#{VARIABLE}'
  id: totrans-424
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: '#{VARIABLE}'
- en: <VARIABLE>
  id: totrans-425
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: <VARIABLE>
- en: ${VARIABLE}
  id: totrans-426
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: ${VARIABLE}
- en: '%VARIABLE%'
  id: totrans-427
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '%VARIABLE%'
- en: What must be specified by pods for CPU-based autoscaling?
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: CPU 自动扩展时，Pods 必须指定什么？
- en: Labels
  id: totrans-429
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标签
- en: Limits
  id: totrans-430
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 限制
- en: Requests
  id: totrans-431
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求
- en: Selectors
  id: totrans-432
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择器
- en: What API version must be used to configure memory-based autoscaling?
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置内存自动扩展时必须使用什么 API 版本？
- en: v1
  id: totrans-434
  prefs:
  - PREF_UL
  - PREF_OL
  type: TYPE_NORMAL
  zh: v1
- en: v2
  id: totrans-435
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: v2
- en: v2alpha1
  id: totrans-436
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: v2alpha1
- en: v1beta1
  id: totrans-437
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: v1beta1
- en: Further reading
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'In this chapter, we covered advanced concepts of the OpenShift container platform.
    Here''s a list of links that may be helpful to look through so that you can learn
    more:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 OpenShift 容器平台的高级概念。以下是一些可能有助于您深入学习的链接列表：
- en: '**OpenShift documentation on ImageStreams**: [https://docs.openshift.org/latest/architecture/core_concepts/builds_and_image_streams.html](https://docs.openshift.org/latest/architecture/core_concepts/builds_and_image_streams.html)'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift 文档：ImageStreams**：[https://docs.openshift.org/latest/architecture/core_concepts/builds_and_image_streams.html](https://docs.openshift.org/latest/architecture/core_concepts/builds_and_image_streams.html)'
- en: '**OpenShift documentation on ConfigMaps**: [https://docs.openshift.org/latest/dev_guide/configmaps.html](https://docs.openshift.org/latest/dev_guide/configmaps.html)'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift 文档：ConfigMaps**：[https://docs.openshift.org/latest/dev_guide/configmaps.html](https://docs.openshift.org/latest/dev_guide/configmaps.html)'
- en: '**OpenShift documentation on ResourceQuotas**: [https://docs.openshift.org/latest/admin_guide/quota.html](https://docs.openshift.org/latest/admin_guide/quota.html)'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift 文档：ResourceQuotas**：[https://docs.openshift.org/latest/admin_guide/quota.html](https://docs.openshift.org/latest/admin_guide/quota.html)'
- en: '**OpenShift documentation on LimitRanges**: [https://docs.openshift.org/latest/admin_guide/limits.html](https://docs.openshift.org/latest/admin_guide/limits.html)'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift 文档：LimitRanges**：[https://docs.openshift.org/latest/admin_guide/limits.html](https://docs.openshift.org/latest/admin_guide/limits.html)'
- en: '**OpenShift documentation on templates**: [https://docs.openshift.org/latest/dev_guide/templates.html#dev-guide-templates](https://docs.openshift.org/latest/dev_guide/templates.html#dev-guide-templates)'
  id: totrans-444
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift 模板文档**: [https://docs.openshift.org/latest/dev_guide/templates.html#dev-guide-templates](https://docs.openshift.org/latest/dev_guide/templates.html#dev-guide-templates)'
- en: '**OpenShift documentation on HorizontalPodAutoscaler**: [https://docs.openshift.org/latest/dev_guide/pod_autoscaling.html](https://docs.openshift.org/latest/dev_guide/pod_autoscaling.html)'
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift 关于 HorizontalPodAutoscaler 的文档**: [https://docs.openshift.org/latest/dev_guide/pod_autoscaling.html](https://docs.openshift.org/latest/dev_guide/pod_autoscaling.html)'
- en: '**Wikipedia article on YAML notation**: [https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML)'
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Wikipedia 上关于 YAML 标记法的文章**: [https://en.wikipedia.org/wiki/YAML](https://en.wikipedia.org/wiki/YAML)'
- en: '**YAML syntax validator**: [http://www.yamllint.com/](http://www.yamllint.com/)'
  id: totrans-447
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAML 语法验证器**: [http://www.yamllint.com/](http://www.yamllint.com/)'
- en: '**JSON notation**: [http://www.json.org](https://www.json.org/)'
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON 标记法**: [http://www.json.org](https://www.json.org/)'
- en: '**JSON syntax validator**: [https://jsonlint.com/](https://jsonlint.com/)'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JSON 语法验证器**: [https://jsonlint.com/](https://jsonlint.com/)'
- en: '**YAML notation specification**: [http://www.yaml.org/start.html](http://www.yaml.org/start.html)'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**YAML 标记法规范**: [http://www.yaml.org/start.html](http://www.yaml.org/start.html)'
- en: '**OpenShift REST API reference**: [https://docs.openshift.org/latest/rest_api/api/](https://docs.openshift.org/latest/rest_api/api/)'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenShift REST API 参考**: [https://docs.openshift.org/latest/rest_api/api/](https://docs.openshift.org/latest/rest_api/api/)'
- en: '**PCRE reference**: [http://perldoc.perl.org/perlre.html](http://perldoc.perl.org/perlre.html)'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PCRE 参考文档**: [http://perldoc.perl.org/perlre.html](http://perldoc.perl.org/perlre.html)'
