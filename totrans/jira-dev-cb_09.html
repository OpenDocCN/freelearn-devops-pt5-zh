<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Remote Access to JIRA</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a SOAP client</li><li class="listitem" style="list-style-type: disc">Creating an issue via SOAP</li><li class="listitem" style="list-style-type: disc">Working with custom fields and SOAP</li><li class="listitem" style="list-style-type: disc">Attachments and SOAP</li><li class="listitem" style="list-style-type: disc">Work logs and time tracking via SOAP</li><li class="listitem" style="list-style-type: disc">Commenting on an issue via SOAP</li><li class="listitem" style="list-style-type: disc">User and Group Management via SOAP</li><li class="listitem" style="list-style-type: disc">Progressing an issue in workflow using SOAP</li><li class="listitem" style="list-style-type: disc">Managing versions via SOAP</li><li class="listitem" style="list-style-type: disc">Administration methods in SOAP API</li><li class="listitem" style="list-style-type: disc">Deploy a SOAP service in JIRA</li><li class="listitem" style="list-style-type: disc">Deploy a XML-RPC service within JIRA</li><li class="listitem" style="list-style-type: disc">Writing a Java XML-RPC client</li><li class="listitem" style="list-style-type: disc">Exposing services and data entities as REST APIs</li><li class="listitem" style="list-style-type: disc">Writing Java client for REST API</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec107"/>Introduction</h1></div></div></div><p>We have seen various ways to enhance the JIRA functionality in the previous chapters, but how do we communicate with JIRA from another application? What are the various methods of integrating third-party applications with JIRA? Or in simple words, how does JIRA expose its functionalities to the outside world?</p><p>JIRA exposes its functionalities via <strong>REST</strong><a id="id1530" class="indexterm"/>, <strong>SOAP</strong><a id="id1531" class="indexterm"/>, or <strong>XML/RPC</strong><a id="id1532" class="indexterm"/> interfaces. Only a handful of the full JIRA functionality is exposed via these interfaces but JIRA also lets us extend these interfaces. In this chapter, we will learn how to communicate with JIRA using these interfaces and add more methods into these interfaces by developing plugins. The focus of this chapter is more on SOAP with examples for other interfaces as well. The core principle for all the interfaces is the same.</p><p>There are quite a lot of methods in SOAP, most of which can be understood well from the API at <a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html">http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html</a>. But there are some methods that need better understanding and those are the ones we will concentrate on in this chapter leaving the rest to the readers.</p><p>SOAP<a id="id1533" class="indexterm"/> is usually the most preferred method of remote access but Atlassian is slowly moving towards REST<a id="id1534" class="indexterm"/> as the preferred mode. A more detailed explanation of these interfaces can be found at: <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/JIRA+RPC+Services">http://confluence.atlassian.com/display/JIRADEV/JIRA+RPC+Services</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec108"/>Creating a SOAP client</h1></div></div></div><p>As mentioned previously, SOAP<a id="id1535" class="indexterm"/> is currently the preferred mode of remote access in JIRA though Atlassian is slowly moving towards REST. SOAP has the most number of methods compared to REST or XML/RPC and is probably used the most in the plugins that we find around us. In this recipe, we will start with the basics and see how we can write a simple SOAP client.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec302"/>Getting ready</h2></div></div></div><p>Install Maven2<a id="id1536" class="indexterm"/> and configure a Java development environment. Make sure the RPC plugin is enabled in JIRA and the <strong>Accept</strong> <strong>remote</strong> <strong>API</strong> <strong>calls</strong> option<a id="id1537" class="indexterm"/> is turned ON at <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong> | <strong>General</strong> <strong>Configuration</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec303"/>How to do it...</h2></div></div></div><a id="id1538" class="indexterm"/><a id="id1539" class="indexterm"/><a id="id1540" class="indexterm"/><a id="id1541" class="indexterm"/><p>The following are the steps to create a JIRA SOAP client:</p><div><ol class="orderedlist arabic"><li class="listitem"><a id="id1542" class="indexterm"/>Download the latest demo SOAP client distribution from the Atlassian public repository at: <a class="ulink" href="http://svn.atlassian.com/svn/public/atlassian/rpc-jira-plugin/tags/">http://svn.atlassian.com/svn/public/atlassian/rpc-jira-plugin/tags/</a>. This contains a Maven 2 project configured to use Apache Axis<a id="id1543" class="indexterm"/>, and a sample Java SOAP client, which creates test issues at <a class="ulink" href="http://jira.atlassian.com">http://jira.atlassian.com</a>.</li><li class="listitem">Modify the <code class="literal">jira.soapclient.jiraurl</code> property<a id="id1544" class="indexterm"/> in the <code class="literal">pom.xml</code> to point to your JIRA instance, the instance you want to connect to. By default, it points to <a class="ulink" href="http://jira.atlassian.com">http://jira.atlassian.com</a>.</li><li class="listitem">Download the WSDL file of the instance you want to connect to. You can find the WSDL file under the <code class="literal">/src/main/wsdl</code> location. If it is not there, or if you want to download the WSDL afresh, run the following command:<div><pre class="programlisting">mvn -Pfetch-wsdl -Djira.soapclient.jiraurl=http://{your_jira_instance}/</pre></div></li><li class="listitem">This will download the WSDL from the configured JIRA instance (as in <em>Step</em> <em>2</em>) to <code class="literal">/src/main/wsdl/</code>. Skip the <code class="literal">jira.soapclient.jiraurl</code> property to download the Atlassian JIRA WSDL.</li><li class="listitem">Create the client JAR. We can do this by running the following command to generate the sources from the WSDL<a id="id1545" class="indexterm"/> and create the SOAP client:<div><pre class="programlisting">mvn -Pbuildclient</pre></div></li><li class="listitem">This will generate a JAR file with all the necessary classes required. There is a second JAR file created with the dependencies (such as the axis) embedded in it. The latter will do a world of good if you are executing it from an environment without axis and other dependencies already configured in it.</li><li class="listitem"><a id="id1546" class="indexterm"/><a id="id1547" class="indexterm"/><a id="id1548" class="indexterm"/><a id="id1549" class="indexterm"/>Write the client program. Let us go with the simplest approach in this recipe, that is, to create a simple standalone Java class in Eclipse. Start by creating an Eclipse project by running the following command:<div><pre class="programlisting">mvn eclipse:eclipse</pre></div><div><div><h3 class="title"><a id="note17"/>Note</h3><p>You can alternatively try other IDEs or even run from the command prompt, whichever is convenient. Make sure you add the client JAR created in <em>Step</em> <em>4</em> in the classpath. All set to write a simple program that just logs into our JIRA instance. From now on, it is just another web service invocation as detailed in the following steps.</p></div></div></li><li class="listitem">Create the standalone Java class.</li><li class="listitem">Get the SOAP service locator:<div><pre class="programlisting">JiraSoapServiceServiceLocator jiraSoapServiceLocator = new JiraSoapServiceServiceLocator();</pre></div></li><li class="listitem">Get the SOAP service instance from the locator by passing the URL of your JIRA instance:<div><pre class="programlisting">JiraSoapService jiraSoapService = jiraSoapServiceLocator.getJirasoapserviceV2(new URL(your_url));</pre></div></li><li class="listitem">Start accessing the methods using the SOAP service instance. For example, the log in can be done as follows:<div><pre class="programlisting">String token = jiraSoapService.login(your_username, your_password);</pre></div><p>The token retrieved here is used for all the other operations instead of logging in every time. You can see the token as the first argument in all other operations.</p></li><li class="listitem">With that, our SOAP Client is ready. Let us just try getting an issue using the key and print its key and ID to prove that this stuff works!<div><pre class="programlisting">RemoteIssue issue = jiraSoapService.getIssue(authToken, ISSUE_KEY);
System.out.println("Retrieved Issue:"+issue.getKey()+" with Id:"+issue.getId());</pre></div><p>You will find the output printed with the issue key and ID.</p></li></ol></div><a id="id1550" class="indexterm"/><a id="id1551" class="indexterm"/><a id="id1552" class="indexterm"/><a id="id1553" class="indexterm"/><p>Hopefully, this gives you a fair idea to get started with your first SOAP client! There is a lot more you can do with the SOAP client some of which we will see in the coming recipes.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec109"/>Creating an issue via SOAP</h1></div></div></div><p>In the previous recipe, we have seen how to create a SOAP client. We also saw how to use the client to connect to the JIRA instance and perform the operations, by taking 'browsing an issue' as an example. In this recipe, we will see how to create an issue using SOAP API.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec304"/>Getting ready</h2></div></div></div><p>Create a JIRA SOAP client as mentioned in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec305"/>How to do it...</h2></div></div></div><a id="id1554" class="indexterm"/><a id="id1555" class="indexterm"/><a id="id1556" class="indexterm"/><p>Following are the steps to create an issue with the standard fields populated on it:</p><div><ol class="orderedlist arabic"><li class="listitem">As mentioned in the previous recipe, get the JIRA SOAP service stub and log in to the box:<div><pre class="programlisting">JiraSoapServiceServiceLocator jiraSoapServiceLocator = new JiraSoapServiceServiceLocator();
JiraSoapService jiraSoapService = jiraSoapServiceLocator.getJirasoapserviceV2(new URL(your_url));
String authToken = jiraSoapService.login(userName, password);</pre></div></li><li class="listitem">Create an instance of <code class="literal">RemoteIssue</code>:<div><pre class="programlisting">RemoteIssue issue = new RemoteIssue();</pre></div></li><li class="listitem">Populate the standard fields on the <code class="literal">RemoteIssue</code> as appropriate:<div><pre class="programlisting">issue.setProject(PROJECT_KEY);
issue.setType(ISSUE_TYPE_ID);
issue.setSummary("Test Issue via my tutorial");
issue.setPriority(PRIORITY_ID);
issue.setDuedate(Calendar.getInstance());
issue.setAssignee("");</pre></div><p>Make sure the <code class="literal">PROJECT_KEY</code>, <code class="literal">ISSUE_TYPE_ID</code>, <code class="literal">PRIORITY_ID</code> , and so on, are all valid values in your JIRA instance. <code class="literal">ISSUE_TYPE_ID</code> and <code class="literal">PRIORITY_ID</code> are IDs and not the name of the issue type and priority.</p></li><li class="listitem"><a id="id1557" class="indexterm"/><a id="id1558" class="indexterm"/><a id="id1559" class="indexterm"/>Set the components on the issue. An issue can have multiple components and hence we need to set an array of <code class="literal">RemoteComponent</code> objects as shown in the following block of code:<div><pre class="programlisting">RemoteComponent component1 = new RemoteComponent();
component1.setId(COMPONENT_ID1);
RemoteComponent component2 = new RemoteComponent();
component2.setId(COMPONENT_ID2);
issue.setComponents(new RemoteComponent[] { component1, component2 });</pre></div><p>We can have as many components as we want, provided the <code class="literal">id</code> instances are valid component IDs in the project we are creating the issue. Here, <code class="literal">id</code> is the unique ID you will find for the component when we browse a component, as shown in the following screenshot:</p><div><img src="img/1803-09-01.jpg" alt="How to do it..."/></div></li><li class="listitem">Set the <strong>Fix</strong> <strong>for</strong> <strong>Versions</strong> or <strong>Affected</strong> <strong>Versions</strong> similar to how we set the components:<div><pre class="programlisting">RemoteVersion version = new RemoteVersion();
version.setId(VERSION_ID);
RemoteVersion[] remoteVersions = new RemoteVersion[] { version };
issue.setFixVersions(remoteVersions);</pre></div><p>Again, <code class="literal">VERSION_ID</code> the unique ID of the version and can be found while browsing the version as we did with components.</p></li><li class="listitem">Invoke the create issue operation on the soap client by passing the authentication token and the <code class="literal">RemoteIssue</code> object<a id="id1560" class="indexterm"/> we constructed.<div><pre class="programlisting">RemoteIssue createdIssue = jiraSoapService.createIssue(authToken, issue);</pre></div></li><li class="listitem"><a id="id1561" class="indexterm"/><a id="id1562" class="indexterm"/><a id="id1563" class="indexterm"/>The issue should now be created and its details like the ID are available on the returned <code class="literal">RemoteIssue</code> object, which can be printed as follows:<div><pre class="programlisting">System.out.println("\tSuccessfully created issue " + createdIssue.getKey() + " with ID:" + createdIssue.getId());</pre></div></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec306"/>How it works...</h2></div></div></div><p>This is just a classic example of invoking a web service from a Java application using Axis2. Once the Java client is written as explained before, we can run the same and the issue will be created in the instance we have referenced in the client.</p><p>Following is a screenshot of an issue created in the TEST project at <a class="ulink" href="http://jira.atlassian.com">http://jira.atlassian.com</a>.</p><div><img src="img/1803-09-02.jpg" alt="How it works..."/></div><p>As you can see, the issue gets populated with all the fields we have set on the <code class="literal">RemoteIssue</code> object.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec110"/>Working with custom fields and SOAP</h1></div></div></div><a id="id1564" class="indexterm"/><p>We have seen how to create an issue with its standard fields. In this recipe, we will deal with custom fields—<strong>create</strong>, <strong>update,</strong> and <strong>read</strong> their values.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec307"/>Getting ready</h2></div></div></div><p>As in the previous recipe, create a JIRA SOAP client.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec308"/>How to do it...</h2></div></div></div><a id="id1565" class="indexterm"/><a id="id1566" class="indexterm"/><p>As mentioned earlier, we will see the creation, updating, and browsing of custom field values separately in this recipe.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec58"/>Creating an issue with custom field values</h3></div></div></div><a id="id1567" class="indexterm"/><a id="id1568" class="indexterm"/><p>Creating an issue with custom fields is pretty similar to creating issues with components or versions. All the custom fields are set on the issue using a single method <code class="literal">setCustomFieldValues</code><a id="id1569" class="indexterm"/>, which takes an array of <a id="id1570" class="indexterm"/>
<code class="literal">RemoteCustomFieldValue</code> objects.</p><p>The following steps explain how it's done:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the custom fields that need to be set on the issue and find their IDs. The ID of a custom field is of the form <code class="literal">customfield_[id]</code> where <code class="literal">[id]</code> is the database ID of the custom field. This ID can be determined from the database, or by editing a custom field in the admin interface, and copying its ID from the URL, as shown in the following screenshot:<div><img src="img/1803-09-03.jpg" alt="Creating an issue with custom field values"/></div></li><li class="listitem"><a id="id1571" class="indexterm"/><a id="id1572" class="indexterm"/>Create a <code class="literal">RemoteCustomFieldValue</code> for each of the custom fields identified. <code class="literal">RemoteCustomFieldValue</code> can be created as follows:<div><pre class="programlisting">RemoteCustomFieldValue customFieldValue = new RemoteCustomFieldValue(CUSTOM_FIELD_KEY, "", new String[] { CUSTOM_FIELD_VALUE1, CUSTOM_FIELD_VALUE2 });</pre></div><p>The values that we pass—<code class="literal">CUSTOM_FIELD_VALUE1</code>, <code class="literal">CUSTOM_FIELD_VALUE2</code>, and so on—should be valid for the field or else will result in validation errors in the server. For single-value custom fields, the array will consist only of a single value. The second attribute takes a <code class="literal">parentKey</code> value that is used only for multidimensional fields such as Cascading select lists. For single-value and multi-value fields like select lists, multi select, and so on, the <code class="literal">parentKey</code> will be an empty string.</p><p>For example, <code class="literal">RemoteCustomFieldValue</code> is constructed for a cascading select as follows:</p><div><pre class="programlisting">RemoteCustomFieldValue customFieldValue = new RemoteCustomFieldValue(CUSTOM_FIELD_KEY_2, "PARENT_KEY", new String[] { CUSTOM_FIELD_VALUE_2 });</pre></div><p>The parent key will be used to construct the full key of the custom field. For example, a cascading select will have the full custom field key as <code class="literal">customfield_10061:1</code> where <code class="literal">customfield_10061</code> is the key of the parent and <code class="literal">:1</code> indicates the first child. In fact, the following two represent the same thing:</p><div><pre class="programlisting">RemoteCustomFieldValue customFieldValue = new RemoteCustomFieldValue("customfield_10061", "1", new String[] { "Some Val" });

RemoteCustomFieldValue customFieldValue = new RemoteCustomFieldValue("customfield_10061:1", null, new String[] { "Some Val" });</pre></div></li><li class="listitem"><a id="id1573" class="indexterm"/><a id="id1574" class="indexterm"/>Set the array of all the custom field values on the issue.<div><pre class="programlisting">RemoteCustomFieldValue[] customFieldValues = new RemoteCustomFieldValue[] { customFieldValue1, customFieldValue2 };
issue.setCustomFieldValues(customFieldValues);</pre></div></li><li class="listitem">Create the issue as usual:<div><pre class="programlisting">RemoteIssue createdIssue = jiraSoapService.createIssue(authToken, issue);</pre></div></li></ol></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec59"/>Updating custom fields on an issue</h3></div></div></div><a id="id1575" class="indexterm"/><a id="id1576" class="indexterm"/><p>Updating a custom field is much similar. However in the <code class="literal">updateIssue</code> method<a id="id1577" class="indexterm"/>, it takes an array of <code class="literal">RemoteFieldValue</code> which could be a standard field or a custom field. In the case of a custom field, we should set the ID of the custom field (full ID if it's a multidimensional field as <code class="literal">RemoteFieldValue</code> doesn't take a parent key!) and an array of String values as shown next:</p><div><pre class="programlisting">RemoteFieldValue[] actionParams = new RemoteFieldValue[] { new RemoteFieldValue(CUSTOM_FIELD_KEY, new String[] { CUSTOM_FIELD_VALUE }) };</pre></div><p>The issue can now be updated as follows:</p><div><pre class="programlisting">RemoteIssue updatedIssue = jiraSoapService.updateIssue(authToken, ISSUE_KEY, actionParams);</pre></div><p>Here, <code class="literal">ISSUE_KEY</code> is the key of the issue to be updated.</p><p>Note that the same <code class="literal">updateIssue()</code> method is used for updating standard fields as well but the only difference is that the <code class="literal">key</code> used in <code class="literal">RemoteFieldValue</code> will be the key of the standard field. The key of the standard field can be found from the <code class="literal">IssueFieldConstants</code> class<a id="id1578" class="indexterm"/>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec60"/>Browsing custom fields on an issue</h3></div></div></div><a id="id1579" class="indexterm"/><a id="id1580" class="indexterm"/><p>Custom fields on an issue can be retrieved using the <code class="literal">getCustomFieldValues</code> method<a id="id1581" class="indexterm"/> on <code class="literal">RemoteIssue</code>. It can then be printed as follows:</p><div><pre class="programlisting">RemoteCustomFieldValue[] cfValues = issue.getCustomFieldValues();
for (RemoteCustomFieldValue remoteCustomFieldValue : cfValues) {
  String[] values = remoteCustomFieldValue.getValues();
  for (String value : values) {
    System.out.println("Value for CF with Id:" + remoteCustomFieldValue.getCustomfieldId() + " -" + value);
  }
}</pre></div><a id="id1582" class="indexterm"/><a id="id1583" class="indexterm"/><p>Here, <code class="literal">remoteCustomFieldValue.getValues()</code> returns an array of String representation of the custom field value.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec111"/>Attachments and SOAP</h1></div></div></div><p>In this recipe, we will see how to add attachments on an issue via SOAP and browse existing attachments.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec309"/>Getting ready</h2></div></div></div><p>As in the previous recipes, create a JIRA SOAP client. Also, make sure attachments are enabled on the JIRA instance.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec310"/>How to do it...</h2></div></div></div><a id="id1584" class="indexterm"/><a id="id1585" class="indexterm"/><a id="id1586" class="indexterm"/><p>Since JIRA4, attachments are added into an issue using <code class="literal">addBase64EncodedAttachmentsToIssue</code> method<a id="id1587" class="indexterm"/> where as pre JIRA4 <code class="literal">addAttachmentsToIssue</code> method<a id="id1588" class="indexterm"/> was used. The latter is still available though it is deprecated. There is also a known issue with the latter where it fails on large attachments.</p><p>Following are the steps to add attachments on an issue using <code class="literal">addBase64EncodedAttachmentsToIssue</code> method:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a File object using the path of the file to be uploaded. The file should be accessible via a valid URL.<div><pre class="programlisting">File file = new File("var/tmp/file.txt");</pre></div><p>The path should be valid in the context.</p></li><li class="listitem">Read the contents of file into a Byte array:<div><pre class="programlisting">// create FileInputStream object
FileInputStream fin = new FileInputStream(file);

/*
* Create byte array large enough to hold the content of the file.
* Use File.length to determine size of the file in bytes.
*/
fileContent = new byte[(int) file.length()];

/*
* To read content of the file in byte array, use int read(byte[]
* byteArray) method of java FileInputStream class.
*/
fin.read(fileContent);
fin.close();</pre></div></li><li class="listitem">Create an encoded String from the Byte array using the <code class="literal">BASE64Encoder</code>.<div><pre class="programlisting">String base64encodedFileData = new BASE64Encoder().encode(fileContent);</pre></div></li><li class="listitem">Do <em>Step</em> <em>1</em> to <em>Step</em> <em>3</em> for all the attachments that need to be uploaded and create a String array of the all the encoded data. In our case, we have only one:<div><pre class="programlisting">String[] encodedData = new String[] { base64encodedFileData };</pre></div></li><li class="listitem"><a id="id1589" class="indexterm"/><a id="id1590" class="indexterm"/><a id="id1591" class="indexterm"/>Use the <code class="literal">encodedData</code> in the <code class="literal">addBase64EncodedAttachmentsToIssue</code> method<a id="id1592" class="indexterm"/>.<div><pre class="programlisting">boolean attachmentAdded = jiraSoapService.addBase64EncodedAttachmentsToIssue(authToken, ISSUE_KEY, new String[] { "test.txt" }, encodedData);</pre></div><p>where ISSUE_KEY is the key of the issue where the files are attached and the String array (third argument) holds the names using which the attachments will be stored on issue.</p></li></ol></div><p>The <code class="literal">addAttachmentsToIssue</code> method<a id="id1593" class="indexterm"/> will also work and is similar to the one mentioned earlier, except that we don't encode the data. Instead of sending the files as a String array of encoded data, this method needs sending the files as an array of Byte arrays. Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Read the file into a Byte array as before:<div><pre class="programlisting">File file = new File(filePath);
FileInputStream fin = new FileInputStream(file);
fileContent = new byte[(int) file.length()];
fin.read(fileContent);
fin.close();</pre></div></li><li class="listitem">Create an array of these Byte arrays and add the read files into it:<div><pre class="programlisting">byte[][] files = new byte[1][];
files[0] = fileContent;</pre></div></li><li class="listitem">You can read as many files as you want and each will be read as a Byte array and will be added into files array.</li><li class="listitem">Invoke the <code class="literal">addAttachmentsToIssue</code> method:<div><pre class="programlisting">boolean attachmentAdded = jiraSoapService.addAttachmentsToIssue(authToken, ISSUE_KEY, new String[] {"test.txt" }, files);</pre></div></li></ol></div><a id="id1594" class="indexterm"/><a id="id1595" class="indexterm"/><a id="id1596" class="indexterm"/><p>Browsing the attachments on an issue can be done using the <code class="literal">getAttachmentsFromIssue</code> method. It returns an array of <code class="literal">RemoteAttachment</code> objects from which the details, such as <code class="literal">name</code>, <code class="literal">id</code>, and so on, can be retrieved. We can then construct the URL to the attachment using the information retrieved. Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Get the array of <code class="literal">RemoteAttachment</code> objects:<div><pre class="programlisting">RemoteAttachment[] attachments = jiraSoapService.getAttachmentsFromIssue(authToken, ISSUE_KEY);</pre></div><p>Here, <code class="literal">ISSUE_KEY</code> is the key of the issue we are browsing.</p></li><li class="listitem">Information about the attachment can be read from the <code class="literal">RemoteAttachment</code> object<div><pre class="programlisting">System.out.println("Attachment Name:" + remoteAttachment.getFilename() + ", Id:"+ remoteAttachment.getId());</pre></div><p>The URL of the attachment on the JIRA instance can be constructed as follows:</p><div><pre class="programlisting">System.out.println("URL: "+ BASE_URL+ "/secure/attachment/" + remoteAttachment.getId() + "/"+ remoteAttachment.getFilename());</pre></div><p>Here, <code class="literal">BASE_URL</code> is the JIRA's base URL including context path.</p></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec112"/>Worklogs and time tracking via SOAP</h1></div></div></div><p>Time tracking<a id="id1597" class="indexterm"/> in JIRA is a great feature that allows the users to track the time they spent on a particular issue. It lets the users to log the work as and when they spend time on an issue and JIRA will keep track of the original estimated time, actual time spent, and the remaining time. It also lets the users to adjust the remaining time to be spent on the issue, if needed!</p><p>While JIRA has a great user interface to let users log the work they are doing there at times, like when integrating with the third-party products, it is necessary to log the work using SOAP. In this recipe, we will see logging work using the SOAP API.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec311"/>Getting ready...</h2></div></div></div><a id="id1598" class="indexterm"/><a id="id1599" class="indexterm"/><p>As shown in the previous recipes, create a JIRA SOAP client. Also, make sure that time tracking is enabled on the JIRA instance.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec312"/>How to do it...</h2></div></div></div><a id="id1600" class="indexterm"/><p>There are different methods available to log work on an issue depending on what we need to with the remaining estimate on the issue. In all the cases, we need to create a <code class="literal">RemoteWorklog</code> object<a id="id1601" class="indexterm"/> that holds the details of the work we are logging. The following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the <code class="literal">RemoteWorklog</code> object with the details as required:<div><pre class="programlisting">RemoteWorklog worklog = new RemoteWorklog();
worklog.setTimeSpent("1d 3h");
worklog.setComment("Some comment!");
worklog.setGroupLevel("jira-users");
worklog.setStartDate(new GregorianCalendar(2011, Calendar.MAY, 10));</pre></div><p>Note that the <code class="literal">setStartDate()</code> method<a id="id1602" class="indexterm"/> takes a <code class="literal">Calendar</code> object<a id="id1603" class="indexterm"/> as opposed to the <code class="literal">Date</code> object<a id="id1604" class="indexterm"/> mentioned in the Javadocs.</p></li><li class="listitem">Use the appropriate method to add the previous worklog. For example, if you want to automatically adjust the remaining estimate on the issue, we can use the <code class="literal">addWorklogAndAutoAdjustRemainingEstimatenethod</code>:<div><pre class="programlisting">RemoteWorklog work = jiraSoapService.addWorklogAndAutoAdjustRemainingEstimate(authToken, ISSUE_KEY, worklog);System.out.println("Added work:" + work.getId());</pre></div></li><li class="listitem">If you want to retain the remaining estimate, use <code class="literal">addWorklogAndRetainRemainingEstimate</code>:<div><pre class="programlisting">RemoteWorklog work = jiraSoapService.addWorklogAndRetainRemainingEstimate(authToken, ISSUE_KEY, worklog);</pre></div></li><li class="listitem">If you want to add a new remaining estimate, use <code class="literal">addWorklogWithNewRemainingEstimate</code>.<div><pre class="programlisting">RemoteWorklog work = jiraSoapService.addWorklogWithNewRemainingEstimate(authToken, ISSUE_KEY, worklog, "1d");</pre></div></li><li class="listitem">This will add the work done as <code class="literal">1d</code> <code class="literal">3h</code> and will reset the remaining estimate to <code class="literal">1d</code> (1 day) no matter how much the original estimate was.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec313"/>How it works...</h2></div></div></div><a id="id1605" class="indexterm"/><a id="id1606" class="indexterm"/><p>In the first step, we used the setter methods to populate the fields. As you might have guessed, the most important field is <code class="literal">timeSpent</code> which specifies a time duration in JIRA duration format, representing the time spent working on the worklog. In our example, we have used <code class="literal">1d 3h</code> which is translated to 1 day and 3 hours.</p><a id="id1607" class="indexterm"/><p>As in the previous code, we can also specify a <code class="literal">startDate</code> for the logged work, <code class="literal">groupLevel,</code> or <code class="literal">roleId</code>, which are used to restrict the visibility of the logged work and add a comment. Note that the ID shouldn't be set on the object as it will be automatically generated when the worklog is added on the issue. Also, the visibility can be set only for a group or for a role, not for both.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec314"/>There's more...</h2></div></div></div><p>Updating and deleting worklogs works in the same way using the following methods:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a id="id1608" class="indexterm"/><code class="literal">updateWorklogAndAutoAdjustRemainingEstimate</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">updateWorklogAndRetainRemainingEstimate</code><a id="id1609" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">updateWorklogWithNewRemainingEstimate</code><a id="id1610" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">deleteWorklogAndAutoAdjustRemainingEstimate</code><a id="id1611" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">deleteWorklogAndRetainRemainingEstimate</code><a id="id1612" class="indexterm"/></li><li class="listitem" style="list-style-type: disc"><code class="literal">updateWorklogWithNewRemainingEstimate</code><a id="id1613" class="indexterm"/></li></ul></div><p>The following is an example for an update and a delete call:</p><div><pre class="programlisting">jiraSoapService.updateWorklogWithNewRemainingEstimate(authToken, work, "1d");
jiraSoapService.deleteWorklogAndRetainRemainingEstimate(authToken, work.getId());</pre></div><p>All the existing worklogs on an issue can be browsed using <code class="literal">getWorklogs</code> method<a id="id1614" class="indexterm"/> that returns an array of <code class="literal">RemoteWorklog</code> objects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec113"/>Commenting on an issue via SOAP</h1></div></div></div><a id="id1615" class="indexterm"/><a id="id1616" class="indexterm"/><a id="id1617" class="indexterm"/><p>In this recipe, we will see how to manage comments on an issue.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec315"/>Getting ready</h2></div></div></div><p>Create a JIRA SOAP client as mentioned in the first recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec316"/>How to do it...</h2></div></div></div><p>Adding a comment on an issue using SOAP can be done as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">RemoteCommentobject</code> and set the necessary fields using the setter methods.<div><pre class="programlisting">final RemoteComment comment = new RemoteComment();
comment.setBody(COMMENT_BODY);
//comment.setRoleLevel(ROLE_LEVEL); // Id of your project role
comment.setGroupLevel(null); // Make it visible to all</pre></div><p>Note that the ID shouldn't be set on the object as it will be generated automatically when the comment is created on the issue. Also, the visibility can be set only for a group or for a role, not for both at the same time.</p></li><li class="listitem">Add the comment to the issue:<div><pre class="programlisting">jiraSoapService.addComment(authToken, ISSUE_KEY, comment);</pre></div><p>Comments on an issue can be retrieved using the <code class="literal">getComments</code> method<a id="id1618" class="indexterm"/>, which returns an array of <code class="literal">RemoteComment</code> objects.</p><div><pre class="programlisting">RemoteComment[] comments = jiraSoapService.getComments(authToken, ISSUE_KEY);
for (RemoteCommentremoteComment : comments) {
  System.out.println("Comment:" + remoteComment.getBody() + " written by " + remoteComment.getAuthor());
}</pre></div></li></ol></div><p>A comment can be edited using the <code class="literal">editComment</code> operation but we should check if we have the edit permission or not by using the <code class="literal">hasPermissionToEditComment</code> method<a id="id1619" class="indexterm"/> as shown next:</p><div><pre class="programlisting">// Check permissions first
if (jiraSoapService.hasPermissionToEditComment(authToken, comment)) {
  comment.setBody(COMMENT_BODY + " Updated");
  comment.setGroupLevel("jira-users"); 
  jiraSoapService<code class="literal">.editComment(authToken, comment);</code>
}</pre></div><p>Deleting a comment is not exposed via SOAP yet!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec114"/>User and group management via SOAP</h1></div></div></div><p>Let us now have a look at the user and group management using SOAP. This is really useful when the users and groups need to be managed from a third-party application.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec317"/>Getting ready</h2></div></div></div><p>Create a SOAP client as mentioned in the previous recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec318"/>How to do it...</h2></div></div></div><a id="id1620" class="indexterm"/><a id="id1621" class="indexterm"/><a id="id1622" class="indexterm"/><a id="id1623" class="indexterm"/><p>Creating a group and user are pretty straightforward. The following is how we do it once the client is created:</p><div><pre class="programlisting">//Create group jtricks-test-group
RemoteGroup group = jiraSoapService.createGroup(authToken, "jtricks-test-group", null);
//Create user jtricks-test-user
RemoteUser user = jiraSoapService.createUser(authToken, "jtricks-test-user", "password", "Test User", "support@j-tricks.com");</pre></div><p>Here, the first snippet creates a group with name <code class="literal">jtricks-test-group</code>. The third argument is a <code class="literal">RemoteUser</code> who can be added to the group as the first user when the group is created. We can leave it as null if the group has to be created empty.</p><p>The second snippet creates a user with the relevant details, such as <code class="literal">Name</code>, <code class="literal">Password</code>, <code class="literal">Full</code> <code class="literal">Name</code>, and <code class="literal">Email</code>.</p><p>A user can be added to a group as follows:</p><div><pre class="programlisting">jiraSoapService.addUserToGroup(authToken, group, user);</pre></div><p>Here, group and user are <code class="literal">RemoteGroup</code> and <code class="literal">RemoteUser</code> objects respectively.</p><p>An existing user or group can be retrieved as follows:</p><div><pre class="programlisting">RemoteUser user = jiraSoapService.getUser(authToken, "jtricks-test-user");
RemoteGroup group = jiraSoapService.getGroup(authToken, "jtricks-test-group");</pre></div><p>The users in a group can be retrieved from the <code class="literal">RemoteGroup</code> object as shown next:</p><div><pre class="programlisting">RemoteUser[] users = group.getUsers();
for (RemoteUser remoteUser : users) {
  System.out.println("Full Name:"+remoteUser.getFullname());
}</pre></div><p>Deleting a user or group is also straightforward as shown next:</p><div><pre class="programlisting">//Delete User.
jiraSoapService.deleteUser(authToken, user1.getName());
//Delete Group. 
jiraSoapService.deleteGroup(authToken, group1.getName(), group.getName());</pre></div><a id="id1624" class="indexterm"/><a id="id1625" class="indexterm"/><a id="id1626" class="indexterm"/><a id="id1627" class="indexterm"/><p>Here, <code class="literal">swapGroup</code> identifies the group to change the comment and work log visibility to.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec115"/>Progressing an issue in workflow using SOAP</h1></div></div></div><a id="id1628" class="indexterm"/><a id="id1629" class="indexterm"/><a id="id1630" class="indexterm"/><p>This is something everyone wants to do when JIRA is integrated with third-party applications. The status of an issue needs to be changed for various use cases and the right way to do this is to progress the issue through its workflow.</p><p>Progressing will move the issue to the appropriate statuses and will fire the appropriate post functions and events. In this recipe, we will see how to do the same.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec319"/>Getting ready</h2></div></div></div><p>As usual, create a SOAP client if you have not already done so.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec320"/>How to do it...</h2></div></div></div><p>JIRA exposes the method, <code class="literal">progressWorkflowAction</code> to progress an issue through its workflow. The following are the steps to do it:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the ID of the action that we should execute from the current state. For every issue status, there is a step associated with it and there are zero or more transitions to the other steps in the workflow.<p>The action ID can be identified from the workflow screen within brackets alongside the transition name, as shown in the following screenshot:</p><a id="id1631" class="indexterm"/><a id="id1632" class="indexterm"/><a id="id1633" class="indexterm"/><div><img src="img/1803-09-04.jpg" alt="How to do it..."/></div><p>The previous screenshot shows the JIRA default workflow and the action ID for <strong>Resolve</strong> <strong>Issue</strong> from <strong>Open</strong> status is <strong>5</strong>. Note that the same action from different states can have a different ID if they are not sharing the common actions. So, it is important that we identify the action ID before proceeding to <em>Step</em> <em>2</em>.</p><p>You might have to store these action IDs on the client side when implementing a full-fledged application as JIRA doesn't expose a method to retrieve action ID based on the current <em>state</em>.</p><p>The ID can also be retrieved from the XML by looking up the <code class="literal">action</code> element:</p><div><pre class="programlisting">&lt;action id="5" name="Resolve Issue" view="resolveissue"&gt;</pre></div><p>A workflow can be exported to XML from the <strong>Administration</strong> | <strong>Workflows</strong> screen by clicking on the XML link.</p></li><li class="listitem">Identify the set of fields that need to be modified during the transition and create a <code class="literal">RemoteFieldValue</code> object for each of them. You can only modify those fields that are available on the workflow transition.<p>In our example, we use the JIRA default workflow's <strong>Resolve</strong> <strong>Issue</strong> action and it has the <strong>Resolve</strong> <strong>Screen</strong> associated with it. We have the fields <strong>Assignee</strong> and <strong>Resolution</strong> on the screen and hence we can create the <code class="literal">RemoteFieldValue</code> objects for them as follows:</p><div><pre class="programlisting">RemoteFieldValue field1 = new RemoteFieldValue("resolution", new String[] { "3" });
RemoteFieldValue field2 = new RemoteFieldValue("assignee", new String[] { "jobinkk" });</pre></div><p>The <code class="literal">RemoteFieldValue</code> takes the ID and an array of String values representing the value we need to set. In our example, the fields are single value fields and hence the array has only a single element. Multidimensional fields such as cascade fields should have the fully qualified ID as we have seen earlier in this chapter while updating custom fields. The full list of standard field IDs can be found at the <code class="literal">IssueFieldConstants</code> class. Any fields that are not in the transition screen will be ignored.</p></li><li class="listitem"><a id="id1634" class="indexterm"/><a id="id1635" class="indexterm"/><a id="id1636" class="indexterm"/>Execute the <code class="literal">progressWorkflowAction</code> using these attributes.<div><pre class="programlisting">RemoteIssue updatedtissue = jiraSoapService.progressWorkflowAction(authToken, ISSUE_KEY, "5", new RemoteFieldValue[] { field1, field2 });</pre></div><p>Before we wind up this recipe, the current status on an issue can be found from the <code class="literal">RemoteIssue</code> object using the <code class="literal">getStatus</code> method<a id="id1637" class="indexterm"/>.</p><div><pre class="programlisting">System.out.println("Progressed "+updatedtissue.getKey()+ " to " + updatedtissue.getStatus() + " status!");</pre></div></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec116"/>Managing versions via SOAP</h1></div></div></div><p>We have seen how to add versions as a fix for versions or affected versions on an issue. But how do we create those versions using SOAP? In this recipe, we will see how to create versions in a project and manage them!</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec321"/>Getting ready</h2></div></div></div><p>As usual, create the SOAP client.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec322"/>How to do it...</h2></div></div></div><a id="id1638" class="indexterm"/><a id="id1639" class="indexterm"/><a id="id1640" class="indexterm"/><p>A new version can be added into a project as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a <code class="literal">RemoteVersion</code> object with the necessary details:<div><pre class="programlisting">RemoteVersion remoteVersion = new RemoteVersion();
remoteVersion.setName("Test Release");
remoteVersion.setReleaseDate(new GregorianCalendar(2011, Calendar.MAY, 10));
remoteVersion.setSequence(5L);</pre></div><p>Here, the <code class="literal">sequence</code> defines the order in which the version will appear in the version list.</p></li><li class="listitem"><a id="id1641" class="indexterm"/><a id="id1642" class="indexterm"/><a id="id1643" class="indexterm"/>Create the version using <code class="literal">addVersion</code> method<a id="id1644" class="indexterm"/>:<div><pre class="programlisting">RemoteVersion createdVersion = jiraSoapService.addVersion(authToken, "TST", remoteVersion);
System.out.println("Created version with id:"+createdVersion.getId());</pre></div><p>where <code class="literal">TST</code> is the project key in which the new version is created.</p></li></ol></div><p>Once a version is created, you can release the version using <code class="literal">releaseVersion</code> method<a id="id1645" class="indexterm"/>. It takes a <code class="literal">RemoteVersion</code> as an input and needs the released flag to be set on it.</p><div><pre class="programlisting">createdVersion.setReleased(true);
jiraSoapService.releaseVersion(authToken, "TST", createdVersion);</pre></div><p>The same method can be used to <code class="literal">unrelease</code> a version. All you need to do is to set the <code class="literal">released</code> flag to <code class="literal">false</code>!</p><p>If the <code class="literal">released</code> flag is set to <code class="literal">true</code> and the version is already released, an error is thrown. This is the same case while trying to <code class="literal">unrelease</code> a version that is not yet released.</p><p>Archiving a version works similar to releasing a version. Here, the archived flag is passed as an argument instead of setting the released flag. Also, here the version name is used instead of a <code class="literal">RemoteVersion</code> object.</p><div><pre class="programlisting">// Archives version with name "Test release" in project with key JRA
jiraSoapService.archiveVersion(authToken, "JRA", "Test Release", true);</pre></div><p>All the versions in a project can be retrieved using the <code class="literal">getVersions</code> method, which returns an array of <code class="literal">RemoteVersion</code> objects.</p><div><pre class="programlisting">RemoteVersion[] versions = jiraSoapService.getVersions(authToken, "JRA");</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec117"/>Administration methods in SOAP API</h1></div></div></div><p>Before we wind up the various useful methods in SOAP API, we can have a look at the administration methods. In this recipe, we will be concentrating on some methods revolving around the creation of projects and permissions. Remaining methods are an easy read once you have a fair idea on the ones we are discussing in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec323"/>Getting ready</h2></div></div></div><a id="id1646" class="indexterm"/><a id="id1647" class="indexterm"/><p>Create the SOAP client as we discussed in the previous recipes.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec324"/>How to do it...</h2></div></div></div><p>We can have a look at the journey of creating a permission scheme, creating a project using it and adding some users into the project roles. Other schemes used during creation of the project like notification scheme and issue security scheme are not supported via SOAP.</p><p>Following are the steps for our journey:</p><div><ol class="orderedlist arabic"><li class="listitem"><a id="id1648" class="indexterm"/><a id="id1649" class="indexterm"/>Create the new Permission scheme:<div><pre class="programlisting">RemotePermissionScheme permScheme = jiraSoapService.createPermissionScheme(authToken, "Test P Scheme", "Test P Description");</pre></div><p>Here, we use the <code class="literal">createPermissionScheme</code> method<a id="id1650" class="indexterm"/> to create a new permission scheme by passing the authentication token, a name, and a description. Note that we can instead get an existing permission scheme from the list retrieved using the <code class="literal">getPermissionSchemes</code> method<a id="id1651" class="indexterm"/>.</p></li><li class="listitem">Add relevant permissions to the newly created permission scheme using the <code class="literal">addPermissionTo</code> method<a id="id1652" class="indexterm"/>. This step is relevant only if we are creating a new permission scheme:<div><pre class="programlisting">RemotePermissionScheme modifiedPermScheme = jiraSoapService.addPermissionTo(authToken, permScheme, adminPermission, user);</pre></div><p>Here, <code class="literal">adminPermission</code> should be a <code class="literal">RemotePermission</code> which is in the list of <code class="literal">RemotePermission</code> objects retrieved using <code class="literal">getAllPermissions</code> method. For example, the <strong>Administer</strong> <strong>Project</strong> permission can be obtained as follows:</p><div><pre class="programlisting">RemotePermission[] permissions = jiraSoapService.getAllPermissions(authToken);
RemotePermission adminPermission = null;
for (RemotePermission remotePermission : permissions) {
  if (remotePermission.getPermission().equals(23L)) {
    adminPermission = remotePermission;
    break;
  }
}</pre></div><p>Here, <code class="literal">23L</code> is the ID of the <strong>Administer</strong> <strong>Project</strong> permission. The IDs of other permissions can be found at <code class="literal">com.atlassian.jira.security.Permissions</code> class.</p><p>The final argument to <code class="literal">addPermissionTo</code> method is a <code class="literal">RemoteEntity</code>, which can be a <code class="literal">RemoteUser</code> or a <code class="literal">RemoteGroup</code> object. We have seen accessing users and groups via SOAP in the previous recipes. In our example, we get a user by name as follows:</p><div><pre class="programlisting">RemoteUser user = jiraSoapService.getUser(authToken, "jobinkk");</pre></div></li><li class="listitem">Create the project using <code class="literal">createProject</code> method:<div><pre class="programlisting">RemoteProject project = jiraSoapService.createProject(authToken, "TEST", "Test Name", "Test Description", "http://www.j-tricks.com", "jobinkk", permScheme, null, null);</pre></div><p>The following are the arguments:</p><p><strong>token - Authentication Token</strong></p><p><strong>key - Project Key</strong></p><p><strong>name - Project Name</strong></p><p><strong>description - Project Description</strong></p><p><strong>url - URL of the project</strong></p><p><strong>lead - Project Lead</strong></p><p><strong>permissionScheme - Permission Scheme for the project of type RemotePermissionScheme</strong></p><p><strong>notificationScheme - Notification Scheme for the project of type RemoteScheme</strong></p><p><strong>issueSecurityScheme - Issue Security Scheme for the project of type RemoteScheme</strong></p><a id="id1653" class="indexterm"/><a id="id1654" class="indexterm"/><p>For the schemes, we use the newly created permissions schemes and leave the other two as null. We can specify a specific notification scheme or issue security scheme with a <code class="literal">RemoteScheme</code> object created by populating the correct ID of the relevant schemes.</p></li><li class="listitem">Add an actor to the newly created Project:<div><pre class="programlisting">jiraSoapService.addActorsToProjectRole(authToken, new String[] { "jobinkk" }, adminRole, project,	"atlassian-user-role-actor");</pre></div><p>Here, the <code class="literal">addActorsToProjectRole</code> method takes an array of actors (only <code class="literal">jobinkk</code> in this case), the role to which the actor should be added, project we have created, and the type of the actor.</p><p>The project role can be retrieved using the role ID as shown :</p><div><pre class="programlisting">RemoteProjectRoleadminRole = jiraSoapService.getProjectRole(authToken, 10020L);</pre></div><p>The actor type can either be <code class="literal">atlassian-user-role-actor</code> or <code class="literal">atlassian-group-role-actor</code> depending on whether the actor we have added in the array is a user or a group.</p></li></ol></div><p>We should now have the project created with the new permission scheme and with the member(s) we added to the relevant roles.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec325"/>How it works...</h2></div></div></div><a id="id1655" class="indexterm"/><a id="id1656" class="indexterm"/><p>Once the method is executed, we can find the project created as follows:</p><div><img src="img/1803-09-05.jpg" alt="How it works..."/></div><p>The new permission scheme is created as shown in the following screenshot:</p><div><img src="img/1803-09-06.jpg" alt="How it works..."/></div><a id="id1657" class="indexterm"/><a id="id1658" class="indexterm"/><p>Here only one permission is added, that is to administer the project. We can add the rest in a similar fashion.</p><p>Similarly, the project members are added as shown in the following screenshot:</p><div><img src="img/1803-09-07.jpg" alt="How it works..."/></div><p>As you can see, the default actors will be part of the membership in addition to the one we have added!</p><p>There are lot of other useful methods in the SOAP API which can be found at: <a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html">http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html</a>.</p><p>Make sure you look at the right Java Docs for your version of JIRA!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec118"/>Deploy a SOAP service in JIRA</h1></div></div></div><p>So far we have seen various methods to perform various operations in JIRA via SOAP. But what about operations that are not supported by SOAP? That little something which prevents you from integrating your JIRA with your third-party app? Here is where the <strong>RPC</strong> <strong>Endpoint</strong> <strong>Plugin</strong> <strong>Module</strong><a id="id1659" class="indexterm"/> is useful.</p><p>The RPC End Point Plugin module lets us deploy new SOAP and XML-RPC end points within JIRA. The new end points added will not be a part of the existing WSDL. Instead, they are available on a new URL and hence you will have to access both the web services if you want to access the new methods and other existing methods.</p><p>In this recipe, we will see how to deploy a new SOAP end point to perform a new operation.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec326"/>Getting ready</h2></div></div></div><a id="id1660" class="indexterm"/><a id="id1661" class="indexterm"/><p>Create a skeleton plugin using Atlassian Plugin SDK. As I write this, PRC plugin is still v1, so make sure to create a v1 plugin if <a class="ulink" href="https://jira.atlassian.com/browse/JRA-22596">https://jira.atlassian.com/browse/JRA-22596</a> isn't resolved yet!</p><p>Also, make sure <strong>Accept</strong> <strong>Remote</strong> <strong>API</strong> <strong>Calls</strong> option is turned on under <strong>Administration</strong> | <strong>General</strong> <strong>Configurations</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec327"/>How to do it...</h2></div></div></div><p>Let us create a SOAP RPC plugin to expose a new method, <code class="literal">getProjectCategories</code>, that retrieves all the project categories in the JIRA instance This is a simple method but will hopefully help us in covering all the basics of creating a new SOAP RPC end point.</p><div><ol class="orderedlist arabic"><li class="listitem">Add the RPC plugin dependency in the <code class="literal">pom.xml</code> to get hold of the existing RPC classes. Change the version accordingly.<div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;atlassian-jira-rpc-plugin&lt;/groupId&gt;
  &lt;artifactId&gt;atlassian-jira-rpc-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.13-1&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p>This JAR is a part of the JIRA installation. So, if your maven build fails looking for the JAR, just navigate to <code class="literal">WEB-INF/lib</code> folder and install the JAR into your local maven repository as follows:</p><div><pre class="programlisting">mvn install:install-file -DgroupId=atlassian-jira-rpc-plugin -DartifactId=atlassian-jira-rpc-plugin -Dversion=3.13-1 -Dpackaging=jar -Dfile=atlassian-jira-rpc-plugin-3.13-1.jar</pre></div></li><li class="listitem">Declare the new RPC service in the <code class="literal">atlassian-plugin.xml</code>.<div><pre class="programlisting">&lt;rpc-soap key="jtricks-soap-service" name="JTricks SOAP Service" class="com.jtricks.JTricksSoapServiceImpl"&gt;
  &lt;description&gt;JTricks SOAP service.&lt;/description&gt;
  &lt;service-path&gt;jtricksservice&lt;/service-path&gt;
  &lt;published-interface&gt;com.jtricks.JTricksSoapService&lt;/published-interface&gt;
&lt;/rpc-soap&gt;</pre></div><p>Here, the SOAP RPC plugin module has a unique <code class="literal">key</code> and it declares a new <code class="literal">interface</code> for your SOAP module and an implementation <code class="literal">class</code> for it. In this case, we have <code class="literal">JTricksSoapService</code> and <code class="literal">JTricksSoapServiceImpl</code>. The service path <code class="literal">jtricksservice</code> defines where in the URL namespace the services will be published and will appear in the URL of the WSDL.</p></li><li class="listitem">Create a <strong>Component</strong> <strong>Plugins</strong> module<a id="id1662" class="indexterm"/> for this new class to avoid the client getting a null pointer exception:<div><pre class="programlisting">&lt;component key="jtricks-soap-component" name="JTricks SOAP Component" class="com.jtricks.JTricksSoapServiceImpl"&gt;
  &lt;interface&gt;com.jtricks.JTricksSoapService&lt;/interface&gt;
&lt;/component&gt;</pre></div></li><li class="listitem"><a id="id1663" class="indexterm"/><a id="id1664" class="indexterm"/>Declare the new method in the interface as shown:<div><pre class="programlisting">public interface JTricksSoapService {
  String login(String username, String password);   
  // Method to return Project Categories
  RemoteCategory[] getProjectCategories(String token) throws RemoteException;
}</pre></div><p>As you can see we have added a method <code class="literal">getProjectCategories</code> that returns an array of <code class="literal">RemoteCategory</code> objects. We have added a login method as well so that we can test this by accessing just the new WSDL.</p></li><li class="listitem">Create the <code class="literal">RemoteCategory</code> bean. Make sure the new bean extends <code class="literal">AbstractNamedRemoteEntity</code> class. The bean should have all the required attributes with getters and setters defined for it. <code class="literal">AbstractNamedRemoteEntity</code> already exposes the field name and hence will be available for <code class="literal">RemoteCategory</code>. We will add a new field <code class="literal">description</code>.<div><pre class="programlisting">public class RemoteCategory extends AbstractNamedRemoteEntity {
  private String description;
  public RemoteCategory(GenericValue value) {
    super(value);
    this.description = value.getString("description");
  }
  
  public void setDescription(String description) {
    this.description = description;
  }
  
  public String getDescription() {
    return description;
  }
}</pre></div><p>As you can see, the constructor takes a <code class="literal">GenericValue</code> and sets the description from it. In the super class, <code class="literal">AbstractNamedRemoteEntity</code>, name is set likewise.</p></li><li class="listitem"><a id="id1665" class="indexterm"/><a id="id1666" class="indexterm"/>Implement the <code class="literal">getProjectCategories</code> method in the implementation class:<div><pre class="programlisting">public RemoteCategory[] getProjectCategories(String token) throws RemoteException {
  validateToken(token);

  Collection&lt;GenericValue&gt; categories = projectManager.getProjectCategories();
  RemoteCategory[] remoteCategories = new RemoteCategory[categories.size()];

  int i = 0;
  for (GenericValue category : categories) {
    remoteCategories[i++] = new RemoteCategory(category);
  }
  return remoteCategories;
}</pre></div><p>Here, all we do is to get the collection of project categories and return an array of <code class="literal">RemoteCategory</code> objects initialized using the category <code class="literal">GenericValue</code> objects. Note that the <code class="literal">getProjectCategories()</code> method is deprecated from JIRA 4.4 and it is advised to use <code class="literal">getAllProjectCategories()</code> method that returns a Collection of <code class="literal">ProjectCategory</code> objects instead of the <code class="literal">GenericValue</code>.</p><p>If you have noticed, we validate the <em>token</em> first before returning the categories. The validation is done as follows:</p><div><pre class="programlisting">private void validateToken(String token) {
  try {
    User user = tokenManager.retrieveUser(token);
  } catch (RemoteAuthenticationException e) {
    throw new RuntimeException("Error Authenticating!,"+e.toString());
  } catch (RemotePermissionException e) {
  throw new RuntimeException("User does not have permission for this operation,"+e.toString());
}
}</pre></div><p>We retrieve the user using the token and throws the appropriate error if the token is not valid. The <code class="literal">ProjectManager</code> and <code class="literal">TokenManager</code> classes can be injected in the constructor as shown:</p><div><pre class="programlisting">public JTricksSoapServiceImpl(ProjectManagerprojectManager, TokenManagertokenManager) {
  this.projectManager = projectManager;
  this.tokenManager = tokenManager;
}</pre></div><p>Note that from JIRA 4.4, <code class="literal">retrieveUserNoPermissioncheck</code> method should be used instead of <code class="literal">retrieveUser</code> as some JIRA instances may want to allow anonymous access. Individual methods will do the permission checks.</p></li><li class="listitem">Implement the <code class="literal">login</code> method to return the token.<div><pre class="programlisting">public String login(String username, String password) {
  try {
    return tokenManager.login(username, password);
  } catch (RemoteAuthenticationException e) {
    throw new RuntimeException("Error Authenticating!,"+e.toString());
  } catch (com.atlassian.jira.rpc.exception.RemoteException e) {
    throw new RuntimeException("Couldn't login,"+e.toString());
  }
}</pre></div><p>It simply uses <code class="literal">TokenManager</code> to return a <em>token</em> created from the username and password.</p><a id="id1667" class="indexterm"/><a id="id1668" class="indexterm"/><p>Compile the plugin and deploy it. As it is v1, make sure the plugin is dropped into the <code class="literal">WEB-INF/lib</code> folder.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec328"/>How it works...</h2></div></div></div><p>Once the plugin is deployed, the new WSDL should be available at: <code class="literal">{your_jira_url}/rpc/soap/jtricksservice?WSDL</code>.</p><div><img src="img/1803-09-08.jpg" alt="How it works..."/></div><a id="id1669" class="indexterm"/><a id="id1670" class="indexterm"/><p>As you can see, the new methods that we exposed via the interface are now visible in the WSDL file at the circled locations in the previous screenshot.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec119"/>Deploy a XML-RPC service within JIRA</h1></div></div></div><a id="id1671" class="indexterm"/><a id="id1672" class="indexterm"/><p>In the previous recipe, we have seen how to deploy a SOAP service within JIRA. In this one, we will see how to deploy a XML-RPC service.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec329"/>Getting ready</h2></div></div></div><a id="id1673" class="indexterm"/><a id="id1674" class="indexterm"/><p>Create a skeleton plugin using Atlassian Plugin SDK. Here again, we are developing a v1 plugin. So, make sure the <code class="literal">atlassian-plugin.xml</code> doesn't have the Version 2 attribute in it.</p><p>And yes, make sure <strong>Accept</strong> <strong>Remote</strong> <strong>API</strong> <strong>Calls</strong> option is turned <strong>ON</strong>, as in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec330"/>How to do it...</h2></div></div></div><p>As in the case of SOAP plugin, let us expose a new method, <code class="literal">getProjectCategories</code>, that retrieves all the project categories in the project. The following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the RPC plugin dependency in the <code class="literal">pom.xml</code> to get hold of the existing RPC classes. Change the version accordingly:<div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;atlassian-jira-rpc-plugin&lt;/groupId&gt;
  &lt;artifactId&gt;atlassian-jira-rpc-plugin&lt;/artifactId&gt;
  &lt;version&gt;3.13-1&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div></li><li class="listitem">Declare the new RPC service in the <code class="literal">atlassian-plugin.xml</code>:<div><pre class="programlisting">&lt;rpc-xmlrpc key="xmlrpc" name="JTricks XML-RPC Services" class="com.jtricks.XmlRpcServiceImpl"&gt;
  &lt;description&gt;The JTricks sample XML-RPC services.&lt;/description&gt;&lt;service-path&gt;jtricks&lt;/service-path&gt;
&lt;/rpc-xmlrpc&gt;</pre></div><p>Here, we define a class, <code class="literal">XmlRpcServiceImpl</code> and a <code class="literal">service-path</code>. The service path, jtricks, is used to access the new methods in place of the default <code class="literal">jira1</code> path used in accessing the existing methods.</p></li><li class="listitem">Create an interface for the class, with <code class="literal">XmlRpcServiceImpl</code> named as <code class="literal">XmlRpcService</code> and define the new methods in it.<div><pre class="programlisting">public interface XmlRpcService {	
  String login(String username, String password) throws Exception;    
  Vector getprojectCategories(String token);
}</pre></div><p>As before, we have a <code class="literal">login</code> method as well. If you have noticed, the return type of the <code class="literal">getprojectCategories</code> method is a <code class="literal">Vector</code> instead of an array of <code class="literal">RemoteCategory</code> objects.</p><p>All the methods in the RPC interface should return a <code class="literal">Vector</code> if it is returning a list of objects and a <code class="literal">HashTable</code> if it is returning a single object (<code class="literal">GenericValue</code>). The Vector will be made of one or more <code class="literal">Hashtables</code> each representing a <code class="literal">GenericValue</code> in the list.</p></li><li class="listitem">Define the <code class="literal">RemoteCategory</code> as defined in the previous recipe. We will create a <code class="literal">Vector</code> from an array of <code class="literal">RemoteCategory</code> objects to return the project category details:<div><pre class="programlisting">public class RemoteCategory extends AbstractNamedRemoteEntity {
  private String description;

  public RemoteCategory(GenericValue value) {
    super(value);
    this.description = value.getString("description");
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public String getDescription() {
    return description;
  }
}</pre></div></li><li class="listitem"><a id="id1675" class="indexterm"/><a id="id1676" class="indexterm"/>Implement the <code class="literal">XmlRpcServiceImpl</code> class<a id="id1677" class="indexterm"/>. The <code class="literal">getprojectCategories</code> method<a id="id1678" class="indexterm"/> is implemented as follows:<div><pre class="programlisting">public Vector getprojectCategories(String token) {
  validateToken(token);

Collection&lt;GenericValue&gt; categories = projectManager.getProjectCategories();
  RemoteCategory[] remoteCategories = new RemoteCategory[categories.size()];

  int i = 0;
  for (GenericValue category : categories) {
    remoteCategories[i++] = new RemoteCategory(category);
  }
  return RpcUtils.makeVector(remoteCategories);
}</pre></div><p>Here we create an array of <code class="literal">RemoteCategory</code> objects and then create a Vector from it using the <code class="literal">RpcUtils</code> utility class. The class, behind the scenes, converts the array of <code class="literal">RemoteCategory</code> objects into a Vector of <code class="literal">Hashtables</code>, each <code class="literal">Hashtable</code> representing a <code class="literal">RemoteCategory</code>.</p><p>If we want to return a single <code class="literal">RemoteCategory</code> object instead of an array, we should return it as a <code class="literal">Hashtable</code> constructed as follows:</p><div><pre class="programlisting">RpcUtils.makeStruct(remoteCategory);</pre></div><p>As mentioned earlier, use the <code class="literal">getAllProjectCategories</code> method<a id="id1679" class="indexterm"/> from JIRA4.4. Implement the <code class="literal">login</code> and <code class="literal">validateToken</code> methods, as discussed in the previous recipe.</p></li><li class="listitem">Compile the plugin and deploy it. As it is v1, make sure the plugin is dropped into the <code class="literal">WEB-INF/lib</code> folder.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec331"/>How it works...</h2></div></div></div><a id="id1680" class="indexterm"/><a id="id1681" class="indexterm"/><p>Once the plugin is deployed, the new methods can be accessed using the new service path as <code class="literal">jtricks.getprojectCategories</code>. More details about how to access an XML-RPC method can be found in the next recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec332"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing a Java XML-RPC client</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec120"/>Writing a Java XML-RPC client</h1></div></div></div><p>In the previous recipes, we saw how to create a SOAP client and use it to connect to JIRA from an external third-party application. We have also seen ways of exposing new methods in JIRA through SOAP and XML-RPC interfaces. In this recipe, we will see how to invoke an XML-RPC method from a client application written in Java.</p><p>The Javadocs for <a id="id1682" class="indexterm"/>XML-RPC client can be found at: <a class="ulink" href="http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/xmlrpc/XmlRpcService.html">http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/xmlrpc/XmlRpcService.html</a>.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec333"/>Getting ready</h2></div></div></div><a id="id1683" class="indexterm"/><a id="id1684" class="indexterm"/><p>Make sure <strong>Accept</strong> <strong>Remote</strong> <strong>API</strong> <strong>Calls</strong> option is turned <strong>ON</strong> in JIRA under <strong>Administration</strong> <strong>|</strong> <strong>Global</strong> <strong>Settings</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec334"/>How to do it...</h2></div></div></div><p>Let us try to retrieve the list of projects using XML-RPC service deployed within JIRA. Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a Maven2 project and add the dependency for <code class="literal">Apache2 xml-rpc</code> libraries.<div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;xmlrpc&lt;/groupId&gt;
  &lt;artifactId&gt;xmlrpc&lt;/artifactId&gt;
  &lt;version&gt;1.1&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p>Note that the version of <code class="literal">xml-rpc</code> libraries we have used in this recipe is Version 1.1.</p></li><li class="listitem">Create a Java client. In this example, we will create a standalone Java class with all the libraries in the <code class="literal">classpath</code>.</li><li class="listitem">Instantiate the <code class="literal">XmlRpcClient</code> object:<div><pre class="programlisting">XmlRpcClientrpcClient = new XmlRpcClient(JIRA_URI + RPC_PATH);</pre></div><p>Here, the <code class="literal">JIRA_URI</code> is the URI of your JIRA instance, <a class="ulink" href="http://jira.atlassian.com">http://jira.atlassian.com</a>, for example, <code class="literal">RPC_PATH</code> will be <code class="literal">/rpc/xmlrpc</code>, which will be the same even for new methods exposed via plugins. In this case, the full path will be: <a class="ulink" href="http://jira.atlassian.com/rpc/xmlrpc">http://jira.atlassian.com/rpc/xmlrpc</a>.</p><p>Note that we are using XML-RPC v2 here. Check out the syntax for the version you are using!</p></li><li class="listitem"><a id="id1685" class="indexterm"/><a id="id1686" class="indexterm"/>Log in to JIRA by invoking the <code class="literal">login</code> method as shown:<div><pre class="programlisting">// Login and retrieve logon token
Vector loginParams = new Vector(2);
loginParams.add(USER_NAME);
loginParams.add(PASSWORD);
String loginToken = (String) rpcClient.execute("jira1.login", loginParams);
System.out.println("Logged in: " + loginToken);</pre></div><p>As you can learn from the Javadocs, the method expects a username and password, which are passed into the execute method on the client as a Vector object. The first argument is the method name which is preceded with the namespace under which the methods are exposed. In this case, it is <code class="literal">jira1</code> and is equivalent to the service path we have seen in the previous recipe. The full method name will hence become <code class="literal">jira1.login</code>.</p><p>In the case of the <code class="literal">login</code> method, the return object is an authentication token which is a String object.</p></li><li class="listitem">Retrieve the list projects using the <code class="literal">getProjectsNoSchemes</code> method<a id="id1687" class="indexterm"/>:<div><pre class="programlisting">// Retrieve projects
Vector loginTokenVector = new Vector(1);
loginTokenVector.add(loginToken);
List projects = (List) rpcClient.execute("jira1.getProjectsNoSchemes",   loginTokenVector);</pre></div><p>Here again, we need to send a <code class="literal">Vector</code> as input along with the method name, in this case, with the authentication token in the <code class="literal">Vector</code>. If we need to invoke a method that needs a complex object in scenarios like creating an issue, we should create a <code class="literal">HashTable</code> with the input parameters as key/value pairs and add it into the <code class="literal">Vector</code>.</p><p>The return type in this case is type cast into a <code class="literal">List</code>. This will be a <code class="literal">List</code> of map objects, each map representing a <code class="literal">RemoteProject</code> with the details of the project in it as key/value pairs. For example, the name of the project can be accessed from the map using the key name, as shown in the next step.</p></li><li class="listitem">Retrieve the details of projects from the list. Details will be the attributes of the project published with the getter/setter methods in the <code class="literal">RemoteProject</code> object, such as name, lead, and so on.<div><pre class="programlisting">for (Iterator iterator = projects.iterator(); iterator.hasNext();) {
  Map project = (Map) iterator.next();
  System.out.println(project.get("name") + " with lead " + project.get("lead"));
}</pre></div><p>As mentioned in the previous step, the details can be retrieved as key/value pairs from the Map objects representing a project. This same logic applies to all XML-RPC methods where complex objects are retrieved as Maps with key/value pairs in it.</p></li><li class="listitem">Log out from JIRA:<div><pre class="programlisting">Boolean bool = (Boolean) rpcClient.execute("jira1.logout", loginTokenVector);</pre></div><a id="id1688" class="indexterm"/><a id="id1689" class="indexterm"/><p>Here the output is converted to Boolean as the method returns a Boolean.</p></li><li class="listitem">If we try to get the list of categories using the new method exposed in the previous recipe, the code will look similar to the following:<div><pre class="programlisting">// Retrieve Categories
Vector loginTokenVector = new Vector(1);
loginTokenVector.add(loginToken);
List categories = (List) rpcClient.execute("jtricks.getprojectCategories", loginTokenVector);
for (Iterator iterator = categories.iterator(); iterator.hasNext();) {
  Map category = (Map) iterator.next();
  System.out.println(category.get("name"));
}</pre></div><p>Note that the method name here is prefixed with jtricks as it is the service path used in the RPC Endpoint Plugin Module. Everything else works the same.</p></li></ol></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec121"/>Expose services and data entities as REST APIs</h1></div></div></div><a id="id1690" class="indexterm"/><a id="id1691" class="indexterm"/><a id="id1692" class="indexterm"/><a id="id1693" class="indexterm"/><a id="id1694" class="indexterm"/><p>Now that we have seen how to expose JIRA functionalities via SOAP and XML-RPC interfaces, it is time to move to REST APIs. Similar to the RPC Endpoint Plugin Module Type, JIRA also has a REST Plugin module type using which services or data can be exposed to the outside world.</p><p>In this recipe, we will see how to expose the <code class="literal">getProjectCategories</code> method<a id="id1695" class="indexterm"/> we have used as examples in the previous recipes using the REST interface.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec335"/>Getting ready</h2></div></div></div><p>Create a skeleton plugin using Atlassian Plugin SDK. The plugin should be v2 for it to work.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec336"/>How to do it...</h2></div></div></div><p>Following is a step-by-step procedure to create a REST plugin to expose the <a id="id1696" class="indexterm"/>
<code class="literal">getProjectCategories</code> method.</p><div><ol class="orderedlist arabic"><li class="listitem">Add the maven dependencies require for REST to the <a id="id1697" class="indexterm"/><code class="literal">pom.xml</code> file:<div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;javax.ws.rs&lt;/groupId&gt;
  &lt;artifactId&gt;jsr311-api&lt;/artifactId&gt;
  &lt;version&gt;1.0&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javax.xml.bind&lt;/groupId&gt;
  &lt;artifactId&gt;jaxb-api&lt;/artifactId&gt;
  &lt;version&gt;2.1&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;com.atlassian.plugins.rest&lt;/groupId&gt;
  &lt;artifactId&gt;atlassian-rest-common&lt;/artifactId&gt;
  &lt;version&gt;1.0.2&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;
  &lt;artifactId&gt;servlet-api&lt;/artifactId&gt;
  &lt;version&gt;2.3&lt;/version&gt;
  &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</pre></div><p>Note that all the dependencies are of scope provided as they are already available in the JIRA runtime.</p></li><li class="listitem">Add the REST plugin module into the <code class="literal">atlassian-plugin.xml</code>.<div><pre class="programlisting">&lt;rest key="rest-service-resources" path="/jtricks" version="1.0"&gt;
  &lt;description&gt;Provides the REST resource for the tutorial plugin.&lt;/description&gt;
&lt;/rest&gt;</pre></div><p>Here, the path and version defines the full path where the resources will be available only after the plugin is deployed. In this case, the full path will become <code class="literal">BASE_URL/rest/jtricks/1.0/</code> where <code class="literal">BASE_URL</code> is the JIRA base URL.</p><p>Define the data that will be returned to the client. JAXB Annotations are used to map these objects to XML and JSON formats.</p><p>In our example, the <code class="literal">getCategories</code> method<a id="id1698" class="indexterm"/> should return a List of Category objects and hence we need to define a Categories object and a Category object, the former containing a List of the latter. For both the objects, we should use the Annotations.</p></li><li class="listitem">Define the <code class="literal">Category</code> object as follows:<div><pre class="programlisting">@XmlRootElement
public static class Category{
  @XmlElement
  private String id;

  @XmlElement
  private String name;
  public Category(){
  }

  public Category(String id, String name) {
    this.id = id;
    this.name = name;
  }
}</pre></div><a id="id1699" class="indexterm"/><a id="id1700" class="indexterm"/><a id="id1701" class="indexterm"/><a id="id1702" class="indexterm"/><a id="id1703" class="indexterm"/><p>Make sure the annotations are used properly. The <code class="literal">@XmlRootElement</code> annotation<a id="id1704" class="indexterm"/> maps a class or an Enum type to an XML element and is used for the categories in this case. <code class="literal">@XmlElement</code><a id="id1705" class="indexterm"/> maps a property or field to an XML Element. Other annotations available are <code class="literal">@XmlAccessorType</code><a id="id1706" class="indexterm"/> and <code class="literal">@XmlAttribute</code><a id="id1707" class="indexterm"/> used for controlling whether fields or properties are serialized by default and mapping a property or 
field to an XML Attribute respectively.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>The details can be read at: <a class="ulink" href="http://jaxb.java.net/nonav/jaxb20-pfd/api/javax/xml/bind/annotation/package-summary.html">http://jaxb.java.net/nonav/jaxb20-pfd/api/javax/xml/bind/annotation/package-summary.html</a>.</p></div></div><p>Make sure a public non-argument constructor is available so as to render the output properly when accessed via the direct URL. Also, note that only the annotated elements will be exposed via the REST API.</p></li><li class="listitem">Define the <code class="literal">Categories</code> object:<div><pre class="programlisting">@XmlRootElement
public class Categories{
  @XmlElement
  private List&lt;Category&gt; categories;

  public Categories(){	
  }

  public Categories(List&lt;Category&gt; categories) {
    this.categories = categories;
  }
}</pre></div><p>Same rules apply here as well.</p></li><li class="listitem"><a id="id1708" class="indexterm"/><a id="id1709" class="indexterm"/><a id="id1710" class="indexterm"/><a id="id1711" class="indexterm"/><a id="id1712" class="indexterm"/>Create the <code class="literal">Resource</code> class. On the package level or the class level or the method level, we can have <code class="literal">@Path</code> annotations to define the path where the resource should be available. If it is available on all the levels, the final path will be a cumulative output.<p>This means that if you have <code class="literal">@Path("/X")</code> at package level, <code class="literal">@Path("/Y")</code> at class level, and <code class="literal">@Path("/Z")</code> at method level, the resource is accessed at:</p><div><pre class="programlisting">BASE_URL/rest/jtricks/1.0/X/Y/Z</pre></div><p>Different methods can have different paths to differentiate between each other. In our example, let us define a path <code class="literal">/categories</code> at class level:</p><div><pre class="programlisting">package com.jtricks;
................

@Path("/category")
public class CategoryResource {
  ..................
}</pre></div></li><li class="listitem">Write the method to return the <code class="literal">Categories</code> resource:<div><pre class="programlisting">@GET
@AnonymousAllowed
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public Response getCategories() throws SearchException {  Collection&lt;GenericValue&gt; categories = this.projectManager.getProjectCategories();
  List&lt;Category&gt; categoryList =  new ArrayList&lt;Category&gt;();		for (GenericValue category : categories) {
    categoryList.add(new Category(category.getString("id"), category.getString("name")));
  }
  Response.ResponseBuilder responseBuilder = Response.ok(new Categories(categoryList));
  return responseBuilder.build();
}</pre></div><p>As you can see, the method doesn't have a <code class="literal">@Path</code> annotation<a id="id1713" class="indexterm"/> and hence will be invoked at the URL, <code class="literal">BASE_URL/rest/jtricks/1.0/category</code>. Here, we normally construct a <code class="literal">Categories</code> object with a simple bean class and then use the <code class="literal">ResponseBuilder</code> to create the response.</p><p>The <code class="literal">@GET</code> annotation<a id="id1714" class="indexterm"/> mentioned earlier denotes that the class method will handle requests for a GET HTTP message.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>Other valid annotations include POST, PUT, DELETE, and so on, and can be viewed in detail at:</p><p><a class="ulink" href="http://jsr311.java.net/nonav/javadoc/javax/ws/rs/package-summary.html">http://jsr311.java.net/nonav/javadoc/javax/ws/rs/package-summary.html</a>.</p></div></div><p><code class="literal">@AnonymousAllowed</code><a id="id1715" class="indexterm"/> indicates that the method can be called without supplying user credentials. <code class="literal">@Produces</code> specifies the content types the method may return. The method can return any type if this annotation is absent. In our case, the method must return an XML or JSON object.</p><a id="id1716" class="indexterm"/><a id="id1717" class="indexterm"/><a id="id1718" class="indexterm"/><a id="id1719" class="indexterm"/><a id="id1720" class="indexterm"/><p>Two other useful annotations are: <code class="literal">@PathParam</code><a id="id1721" class="indexterm"/> and <code class="literal">@QueryParam</code><a id="id1722" class="indexterm"/>. <code class="literal">@PathParam</code> maps a method variable to an element in the <code class="literal">@Path</code> whereas <code class="literal">@QueryParam</code> maps a method variable to a query parameter.</p><p>The following is how we use each of them:</p><div><pre class="programlisting">
<strong>@QueryParam</strong>
</pre></div><p>Following is an example of how <code class="literal">@QueryParam</code> is used:</p><div><pre class="programlisting">@GET
@AnonymousAllowed
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
public Response getCategories(@QueryParam("dummyParam") String dummyParam) throws SearchException {
  System.out.println("This is just a dummyParam to show how parameters can be passed to REST methods:"+dummyParam);  ................
                   return responseBuilder.build();
}</pre></div><p>Here, we take a query parameter named <code class="literal">dummyParam,</code> which can then be used within our method. The resource will then be accessed as follows: <code class="literal">BASE_URL/rest/jtricks/1.0/category?dummyParam=xyz</code>.</p><p>In this case, you will see that the value xyz is printed into the console.</p><div><pre class="programlisting">
<strong>@PathParam</strong>

@GET
@AnonymousAllowed
@Produces({ MediaType.APPLICATION_JSON, MediaType.APPLICATION_XML })
@Path("/{id}")
public Response getCategoryFromId(@PathParam("id") String id) throws SearchException {
  GenericValue category = this.projectManager.getProjectCategory(new Long(id));  Response.ResponseBuilderresponseBuilder = Response.ok(new Category(category.getString("id"), category.getString("name")));
  return responseBuilder.build();
}</pre></div><a id="id1723" class="indexterm"/><a id="id1724" class="indexterm"/><a id="id1725" class="indexterm"/><a id="id1726" class="indexterm"/><a id="id1727" class="indexterm"/><p>Let us say we want to pass the ID of a category as well in the path and get the details of that <code class="literal">Category</code> alone; we can use the <code class="literal">PathParam</code> here as shown earlier. In that case, the URL to this method will be as shown:</p><div><pre class="programlisting">BASE_URL/rest/jtricks/1.0/category/10010</pre></div><p>Here, 10010 is the category ID passed into the previously described method as id.</p><p>When query parameters are used, the resource will not be cached by a proxy or your browser. So if you are passing in an ID to find some information about some sort of entity, then use a path parameter. This information will then be cached.</p></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec337"/>How it works...</h2></div></div></div><p>If you have deployed the plugin with both the <code class="literal">getCategories()</code> method and <code class="literal">getCategoryFromId()</code> method seen earlier, the list of categories can be retrieved at the URL: <code class="literal">BASE_URL/rest/jtricks/1.0/category</code>, as shown in the following screenshot:</p><div><img src="img/1803-09-09.jpg" alt="How it works..."/></div><a id="id1728" class="indexterm"/><a id="id1729" class="indexterm"/><a id="id1730" class="indexterm"/><a id="id1731" class="indexterm"/><a id="id1732" class="indexterm"/><p>The details of a particular category can be retrieved using the ID in the path, <code class="literal">BASE_URL/rest/jtricks/1.0/category/10001</code> for example, as shown in the next screenshot:</p><div><img src="img/1803-09-10.jpg" alt="How it works..."/></div><a id="id1733" class="indexterm"/><a id="id1734" class="indexterm"/><a id="id1735" class="indexterm"/><a id="id1736" class="indexterm"/><a id="id1737" class="indexterm"/><p>Atlassian has published some guidelines at: <a class="ulink" href="http://confluence.atlassian.com/display/REST/Atlassian+REST+API+Design+Guidelines+version+1">http://confluence.atlassian.com/display/REST/Atlassian+REST+API+Design+Guidelines+version+1</a>, which is a very useful read before developing your production version of REST service plugin. Check out: <a class="ulink" href="http://confluence.atlassian.com/display/REST/REST+API+Developer+Documentation">http://confluence.atlassian.com/display/REST/REST+API+Developer+Documentation</a> for more details.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec122"/>Writing Java client for REST API</h1></div></div></div><p>In this recipe, we will quickly see how we can create a Java client to communicate with JIRA using the REST APIs.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec338"/>Getting ready</h2></div></div></div><p>Make sure <strong>Accept</strong> <strong>Remote</strong> <strong>API</strong> <strong>Calls</strong> option is turned <strong>ON</strong> in JIRA under <strong>Administration</strong> | <strong>Global</strong> <strong>Settings</strong>.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec339"/>How to do it...</h2></div></div></div><a id="id1738" class="indexterm"/><a id="id1739" class="indexterm"/><a id="id1740" class="indexterm"/><p>In order to connect to JIRA using REST APIs, Atlassian has developed a JIRA REST Java Client Library, called JRJC in short. It provides a thin layer of abstraction on top of the REST API and related HTTP(S) communication and gives a domain object model to represent the JIRA entities, such as issues, priorities, resolutions, statuses, users, and so on. The REST API and the JRJC Library are in alpha phase and are quickly evolving! The status of the library can be viewed at: <a class="ulink" href="https://studio.atlassian.com/wiki/display/JRJC/Home">https://studio.atlassian.com/wiki/display/JRJC/Home</a>.</p><p>We will be using JRJC to connect to our JIRA instance using the standalone Java program. Following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a Maven project and add the JRJC dependency to the <code class="literal">pom.xml</code> file.<div><pre class="programlisting">&lt;dependency&gt;
  &lt;groupId&gt;com.atlassian.jira&lt;/groupId&gt;
  &lt;artifactId&gt;jira-rest-java-client&lt;/artifactId&gt;
  &lt;version&gt;0.2.1&lt;/version&gt;
&lt;/dependency&gt;</pre></div><p>Make sure you use the appropriate version of JRJC. All the versions can be found in the maven repository under <a class="ulink" href="https://maven.atlassian.com/public/com/atlassian/jira/jira-rest-java-client/">https://maven.atlassian.com/public/com/atlassian/jira/jira-rest-java-client/</a>. If you are not using Maven, the full dependencies are listed in the Atlassian documentation at <a class="ulink" href="https://studio.atlassian.com/wiki/display/JRJC/Project+Dependencies">https://studio.atlassian.com/wiki/display/JRJC/Project+Dependencies</a>.</p></li><li class="listitem">Create a Java project by running <code class="literal">maven eclipse:eclipse</code> if you are using Maven or create the project using your favorite IDE and add all dependencies listed earlier in the class path. Once done, create a standalone Java class.</li><li class="listitem">Create a connection to the JIRA server<div><pre class="programlisting">JerseyJiraRestClientFactory factory = new JerseyJiraRestClientFactory();
<code class="literal">URI uri = new URI("http://localhost:8080/jira");</code>
JiraRestClient jiraRestClient = factory.createWithBasicHttpAuthentication(uri, "username", "password");</pre></div><a id="id1741" class="indexterm"/><a id="id1742" class="indexterm"/><a id="id1743" class="indexterm"/><p>Here, we instantiate the <code class="literal">JerseyJiraRestClientFactory</code> and use the <code class="literal">createWithBasicHttpAuthentication</code> method to instantiate the REST client by passing the username and password.</p><p>RESTful architecture promotes stateless connection and hence there is no notion of the user session. This means the credentials will be send back and forth in plain text, just encoded with <code class="literal">Base64</code>, for each request and so it is not safe to use it outside a firewall or company network.</p></li><li class="listitem">Initiate the <code class="literal">ProgressMonitor</code>. All REST remote calls take this as a parameter. As per Atlassian docs, first, it serves as a clear marker of a remote call and second, in the future, they plan to make this interface capable of reporting the progress and cancelling (where possible) the remote requests taking too much time.<p>As of now, we initiate it as follows:</p><div><pre class="programlisting">NullProgressMonitor nullProgressMonitor = new NullProgressMonitor();</pre></div><p>Retrieve the appropriate client needed for the operation. The <code class="literal">jiraRestClient</code> exposes a set of clients, such as <code class="literal">IssueRestClient</code>, <code class="literal">ProjectRestClient</code>, <code class="literal">SearchClient</code>, and so on, each one exposing the related set of operations. In this example, we will try to retrieve an issue and hence will go for the <code class="literal">IssueRestClient</code>:</p><div><pre class="programlisting">IssueRestClient issueRestClient = jiraRestClient.getIssueClient();</pre></div></li><li class="listitem">Retrieve the issue details and print it. Alternatively, perform the required operation as appropriate:<div><pre class="programlisting">Issue issue = issueRestClient.getIssue("TST-10", nullProgressMonitor);
System.out.println(issue);</pre></div><p>Here, the issue is <code class="literal">com.atlassian.jira.rest.client.domain.Issue!</code></p><p>Various other operations can be performed on the issue, details of which can be found in the Javadocs at <a class="ulink" href="http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html">http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html</a>.</p><a id="id1744" class="indexterm"/><a id="id1745" class="indexterm"/><a id="id1746" class="indexterm"/><p>For example, we can vote on the issue as follows:</p><div><pre class="programlisting">issueRestClient.vote(issue.getVotesUri(), nullProgressMonitor);</pre></div><p>The API for this is available at <a class="ulink" href="http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html">http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html</a>.</p></li></ol></div><p>Some operations are a little more complex. For example, in order to progress the issue through its workflow, you will need the appropriate transition ID, the fields needed during the transition, and optionally a comment. We can do it as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Get the available transitions from the issue.<div><pre class="programlisting">Iterable&lt;Transition&gt; transitions = issueRestClient.getTransitions(issue.getTransitionsUri(), nullProgressMonitor);</pre></div></li><li class="listitem">Find the relevant transition by name or ID as follows:<div><pre class="programlisting">private static Transition getTransitionByName(Iterable&lt;Transition&gt; transitions, String transitionName) {
  for (Transition transition : transitions) {
    if (transition.getName().equals(transitionName)) {
      return transition;
    }
  }
  return null;
}</pre></div></li><li class="listitem">Create a list of fields needed during the transition. This can be empty if the fields are not mandatory:<div><pre class="programlisting">Collection&lt;FieldInput&gt;fieldInputs = Arrays.asList(new FieldInput("resolution", "Done"));</pre></div><p>Create a <code class="literal">Comment</code> object if needed:</p><div><pre class="programlisting">Comment.valueOf("New comment");</pre></div></li><li class="listitem"><a id="id1747" class="indexterm"/><a id="id1748" class="indexterm"/><a id="id1749" class="indexterm"/>Transition the issue as follows:<div><pre class="programlisting">issueRestClient.transition(issue.getTransitionsUri(), new TransitionInput(startProgressTransition.getId(), fieldInputs, Comment.valueOf("New comment")),nullProgressMonitor);</pre></div></li><li class="listitem">You will see that the issue is progressed in the workflow by executing the transition we selected.</li></ol></div><p>Similarly, the various methods can be executed using the appropriate clients. Given the fact that JIRA REST API is evolving so quickly, JRJC has a lot of potential and is worth investing time in.</p></div></div></body></html>