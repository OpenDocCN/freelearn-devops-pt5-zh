- en: Chapter 2. Start Treating Your Infrastructure as Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 开始将基础设施视为代码
- en: Ladies and gentlemen, put your hands in the air, for Programmable Infrastructure
    is here!
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 诸位，举起你们的手，程序化基础设施来了！
- en: Perhaps **Infrastructure-as-Code** (**IaC**) is not an entirely new concept
    considering how long Configuration Management has been around. Codifying server,
    storage, and networking infrastructure and their relationships, however, is a
    relatively recent tendency brought about by the rise of cloud computing. But let
    us leave Configuration Management for later and focus our attention on that second
    aspect of IaC.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 也许**基础设施即代码**（**IaC**）并不是一个全新的概念，因为配置管理已经存在了很长时间。然而，将服务器、存储和网络基础设施及其关系编写成代码的做法，是云计算崛起后才出现的相对较新的趋势。不过，让我们先放下配置管理，集中注意力在IaC的第二个方面。
- en: 'You should recall from the previous chapter some of the benefits of storing
    all the things as code:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该记得上一章中存储所有内容为代码的一些好处：
- en: Code can be kept under version control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以保持版本控制
- en: Code can be shared/collaborated on easily
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码可以轻松共享和协作
- en: Code doubles as documentation
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码即文档
- en: Code is reproducible
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码是可复现的
- en: That last point was a big win for me personally. Automated provisioning helped
    reduce the time it took to deploy a full-featured cloud environment from four
    hours down to one, and the occurrences of human error to almost zero (one shall
    not be trusted with an input field).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点对我个人来说是一个巨大的收获。自动化资源配置帮助将部署一个功能齐全的云环境的时间从四小时减少到一个小时，并且将人为错误的发生率降到了几乎为零（不能让一个人负责输入字段）。
- en: Being able to rapidly provision resources becomes a significant advantage when
    a team starts using multiple environments in parallel and needs those brought
    up or down on-demand. In this chapter, we examine in detail how to describe (in
    code) and deploy one such environment on AWS with minimal manual interaction.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当团队开始并行使用多个环境并且需要随时启动或停止这些环境时，能够快速配置资源成为一个显著的优势。在这一章节中，我们将详细探讨如何用代码描述并在 AWS
    上部署这样的一个环境，并尽量减少手动操作。
- en: 'To implement IaC in the cloud, we will look at two tools or services: **Terraform**
    and **CloudFormation**.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在云中实现IaC，我们将关注两个工具或服务：**Terraform**和**CloudFormation**。
- en: 'We will go through examples of the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下示例进行讲解：
- en: Configuring the tool
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置工具
- en: Writing an IaC template
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写IaC模板
- en: Deploying a template
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模板
- en: Deploying subsequent changes to the template
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署模板的后续变更
- en: Deleting a template and removing the provisioned infrastructure
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除模板并移除已配置的基础设施
- en: For the purpose of these examples, let us assume our application requires a
    **Virtual Private Cloud** (**VPC**) that hosts a **Relational Database Services**
    (**RDS**) backend and a couple of **Elastic Compute Cloud** (**EC2**) instances
    behind an **Elastic Load Balancer** (**ELB**). We will keep most components behind
    **Network Address Translation** (**NAT**), allowing only the load balancer to
    be accessed externally.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些示例中，假设我们的应用程序需要一个**虚拟私有云**（**VPC**），它托管一个**关系型数据库服务**（**RDS**）后端和若干个在**弹性负载均衡器**（**ELB**）后面的**弹性计算云**（**EC2**）实例。我们将大多数组件置于**网络地址转换**（**NAT**）背后，只允许负载均衡器可以从外部访问。
- en: IaC using Terraform
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Terraform 实现基础设施即代码（IaC）
- en: One of the tools that can help deploy infrastructure on AWS is HashiCorp's Terraform
    ([https://www.terraform.io](https://www.terraform.io)). HashiCorp is that genius
    bunch that gave us Vagrant, Packer, and Consul. I would recommend you look up
    their website if you have not already.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 部署AWS基础设施的工具之一是HashiCorp的Terraform（[https://www.terraform.io](https://www.terraform.io)）。HashiCorp是那个给我们带来Vagrant、Packer和Consul的天才团队。如果你还没看过他们的网站，我推荐你去看看。
- en: Using **Terraform** (**TF**), we will be able to write a template describing
    an environment, perform a *dry run* to see what is about to happen and whether
    it is expected, deploy the template, and make any late adjustments where necessary-all
    of this without leaving the shell prompt.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**Terraform**（**TF**），我们可以编写一个模板来描述一个环境，进行*模拟运行*查看即将发生的事情以及是否符合预期，部署模板，并在必要时进行任何后期调整——这一切都无需离开终端。
- en: Configuration
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: 'Firstly, you will need to have a copy of TF ([https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html))
    on your machine and available on the CLI. You should be able to query the currently
    installed version, which in my case is 0.6.15:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要在你的机器上安装一份TF（[https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)），并确保它能在CLI中使用。你应该能够查询到当前安装的版本，在我这里是0.6.15：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since TF makes use of the AWS APIs, it requires a set of authentication keys
    and some level of access to your AWS account. In order to deploy the examples
    in this chapter you could create a new **Identity** **and** **Access Management**
    (**IAM**) user with the following permissions:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-26
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to this file for more information: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json).'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to make the credentials of the IAM user available to TF is by exporting
    the following environment variables:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This should be sufficient to get us started.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'The code bundle for the book is also hosted on GitHub at: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS).
    We also have other code bundles from our rich catalog of books and videos available
    at: [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Template design
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get to coding, here are some of the rules:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: You could choose to write a TF template as a single large file or a combination
    of smaller ones
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates can be written in pure JSON or TF's own format
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TF will look for files with`.tf` or `.tf.json` extensions in a given folder
    and load them in alphabetical order
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TF templates are declarative, hence the order in which resources appear in them
    does not affect the flow of execution
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A TF template generally consists of three sections: *resources*, *variables*,
    and *outputs*. As mentioned in the preceding section, it is a matter of personal
    preference how you arrange these; however, for better readability I suggest we
    make use of the TF format and write each section to a separate file. Also, while
    the file extensions are of importance, the filenames are up to you.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a way, this file holds the main part of a template, as the resources represent
    the actual components that end up being provisioned. For example, we will be using
    the VPC Terraform resource, RDS, ELB and a few others to provision what roughly
    looks like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![Resources](img/B05585_02_05a-1024x844.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Since template elements can be written in any order, TF determines the flow
    of execution by examining any references that it finds (for example, a VPC should
    exist before an ELB that is said to belong to it is created). Alternatively, explicit
    flow control attributes such as `depends_on` are used, as we will observe shortly.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: To find out more, let us go through the contents of the `resources.tf` file.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we tell Terraform what provider to use for our infrastructure:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You will notice that no credentials are specified, since we set them as environment
    variables earlier.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add the VPC and its networking components:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So far, we have declared the VPC, its Internet and NAT gateways, plus a set
    of public and private subnets with matching routing tables.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'It will help clarify the syntax if we examined some of those resource blocks,
    line by line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The first argument is the type of the resource followed by an arbitrary name:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `aws_subnet` resource named `public-1` has a `vpc_id` property, which refers
    to the `id` attribute of a different `aws_vpc` resource named `terraform-vpc`.
    Such references to other resources implicitly define the execution flow, that
    is to say, the VPC needs to exist before the subnet can be created:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: We will talk more about variables in a moment, but the format is `var.var_name
    as shown here`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use the `cidrsubnet` function with the `vpc-cidr` variable, which returns
    a `cidr_block` to be assigned to the `public-1` subnet. Please refer to the TF
    documentation for this and other useful functions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a RDS to the VPC:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we mostly see references to variables with a few calls to other resources.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the RDS is an ELB:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Lastly, we define the EC2 Auto Scaling Group and related resources such as the
    Launch Configuration.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Launch Configuration we define the AMI and type of instance to be used,
    the name of the SSH keypair, EC2 security group(s) and the UserData to be used
    to bootstrap the instances:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Auto Scaling Group takes the ID of the Launch Configuration, a list of
    VPC subnets, the min/max number of instances and the name of the ELB to attach
    provisioned instances to:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding `user_data` shell script will install and start NGINX onto the
    EC2 node(s).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have made great use of variables to define our resources, making the template
    as re-usable as possible. Let us now look inside `variables.tf` to study these
    further.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the resources list, we start with the VPC:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The syntax is as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '`variable_name` is arbitrary, but needs to match relevant `var.var_name` references
    made in other parts of the template. For example, the `aws-region` variable will
    satisfy the `${var.aws-region}` reference we made earlier when describing the
    region of the `provider aws resource`.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'We will mostly use `string` variables, but there is another useful type called
    **map** that can hold lookup tables. Maps are queried in a similar way to looking
    up values in a hash/dict (Please see: [https://www.terraform.io/docs/configuration/variables.html](https://www.terraform.io/docs/configuration/variables.html)).'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes RDS:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Lastly, we add our EC2 related variables:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We now have the type and description of all our variables defined in `variables.tf`,
    but no values have been assigned to them yet.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: 'TF is quite flexible with how this can be done. We could do it any of the following
    ways:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Assign (default) values directly in `variables.tf:`
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: variable "`aws-region`" { `type = "string"``description = "AWS region"``default
    = 'us-east-1'` }
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not assign a value to a variable, in which case TF will prompt for it at run
    time
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` Pass a `-var ''key=value''` argument directly to the TF command, like so:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Store `key=value` pairs in a file
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use environment variables prefixed with `TF_VAR`, as in `TF_VAR_ aws-region`
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `key=value` pairs file proves to be quite convenient within teams, as
    each engineer can have a private copy (excluded from revision control). If the
    file is named `terraform.tfvars` it will be read automatically by TF; alternatively,
    `-var-file` can be used on the command line to specify a different source.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of our sample `terraform.tfvars` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars).'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A point of interest is `aws-availability-zones`, as it holds multiple values
    that we interact with using the element and split functions, as seen in `resources.tf`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third, mostly informational part of our template contains the TF Outputs.
    These allow selected values to be returned to the user when testing, deploying
    or after a template has been deployed. The concept is similar to how echo statements
    are commonly used in shell scripts to display useful information during execution.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add outputs to our template by creating an `outputs.tf` file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To configure an output, you simply reference a given resource and its attribute.
    As shown in preceding code, we have chosen the ID of the VPC, the Elastic IP address
    of the NAT gateway, the DNS name of the ELB and the endpoint address of the RDS
    instance.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: 'This section completes the template in this example. You should now have four
    files in your template folder: `resources.tf`, `variables.tf`, `terraform.tfvars`,
    and `outputs.tf`.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We shall examine five main TF operations:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Validating a template
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing (dry-run)
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial deployment
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a deployment
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of a deployment
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following command line examples, Terraform is run within the folder that
    contains the template files.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before going any further, a basic syntax check should be done with the `terraform
    validate` command. After renaming one of the variables in `resources.tf`, validate
    returns an `unknown variable` error:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Once the variable name has been corrected, re-running `validate` returns no
    output, meaning validation has passed.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Dry-run
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is to perform a test/dry-run execution with `terraform plan`,
    which displays what would happen during an actual deployment. The command returns
    a color-coded list of resources and their properties or more precisely, as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To literally get the picture of what the to-be-deployed infrastructure looks
    like, you could use `terraform graph`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'DOT files can be manipulated with the **Graphviz** open source software (Please
    see [http://www.graphviz.org](http://www.graphviz.org)) or many online readers/converters.
    The following diagram is a portion of a larger graph representing the template
    we designed earlier:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![Dry-run](img/image_02_002.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: Terraform graph
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are happy with the plan and graph, the template can now be deployed
    using `terraform apply`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The state of your infrastructure has been saved to the following path. This
    state is required to modify and destroy your infrastructure, so keep it safe.
    To inspect the complete state, use the `terraform show` command.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'At the end of a successful deployment, you will notice the `Outputs` we configured
    earlier and a message about another important part of *TF - the state file* (please
    refer to [https://www.terraform.io/docs/state/](https://www.terraform.io/docs/state/)):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: TF stores the state of your managed infrastructure from the last time TF was
    run. By default, this state is stored in a local file named `terraform.tfstate`,
    but it can also be stored remotely, which works better in a team environment.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: TF uses this local state to create plans and make changes to your infrastructure.
    Prior to any operation, TF does a refresh to update the state with the real infrastructure.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sense, the `state` file contains a snapshot of your infrastructure and
    is used to calculate any changes when a template has been modified. Normally,
    you would keep the `terraform.tfstate` file under version control alongside your
    templates. In a team environment however, if you encounter too many merge conflicts
    you can switch to storing the `state` file(s) in an alternative location such
    as S3 (please see: [https://www.terraform.io/docs/state/remote/index.html](https://www.terraform.io/docs/state/remote/index.html)).'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'Allow a few minutes for the EC2 node to fully initialize, then try loading
    the ELB URI from the preceding `Outputs` in your browser. You should be greeted
    by **nginx**, as shown in the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment](img/image_02_003.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: Updates
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As per Murphy 's Law, as soon as we deploy a template, a change to it will become
    necessary. Fortunately, all that is needed for this is to update and re-deploy
    the given template.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we need to add a new rule to the ELB security group (shown in bold):'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `"aws_security_group" "terraform-elb"` resource block in `resources.tf`:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verify what is about to change:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Deploy the change:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Some update operations can be destructive (please refer to [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)).
    You should always check the CloudFormation documentation on the resource you are
    planning to modify to see whether a change is going to cause an interruption.
    TF provides some protection via the `prevent_destroy` life cycle property (please
    refer to [https://www.terraform.io/docs/configuration/resources.html#prevent_destroy](https://www.terraform.io/docs/configuration/resources.html#prevent_destroy)).
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Removal
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a friendly reminder to always remove AWS resources after you are done
    experimenting with them to avoid any unexpected charges.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Before performing any `delete` operations, we will need to grant such privileges
    to the (`terraform`) IAM user we created in the beginning of this chapter. As
    a shortcut, you could temporarily attach the **AdministratorAccess** managed policy
    to the user via the AWS Console, as shown in the following figure:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '![Removal](img/image_02_004.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
- en: 'To remove the VPC and all associated resources that we created as part of this
    example, we will use `terraform destroy`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Terraform` asks for a confirmation then proceeds to destroy resources, ending
    with the following:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, we remove the temporary admin access we granted to the IAM user by detaching
    the **AdministratorAccess** managed policy, as shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: '![Removal](img/image_02_005.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
- en: Then, verify that the VPC is no longer visible in the AWS Console.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: IaC using CloudFormation
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CloudFormation** is an AWS service for deploying infrastructure as code.
    As before, we are going to describe our infrastructure via templates containing
    parameters (variables), resources, and outputs.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation calls each deployed template a **Stack**. Creating, listing,
    updating, and deleting stacks is possible via the AWS Console, CLI, or API. In
    a small setup, you would probably deploy each of your stacks individually, but
    as your architecture becomes more complex, you can start nesting stacks. You would
    have a top-level or a parent stack (template) that invokes a number of sub-stacks.
    Nested stacks allow you to pass variables between them and, of course, save you
    the time of having to deploy each one individually.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CloudFormation provides a GUI via the AWS Console; we however, are going to
    focus on the AWS CLI since it is most suitable for automating tasks in the future.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the OS you run, you could download an installer from [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)
    or use Python PIP:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的操作系统，你可以从 [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/) 下载安装程序，或者使用
    Python PIP：
- en: '[PRE29]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will need a set of API keys, so let''s create a new IAM user called `cloudformation`
    with the following privileges:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将需要一组 API 密钥，因此让我们创建一个名为 `cloudformation` 的新 IAM 用户，并赋予以下权限：
- en: '[PRE30]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-174
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json).'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json)。
- en: 'You have the choice of using `aws configure`, which will prompt you for the
    API credentials, or if you prefer not to store them permanently, you could use
    an environment variable:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择使用 `aws configure`，它会提示你输入 API 凭证，或者如果你不想永久存储它们，你也可以使用环境变量：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'CloudFormation templates do not store any AWS region information, so to avoid
    specifying it on the command line each time. It can be exported as well:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 模板不会存储任何 AWS 区域信息，因此为了避免每次在命令行中指定，可以将其导出：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With those environment variables in place, `awscli` should be ready for use.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好这些环境变量后，`awscli` 应该可以开始使用了。
- en: Template design
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板设计
- en: 'CloudFormation templates are written in JSON and usually contain at least three
    sections (in any order): parameters, resources and outputs.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: CloudFormation 模板是用 JSON 编写的，通常至少包含三个部分（顺序无关）：参数、资源和输出。
- en: Unfortunately it is not possible to store these into separate files (with the
    exception of parameter values), so in this example we will work with a single
    template file named `main.json`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，无法将这些参数存储到单独的文件中（参数值除外），因此在这个例子中，我们将使用一个名为`main.json`的单一模板文件。
- en: Templates can be used locally or imported from a remote location (an S3 bucket
    is a common choice).
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 模板可以在本地使用，也可以从远程位置导入（S3 存储桶是常见的选择）。
- en: Parameters
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数
- en: Parameters add flexibility and portability to our Stack by letting us pass variables
    to it such as instance types, AMI ids, SSH keypair names and similar values which
    it is best not to hard-code.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 参数通过允许我们传递变量（例如实例类型、AMI ID、SSH 密钥对名称等）为我们的堆栈增加了灵活性和可移植性，这些值最好不要硬编码。
- en: Each parameter takes an arbitrary logical name (alphanumeric, unique within
    the template), description, type, and an optional default value. The available
    types are `String`, `Number`, `CommaDelimitedList`, and the more special AWS-specific
    type, such as `AWS::EC2::KeyPair::KeyName`, as seen in the preceding code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参数都有一个任意的逻辑名称（字母数字，模板中唯一）、描述、类型和一个可选的默认值。可用的类型包括 `String`、`Number`、`CommaDelimitedList`，以及一些特定于
    AWS 的特殊类型，例如 `AWS::EC2::KeyPair::KeyName`，如前面的代码所示。
- en: The latter is useful for validation, as CloudFormation will check whether a
    key pair with the given name actually exists in your AWS account.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 后者对于验证很有用，因为 CloudFormation 会检查给定名称的密钥对是否确实存在于你的 AWS 账户中。
- en: Parameters can also have properties such as `AllowedValues`, `Min/MaxLength`,
    `Min/MaxValue`, `NoEcho` and other (please see [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html)).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 参数还可以具有诸如 `AllowedValues`、`Min/MaxLength`、`Min/MaxValue`、`NoEcho` 等属性（请参阅 [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html)）。
- en: There is a limit of 60 parameters per template.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模板的参数限制为 60 个。
- en: 'Let us examine the parameters found at the top of our template:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来检查一下模板顶部的参数：
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json)。
- en: '[PRE33]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We have used the following:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了以下内容：
- en: '`CommaDelimitedList`, which we will conveniently query later with a special
    function'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CommaDelimitedList`，我们稍后会通过一个特殊的函数方便地查询它'
- en: '`AllowedValues` and `MinValue` to enforce constraints'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `AllowedValues` 和 `MinValue` 来强制执行约束
- en: '`NoEcho` for passwords or other sensitive data'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NoEcho` 用于密码或其他敏感数据'
- en: Some AWS-specific types to have CloudFormation further validate input
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice that there are no values assigned to any of the preceding parameters.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain a reusable template, we will store values in a separate file (`parameters.json`):'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-202
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json).'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Resources
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are already familiar with the concept of resources and how they are used
    to describe different pieces of infrastructure.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how resources appear in a template, CloudFormation will follow
    its internal logic to decide the order in which these get provisioned.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for declaring a resource is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: IDs need to be alphanumeric and unique within the template.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of CloudFormation resource types and their properties can be found
    here: [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: The max number of resources a template can have is 200\. Reaching that limit,
    you will need to split a template into smaller ones and possibly look into nested
    stacks.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our example, as per tradition we start by creating a VPC and its supporting
    elements such as subnets, Internet gateway and NAT gateway:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-214
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Note some of the `CloudFormation` functions used in the preceding code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`"Fn::Select"` in `"CidrBlock" : { "Fn::Select" : [ "0", {"Ref" : "publicCidr"}
    ] }`, which allows us to query the `CommaDelimitedList` type parameters we set
    earlier'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Fn::Join"`, for concatenating strings'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Fn::GetAtt"`, for retrieving resource attributes'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the `DependsOn` property of the `natGateway` resource allows us to set
    explicit conditions on the order of execution. In this case, we are saying that
    the Internet Gateway resource needs to be ready (attached to the VPC) before the
    NAT Gateway is provisioned.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'After the VPC, let''s add RDS:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Then add the ELB:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'And add the EC2 resources:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We still use a `UserData` shell script to install the NGINX package; however,
    the presentation is slightly different this time. `CloudFormation` is going to
    concatenate the lines using a new line character as a delimiter then encode the
    result in `Base64`:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'We use `DependsOn` to ensure the RDS instance goes in before `autoScalingGroup`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Outputs
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, we will use these to highlight some resource attributes following a successful
    deployment. Another important feature of `Outputs`, however, is that they can
    be used as input parameters for other templates (stacks). This becomes very useful
    with nested stacks.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once declared, `Outputs` cannot be subsequently updated on their own. You will
    need to modify at least one resource in order to trigger an Output update.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the `VPC ID`, `NAT IP` address and `ELB DNS` name as `Outputs`:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Currently, a template can have no more than 60 Outputs.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have been following along, you should now have a `main.json` and a `parameters.json`
    in your current folder. It is time to put them to use, so here are a few operations
    we are going to perform:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: Validate a template
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a stack
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update a stack
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a stack
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template validation
  id: totrans-247
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First things first, a basic check of our JSON template with `validate-template`:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: If there's no errors, the CLI returns the parsed template. Note that we could
    have just as easily pointed to a remote location using `--template-url` instead
    of `-template-body`.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Stack
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To deploy our template (stack), we will use `create-stack`. It takes an arbitrary
    name, the location of the template, and the file containing parameter values:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'CloudFormation starts creating the stack and no further output is returned.
    To get progress information on the CLI, use `describe-stacks`:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: And for even more details, use `describe-stack-events`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: 'After a few minutes (based on our small template) `StackStatus` changes from
    `CREATE_IN_PROGRESS` to `CREATE_COMPLETE` and we are provided the requested `Outputs`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'At this point, the `elbDNS` URL should return the nginx welcome page, as shown
    here:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a Stack](img/image_02_006.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
- en: If not, you might need to allow some more time for the EC2 node to fully initialize.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: Updating a stack
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CloudFormation` offers two ways of updating a deployed stack.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-264
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some update operations can be destructive (please refer to [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)).
    You should always check the `CloudFormation` documentation on the resource you
    are planning to modify to see whether a change is going to cause any interruption.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to quickly deploy a minor change, then all you need to do
    is modify the template file and deploy it directly with `update-stack`:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Otherwise, a good practice would be to use `Change Sets` to preview stack changes
    before deploying them. For example, let us update the rules in the ELB security
    group as we did before:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `main.json` template (add another rule to `elbSecurityGroup`):'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Create a Change Set`:`
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Preview the Change Set:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Execute the Change Set:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Tip
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether via a Change Set or updating directly, if you are simply modifying parameter
    values (`parameters.json`) you can skip re-uploading the template (`main.json`)
    with `--use-previous-template`.
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Deleting a stack
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to tidy up after our experiments, we will need to grant temporary
    Admin privileges to the CloudFormation IAM user (the same procedure as in the
    earlier TF section); run `delete-stack`:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Then revoke the Admin privileges.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-283
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the importance and usefulness of Infrastructure
    as Code and ways to implement it using `Terraform` or AWS `CloudFormation`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: We examined the structure and individual components of both a TF and a CF template
    then practiced deploying those onto AWS using the CLI. I trust that the examples
    we went through have demonstrated the benefits and immediate gains from the practice
    of deploying infrastructure as code.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: So far, however, we have only done half the job. With the provisioning stage
    completed, you will naturally want to start configuring your infrastructure, and
    that is what we are going to do in the next chapter on *Configuration Management*.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
