- en: Chapter 2. Start Treating Your Infrastructure as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ladies and gentlemen, put your hands in the air, for Programmable Infrastructure
    is here!
  prefs: []
  type: TYPE_NORMAL
- en: Perhaps **Infrastructure-as-Code** (**IaC**) is not an entirely new concept
    considering how long Configuration Management has been around. Codifying server,
    storage, and networking infrastructure and their relationships, however, is a
    relatively recent tendency brought about by the rise of cloud computing. But let
    us leave Configuration Management for later and focus our attention on that second
    aspect of IaC.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should recall from the previous chapter some of the benefits of storing
    all the things as code:'
  prefs: []
  type: TYPE_NORMAL
- en: Code can be kept under version control
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code can be shared/collaborated on easily
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code doubles as documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Code is reproducible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That last point was a big win for me personally. Automated provisioning helped
    reduce the time it took to deploy a full-featured cloud environment from four
    hours down to one, and the occurrences of human error to almost zero (one shall
    not be trusted with an input field).
  prefs: []
  type: TYPE_NORMAL
- en: Being able to rapidly provision resources becomes a significant advantage when
    a team starts using multiple environments in parallel and needs those brought
    up or down on-demand. In this chapter, we examine in detail how to describe (in
    code) and deploy one such environment on AWS with minimal manual interaction.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement IaC in the cloud, we will look at two tools or services: **Terraform**
    and **CloudFormation**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go through examples of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing an IaC template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying subsequent changes to the template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a template and removing the provisioned infrastructure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the purpose of these examples, let us assume our application requires a
    **Virtual Private Cloud** (**VPC**) that hosts a **Relational Database Services**
    (**RDS**) backend and a couple of **Elastic Compute Cloud** (**EC2**) instances
    behind an **Elastic Load Balancer** (**ELB**). We will keep most components behind
    **Network Address Translation** (**NAT**), allowing only the load balancer to
    be accessed externally.
  prefs: []
  type: TYPE_NORMAL
- en: IaC using Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the tools that can help deploy infrastructure on AWS is HashiCorp's Terraform
    ([https://www.terraform.io](https://www.terraform.io)). HashiCorp is that genius
    bunch that gave us Vagrant, Packer, and Consul. I would recommend you look up
    their website if you have not already.
  prefs: []
  type: TYPE_NORMAL
- en: Using **Terraform** (**TF**), we will be able to write a template describing
    an environment, perform a *dry run* to see what is about to happen and whether
    it is expected, deploy the template, and make any late adjustments where necessary-all
    of this without leaving the shell prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Firstly, you will need to have a copy of TF ([https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html))
    on your machine and available on the CLI. You should be able to query the currently
    installed version, which in my case is 0.6.15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Since TF makes use of the AWS APIs, it requires a set of authentication keys
    and some level of access to your AWS account. In order to deploy the examples
    in this chapter you could create a new **Identity** **and** **Access Management**
    (**IAM**) user with the following permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to this file for more information: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/iam_user_policy.json).'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to make the credentials of the IAM user available to TF is by exporting
    the following environment variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This should be sufficient to get us started.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: Detailed steps to download the code bundle are mentioned in the Preface of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code bundle for the book is also hosted on GitHub at: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS).
    We also have other code bundles from our rich catalog of books and videos available
    at: [https://github.com/PacktPublishing/](https://github.com/PacktPublishing/).
    Check them out!'
  prefs: []
  type: TYPE_NORMAL
- en: Template design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get to coding, here are some of the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: You could choose to write a TF template as a single large file or a combination
    of smaller ones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Templates can be written in pure JSON or TF's own format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TF will look for files with`.tf` or `.tf.json` extensions in a given folder
    and load them in alphabetical order
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TF templates are declarative, hence the order in which resources appear in them
    does not affect the flow of execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A TF template generally consists of three sections: *resources*, *variables*,
    and *outputs*. As mentioned in the preceding section, it is a matter of personal
    preference how you arrange these; however, for better readability I suggest we
    make use of the TF format and write each section to a separate file. Also, while
    the file extensions are of importance, the filenames are up to you.'
  prefs: []
  type: TYPE_NORMAL
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In a way, this file holds the main part of a template, as the resources represent
    the actual components that end up being provisioned. For example, we will be using
    the VPC Terraform resource, RDS, ELB and a few others to provision what roughly
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Resources](img/B05585_02_05a-1024x844.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since template elements can be written in any order, TF determines the flow
    of execution by examining any references that it finds (for example, a VPC should
    exist before an ELB that is said to belong to it is created). Alternatively, explicit
    flow control attributes such as `depends_on` are used, as we will observe shortly.
  prefs: []
  type: TYPE_NORMAL
- en: To find out more, let us go through the contents of the `resources.tf` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/resources.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we tell Terraform what provider to use for our infrastructure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that no credentials are specified, since we set them as environment
    variables earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can add the VPC and its networking components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: So far, we have declared the VPC, its Internet and NAT gateways, plus a set
    of public and private subnets with matching routing tables.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will help clarify the syntax if we examined some of those resource blocks,
    line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument is the type of the resource followed by an arbitrary name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `aws_subnet` resource named `public-1` has a `vpc_id` property, which refers
    to the `id` attribute of a different `aws_vpc` resource named `terraform-vpc`.
    Such references to other resources implicitly define the execution flow, that
    is to say, the VPC needs to exist before the subnet can be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: We will talk more about variables in a moment, but the format is `var.var_name
    as shown here`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we use the `cidrsubnet` function with the `vpc-cidr` variable, which returns
    a `cidr_block` to be assigned to the `public-1` subnet. Please refer to the TF
    documentation for this and other useful functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add a RDS to the VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we mostly see references to variables with a few calls to other resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the RDS is an ELB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Lastly, we define the EC2 Auto Scaling Group and related resources such as the
    Launch Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the Launch Configuration we define the AMI and type of instance to be used,
    the name of the SSH keypair, EC2 security group(s) and the UserData to be used
    to bootstrap the instances:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The Auto Scaling Group takes the ID of the Launch Configuration, a list of
    VPC subnets, the min/max number of instances and the name of the ELB to attach
    provisioned instances to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `user_data` shell script will install and start NGINX onto the
    EC2 node(s).
  prefs: []
  type: TYPE_NORMAL
- en: Variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have made great use of variables to define our resources, making the template
    as re-usable as possible. Let us now look inside `variables.tf` to study these
    further.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly to the resources list, we start with the VPC:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/variables.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '`variable_name` is arbitrary, but needs to match relevant `var.var_name` references
    made in other parts of the template. For example, the `aws-region` variable will
    satisfy the `${var.aws-region}` reference we made earlier when describing the
    region of the `provider aws resource`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will mostly use `string` variables, but there is another useful type called
    **map** that can hold lookup tables. Maps are queried in a similar way to looking
    up values in a hash/dict (Please see: [https://www.terraform.io/docs/configuration/variables.html](https://www.terraform.io/docs/configuration/variables.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes RDS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, we add our EC2 related variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We now have the type and description of all our variables defined in `variables.tf`,
    but no values have been assigned to them yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'TF is quite flexible with how this can be done. We could do it any of the following
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Assign (default) values directly in `variables.tf:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: variable "`aws-region`" { `type = "string"``description = "AWS region"``default
    = 'us-east-1'` }
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not assign a value to a variable, in which case TF will prompt for it at run
    time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` Pass a `-var ''key=value''` argument directly to the TF command, like so:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Store `key=value` pairs in a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use environment variables prefixed with `TF_VAR`, as in `TF_VAR_ aws-region`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `key=value` pairs file proves to be quite convenient within teams, as
    each engineer can have a private copy (excluded from revision control). If the
    file is named `terraform.tfvars` it will be read automatically by TF; alternatively,
    `-var-file` can be used on the command line to specify a different source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the content of our sample `terraform.tfvars` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/terraform.tfvars).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A point of interest is `aws-availability-zones`, as it holds multiple values
    that we interact with using the element and split functions, as seen in `resources.tf`.
  prefs: []
  type: TYPE_NORMAL
- en: Outputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The third, mostly informational part of our template contains the TF Outputs.
    These allow selected values to be returned to the user when testing, deploying
    or after a template has been deployed. The concept is similar to how echo statements
    are commonly used in shell scripts to display useful information during execution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us add outputs to our template by creating an `outputs.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/Terraform/outputs.tf).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: To configure an output, you simply reference a given resource and its attribute.
    As shown in preceding code, we have chosen the ID of the VPC, the Elastic IP address
    of the NAT gateway, the DNS name of the ELB and the endpoint address of the RDS
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section completes the template in this example. You should now have four
    files in your template folder: `resources.tf`, `variables.tf`, `terraform.tfvars`,
    and `outputs.tf`.'
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We shall examine five main TF operations:'
  prefs: []
  type: TYPE_NORMAL
- en: Validating a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing (dry-run)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initial deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Removal of a deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the following command line examples, Terraform is run within the folder that
    contains the template files.
  prefs: []
  type: TYPE_NORMAL
- en: Validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Before going any further, a basic syntax check should be done with the `terraform
    validate` command. After renaming one of the variables in `resources.tf`, validate
    returns an `unknown variable` error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Once the variable name has been corrected, re-running `validate` returns no
    output, meaning validation has passed.
  prefs: []
  type: TYPE_NORMAL
- en: Dry-run
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The next step is to perform a test/dry-run execution with `terraform plan`,
    which displays what would happen during an actual deployment. The command returns
    a color-coded list of resources and their properties or more precisely, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To literally get the picture of what the to-be-deployed infrastructure looks
    like, you could use `terraform graph`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'DOT files can be manipulated with the **Graphviz** open source software (Please
    see [http://www.graphviz.org](http://www.graphviz.org)) or many online readers/converters.
    The following diagram is a portion of a larger graph representing the template
    we designed earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dry-run](img/image_02_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Terraform graph
  prefs: []
  type: TYPE_NORMAL
- en: Deployment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you are happy with the plan and graph, the template can now be deployed
    using `terraform apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The state of your infrastructure has been saved to the following path. This
    state is required to modify and destroy your infrastructure, so keep it safe.
    To inspect the complete state, use the `terraform show` command.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of a successful deployment, you will notice the `Outputs` we configured
    earlier and a message about another important part of *TF - the state file* (please
    refer to [https://www.terraform.io/docs/state/](https://www.terraform.io/docs/state/)):'
  prefs: []
  type: TYPE_NORMAL
- en: TF stores the state of your managed infrastructure from the last time TF was
    run. By default, this state is stored in a local file named `terraform.tfstate`,
    but it can also be stored remotely, which works better in a team environment.
  prefs: []
  type: TYPE_NORMAL
- en: TF uses this local state to create plans and make changes to your infrastructure.
    Prior to any operation, TF does a refresh to update the state with the real infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a sense, the `state` file contains a snapshot of your infrastructure and
    is used to calculate any changes when a template has been modified. Normally,
    you would keep the `terraform.tfstate` file under version control alongside your
    templates. In a team environment however, if you encounter too many merge conflicts
    you can switch to storing the `state` file(s) in an alternative location such
    as S3 (please see: [https://www.terraform.io/docs/state/remote/index.html](https://www.terraform.io/docs/state/remote/index.html)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Allow a few minutes for the EC2 node to fully initialize, then try loading
    the ELB URI from the preceding `Outputs` in your browser. You should be greeted
    by **nginx**, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deployment](img/image_02_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As per Murphy 's Law, as soon as we deploy a template, a change to it will become
    necessary. Fortunately, all that is needed for this is to update and re-deploy
    the given template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we need to add a new rule to the ELB security group (shown in bold):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `"aws_security_group" "terraform-elb"` resource block in `resources.tf`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Verify what is about to change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Deploy the change:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Some update operations can be destructive (please refer to [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)).
    You should always check the CloudFormation documentation on the resource you are
    planning to modify to see whether a change is going to cause an interruption.
    TF provides some protection via the `prevent_destroy` life cycle property (please
    refer to [https://www.terraform.io/docs/configuration/resources.html#prevent_destroy](https://www.terraform.io/docs/configuration/resources.html#prevent_destroy)).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Removal
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a friendly reminder to always remove AWS resources after you are done
    experimenting with them to avoid any unexpected charges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before performing any `delete` operations, we will need to grant such privileges
    to the (`terraform`) IAM user we created in the beginning of this chapter. As
    a shortcut, you could temporarily attach the **AdministratorAccess** managed policy
    to the user via the AWS Console, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removal](img/image_02_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove the VPC and all associated resources that we created as part of this
    example, we will use `terraform destroy`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Terraform` asks for a confirmation then proceeds to destroy resources, ending
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we remove the temporary admin access we granted to the IAM user by detaching
    the **AdministratorAccess** managed policy, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removal](img/image_02_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, verify that the VPC is no longer visible in the AWS Console.
  prefs: []
  type: TYPE_NORMAL
- en: IaC using CloudFormation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CloudFormation** is an AWS service for deploying infrastructure as code.
    As before, we are going to describe our infrastructure via templates containing
    parameters (variables), resources, and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: CloudFormation calls each deployed template a **Stack**. Creating, listing,
    updating, and deleting stacks is possible via the AWS Console, CLI, or API. In
    a small setup, you would probably deploy each of your stacks individually, but
    as your architecture becomes more complex, you can start nesting stacks. You would
    have a top-level or a parent stack (template) that invokes a number of sub-stacks.
    Nested stacks allow you to pass variables between them and, of course, save you
    the time of having to deploy each one individually.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CloudFormation provides a GUI via the AWS Console; we however, are going to
    focus on the AWS CLI since it is most suitable for automating tasks in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on the OS you run, you could download an installer from [https://aws.amazon.com/cli/](https://aws.amazon.com/cli/)
    or use Python PIP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need a set of API keys, so let''s create a new IAM user called `cloudformation`
    with the following privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/iam_user_policy.json).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have the choice of using `aws configure`, which will prompt you for the
    API credentials, or if you prefer not to store them permanently, you could use
    an environment variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'CloudFormation templates do not store any AWS region information, so to avoid
    specifying it on the command line each time. It can be exported as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: With those environment variables in place, `awscli` should be ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: Template design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CloudFormation templates are written in JSON and usually contain at least three
    sections (in any order): parameters, resources and outputs.'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately it is not possible to store these into separate files (with the
    exception of parameter values), so in this example we will work with a single
    template file named `main.json`.
  prefs: []
  type: TYPE_NORMAL
- en: Templates can be used locally or imported from a remote location (an S3 bucket
    is a common choice).
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parameters add flexibility and portability to our Stack by letting us pass variables
    to it such as instance types, AMI ids, SSH keypair names and similar values which
    it is best not to hard-code.
  prefs: []
  type: TYPE_NORMAL
- en: Each parameter takes an arbitrary logical name (alphanumeric, unique within
    the template), description, type, and an optional default value. The available
    types are `String`, `Number`, `CommaDelimitedList`, and the more special AWS-specific
    type, such as `AWS::EC2::KeyPair::KeyName`, as seen in the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The latter is useful for validation, as CloudFormation will check whether a
    key pair with the given name actually exists in your AWS account.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters can also have properties such as `AllowedValues`, `Min/MaxLength`,
    `Min/MaxValue`, `NoEcho` and other (please see [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/parameters-section-structure.html)).
  prefs: []
  type: TYPE_NORMAL
- en: There is a limit of 60 parameters per template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us examine the parameters found at the top of our template:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We have used the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CommaDelimitedList`, which we will conveniently query later with a special
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AllowedValues` and `MinValue` to enforce constraints'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NoEcho` for passwords or other sensitive data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some AWS-specific types to have CloudFormation further validate input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will notice that there are no values assigned to any of the preceding parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'To maintain a reusable template, we will store values in a separate file (`parameters.json`):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/parameters.json).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You are already familiar with the concept of resources and how they are used
    to describe different pieces of infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Regardless of how resources appear in a template, CloudFormation will follow
    its internal logic to decide the order in which these get provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax for declaring a resource is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: IDs need to be alphanumeric and unique within the template.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of CloudFormation resource types and their properties can be found
    here: [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-template-resource-type-ref.html)'
  prefs: []
  type: TYPE_NORMAL
- en: The max number of resources a template can have is 200\. Reaching that limit,
    you will need to split a template into smaller ones and possibly look into nested
    stacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our example, as per tradition we start by creating a VPC and its supporting
    elements such as subnets, Internet gateway and NAT gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Note some of the `CloudFormation` functions used in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"Fn::Select"` in `"CidrBlock" : { "Fn::Select" : [ "0", {"Ref" : "publicCidr"}
    ] }`, which allows us to query the `CommaDelimitedList` type parameters we set
    earlier'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Fn::Join"`, for concatenating strings'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"Fn::GetAtt"`, for retrieving resource attributes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, the `DependsOn` property of the `natGateway` resource allows us to set
    explicit conditions on the order of execution. In this case, we are saying that
    the Internet Gateway resource needs to be ready (attached to the VPC) before the
    NAT Gateway is provisioned.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the VPC, let''s add RDS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add the ELB:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And add the EC2 resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We still use a `UserData` shell script to install the NGINX package; however,
    the presentation is slightly different this time. `CloudFormation` is going to
    concatenate the lines using a new line character as a delimiter then encode the
    result in `Base64`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `DependsOn` to ensure the RDS instance goes in before `autoScalingGroup`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Outputs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, we will use these to highlight some resource attributes following a successful
    deployment. Another important feature of `Outputs`, however, is that they can
    be used as input parameters for other templates (stacks). This becomes very useful
    with nested stacks.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Once declared, `Outputs` cannot be subsequently updated on their own. You will
    need to modify at least one resource in order to trigger an Output update.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the `VPC ID`, `NAT IP` address and `ELB DNS` name as `Outputs`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_02_CodeFiles/CloudFormation/main.json).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Currently, a template can have no more than 60 Outputs.
  prefs: []
  type: TYPE_NORMAL
- en: Operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have been following along, you should now have a `main.json` and a `parameters.json`
    in your current folder. It is time to put them to use, so here are a few operations
    we are going to perform:'
  prefs: []
  type: TYPE_NORMAL
- en: Validate a template
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Template validation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First things first, a basic check of our JSON template with `validate-template`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: If there's no errors, the CLI returns the parsed template. Note that we could
    have just as easily pointed to a remote location using `--template-url` instead
    of `-template-body`.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a Stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To deploy our template (stack), we will use `create-stack`. It takes an arbitrary
    name, the location of the template, and the file containing parameter values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'CloudFormation starts creating the stack and no further output is returned.
    To get progress information on the CLI, use `describe-stacks`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And for even more details, use `describe-stack-events`.
  prefs: []
  type: TYPE_NORMAL
- en: 'After a few minutes (based on our small template) `StackStatus` changes from
    `CREATE_IN_PROGRESS` to `CREATE_COMPLETE` and we are provided the requested `Outputs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, the `elbDNS` URL should return the nginx welcome page, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying a Stack](img/image_02_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If not, you might need to allow some more time for the EC2 node to fully initialize.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`CloudFormation` offers two ways of updating a deployed stack.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Some update operations can be destructive (please refer to [http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html](http://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-update-behaviors.html)).
    You should always check the `CloudFormation` documentation on the resource you
    are planning to modify to see whether a change is going to cause any interruption.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you would like to quickly deploy a minor change, then all you need to do
    is modify the template file and deploy it directly with `update-stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Otherwise, a good practice would be to use `Change Sets` to preview stack changes
    before deploying them. For example, let us update the rules in the ELB security
    group as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `main.json` template (add another rule to `elbSecurityGroup`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create a Change Set`:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Preview the Change Set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute the Change Set:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Whether via a Change Set or updating directly, if you are simply modifying parameter
    values (`parameters.json`) you can skip re-uploading the template (`main.json`)
    with `--use-previous-template`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Deleting a stack
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to tidy up after our experiments, we will need to grant temporary
    Admin privileges to the CloudFormation IAM user (the same procedure as in the
    earlier TF section); run `delete-stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Then revoke the Admin privileges.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at the importance and usefulness of Infrastructure
    as Code and ways to implement it using `Terraform` or AWS `CloudFormation`.
  prefs: []
  type: TYPE_NORMAL
- en: We examined the structure and individual components of both a TF and a CF template
    then practiced deploying those onto AWS using the CLI. I trust that the examples
    we went through have demonstrated the benefits and immediate gains from the practice
    of deploying infrastructure as code.
  prefs: []
  type: TYPE_NORMAL
- en: So far, however, we have only done half the job. With the provisioning stage
    completed, you will naturally want to start configuring your infrastructure, and
    that is what we are going to do in the next chapter on *Configuration Management*.
  prefs: []
  type: TYPE_NORMAL
