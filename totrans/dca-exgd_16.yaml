- en: Implementing an Enterprise-Grade Registry with DTR
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DTR 实现企业级注册表
- en: Docker Enterprise is a complete **Container as a Service** (**CaaS**) platform.
    In previous chapters, we have learned how **Universal Control Plane** (**UCP**)
    provides a complete control plane solution for the Docker Swarm and Kubernetes
    orchestrators. We also learned about how UCP includes publishing features using
    Interlock. An enterprise-ready platform should also cover the storage of images.
    In this chapter, we will learn about **Docker Trusted Registry** (**DTR**), a
    component of the Docker Enterprise platform designed to manage and ensure security
    in Docker images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 企业版是一个完整的 **容器即服务** (**CaaS**) 平台。在前面的章节中，我们学习了 **通用控制平面** (**UCP**)
    如何为 Docker Swarm 和 Kubernetes 编排器提供完整的控制平面解决方案。我们还学习了 UCP 如何通过 Interlock 提供发布功能。一个面向企业的完整平台还应该涵盖镜像的存储。在本章中，我们将学习
    **Docker 可信注册表** (**DTR**)，这是 Docker 企业平台的一个组件，旨在管理和确保 Docker 镜像的安全性。
- en: In this chapter, we will learn about DTR components and how to deploy and manage
    a secure registry with high availability in terms of its components. We will also
    learn about how DTR provides an enterprise solution using **Role-Based Access
    Control** (**RBAC**), image scanning, and other security features. The final topics
    covered will demonstrate how we can integrate DTR automation and promotion features
    in our CI/CD workflow and strategies to ensure DTR's health. By the end of this
    series of chapters about Docker Enterprise, you will have good knowledge of this
    platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 DTR 组件以及如何在其组件方面部署和管理一个安全的高可用性注册表。我们还将学习 DTR 如何通过 **基于角色的访问控制** (**RBAC**)、镜像扫描和其他安全特性提供企业解决方案。最后的内容将展示如何将
    DTR 自动化和推广功能集成到我们的 CI/CD 工作流中，并提供确保 DTR 健康的策略。通过这系列关于 Docker 企业版的章节，你将对这个平台有深入的了解。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding DTR components and features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DTR 组件和特性
- en: Deploying DTR with high availability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署具有高可用性的 DTR
- en: Learning about RBAC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 RBAC（基于角色的访问控制）
- en: Image scanning and security features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像扫描和安全特性
- en: Integrating and automating image workflow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成和自动化镜像工作流
- en: Backup strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份策略
- en: Updates, health checks, and troubleshooting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新、健康检查和故障排除
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter in the GitHub repository: [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中找到本章的代码：[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码示例：
- en: '"[https://bit.ly/32tg6sn](https://bit.ly/32tg6sn)"'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/32tg6sn](https://bit.ly/32tg6sn)"'
- en: Understanding DTR components and features
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DTR 组件和特性
- en: DTR is the Docker Enterprise's platform registry, used to store and manage images.
    It is deployed on top of defined UCP worker nodes. DTR will run as a multi-container
    application. This means that all containers will run together, associated with
    just one defined node. In the case of node failure, no other nodes will take its
    DTR containers. This is very important because we need to deploy multiple DTR
    deployments, on different nodes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 是 Docker 企业版的容器平台注册表，用于存储和管理镜像。它部署在定义好的 UCP 工作节点之上。DTR 将作为一个多容器应用程序运行。这意味着所有容器将一起运行，并且仅与一个定义的节点相关联。在节点出现故障时，不会有其他节点接管其
    DTR 容器。这一点非常重要，因为我们需要在不同的节点上部署多个 DTR 实例。
- en: DTR uses RethinkDB as a database to store and sync data between registry nodes.
    To provide high availability to DTR, we need to deploy an odd number of replicas.
    We will use three replicas, so we need to deploy DTR workloads on three worker
    nodes. Synchronization will be done using overlay networking. DTR installation
    will create a `dtr-ol` overlay network and this will be used internally for replica
    synchronization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 使用 RethinkDB 作为数据库，用于存储和同步注册表节点之间的数据。为了确保 DTR 的高可用性，我们需要部署奇数个副本。我们将使用三个副本，因此需要在三个工作节点上部署
    DTR 工作负载。同步将使用覆盖网络进行。DTR 安装将创建一个 `dtr-ol` 覆盖网络，并将用于副本同步。
- en: 'Each replica will deploy the following processes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个副本将部署以下进程：
- en: '| **Replica (DTR instance)**  | **Process** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **副本（DTR 实例）**  | **进程** |'
- en: '| `dtr-api-<replica_id>` | This process exposes DTR''s API internally. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-api-<replica_id>` | 该进程内部暴露 DTR 的 API。 |'
- en: '| `dtr-garant-<replica_id>` | DTR''s authentication is managed by means of
    this component. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-garant-<replica_id>` | DTR的身份验证通过此组件管理。 |'
- en: '| `dtr-jobrunner-<replica_id>` | `jobrunner` is used to schedule different
    internal DTR maintenance tasks. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-jobrunner-<replica_id>` | `jobrunner`用于调度DTR的不同内部维护任务。 |'
- en: '| `dtr-nginx-<replica_id>` | The `nginx` process acts as a reverse proxy, publishing
    DTR''s API and web UI on ports `80` and `443` (secure). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-nginx-<replica_id>` | `nginx`进程充当反向代理，将DTR的API和Web UI发布在`80`端口和`443`（安全端口）上。
    |'
- en: '| `dtr-notary-server-<replica_id>` and `dtr-notary-signer-<replica_id>` | These
    processes help us to sign and maintain users'' signatures. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-notary-server-<replica_id>` 和 `dtr-notary-signer-<replica_id>` | 这些进程帮助我们签署和维护用户的签名。
    |'
- en: '| `dtr-registry-<replica_id>` | A community-based registry will be installed
    as a core component in DTR. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-registry-<replica_id>` | 一个基于社区的注册表将作为DTR的核心组件安装。 |'
- en: '| `dtr-rethinkdb-<replica_id>` | RethinkDB is the database used to store DTR''s
    repository information. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-rethinkdb-<replica_id>` | RethinkDB是用来存储DTR仓库信息的数据库。 |'
- en: '| `dtr-scanningstore-<replica_id>` | This component manages and stores scanning
    data. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-scanningstore-<replica_id>` | 此组件管理并存储扫描数据。 |'
- en: Notice that all processes will have a common suffix to identify each replica
    within the cluster. We will deploy different replicas, but their data will be
    synchronized.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有进程都会有一个共同的后缀，以便识别集群中每个副本。我们将部署不同的副本，但它们的数据会同步。
- en: Notary server processes will also receive requests whenever any user pushes
    or pulls images using a client with content trust enabled. A notary signer will
    execute server-side timestamps and snapshots for image signatures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 公证服务器进程还会在任何用户通过启用了内容信任的客户端推送或拉取镜像时接收请求。公证签名者将执行服务器端的时间戳和镜像签名快照。
- en: 'Volumes will be used to persist DTR data. Each node running a DTR replica will
    manage its own volumes. If DTR detects their existence, they will be used. This
    prevents the destruction of previous installations (we have to use the previous
    `replica_id` identification):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 卷将用于持久化DTR数据。每个运行DTR副本的节点将管理自己的卷。如果DTR检测到它们的存在，它们将被使用。这可以防止销毁之前的安装（我们必须使用先前的`replica_id`标识）：
- en: '| **Replica (DTR instance)** | **Process** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **副本（DTR实例）** | **进程** |'
- en: '| `dtr-ca-<replica_id>` | This volume manages the required key and root information
    to issue DTR''s CA. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-ca-<replica_id>` | 此卷管理颁发DTR CA所需的密钥和根信息。 |'
- en: '| `dtr-notary-<replica_id>` | This volume stores notary keys and certificates.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-notary-<replica_id>` | 此卷存储公证密钥和证书。 |'
- en: '| `dtr-postgres-<replica_id>` | This volume is used by images'' vulnerability
    scanning. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-postgres-<replica_id>` | 此卷用于镜像的漏洞扫描。 |'
- en: '| `dtr-registry-<replica_id>` and `dtr-nfs-registry-<replica_id>` | A registry''s
    data is stored on this volume. This is the default option, but we are able to
    integrate third-party storage. In fact, shared storage will be required to provide
    DTR processes with high availability. `dtr-nfs-registry-<replica_id>` will be
    used if the storage''s backend is NFS. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-registry-<replica_id>` 和 `dtr-nfs-registry-<replica_id>` | 注册表的数据存储在此卷中。这是默认选项，但我们可以集成第三方存储。实际上，共享存储将是提供DTR进程高可用性的必要条件。如果存储后端是NFS，则将使用`dtr-nfs-registry-<replica_id>`。
    |'
- en: '| `dtr-rethink-<replica_id>` | This volume stores repository information. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-rethink-<replica_id>` | 此卷存储仓库信息。 |'
- en: DTR's data storage is key because this is where images will live. Take care
    of your images' layers because DTR's backup does not back up their data and meta-information.
    You have to deploy your own backup to be able to restore your images' data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DTR的数据存储非常重要，因为这里是镜像存放的地方。请注意镜像的层，因为DTR的备份不会备份它们的数据和元信息。你必须部署自己的备份，以便能够恢复镜像数据。
- en: 'DTR can be deployed either on-premises or in the cloud. We can use Amazon,
    Google, or Microsoft Azure. It supports the following storage backends:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DTR可以部署在本地或云中。我们可以使用Amazon、Google或Microsoft Azure。它支持以下存储后端：
- en: NFS
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFS
- en: Amazon S3
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon S3
- en: Cleversafe
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cleversafe
- en: Google Cloud Storage
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Storage
- en: OpenStack Swift
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStack Swift
- en: Microsoft Azure
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure
- en: We can use any S3 object's storage-compatible solution (Minio, for example).
    Object storage works great with an image's data if we have big layers with a lot
    of content.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何与S3对象存储兼容的解决方案（例如Minio）。对象存储非常适合存储镜像的数据，尤其是当我们有包含大量内容的大镜像层时。
- en: DTR provides image caching for multi-site environments where communication latency
    between users and the registry can become a problem. Image caching will be used
    to ensure that users get the required images from the nearest registry node.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: RBAC is provided with DTR as it is in UCP. Both applications can be integrated
    to have a single sign-on solution, but RBAC is independent. DTR will forward authentication
    to UCP and this will verify a user's authentication, but each application will
    manage different roles and profiles. This way, a UCP's power user can have limited
    access to images in DTR.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Security in DTR is based on image security scanning and Docker Content Trust.
    Image security scanning will search for an image's content vulnerabilities using
    binaries' and libraries' **bills of materials** (**BOMs**). A **Common Vulnerabilities
    and Exposures** (**CVE**) database is used to search for well-known issues in
    our images.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: A BOM is a detailed list of all the files present inside an image. A CVE database
    is a public database of well-known vulnerabilities found in files around the world.
    It is community-driven and there are many contributors reporting and looking for
    vulnerabilities in applications' code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: DTR also includes image promotion and task scheduling. These features allow
    us to monitor image tagging and security to trigger different modifications or
    interactions with either external or DTR-integrated tools.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Repository mirroring and caching will help us to integrate DTR in enterprise
    environments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: We will learn how to deploy DTR with high availability in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Deploying DTR with high availability
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Deploying DTR with high availability requires more than one replica executing
    all DTR components. We will deploy an odd number of replicas to ensure high availability.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: DTR should be deployed on dedicated worker nodes. This will ensure that none
    of the non-system processes will impact DTR's behavior and vice versa. DTR's processes
    can take a lot of CPU during scanning and other procedures. Therefore, we will
    use three dedicated worker nodes. We usually admit DHCP on worker nodes, but we
    will ask for fixed IP addresses on DTR's worker nodes. We will also require fixed
    hostnames.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: We can deploy the Docker Enterprise platform on-premises or in the cloud. DTR
    requirements were described in brief in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'To deploy DTR on dedicated workers, these nodes require at least the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: 16 GB of RAM
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 2 vCPUs (virtual CPUs)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For production, we will ask for bigger nodes with more resources:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 32 GB of RAM
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 4 vCPUs
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This increment of hardware resources is due to image-scanning features. This
    will take a bunch of CPU and memory resources because it will load the content
    of all images and create all binary and library `md5-checksum-hashes` to compare
    these values against the CVE database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: An image's data will be downloaded by default in the `dtr-registry-<REPLICA_ID>`
    volume. If you deploy a standalone replica for testing, for example, ensure that
    you have sufficient space for your images. A minimum of 25 GB is required, but
    we recommend having at least 500 GB if you plan to manage Microsoft Windows images.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，镜像的数据将下载到 `dtr-registry-<REPLICA_ID>` 卷中。例如，如果您部署了一个独立的副本进行测试，请确保您有足够的空间来存储镜像。最低要求为
    25 GB，但如果您计划管理 Microsoft Windows 镜像，建议至少拥有 500 GB 的空间。 |
- en: At the time of writing this book, the latest DTR release is 2.7.6\. We will
    first install a DTR replica. Once the first replica is installed, we will join
    two other replicas. We recommend that you configure the first replica before continuing
    with others. This will ensure the synchronization of configuration changes between
    replicas. This is important for configuring DTR's data storage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，最新的 DTR 版本是 2.7.6。我们将首先安装一个 DTR 副本。安装第一个副本后，我们将加入另外两个副本。我们建议在继续其他副本之前先配置第一个副本。这将确保副本之间配置变化的同步。这对于配置
    DTR 的数据存储非常重要。 |
- en: If we configured a license on UCP, this will be copied to the DTR. If not, we
    will need to configure it in both environments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 UCP 上配置了许可证，则该许可证将被复制到 DTR。如果没有，我们需要在两个环境中进行配置。 |
- en: 'As we have seen in Docker''s UCP installation, `installation-container` will
    have many actions associated with it, such as `backups`/`restore`, `install`,
    and `join`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Docker 的 UCP 安装中所看到的，`installation-container` 将有许多相关的操作，如 `backups`/`restore`、`install`
    和 `join`： |
- en: '| **Command** | **Action** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `install` | DTR will be installed using the `docker/dtr` image. We will launch
    this process from any UCP node because the UCP URL will be used and the process
    will be executed from manager nodes once the connection is established. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `install` | DTR 将使用 `docker/dtr` 镜像进行安装。我们将从任何 UCP 节点启动此过程，因为 UCP URL 将被使用，并且一旦连接建立，过程将从管理节点执行。
    |'
- en: '| `join` | We will execute more than one DTR replica to provide high availability.
    In this case, we will install the first replica and then we will join others to
    this one. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `join` | 我们将执行多个 DTR 副本以提供高可用性。在这种情况下，我们将首先安装第一个副本，然后将其他副本加入到该副本中。 |'
- en: '| `reconfigure` | We can modify DTR configurations using the DTR image. Some
    configurations require restarting. We will configure DTR replicas to avoid downtime.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `reconfigure` | 我们可以使用 DTR 镜像修改 DTR 配置。有些配置需要重启。我们将配置 DTR 副本以避免停机。 |'
- en: '| `remove` | Sometimes, we need to remove a number of DTR replicas. We will
    use the `remove` action, available in the `docker/dtr` image, to delete replicas
    from the DTR environment. This action will neatly remove replicas, updating other
    replicas about this change. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 有时我们需要移除多个 DTR 副本。我们将使用 `docker/dtr` 镜像中的 `remove` 操作来删除 DTR 环境中的副本。此操作将整洁地移除副本，并更新其他副本关于此变化的信息。
    |'
- en: '| `destroy` | This command will be used to forcefully remove all DTR replicas''
    containers and volumes. This procedure should be used with care because replica
    removal is forced and does not inform others about this condition, meaning that
    a cluster can be left in an unhealthy state. Use this option to completely remove
    DTR from your cluster. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `destroy` | 此命令将用于强制删除所有 DTR 副本的容器和卷。此过程应谨慎使用，因为副本删除是强制的，且不会通知其他副本这一变化，这意味着集群可能会处于不健康状态。使用此选项可以完全从集群中删除
    DTR。 |'
- en: '| `backup`/`restore` | This command creates a TAR file with all the information
    and files required to restore a DTR replica, including non-image volumes and configurations.
    This will not back up an image''s data layers. An image''s data must be stored
    using third-party tools. Take care with this because you should be able to restore
    your DTR cluster to a running state, but you could lose all your images. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `backup`/`restore` | 此命令将创建一个 TAR 文件，其中包含恢复 DTR 副本所需的所有信息和文件，包括非镜像卷和配置。这不会备份镜像的数据层。镜像的数据必须使用第三方工具存储。请小心，因为您应该能够恢复您的
    DTR 集群到运行状态，但可能会丢失所有镜像。 |'
- en: '| `upgrade` | The `upgrade` option will help us to automatically deploy platform
    upgrades. All DTR components will be updated to a defined upgrade release. If
    we have deployed DTR with high availability, this process should not impact our
    users. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `upgrade` | `upgrade` 选项将帮助我们自动部署平台升级。所有 DTR 组件将更新到定义的升级版本。如果我们已部署高可用性 DTR，这个过程应该不会影响用户。
    |'
- en: '| `images` | We can download DTR''s required images prior to installation.
    This is very useful, for example, when we have to execute an offline installation.
    We will download DTR images using a Docker Engine instance with internet access.
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `images` | 我们可以在安装之前下载 DTR 所需的镜像。这非常有用，例如，在我们必须执行离线安装时。我们将使用具有互联网访问权限的 Docker
    Engine 实例来下载 DTR 镜像。 |'
- en: '| `emergency-repair` | When all the replicas of DTR are unhealthy, but one
    replica is running with healthy core processes, we will use the `emergency-repair`
    action with this replica to recover the cluster. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `emergency-repair` | 当所有 DTR 副本都不健康，但有一个副本正在运行并且核心进程健康时，我们将使用 `emergency-repair`
    操作来修复集群。 |'
- en: 'We will usually have the following common arguments for the majority of the
    actions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会为大多数操作使用以下常见参数：
- en: '| **Arguments** | **Actions** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **操作** |'
- en: '| `--ucp-url` | This should be our valid UCP''s URL. We will use the cluster''s
    **Fully Qualified Domain Name** (**FQDN**) and port (`443` by default). |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `--ucp-url` | 这应该是我们有效的 UCP URL。我们将使用集群的 **完全限定域名**（**FQDN**）和端口（默认是 `443`）。
    |'
- en: '| `--ucp-ca`and `--ucp-insecure-tls` | We will choose either of these options,
    using UCP''s valid CA or insecure TLS, avoiding any CA authentication. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `--ucp-ca` 和 `--ucp-insecure-tls` | 我们将选择其中一个选项，使用 UCP 的有效 CA 或不安全的 TLS，避免任何
    CA 认证。 |'
- en: '| `--ucp-username`and `--ucp-password` | These options will provide UCP''s
    user authentication. If none are used, we will be asked for them during execution.
    These should be valid and must have administrator privileges. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `--ucp-username` 和 `--ucp-password` | 这些选项将提供 UCP 用户认证。如果没有使用这些选项，执行过程中将会要求输入。它们必须有效且具有管理员权限。
    |'
- en: Always use the appropriate `docker/dtr:<RELEASE>` version for all actions. Do
    not mix releases unless you are doing a DTR upgrade. The current release, at the
    time of writing this book, is 2.7.6.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用适当的 `docker/dtr:<RELEASE>` 版本进行所有操作。除非您正在进行 DTR 升级，否则不要混用不同的版本。本书写作时的当前版本是
    2.7.6。
- en: DTR installation requires UCP's URL and one administrator's username and password.
    We can use these interactively, but as we learned in previous sections, it is
    preferable to include installation as part of script-like structures. This will
    help us to provide a reproducible configuration and installation methodology.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 安装需要 UCP 的 URL 和一个管理员的用户名及密码。我们可以交互式地使用它们，但正如我们在前面的章节中所学的，最好将安装作为脚本结构的一部分。这将帮助我们提供可复现的配置和安装方法。
- en: 'We will now describe DTR''s installation process. The first replica will be
    installed using `docker container run docker/dtr:<RELEASE> install`. We will launch
    the installation process from any cluster node. In fact, we can deploy DTR from
    our laptop because we will include UCP''s URL and the administrator''s username
    and password. Installation can be done using an interactive or automated process.
    We will also choose which UCP node will run the first replica''s processes using
    `--ucp-node`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将描述 DTR 的安装过程。第一个副本将通过 `docker container run docker/dtr:<RELEASE> install`
    命令安装。我们将在任何集群节点上启动安装过程。实际上，我们可以从笔记本电脑上部署 DTR，因为我们会提供 UCP 的 URL 以及管理员的用户名和密码。安装可以通过交互式或自动化过程完成。我们还将选择哪个
    UCP 节点将运行第一个副本的进程，使用 `--ucp-node`：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since DTR's installation process will connect to UCP's API, TLS will be used,
    and certificates will be sent. We added UCP's CA to validate its certificates.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DTR 的安装过程将连接到 UCP 的 API，TLS 将被使用，并且证书将被发送。我们已将 UCP 的 CA 添加到验证其证书。
- en: Once the first replica is installed, we will configure and then join other replicas.
    It is important to configure shared storage and other settings if you have not
    changed them during the installation process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦第一个副本安装完成，我们将进行配置，然后加入其他副本。如果在安装过程中没有更改共享存储和其他设置，配置这些内容非常重要。
- en: Notice the last line of the installation's output. It shows the `You can use
    flag '--existing-replica-id c8a9ec361fde' when joining other replicas to your
    Docker Trusted Registry Cluster` text message. Keep this replica's ID; we will
    use it for reconfiguring it and joining other replicas.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意安装输出的最后一行。它显示了 `You can use flag '--existing-replica-id c8a9ec361fde' when
    joining other replicas to your Docker Trusted Registry Cluster` 这段文字。请记住这个副本的
    ID；我们将在重新配置它并加入其他副本时使用它。
- en: 'We can configure the shared storage we need to execute the `reconfigure` action.
    We can use either filesystem or object storage types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置需要执行 `reconfigure` 操作的共享存储。我们可以使用文件系统或对象存储类型：
- en: '**Filesystem storage types**: **Network File System** (**NFS**), bind mount,
    and volume'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统存储类型**：**网络文件系统**（**NFS**）、绑定挂载和卷'
- en: '**Object storage (cloud) types**: Amazon S3, Openstack''s Swift, Microsoft
    Azure, and Google Cloud Storage'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象存储（云）类型**：Amazon S3、Openstack 的 Swift、Microsoft Azure 和 Google Cloud Storage'
- en: 'Object storage and NFS are valid options for shared storage. Each cloud provider
    will require its own specifications. Common parameters will be the user or account
    name, password, and bucket. Object storage is the preferred option for DTR shared
    image storage. There are some on-premises solutions, such as Minio, that are easy
    to implement in our data center. NFS is also valid and it is quite common in current
    data centers. In this case, we will use the `--nfs-storage-url` parameter with
    the `reconfigure` action. `nfs-storage-url` will require the following format:
    `nfs://<ip|hostname>/<mountpoint>`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储和 NFS 都是有效的共享存储选项。每个云服务提供商会要求不同的规格。常见的参数包括用户名或账户名、密码和桶名。对象存储是 DTR 共享镜像存储的首选选项。有一些本地解决方案，如
    Minio，容易在我们的数据中心实现。NFS 也是有效的选项，并且在当前的数据中心中非常常见。在这种情况下，我们将使用 `--nfs-storage-url`
    参数与 `reconfigure` 操作。`nfs-storage-url` 将要求以下格式：`nfs://<ip|hostname>/<mountpoint>`。
- en: DTR's storage backend configuration can also be managed using YAML format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 的存储后端配置也可以使用 YAML 格式进行管理。
- en: Many DTR options can be set using environment variables. To review available
    variables, execute `docker container run docker/dtr:<RELEASE> <ACTION> --help`
    to retrieve an action's help. Variables will be shown on each argument or option.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 DTR 选项可以通过环境变量进行设置。要查看可用的变量，执行 `docker container run docker/dtr:<RELEASE>
    <ACTION> --help` 来获取操作的帮助。变量将在每个参数或选项上显示。
- en: Joining replicas will provide high availability to DTR's processes. Replication
    requires external storage for sharing images' blobs (data layers) and meta-information.
    Therefore, we will reconfigure the first replica's storage if we did not choose
    shared storage during installation. We have the first replica's ID and we will
    use `docker/dtr:<RELEASE> reconfigure --existing-replica-id <FIRST_REPLICA'S_ID>`
    to reconfigure the storage's backend. In this example, we will just use NFS, which
    is common in our data centers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 加入副本将为 DTR 的进程提供高可用性。复制需要外部存储以共享镜像的 blob（数据层）和元信息。因此，如果在安装时没有选择共享存储，我们将重新配置第一个副本的存储。我们已经有了第一个副本的
    ID，将使用 `docker/dtr:<RELEASE> reconfigure --existing-replica-id <FIRST_REPLICA'S_ID>`
    来重新配置存储后端。在此示例中，我们将仅使用 NFS，这是我们数据中心常见的配置。
- en: Before executing the storage's configuration, we will copy the registry volume's
    data into our NFS filesystem.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行存储配置之前，我们将把注册表卷的数据复制到我们的 NFS 文件系统中。
- en: 'The following lines provide us with a quick example of this migration mounting
    NFS endpoint as a local directory on DTR''s host (we have used a sample IP address
    and the ID of the replica created previously):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行展示了将 NFS 端点作为本地目录挂载到 DTR 主机上的快速示例（我们使用了一个示例 IP 地址和先前创建的副本 ID）：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This step will guarantee previous data if we use `--storage-migrated` with the
    `reconfigure` action. If you are using NFS as a local volume, you should guarantee
    that it is mounted on reboot using the appropriate line in your `fstab` file.
    This was just an example. We will never use NFS locally mounted for DTR; we can
    use NFS directly, using appropriate command-line options, to mount an NFS endpoint
    as a DTR volume.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步将确保如果我们在使用 `--storage-migrated` 和 `reconfigure` 操作时，之前的数据不会丢失。如果您将 NFS 用作本地卷，应该确保它在重启时能够通过在
    `fstab` 文件中添加适当的行进行挂载。这只是一个示例。我们不会在 DTR 中使用本地挂载的 NFS；我们可以直接使用 NFS，通过适当的命令行选项，将
    NFS 端点挂载为 DTR 卷。
- en: 'The following screenshot shows Amazon''s S3 options integrated in DTR''s web
    UI. Each backend type will integrate different options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 Amazon S3 选项集成在 DTR 的 Web UI 中。每种后端类型将集成不同的选项：
- en: '![](img/d58a7bc5-662f-4efe-b0c8-444c997bf89e.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d58a7bc5-662f-4efe-b0c8-444c997bf89e.jpg)'
- en: 'We have used variables for command parameters, but we have left the command''s
    output intact because it is interesting how NFS and the current replica''s ID
    are present:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已使用变量作为命令参数，但我们保留了命令的输出，因为它展示了 NFS 和当前副本的 ID 信息：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the `--storage-migrated` argument. If we migrate storage after the creation
    of a number of repositories, all this work will be lost if we do not migrate the
    registry volume's data. In this case, we have just copied the volume's content.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `--storage-migrated` 参数。如果我们在创建多个仓库后迁移存储，如果没有迁移注册表卷的数据，所有的工作将会丢失。在这种情况下，我们只复制了卷的内容。
- en: 'Now that we have a shared registry''s storage backend, we can join new replicas.
    We will use the current replica''s ID because new replicas require a base replica
    to sync with. We will use the `join` action on any cluster node because we will
    select another worker node for this replica (we have mocked our example using
    `<NEW_UCP_NODE>`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了共享注册表的存储后端，我们可以加入新的副本。我们将使用当前副本的 ID，因为新的副本需要一个基础副本来同步。我们将在任何集群节点上使用 `join`
    操作，因为我们将为这个副本选择另一个工作节点（我们已经用 `<NEW_UCP_NODE>` 模拟了我们的例子）：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All values apart from the first replica's ID were mocked and the outputs of
    the `join` command have been reduced for this book. Notice that we have used `--ucp-insecure-tls`
    instead of adding UCP's CA. After `183` steps, the new replica was joined. At
    least three replicas are required for high availability. All replicas are deployed
    as multi-container applications on defined worker nodes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个副本的 ID 外，所有其他值都被模拟了，`join` 命令的输出也已简化。请注意，我们使用了 `--ucp-insecure-tls` 而不是添加
    UCP 的 CA。在执行了 `183` 步之后，新的副本已成功加入。至少需要三个副本才能保证高可用性。所有副本都作为多容器应用部署在定义好的工作节点上。
- en: Starting in DTR 2.6, you should perform a backup before switching storage drivers.
    This ensures that your images will be preserved if you decide to switch back to
    your current storage driver.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DTR 2.6 版本开始，在切换存储驱动程序之前，您应该先执行备份。这确保了如果您决定切换回当前的存储驱动程序，您的镜像将被保留。
- en: 'DTR will expose its API securely, using TLS. Therefore, certificates will be
    used to create secure tunnels. By default, DTR will create a CA to sign server
    certificates. We can use our corporation''s private or public certificates. They
    can be applied during installation using `--dtr-ca` and `--dtr-cert`, but we can
    change them later in DTR''s web UI or by using the `reconfigure` action. If you
    used your custom certificate, your certificate will probably be included in your
    system. If Docker created auto-signed certificates for us, these will not be trusted
    in your system. Docker created a CA for use to sign DTR certificates and you will
    probably get the following error message when you try to execute any registry
    action from your command line:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 将安全地公开其 API，使用 TLS 协议。因此，证书将用于创建安全的隧道。默认情况下，DTR 会创建一个 CA 来签署服务器证书。我们可以使用公司私有或公有证书。它们可以在安装过程中通过
    `--dtr-ca` 和 `--dtr-cert` 参数进行应用，但我们也可以稍后在 DTR 的 Web UI 或通过使用 `reconfigure` 操作进行更改。如果您使用了自定义证书，您的证书可能会包含在您的系统中。如果
    Docker 为我们创建了自动签名的证书，这些证书在您的系统中将不被信任。Docker 创建了一个 CA 来签署 DTR 证书，当您尝试从命令行执行任何注册表操作时，您可能会看到以下错误信息：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To avoid this issue, we can either avoid SSL verification, define an insecure
    registry, or add DTR''s CA as trusted on our system:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们可以选择不验证 SSL，定义不安全的注册表，或者将 DTR 的 CA 添加为受信任的证书：
- en: '**Insecure registry**: To set up an insecure registry for our client, we will
    add `"insecure-registries" : ["<DTR_FQDN>[:DTR_PORT]"]` to our Docker Engine `daemon.json`
    file. This is not recommended and should be avoided in production because someone
    could hijack our server''s identity.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全的注册表**：要为我们的客户端设置一个不安全的注册表，我们将在 Docker 引擎的 `daemon.json` 文件中添加 `"insecure-registries"
    : ["<DTR_FQDN>[:DTR_PORT]"]`。这不推荐在生产环境中使用，因为有人可能会劫持我们的服务器身份。'
- en: '**Adding DTR''s CA to our system**: This procedure may change depending on
    the Docker Engine host''s operating system. We will describe procedures for Ubuntu/Debian
    and Red Hat/CentOS nodes. They are very common in our data centers:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 DTR 的 CA 添加到我们的系统中**：这个过程可能会根据 Docker 引擎主机的操作系统有所不同。我们将描述 Ubuntu/Debian
    和 Red Hat/CentOS 节点的操作流程。它们在我们的数据中心中非常常见：'
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Including DTR's CA in our client systems is the preferred method because we
    will still validate its certificates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DTR 的 CA 添加到我们的客户端系统中是首选方法，因为我们仍然会验证其证书。
- en: We can log in to DTR's web UI using the defined DTR's URL. Since login is integrated
    with UCP by default, redirections will be integrated into this process and UCP
    will authorize users.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用定义好的 DTR URL 登录到 DTR 的 Web UI。由于默认情况下登录集成了 UCP，重定向将会整合到这个过程中，并且 UCP 将授权用户。
- en: 'The following screenshot shows DTR''s main interface once we are logged in.
    Repositories will be shown in a tree-like structure. Users will only have access
    to their resources:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们登录后 DTR 的主界面。仓库将以树形结构展示，用户只能访问自己的资源：
- en: '![](img/3f47db5f-1391-4c0f-b25d-39b447b06396.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f47db5f-1391-4c0f-b25d-39b447b06396.jpg)'
- en: 'DTR''s web UI is quite simple. It allows administrators to manage users, teams,
    organizations, and RBAC integrations. The following is a screenshot of the system''s
    endpoint:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 的 Web UI 非常简单。它允许管理员管理用户、团队、组织和 RBAC 集成。以下是系统端点的截图：
- en: '![](img/bd8254c4-7514-475b-b57a-1e40a1076318.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd8254c4-7514-475b-b57a-1e40a1076318.jpg)'
- en: 'The system''s endpoint provides access to the following resources and configurations:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的端点提供对以下资源和配置的访问：
- en: '**The General tab**:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规标签**：'
- en: Allows us to manage DTR's license.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们管理 DTR 的许可证。
- en: DTR's load-balanced URL.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTR 的负载均衡 URL。
- en: Integration of corporate proxies to download the required image-scanning CVE
    database.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成企业代理以下载所需的镜像扫描 CVE 数据库。
- en: Single sign-on integration within UCP and DTR.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UCP 和 DTR 之间的单点登录集成。
- en: Configures browser cookies for clients. This will help us to forward requests
    to specific DTR backends.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置客户端的浏览器 cookies。这将帮助我们将请求转发到特定的 DTR 后端。
- en: Allows us to set whether repositories can be created on push. This allows users
    to push images, and repositories will automatically be created if they do not
    exist.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们设置是否可以在推送时创建仓库。这使得用户可以推送镜像，如果仓库不存在，将自动创建该仓库。
- en: '**The Storage tab**: This tab allows us to configure all of DTR''s storage
    backends. We can choose between filesystem or object storage (cloud), and each
    backend will have different options.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储标签**：此标签允许我们配置所有 DTR 的存储后端。我们可以在文件系统存储和对象存储（云）之间进行选择，每个后端会有不同的选项。'
- en: '**The Security tab**: Security is key for images. This tab allows us to configure
    DTR''s image-scanning features.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全标签**：安全对于镜像至关重要。此标签允许我们配置 DTR 的镜像扫描功能。'
- en: '**The Garbage collection tab**: Untagged images consume space and will increase
    the risk if some use non-referenced layers. This tab allows us to schedule the
    automatic removal of untagged images.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收标签**：未标记的镜像占用空间，如果某些镜像使用了非引用的层，还会增加风险。此标签允许我们安排自动删除未标记镜像。'
- en: '**The Job logs tab**: The logs of internal tasks can be reviewed on this tab.
    This log will show us information regarding mirroring and image pruning, among
    other internal features.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业日志标签**：可以在此标签中查看内部任务的日志。该日志将显示与镜像同步和镜像修剪等内部功能的信息。'
- en: The following section will show us how to manage different access to consume
    images stored in your DTR repositories.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将展示如何管理不同的访问权限，以使用存储在 DTR 仓库中的镜像。
- en: Learning about RBAC
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 RBAC
- en: DTR provides a complete RBAC environment. DTR will authenticate and authorize
    valid users. We can integrate third-party authentication solutions as we learned
    in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal Control
    Plane*. Integrating external **Lightweight Directory Access Protocol** (**LDAP**)/**Active
    Directory** (**AD**) authentication mechanisms will allow us to delegate users'
    passwords to them, while UCP and DTR will manage user authorization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 提供了一个完整的 RBAC 环境。DTR 将对有效用户进行身份验证和授权。我们可以集成第三方身份验证解决方案，如在[第 11 章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)
    *通用控制平面* 中所学的那样。集成外部的 **轻量级目录访问协议**（**LDAP**）/**活动目录**（**AD**）身份验证机制将允许我们将用户密码委托给他们，而
    UCP 和 DTR 将管理用户授权。
- en: By default, DTR redirects user authentications to UCP because single sign-on
    is included. We can change this behavior in the System | General menu. It is recommended
    to keep this setting so as to manage users in just one application. All authentication
    will be delegated to UCP and this will route users to its integrated third-party
    authentication mechanism (if configured).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，DTR 会将用户身份验证重定向到 UCP，因为包括了单点登录。我们可以在系统 | 常规菜单中更改此行为。建议保持此设置，以便仅在一个应用程序中管理用户。所有身份验证将委托给
    UCP，并且此设置将用户路由到其集成的第三方身份验证机制（如果已配置）。
- en: Once we are authenticated to the DTR environment, we will get different permissions
    to allow us to manage images from repositories or just pull different releases
    from them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过身份验证进入 DTR 环境，我们将获得不同的权限，允许我们管理来自仓库的镜像或仅从中拉取不同的版本。
- en: By default, anonymous users will be able to pull images from public repositories.
    You must ensure that only allowed images are stored in public repositories.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，匿名用户将能够从公共仓库中拉取镜像。您必须确保只有允许的镜像存储在公共仓库中。
- en: We can create users on either UCP or DTR because, by default, we will have a
    single sign-on environment and users will be shared between both applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 UCP 或 DTR 上创建用户，因为默认情况下，我们将拥有一个单点登录环境，用户将在这两个应用程序之间共享。
- en: 'Users are managed in teams and organizations, as we also learned in [Chapter
    11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal Control Plane*. These
    allow us to integrate teams into organizations, while users will be integrated
    in those teams:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在团队和组织中进行管理，正如我们在[第11章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)《通用控制平面》中所学的那样，*通用控制平面*。这允许我们将团队整合到组织中，同时用户会被分配到这些团队中：
- en: '**Organizations** will provide a logical level of abstraction and isolation.
    They allow us to namespace other resources.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织**将提供一个逻辑层次的抽象和隔离。它们允许我们为其他资源命名空间。'
- en: '**Teams** will allow us to assign user access to repositories.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队**将允许我们为仓库分配用户访问权限。'
- en: Users will be integrated into organizations and teams. These allow us to restrict
    access to images within organizations and with the permissions and allowed actions
    given using teams.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将被整合到组织和团队中。这使我们能够限制组织内镜像的访问权限，并使用团队赋予的权限和允许的操作。
- en: 'Repositories'' accesses are managed by two concepts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的访问权限由两个概念管理：
- en: '**Ownership**: Repository creators'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权**：仓库创建者'
- en: '**Public accessibility**: Public or private repositories'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共可访问性**：公共或私人仓库'
- en: Owners of repositories can decide about access for others. As has been mentioned,
    we can have public and private images.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的所有者可以决定其他用户的访问权限。如前所述，我们可以有公共和私有镜像。
- en: Private repositories can only be consumed by owners and DTR administrators.
    Other users cannot pull images from these repositories. Only repositories' owners
    can push images to them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 私人仓库只能由所有者和 DTR 管理员使用。其他用户无法从这些仓库拉取镜像。只有仓库的所有者才能将镜像推送到这些仓库。
- en: Within organizations, we will provide read and write access for specific teams
    in an organization's private repositories. These teams will be able to push images
    to these repositories. These teams are owners of these repositories and we can
    provide read-only access to some teams. They will only be able to pull images.
    All other teams will not have any access because we are talking about an organization's
    private repositories.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织内部，我们将为特定团队提供对组织私人仓库的读写权限。这些团队将能够将镜像推送到这些仓库。这些团队是这些仓库的所有者，我们可以为某些团队提供只读权限。它们只能拉取镜像。其他所有团队将无法访问，因为我们讨论的是组织的私人仓库。
- en: Public repositories are different. Users' public repositories allow other users
    to pull images from them, while only owners are able to push. They have read-write
    access. An organization's public repositories will allow users to also pull images.
    In these cases, only teams with read-write access will be allowed to push images.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 公共仓库是不同的。用户的公共仓库允许其他用户从中拉取镜像，而只有仓库所有者才能推送镜像。它们具有读写权限。一个组织的公共仓库将允许用户同样拉取镜像。在这些情况下，只有具有读写权限的团队才能推送镜像。
- en: 'The following table represents permissions that can be applied to repositories:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下表表示可以应用于仓库的权限：
- en: '| **Permissions** | **Description** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **权限** | **描述** |'
- en: '| **Read-only** | A user can browse/search and pull images from a repository.
    Users will not be able to push to this repository. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **只读权限** | 用户可以浏览/搜索并从仓库中拉取镜像。用户无法向该仓库推送镜像。 |'
- en: '| **Read and write** | A user can browse/search, pull, and push images to a
    repository. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **读写权限** | 用户可以浏览/搜索、拉取和推送镜像到仓库。 |'
- en: '| **Owner** | The owner has read-write access to their repositories, but they
    are also allowed to manage their permissions and descriptions. They can also set
    a repository''s privacy level (public/private). |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **所有者** | 所有者对其仓库具有读写权限，但他们也可以管理其权限和描述。还可以设置仓库的隐私级别（公共/私有）。 |'
- en: Organizations' members have read-only access to public images within this organization.
    Therefore, an organization's users can always pull their public images. Organizations'
    members can see other members and view all teams included within their organization.
    But we need to integrate users within an organization's teams to provide management
    and read-write access.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的成员对该组织的公共镜像具有只读访问权限。因此，组织的用户始终可以拉取其公共镜像。组织的成员可以看到其他成员并查看组织内所有团队。但是，我们需要将用户整合到组织的团队中，以便提供管理和读写权限。
- en: An organization's members who are not included in any team cannot manage an
    organization's repositories. They can only pull its public images.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的成员如果未加入任何团队，则无法管理组织的仓库。他们只能拉取其公共镜像。
- en: An organization's owners, on the other hand, will be able to manage the organization
    and all its repositories. We can include any user within an organization as an
    owner. These users can also manage teams within an organization and their level
    of access.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: We will use a simple example to help you understand how permissions and access
    will be given to users in different repositories.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine an organization named **myorganization**. Let's include a team
    for **devops** and others for **developers** and **operations**. In this example,
    the **devops** team will define core images, while **developers** will use them
    for their applications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '**devops** group members will have read-write access, while **developers**
    will have read-only access. These will just pull images to create their own ones.
    They will use enterprise-defined core images, created by the **devops** team.
    In this case, the **operations** team does not have access to these application
    core images.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the **devops** team created a series of images for testing
    the platform, under the **testing image** repository. This repository is public
    and all users within the organization will be able to use it on the Docker Enterprise
    platform. The following diagram shows the RBAC situation described:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e1848d9-a860-4a6f-bf67-72db259d8679.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will review image scanning and other security features
    included in the DTR platform.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Image scanning and security features
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will review DTR's security features, such as security scanning
    and image signing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: Security scanning
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DTR includes image security scanning as a built-in feature. It will scan each
    image's layer for binaries and libraries. A scan report will include the aggregated
    BOM for each layer. We now have a complete picture of an image's files and its
    MD5 hashes. This ensures the immutability of each layer's content between image
    releases. If we change a file within a layer, its hash changes and scanning will
    be executed against the new layer's content. Image scanning will also download
    and manage a CVE database provided by Docker. This will be used to correlate an
    image's layer reports with the vulnerability information given.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: Scanning will show us a report regarding the health of our image, reporting
    all detected well-known vulnerabilities found on the image's layers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: This CVE database should be updated frequently because new threats appear almost
    daily. We can use either online synchronization or offline manual updates. In
    both cases, we require a valid Docker Enterprise license. Online synchronization
    requires a valid internet connection (we can use our corporate's proxies within
    DTR, configuring the `--http-proxy` and/or `--https-proxy` options either on DTR's
    installation or by reconfiguring the environment following the installation process).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: Do not forget to use the `--no-proxy` option to configure all your enterprise's
    internal FQDNs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Image scanning consumes a lot of DTR's hosts' resources. In fact, the first
    security scan for each layer requires a lot of resources. Subsequent scans will
    use previous layers' reports. If an image's layer size is large, scanning will
    take a lot of resources to create the layer's report. All files' hashes should
    be included in the report to correlate them with the database's data. If we use
    common layers in our images, this process will only be executed once. A layer's
    report will be updated if we change that layer's content. That layer will become
    old and a new scan will be executed. Take care of these processes between image
    changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像扫描消耗大量DTR主机的资源。实际上，每层的第一次安全扫描需要大量资源。随后的扫描将使用之前层的报告。如果镜像的层大小较大，扫描将消耗大量资源来生成该层的报告。报告中应包括所有文件的哈希值，以便与数据库中的数据进行关联。如果我们在镜像中使用公共层，这个过程只会执行一次。如果我们更改该层的内容，该层的报告将被更新，该层会变得过时，并且将执行新的扫描。在镜像更改时需要注意这些过程。
- en: Scanning can be executed whenever an image is updated or created within DTR's
    registry automatically. This will be set on each repository using the Scan on
    push feature. We can periodically execute images' scans manually, but this could
    prove hard to maintain without using DTR's API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描可以在DTR注册表中每次更新或创建镜像时自动执行。这个功能将通过在每个仓库中启用“推送时扫描”来设置。我们也可以定期手动执行镜像扫描，但如果不使用DTR的API，这将很难维护。
- en: 'The image''s scanning report will be shown on each repository''s tag. We will
    have a report of the health of the image''s vulnerabilities, as can be seen in
    the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的扫描报告将显示在每个仓库的标签上。我们将获得镜像漏洞的健康报告，如下图所示：
- en: '![](img/34825d8e-f894-4155-b846-ac0a14a84639.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34825d8e-f894-4155-b846-ac0a14a84639.png)'
- en: 'The vulnerability status of the image can be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的漏洞状态可以如下：
- en: '**Green**: No vulnerability was found. The image is secure.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：未发现漏洞，镜像是安全的。'
- en: '**Orange**: Some minor or major vulnerabilities were found.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**橙色**：发现了一些轻微或严重的漏洞。'
- en: '**Red**: Critical vulnerabilities were found and security could be compromised.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：发现了严重漏洞，可能会危及安全。'
- en: We can dive into each tag's report by clicking on its details. We will be able
    to review the full scan results, including the image's metadata, size, owner,
    and the most recent scan.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击每个标签的详细信息来查看其报告。我们将能够查看完整的扫描结果，包括镜像的元数据、大小、所有者和最新扫描。
- en: 'We have two different views for a tag''s scan details:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种不同的视图来查看标签的扫描详情：
- en: The **Layers** view will show us a list of the image's layers in the order of
    the image's construction. We will see each layer with the vulnerabilities identified
    on it. We can click on each layer to drill down into its components.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**视图将按镜像构建的顺序显示镜像的层列表。我们将看到每一层及其上识别出的漏洞。我们可以点击每一层，深入查看其组件。'
- en: The **Components** view will list all the image's components. Components will
    be sorted according to the number of vulnerabilities identified because a file
    can have multiple issues.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**视图将列出所有镜像的组件。组件将根据发现的漏洞数量进行排序，因为一个文件可能有多个问题。'
- en: We can integrate triggers to inform other processes or applications regarding
    the scanning results once they are finished.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以集成触发器，在扫描结果完成后通知其他进程或应用程序。
- en: Image immutability
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像不可变性
- en: Another interesting feature can be enabled for each image's repository. An image's
    immutability will mean that the overwriting of tags will be avoided. This will
    ensure the uniqueness of tags. This is interesting in terms of production releases.
    No one will reuse a tag that has already been used, so the development life cycle
    is not compromised because each release will have a unique ID.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能可以为每个镜像的仓库启用。镜像的不可变性意味着将避免覆盖标签。这将确保标签的唯一性。在生产发布方面，这非常有趣。没有人会重新使用已经使用过的标签，因此开发生命周期不会受到影响，因为每个发布都会有一个唯一的ID。
- en: Content trust in DTR
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DTR中的内容信任
- en: DTR has integration with **Docker Content Trust** (**DCT**). We have covered
    this topic in [Chapter 6](e9fd3807-5bbd-4ea8-84f7-ee02d288643d.xhtml), *Introduction
    to Docker Content Trust*. We learned that image signing improves cluster and application
    security, ensuring image ownership, immutability, and provenance. If we have a
    CI/CD pipeline that creates images as application artifacts, we can ensure that
    the correct image will run in production. UCP allowed us to run only signed images
    within our organization.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
- en: DTR provides a notary server and a notary signer. These components are required
    for DCT. Both application components will be accessed through an internal proxy
    and integrated with UCP's roles and access environment. This integration enables
    the signing of images that UCP can trust and execute securely.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: The Docker client will allow us to configure content trust for repositories
    and sign images. We will use a simple Docker client command line to sign images.
    The main difference in a corporate environment is that we need to ensure that
    images are signed by enterprise users. We will use our own certificates, included
    in our user's bundle. We will use `key.pem` and `cert.pem` as private and public
    keys, respectively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now describe the steps necessary for signing images in the Docker Enterprise
    environment:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will download the user''s bundle. We have already described this
    process in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal
    Control Plane*. Once we have our bundle in our system (already decompressed and
    ready to use), we will add a private key to our laptop''s or Docker client node''s
    trust store. We will use `docker trust load`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will then initialize trust metadata for a specific repository. We should
    add ourselves as signers on each repository where we will push images. Remember
    that repositories should contain the registry''s FQDN and port. We will use the
    `docker trust signer add` command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With these few steps, we are ready to sign an image. Let''s review a simple
    example with an `alpine` image. We will tag our image ready for our registry and
    we will sign it using `docker trust sign`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once signed, we can push our image to the registry. Notice that we are using
    `<DTR_FQDN>[:DTR_PORT]` as DTR''s registry:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now have our signed image in the registry, as we can observe in the following
    screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3b868554-3c49-4786-ba85-890116e9fb18.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: 'We can review image ownership and its signatures using `docker trust inspect`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have mocked this output and other output seen in this chapter, but you will
    receive similar output. Your user should be shown under the `SIGNER KEYS` section
    (we have `<MY_USERNAME>` in the previous command's output).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'There is also an important topic related to signing. Users can delegate image
    signing. This concept will allow other users to sign for us or share signing within
    a team. If we need to impersonate another user''s signing process, we need to
    import their key. Therefore, we require the other user''s `key.pem` key file.
    We will load this key in keeping with the steps covered previously:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We mocked the users' names and IDs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add our teammate''s public key to our repository:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can sign using both signatures:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can conduct a further inspection and we will see both signatures:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To delete the repository's DCT, we will use `notary delete <DTR_FQDN>[:DTR_PORT][/ORGANIZATION][/USERNAME][/REPOSITORY]
    --remote`. You will require the `notary` application's binary in your host.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: Remember that all client actions can be forced to be secure using `export DOCKER_CONTENT_TRUST=1`,
    to enable content trust as regards all the commands executed in the current shell.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: 'Content trust can be integrated into CI/CD with process orchestrators and other
    automation tools. To avoid a user''s interaction as regards image signing procedures,
    we can use the following variables:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: '`DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE`: Will be used for the local root key
    passphrase'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE`: Will be used for the repository
    passphrase'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we have learned, users will be available to sign their images using their
    Docker bundle from UCP. It is also possible to generate keys using `docker trust
    key generate command`, but these will not be included in DTR.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: DTR ships with Notary built in so that you can use DCT to sign and verify images.
    For more information about managing Notary data in DTR, refer to the DTR-specific
    notary documentation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: The following section will show us how we can integrate Docker Enterprise into
    our CI/CD pipeline using DTR's built-in features.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Integrating and automating image workflow
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'DTR provides built-in features aligned with CI/CD pipeline construction logic.
    We will have webhooks that can be triggered to inform other applications or processes
    regarding certain events, such as a completed image scan or a new image/tag arrival.
    We also have image promotions. This feature will retag images between repositories.
    The following diagram shows a simple workflow for building, distributing, and
    executing an application. We are including some of the features provided by DTR:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/977b9776-a6eb-4af7-bde5-05a2759718a9.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
- en: This workflow represents how to implement DTR in several development stages.
    Promoting a scanned image for testing will ensure its security before going to
    production in this example. Toward the end of this section, we will also be reviewing
    image mirroring. This is a feature used to share images between different DTR
    environments.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Image promotion
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DTR allows us to automatically promote images between repositories. Promotion
    is based on repository-defined policies. Therefore, policies are defined at the
    repository level. When an image is pushed to this repository, policies are reviewed
    and, if the rules match, a new push is done to another registry.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: DTR允许我们在仓库之间自动推广镜像。推广是基于仓库定义的策略进行的。因此，策略在仓库级别定义。当镜像被推送到该仓库时，策略会被审核，如果规则匹配，则会将镜像推送到另一个注册表。
- en: Image promotion is very useful in CI/CD pipeline stages. It is easier to understand
    with the help of a quick example. Let's imagine a development repository for a
    frontend application's component. Developers will push images to this `development/frontend`
    repository. They manage all the updates in this repository. In fact, no one apart
    from them has access to this repository. They will develop new updates with fixes
    and new features. When a release has to be deployed to production, they will prepare
    a `release` version. They will include a `release` string in this image's tag.
    A policy will match this string and a new image will be created on the `Quality
    Assurance` repository for the application's component.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像推广在CI/CD流水线阶段非常有用。通过快速示例可以更容易理解。假设有一个用于前端应用程序组件的开发仓库。开发人员将把镜像推送到`development/frontend`仓库，他们在这个仓库中管理所有更新。事实上，除了他们自己，没有人可以访问这个仓库。他们会在此开发新的更新，包括修复和新功能。当需要将版本发布到生产环境时，他们会准备一个`release`版本，并在该镜像的标签中加入`release`字符串。一个策略将匹配此字符串，然后会在`质量保证`仓库为该应用组件创建一个新的镜像。
- en: This process creates a new image to be tested by the quality assurance team
    when the `release` image is pushed. These users do not have access to non-release
    images. Only those images tagged as `release` will be available to quality assurance
    users. We know that only an image's ID is unique. We can have many tags for each
    image. Therefore, we are not duplicating images. We are just adding new tags and
    names for a defined image.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当`release`镜像被推送时，该过程会创建一个新的镜像供质量保证团队进行测试。这些用户无法访问非发布镜像。只有标记为`release`的镜像才能供质量保证用户使用。我们知道，只有镜像的ID是唯一的。每个镜像可以有多个标签。因此，我们并没有重复镜像，只是为定义的镜像添加了新的标签和名称。
- en: 'We can define policies based on the following attributes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据以下属性定义策略：
- en: '| **Attributes** | **Description** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| Tag name | We define a matching string for a repository''s image''s tags.
    Matching tags can be equal, or can start with, end with, contain, or be one of
    the image-defined ones. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 标签名称 | 我们为仓库的镜像标签定义匹配字符串。匹配标签可以相等，或者可以是以某个字符串开头、结尾、包含某个字符串，或者是镜像定义的标签之一。
    |'
- en: '| Component name | This will be used to match if an image has a given component
    and its name equals, starts with, ends with, or contains, or is one the specified
    ones. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 组件名称 | 如果镜像具有给定组件，并且其名称等于、以某个字符串开头、结尾、包含某个字符串，或者是指定的名称之一，则此规则将匹配。 |'
- en: '| Vulnerabilities | We can define how many critical, major, or minor vulnerabilities
    (or all vulnerabilities) will be monitored to promote an image to another repository.
    We will use comparison expressions such as "is greater than," "greater than or
    equal to," "less than or equal to," "equal," or "not" with the defined value and
    the image will only be promoted if the equation is satisfied. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 漏洞 | 我们可以定义将监控多少个关键、重大或轻微漏洞（或所有漏洞），以便将镜像提升到另一个仓库。当满足定义的值和镜像之间的方程时，使用如“更大于”，“大于或等于”，“小于或等于”，“等于”或“非”等比较表达式，只有当方程式成立时，镜像才会被提升。
    |'
- en: '| License | This rule will match if the image uses a license. This is usually
    used in relation to Microsoft Windows images. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 许可证 | 如果镜像使用许可证，则此规则将匹配。通常，这与Microsoft Windows镜像相关。 |'
- en: We can apply more than one attribute to this policy's rules. Once we choose
    which criteria will be applied, we can set up the new repository and tag. There
    are a number of templates for the names of new image tags. These allow us to include
    an image's source tag or timestamps.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个属性应用于此策略的规则。一旦选择了将应用的标准，我们可以设置新的仓库和标签。新的镜像标签有许多命名模板。这些模板允许我们包含镜像的源标签或时间戳。
- en: DTR webhooks
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DTR Webhook
- en: DTR has a series of integrated webhooks that will be triggered under special
    circumstances. When some events occur, DTR will be able to send webhooks to third-party
    applications. This is vital to integrating DTR in your CI/CD pipelines. DTR webhooks
    can be secured using TLS if the receiver backend also has this feature.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover most of the important webhooks, but this link provides an accurate
    list of the current ones: [https://docs.docker.com/ee/dtr/admin/manage-webhooks/](https://docs.docker.com/ee/dtr/admin/manage-webhooks/):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '| **Webhooks** | **Description** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
- en: '| `TAG_PUSH`, `TAG_PULL`, and `TAG_DELETE` | Repositories'' tag events will
    generate webhooks when someone pushes or pulls on a repository or when it is removed.
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
- en: '| `SCAN_COMPLETED` and `SCANNER_UPDATE_COMPLETED` | Scanning is key to ensuring
    security. We will send notifications when the image-scanning database is updated
    or when a repository''s scan has ended correctly. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
- en: '| `PROMOTION` | Whenever a promotion policy is applied, we will send a webhook.
    This will help us to follow DTR images'' internal workflow. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
- en: We must have administrative privileges on a repository to be able to configure
    its webhooks using either DTR's web UI or its API. The web UI allows us to test
    defined webhooks by clicking Test.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows a repository''s webhook configuration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6824c1e9-c756-4b2e-b6fe-6d6b7ff6f6fd.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
- en: The following section will show us how to implement registry mirroring.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Mirror images between registries
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Registry mirroring can also help us in our CI/CD. When images get pushed into
    repositories and there is some mirroring configuration, DTR will push them into
    another defined registry. This helps us to distribute repositories on different
    registries, with high availability.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: 'Mirroring configuration is based on the promotion logic covered previously.
    We will first configure mirror direction to define which action will be used:
    pull or push. DTR mirroring allows us to integrate Docker Hub with the on-premises
    Docker Enterprise DTR environment.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to understand that DTR''s metadata is not synced between registries.
    Therefore, image scanning and signing information from the first registry will
    not be available on the second one. All these actions must also be executed on
    the mirror registry. We can integrate scanning automatically when images are pushed
    to the second registry. Image signing requires external integrations. The following
    screenshot shows the mirroring configurations for a repository:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/42d76fea-b8cd-46b6-8986-b54a1f33a849.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
- en: Now that we have learned about the built-in features for automation, we will
    review registry caching with a view to improving a developer's work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Registry caching
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Registry caching will help us to manage images on distributed environments.
    Users from remote locations can have latency problems and big images can take
    forever to load. We can deploy intermediate registry caches to decrease pull times.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Caches are transparent to users because they will use the original DTR's URL.
    When a user pulls an image, the DTR will check whether it is authorized and it
    will then be redirected to a defined cache. This cache pulls an image's layers
    from the DTR and keeps a copy for users. New requests do not require an image's
    layers to be pulled from DTR again.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: To deploy a registry cache service, we will use the `docker/dtr-content-cache:<RELEASE>`
    image.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'Registry caching help us to manage distributed environments. Docker clients
    must be configured in order to use this feature. We will add `"registry-mirrors":
    ["https://<REGISTRY''s_MIRROR_URL>"]` to the `daemon.json` configuration file
    or configure users to use it by using the Users Settings page. For this to work,
    it is necessary to register the deployed cache with DTR''s configuration using
    DTR''s API. Detailed instructions can be found at the following link: [https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/](https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: We will now learn about DTR's automated garbage deletion.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
- en: Garbage collection
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Garbage collection will remove unreferenced layers and manifests from DTR. Registry
    data can consume a lot of space in our storage backend. This is not only a problem
    for storage resources. Security can be compromised if unsecured layers remain.
    It is recommended to remove all unused layers (also known as **dangling images**).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'This process runs in two phases:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: DTR's garbage collector will search all registry manifests. Those with active
    content, and image layers included within other images, will not be deleted.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The process will scan all the blobs. Those not included in the first phase's
    list will be removed.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Garbage collection can be run manually from a registry''s container using `bin/registry
    garbage-collect`. We will usually apply scheduled tasks integrated into DTR''s
    web UI. Garbage collection options will allow us to configure the removal of unreferenced
    layers periodically using cron-like logic. We will also establish for how long
    we will allow the removal process to run because it can take a significant amount
    of time. The following screenshot shows the Garbage collection configuration page:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/63c47699-4ee0-4425-85a4-ac79fb639906.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will learn how to deploy DTR's backup.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: Backup strategies
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DTR's backup procedure does not result in any service interruption. A backup
    process can be executed from any of the cluster nodes. It is recommended to create
    all backups from the same replica. This will help us to recover at least this
    replica. We will be able to recreate the full DTR's cluster environment using
    this replica.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list shows which content will be stored as part of your DTR''s
    backup TAR file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: DTR configurations
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repository metadata
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User access control and repository configurations
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TLS certificates and keys required for DTR communication
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images' signatures and digests, including the integration of Notary
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Images' scan results
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following content will not be included within your backups:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Images' layers
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Users, teams, and organizations
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The vulnerability database used for image scanning
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take care of the content of images because users, teams, and organizations will
    be included in UCP's backup and the vulnerability database (CVE and reports) can
    be recreated whenever we need it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: By default, DTR's web UI will show a warning message if we haven't performed
    any backup.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'We will find the healthy replica''s ID by using `REPLICA_ID=$(docker inspect
    -f ''{{.Name}}'' $(docker ps -q -f name=dtr-rethink) | cut -f 3 -d ''-'') && echo
    $REPLICA_ID` and we will then execute a backup using this ID:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember, this file does not include an image's blobs or meta-information. We
    need to include third-party backup solutions for DTR's storage backend.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: We can use either `--ucp-ca` with a valid UCP CA certificate or `--ucp-insecure-tls`
    to connect to UCP.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'To restore DTR, we will use the same `docker/dtr` image release. We will use
    `docker container run docker/dtr:<RELEASE> restore`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command will not restore images' blobs and meta-information as the backup
    only provides information to recover all of DTR's processes and their configurations.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: The following section will help us to understand how to monitor DTR's health.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: Updates, health checks, and troubleshooting
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DTR application upgrades can sometimes integrate database modifications. Therefore,
    you must ensure the correct upgrade path between releases. The `upgrade` command
    can be executed from any node as we will execute this command against all DTR
    replicas. We will use the replicas' IDs or interactive mode to upgrade each DTR
    replica. The upgrade process will replace all replica containers.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended to review Docker''s documentation relating to updated procedures
    at the following link: [https://docs.docker.com/ee/dtr/admin/upgrade](https://docs.docker.com/ee/dtr/admin/upgrade)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: DTR uses semantic versioning. This is key for following upgrade paths. Downgrading
    is not supported because sometimes, an upgrade can modify database objects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: Upgrades between different patch releases can be skipped if a minor release
    is applied. Patches do not modify the database, so CA can be applied without an
    object's data changing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, upgrades between minor versions must follow the version number,
    although we can skip intermediate patches, as has been mentioned.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Major version upgrades require upgrading to the latest minor/patch release before
    going to the next major release. This procedure will implement a host of changes
    and you must ensure that you have a valid backup before this upgrade. Remember
    to verify a valid image's data backup.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: To monitor DTR, we will use a common container's monitoring procedures. We can
    also use UCP's stacks view because DTR is deployed as a multi-container application.
    All replicas will be displayed. We can then click on each replica's link and inspect
    its resources.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: 'DTR exposes the following endpoints for monitoring. We will use them to verify
    its health:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: '| **Endpoints** | **Description** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
- en: '| `/_ping` | This endpoint shows a replica''s status. We can verify status
    using third-party monitoring tools. If the replica is fine, we will obtain `"Healthy":true`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: '| `/nginx_status` | This shows us the common open source `nginx` status and
    statistics page. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
- en: '| `/api/v0/meta/cluster_status` | For all replica statuses, we will use this
    endpoint. This requires authentication because we will be accessing DTR''s API.
    We will use any administrator''s access. An overall cluster state and a list of
    replicas with their statuses will be shown. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
- en: We will also search for errors on DTR's container logs. In this case, we will
    usually integrate these logs in third-party logging management applications.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Logging
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As standard, DTR's container logs will show all application errors. DTR also
    includes a view in its web UI with all job logs. We will have detailed information
    regarding the many actions executed within the environment. This log view provides
    useful audit information because it contains all images' management actions executed
    in DTR.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: The following section will show us how to recover an unhealthy DTR environment.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
- en: DTR disaster recovery
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: DTR is deployed using a high-availability strategy. Therefore, we have a variety
    of situations, depending on how many replicas are unhealthy.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: Some replicas are unhealthy, but we keep the cluster's quorum's state
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this case, the majority of replicas are healthy, so overall, the cluster''s
    state is healthy. We will remove unhealthy replicas and add new ones as soon as
    possible. It is important to only join replicas after unhealthy ones have been
    removed. We will execute this procedure step by step, removing an unhealthy replica,
    adding a new one, and so on. This will keep the overall cluster''s state intact.
    We will only remove unhealthy replicas that have been identified, so we will first
    need to identify which replicas are in a failing state using `docker ps --format
    "{{.Names}}" | grep dtr`. Once identified, we will execute `docker container run
    docker/dtr:<RELEASE> remove` to delete the replica in question:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Although the `--replica-ids` argument will allow us to remove a list of replicas,
    it is recommended to follow this procedure on each unhealthy replica, adding a
    new one with each removal:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will join a new replica. Always wait until synchronization has finished
    before continuing with a new one.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: The majority of replicas are unhealthy
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If the majority of replicas are unhealthy, the cluster's state will be unhealthy
    because it will have lost its quorum. However, if we still have at least one healthy
    node, we can repair the cluster using this replica. We will execute an emergency
    repair procedure using `docker container run docker/dtr:<RELEASE> emergency-repair`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the healthy replica''s ID using `REPLICA_ID=$(docker inspect -f
    ''{{.Name}}'' $(docker ps -q -f name=dtr-rethink) | cut -f 3 -d ''-'') && echo
    $REPLICA_ID` and we will then execute the emergency repair procedure:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This process should recover a replica completely and we will then add new replicas
    to recover a cluster's consensus.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: All replicas are unhealthy
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In this situation, we cannot recover the cluster without an existing backup.
    We will use `docker container run docker/dtr:<RELEASE> restore`. It is critical
    to have a valid DTR backup:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command will not restore Docker images. We have to implement a separate
    procedure for this data. We will use the normal filesystem's backup and restore
    procedures. Once we have a healthy replica, we will be able to join new ones in
    keeping with the procedure described previously.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered DTR's features and components. We learned how to implement
    DTR in production using a high-availability strategy. We reviewed different solutions
    available for storing images securely.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: We also covered image scanning and signing. Both options allow us to improve
    image security by integrating with UCP's application deployment platform. Users
    within organizations will have different levels of access to images thanks to
    DTR's integrated RBAC system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD environments have changed the way we create and deploy applications nowadays.
    We have reviewed different features built using DTR that help us to integrate
    image building, sharing, and security in CI/CD pipelines. We also learned how
    to mirror repositories and improve users' experiences with registry caching.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Knowledge of DTR and UCP is required for the exam. We need to know their component
    distributions on cluster nodes and how they work. We also need to understand their
    installation processes and how we can ensure their health.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: This is the last chapter related to the Docker Enterprise platform. Later chapters
    will cover the content that is required for the exam, with some quick topic reviews
    and further questions and answers.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which features are included in DTR?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Repository load balancing
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: b) Repository mirroring
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: c) Repository signing
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: How many DTR replicas do we need in order to provide high availability for Docker
    images' layers?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) We will need at least three DTR replicas to provide high availability.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: b) DTR does not manage the high availability of data. We need to provide third-party
    solutions for DTR storage.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: c) DTR manages volume synchronization when we deploy more than one replica.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above statements are true.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: Which processes are part of DTR?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) `garant`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: b) `jobrunner`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: c) `notary-client`
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
- en: d) `auth-store`
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: Which of these statements are true in terms of how to deploy DTR with high availability?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Configure a load balancer as a transparent reverse proxy. We will forward
    all requests for DTR's FQDN to any of the replicas.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: b) Deploy shared storage to allow all DTR replicas to store an image's data
    and meta-information at the same location.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: c) Deploy the first DTR replica with previously created shared storage on one
    node. Then, add at least two more replicas on different nodes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above statements are true.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: Which content is not included in DTR's backup?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a) Repository metadata and images' layers.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: b) RBAC configurations.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: c) Image signatures.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
- en: d) All of the above statements are true.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following links will help us to understand some of the topics covered in
    this chapter:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
- en: 'Content trust integration in DTR: [https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Deploying the registry cache: [https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/](https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Authentication and authorization in DTR: [https://docs.docker.com/ee/dtr/admin/manage-users/](https://docs.docker.com/ee/dtr/admin/manage-users/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
