- en: Implementing an Enterprise-Grade Registry with DTR
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DTR 实现企业级注册表
- en: Docker Enterprise is a complete **Container as a Service** (**CaaS**) platform.
    In previous chapters, we have learned how **Universal Control Plane** (**UCP**)
    provides a complete control plane solution for the Docker Swarm and Kubernetes
    orchestrators. We also learned about how UCP includes publishing features using
    Interlock. An enterprise-ready platform should also cover the storage of images.
    In this chapter, we will learn about **Docker Trusted Registry** (**DTR**), a
    component of the Docker Enterprise platform designed to manage and ensure security
    in Docker images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 企业版是一个完整的 **容器即服务** (**CaaS**) 平台。在前面的章节中，我们学习了 **通用控制平面** (**UCP**)
    如何为 Docker Swarm 和 Kubernetes 编排器提供完整的控制平面解决方案。我们还学习了 UCP 如何通过 Interlock 提供发布功能。一个面向企业的完整平台还应该涵盖镜像的存储。在本章中，我们将学习
    **Docker 可信注册表** (**DTR**)，这是 Docker 企业平台的一个组件，旨在管理和确保 Docker 镜像的安全性。
- en: In this chapter, we will learn about DTR components and how to deploy and manage
    a secure registry with high availability in terms of its components. We will also
    learn about how DTR provides an enterprise solution using **Role-Based Access
    Control** (**RBAC**), image scanning, and other security features. The final topics
    covered will demonstrate how we can integrate DTR automation and promotion features
    in our CI/CD workflow and strategies to ensure DTR's health. By the end of this
    series of chapters about Docker Enterprise, you will have good knowledge of this
    platform.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解 DTR 组件以及如何在其组件方面部署和管理一个安全的高可用性注册表。我们还将学习 DTR 如何通过 **基于角色的访问控制** (**RBAC**)、镜像扫描和其他安全特性提供企业解决方案。最后的内容将展示如何将
    DTR 自动化和推广功能集成到我们的 CI/CD 工作流中，并提供确保 DTR 健康的策略。通过这系列关于 Docker 企业版的章节，你将对这个平台有深入的了解。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding DTR components and features
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 DTR 组件和特性
- en: Deploying DTR with high availability
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署具有高可用性的 DTR
- en: Learning about RBAC
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习 RBAC（基于角色的访问控制）
- en: Image scanning and security features
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 镜像扫描和安全特性
- en: Integrating and automating image workflow
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成和自动化镜像工作流
- en: Backup strategies
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 备份策略
- en: Updates, health checks, and troubleshooting
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新、健康检查和故障排除
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code for this chapter in the GitHub repository: [https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中找到本章的代码：[https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git](https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git)
- en: 'Check out the following video to see the Code in Action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码示例：
- en: '"[https://bit.ly/32tg6sn](https://bit.ly/32tg6sn)"'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '"[https://bit.ly/32tg6sn](https://bit.ly/32tg6sn)"'
- en: Understanding DTR components and features
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 DTR 组件和特性
- en: DTR is the Docker Enterprise's platform registry, used to store and manage images.
    It is deployed on top of defined UCP worker nodes. DTR will run as a multi-container
    application. This means that all containers will run together, associated with
    just one defined node. In the case of node failure, no other nodes will take its
    DTR containers. This is very important because we need to deploy multiple DTR
    deployments, on different nodes.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 是 Docker 企业版的容器平台注册表，用于存储和管理镜像。它部署在定义好的 UCP 工作节点之上。DTR 将作为一个多容器应用程序运行。这意味着所有容器将一起运行，并且仅与一个定义的节点相关联。在节点出现故障时，不会有其他节点接管其
    DTR 容器。这一点非常重要，因为我们需要在不同的节点上部署多个 DTR 实例。
- en: DTR uses RethinkDB as a database to store and sync data between registry nodes.
    To provide high availability to DTR, we need to deploy an odd number of replicas.
    We will use three replicas, so we need to deploy DTR workloads on three worker
    nodes. Synchronization will be done using overlay networking. DTR installation
    will create a `dtr-ol` overlay network and this will be used internally for replica
    synchronization.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 使用 RethinkDB 作为数据库，用于存储和同步注册表节点之间的数据。为了确保 DTR 的高可用性，我们需要部署奇数个副本。我们将使用三个副本，因此需要在三个工作节点上部署
    DTR 工作负载。同步将使用覆盖网络进行。DTR 安装将创建一个 `dtr-ol` 覆盖网络，并将用于副本同步。
- en: 'Each replica will deploy the following processes:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个副本将部署以下进程：
- en: '| **Replica (DTR instance)**  | **Process** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **副本（DTR 实例）**  | **进程** |'
- en: '| `dtr-api-<replica_id>` | This process exposes DTR''s API internally. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-api-<replica_id>` | 该进程内部暴露 DTR 的 API。 |'
- en: '| `dtr-garant-<replica_id>` | DTR''s authentication is managed by means of
    this component. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-garant-<replica_id>` | DTR的身份验证通过此组件管理。 |'
- en: '| `dtr-jobrunner-<replica_id>` | `jobrunner` is used to schedule different
    internal DTR maintenance tasks. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-jobrunner-<replica_id>` | `jobrunner`用于调度DTR的不同内部维护任务。 |'
- en: '| `dtr-nginx-<replica_id>` | The `nginx` process acts as a reverse proxy, publishing
    DTR''s API and web UI on ports `80` and `443` (secure). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-nginx-<replica_id>` | `nginx`进程充当反向代理，将DTR的API和Web UI发布在`80`端口和`443`（安全端口）上。
    |'
- en: '| `dtr-notary-server-<replica_id>` and `dtr-notary-signer-<replica_id>` | These
    processes help us to sign and maintain users'' signatures. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-notary-server-<replica_id>` 和 `dtr-notary-signer-<replica_id>` | 这些进程帮助我们签署和维护用户的签名。
    |'
- en: '| `dtr-registry-<replica_id>` | A community-based registry will be installed
    as a core component in DTR. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-registry-<replica_id>` | 一个基于社区的注册表将作为DTR的核心组件安装。 |'
- en: '| `dtr-rethinkdb-<replica_id>` | RethinkDB is the database used to store DTR''s
    repository information. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-rethinkdb-<replica_id>` | RethinkDB是用来存储DTR仓库信息的数据库。 |'
- en: '| `dtr-scanningstore-<replica_id>` | This component manages and stores scanning
    data. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-scanningstore-<replica_id>` | 此组件管理并存储扫描数据。 |'
- en: Notice that all processes will have a common suffix to identify each replica
    within the cluster. We will deploy different replicas, but their data will be
    synchronized.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，所有进程都会有一个共同的后缀，以便识别集群中每个副本。我们将部署不同的副本，但它们的数据会同步。
- en: Notary server processes will also receive requests whenever any user pushes
    or pulls images using a client with content trust enabled. A notary signer will
    execute server-side timestamps and snapshots for image signatures.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 公证服务器进程还会在任何用户通过启用了内容信任的客户端推送或拉取镜像时接收请求。公证签名者将执行服务器端的时间戳和镜像签名快照。
- en: 'Volumes will be used to persist DTR data. Each node running a DTR replica will
    manage its own volumes. If DTR detects their existence, they will be used. This
    prevents the destruction of previous installations (we have to use the previous
    `replica_id` identification):'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 卷将用于持久化DTR数据。每个运行DTR副本的节点将管理自己的卷。如果DTR检测到它们的存在，它们将被使用。这可以防止销毁之前的安装（我们必须使用先前的`replica_id`标识）：
- en: '| **Replica (DTR instance)** | **Process** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **副本（DTR实例）** | **进程** |'
- en: '| `dtr-ca-<replica_id>` | This volume manages the required key and root information
    to issue DTR''s CA. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-ca-<replica_id>` | 此卷管理颁发DTR CA所需的密钥和根信息。 |'
- en: '| `dtr-notary-<replica_id>` | This volume stores notary keys and certificates.
    |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-notary-<replica_id>` | 此卷存储公证密钥和证书。 |'
- en: '| `dtr-postgres-<replica_id>` | This volume is used by images'' vulnerability
    scanning. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-postgres-<replica_id>` | 此卷用于镜像的漏洞扫描。 |'
- en: '| `dtr-registry-<replica_id>` and `dtr-nfs-registry-<replica_id>` | A registry''s
    data is stored on this volume. This is the default option, but we are able to
    integrate third-party storage. In fact, shared storage will be required to provide
    DTR processes with high availability. `dtr-nfs-registry-<replica_id>` will be
    used if the storage''s backend is NFS. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-registry-<replica_id>` 和 `dtr-nfs-registry-<replica_id>` | 注册表的数据存储在此卷中。这是默认选项，但我们可以集成第三方存储。实际上，共享存储将是提供DTR进程高可用性的必要条件。如果存储后端是NFS，则将使用`dtr-nfs-registry-<replica_id>`。
    |'
- en: '| `dtr-rethink-<replica_id>` | This volume stores repository information. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `dtr-rethink-<replica_id>` | 此卷存储仓库信息。 |'
- en: DTR's data storage is key because this is where images will live. Take care
    of your images' layers because DTR's backup does not back up their data and meta-information.
    You have to deploy your own backup to be able to restore your images' data.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: DTR的数据存储非常重要，因为这里是镜像存放的地方。请注意镜像的层，因为DTR的备份不会备份它们的数据和元信息。你必须部署自己的备份，以便能够恢复镜像数据。
- en: 'DTR can be deployed either on-premises or in the cloud. We can use Amazon,
    Google, or Microsoft Azure. It supports the following storage backends:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DTR可以部署在本地或云中。我们可以使用Amazon、Google或Microsoft Azure。它支持以下存储后端：
- en: NFS
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NFS
- en: Amazon S3
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon S3
- en: Cleversafe
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cleversafe
- en: Google Cloud Storage
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Cloud Storage
- en: OpenStack Swift
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OpenStack Swift
- en: Microsoft Azure
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Microsoft Azure
- en: We can use any S3 object's storage-compatible solution (Minio, for example).
    Object storage works great with an image's data if we have big layers with a lot
    of content.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用任何与S3对象存储兼容的解决方案（例如Minio）。对象存储非常适合存储镜像的数据，尤其是当我们有包含大量内容的大镜像层时。
- en: DTR provides image caching for multi-site environments where communication latency
    between users and the registry can become a problem. Image caching will be used
    to ensure that users get the required images from the nearest registry node.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 提供了多站点环境下的镜像缓存功能，在这种环境下，用户与注册表之间的通信延迟可能成为问题。镜像缓存将确保用户从最近的注册表节点获取所需的镜像。
- en: RBAC is provided with DTR as it is in UCP. Both applications can be integrated
    to have a single sign-on solution, but RBAC is independent. DTR will forward authentication
    to UCP and this will verify a user's authentication, but each application will
    manage different roles and profiles. This way, a UCP's power user can have limited
    access to images in DTR.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与 UCP 一样，DTR 提供了基于角色的访问控制（RBAC）。这两个应用可以集成在一起，实现单点登录解决方案，但 RBAC 是独立的。DTR 将身份验证转发给
    UCP，UCP 会验证用户的身份，但每个应用会管理不同的角色和配置文件。通过这种方式，UCP 的高级用户可以对 DTR 中的镜像进行有限的访问。
- en: Security in DTR is based on image security scanning and Docker Content Trust.
    Image security scanning will search for an image's content vulnerabilities using
    binaries' and libraries' **bills of materials** (**BOMs**). A **Common Vulnerabilities
    and Exposures** (**CVE**) database is used to search for well-known issues in
    our images.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 的安全性基于镜像安全扫描和 Docker 内容信任。镜像安全扫描将通过二进制文件和库的**物料清单**（**BOMs**）来查找镜像内容中的漏洞。**常见漏洞与暴露**（**CVE**）数据库用于查找我们镜像中已知的问题。
- en: A BOM is a detailed list of all the files present inside an image. A CVE database
    is a public database of well-known vulnerabilities found in files around the world.
    It is community-driven and there are many contributors reporting and looking for
    vulnerabilities in applications' code.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: BOM 是镜像中所有文件的详细清单。CVE 数据库是一个公开的数据库，列出了世界各地文件中已知的漏洞。它是由社区驱动的，许多贡献者在报告和寻找应用程序代码中的漏洞。
- en: DTR also includes image promotion and task scheduling. These features allow
    us to monitor image tagging and security to trigger different modifications or
    interactions with either external or DTR-integrated tools.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 还包括镜像促销和任务调度。这些功能允许我们监控镜像标签和安全性，以触发与外部工具或 DTR 集成工具的不同修改或交互。
- en: Repository mirroring and caching will help us to integrate DTR in enterprise
    environments.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库镜像和缓存将帮助我们将 DTR 集成到企业环境中。
- en: We will learn how to deploy DTR with high availability in the next section.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节学习如何部署具有高可用性的 DTR。
- en: Deploying DTR with high availability
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署具有高可用性的 DTR
- en: Deploying DTR with high availability requires more than one replica executing
    all DTR components. We will deploy an odd number of replicas to ensure high availability.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 部署具有高可用性的 DTR 需要执行所有 DTR 组件的多个副本。我们将部署奇数个副本以确保高可用性。
- en: DTR should be deployed on dedicated worker nodes. This will ensure that none
    of the non-system processes will impact DTR's behavior and vice versa. DTR's processes
    can take a lot of CPU during scanning and other procedures. Therefore, we will
    use three dedicated worker nodes. We usually admit DHCP on worker nodes, but we
    will ask for fixed IP addresses on DTR's worker nodes. We will also require fixed
    hostnames.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 应部署在专用工作节点上。这将确保非系统进程不会影响 DTR 的行为，反之亦然。DTR 在扫描和其他过程中的进程可能会占用大量 CPU。因此，我们将使用三个专用工作节点。我们通常允许工作节点使用
    DHCP，但我们将要求 DTR 的工作节点使用固定 IP 地址。我们还需要固定的主机名。
- en: We can deploy the Docker Enterprise platform on-premises or in the cloud. DTR
    requirements were described in brief in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml),
    *Universal Control Plane*.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 Docker Enterprise 平台部署在本地或云端。[第 11 章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)，*通用控制平面*
    中简要描述了 DTR 的要求。
- en: 'To deploy DTR on dedicated workers, these nodes require at least the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 要在专用工作节点上部署 DTR，这些节点至少需要满足以下要求：
- en: 16 GB of RAM
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 16 GB 内存
- en: 2 vCPUs (virtual CPUs)
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2 个 vCPU（虚拟 CPU）
- en: 'For production, we will ask for bigger nodes with more resources:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 对于生产环境，我们将要求使用更大配置的节点，提供更多的资源：
- en: 32 GB of RAM
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 32 GB 内存
- en: 4 vCPUs
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 4 个 vCPU
- en: This increment of hardware resources is due to image-scanning features. This
    will take a bunch of CPU and memory resources because it will load the content
    of all images and create all binary and library `md5-checksum-hashes` to compare
    these values against the CVE database.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 由于镜像扫描功能，硬件资源的增加是必需的。这将消耗大量的 CPU 和内存资源，因为它需要加载所有镜像的内容并创建所有二进制文件和库的 `md5-checksum-hashes`，以便将这些值与
    CVE 数据库进行对比。
- en: An image's data will be downloaded by default in the `dtr-registry-<REPLICA_ID>`
    volume. If you deploy a standalone replica for testing, for example, ensure that
    you have sufficient space for your images. A minimum of 25 GB is required, but
    we recommend having at least 500 GB if you plan to manage Microsoft Windows images.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，镜像的数据将下载到 `dtr-registry-<REPLICA_ID>` 卷中。例如，如果您部署了一个独立的副本进行测试，请确保您有足够的空间来存储镜像。最低要求为
    25 GB，但如果您计划管理 Microsoft Windows 镜像，建议至少拥有 500 GB 的空间。 |
- en: At the time of writing this book, the latest DTR release is 2.7.6\. We will
    first install a DTR replica. Once the first replica is installed, we will join
    two other replicas. We recommend that you configure the first replica before continuing
    with others. This will ensure the synchronization of configuration changes between
    replicas. This is important for configuring DTR's data storage.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写本书时，最新的 DTR 版本是 2.7.6。我们将首先安装一个 DTR 副本。安装第一个副本后，我们将加入另外两个副本。我们建议在继续其他副本之前先配置第一个副本。这将确保副本之间配置变化的同步。这对于配置
    DTR 的数据存储非常重要。 |
- en: If we configured a license on UCP, this will be copied to the DTR. If not, we
    will need to configure it in both environments.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在 UCP 上配置了许可证，则该许可证将被复制到 DTR。如果没有，我们需要在两个环境中进行配置。 |
- en: 'As we have seen in Docker''s UCP installation, `installation-container` will
    have many actions associated with it, such as `backups`/`restore`, `install`,
    and `join`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Docker 的 UCP 安装中所看到的，`installation-container` 将有许多相关的操作，如 `backups`/`restore`、`install`
    和 `join`： |
- en: '| **Command** | **Action** |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **操作** |'
- en: '| `install` | DTR will be installed using the `docker/dtr` image. We will launch
    this process from any UCP node because the UCP URL will be used and the process
    will be executed from manager nodes once the connection is established. |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| `install` | DTR 将使用 `docker/dtr` 镜像进行安装。我们将从任何 UCP 节点启动此过程，因为 UCP URL 将被使用，并且一旦连接建立，过程将从管理节点执行。
    |'
- en: '| `join` | We will execute more than one DTR replica to provide high availability.
    In this case, we will install the first replica and then we will join others to
    this one. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| `join` | 我们将执行多个 DTR 副本以提供高可用性。在这种情况下，我们将首先安装第一个副本，然后将其他副本加入到该副本中。 |'
- en: '| `reconfigure` | We can modify DTR configurations using the DTR image. Some
    configurations require restarting. We will configure DTR replicas to avoid downtime.
    |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| `reconfigure` | 我们可以使用 DTR 镜像修改 DTR 配置。有些配置需要重启。我们将配置 DTR 副本以避免停机。 |'
- en: '| `remove` | Sometimes, we need to remove a number of DTR replicas. We will
    use the `remove` action, available in the `docker/dtr` image, to delete replicas
    from the DTR environment. This action will neatly remove replicas, updating other
    replicas about this change. |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| `remove` | 有时我们需要移除多个 DTR 副本。我们将使用 `docker/dtr` 镜像中的 `remove` 操作来删除 DTR 环境中的副本。此操作将整洁地移除副本，并更新其他副本关于此变化的信息。
    |'
- en: '| `destroy` | This command will be used to forcefully remove all DTR replicas''
    containers and volumes. This procedure should be used with care because replica
    removal is forced and does not inform others about this condition, meaning that
    a cluster can be left in an unhealthy state. Use this option to completely remove
    DTR from your cluster. |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '| `destroy` | 此命令将用于强制删除所有 DTR 副本的容器和卷。此过程应谨慎使用，因为副本删除是强制的，且不会通知其他副本这一变化，这意味着集群可能会处于不健康状态。使用此选项可以完全从集群中删除
    DTR。 |'
- en: '| `backup`/`restore` | This command creates a TAR file with all the information
    and files required to restore a DTR replica, including non-image volumes and configurations.
    This will not back up an image''s data layers. An image''s data must be stored
    using third-party tools. Take care with this because you should be able to restore
    your DTR cluster to a running state, but you could lose all your images. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| `backup`/`restore` | 此命令将创建一个 TAR 文件，其中包含恢复 DTR 副本所需的所有信息和文件，包括非镜像卷和配置。这不会备份镜像的数据层。镜像的数据必须使用第三方工具存储。请小心，因为您应该能够恢复您的
    DTR 集群到运行状态，但可能会丢失所有镜像。 |'
- en: '| `upgrade` | The `upgrade` option will help us to automatically deploy platform
    upgrades. All DTR components will be updated to a defined upgrade release. If
    we have deployed DTR with high availability, this process should not impact our
    users. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| `upgrade` | `upgrade` 选项将帮助我们自动部署平台升级。所有 DTR 组件将更新到定义的升级版本。如果我们已部署高可用性 DTR，这个过程应该不会影响用户。
    |'
- en: '| `images` | We can download DTR''s required images prior to installation.
    This is very useful, for example, when we have to execute an offline installation.
    We will download DTR images using a Docker Engine instance with internet access.
    |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `images` | 我们可以在安装之前下载 DTR 所需的镜像。这非常有用，例如，在我们必须执行离线安装时。我们将使用具有互联网访问权限的 Docker
    Engine 实例来下载 DTR 镜像。 |'
- en: '| `emergency-repair` | When all the replicas of DTR are unhealthy, but one
    replica is running with healthy core processes, we will use the `emergency-repair`
    action with this replica to recover the cluster. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `emergency-repair` | 当所有 DTR 副本都不健康，但有一个副本正在运行并且核心进程健康时，我们将使用 `emergency-repair`
    操作来修复集群。 |'
- en: 'We will usually have the following common arguments for the majority of the
    actions:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常会为大多数操作使用以下常见参数：
- en: '| **Arguments** | **Actions** |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| **参数** | **操作** |'
- en: '| `--ucp-url` | This should be our valid UCP''s URL. We will use the cluster''s
    **Fully Qualified Domain Name** (**FQDN**) and port (`443` by default). |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `--ucp-url` | 这应该是我们有效的 UCP URL。我们将使用集群的 **完全限定域名**（**FQDN**）和端口（默认是 `443`）。
    |'
- en: '| `--ucp-ca`and `--ucp-insecure-tls` | We will choose either of these options,
    using UCP''s valid CA or insecure TLS, avoiding any CA authentication. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `--ucp-ca` 和 `--ucp-insecure-tls` | 我们将选择其中一个选项，使用 UCP 的有效 CA 或不安全的 TLS，避免任何
    CA 认证。 |'
- en: '| `--ucp-username`and `--ucp-password` | These options will provide UCP''s
    user authentication. If none are used, we will be asked for them during execution.
    These should be valid and must have administrator privileges. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `--ucp-username` 和 `--ucp-password` | 这些选项将提供 UCP 用户认证。如果没有使用这些选项，执行过程中将会要求输入。它们必须有效且具有管理员权限。
    |'
- en: Always use the appropriate `docker/dtr:<RELEASE>` version for all actions. Do
    not mix releases unless you are doing a DTR upgrade. The current release, at the
    time of writing this book, is 2.7.6.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 始终使用适当的 `docker/dtr:<RELEASE>` 版本进行所有操作。除非您正在进行 DTR 升级，否则不要混用不同的版本。本书写作时的当前版本是
    2.7.6。
- en: DTR installation requires UCP's URL and one administrator's username and password.
    We can use these interactively, but as we learned in previous sections, it is
    preferable to include installation as part of script-like structures. This will
    help us to provide a reproducible configuration and installation methodology.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 安装需要 UCP 的 URL 和一个管理员的用户名及密码。我们可以交互式地使用它们，但正如我们在前面的章节中所学的，最好将安装作为脚本结构的一部分。这将帮助我们提供可复现的配置和安装方法。
- en: 'We will now describe DTR''s installation process. The first replica will be
    installed using `docker container run docker/dtr:<RELEASE> install`. We will launch
    the installation process from any cluster node. In fact, we can deploy DTR from
    our laptop because we will include UCP''s URL and the administrator''s username
    and password. Installation can be done using an interactive or automated process.
    We will also choose which UCP node will run the first replica''s processes using
    `--ucp-node`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将描述 DTR 的安装过程。第一个副本将通过 `docker container run docker/dtr:<RELEASE> install`
    命令安装。我们将在任何集群节点上启动安装过程。实际上，我们可以从笔记本电脑上部署 DTR，因为我们会提供 UCP 的 URL 以及管理员的用户名和密码。安装可以通过交互式或自动化过程完成。我们还将选择哪个
    UCP 节点将运行第一个副本的进程，使用 `--ucp-node`：
- en: '[PRE0]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Since DTR's installation process will connect to UCP's API, TLS will be used,
    and certificates will be sent. We added UCP's CA to validate its certificates.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 DTR 的安装过程将连接到 UCP 的 API，TLS 将被使用，并且证书将被发送。我们已将 UCP 的 CA 添加到验证其证书。
- en: Once the first replica is installed, we will configure and then join other replicas.
    It is important to configure shared storage and other settings if you have not
    changed them during the installation process.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦第一个副本安装完成，我们将进行配置，然后加入其他副本。如果在安装过程中没有更改共享存储和其他设置，配置这些内容非常重要。
- en: Notice the last line of the installation's output. It shows the `You can use
    flag '--existing-replica-id c8a9ec361fde' when joining other replicas to your
    Docker Trusted Registry Cluster` text message. Keep this replica's ID; we will
    use it for reconfiguring it and joining other replicas.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意安装输出的最后一行。它显示了 `You can use flag '--existing-replica-id c8a9ec361fde' when
    joining other replicas to your Docker Trusted Registry Cluster` 这段文字。请记住这个副本的
    ID；我们将在重新配置它并加入其他副本时使用它。
- en: 'We can configure the shared storage we need to execute the `reconfigure` action.
    We can use either filesystem or object storage types:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置需要执行 `reconfigure` 操作的共享存储。我们可以使用文件系统或对象存储类型：
- en: '**Filesystem storage types**: **Network File System** (**NFS**), bind mount,
    and volume'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件系统存储类型**：**网络文件系统**（**NFS**）、绑定挂载和卷'
- en: '**Object storage (cloud) types**: Amazon S3, Openstack''s Swift, Microsoft
    Azure, and Google Cloud Storage'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对象存储（云）类型**：Amazon S3、Openstack 的 Swift、Microsoft Azure 和 Google Cloud Storage'
- en: 'Object storage and NFS are valid options for shared storage. Each cloud provider
    will require its own specifications. Common parameters will be the user or account
    name, password, and bucket. Object storage is the preferred option for DTR shared
    image storage. There are some on-premises solutions, such as Minio, that are easy
    to implement in our data center. NFS is also valid and it is quite common in current
    data centers. In this case, we will use the `--nfs-storage-url` parameter with
    the `reconfigure` action. `nfs-storage-url` will require the following format:
    `nfs://<ip|hostname>/<mountpoint>`.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对象存储和 NFS 都是有效的共享存储选项。每个云服务提供商会要求不同的规格。常见的参数包括用户名或账户名、密码和桶名。对象存储是 DTR 共享镜像存储的首选选项。有一些本地解决方案，如
    Minio，容易在我们的数据中心实现。NFS 也是有效的选项，并且在当前的数据中心中非常常见。在这种情况下，我们将使用 `--nfs-storage-url`
    参数与 `reconfigure` 操作。`nfs-storage-url` 将要求以下格式：`nfs://<ip|hostname>/<mountpoint>`。
- en: DTR's storage backend configuration can also be managed using YAML format.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 的存储后端配置也可以使用 YAML 格式进行管理。
- en: Many DTR options can be set using environment variables. To review available
    variables, execute `docker container run docker/dtr:<RELEASE> <ACTION> --help`
    to retrieve an action's help. Variables will be shown on each argument or option.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 DTR 选项可以通过环境变量进行设置。要查看可用的变量，执行 `docker container run docker/dtr:<RELEASE>
    <ACTION> --help` 来获取操作的帮助。变量将在每个参数或选项上显示。
- en: Joining replicas will provide high availability to DTR's processes. Replication
    requires external storage for sharing images' blobs (data layers) and meta-information.
    Therefore, we will reconfigure the first replica's storage if we did not choose
    shared storage during installation. We have the first replica's ID and we will
    use `docker/dtr:<RELEASE> reconfigure --existing-replica-id <FIRST_REPLICA'S_ID>`
    to reconfigure the storage's backend. In this example, we will just use NFS, which
    is common in our data centers.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 加入副本将为 DTR 的进程提供高可用性。复制需要外部存储以共享镜像的 blob（数据层）和元信息。因此，如果在安装时没有选择共享存储，我们将重新配置第一个副本的存储。我们已经有了第一个副本的
    ID，将使用 `docker/dtr:<RELEASE> reconfigure --existing-replica-id <FIRST_REPLICA'S_ID>`
    来重新配置存储后端。在此示例中，我们将仅使用 NFS，这是我们数据中心常见的配置。
- en: Before executing the storage's configuration, we will copy the registry volume's
    data into our NFS filesystem.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行存储配置之前，我们将把注册表卷的数据复制到我们的 NFS 文件系统中。
- en: 'The following lines provide us with a quick example of this migration mounting
    NFS endpoint as a local directory on DTR''s host (we have used a sample IP address
    and the ID of the replica created previously):'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下几行展示了将 NFS 端点作为本地目录挂载到 DTR 主机上的快速示例（我们使用了一个示例 IP 地址和先前创建的副本 ID）：
- en: '[PRE1]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This step will guarantee previous data if we use `--storage-migrated` with the
    `reconfigure` action. If you are using NFS as a local volume, you should guarantee
    that it is mounted on reboot using the appropriate line in your `fstab` file.
    This was just an example. We will never use NFS locally mounted for DTR; we can
    use NFS directly, using appropriate command-line options, to mount an NFS endpoint
    as a DTR volume.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步将确保如果我们在使用 `--storage-migrated` 和 `reconfigure` 操作时，之前的数据不会丢失。如果您将 NFS 用作本地卷，应该确保它在重启时能够通过在
    `fstab` 文件中添加适当的行进行挂载。这只是一个示例。我们不会在 DTR 中使用本地挂载的 NFS；我们可以直接使用 NFS，通过适当的命令行选项，将
    NFS 端点挂载为 DTR 卷。
- en: 'The following screenshot shows Amazon''s S3 options integrated in DTR''s web
    UI. Each backend type will integrate different options:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图展示了 Amazon S3 选项集成在 DTR 的 Web UI 中。每种后端类型将集成不同的选项：
- en: '![](img/d58a7bc5-662f-4efe-b0c8-444c997bf89e.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d58a7bc5-662f-4efe-b0c8-444c997bf89e.jpg)'
- en: 'We have used variables for command parameters, but we have left the command''s
    output intact because it is interesting how NFS and the current replica''s ID
    are present:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已使用变量作为命令参数，但我们保留了命令的输出，因为它展示了 NFS 和当前副本的 ID 信息：
- en: '[PRE2]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Notice the `--storage-migrated` argument. If we migrate storage after the creation
    of a number of repositories, all this work will be lost if we do not migrate the
    registry volume's data. In this case, we have just copied the volume's content.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `--storage-migrated` 参数。如果我们在创建多个仓库后迁移存储，如果没有迁移注册表卷的数据，所有的工作将会丢失。在这种情况下，我们只复制了卷的内容。
- en: 'Now that we have a shared registry''s storage backend, we can join new replicas.
    We will use the current replica''s ID because new replicas require a base replica
    to sync with. We will use the `join` action on any cluster node because we will
    select another worker node for this replica (we have mocked our example using
    `<NEW_UCP_NODE>`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了共享注册表的存储后端，我们可以加入新的副本。我们将使用当前副本的 ID，因为新的副本需要一个基础副本来同步。我们将在任何集群节点上使用 `join`
    操作，因为我们将为这个副本选择另一个工作节点（我们已经用 `<NEW_UCP_NODE>` 模拟了我们的例子）：
- en: '[PRE3]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All values apart from the first replica's ID were mocked and the outputs of
    the `join` command have been reduced for this book. Notice that we have used `--ucp-insecure-tls`
    instead of adding UCP's CA. After `183` steps, the new replica was joined. At
    least three replicas are required for high availability. All replicas are deployed
    as multi-container applications on defined worker nodes.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 除了第一个副本的 ID 外，所有其他值都被模拟了，`join` 命令的输出也已简化。请注意，我们使用了 `--ucp-insecure-tls` 而不是添加
    UCP 的 CA。在执行了 `183` 步之后，新的副本已成功加入。至少需要三个副本才能保证高可用性。所有副本都作为多容器应用部署在定义好的工作节点上。
- en: Starting in DTR 2.6, you should perform a backup before switching storage drivers.
    This ensures that your images will be preserved if you decide to switch back to
    your current storage driver.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 从 DTR 2.6 版本开始，在切换存储驱动程序之前，您应该先执行备份。这确保了如果您决定切换回当前的存储驱动程序，您的镜像将被保留。
- en: 'DTR will expose its API securely, using TLS. Therefore, certificates will be
    used to create secure tunnels. By default, DTR will create a CA to sign server
    certificates. We can use our corporation''s private or public certificates. They
    can be applied during installation using `--dtr-ca` and `--dtr-cert`, but we can
    change them later in DTR''s web UI or by using the `reconfigure` action. If you
    used your custom certificate, your certificate will probably be included in your
    system. If Docker created auto-signed certificates for us, these will not be trusted
    in your system. Docker created a CA for use to sign DTR certificates and you will
    probably get the following error message when you try to execute any registry
    action from your command line:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 将安全地公开其 API，使用 TLS 协议。因此，证书将用于创建安全的隧道。默认情况下，DTR 会创建一个 CA 来签署服务器证书。我们可以使用公司私有或公有证书。它们可以在安装过程中通过
    `--dtr-ca` 和 `--dtr-cert` 参数进行应用，但我们也可以稍后在 DTR 的 Web UI 或通过使用 `reconfigure` 操作进行更改。如果您使用了自定义证书，您的证书可能会包含在您的系统中。如果
    Docker 为我们创建了自动签名的证书，这些证书在您的系统中将不被信任。Docker 创建了一个 CA 来签署 DTR 证书，当您尝试从命令行执行任何注册表操作时，您可能会看到以下错误信息：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To avoid this issue, we can either avoid SSL verification, define an insecure
    registry, or add DTR''s CA as trusted on our system:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这个问题，我们可以选择不验证 SSL，定义不安全的注册表，或者将 DTR 的 CA 添加为受信任的证书：
- en: '**Insecure registry**: To set up an insecure registry for our client, we will
    add `"insecure-registries" : ["<DTR_FQDN>[:DTR_PORT]"]` to our Docker Engine `daemon.json`
    file. This is not recommended and should be avoided in production because someone
    could hijack our server''s identity.'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**不安全的注册表**：要为我们的客户端设置一个不安全的注册表，我们将在 Docker 引擎的 `daemon.json` 文件中添加 `"insecure-registries"
    : ["<DTR_FQDN>[:DTR_PORT]"]`。这不推荐在生产环境中使用，因为有人可能会劫持我们的服务器身份。'
- en: '**Adding DTR''s CA to our system**: This procedure may change depending on
    the Docker Engine host''s operating system. We will describe procedures for Ubuntu/Debian
    and Red Hat/CentOS nodes. They are very common in our data centers:'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**将 DTR 的 CA 添加到我们的系统中**：这个过程可能会根据 Docker 引擎主机的操作系统有所不同。我们将描述 Ubuntu/Debian
    和 Red Hat/CentOS 节点的操作流程。它们在我们的数据中心中非常常见：'
- en: '[PRE5]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Including DTR's CA in our client systems is the preferred method because we
    will still validate its certificates.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 将 DTR 的 CA 添加到我们的客户端系统中是首选方法，因为我们仍然会验证其证书。
- en: We can log in to DTR's web UI using the defined DTR's URL. Since login is integrated
    with UCP by default, redirections will be integrated into this process and UCP
    will authorize users.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用定义好的 DTR URL 登录到 DTR 的 Web UI。由于默认情况下登录集成了 UCP，重定向将会整合到这个过程中，并且 UCP 将授权用户。
- en: 'The following screenshot shows DTR''s main interface once we are logged in.
    Repositories will be shown in a tree-like structure. Users will only have access
    to their resources:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们登录后 DTR 的主界面。仓库将以树形结构展示，用户只能访问自己的资源：
- en: '![](img/3f47db5f-1391-4c0f-b25d-39b447b06396.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3f47db5f-1391-4c0f-b25d-39b447b06396.jpg)'
- en: 'DTR''s web UI is quite simple. It allows administrators to manage users, teams,
    organizations, and RBAC integrations. The following is a screenshot of the system''s
    endpoint:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 的 Web UI 非常简单。它允许管理员管理用户、团队、组织和 RBAC 集成。以下是系统端点的截图：
- en: '![](img/bd8254c4-7514-475b-b57a-1e40a1076318.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bd8254c4-7514-475b-b57a-1e40a1076318.jpg)'
- en: 'The system''s endpoint provides access to the following resources and configurations:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的端点提供对以下资源和配置的访问：
- en: '**The General tab**:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**常规标签**：'
- en: Allows us to manage DTR's license.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们管理 DTR 的许可证。
- en: DTR's load-balanced URL.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTR 的负载均衡 URL。
- en: Integration of corporate proxies to download the required image-scanning CVE
    database.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成企业代理以下载所需的镜像扫描 CVE 数据库。
- en: Single sign-on integration within UCP and DTR.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: UCP 和 DTR 之间的单点登录集成。
- en: Configures browser cookies for clients. This will help us to forward requests
    to specific DTR backends.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置客户端的浏览器 cookies。这将帮助我们将请求转发到特定的 DTR 后端。
- en: Allows us to set whether repositories can be created on push. This allows users
    to push images, and repositories will automatically be created if they do not
    exist.
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许我们设置是否可以在推送时创建仓库。这使得用户可以推送镜像，如果仓库不存在，将自动创建该仓库。
- en: '**The Storage tab**: This tab allows us to configure all of DTR''s storage
    backends. We can choose between filesystem or object storage (cloud), and each
    backend will have different options.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储标签**：此标签允许我们配置所有 DTR 的存储后端。我们可以在文件系统存储和对象存储（云）之间进行选择，每个后端会有不同的选项。'
- en: '**The Security tab**: Security is key for images. This tab allows us to configure
    DTR''s image-scanning features.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全标签**：安全对于镜像至关重要。此标签允许我们配置 DTR 的镜像扫描功能。'
- en: '**The Garbage collection tab**: Untagged images consume space and will increase
    the risk if some use non-referenced layers. This tab allows us to schedule the
    automatic removal of untagged images.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垃圾回收标签**：未标记的镜像占用空间，如果某些镜像使用了非引用的层，还会增加风险。此标签允许我们安排自动删除未标记镜像。'
- en: '**The Job logs tab**: The logs of internal tasks can be reviewed on this tab.
    This log will show us information regarding mirroring and image pruning, among
    other internal features.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作业日志标签**：可以在此标签中查看内部任务的日志。该日志将显示与镜像同步和镜像修剪等内部功能的信息。'
- en: The following section will show us how to manage different access to consume
    images stored in your DTR repositories.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将展示如何管理不同的访问权限，以使用存储在 DTR 仓库中的镜像。
- en: Learning about RBAC
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 RBAC
- en: DTR provides a complete RBAC environment. DTR will authenticate and authorize
    valid users. We can integrate third-party authentication solutions as we learned
    in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal Control
    Plane*. Integrating external **Lightweight Directory Access Protocol** (**LDAP**)/**Active
    Directory** (**AD**) authentication mechanisms will allow us to delegate users'
    passwords to them, while UCP and DTR will manage user authorization.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 提供了一个完整的 RBAC 环境。DTR 将对有效用户进行身份验证和授权。我们可以集成第三方身份验证解决方案，如在[第 11 章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)
    *通用控制平面* 中所学的那样。集成外部的 **轻量级目录访问协议**（**LDAP**）/**活动目录**（**AD**）身份验证机制将允许我们将用户密码委托给他们，而
    UCP 和 DTR 将管理用户授权。
- en: By default, DTR redirects user authentications to UCP because single sign-on
    is included. We can change this behavior in the System | General menu. It is recommended
    to keep this setting so as to manage users in just one application. All authentication
    will be delegated to UCP and this will route users to its integrated third-party
    authentication mechanism (if configured).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，DTR 会将用户身份验证重定向到 UCP，因为包括了单点登录。我们可以在系统 | 常规菜单中更改此行为。建议保持此设置，以便仅在一个应用程序中管理用户。所有身份验证将委托给
    UCP，并且此设置将用户路由到其集成的第三方身份验证机制（如果已配置）。
- en: Once we are authenticated to the DTR environment, we will get different permissions
    to allow us to manage images from repositories or just pull different releases
    from them.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们通过身份验证进入 DTR 环境，我们将获得不同的权限，允许我们管理来自仓库的镜像或仅从中拉取不同的版本。
- en: By default, anonymous users will be able to pull images from public repositories.
    You must ensure that only allowed images are stored in public repositories.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，匿名用户将能够从公共仓库中拉取镜像。您必须确保只有允许的镜像存储在公共仓库中。
- en: We can create users on either UCP or DTR because, by default, we will have a
    single sign-on environment and users will be shared between both applications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在 UCP 或 DTR 上创建用户，因为默认情况下，我们将拥有一个单点登录环境，用户将在这两个应用程序之间共享。
- en: 'Users are managed in teams and organizations, as we also learned in [Chapter
    11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal Control Plane*. These
    allow us to integrate teams into organizations, while users will be integrated
    in those teams:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 用户在团队和组织中进行管理，正如我们在[第11章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)《通用控制平面》中所学的那样，*通用控制平面*。这允许我们将团队整合到组织中，同时用户会被分配到这些团队中：
- en: '**Organizations** will provide a logical level of abstraction and isolation.
    They allow us to namespace other resources.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组织**将提供一个逻辑层次的抽象和隔离。它们允许我们为其他资源命名空间。'
- en: '**Teams** will allow us to assign user access to repositories.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队**将允许我们为仓库分配用户访问权限。'
- en: Users will be integrated into organizations and teams. These allow us to restrict
    access to images within organizations and with the permissions and allowed actions
    given using teams.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用户将被整合到组织和团队中。这使我们能够限制组织内镜像的访问权限，并使用团队赋予的权限和允许的操作。
- en: 'Repositories'' accesses are managed by two concepts:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的访问权限由两个概念管理：
- en: '**Ownership**: Repository creators'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**所有权**：仓库创建者'
- en: '**Public accessibility**: Public or private repositories'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公共可访问性**：公共或私人仓库'
- en: Owners of repositories can decide about access for others. As has been mentioned,
    we can have public and private images.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库的所有者可以决定其他用户的访问权限。如前所述，我们可以有公共和私有镜像。
- en: Private repositories can only be consumed by owners and DTR administrators.
    Other users cannot pull images from these repositories. Only repositories' owners
    can push images to them.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 私人仓库只能由所有者和 DTR 管理员使用。其他用户无法从这些仓库拉取镜像。只有仓库的所有者才能将镜像推送到这些仓库。
- en: Within organizations, we will provide read and write access for specific teams
    in an organization's private repositories. These teams will be able to push images
    to these repositories. These teams are owners of these repositories and we can
    provide read-only access to some teams. They will only be able to pull images.
    All other teams will not have any access because we are talking about an organization's
    private repositories.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在组织内部，我们将为特定团队提供对组织私人仓库的读写权限。这些团队将能够将镜像推送到这些仓库。这些团队是这些仓库的所有者，我们可以为某些团队提供只读权限。它们只能拉取镜像。其他所有团队将无法访问，因为我们讨论的是组织的私人仓库。
- en: Public repositories are different. Users' public repositories allow other users
    to pull images from them, while only owners are able to push. They have read-write
    access. An organization's public repositories will allow users to also pull images.
    In these cases, only teams with read-write access will be allowed to push images.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 公共仓库是不同的。用户的公共仓库允许其他用户从中拉取镜像，而只有仓库所有者才能推送镜像。它们具有读写权限。一个组织的公共仓库将允许用户同样拉取镜像。在这些情况下，只有具有读写权限的团队才能推送镜像。
- en: 'The following table represents permissions that can be applied to repositories:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 下表表示可以应用于仓库的权限：
- en: '| **Permissions** | **Description** |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| **权限** | **描述** |'
- en: '| **Read-only** | A user can browse/search and pull images from a repository.
    Users will not be able to push to this repository. |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **只读权限** | 用户可以浏览/搜索并从仓库中拉取镜像。用户无法向该仓库推送镜像。 |'
- en: '| **Read and write** | A user can browse/search, pull, and push images to a
    repository. |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| **读写权限** | 用户可以浏览/搜索、拉取和推送镜像到仓库。 |'
- en: '| **Owner** | The owner has read-write access to their repositories, but they
    are also allowed to manage their permissions and descriptions. They can also set
    a repository''s privacy level (public/private). |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| **所有者** | 所有者对其仓库具有读写权限，但他们也可以管理其权限和描述。还可以设置仓库的隐私级别（公共/私有）。 |'
- en: Organizations' members have read-only access to public images within this organization.
    Therefore, an organization's users can always pull their public images. Organizations'
    members can see other members and view all teams included within their organization.
    But we need to integrate users within an organization's teams to provide management
    and read-write access.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的成员对该组织的公共镜像具有只读访问权限。因此，组织的用户始终可以拉取其公共镜像。组织的成员可以看到其他成员并查看组织内所有团队。但是，我们需要将用户整合到组织的团队中，以便提供管理和读写权限。
- en: An organization's members who are not included in any team cannot manage an
    organization's repositories. They can only pull its public images.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 组织的成员如果未加入任何团队，则无法管理组织的仓库。他们只能拉取其公共镜像。
- en: An organization's owners, on the other hand, will be able to manage the organization
    and all its repositories. We can include any user within an organization as an
    owner. These users can also manage teams within an organization and their level
    of access.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，组织的所有者将能够管理该组织及其所有仓库。我们可以将任何用户包括在组织内作为所有者。这些用户还可以管理组织内的团队及其访问级别。
- en: We will use a simple example to help you understand how permissions and access
    will be given to users in different repositories.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的示例帮助你理解如何在不同仓库中为用户分配权限和访问。
- en: Let's imagine an organization named **myorganization**. Let's include a team
    for **devops** and others for **developers** and **operations**. In this example,
    the **devops** team will define core images, while **developers** will use them
    for their applications.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个名为 **myorganization** 的组织。让我们为 **devops** 团队和其他 **开发人员** 和 **运维** 团队创建一个示例。在这个示例中，**devops**
    团队将定义核心图像，而 **开发人员** 将使用这些图像来构建他们的应用程序。
- en: '**devops** group members will have read-write access, while **developers**
    will have read-only access. These will just pull images to create their own ones.
    They will use enterprise-defined core images, created by the **devops** team.
    In this case, the **operations** team does not have access to these application
    core images.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '**devops** 组成员将拥有读写权限，而 **开发人员** 将拥有只读权限。他们只会拉取图像来创建自己的图像。他们将使用 **devops**
    团队创建的企业定义的核心图像。在这种情况下，**运维** 团队无法访问这些应用程序核心图像。'
- en: 'On the other hand, the **devops** team created a series of images for testing
    the platform, under the **testing image** repository. This repository is public
    and all users within the organization will be able to use it on the Docker Enterprise
    platform. The following diagram shows the RBAC situation described:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**devops** 团队创建了一系列用于测试平台的图像，这些图像存放在 **测试图像** 仓库中。这个仓库是公开的，组织内的所有用户都可以在
    Docker Enterprise 平台上使用它。下图展示了描述的 RBAC 情况：
- en: '![](img/0e1848d9-a860-4a6f-bf67-72db259d8679.png)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0e1848d9-a860-4a6f-bf67-72db259d8679.png)'
- en: In the next section, we will review image scanning and other security features
    included in the DTR platform.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将回顾 DTR 平台中包含的图像扫描和其他安全功能。
- en: Image scanning and security features
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像扫描和安全功能
- en: In this section, we will review DTR's security features, such as security scanning
    and image signing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一部分，我们将回顾 DTR 的安全功能，如安全扫描和图像签名。
- en: Security scanning
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全扫描
- en: DTR includes image security scanning as a built-in feature. It will scan each
    image's layer for binaries and libraries. A scan report will include the aggregated
    BOM for each layer. We now have a complete picture of an image's files and its
    MD5 hashes. This ensures the immutability of each layer's content between image
    releases. If we change a file within a layer, its hash changes and scanning will
    be executed against the new layer's content. Image scanning will also download
    and manage a CVE database provided by Docker. This will be used to correlate an
    image's layer reports with the vulnerability information given.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 包含内置的图像安全扫描功能。它将扫描每个图像层中的二进制文件和库。扫描报告将包含每一层的汇总 BOM。我们现在可以完整查看图像的文件及其 MD5
    哈希值。这确保了每一层内容在图像发布之间的不可变性。如果我们更改了某一层中的文件，其哈希值会发生变化，扫描将针对新层的内容执行。图像扫描还将下载并管理 Docker
    提供的 CVE 数据库。这将用于将图像层报告与给定的漏洞信息进行关联。
- en: Scanning will show us a report regarding the health of our image, reporting
    all detected well-known vulnerabilities found on the image's layers.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描将向我们展示一份报告，关于我们图像的健康状况，报告图像层中检测到的所有已知漏洞。
- en: This CVE database should be updated frequently because new threats appear almost
    daily. We can use either online synchronization or offline manual updates. In
    both cases, we require a valid Docker Enterprise license. Online synchronization
    requires a valid internet connection (we can use our corporate's proxies within
    DTR, configuring the `--http-proxy` and/or `--https-proxy` options either on DTR's
    installation or by reconfiguring the environment following the installation process).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 CVE 数据库应该频繁更新，因为新的威胁几乎每天都会出现。我们可以使用在线同步或离线手动更新。无论哪种方式，我们都需要有效的 Docker Enterprise
    许可证。在线同步要求有效的互联网连接（我们可以在 DTR 内使用公司代理，通过在 DTR 安装时或安装后重新配置环境来配置 `--http-proxy` 和/或
    `--https-proxy` 选项）。
- en: Do not forget to use the `--no-proxy` option to configure all your enterprise's
    internal FQDNs.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记使用 `--no-proxy` 选项来配置你们企业内部的所有 FQDN。
- en: Image scanning consumes a lot of DTR's hosts' resources. In fact, the first
    security scan for each layer requires a lot of resources. Subsequent scans will
    use previous layers' reports. If an image's layer size is large, scanning will
    take a lot of resources to create the layer's report. All files' hashes should
    be included in the report to correlate them with the database's data. If we use
    common layers in our images, this process will only be executed once. A layer's
    report will be updated if we change that layer's content. That layer will become
    old and a new scan will be executed. Take care of these processes between image
    changes.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像扫描消耗大量DTR主机的资源。实际上，每层的第一次安全扫描需要大量资源。随后的扫描将使用之前层的报告。如果镜像的层大小较大，扫描将消耗大量资源来生成该层的报告。报告中应包括所有文件的哈希值，以便与数据库中的数据进行关联。如果我们在镜像中使用公共层，这个过程只会执行一次。如果我们更改该层的内容，该层的报告将被更新，该层会变得过时，并且将执行新的扫描。在镜像更改时需要注意这些过程。
- en: Scanning can be executed whenever an image is updated or created within DTR's
    registry automatically. This will be set on each repository using the Scan on
    push feature. We can periodically execute images' scans manually, but this could
    prove hard to maintain without using DTR's API.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 扫描可以在DTR注册表中每次更新或创建镜像时自动执行。这个功能将通过在每个仓库中启用“推送时扫描”来设置。我们也可以定期手动执行镜像扫描，但如果不使用DTR的API，这将很难维护。
- en: 'The image''s scanning report will be shown on each repository''s tag. We will
    have a report of the health of the image''s vulnerabilities, as can be seen in
    the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的扫描报告将显示在每个仓库的标签上。我们将获得镜像漏洞的健康报告，如下图所示：
- en: '![](img/34825d8e-f894-4155-b846-ac0a14a84639.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![](img/34825d8e-f894-4155-b846-ac0a14a84639.png)'
- en: 'The vulnerability status of the image can be as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像的漏洞状态可以如下：
- en: '**Green**: No vulnerability was found. The image is secure.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绿色**：未发现漏洞，镜像是安全的。'
- en: '**Orange**: Some minor or major vulnerabilities were found.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**橙色**：发现了一些轻微或严重的漏洞。'
- en: '**Red**: Critical vulnerabilities were found and security could be compromised.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**红色**：发现了严重漏洞，可能会危及安全。'
- en: We can dive into each tag's report by clicking on its details. We will be able
    to review the full scan results, including the image's metadata, size, owner,
    and the most recent scan.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过点击每个标签的详细信息来查看其报告。我们将能够查看完整的扫描结果，包括镜像的元数据、大小、所有者和最新扫描。
- en: 'We have two different views for a tag''s scan details:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两种不同的视图来查看标签的扫描详情：
- en: The **Layers** view will show us a list of the image's layers in the order of
    the image's construction. We will see each layer with the vulnerabilities identified
    on it. We can click on each layer to drill down into its components.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层**视图将按镜像构建的顺序显示镜像的层列表。我们将看到每一层及其上识别出的漏洞。我们可以点击每一层，深入查看其组件。'
- en: The **Components** view will list all the image's components. Components will
    be sorted according to the number of vulnerabilities identified because a file
    can have multiple issues.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**组件**视图将列出所有镜像的组件。组件将根据发现的漏洞数量进行排序，因为一个文件可能有多个问题。'
- en: We can integrate triggers to inform other processes or applications regarding
    the scanning results once they are finished.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以集成触发器，在扫描结果完成后通知其他进程或应用程序。
- en: Image immutability
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像不可变性
- en: Another interesting feature can be enabled for each image's repository. An image's
    immutability will mean that the overwriting of tags will be avoided. This will
    ensure the uniqueness of tags. This is interesting in terms of production releases.
    No one will reuse a tag that has already been used, so the development life cycle
    is not compromised because each release will have a unique ID.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能可以为每个镜像的仓库启用。镜像的不可变性意味着将避免覆盖标签。这将确保标签的唯一性。在生产发布方面，这非常有趣。没有人会重新使用已经使用过的标签，因此开发生命周期不会受到影响，因为每个发布都会有一个唯一的ID。
- en: Content trust in DTR
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DTR中的内容信任
- en: DTR has integration with **Docker Content Trust** (**DCT**). We have covered
    this topic in [Chapter 6](e9fd3807-5bbd-4ea8-84f7-ee02d288643d.xhtml), *Introduction
    to Docker Content Trust*. We learned that image signing improves cluster and application
    security, ensuring image ownership, immutability, and provenance. If we have a
    CI/CD pipeline that creates images as application artifacts, we can ensure that
    the correct image will run in production. UCP allowed us to run only signed images
    within our organization.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 与 **Docker 内容信任** (**DCT**) 集成。我们在[第6章](e9fd3807-5bbd-4ea8-84f7-ee02d288643d.xhtml)中讨论过这个话题，*Docker内容信任简介*。我们了解到，镜像签名能够提升集群和应用的安全性，确保镜像的所有权、不变性和来源。如果我们有一个生成镜像作为应用程序工件的CI/CD管道，我们可以确保在生产环境中运行的是正确的镜像。UCP允许我们只在组织内运行已签名的镜像。
- en: DTR provides a notary server and a notary signer. These components are required
    for DCT. Both application components will be accessed through an internal proxy
    and integrated with UCP's roles and access environment. This integration enables
    the signing of images that UCP can trust and execute securely.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 提供了一个公证服务器和一个公证签名者。这些组件是DCT所必需的。这两个应用程序组件将通过内部代理访问，并与UCP的角色和访问环境集成。这种集成使得我们能够签名UCP可以信任并安全执行的镜像。
- en: The Docker client will allow us to configure content trust for repositories
    and sign images. We will use a simple Docker client command line to sign images.
    The main difference in a corporate environment is that we need to ensure that
    images are signed by enterprise users. We will use our own certificates, included
    in our user's bundle. We will use `key.pem` and `cert.pem` as private and public
    keys, respectively.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Docker客户端将允许我们为仓库配置内容信任并签名镜像。我们将使用一个简单的Docker客户端命令行来签名镜像。企业环境中的主要区别在于，我们需要确保镜像是由企业用户签名的。我们将使用我们自己的证书，这些证书包含在我们的用户捆绑包中。我们将使用`key.pem`和`cert.pem`作为私钥和公钥。
- en: 'We will now describe the steps necessary for signing images in the Docker Enterprise
    environment:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将描述在Docker企业环境中签名镜像所需的步骤：
- en: 'First, we will download the user''s bundle. We have already described this
    process in [Chapter 11](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml), *Universal
    Control Plane*. Once we have our bundle in our system (already decompressed and
    ready to use), we will add a private key to our laptop''s or Docker client node''s
    trust store. We will use `docker trust load`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将下载用户的捆绑包。我们已经在[第11章](1879ea92-ae47-4230-ac84-784d4bc73185.xhtml)中描述了这个过程，*通用控制平面*。一旦我们将捆绑包下载到系统中（已经解压并准备使用），我们将把私钥添加到笔记本电脑或Docker客户端节点的信任存储中。我们将使用`docker
    trust load`：
- en: '[PRE6]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We will then initialize trust metadata for a specific repository. We should
    add ourselves as signers on each repository where we will push images. Remember
    that repositories should contain the registry''s FQDN and port. We will use the
    `docker trust signer add` command:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为特定的仓库初始化信任元数据。我们应该将自己添加为每个我们将推送镜像的仓库的签名者。记住，仓库应包含注册表的FQDN和端口。我们将使用`docker
    trust signer add`命令：
- en: '[PRE7]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With these few steps, we are ready to sign an image. Let''s review a simple
    example with an `alpine` image. We will tag our image ready for our registry and
    we will sign it using `docker trust sign`:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这几个步骤，我们准备好签名镜像了。让我们回顾一个简单的示例，使用`alpine`镜像。我们将为我们的镜像打上准备推送到注册表的标签，并使用`docker
    trust sign`进行签名：
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once signed, we can push our image to the registry. Notice that we are using
    `<DTR_FQDN>[:DTR_PORT]` as DTR''s registry:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦签名完成，我们可以将镜像推送到注册表中。请注意，我们使用`<DTR_FQDN>[:DTR_PORT]`作为DTR的注册表地址：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now have our signed image in the registry, as we can observe in the following
    screenshot:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在在注册表中有了签名的镜像，正如我们在下面的截图中所看到的：
- en: '![](img/3b868554-3c49-4786-ba85-890116e9fb18.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3b868554-3c49-4786-ba85-890116e9fb18.jpg)'
- en: 'We can review image ownership and its signatures using `docker trust inspect`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以使用`docker trust inspect`来查看镜像的所有权及其签名：
- en: '[PRE10]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We have mocked this output and other output seen in this chapter, but you will
    receive similar output. Your user should be shown under the `SIGNER KEYS` section
    (we have `<MY_USERNAME>` in the previous command's output).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经模拟了本章中看到的此输出和其他输出，但你将看到类似的输出。用户应该出现在`SIGNER KEYS`部分（我们在前面的命令输出中有`<MY_USERNAME>`）。
- en: 'There is also an important topic related to signing. Users can delegate image
    signing. This concept will allow other users to sign for us or share signing within
    a team. If we need to impersonate another user''s signing process, we need to
    import their key. Therefore, we require the other user''s `key.pem` key file.
    We will load this key in keeping with the steps covered previously:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个与签名相关的重要话题。用户可以委托其他人进行镜像签名。这个概念允许其他用户为我们签名，或者在团队内共享签名。如果我们需要模拟其他用户的签名过程，我们需要导入他们的密钥。因此，我们需要另一个用户的
    `key.pem` 密钥文件。我们将按照之前的步骤加载该密钥：
- en: '[PRE11]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We mocked the users' names and IDs.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们模拟了用户的姓名和 ID。
- en: 'We then add our teammate''s public key to our repository:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将团队成员的公钥添加到我们的存储库中：
- en: '[PRE12]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, we can sign using both signatures:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以使用两个签名进行签名：
- en: '[PRE13]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, we can conduct a further inspection and we will see both signatures:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以进行进一步检查，并查看到两个签名：
- en: '[PRE14]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To delete the repository's DCT, we will use `notary delete <DTR_FQDN>[:DTR_PORT][/ORGANIZATION][/USERNAME][/REPOSITORY]
    --remote`. You will require the `notary` application's binary in your host.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 要删除存储库的 DCT，我们将使用 `notary delete <DTR_FQDN>[:DTR_PORT][/ORGANIZATION][/USERNAME][/REPOSITORY]
    --remote`。你将需要在主机中安装 `notary` 应用的二进制文件。
- en: Remember that all client actions can be forced to be secure using `export DOCKER_CONTENT_TRUST=1`,
    to enable content trust as regards all the commands executed in the current shell.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，所有客户端操作都可以强制执行安全操作，通过 `export DOCKER_CONTENT_TRUST=1` 来启用内容信任，从而对当前 shell
    中执行的所有命令生效。
- en: 'Content trust can be integrated into CI/CD with process orchestrators and other
    automation tools. To avoid a user''s interaction as regards image signing procedures,
    we can use the following variables:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 内容信任可以与 CI/CD 流程编排器和其他自动化工具集成。为了避免用户在镜像签名过程中进行交互，我们可以使用以下变量：
- en: '`DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE`: Will be used for the local root key
    passphrase'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_CONTENT_TRUST_ROOT_PASSPHRASE`：将用于本地根密钥的密码短语'
- en: '`DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE`: Will be used for the repository
    passphrase'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOCKER_CONTENT_TRUST_REPOSITORY_PASSPHRASE`：将用于存储库密码短语'
- en: As we have learned, users will be available to sign their images using their
    Docker bundle from UCP. It is also possible to generate keys using `docker trust
    key generate command`, but these will not be included in DTR.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所学到的，用户可以通过 UCP 使用 Docker 捆绑包来签名他们的图像。也可以使用 `docker trust key generate command`
    命令生成密钥，但这些密钥不会被包括在 DTR 中。
- en: DTR ships with Notary built in so that you can use DCT to sign and verify images.
    For more information about managing Notary data in DTR, refer to the DTR-specific
    notary documentation.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 内置了 Notary，因此你可以使用 DCT 来签名和验证镜像。有关在 DTR 中管理 Notary 数据的更多信息，请参考 DTR 专用的 Notary
    文档。
- en: The following section will show us how we can integrate Docker Enterprise into
    our CI/CD pipeline using DTR's built-in features.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将展示我们如何使用 DTR 内置功能将 Docker Enterprise 集成到我们的 CI/CD 流水线中。
- en: Integrating and automating image workflow
  id: totrans-223
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成和自动化镜像工作流
- en: 'DTR provides built-in features aligned with CI/CD pipeline construction logic.
    We will have webhooks that can be triggered to inform other applications or processes
    regarding certain events, such as a completed image scan or a new image/tag arrival.
    We also have image promotions. This feature will retag images between repositories.
    The following diagram shows a simple workflow for building, distributing, and
    executing an application. We are including some of the features provided by DTR:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 提供了与 CI/CD 流水线构建逻辑相一致的内置功能。我们将有可以触发的 Webhook，用于通知其他应用或进程某些事件，如完成图像扫描或新图像/标签到达。我们还有图像推广功能，该功能将在存储库之间重新标记图像。以下图示展示了构建、分发和执行应用程序的简单工作流。我们列出了
    DTR 提供的一些功能：
- en: '![](img/977b9776-a6eb-4af7-bde5-05a2759718a9.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![](img/977b9776-a6eb-4af7-bde5-05a2759718a9.jpg)'
- en: This workflow represents how to implement DTR in several development stages.
    Promoting a scanned image for testing will ensure its security before going to
    production in this example. Toward the end of this section, we will also be reviewing
    image mirroring. This is a feature used to share images between different DTR
    environments.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 该工作流展示了如何在多个开发阶段中实现 DTR。在本示例中，通过推广扫描图像进行测试，将确保其在投入生产前的安全性。在本节的末尾，我们还将回顾镜像镜像功能。这是一个用于在不同
    DTR 环境之间共享图像的功能。
- en: Image promotion
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像推广
- en: DTR allows us to automatically promote images between repositories. Promotion
    is based on repository-defined policies. Therefore, policies are defined at the
    repository level. When an image is pushed to this repository, policies are reviewed
    and, if the rules match, a new push is done to another registry.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: DTR允许我们在仓库之间自动推广镜像。推广是基于仓库定义的策略进行的。因此，策略在仓库级别定义。当镜像被推送到该仓库时，策略会被审核，如果规则匹配，则会将镜像推送到另一个注册表。
- en: Image promotion is very useful in CI/CD pipeline stages. It is easier to understand
    with the help of a quick example. Let's imagine a development repository for a
    frontend application's component. Developers will push images to this `development/frontend`
    repository. They manage all the updates in this repository. In fact, no one apart
    from them has access to this repository. They will develop new updates with fixes
    and new features. When a release has to be deployed to production, they will prepare
    a `release` version. They will include a `release` string in this image's tag.
    A policy will match this string and a new image will be created on the `Quality
    Assurance` repository for the application's component.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像推广在CI/CD流水线阶段非常有用。通过快速示例可以更容易理解。假设有一个用于前端应用程序组件的开发仓库。开发人员将把镜像推送到`development/frontend`仓库，他们在这个仓库中管理所有更新。事实上，除了他们自己，没有人可以访问这个仓库。他们会在此开发新的更新，包括修复和新功能。当需要将版本发布到生产环境时，他们会准备一个`release`版本，并在该镜像的标签中加入`release`字符串。一个策略将匹配此字符串，然后会在`质量保证`仓库为该应用组件创建一个新的镜像。
- en: This process creates a new image to be tested by the quality assurance team
    when the `release` image is pushed. These users do not have access to non-release
    images. Only those images tagged as `release` will be available to quality assurance
    users. We know that only an image's ID is unique. We can have many tags for each
    image. Therefore, we are not duplicating images. We are just adding new tags and
    names for a defined image.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当`release`镜像被推送时，该过程会创建一个新的镜像供质量保证团队进行测试。这些用户无法访问非发布镜像。只有标记为`release`的镜像才能供质量保证用户使用。我们知道，只有镜像的ID是唯一的。每个镜像可以有多个标签。因此，我们并没有重复镜像，只是为定义的镜像添加了新的标签和名称。
- en: 'We can define policies based on the following attributes:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据以下属性定义策略：
- en: '| **Attributes** | **Description** |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '| **属性** | **描述** |'
- en: '| Tag name | We define a matching string for a repository''s image''s tags.
    Matching tags can be equal, or can start with, end with, contain, or be one of
    the image-defined ones. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 标签名称 | 我们为仓库的镜像标签定义匹配字符串。匹配标签可以相等，或者可以是以某个字符串开头、结尾、包含某个字符串，或者是镜像定义的标签之一。
    |'
- en: '| Component name | This will be used to match if an image has a given component
    and its name equals, starts with, ends with, or contains, or is one the specified
    ones. |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 组件名称 | 如果镜像具有给定组件，并且其名称等于、以某个字符串开头、结尾、包含某个字符串，或者是指定的名称之一，则此规则将匹配。 |'
- en: '| Vulnerabilities | We can define how many critical, major, or minor vulnerabilities
    (or all vulnerabilities) will be monitored to promote an image to another repository.
    We will use comparison expressions such as "is greater than," "greater than or
    equal to," "less than or equal to," "equal," or "not" with the defined value and
    the image will only be promoted if the equation is satisfied. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 漏洞 | 我们可以定义将监控多少个关键、重大或轻微漏洞（或所有漏洞），以便将镜像提升到另一个仓库。当满足定义的值和镜像之间的方程时，使用如“更大于”，“大于或等于”，“小于或等于”，“等于”或“非”等比较表达式，只有当方程式成立时，镜像才会被提升。
    |'
- en: '| License | This rule will match if the image uses a license. This is usually
    used in relation to Microsoft Windows images. |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 许可证 | 如果镜像使用许可证，则此规则将匹配。通常，这与Microsoft Windows镜像相关。 |'
- en: We can apply more than one attribute to this policy's rules. Once we choose
    which criteria will be applied, we can set up the new repository and tag. There
    are a number of templates for the names of new image tags. These allow us to include
    an image's source tag or timestamps.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将多个属性应用于此策略的规则。一旦选择了将应用的标准，我们可以设置新的仓库和标签。新的镜像标签有许多命名模板。这些模板允许我们包含镜像的源标签或时间戳。
- en: DTR webhooks
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DTR Webhook
- en: DTR has a series of integrated webhooks that will be triggered under special
    circumstances. When some events occur, DTR will be able to send webhooks to third-party
    applications. This is vital to integrating DTR in your CI/CD pipelines. DTR webhooks
    can be secured using TLS if the receiver backend also has this feature.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 提供了一系列集成的 Webhooks，这些 Webhooks 会在特定情况下触发。当某些事件发生时，DTR 将能够向第三方应用程序发送 Webhook。这对将
    DTR 集成到您的 CI/CD 流水线中至关重要。如果接收方后端也具有此功能，DTR 的 Webhooks 可以通过 TLS 安全传输。
- en: 'We will cover most of the important webhooks, but this link provides an accurate
    list of the current ones: [https://docs.docker.com/ee/dtr/admin/manage-webhooks/](https://docs.docker.com/ee/dtr/admin/manage-webhooks/):'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将覆盖大部分重要的 Webhooks，但此链接提供了当前 Webhooks 的准确列表：[https://docs.docker.com/ee/dtr/admin/manage-webhooks/](https://docs.docker.com/ee/dtr/admin/manage-webhooks/)：
- en: '| **Webhooks** | **Description** |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **Webhooks** | **描述** |'
- en: '| `TAG_PUSH`, `TAG_PULL`, and `TAG_DELETE` | Repositories'' tag events will
    generate webhooks when someone pushes or pulls on a repository or when it is removed.
    |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| `TAG_PUSH`、`TAG_PULL` 和 `TAG_DELETE` | 仓库的标签事件将在有人推送或拉取仓库，或仓库被删除时触发 Webhook。
    |'
- en: '| `SCAN_COMPLETED` and `SCANNER_UPDATE_COMPLETED` | Scanning is key to ensuring
    security. We will send notifications when the image-scanning database is updated
    or when a repository''s scan has ended correctly. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `SCAN_COMPLETED` 和 `SCANNER_UPDATE_COMPLETED` | 扫描是确保安全性的关键。我们将在镜像扫描数据库更新或仓库扫描正确结束时发送通知。
    |'
- en: '| `PROMOTION` | Whenever a promotion policy is applied, we will send a webhook.
    This will help us to follow DTR images'' internal workflow. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `PROMOTION` | 每当应用促销策略时，我们将发送一个 Webhook。这有助于我们跟踪 DTR 镜像的内部工作流程。 |'
- en: We must have administrative privileges on a repository to be able to configure
    its webhooks using either DTR's web UI or its API. The web UI allows us to test
    defined webhooks by clicking Test.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须拥有仓库的管理员权限，才能通过 DTR 的 Web UI 或 API 配置其 Webhooks。Web UI 允许我们通过点击“测试”来测试已定义的
    Webhooks。
- en: 'The following screenshot shows a repository''s webhook configuration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了仓库的 Webhook 配置：
- en: '![](img/6824c1e9-c756-4b2e-b6fe-6d6b7ff6f6fd.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6824c1e9-c756-4b2e-b6fe-6d6b7ff6f6fd.jpg)'
- en: The following section will show us how to implement registry mirroring.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将向我们展示如何实现注册表镜像。
- en: Mirror images between registries
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 镜像在注册表之间的同步
- en: Registry mirroring can also help us in our CI/CD. When images get pushed into
    repositories and there is some mirroring configuration, DTR will push them into
    another defined registry. This helps us to distribute repositories on different
    registries, with high availability.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表镜像也可以帮助我们在 CI/CD 中。当镜像推送到仓库并且存在镜像配置时，DTR 会将其推送到另一个定义好的注册表。这有助于我们将仓库分布到不同的注册表上，提供高可用性。
- en: 'Mirroring configuration is based on the promotion logic covered previously.
    We will first configure mirror direction to define which action will be used:
    pull or push. DTR mirroring allows us to integrate Docker Hub with the on-premises
    Docker Enterprise DTR environment.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 镜像配置基于之前讲解的促销逻辑。我们将首先配置镜像方向，以定义使用的操作：拉取或推送。DTR 镜像允许我们将 Docker Hub 与本地的 Docker
    Enterprise DTR 环境集成。
- en: 'We need to understand that DTR''s metadata is not synced between registries.
    Therefore, image scanning and signing information from the first registry will
    not be available on the second one. All these actions must also be executed on
    the mirror registry. We can integrate scanning automatically when images are pushed
    to the second registry. Image signing requires external integrations. The following
    screenshot shows the mirroring configurations for a repository:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要理解 DTR 的元数据在注册表之间并未同步。因此，第一个注册表中的镜像扫描和签名信息在第二个注册表中将不可用。所有这些操作也必须在镜像注册表上执行。当镜像被推送到第二个注册表时，我们可以自动集成扫描。镜像签名需要外部集成。以下截图显示了仓库的镜像配置：
- en: '![](img/42d76fea-b8cd-46b6-8986-b54a1f33a849.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![](img/42d76fea-b8cd-46b6-8986-b54a1f33a849.jpg)'
- en: Now that we have learned about the built-in features for automation, we will
    review registry caching with a view to improving a developer's work.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了自动化的内置功能，我们将回顾注册表缓存，以改善开发者的工作。
- en: Registry caching
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册表缓存
- en: Registry caching will help us to manage images on distributed environments.
    Users from remote locations can have latency problems and big images can take
    forever to load. We can deploy intermediate registry caches to decrease pull times.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 注册表缓存将帮助我们在分布式环境中管理镜像。来自远程位置的用户可能会遇到延迟问题，而大镜像可能需要很长时间才能加载。我们可以部署中间注册表缓存以减少拉取时间。
- en: Caches are transparent to users because they will use the original DTR's URL.
    When a user pulls an image, the DTR will check whether it is authorized and it
    will then be redirected to a defined cache. This cache pulls an image's layers
    from the DTR and keeps a copy for users. New requests do not require an image's
    layers to be pulled from DTR again.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存对用户是透明的，因为他们将使用原始的 DTR URL。当用户拉取镜像时，DTR 将检查是否经过授权，然后会将请求重定向到定义的缓存。这些缓存从 DTR
    拉取镜像层并为用户保留副本。新的请求无需再次从 DTR 拉取镜像层。
- en: To deploy a registry cache service, we will use the `docker/dtr-content-cache:<RELEASE>`
    image.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署注册表缓存服务，我们将使用 `docker/dtr-content-cache:<RELEASE>` 镜像。
- en: 'Registry caching help us to manage distributed environments. Docker clients
    must be configured in order to use this feature. We will add `"registry-mirrors":
    ["https://<REGISTRY''s_MIRROR_URL>"]` to the `daemon.json` configuration file
    or configure users to use it by using the Users Settings page. For this to work,
    it is necessary to register the deployed cache with DTR''s configuration using
    DTR''s API. Detailed instructions can be found at the following link: [https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/](https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '注册表缓存帮助我们管理分布式环境。Docker 客户端必须进行配置才能使用此功能。我们将把 `"registry-mirrors": ["https://<REGISTRY''s_MIRROR_URL>"]`
    添加到 `daemon.json` 配置文件中，或者通过用户设置页面配置用户使用它。为了使其工作，必须使用 DTR 的 API 将部署的缓存注册到 DTR
    配置中。详细说明可以在以下链接中找到：[https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/](https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/)'
- en: We will now learn about DTR's automated garbage deletion.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将了解 DTR 的自动垃圾删除功能。
- en: Garbage collection
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垃圾回收
- en: Garbage collection will remove unreferenced layers and manifests from DTR. Registry
    data can consume a lot of space in our storage backend. This is not only a problem
    for storage resources. Security can be compromised if unsecured layers remain.
    It is recommended to remove all unused layers (also known as **dangling images**).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 垃圾回收将从 DTR 中移除未引用的层和清单。注册表数据可能会占用我们存储后端大量空间。这不仅仅是存储资源的问题。如果未加固的层仍然存在，安全性可能会受到威胁。建议移除所有未使用的层（也称为**悬空镜像**）。
- en: 'This process runs in two phases:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程分为两个阶段：
- en: DTR's garbage collector will search all registry manifests. Those with active
    content, and image layers included within other images, will not be deleted.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DTR 的垃圾回收器将搜索所有注册表清单。那些具有活动内容并且被其他镜像包含的图像层将不会被删除。
- en: The process will scan all the blobs. Those not included in the first phase's
    list will be removed.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 该过程将扫描所有的二进制大对象（blobs）。未包含在第一阶段清单中的对象将被删除。
- en: 'Garbage collection can be run manually from a registry''s container using `bin/registry
    garbage-collect`. We will usually apply scheduled tasks integrated into DTR''s
    web UI. Garbage collection options will allow us to configure the removal of unreferenced
    layers periodically using cron-like logic. We will also establish for how long
    we will allow the removal process to run because it can take a significant amount
    of time. The following screenshot shows the Garbage collection configuration page:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过 `bin/registry garbage-collect` 命令手动运行垃圾回收。通常我们会通过集成到 DTR Web UI 中的计划任务来进行。垃圾回收选项将允许我们使用类似
    cron 的逻辑定期配置移除未引用的层。我们还将设置允许移除过程运行的时间，因为这可能需要相当长的时间。以下截图展示了垃圾回收配置页面：
- en: '![](img/63c47699-4ee0-4425-85a4-ac79fb639906.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![](img/63c47699-4ee0-4425-85a4-ac79fb639906.jpg)'
- en: In the next section, we will learn how to deploy DTR's backup.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一部分，我们将学习如何部署 DTR 的备份。
- en: Backup strategies
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 备份策略
- en: DTR's backup procedure does not result in any service interruption. A backup
    process can be executed from any of the cluster nodes. It is recommended to create
    all backups from the same replica. This will help us to recover at least this
    replica. We will be able to recreate the full DTR's cluster environment using
    this replica.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 的备份过程不会导致任何服务中断。备份过程可以在集群的任何节点上执行。建议从同一副本创建所有备份。这将帮助我们至少恢复该副本。我们可以使用该副本重建完整的
    DTR 集群环境。
- en: 'The following list shows which content will be stored as part of your DTR''s
    backup TAR file:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 以下清单显示了将作为 DTR 备份 TAR 文件一部分存储的内容：
- en: DTR configurations
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTR 配置
- en: Repository metadata
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库元数据
- en: User access control and repository configurations
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户访问控制和仓库配置
- en: TLS certificates and keys required for DTR communication
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTR 通信所需的 TLS 证书和密钥
- en: Images' signatures and digests, including the integration of Notary
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的签名和摘要，包括 Notary 的集成
- en: Images' scan results
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像扫描结果
- en: 'The following content will not be included within your backups:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 以下内容将不会包含在您的备份中：
- en: Images' layers
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像的层
- en: Users, teams, and organizations
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户、团队和组织
- en: The vulnerability database used for image scanning
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于图像扫描的漏洞数据库
- en: Take care of the content of images because users, teams, and organizations will
    be included in UCP's backup and the vulnerability database (CVE and reports) can
    be recreated whenever we need it.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 注意图像的内容，因为用户、团队和组织将包含在 UCP 的备份中，漏洞数据库（CVE 和报告）可以在需要时重新创建。
- en: By default, DTR's web UI will show a warning message if we haven't performed
    any backup.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，如果我们没有执行任何备份，DTR 的 web UI 会显示警告信息。
- en: 'We will find the healthy replica''s ID by using `REPLICA_ID=$(docker inspect
    -f ''{{.Name}}'' $(docker ps -q -f name=dtr-rethink) | cut -f 3 -d ''-'') && echo
    $REPLICA_ID` and we will then execute a backup using this ID:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用`REPLICA_ID=$(docker inspect -f '{{.Name}}' $(docker ps -q -f name=dtr-rethink)
    | cut -f 3 -d '-') && echo $REPLICA_ID`来查找健康副本的 ID，然后我们将使用此 ID 执行备份：
- en: '[PRE15]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Remember, this file does not include an image's blobs or meta-information. We
    need to include third-party backup solutions for DTR's storage backend.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，此文件不包括图像的二进制数据或元信息。我们需要为 DTR 的存储后端包含第三方备份解决方案。
- en: We can use either `--ucp-ca` with a valid UCP CA certificate or `--ucp-insecure-tls`
    to connect to UCP.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用有效的 UCP CA 证书通过`--ucp-ca`或使用`--ucp-insecure-tls`连接到 UCP。
- en: 'To restore DTR, we will use the same `docker/dtr` image release. We will use
    `docker container run docker/dtr:<RELEASE> restore`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 要恢复 DTR，我们将使用相同的`docker/dtr`镜像版本。我们将使用`docker container run docker/dtr:<RELEASE>
    restore`：
- en: '[PRE16]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This command will not restore images' blobs and meta-information as the backup
    only provides information to recover all of DTR's processes and their configurations.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令不会恢复图像的二进制数据和元信息，因为备份仅提供恢复所有 DTR 进程及其配置所需的信息。
- en: The following section will help us to understand how to monitor DTR's health.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分将帮助我们了解如何监控 DTR 的健康状况。
- en: Updates, health checks, and troubleshooting
  id: totrans-292
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新、健康检查和故障排除
- en: DTR application upgrades can sometimes integrate database modifications. Therefore,
    you must ensure the correct upgrade path between releases. The `upgrade` command
    can be executed from any node as we will execute this command against all DTR
    replicas. We will use the replicas' IDs or interactive mode to upgrade each DTR
    replica. The upgrade process will replace all replica containers.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 应用程序升级有时会集成数据库修改。因此，必须确保正确的升级路径。`upgrade`命令可以从任何节点执行，因为我们将在所有 DTR 副本上执行此命令。我们将使用副本的
    ID 或交互模式来升级每个 DTR 副本。升级过程将替换所有副本容器。
- en: 'It is recommended to review Docker''s documentation relating to updated procedures
    at the following link: [https://docs.docker.com/ee/dtr/admin/upgrade](https://docs.docker.com/ee/dtr/admin/upgrade)'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 建议查看 Docker 文档中关于更新程序的相关内容，链接如下：[https://docs.docker.com/ee/dtr/admin/upgrade](https://docs.docker.com/ee/dtr/admin/upgrade)
- en: DTR uses semantic versioning. This is key for following upgrade paths. Downgrading
    is not supported because sometimes, an upgrade can modify database objects.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 使用语义版本控制。这对于遵循升级路径至关重要。由于有时升级会修改数据库对象，因此不支持降级。
- en: Upgrades between different patch releases can be skipped if a minor release
    is applied. Patches do not modify the database, so CA can be applied without an
    object's data changing.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 不同补丁版本之间的升级可以跳过，如果应用了小版本。补丁不会修改数据库，因此可以应用 CA，而对象的数据不会发生变化。
- en: On the other hand, upgrades between minor versions must follow the version number,
    although we can skip intermediate patches, as has been mentioned.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，小版本之间的升级必须遵循版本号，尽管我们可以跳过中间的补丁，如前所述。
- en: Major version upgrades require upgrading to the latest minor/patch release before
    going to the next major release. This procedure will implement a host of changes
    and you must ensure that you have a valid backup before this upgrade. Remember
    to verify a valid image's data backup.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 重大版本升级需要先升级到最新的小版本/补丁版本，然后才能进行下一个重大版本的升级。此过程将实施一系列更改，在此升级之前，必须确保有有效的备份。记得验证有效图像的数据备份。
- en: To monitor DTR, we will use a common container's monitoring procedures. We can
    also use UCP's stacks view because DTR is deployed as a multi-container application.
    All replicas will be displayed. We can then click on each replica's link and inspect
    its resources.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为了监控 DTR，我们将使用常见的容器监控程序。我们也可以使用 UCP 的堆栈视图，因为 DTR 是作为多容器应用程序部署的。所有副本都会显示。然后，我们可以点击每个副本的链接并检查其资源。
- en: 'DTR exposes the following endpoints for monitoring. We will use them to verify
    its health:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 提供以下监控端点。我们将使用它们来验证其健康状态：
- en: '| **Endpoints** | **Description** |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| **端点** | **描述** |'
- en: '| `/_ping` | This endpoint shows a replica''s status. We can verify status
    using third-party monitoring tools. If the replica is fine, we will obtain `"Healthy":true`:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '| `/_ping` | 这个端点显示副本的状态。我们可以使用第三方监控工具验证状态。如果副本正常，我们将获得 `"Healthy":true`：'
- en: '[PRE17]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '|'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| `/nginx_status` | This shows us the common open source `nginx` status and
    statistics page. |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| `/nginx_status` | 这将显示常见开源 `nginx` 的状态和统计信息页面。 |'
- en: '| `/api/v0/meta/cluster_status` | For all replica statuses, we will use this
    endpoint. This requires authentication because we will be accessing DTR''s API.
    We will use any administrator''s access. An overall cluster state and a list of
    replicas with their statuses will be shown. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| `/api/v0/meta/cluster_status` | 对于所有副本的状态，我们将使用这个端点。此操作需要认证，因为我们将访问 DTR 的
    API。我们将使用任何管理员的访问权限。此端点将显示集群的整体状态及其副本列表和状态。 |'
- en: We will also search for errors on DTR's container logs. In this case, we will
    usually integrate these logs in third-party logging management applications.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将检查 DTR 容器日志中的错误。在这种情况下，我们通常会将这些日志集成到第三方日志管理应用程序中。
- en: Logging
  id: totrans-308
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日志记录
- en: As standard, DTR's container logs will show all application errors. DTR also
    includes a view in its web UI with all job logs. We will have detailed information
    regarding the many actions executed within the environment. This log view provides
    useful audit information because it contains all images' management actions executed
    in DTR.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 按照标准，DTR 的容器日志会显示所有应用程序错误。DTR 还在其 Web UI 中提供了一个视图，显示所有作业日志。我们将获得关于环境中执行的众多操作的详细信息。此日志视图提供了有用的审计信息，因为它包含了
    DTR 中执行的所有镜像管理操作。
- en: The following section will show us how to recover an unhealthy DTR environment.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的部分将向我们展示如何恢复不健康的 DTR 环境。
- en: DTR disaster recovery
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DTR 灾难恢复
- en: DTR is deployed using a high-availability strategy. Therefore, we have a variety
    of situations, depending on how many replicas are unhealthy.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: DTR 使用高可用策略进行部署。因此，我们会遇到多种情况，取决于有多少副本处于不健康状态。
- en: Some replicas are unhealthy, but we keep the cluster's quorum's state
  id: totrans-313
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些副本不健康，但我们保持集群法定人数的状态
- en: 'In this case, the majority of replicas are healthy, so overall, the cluster''s
    state is healthy. We will remove unhealthy replicas and add new ones as soon as
    possible. It is important to only join replicas after unhealthy ones have been
    removed. We will execute this procedure step by step, removing an unhealthy replica,
    adding a new one, and so on. This will keep the overall cluster''s state intact.
    We will only remove unhealthy replicas that have been identified, so we will first
    need to identify which replicas are in a failing state using `docker ps --format
    "{{.Names}}" | grep dtr`. Once identified, we will execute `docker container run
    docker/dtr:<RELEASE> remove` to delete the replica in question:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，大多数副本是健康的，因此整体集群的状态是健康的。我们将尽快移除不健康的副本并添加新的副本。重要的是，在移除不健康副本之后，才加入新的副本。我们将逐步执行此过程，移除一个不健康副本，添加一个新的副本，依此类推。这样可以保持整体集群的状态不变。我们只会移除已识别的不健康副本，因此我们需要首先识别哪些副本处于失败状态，使用
    `docker ps --format "{{.Names}}" | grep dtr` 来查找。一旦识别出不健康副本，我们将执行 `docker container
    run docker/dtr:<RELEASE> remove` 来删除相关副本：
- en: '[PRE18]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Although the `--replica-ids` argument will allow us to remove a list of replicas,
    it is recommended to follow this procedure on each unhealthy replica, adding a
    new one with each removal:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管 `--replica-ids` 参数允许我们移除副本列表，但建议对每个不健康的副本执行以下步骤，每移除一个副本就添加一个新的副本：
- en: '[PRE19]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This will join a new replica. Always wait until synchronization has finished
    before continuing with a new one.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加入一个新的副本。请务必等待同步完成后，再继续添加新的副本。
- en: The majority of replicas are unhealthy
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 大多数副本不健康
- en: If the majority of replicas are unhealthy, the cluster's state will be unhealthy
    because it will have lost its quorum. However, if we still have at least one healthy
    node, we can repair the cluster using this replica. We will execute an emergency
    repair procedure using `docker container run docker/dtr:<RELEASE> emergency-repair`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果大多数副本都不健康，集群的状态将变得不健康，因为它失去了法定人数。然而，如果我们仍然有至少一个健康节点，就可以使用这个副本来修复集群。我们将使用 `docker
    container run docker/dtr:<RELEASE> emergency-repair` 执行紧急修复程序。
- en: 'We can find the healthy replica''s ID using `REPLICA_ID=$(docker inspect -f
    ''{{.Name}}'' $(docker ps -q -f name=dtr-rethink) | cut -f 3 -d ''-'') && echo
    $REPLICA_ID` and we will then execute the emergency repair procedure:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `REPLICA_ID=$(docker inspect -f '{{.Name}}' $(docker ps -q -f name=dtr-rethink)
    | cut -f 3 -d '-') && echo $REPLICA_ID` 查找到健康副本的 ID，然后执行紧急修复程序：
- en: '[PRE20]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This process should recover a replica completely and we will then add new replicas
    to recover a cluster's consensus.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程应完全恢复一个副本，然后我们将添加新的副本以恢复集群的一致性。
- en: All replicas are unhealthy
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 所有副本都不健康
- en: 'In this situation, we cannot recover the cluster without an existing backup.
    We will use `docker container run docker/dtr:<RELEASE> restore`. It is critical
    to have a valid DTR backup:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果没有现有的备份，我们将无法恢复集群。我们将使用 `docker container run docker/dtr:<RELEASE>
    restore`。拥有有效的 DTR 备份至关重要：
- en: '[PRE21]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command will not restore Docker images. We have to implement a separate
    procedure for this data. We will use the normal filesystem's backup and restore
    procedures. Once we have a healthy replica, we will be able to join new ones in
    keeping with the procedure described previously.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令不会恢复 Docker 镜像。我们必须为此数据实施单独的程序。我们将使用正常的文件系统备份和恢复程序。一旦我们有了健康的副本，就可以按照先前描述的程序将新的副本加入集群。
- en: Summary
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: This chapter covered DTR's features and components. We learned how to implement
    DTR in production using a high-availability strategy. We reviewed different solutions
    available for storing images securely.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了 DTR 的功能和组件。我们学习了如何通过高可用性策略在生产环境中实施 DTR。我们回顾了不同的安全存储镜像的解决方案。
- en: We also covered image scanning and signing. Both options allow us to improve
    image security by integrating with UCP's application deployment platform. Users
    within organizations will have different levels of access to images thanks to
    DTR's integrated RBAC system.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了镜像扫描和签名。这两种选项使我们能够通过与 UCP 的应用程序部署平台集成来提高镜像的安全性。组织内的用户将通过 DTR 集成的 RBAC
    系统享有不同级别的镜像访问权限。
- en: CI/CD environments have changed the way we create and deploy applications nowadays.
    We have reviewed different features built using DTR that help us to integrate
    image building, sharing, and security in CI/CD pipelines. We also learned how
    to mirror repositories and improve users' experiences with registry caching.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: CI/CD 环境已经改变了我们如今创建和部署应用程序的方式。我们回顾了使用 DTR 构建的不同功能，这些功能帮助我们在 CI/CD 管道中集成镜像构建、共享和安全性。我们还学习了如何镜像仓库并通过注册表缓存改善用户体验。
- en: Knowledge of DTR and UCP is required for the exam. We need to know their component
    distributions on cluster nodes and how they work. We also need to understand their
    installation processes and how we can ensure their health.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 需要了解 DTR 和 UCP 的知识才能通过考试。我们需要了解它们在集群节点上的组件分布以及它们如何工作。我们还需要理解它们的安装过程，以及如何确保它们的健康状态。
- en: This is the last chapter related to the Docker Enterprise platform. Later chapters
    will cover the content that is required for the exam, with some quick topic reviews
    and further questions and answers.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这是与 Docker 企业平台相关的最后一章。后续章节将覆盖考试所需的内容，包括一些快速的主题复习和进一步的问题解答。
- en: Questions
  id: totrans-334
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which features are included in DTR?
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DTR 包含哪些功能？
- en: a) Repository load balancing
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: a) 仓库负载均衡
- en: b) Repository mirroring
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: b) 仓库镜像
- en: c) Repository signing
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: c) 仓库签名
- en: d) All of the above
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有内容
- en: How many DTR replicas do we need in order to provide high availability for Docker
    images' layers?
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要多少个 DTR 副本才能为 Docker 镜像的层提供高可用性？
- en: a) We will need at least three DTR replicas to provide high availability.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: a) 我们将需要至少三个 DTR 副本才能提供高可用性。
- en: b) DTR does not manage the high availability of data. We need to provide third-party
    solutions for DTR storage.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: b) DTR 不管理数据的高可用性。我们需要为 DTR 存储提供第三方解决方案。
- en: c) DTR manages volume synchronization when we deploy more than one replica.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: c) DTR 管理当我们部署多个副本时的卷同步。
- en: d) All of the above statements are true.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: d) 以上所有陈述都为真。
- en: Which processes are part of DTR?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DTR 包含哪些过程？
- en: a) `garant`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: a) `garant`
- en: b) `jobrunner`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: b) `jobrunner`
- en: c) `notary-client`
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: c) `notary-client`
- en: d) `auth-store`
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: d) `auth-store`
- en: Which of these statements are true in terms of how to deploy DTR with high availability?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于如何部署具有高可用性的DTR，哪些陈述是正确的？
- en: a) Configure a load balancer as a transparent reverse proxy. We will forward
    all requests for DTR's FQDN to any of the replicas.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: a) 配置负载均衡器作为透明反向代理。我们将所有针对DTR FQDN的请求转发到任何一个副本。
- en: b) Deploy shared storage to allow all DTR replicas to store an image's data
    and meta-information at the same location.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: b) 部署共享存储，允许所有DTR副本在相同位置存储镜像的数据和元信息。
- en: c) Deploy the first DTR replica with previously created shared storage on one
    node. Then, add at least two more replicas on different nodes.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: c) 在一个节点上使用之前创建的共享存储部署第一个DTR副本。然后，在不同的节点上添加至少两个更多的副本。
- en: d) All of the above statements are true.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: d) 上述所有陈述都是正确的。
- en: Which content is not included in DTR's backup?
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: DTR的备份中不包含哪些内容？
- en: a) Repository metadata and images' layers.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: a) 仓库元数据和镜像的层。
- en: b) RBAC configurations.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: b) RBAC配置。
- en: c) Image signatures.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: c) 图像签名。
- en: d) All of the above statements are true.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: d) 上述所有陈述都是正确的。
- en: Further reading
  id: totrans-360
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 深入阅读
- en: 'The following links will help us to understand some of the topics covered in
    this chapter:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 以下链接将帮助我们理解本章中涉及的一些主题：
- en: 'Content trust integration in DTR: [https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)'
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTR中的内容信任集成：[https://docs.docker.com/engine/security/trust/content_trust/](https://docs.docker.com/engine/security/trust/content_trust/)
- en: 'Deploying the registry cache: [https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/](https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/)'
  id: totrans-363
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署注册表缓存：[https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/](https://docs.docker.com/ee/dtr/admin/configure/deploy-caches/simple/)
- en: 'Authentication and authorization in DTR: [https://docs.docker.com/ee/dtr/admin/manage-users/](https://docs.docker.com/ee/dtr/admin/manage-users/)'
  id: totrans-364
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DTR中的身份验证和授权：[https://docs.docker.com/ee/dtr/admin/manage-users/](https://docs.docker.com/ee/dtr/admin/manage-users/)
