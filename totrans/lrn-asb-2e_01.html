<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor017"/>1</h1>
<h1 id="_idParaDest-16"><a id="_idTextAnchor018"/>Installing and Running Ansible</h1>
<p>Welcome to this, our first chapter in the second edition of <em class="italic">Learn Ansible</em>. In this chapter, we will look at a few topics to introduce you to <strong class="bold">Ansible</strong>; these topics will familiarize<a id="_idIndexMarker000"/> you with the basics of what Ansible is and give you a few different use cases.</p>
<p>By the end of the chapter, you will have gotten hands-on with Ansible and covered the following:</p>
<ul>
<li>Who is behind Ansible?</li>
<li>The differences between Ansible and other tools</li>
<li>The problem Ansible solves</li>
<li>How to install Ansible on macOS and Linux</li>
<li>Running Ansible on Windows 11 using the Windows Subsystem for Linux</li>
<li>Launching a test virtual machine</li>
<li>An introduction to playbooks</li>
</ul>
<p>Before we start talking about Ansible, let’s quickly discuss my background, how I came to be writing a book about Ansible, and what you will need to install and run Ansible on your system.</p>
<h1 id="_idParaDest-17">Technical requirements<a id="_idTextAnchor019"/></h1>
<p>Later in this chapter, we will install Ansible, so you will need a machine capable of running it. I will go into more detail about these requirements in the second half of the chapter. We will also use <strong class="bold">Multipass</strong> to launch a virtual machine locally. A section walks through installing Multipass and downloading an Ubuntu image to use the virtual machine’s base, which is a download of a few hundred MBs. You can find all of the code used in this chapter at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter01">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter01</a>.<a id="_idTextAnchor020"/></p>
<h1 id="_idParaDest-18"><a id="_idTextAnchor021"/>My story: part one</h1>
<p>I have been working with servers, primarily ones that serve web pages, since the late 90s, and the landscape is unrecognizable. Here is a quick overview of my first few years running servers to give you an idea of how I used to operate my early servers.</p>
<p>Like most people at the time, I started with a shared hosting account where I had very little control over anything on the server side when the website I was running outgrew shared hosting due to the forum, which made up part of the site’s popularity. I moved to a dedicated server, where I thought I could flex my future system administrator muscles, but I was wrong.</p>
<p>The server I got was a Cobalt RaQ 3; this was a 1U server appliance that was ahead of its time. However, I did not have root-level access to the machine, and I had to use the web-based control panel for everything I needed to do. Eventually, I got a level of access where I could access the server using Telnet; I now know this isn’t good, but it was the early days, and SSH was considered cutting-edge. I started to teach myself how to be a system administrator by making changes in the web control panel and looking at the changes to the configuration files on the server.</p>
<p>After a while, I changed servers and, this time, opted to forego any web-based<a id="_idIndexMarker001"/> control panel and use what I had learned with the Cobalt RaQ to configure my first proper <strong class="bold">Linux</strong>, <strong class="bold">Apache</strong>, <strong class="bold">MySQL</strong>, <strong class="bold">PHP</strong> (or <strong class="bold">LAMP</strong> for short) server by using the pages of notes I had made. I had created runbooks of one-liners to install and configure the software I needed and numerous scribbles to help me investigate problems and keep the lights on.</p>
<p>After I got my second server for another project, I realized that was probably a good time to type out my notes so that I could copy and paste them when I needed to deploy a server; the timing of this couldn’t have been better as it was a few months after making these notes that my first server failed—my host apologized and replaced it with a higher-specification but completely fresh machine with an updated operating system.</p>
<p>So, I grabbed my Microsoft Word file containing my notes and copied and pasted each instruction, making tweaks based on what I needed to install on the upgraded operating system. Several hours later, I had my server up and running and my data restored.</p>
<p>One of the critical lessons I learned, other than that there is no such thing as too many backups, was not to use Microsoft Word to store these types of notes; the Linux command line doesn’t care if your notes are all nicely formatted with headings and courier font for the bits you need to paste in. It does care about proper syntax, and Word had very kindly autocorrected and formatted all of my notes for print, meaning that not only did I have the pressure of having to deploy a new server and restore the backups I had thankfully been taking each day but also to try and debug my notes as I was doing so.</p>
<p>Because of this, I made a copy of the history file on the server and transcribed my notes in plaintext. These notes provided the base for the next few years as I started to script parts of them, mainly the bits that didn’t require any user input.</p>
<p>These scraps of commands, one-liners, and scripts were all adapted through Red Hat Linux 6; note the lack of the word Enterprise appended to the operating system’s name there, all the way through to CentOS 3 and 4.</p>
<p>Things got complicated when I changed roles; I stopped consuming services from a web hosting company and started working for one. Suddenly, I was building servers for customers who may have different requirements than my projects—each server was different.</p>
<p>From here, I started working with Kickstart scripts, PXE boot servers, gold masters on imaging servers, virtual machines, and bash scripts that started prompting information on the system being built. I had also moved from only needing to worry about maintaining my servers to having to log in to hundreds of different physical and virtual servers, from ones that belonged to the company I was working for to customer machines.</p>
<p>Over the next few years, my single text file quickly morphed into a complex collection of notes, scripts, precompiled binaries, and spreadsheets of information that only made sense to me; if I am being honest, I ended up making myself quite a significant single point of failure.</p>
<p>While I had moved to automate quite a few parts of my day-to-day work using bash scripts and stringing commands together, I found that my days were still very much filled with running all these tasks manually and working a service desk dealing with customer-reported problems and queries.</p>
<p>My story is typical of many people, while the operating systems used will probably be considered ancient. The entry point of using a GUI and moving to the command line while keeping a scratch pad of common commands is quite a common scenario I have heard when working with other system administrators and even modern-day DevOps practitioners.</p>
<p>So now that you know a little about my background, let’s talk about Ansible.</p>
<h1 id="_idParaDest-19"><a id="_idTextAnchor022"/>Ansible’s story</h1>
<p>Let’s take a quick look at who developed Ansible and what it actually is.</p>
<h2 id="_idParaDest-20"><a id="_idTextAnchor023"/>What is Ansible?</h2>
<p>Before we discuss how Ansible<a id="_idIndexMarker002"/> started, we should quickly discuss the origin of the name. The term “Ansible” was penned by science fiction novelist Ursula K. Le Guin; it was first used in her novel <em class="italic">Rocannon’s World</em>, which was first published in 1966. In the story’s context, an Ansible is a fictional device that sends and receives messages faster than light.</p>
<p class="callout-heading">Note</p>
<p class="callout">In 1974, Ursula K. Le Guin’s novel <em class="italic">The Dispossessed: An Ambiguous Utopia</em> was published. This book features the development of the Ansible technology by exploring the (fictional) details of the mathematical theory that would make such a device possible.</p>
<p>The term has since been used by several other notable authors within the genre to describe communication devices that are capable of relaying messages over interstellar distances, which, as you will discover throughout the course of the book, is quite an apt description of the software itself.</p>
<h2 id="_idParaDest-21"><a id="_idTextAnchor024"/>Ansible, the software</h2>
<p>Ansible was initially developed <a id="_idIndexMarker003"/>by Michael DeHaan, who was also the author of <strong class="bold">Cobbler</strong>, which was developed while DeHaan worked for Red Hat.</p>
<p class="callout-heading">Note</p>
<p class="callout">Cobbler is a Linux installation<a id="_idIndexMarker004"/> server that allows you to deploy servers within your network quickly; it can help with DNS, DHCP, package updates and distribution, virtual machine deployment, power management of physical hosts, and also the handoff of a newly deployed server, be it physical or virtual, to a configuration management system.</p>
<p>DeHaan left Red Hat<a id="_idIndexMarker005"/> and worked for companies such as <strong class="bold">Puppet</strong>, which was a good fit since many users of Cobbler used it to hand off to a Puppet server to manage the servers once they had been provisioned, myself included.</p>
<p>A few years after leaving Puppet, DeHaan made the first public commit to the Ansible project on February 23, 2012. The original <code>README</code> file gave quite a simple description that laid the foundation for what Ansible would eventually become:</p>
<p class="author-quote">Ansible is an extra-simple Python API for doing ‘remote things’ over SSH. As Func, which I co-wrote, aspired to avoid using SSH and have its own daemon infrastructure, Ansible aspires to be quite different and more minimal, but still able to grow more modularly over time.</p>
<p>Since that first commit, and at the time of writing, there have been over 53,000 commits by 5,000 contributors, and the project has over 58,000 stars on GitHub.</p>
<p>In 2013, the project had grown. Ansible, Inc. was founded to offer commercial support to users who had relied on the project to manage their infrastructure and server configuration, whether physical, virtual, or hosted on public clouds.</p>
<p>Out of the formation of Ansible, Inc., which received $6 million in series A funding, came the commercial Ansible Tower, which acted as a web-based frontend where end users could consume role-based access to Ansible services.</p>
<p>Then, in October 2015, Red Hat announced they would acquire Ansible for $150 million.</p>
<p>In the announcement, Joe Fitzgerald, who was vice president, Management, at Red Hat at the time of the acquisition, stated, <em class="italic">“Ansible is a clear leader in IT automation and DevOps, and helps Red Hat take a significant step forward in our goal of creating </em><em class="italic">frictionless IT.”</em></p>
<p>During this book, you will find<a id="_idIndexMarker006"/> that the statements in the original <code>README</code> file and Red Hat’s statement when acquiring Ansible still ring true.</p>
<p>Before we look at rolling our sleeves up and installing Ansible, which we will do later in this chapter, we should look at some of its core concepts.</p>
<h1 id="_idParaDest-22"><a id="_idTextAnchor025"/>Ansible versus other tools</h1>
<p>If you look at the design principles in the first commit compared to the current version, you will notice that while there have been some additions and tweaks, the core principles<a id="_idIndexMarker007"/> remain pretty much intact:</p>
<ul>
<li><strong class="bold">Agentless</strong>: Everything should be managed by the SSH daemon using the WinRM protocol in the case of Windows machines or API calls—there should be no reliance on custom agents or additional ports that need to be opened or interacted with on the target host. The machine running Ansible should need line of sight of the target resource network-wise.</li>
<li><strong class="bold">Minimal</strong>: You should be able to manage new remote machines without installing any new software on the target host; each Linux target host will typically have at least SSH and Python installed as part of a minimal installation, which is all needed to run Ansible.</li>
<li><strong class="bold">Descriptive</strong>: You should be able to describe your infrastructure, stack, or task in a language readable by machines and humans.</li>
<li><strong class="bold">Simple</strong>: The setup processes and the learning curve should be simple and intuitive.</li>
<li><strong class="bold">Easy to use</strong>: It should be the most accessible IT automation system ever.</li>
</ul>
<p>A few of these principles make Ansible quite different from other tools. Let’s examine the fundamental difference<a id="_idIndexMarker008"/> between Ansible and other tools, such as Puppet and <strong class="bold">Chef</strong>.</p>
<h2 id="_idParaDest-23"><a id="_idTextAnchor026"/>Declarative versus imperative</h2>
<p>When I started using Ansible, I had already<a id="_idIndexMarker009"/> implemented Puppet to help manage the stacks on the machines I was managing. As the configuration became increasingly complex, the Puppet code became highly complicated. This was when I started looking at alternatives, and some fixed some of the issues I was facing.</p>
<p>Puppet uses a custom declarative language to describe the configuration. Puppet then packages this configuration as a manifest that the agent running on each server then applies.</p>
<p>Using declarative language<a id="_idIndexMarker010"/> means that Puppet, Chef, and other configuration tools, such as <strong class="bold">CFEngine</strong>, all operate using the principle of eventual consistency, meaning that eventually, after a few runs of the agent, your desired configuration would be in place.</p>
<p>On the other hand, Ansible is an imperative language that, rather than just defining the end state of your desired outcome and letting the tool decide how it should get there, you also define the order in which tasks are executed to reach the state you have defined.</p>
<p>The example I use is as follows. We have a configuration<a id="_idIndexMarker011"/> where the following states need to be applied to a server:</p>
<ol>
<li>Create a group called <code>Team</code>.</li>
<li>Create a user <code>Alice</code> and add her to the group <code>Team</code>.</li>
<li>Create a user <code>Bob</code>, and add him to the group <code>Team</code>.</li>
<li>Give the user <code>Alice</code> escalated privileges.</li>
</ol>
<p>This may seem simple; however, when you execute these tasks using declarative language, you may, for example, find that the following <a id="_idTextAnchor027"/>happens:</p>
<div><div><img alt="Figure 1.1 – An overview of what happens with the declarative run" src="img/B21620_01_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – An overview of what happens with the declarative run</p>
<p>So, what has happened here? Our tool<a id="_idIndexMarker012"/> has executed the tasks during <code>Alice</code> could not be created when the first task ran because the group <code>Team</code> did<a id="_idTextAnchor028"/> not exist.</p>
<p>However, as the group <code>Team</code> was created before the user <code>Bob</code> was created, <code>Bob</code>’s user was created without any errors, and the final task, adding escalated privileges to the user <code>Alice</code>, failed because no user called <code>Alice</code> existed on the system for the escalated privileges to be applied to.</p>
<p>During <code>Team</code> existed, the user <code>Alice</code> was created, and because <code>Alice</code> was present, that user was given escalated privileges.</p>
<p>No changes were needed during <strong class="bold">run 3</strong> as everything was as expected; that is, consistent.</p>
<p>Each subsequent run would continue until there was either a change to the configuration or on the host itself, for example, if <code>Bob</code> had annoyed <code>Alice</code> and she used her escalated privileges to remove the user <code>Bob</code> from the host. When the agent subsequently runs, <code>Bob</code> will be recreated as that is still our desired configuration, no matter what access <code>Alice</code> thinks <code>Bob</code> should have.</p>
<p>If we were to run the same tasks using an imperative language, then the following should<a id="_idTextAnchor029"/> happen:</p>
<div><div><img alt="Figure 1.2 – An overview of what happens with the imperative run" src="img/B21620_01_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – An overview of what happens with the imperative run</p>
<p>The tasks are executed in the order<a id="_idIndexMarker013"/> we defined them, meaning that the <code>Team</code> group is created, the <code>Alice</code> and <code>Bob</code> users are added, and the escalated privileges to the <code>Alice</code> user are applied.</p>
<p>As you can see, both ways get to our final configuration and enforce our desired state. With the tools that use declarative language, it is possible to declare dependencies, meaning we can engineer the issue we encountered when running the tasks.</p>
<p>However, this example only has four steps; what happens when you have a few hundred steps that are launching servers in public cloud platforms and then installing software that needs several prerequisites?</p>
<p>This is the position I found myself in before I started to use Ansible. Puppet was great at enforcing my desired end configuration; however, to get there, I had to worry about building so much logic into my manifests to arrive at my desired state. In Puppet, this logic was using a function that allowed me as the end user to define my dependencies.</p>
<p>In the example we used, I would have had to define that users could only be created once the block of code that created the group had been run and the resource was present.</p>
<p>The more complex my code got, the more I fought the way the declarative tools wanted to run and the longer each execution would take because the tool had to consider my logic, which was a little hit and miss.</p>
<p>This became more annoying, as each successful run was getting close to taking about 40 minutes to complete. If I had dependency issues, I had to start from scratch with each failure and change to ensure that I was fixing the problem and not because things were starting to become consistent, so that typically meant having to redeploy a resource rather than running subsequent runs of my code. This made development very time-consuming, especially<a id="_idIndexMarker014"/> when it came to debugging the code, which sometimes involved trial and error.</p>
<p>This is not a great position to find yourself in when you are on the clock and must meet customer deadlines.</p>
<h2 id="_idParaDest-24"><a id="_idTextAnchor030"/>Configuration versus orchestration</h2>
<p>Another critical difference<a id="_idIndexMarker015"/> between Ansible and the other tools it is commonly compared to is that most of these tools have their origins as systems designed to deploy and police a configuration state.</p>
<p>They typically require an agent to be installed on each host; that agent discovers some information about the host it is installed on, then calls back to a central server saying, “<em class="italic">Hi, I am server XYZ. Could I please have my configuration?</em>” The server then decides what the configuration for the server looks like and sends it across to the agent, which then applies it. Typically, this exchange takes place every 15 to 30 minutes—this is great if you need to enforce a configuration on a server.</p>
<p>However, the way that Ansible has been designed to run allows it to act as an orchestration tool; for example, you can run it to launch a server in your VMware environment, and once the server has been launched, it can then connect to your newly launched machine and install a LAMP stack. Then, it never has to connect to that host again, meaning that all we are left with is the server, the LAMP stack, and nothing else, other than maybe a few comments in files to say that Ansible added some lines of configuration, which should <a id="_idIndexMarker016"/>be the only sign that Ansible was used to configure the host.</p>
<h2 id="_idParaDest-25"><a id="_idTextAnchor031"/>Looking at some code</h2>
<p>Before we finish this part<a id="_idIndexMarker017"/> of the chapter and move on to installing Ansible, let’s quickly look at examples of some actual code. The following bash script installs several RPMs using the yum package manager:</p>
<pre class="source-code">
#!/bin/sh
LIST_OF_APPS="dstat lsof mailx rsync tree vim-enhanced git whois"
yum install -y $LIST_OF_APPS</pre> <p>The following is a Puppet class that does the same task as the previous bash script:</p>
<pre class="source-code">
class common::apps {
  package {
    [
      'dstat',
      'lsof',
      'mailx',
      'rsync',
      'tree',
      'vim-enhanced',
      'git',
      'whois',
    ]:
    ensure =&gt; installed,
  }
}</pre> <p>Next up, we have<a id="_idIndexMarker018"/> the same task using <strong class="bold">SaltStack</strong>:</p>
<pre class="source-code">
common.packages:
  pkg.installed:
    - pkgs:
      - dstat
      - lsof
      - mailx
      - rsync
      - tree
      - vim-enhanced
      - git
      - whois</pre> <p>Finally, we have the same<a id="_idIndexMarker019"/> task again, this time using Ansible:</p>
<pre class="source-code">
- name: "Install packages we need"
  ansible.builtin.yum:
    name:
      - "dstat"
      - "lsof"
      - "mailx"
      - "rsync"
      - "tree"
      - "vim-enhanced"
      - "git"
      - "whois"
      - "iptables-services"
    state: "present"</pre> <p>Even without going into any detail, you should be able to get the general gist of what each of the three examples is doing. While not strictly infrastructure, all three are valid examples of infrastructure as code.</p>
<p>This is where you manage the code that manages your infrastructure in precisely the same way as a developer would manage the source code for their application. You use source control, store it in a centrally available repository where you can collaborate with your peers, branch and use pull requests to check in your changes, and, where possible, write and execute unit tests to ensure that changes to your infrastructure are successful and error-free before deploying to production. This should be as automated as possible. Any manual intervention in the tasks mentioned could be a point of failure, and you should work to automate the task.</p>
<p>This approach to infrastructure management has a few advantages, one being that you, as system administrators, are using the same processes and tooling as your developer colleagues, meaning that any procedures that apply to them also apply to you. This makes for a more consistent working experience and exposes you to tools you may have yet to be exposed to or use.</p>
<p>Secondly, and more importantly, it allows<a id="_idIndexMarker020"/> you to share your work. Before this approach, this type of work seemed to others a dark art performed only by system administrators. Doing this work in the open allows you to have your peers review and comment on your configuration and do the same yourself to theirs. Also, you can share your work so that others can incorporate elements into their projects.</p>
<h1 id="_idParaDest-26"><a id="_idTextAnchor032"/>My story: part two</h1>
<p>Before we finish this part of the chapter, I would like to finish the story of my journey. As mentioned earlier in the chapter, I moved from my collection of scripts and runbooks to Puppet, which was great until my requirements moved away from managing just server configuration and maintaining the servers’ state.</p>
<p>I needed to start managing infrastructure in public clouds. This requirement quickly started to frustrate me when using Puppet. At the time, Puppet’s coverage of the APIs I needed to use for my infrastructure needed to be improved. I am assured it is a lot better now, but also, I found myself having to build too much logic into my manifests about the order in which each task was executed.</p>
<p>It was around this time, which was December 2014, that I decided to look at Ansible. I know the date because I wrote a blog post entitled <em class="italic">First Steps With Ansible</em>; I don’t think I have looked back since. I have since introduced several of my work colleagues and customers to Ansible and have written books on the subject, including the first edition of the title you are reading now.</p>
<p>So far in this chapter, we have looked at my personal history with both Ansible and some of the other tools that Ansible is compared to, and we have discussed the differences between these tools and where Ansible originated.</p>
<p>Now we are going to start your journey with Ansible by looking at installing it and running our first Ansible playbook against a local virtual machine.</p>
<h1 id="_idParaDest-27"><a id="_idTextAnchor033"/>Installing and running Ansible</h1>
<p>Let’s dive straight in and install Ansible. Throughout this book, I will assume you are running a macOS host machine or a Linux machine with an Ubuntu LTS release. While we will cover running Ansible on Windows 11 using the Linux subsystem for Windows, this book will not support using Windows as a host machine.</p>
<h2 id="_idParaDest-28"><a id="_idTextAnchor034"/>Installing on macOS</h2>
<p>You can install Ansible on your macOS<a id="_idIndexMarker021"/> host machine in a few different ways. I will cover both here. As we are discussing two different ways of installing Ansible, I recommend reading through this section and the <em class="italic">Pros and cons</em> subsection before choosing which installation method to use on your local machine.</p>
<h3>Installing with Homebrew</h3>
<p>The first installation<a id="_idIndexMarker022"/> method is to<a id="_idIndexMarker023"/> use a <a id="_idIndexMarker024"/>package manager called <strong class="bold">Homebrew</strong>.</p>
<p class="callout-heading">Note</p>
<p class="callout">Homebrew is a package manager of macOS. It can be used to install command-line tools and desktop packages. It describes itself as <em class="italic">“The missing package manager for macOS”</em>, and it usually is one of the first tools I install after a clean installation or when getting a new computer.</p>
<p>To install Ansible using<a id="_idIndexMarker025"/> Homebrew, you first<a id="_idIndexMarker026"/> need to install Homebrew. To do this, run the following command:</p>
<pre class="console">
$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"</pre> <p>At each step of the installation process, the installer will tell you exactly what it is going to do and also prompt you for any additional information it needs from you to complete the installation.</p>
<p>Once installed, or if you already have Homebrew installed, run the following commands to update your list of packages; if there are any updates, then you can also upgrade them:</p>
<pre class="console">
$ brew update
$ brew upgrade</pre> <p>Finally, depending on how new your installation is or when you last used it, you might want to run the following command to check that your Homebrew installation is optimal:</p>
<pre class="console">
$ brew doctor</pre> <p>Now that we have Homebrew installed, updated, and ready to <code>brew</code>, we can run the following to check what Ansible packages Homebrew has by running:</p>
<pre class="console">
$ brew search ansible</pre> <p>As you can see from the results in the following screenshot, there are several packages returned in the search:</p>
<div><div><img alt="Figure 1.3 – Searching for Ansible using the brew command" src="img/B21620_01_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Searching for Ansible using the brew command</p>
<p>We want the Ansible package; you can find out more about the package by running the following command:</p>
<pre class="console">
$ brew info ansible</pre> <p>You can see the results of the command in the following screenshot:</p>
<div><div><img alt="Figure 1.4 – Viewing information on the Ansible package we will install" src="img/B21620_01_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Viewing information on the Ansible package we will install</p>
<p>As you can see, the command<a id="_idIndexMarker027"/> returns information on the version <a id="_idIndexMarker028"/>of the package that will be installed along with a complete list of its dependencies; in the preceding screen, all of the dependencies have green ticks next to them because I already have them installed—yours may look different.</p>
<p>It also gives the URL to the Homebrew formula, which will be used to install the package. In our case, you can view formula details at <a href="https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb">https://github.com/Homebrew/homebrew-core/blob/master/Formula/ansible.rb</a>.</p>
<p>To install Ansible using Homebrew, we must run the following command:</p>
<pre class="console">
$ brew install ansible</pre> <p>This will download and install all dependencies and then the Ansible package itself.</p>
<p>Depending on how many dependencies are installed on your machine, this may take a few minutes.</p>
<p>Once installed, you should see something like the following screenshot:</p>
<div><div><img alt="Figure 1.5 – Installing Ansible using Homebrew" src="img/B21620_01_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Installing Ansible using Homebrew</p>
<p>As you can see from the preceding screenshot, Homebrew is quite verbose in its output, giving you both feedback on what it is doing and details on how to use the packages it installs.</p>
<p>The second of two installation<a id="_idIndexMarker029"/> methods we will look at for macOS<a id="_idIndexMarker030"/> is a more traditional one.</p>
<h3>Installing using pip</h3>
<p>The second method, pip, is a more<a id="_idIndexMarker031"/> traditional approach<a id="_idIndexMarker032"/> to installing and configuring a Python package.</p>
<p class="callout-heading">Note</p>
<p class="callout"><code>pip</code> is a package manager<a id="_idIndexMarker033"/> for Python software. It is a recursive acronym for <strong class="bold">pip install packages</strong>. It is a good frontend for <a id="_idIndexMarker034"/>installing packages from the <strong class="bold">Python Package </strong><strong class="bold">Index</strong> (<strong class="bold">PyPI</strong>).</p>
<p>Most modern macOS installations come with pip installed by default; depending on what you have installed on your machine, you may have to check which pip binary you have installed.</p>
<p>To do this, run the following commands:</p>
<pre class="console">
$ pip --version
$ pip3 --version</pre> <p>One or both should return a version number and give you the path to the pip binary.</p>
<p>Depending on the version of pip you have installed, you may need to amend the following pip command, which is what we need to run to install Ansible:</p>
<pre class="console">
$ pip install ansible</pre> <p>This command will download and install all the prerequisites to run Ansible on your system. While it is as verbose as Homebrew, its output contains information on what it has done rather than<a id="_idTextAnchor035"/> hints on what to do next:</p>
<div><div><img alt="Figure 1.6 – Installing Ansible using Pip" src="img/B21620_01_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Installing Ansible using Pip</p>
<p>As you can see from the small<a id="_idIndexMarker035"/> amount of output, many of the requirements<a id="_idIndexMarker036"/> were already satisfied.</p>
<h3>Pros and cons</h3>
<p>So, now that we have covered<a id="_idIndexMarker037"/> some of the different ways of installing<a id="_idIndexMarker038"/> Ansible on macOS, which is best? Well, there is no real answer to this as it comes down to personal preference. Both methods will install the latest versions of Ansible. However, Homebrew tends to be a week or two behind the current release.</p>
<p>If you have a lot of packages already installed using Homebrew, then you will be used to running the following commands:</p>
<pre class="console">
$ brew update
$ brew upgrade</pre> <p>Just run these occasionally to update your installed packages to the latest versions. If you already do this, it makes sense to use Homebrew to manage your Ansible installation.</p>
<p>If you are not a Homebrew user and want to ensure that you immediately have the latest version installed, use the pip command to install Ansible. Upgrading to the latest version of Ansible is as simple as running the following command:</p>
<pre class="console">
$ pip install ansible --upgrade</pre> <p>Should you need to, you can install older versions of Ansible using Homebrew and pip.</p>
<p>To do this using Homebrew, you need to remove the current version by running the following command:</p>
<pre class="console">
$ brew uninstall ansible</pre> <p>Then, you can install an earlier version of the package by running the following command:</p>
<pre class="console">
$ brew install ansible@2.0</pre> <p>While this will install an earlier version, you do not have much choice in which version you get. If you really need an exact version, you can use the pip command to install it. For example, to install Ansible 2.3.1.0, you would need to run:</p>
<pre class="console">
$ pip install ansible==2.3.1.0</pre> <p>It is essential to note that you should never need to do this, and I do not recommend it.</p>
<p>However, I have found that on rare occasions, I have had to downgrade to help debug quirks in my playbooks introduced by upgrading to a later version of Ansible for playbooks that I last touched a few years ago.</p>
<p>As mentioned, I spend the bulk of my time in front of a macOS machine both during my day job and at home, so which of the two methods do I use?</p>
<p>Primarily, I use Homebrew<a id="_idIndexMarker039"/> as I have several other tools installed using<a id="_idIndexMarker040"/> Homebrew. However, if I need to roll back to a previous version, I use pip and then return to Homebrew once the issue is resolved.</p>
<h2 id="_idParaDest-29"><a id="_idTextAnchor036"/>Installing on Linux</h2>
<p>There are a few different<a id="_idIndexMarker041"/> ways of installing<a id="_idIndexMarker042"/> Ansible on Ubuntu. However, I am only going to cover one of them here. While there are packages available for Ubuntu that you can install with <code>apt</code>, they tend to become out of date quickly and are typically behind the current release.</p>
<p>If you wish to install using the <code>apt</code> package manager, then you can run the following command:</p>
<pre class="console">
$ apt install ansible</pre> <p class="callout-heading">Note</p>
<p class="callout"><code>.</code><code>deb</code> files.</p>
<p>Because of this, we will be using pip. The first thing to do is install pip, and this can be done by running the followi<a id="_idTextAnchor037"/>ng commands:</p>
<pre class="console">
$ sudo -H apt-get update
$ sudo -H apt-get install python3-pip</pre> <p>The first of the two <code>apt-get</code> commands<a id="_idIndexMarker044"/> downloads all the update files, ensuring that<a id="_idIndexMarker045"/> the package list is up to date on your Ubuntu installation, and the second command installs the <code>python3-pip</code> package and its dependencies.</p>
<p>Once pip is installed, the instruction for installing Ansible is similar to installing on macOS. Run the following command:</p>
<pre class="console">
$ sudo -H pip install ansible</pre> <p>This will download and then install Ansible and its requirements, a<a id="_idTextAnchor038"/>s shown in the following screenshot:</p>
<div><div><img alt="Figure 1.7 – Installing Ansible using pip on Ubuntu" src="img/B21620_01_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – Installing Ansible using pip on Ubuntu</p>
<p>Once installed, you can upgrade it by using the following command:</p>
<pre class="console">
$ sudo -H pip install ansible --upgrade</pre> <p>Also, downgrading Ansible uses the same command:</p>
<pre class="console">
$<a id="_idTextAnchor039"/> sudo -H pip install ansible==2.3.1.0</pre> <p>The preceding commands should work on most Linux distributions, such as Rocky Linux, Red Hat Enterprise Linux, Debian, and Linux Mint, to name a few.</p>
<p>A lot of these distributions have their own package managers you can also use to install Ansible; for example, on Red Hat-based distributions such as Red Hat Enterprise Linux or Rocky Linux, you could also run:</p>
<pre class="console">
$ dnf install ansible-core</pre> <p>Please consult the document for more<a id="_idIndexMarker046"/> details on installing whatever your Linux<a id="_idIndexMarker047"/> distribution of choice is.</p>
<h2 id="_idParaDest-30"><a id="_idTextAnchor040"/>Installing on Windows 11</h2>
<p>The last platform<a id="_idIndexMarker048"/> we will cover<a id="_idIndexMarker049"/> is Windows 11; well, sort of. While it is technically possible to run Ansible on a Windows 11 natively, it is not something I would recommend attempting as it is one of those tasks where the phrase “<em class="italic">just because you can doesn’t mean you should</em>” applies, as getting all of the dependencies installed and configured just right can be very troublesome, and maintaining them is more so.</p>
<p>Luckily, Microsoft—and as a long-term Linux System administrator typing this, this still feels strange—has excellent native support for running Linux systems seamlessly within Windows 11.</p>
<p>Open the Microsoft Store and search for Ubuntu; you should see something like the following screen:</p>
<div><div><img alt="Figure 1.8 – Finding Ubuntu in the Microsoft Store" src="img/B21620_01_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Finding Ubuntu in the Microsoft Store</p>
<p>Click the <strong class="bold">Get</strong> button to download <a id="_idIndexMarker050"/>Ubuntu. Once downloaded, we have Ubuntu<a id="_idIndexMarker051"/> on our Windows 11 host, but we still need something to run it on. To run it, we need to enable Windows Subsystem for Linux.</p>
<p>To enable this, open a PowerShell <a id="_idIndexMarker052"/>window by typing <strong class="bold">PowerShell</strong> into your Windows Search bar and opening the <strong class="bold">Windows PowerShell</strong> application; once you are at a terminal prompt, run the following command:</p>
<pre class="console">
$ wsl --install</pre> <p>Follow the onscreen prompts, and once everything is installed, restart your Windows 11 host.</p>
<p>Once rebooted, you should have something like the foll<a id="_idTextAnchor041"/>owing prompt pop-up once you log back in:</p>
<div><div><img alt="Figure 1.9 – Completing the Ubuntu installation on Windows 11" src="img/B21620_01_9.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Completing the Ubuntu installation on Windows 11</p>
<p>Once the installation is completed, I like to switch<a id="_idIndexMarker053"/> out of the default Windows <a id="_idIndexMarker054"/>Subsystem for the Linux terminal and use the Microsoft Terminal, which you can grab for free in the Microsoft Store.</p>
<p>Once you have your preferred terminal emulator open and you are sitting at a prompt in your Windows Subsystem for Linux Ubuntu installation, you can run the same commands we ran to install Ansible on Linux, which are as follows:</p>
<pre class="console">
$ sudo -H apt-get update
$ sudo -H apt-get install python3-pip
$ sudo -H pip install ansible</pre> <p>Once you have run these commands, you should see an output that looks like the following screenshot:</p>
<div><div><img alt="Figure 1.10 – Installing Ansible in Ubuntu on Windows 11" src="img/B21620_01_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Installing Ansible in Ubuntu on Windows 11</p>
<p>As you can see, everything works as if you were running an Ubuntu machine, allowing you to run and maintain your Ansible installation in precisely the same way.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <strong class="bold">Windows Subsystem for Linux</strong> (<strong class="bold">WSL</strong>) is not running on a virtual machine. It is a full native Linux<a id="_idIndexMarker055"/> experience baked right into Windows 11. It targets developers who must run Linux tools as part of their toolchain. While the overall support for Linux commands is excellent, I recommend reading through the FAQs written and maintained by Microsoft to get an idea of the limits and quirks<a id="_idIndexMarker056"/> of the subsystem. The FAQ can be found at <a href="https://learn.microsoft.com/en-us/windows/wsl/faq">https://learn.microsoft.com/en-us/windows/wsl/faq</a>.</p>
<p>As mentioned, while this is a viable <a id="_idIndexMarker057"/>way of running an Ansible control<a id="_idIndexMarker058"/> node on a Windows-based machine, some of the other tools we will cover in future chapters may not work with Windows. So, while you may follow along using the Ubuntu instructions, some parts may not work.</p>
<h1 id="_idParaDest-31"><a id="_idTextAnchor042"/>Launching a virtual machine</h1>
<p>To launch a virtual machine<a id="_idIndexMarker059"/> to run our first set of Ansible commands<a id="_idIndexMarker060"/> against, we will use a tool called <strong class="bold">Multipass</strong>. This tool allows you to run Ubuntu virtual machines on your local host. It works with macOS, Linux, and Windows.</p>
<p>To install Multipass on macOS, we can use Homebrew and run the following command:</p>
<pre class="console">
$ brew install multipass</pre> <p>To install on Ubuntu, you can run the following command:</p>
<pre class="console">
$ snap install multipass</pre> <p>Finally, for Windows 11 users, you will <a id="_idIndexMarker061"/>have to first download and install the VirtualBox<a id="_idIndexMarker062"/> Windows executable from <a href="https://www.virtualbox.org/wiki/Downloads">https://www.virtualbox.org/wiki/Downloads</a> and then download and install Multipass from https://multipass.run/install. I recommend reading through the installation notes for Windows, which<a id="_idIndexMarker063"/> can be found at the following URL https://multipass.run/docs/installing-on-windows before installing.</p>
<p class="callout-heading">Note</p>
<p class="callout">While you can run the same commands in Ubuntu running under Windows Subsystem for Linux, you will need to replace all references of the <code>multipass</code> command with <code>multipass.exe</code> so that the Windows version of Multipass is called.</p>
<p>Next, check out the GitHub repo accompanying this title and open your terminal in the <code>Chapter01</code> folder—if you are running Windows 11, you must open an Ubuntu terminal, not a Windows one.</p>
<p class="callout-heading">Important</p>
<p class="callout">Before we start, a quick word of warning: the folder <code>Chapter01</code> contains an OpenSSH key-pair, which will be used to access the local machine. It is important that you do not use this key-pair anywhere other than this example on your local machine as the key-pair is publicly accessible, which is not considered secure.</p>
<p>You will see several files in the <code>Chapter01</code> folder. The one we are going<a id="_idIndexMarker064"/> to use when launching the virtual machine is called <code>vmadmin</code> and attach the public portion of an OpenSSH key to the user, meaning that when executing Ansible, we can use the private part of the OpenSSH key to authenticate as the <code>vmadmin</code> user.</p>
<p>The command we are <a id="_idIndexMarker065"/>going to run to launch the virtual machine, which will be called <strong class="bold">ansiblevm</strong>, is as follows:</p>
<pre class="console">
$ multipass launch -n ansiblevm --cloud-init cloud-init.yaml</pre> <p>Once the virtual machine<a id="_idIndexMarker066"/> has been launched, which may take a short while when you first run the command as it will download a virtual machine image, you need to run the following command to get some information on the newly created <code>ansiblevm</code> virtual machine:</p>
<pre class="console">
$ multipass info ansiblevm</pre> <p>The following screen shows me startin<a id="_idTextAnchor043"/>g and viewing the information on the virtual<a id="_idTextAnchor044"/> machine:</p>
<div><div><img alt="Figure 1.11 – Launching our virtual machine" src="img/B21620_01_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – Launching our virtual machine</p>
<p>Now that we have our virtual machine running and we have checked out the basic information, you will need to note the IP address, which in my case is <code>192.168.64.7</code>. The IP address will be diff<a id="_idTextAnchor045"/>erent when you launch the virtual machine on your host.</p>
<p>Before we run our first Ansible playbook, you must make a copy of the <code>hosts-simple.example</code> and <code>hosts.example</code> files and remove the <code>.exa<a id="_idTextAnchor046"/>mple</code> in the filename by running the following commands:</p>
<pre class="console">
$ cp -pr hosts-simple.example hosts-simple
$ cp -pr hosts.example hosts</pre> <p>Once you have made a copy of the file, open the newly created files and replace just the text that says <code>paste_your_ip_here</code> with the IP address of the <code>ansiblevm</code> virtual machine; in my case, the <code>hosts-simple</code> file went from:</p>
<pre class="source-code">
paste_your_ip_here.nip.io ansible_user=vma<a id="_idTextAnchor047"/>dmin ansible_private_key_file=./example_key</pre> <p>to reading:</p>
<pre class="source-code">
192.168.64.7.nip.io ansible_user=vmadmin ansible_private_key_file=./example_key</pre> <p>Once you have changed<a id="_idIndexMarker067"/> both the <code>hosts-simple</code> and <code>hosts</code> files, you are ready to run your first Ansible Playbook.</p>
<h1 id="_idParaDest-32"><a id="_idTextAnchor048"/>An introduction to playbooks</h1>
<p>Typically, in IT, a <strong class="bold">playbook</strong> is a set of instructions run by someone<a id="_idIndexMarker068"/> when something happens; a little vague, I know, but stay with me. These range from building and configuring new server instances to deploying code updates and dealing with problems when they occur.</p>
<p>In the traditional sense, a playbook is typically a collection of scripts or instructions for a user to follow, and while they are meant to introduce consistency and conformity across systems, even with the best intentions, this is seldom the case.</p>
<p>This is where Ansible comes in. Using an Ansible playbook, you are telling it to apply these changes and commands against these sets of hosts rather than having to log in and start working your way through the playbook manually.</p>
<p>Before we run a playbook, let’s discuss how we provide Ansible with a list of hosts to target. To do this, we will be using the <code>ansible.builtin.setup</code> module. This connects to a host and then fetches as much information on the host as possible.</p>
<h2 id="_idParaDest-33"><a id="_idTextAnchor049"/>Host inventories</h2>
<p>To provide a list of hosts, we need to provide<a id="_idIndexMarker069"/> an inventory list. This is in the form of a host’s file.</p>
<p>In its simplest form, our host’s file co<a id="_idTextAnchor050"/>uld contain a single line just like our <code>hosts-simple</code> file:</p>
<pre class="source-code">
192.168.64.7.nip.io ansible_user=vmadmin ansible_private_key_file=./example_key</pre> <p>This tells Ansible that the host we want to contact is <code>192.168.64.7.nip.io</code> (please remember your IP address will be different) using the username <code>vmadmin</code>. If we didn’t provide the username, it would fall back to the user you are logged into your Ansible control host as, which in my case is the user <code>russ</code>, which does not exist on the <code>ansiblevm</code> we launched. The final part tells Ansible to use the private OpenSSH key file called <code>example_key</code>, which we installed the public portion of to t<a id="_idTextAnchor051"/>he <code>vmadmin</code> user when we launched the virtual machine.</p>
<p class="callout-heading">Note</p>
<p class="callout">We are using <a href="https://nip.io">https://nip.io</a>, a free service that provides free wildcard DNS entries for any hostname containing an IP address. This means that our domain <code>192.168.64.7.nip.io</code> will resolve to <code>192.168.64.7</code> when a DNS lookup is made against the domain.</p>
<p>To run the <code>ansible.builtin.setup</code> module, we need to run the following command from within the <code>Chapter01</code> folder where your updated <code>hosts-simple</code> and <code>example_key</code> files are<a id="_idTextAnchor052"/> stored, making sure to update the IP address to your own:</p>
<pre class="console">
$ ansible -i hosts-simple 192.168.64.7.nip.io -m ansible.builtin.setup</pre> <p>If everything works as expected, you should see a lot of output, which specifies some quite detailed and low-level information about <a id="_idTextAnchor053"/>your host. You should see something like the following:</p>
<div><div><img alt="Figure 1.12 – The start of the output of me running the ansible.builtin.setup module" src="img/B21620_01_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – The start of the output of me running the ansible.builtin.setup module</p>
<p>As you can see from the preceding<a id="_idIndexMarker070"/> screenshot, Ansible has quickly found out a lot of information on our Vagrant box. The screenshot shows the IP addresses configured on the machine, along with the IPv6 addresses. It has recorded the time and date, and if you scroll through your output, you will see a lot of information returne<a id="_idTextAnchor054"/>d detailing the host.</p>
<p>Let’s go back to the command we ran:</p>
<pre class="console">
$ ansible -i hosts-simple 192.168.64.7.nip.io -m ansible.builtin.setup</pre> <p>As you can see, we are loading the <code>hosts-simple</code> file using the <code>-i</code> flag. We could have also used <code>--inventory=hosts-simple</code>, which loads our inventory file. The next part of the command is the host to the target. In our case, this is <code>192.168.50.4.nip.io</code>. The final part of the command, <code>-m</code>, tells Ansible to use the setup module. We could have also used <code>--</code><code>module-name= ansible.builtin.setup</code>.</p>
<p>This means <a id="_idTextAnchor055"/>that the full command if we didn’t use shorthand would be:</p>
<pre class="console">
$ ansible --inventory=hosts-simple simple 192.168.64.7.nip.io --module-name=ansible.builtin.setup</pre> <p>As already mentioned, the <code>hosts-simple</code> file is as basic as we can g<a id="_idTextAnchor056"/>et it. The following is a more common host <a id="_idTextAnchor057"/>inventory file:</p>
<pre class="source-code">
<a id="_idTextAnchor058"/>ansiblevm <a id="_idTextAnchor059"/>ansible_host=192.168.64.7.nip.io
[ansible_hosts]
ansiblevm
[ansible_hosts:vars]
ansible_connection=ssh
ansible_user=vmadmin
ansible_private_key_file=./example_key
host_key_checking=False</pre> <p>This is the content of the file called just <code>hosts</code>; as you can see, there is a lot more going on, so let’s quickly work through it from top to bottom.</p>
<p>The first line defines our single host. Unlike the simple example, we will be calling our target host <code>ansiblevm</code> and grouping it together in a group called <code>ansible_hosts</code>, so we are giving Ansible details of where it can SSH to. This means we can now use the name <code>ansiblevm</code> when referring to <code>192.168.64.7.nip.io</code>. <a id="_idTextAnchor060"/>This means our command would now look something like t<a id="_idTextAnchor061"/>his:</p>
<pre class="console">
$ ansible -i hosts ansiblevm -m ansible.builtin.setup</pre> <p>Next up in the file, we are creating a group of hosts called <code>ansible_hosts</code> and, in that group, we are adding o<a id="_idTextAnchor062"/>ur single host <code>ansiblevm</code>. This means that we can also run:</p>
<pre class="console">
$ ansible -i hosts ansible_hosts -m ansible.builtin.setup</pre> <p>If we had more than just a single host in the group, the preceding command would have looped through all of them. The final section of the <code>hosts</code> file sets up some common configuration options for all of the hosts in the boxes group. In this case, we are telling Ansible that all of the hosts in the group are using SSH, the user is <code>vmadmin</code>, the private key at <code>./example_key</code> should be used, and it should not check the host key when connecting.</p>
<p>We will be revisiting the inventory host<a id="_idIndexMarker071"/> files in later chapters. From now on, we will use the <code>hosts</code> file to target the <code>ansible_hosts</code> group.</p>
<h2 id="_idParaDest-34"><a id="_idTextAnchor063"/>Playbooks</h2>
<p>In the previous section, running<a id="_idIndexMarker072"/> the <code>ansible</code> command allowed us to call a single module.</p>
<p>In this section, we are going to look at calling several modules. The following playbook is called <code>ansible.builtin.setup</code> module we called in the previous section and then uses the <code>ansible.builtin.debug</code> module to print a message to the screen:</p>
<pre class="source-code">
---
- name: "A simple playbook"
  hosts: ansible_hosts
  gather_facts: true
  become: true
  become_method: "ansible.builtin.sudo"
  tasks:
    - name: "Output some information on our host"
      ansible.builtin.debug:
        msg: "I am connecting to {{ ansible_nodename }} which is running {{ ansible_distribution }} {{ ansible_distribution_version }}"</pre> <p>Before we break the configuration down, let’s look at the results of <a id="_idTextAnchor064"/>running the playbook. To do this, use the following command:</p>
<pre class="console">
$ ansible-playbook -i hosts playbook01.yml</pre> <p>This will connect to our host, gather information on the system, a<a id="_idTextAnchor065"/>nd then return just the information we want in a message:</p>
<div><div><img alt="Figure 1.13 – The output of running ansible-playbook01.yml" src="img/B21620_01_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – The output of running ansible-playbook01.yml</p>
<p>The first thing you will notice<a id="_idIndexMarker073"/> about the playbook is that it is written in <strong class="bold">YAML</strong>, a recursive acronym for <strong class="bold">YAML Ain’t Markup Language</strong>. YAML was designed to be a human-readable data serialization standard that all programming languages can use. It is commonly used to help define configurations.</p>
<p>The indentation is very important in YAML as it is used to nest and define areas of the file. Let’s look at our playbook in more detail:</p>
<pre class="source-code">
---</pre> <p>While these lines might not seem like much, they are used as document separators, as Ansible compiles all the YAML files into a single file. It is essential for Ansible to know where one document ends and another begins.</p>
<p>Next up, we have the configuration<a id="_idIndexMarker074"/> for the playbook. As you can see, this is where the indentation starts to come into play:</p>
<pre class="source-code">
- name: "A simple playbook"
  hosts: ansible_hosts
  gather_facts: true
  become: true
  become_method: "ansible.builtin.sudo"</pre> <p>The <code>-</code> tells Ansible that this is the start of a section. From there, key-value pairs are used. These are as follows:</p>
<ul>
<li><code>name</code>: This gives a name to the playbook run.</li>
<li><code>hosts</code>: This tells Ansible the host or host group to target in the playbook. This must be defined in a host inventory like the ones we covered in the previous section.</li>
<li><code>gather_facts</code>: This tells Ansible to run the <code>ansible.builtin.setup</code> module when it first connects to the host. This information is then available to the playbook during the run.</li>
<li><code>become</code>: This is present because we are connecting<a id="_idIndexMarker075"/> to our host as a basic user, in this case, the <strong class="bold">vmadmin</strong> user. Ansible may not have enough access privileges to execute some of the commands we are telling it to, so this instructs Ansible to execute all of its commands as the root user.</li>
<li><code>become_method</code>: This tells Ansible how to become the root user; in our case, we have a passwordless sudo configured by the <code>cloud-init</code> script we ran when launching the virtual machine, so we are using <code>ansible.builtin.sudo</code>.</li>
<li><code>tasks</code>: These are the tasks we can tell Ansible to run when connected to the target host.</li>
</ul>
<p>You will notice that from here, we move<a id="_idIndexMarker076"/> the indentation across again. This defines another section of the configuration. This time it is for the tasks:</p>
<pre class="source-code">
    - name: "Output some information on our host"
      ansible.builtin.debug:
        msg: "I am connecting to {{ ansible_nodename }} which is running {{ ansible_distribution }} {{ ansible_distribution_version }}"</pre> <p>As we have already seen, the only task we run is the <code>ansible.builtin.debug</code> module. This module allows us to display output in the Ansible playbook run stream you saw when we ran the playbook.</p>
<p>You may have already noticed that the information between the curly brackets is made up of the keys from the <code>ansible.builtin.setup</code> module. Here, we are telling Ansible to substitute the value of each key wherever we use the key. We will be using this a lot in our playbooks. We will also be defining our own key values to use as part of our playbook runs.</p>
<p>Let’s extend our playbook by adding another<a id="_idIndexMarker077"/> task. The following can be found as <strong class="bold">playbook02.yml</strong>:</p>
<pre class="source-code">
---
- name: "Update all packages"
  hosts: "ansible_hosts"
  gather_facts: true
  become: true
  become_method: "ansible.builtin.sudo"
  tasks:
    - name: "Output some information on our host"
      ansible.builtin.debug:
        msg: "I am connecting to {{ ansible_nodename }} which is running {{ ansible_distribution }} {{ ansible_distribution_version }}"
    - name: "Update all packages to the latest version"
      ansible.builtin.apt:
        name: "*"
        state: "latest"
        update_cache: true</pre> <p>As you can see, we have added a second task that calls the <code>ansible.builtin.apt</code> module. This module is designed to help us interact with the package manager used by Ubuntu and other Debian-based operating systems called <code>apt</code>. We are setting three key values here:</p>
<ul>
<li><code>name</code>: This is a wildcard. It tells Ansible to use all of the installed packages rather than just a single named package. For example, we could have used something such as <code>apache2</code> here to target Apache.</li>
<li><code>state</code>: Here, we are telling Ansible to ensure the package we have defined in the name key is the <code>latest</code> version. As we have named all of the installed packages, this will update everything we have installed.</li>
<li><code>update_cache</code>: As the virtual machine image we downloaded was optimized for being small, it does not contain any information on the available package; by setting <code>update_cache</code> to <code>true</code>, this will download a list of all package and ve<a id="_idTextAnchor066"/>rsion information.</li>
</ul>
<p>Run the playbook using the following command:</p>
<pre class="console">
$ ansible-playbook -i <a id="_idTextAnchor067"/>hosts playbook02.yml</pre> <p>This will give us the following result<a id="_idTextAnchor068"/>s:</p>
<div><div><img alt="Figure 1.14 – The output of running ansible-playbook02.yml" src="img/B21620_01_14.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – The output of running ansible-playbook02.yml</p>
<p>The <code>ansible.builtin.apt</code> task has been marked<a id="_idIndexMarker078"/> as changed on the host box. This means that packages were upd<a id="_idTextAnchor069"/>ated.</p>
<p>Rerunning the same command shows the following results:</p>
<div><div><img alt="Figure 1.15 – The output of rerunning ansible-playbook02.yml" src="img/B21620_01_15.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – The output of rerunning ansible-playbook02.yml</p>
<p>As you can see, the <code>ansible.builtin.apt</code> task is now showing as <code>ok</code> on our host. This is because there are currently no longer any packages requiring updates.</p>
<p>Before we finish this quick look at playbooks, let’s do something more interesting.</p>
<p>The playbook, <code>playbook03.yml</code>, adds NTP installing, configuring, and starting capabilities to our virtual machine. It also uses a template to add a custom NTP config file to our virtual machine.</p>
<p>The <code>vars</code> section allows us to configure<a id="_idIndexMarker079"/> our own key-value pairs. In this case, we are providing a list of NTP servers, which we will be using later in the playbook:</p>
<pre class="source-code">
  vars:
    ntp_servers:
      - "0.uk.pool.ntp.org"
      - "1.uk.pool.ntp.org"
      - "2.uk.pool.ntp.org"
      - "3.uk.pool.ntp.org"</pre> <p>We are actually providing four different values for the same key. These will be used in the te<a id="_idTextAnchor070"/>mplate task. We could have also written this as follows:</p>
<pre class="source-code">
  vars:
    ntp_servers: [ "0.uk.pool.ntp.org", "1. uk.pool.ntp.org", "2. uk.pool.ntp.org", "3. uk.pool.ntp.org" ]</pre> <p>However, this is a little more difficult<a id="_idIndexMarker080"/> to read. The next new section is <code>handlers</code>. A <strong class="bold">handler</strong> is a task that is assigned<a id="_idIndexMarker081"/> a name and called at the end of a playbook run depending on what tasks have changed:</p>
<pre class="source-code">
  handlers:
    - name: "Restart ntp"
      ansible.builtin.service:
        name: "ntp"
        state: "restarted"</pre> <p>In our case, the restart <code>ntp</code> handler uses the <code>ansible.builtin.service</code> module to restart <code>ntp</code>. Next up, we have two new tasks, starting with installing the NTP service and the <code>sntp</code> and <code>ntp-doc</code> packages using <code>ansible.builtin.apt</code>:</p>
<pre class="source-code">
    - name: "Install packages"
      ansible.builtin.apt:
        state: "present"
        pkg:
          - "ntp"
          - "sntp"
          - "ntp-doc"</pre> <p>As we need to install three packages, we need a way to provide three different package names to the <code>ansible.builtin.apt</code> module so that we don’t have to have three different tasks for each of the package installations. To achieve this, we use the <code>pkg</code> option rather than the <code>name</code> option, where you can only define a single package to install. Rather than using <code>latest</code>, we are using <code>present</code>; this will mean that our packages don’t get updated if they are already installed.</p>
<p>The final addition to the playbook is the following task:</p>
<pre class="source-code">
    - name: "Configure NTP"
      ansible.builtin.template:
        src: "./ntp.conf.j2"
        dest: "/etc/ntp.conf"
        mode: "0644"
      notify: "Restart ntp"</pre> <p>This task uses the <code>ansible.builtin.template</code> module. To read a template file from our Ansible controller, process it and upload the processed template to the host machine. Once uploaded, we are telling Ansible to notify the <code>restart ntp</code> handler if there have been any changes to the configuration file we are uploading.</p>
<p>In this case, the template<a id="_idIndexMarker082"/> file is the <code>ntp.conf.j2</code> file in the same folder as the playbooks, as defined in the <code>src</code> option. This file looks like this:</p>
<pre class="source-code">
# {{ ansible_managed }}
driftfile /var/lib/ntp/drift
restrict default nomodify notrap nopeer noquery
restrict 127.0.0.1
restrict ::1
{% for item in ntp_servers %}
server {{ item }} iburst
{% endfor %}
includefile /etc/ntp/crypto/pw
keys /etc/ntp/keys
disable monitor</pre> <p>The bulk of the file is the standard NTP configuration file, with the addition of a few Ansible parts. The first addition is the very first line:</p>
<pre class="source-code">
# {{ ansible_managed }}</pre> <p>If this line wasn’t there every time we ran Ansible, the file would be uploaded, which would count as a change and the restart ntp handler would be called, meaning that even if there were no changes, NTP would be restarted.</p>
<p>The next part loops through the <code>ntp_servers</code> values we defined in the <code>vars</code> section of the playbook:</p>
<pre class="source-code">
{% for item in ntp_servers %}
server {{ item }} iburst
{% endfor %}</pre> <p>For each of the values, add a line that contains the word <code>server</code>, the value or <code>{{ item }},</code> and then <code>iburst</code>.</p>
<p>Now that we know what we have added to the playbook and have an idea of the additional task<a id="_idTextAnchor071"/>s that will be performed, let’s run it using the following command:</p>
<pre class="console">
$ ansible-playbook -i hosts playbook03.yml</pre> <p>The following screen just shows the additional tasks<a id="_idIndexMarker083"/><a id="_idTextAnchor072"/> and not the full output as we know it will be just marked as <code>ok</code>:</p>
<div><div><img alt="Figure 1.16 – The output of running ansible-playbook03.yml" src="img/B21620_01_16.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – The output of running ansible-playbook03.yml</p>
<p>This time, we have thre<a id="_idTextAnchor073"/>e changed tasks. Running the playbook again shows the following:</p>
<div><div><img alt="Figure 1.17 – The output of rerunning ansible-playbook03.yml" src="img/B21620_01_17.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.17 – The output of rerunning ansible-playbook03.yml</p>
<p>As expected, there are no changes because we haven’t changed the playbook or anything on the virtual machine, and Ansible is reporting everything as <code>ok</code>. Also, because no changes were detected to the NTP config file, the Handler to restart NTP did not need to be called, and therefore it doesn’t appear in the output.</p>
<p>Before we finish, let’s<a id="_idTextAnchor074"/> launch a second virtual machine by running the following command:</p>
<pre class="console">
$ multipass launch -n ansiblevm2 --cloud-init cloud-init.yaml</pre> <p>Once the second virtual machine<a id="_idIndexMarker084"/> has started, run the fo<a id="_idTextAnchor075"/>llowing command to get some information on the new virtual machine:</p>
<pre class="console">
$ multipass info ansiblevm2</pre> <p>Now that we know the IP address, we can add two new lines to our <code>hosts</code> file. First of all, to define the new host, add the following code (updating it so it uses the<a id="_idTextAnchor076"/> correct IP address) underneath where our original host is defined:</p>
<pre class="source-code">
ansiblevm2 ansible_host=192.168.64.8.nip.io</pre> <p>Then, add <code>ansiblevm2</code> to the <code>ansible_hosts</code> group:</p>
<pre class="source-code">
[ansible_hosts]
ansiblevm
ansiblevm2</pre> <p>Then, rerun the playbook using the following:</p>
<pre class="console">
$ ansible-playbook -i hosts playbook03.yml</pre> <p>As you can see, the same commands run, but now we are targeting both virtual machines, the original virtual machine has no changes, and all the changes are applied to the newly deployed host:</p>
<div><div><img alt="Figure 1.18 – The output of rerunning ansible-playbook03.yml against two virtual machines" src="img/B21620_01_18.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.18 – The output of rerunning ansible-playbook03.yml against two virtual machines</p>
<p>If you rerun the command, you will see that everything is now shown as <code>ok</code> as there are no further changes.</p>
<p>Before we move on to the summary, let’s tidy up our two virtual machines and remove them as we won’t need them again. To do this, run the following command:</p>
<pre class="console">
$ multipass delete --purge ansiblevm ansiblevm2</pre> <p>As I am sure you would have<a id="_idIndexMarker085"/> already guessed, this deletes the virtual machines and then purges the configuration and files.</p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor077"/>Summary</h1>
<p>In this chapter, we have taken our first steps with Ansible by installing it locally and then, using Vagrant, launching a virtual machine to interact with. We learned about basic host inventory files and used the Ansible command to execute a single task against our virtual machine.</p>
<p>We then looked at playbooks, starting with a basic playbook that returned some information on our target before progressing to a playbook that updates all the installed operating system packages before installing and configuring the NTP service.</p>
<p>By the end of the chapter, we had launched a second virtual machine and quickly brought it up to the same configuration level as our first virtual machine.</p>
<p>In the next chapter, we will look at Ansible Galaxy and discuss how Ansible packages up and maintains its community modules.</p>
<h1 id="_idParaDest-36"><a id="_idTextAnchor078"/>Further reading</h1>
<p>In this chapter, we mentioned Puppet and SaltStack:</p>
<ul>
<li><strong class="bold">Puppet</strong> is a configuration management tool that runs a server/agent configuration. It comes in two flavors—an open source version and an enterprise version that Puppet, the company, supports. It is a declarative system and is closely tied to Ruby. For more information on Puppet, see <a href="https://www.puppet.com/">https://www.puppet.com/</a>.</li>
<li><strong class="bold">SaltStack</strong> is another configuration management tool. It is highly scalable and, while it shares a design approach with Ansible, it works in a similar way to Puppet in that it has a server/agent approach. You can find more information on SaltStack at <a href="https://www.vmware.com/support/acquisitions/saltstack.html">https://www.vmware.com/support/acquisitions/saltstack.html</a>.</li>
<li>I also mentioned my personal blog, which you can find at <a href="https://www.russ.foo/">https://www.russ.foo/</a>.</li>
</ul>
<p>We used the following Ansible modules, and you can find out more information on each module at the following links:</p>
<ul>
<li><code>ansible.builtin.setup</code>: <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/setup_module.html</a></li>
<li><code>ansible.builtin.debug</code>: <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/debug_module.html</a></li>
<li><code>ansible.builtin.apt</code>: <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/apt_module.html</a></li>
<li><code>ansible.builtin.template</code>: <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/template_module.html</a></li>
<li><code>ansible.builtin.service</code>: <a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_module.html">https://docs.ansible.com/ansible/latest/collections/ansible/builtin/service_module.html</a></li>
</ul>
</div>
</body></html>