<html><head></head><body>
		<div><h1 id="_idParaDest-16"><em class="italic"><a id="_idTextAnchor015"/>Chapter 1</em>: Introducing Continuous Delivery</h1>
			<p>A common problem that's faced by most developers is how to release the implemented code quickly and safely. The delivery process that's traditionally used is a source of pitfalls and usually leads to the disappointment of both developers and clients. This chapter will present the idea of the <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) approach and provide the context for the rest of this book.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding CD</li>
				<li>The automated deployment pipeline</li>
				<li>Prerequisites to CD</li>
				<li>Combining CD and microservices</li>
				<li>Building the CD process</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Understanding CD</h1>
			<p>The most accurate definition<a id="_idIndexMarker000"/> of CD is stated by <em class="italic">Jez Humble</em> and reads as follows:</p>
			<p class="author-quote">"Continuous delivery is the ability to get changes of all types – including new features, configuration changes, bug fixes, and experiments – into production, or into the hands of users, safely and quickly, in a sustainable way."</p>
			<p>This definition covers the key points.</p>
			<p>To understand this better, let's imagine a scenario. You are responsible for a product – let's say, an email client application. Users come to you with a new requirement: they want to sort emails by size. You decide that the development will take around 1 week. <em class="italic">When can the user expect to use the feature?</em> Usually, after the development is done, you hand over<a id="_idIndexMarker001"/> the completed feature to the <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) team and then to the operations team, which takes additional time, ranging from days to months.</p>
			<p>Therefore, even though the development only took 1 week, the user receives it in a couple of months! The CD approach<a id="_idIndexMarker002"/> addresses this issue by automating manual tasks so that the user can receive a new feature as soon as it's implemented.</p>
			<p>To help you understand what to automate and how, we'll start by describing the delivery process that is currently used for most software systems.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>The traditional delivery process</h2>
			<p>The traditional delivery<a id="_idIndexMarker003"/> process, as its name suggests, has been in place for many years and is implemented in most IT companies. Let's define how it works and comment on its shortcomings.</p>
			<h3>Introducing the traditional delivery process</h3>
			<p>Every delivery process begins with the requirements that have been defined by a customer and ends with the product being released to production. There are differences between these two stages. Traditionally, this process looks as follows:</p>
			<p class="figure-caption"><img src="img/B18223_01_01.png" alt="Figure 1.1 – Release cycle diagram&#13;&#10;"/></p>
			<p class="figure-caption">Figure 1.1 – Release cycle diagram</p>
			<p>The release cycle starts with<a id="_idIndexMarker004"/> the requirements provided by the <strong class="bold">Product Owner</strong>, who represents the <strong class="bold">Customer</strong> (stakeholders). Then, there are three phases, during which the work is passed between different teams:</p>
			<ul>
				<li><strong class="bold">Development</strong>: The developers (sometimes together with business analysts) work<a id="_idIndexMarker005"/> on the product. They often use agile techniques (Scrum or Kanban) to increase the development velocity and improve communication with the client. Demo sessions are organized to obtain a customer's quick feedback. All good<a id="_idIndexMarker006"/> development techniques (such as <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>) or extreme programming practices) are welcome. Once the implementation is complete, the code is passed to the QA team.</li>
				<li><strong class="bold">Quality Assurance</strong>: This phase is usually called <strong class="bold">User Acceptance Testing</strong> (<strong class="bold">UAT</strong>) and it requires<a id="_idIndexMarker007"/> the code to be frozen<a id="_idIndexMarker008"/> on the trunk code<a id="_idIndexMarker009"/> base so that no new development<a id="_idIndexMarker010"/> will break the tests. The QA team performs a suite of <strong class="bold">integration testing</strong>, <strong class="bold">acceptance testing</strong>, and <strong class="bold">non-functional analysis</strong> (performance, recovery, security, and so on). Any bug<a id="_idIndexMarker011"/> that is detected goes back<a id="_idIndexMarker012"/> to the development team, so the developers usually have their hands full. After the UAT phase is completed, the QA team approves the features that have been planned for the next release.</li>
				<li><strong class="bold">Operations</strong>: The final phase, and usually the shortest one, involves passing the code to the operations<a id="_idIndexMarker013"/> team so that they can perform the release and monitor the production environment. If anything goes wrong, they contact the developers so that they can help with the production system.</li>
			</ul>
			<p>The length of the release cycle depends on the system and the organization, but it usually ranges from 1 week to a few months. The longest I've heard about was 1 year. The longest I worked on one was quarterly-based, and each part was as follows:</p>
			<ul>
				<li><strong class="bold">Development</strong>: 1.5 months</li>
				<li><strong class="bold">UAT</strong>: 1 month and 3 weeks</li>
				<li><strong class="bold">Release (and strict production monitoring)</strong>: 1 week</li>
			</ul>
			<p>The traditional delivery process is widely used in the IT industry, so this is probably not the first time you've read<a id="_idIndexMarker014"/> about such an approach. Nevertheless, it has several drawbacks. Let's look at them explicitly to understand why we need to strive for something better.</p>
			<h3>Shortcomings of the traditional delivery process</h3>
			<p>The most significant shortcomings<a id="_idIndexMarker015"/> of the traditional delivery process are as follows:</p>
			<ul>
				<li><strong class="bold">Slow delivery</strong>: The customer receives the product long after the requirements were specified. This results in unsatisfactory time to market and delays customer feedback.</li>
				<li><strong class="bold">Long feedback cycle</strong>: The feedback cycle is not only related to customers but developers. Imagine that you accidentally created a bug, and you learn about it during the UAT phase. <em class="italic">How long does it take to fix something you worked on 2 months ago?</em> Even dealing with minor bugs can take weeks.</li>
				<li><strong class="bold">Lack of automation</strong>: Rare releases do not encourage automation, which leads to unpredictable releases.</li>
				<li><strong class="bold">Risky hotfixes</strong>: Hotfixes cannot usually wait for the full UAT phase, so they tend to be tested differently (the UAT phase is shortened) or not tested at all.</li>
				<li><strong class="bold">Stress</strong>: Unpredictable releases are stressful for the operations team. What's more, the release cycle is usually tightly scheduled, which imposes additional stress on developers and testers.</li>
				<li><strong class="bold">Poor communication</strong>: Work that's passed from one team to another represents the waterfall approach, in which people start to care only about their part, rather than the complete product. If anything goes wrong, that usually leads to the blame game instead of cooperation.</li>
				<li><strong class="bold">Shared responsibility</strong>: No team takes responsibility for the product from A to Z:<ul><li><strong class="bold">For developers</strong>: <em class="italic">Done</em> means that the requirements have been implemented.</li><li><strong class="bold">For testers</strong>: <em class="italic">Done</em> means that the code has been tested.</li><li><strong class="bold">For operations</strong>: <em class="italic">Done</em> means that the code has been released.</li></ul></li>
				<li><strong class="bold">Lower job satisfaction</strong>: Each phase is interesting for a different team, but other teams need to support the process. For example, the development phase is interesting for developers but, during the other two phases, they still need to fix bugs and support the release, which is usually not interesting for them at all.</li>
			</ul>
			<p>These drawbacks<a id="_idIndexMarker016"/> represent just the tip of the iceberg of the challenges related to the traditional delivery process. You may already feel that there must be a better way to develop software and this better way is, obviously, the CD approach.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>The benefits of CD</h2>
			<p><em class="italic">How long would it take your organization to deploy a change that involves just a single line of code?</em> <em class="italic">Do you do this on a repeatable, reliable basis?</em> These are the famous questions from <em class="italic">Mary</em> and <em class="italic">Tom Poppendieck</em> (authors of <em class="italic">Implementing Lean Software Development</em>), which have been quoted many times by <em class="italic">Jez Humble</em> and others. The answers to these questions<a id="_idIndexMarker017"/> are the only valid measurement of the health of your delivery process.</p>
			<p>To be able to deliver continuously, and not spend a fortune on the army of operations teams working 24/7, we need automation. That is why, in short, CD is all about changing each phase of the traditional delivery process into a sequence of scripts called the <em class="italic">automated deployment pipeline</em>, or the <em class="italic">CD pipeline</em>. Then, if no manual steps are required, we can run the process after every code change and deliver the product continuously to users.</p>
			<p>CD lets us get rid of the tedious release cycle and brings the following benefits:</p>
			<ul>
				<li><strong class="bold">Fast delivery</strong>: Time to market is significantly reduced as customers can use the product as soon as development is completed. Remember that the software delivers no revenue until it is in the hands of its users.</li>
				<li><strong class="bold">Fast feedback cycle</strong>: Imagine that you created a bug in the code, which goes into production the same day. <em class="italic">How much time does it take to fix something you worked on the same day?</em> Probably not much. This, together with the quick rollback strategy, is the best way to keep production stable.</li>
				<li><strong class="bold">Low-risk releases</strong>: If you release daily, the process becomes repeatable and much safer. As the saying goes, <em class="italic">if it hurts, do it more often</em>.</li>
				<li><strong class="bold">Flexible release options</strong>: If you need to release<a id="_idIndexMarker018"/> immediately, everything is already prepared, so there is no additional time/cost associated with the release decision.</li>
			</ul>
			<p>Needless to say, we could achieve all these benefits simply by eliminating all the delivery phases and proceeding with development directly from production. However, this would result in a reduction in quality. The whole difficulty of introducing CD is the concern that the quality would decrease alongside eliminating any manual steps. In this book, we will show you how to approach CD safely and explain why, contrary to common beliefs, products that are delivered continuously contain fewer bugs and are better adjusted to the customer's needs.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor019"/>Success stories</h2>
			<p>My favorite story on CD was told by Rolf Russell<a id="_idIndexMarker019"/> at one of his talks. It goes as follows. In 2005, Yahoo! acquired Flickr, and it was a clash of two cultures in the developer's world. Flickr, by that time, was a company with the start-up approach in mind. Yahoo!, on the other hand, was a huge corporation with strict rules and a safety-first attitude. Their release processes differed a lot. While Yahoo used the traditional delivery process, Flickr released many times a day. Every change that was implemented by developers went into production the same day. They even had a footer at the bottom of their page showing the time of the last release and the avatars of the developers who made the changes.</p>
			<p>Yahoo! deployed rarely, and each release brought a lot of changes that were well-tested and prepared. Flickr worked in very small chunks; each feature was divided into small incremental parts, and each part was deployed to production quickly. The difference is presented in the following diagram:</p>
			<div><div><img src="img/B18223_01_02.jpg" alt="Figure 1.2 – Comparison of the release cycles of Yahoo! and Flickr&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2 – Comparison of the release cycles of Yahoo! and Flickr</p>
			<p>You can imagine what happened <a id="_idIndexMarker020"/>when the developers from the two companies met. Yahoo! treated Flickr's colleagues as irresponsible junior developers, a bunch of software cowboys who didn't know what they were doing. So, the first thing they wanted to do was add a QA team and the UAT phase to Flickr's delivery process. Before they applied the change, however, Flickr's developers had only one wish. They asked to evaluate the most reliable products throughout Yahoo! as a whole. It came as a surprise when they saw that even with all the software in Yahoo!, Flickr had the lowest downtime. The Yahoo! team didn't understand it at first, but they let Flickr stay with their current process anyway. After all, they were engineers, so the evaluation result was conclusive. Only after some time had passed did the Yahoo! developers realize that the CD process could be beneficial for all the products in Yahoo! and they started to gradually introduce it everywhere.</p>
			<p>The most important question of the story remains: <em class="italic">how come Flickr was the most reliable system?</em> The reason behind this was what we already mentioned in the previous sections. A release is less risky if the following is true:</p>
			<ul>
				<li>The delta of code changes is small</li>
				<li>The process is repeatable</li>
			</ul>
			<p>That is why, even though the release itself is a difficult activity, it is much safer when it's done frequently.</p>
			<p>The story of Yahoo! and Flickr is only one example of many successful companies where the CD process proved to be the correct choice. Nowadays, it's common for even small organizations to release frequently and market leaders such as Amazon, Facebook, Google, and Netflix perform thousands of releases per day.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">You can read more about the research on the CD process and individual case studies at <a href="https://continuousdelivery.com/evidence-case-studies/">https://continuousdelivery.com/evidence-case-studies/</a>.</p>
			<p>Keep in mind that the statistics get better every day. However, even without any numbers, just imagine a world in which every line of code you implement goes safely into production. Clients can react quickly and adjust their requirements, developers are happy as they don't have to solve that many bugs, and managers are satisfied because<a id="_idIndexMarker021"/> they always know the current state of work. After all, remember that the only true measure of progress is the software that is released.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>The automated deployment pipeline</h1>
			<p>We already know<a id="_idIndexMarker022"/> what the CD process is and why we use it. In this section, we'll describe how to implement it.</p>
			<p>Let's start by emphasizing that each phase in the traditional delivery process is important. Otherwise, it would never have been created in the first place. No one wants to deliver software without testing it! The role of the UAT phase is to detect bugs and ensure that what the developers have created is what the customer wanted. The same applies to the operations team – the software must be configured, deployed to production, and monitored. That's out of the question. So, <em class="italic">how do we automate the process so that we preserve all the phases?</em> That is the role of the automated deployment pipeline, which consists of three stages, as shown in the following diagram:</p>
			<div><div><img src="img/B18223_01_03.jpg" alt="Figure 1.3 – Automated deployment pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3 – Automated deployment pipeline</p>
			<p>The automated deployment pipeline<a id="_idIndexMarker023"/> is a sequence of scripts that is executed after every code change is committed to the repository. If the process is successful, it ends up being deployed to the production environment.</p>
			<p>Each step corresponds to a phase in the traditional delivery process, as follows:</p>
			<ul>
				<li><strong class="bold">Continuous integration</strong>: This checks to make sure that the code that's been written<a id="_idIndexMarker024"/> by different developers is integrated.</li>
				<li><strong class="bold">Automated acceptance testing</strong>: This checks if the client's requirements have been met by the developers<a id="_idIndexMarker025"/> implementing the features. This testing also replaces the manual QA phase.</li>
				<li><strong class="bold">Configuration management</strong>: This replaces the manual operations phase; it configures the environment<a id="_idIndexMarker026"/> and deploys the software.</li>
			</ul>
			<p>Let's take a deeper look at each phase to understand its responsibility and what steps it includes.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Continuous integration</h2>
			<p>The <strong class="bold">continuous integration</strong> (<strong class="bold">CI</strong>) phase provides the first set of feedback to developers. It checks out the code<a id="_idIndexMarker027"/> from the repository, compiles it, runs unit tests, and verifies the code's quality. If any step fails, the pipeline's execution is stopped and the first thing the developers should do is fix the CI build. The essential aspect of this phase is time; it must be executed promptly. For example, if this phase took 1 hour to complete, the developers would commit the code faster, which would result in a constantly failing pipeline.</p>
			<p>The CI pipeline<a id="_idIndexMarker028"/> is usually the starting point. Setting it up is simple because everything is done within the development team, and no agreement with the QA and operations teams is necessary.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Automated acceptance testing</h2>
			<p>The automated acceptance testing phase is a suite of tests written together with the client (and QAs) that is supposed to replace<a id="_idIndexMarker029"/> the manual UAT stage. It acts as a quality<a id="_idIndexMarker030"/> gate to decide whether a product is ready to be released. If any of the acceptance tests fail, pipeline execution is stopped and no further steps are run. It prevents movement to the configuration management phase and, hence, the release.</p>
			<p>The whole idea of automating the acceptance phase is to build quality into the product instead of verifying it later. In other words, when a developer completes the implementation, the software is delivered together with the acceptance tests, which verify that the software is what the client wanted. That is a large shift in thinking concerning testing software. There is no longer a single person (or team) who approves the release, but everything depends on passing the acceptance test suite. That is why creating this phase is usually the most difficult part of the CD process. It requires close cooperation with the client and creating tests at the beginning (not at the end) of the process.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Introducing automated acceptance tests is especially challenging in the case of legacy systems. We will discuss this topic in more detail in <a href="B18223_09_ePub.xhtml#_idTextAnchor242"><em class="italic">Chapter 9</em></a>, <em class="italic">Advanced Continuous Delivery</em>.</p>
			<p>There is usually a lot of confusion about the types of tests and their place in the CD process. It's also often<a id="_idIndexMarker031"/> unclear as to how to automate each type, what the coverage should be, and what the role of the QA team should be in the development process. Let's clarify this using the Agile testing matrix and the testing pyramid.</p>
			<h3>The Agile testing matrix</h3>
			<p>Brian Marick, in a series<a id="_idIndexMarker032"/> of his blog posts, classified software<a id="_idIndexMarker033"/> tests in the form of the agile testing matrix. It places tests in two dimensions – business - or technology-facing – and supports programmers or a critique of the product. Let's have a look at this classification:</p>
			<div><div><img src="img/B18223_01_04.jpg" alt="Figure 1.4 – Brian Marick's testing matrix&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4 – Brian Marick's testing matrix</p>
			<p>Let's look at each type of test:</p>
			<ul>
				<li><strong class="bold">Acceptance Testing (automated)</strong>: These are tests that represent the functional requirements<a id="_idIndexMarker034"/> that are seen from the business perspective. They are written in the form of stories or examples by clients and developers so that they can agree on how the software should work.</li>
				<li><strong class="bold">Unit Testing (automated)</strong>: These are tests that help developers provide high-quality software<a id="_idIndexMarker035"/> and minimize the number of bugs.</li>
				<li><strong class="bold">Exploratory Testing (manual)</strong>: This is the manual black-box testing phase, which tries to break <a id="_idIndexMarker036"/>or improve the system.</li>
				<li><strong class="bold">Non-Functional Testing (automated)</strong>: These are tests that represent system <a id="_idIndexMarker037"/>properties related to performance, scalability, security, and so on.</li>
			</ul>
			<p>This classification answers one of the most important questions about the CD process: <em class="italic">what is the role of a QA in the process?</em></p>
			<p>Manual QAs perform<a id="_idIndexMarker038"/> exploratory testing, which means they play with the system, try to break it, ask questions, and think about improvements. Automation QAs help with non-functional and acceptance testing; for example, they write code to support load testing. In general, QAs don't have a special place in the delivery process, but rather have a role in the development team.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the automated CD process, there is no longer a place for manual QAs who perform repetitive tasks.</p>
			<p>You may look at the classification and wonder why you see no integration tests there. <em class="italic">Where are they according to Brian Marick, and where can we put them in the CD pipeline?</em></p>
			<p>To explain this well, we need to mention that the meaning of an integration test differs based on the context. For (micro) service architectures, they usually mean the same as acceptance testing, as services are small and need nothing more than unit and acceptance tests. If you build a modular application, then integration tests usually mean component tests that bind multiple modules (but not the whole application) and test them together. In that case, integration tests place themselves somewhere between acceptance and unit tests. They are written in a similar way to acceptance tests, but they are usually more technical and require mocking not only external services but also internal modules. Integration tests, similar to unit tests, represent the code's point of view, while acceptance tests represent the user's point of view. In regards to the CD pipeline, integration tests are simply<a id="_idIndexMarker039"/> implemented as a separate phase in the process.</p>
			<h3>The testing pyramid</h3>
			<p>The previous section explained<a id="_idIndexMarker040"/> what each test type represents<a id="_idIndexMarker041"/> in the process, but mentioned nothing about how many tests we should develop. So, <em class="italic">what should the code coverage be in the case of unit testing? What about acceptance testing?</em></p>
			<p>To answer these questions, <em class="italic">Mike Cohn</em>, in his book <em class="italic">Succeeding with Agile</em>, created a so-called <strong class="bold">testing pyramid</strong>. The following diagram should help you develop a better understanding of this:</p>
			<div><div><img src="img/B18223_01_05.jpg" alt="Figure 1.5 – Mike Cohn's testing pyramid&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5 – Mike Cohn's testing pyramid</p>
			<p>When we move up the pyramid, the tests become slower and more expensive to create. They often require user interfaces to be touched and a separate test automation team to be hired. That is why acceptance tests should not target 100% coverage. On the contrary, they should be feature-oriented and only verify selected test scenarios. Otherwise, we would spend a fortune on test development and maintenance, and our CD pipeline build would take ages to execute.</p>
			<p>The case is different at the bottom of the pyramid. Unit tests are cheap and fast, so we should strive for 100% code coverage. They are written by developers, and providing them should be a standard procedure for any mature team.</p>
			<p>I hope that the agile testing matrix<a id="_idIndexMarker042"/> and the testing pyramid clarified the role<a id="_idIndexMarker043"/> and the importance of acceptance testing.</p>
			<p>Now, let's look at the last phase of the CD process: configuration management.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Configuration management</h2>
			<p>The configuration management phase<a id="_idIndexMarker044"/> is responsible for tracking and controlling<a id="_idIndexMarker045"/> changes in the software and its environment. It involves taking care of preparing and installing the necessary tools, scaling the number of service instances and their distribution, infrastructure inventory, and all the tasks related to application deployment.</p>
			<p>Configuration management is a solution to the problems that are posed by manually deploying and configuring applications in production. This common practice results in an issue whereby we no longer know where each service is running and with what properties. Configuration management tools (such as Ansible, Chef, and Puppet) enable us to store configuration files in the version control system and track every change that was made to the production servers.</p>
			<p>Additional effort to replace the operations team's manual tasks involves taking care of application monitoring. This is usually done by streaming the logs and metrics of the running systems to a common dashboard, which is monitored by developers (or the DevOps team, as explained in the next section).</p>
			<p>One other term related to configuration management<a id="_idIndexMarker046"/> that has recently gained a lot of traction is <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>). If you use the cloud instead of bare-metal servers, then tools such as Terraform or AWS CloudFormation let you store the description of your infrastructure, not only your software, in the version control system. We will discuss both configuration management and IaC in<em class="italic"> </em><a href="B18223_07_ePub.xhtml#_idTextAnchor185"><em class="italic">Chapter 7</em></a>, <em class="italic">Configuration Management with Ansible</em>.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor024"/>Prerequisites to CD</h1>
			<p>The rest of this book<a id="_idIndexMarker047"/> is dedicated to technical details on how to implement a successful CD pipeline. The success of this process, however, depends not only on the tools we present throughout this book. In this section, we will take a holistic look at the whole process and define the CD requirements in three areas:</p>
			<ul>
				<li>Your organization's structure and its impact on the development process</li>
				<li>Your products and their technical details</li>
				<li>Your development team and the practices you adopt</li>
			</ul>
			<p>Let's start with the organizational prerequisites.</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Organizational prerequisites</h2>
			<p>The way your organization works<a id="_idIndexMarker048"/> has a high impact on the success of introducing the CD process. It's a bit similar to introducing Scrum. Many organizations would like to use the Agile<a id="_idIndexMarker049"/> process, but they don't change their culture. You can't use Scrum in your development team unless the organization's structure has been adjusted for that. For example, you need a product owner, stakeholders, and a management team that understands that no requirement changes are possible during the sprint. Otherwise, even with good intentions, you won't make it. The same applies to the CD process; it requires you to adjust how the organization is structured. Let's have a look at three aspects: the DevOps culture, a client in the process, and business decisions.</p>
			<h3>DevOps culture</h3>
			<p>A long time ago, when software<a id="_idIndexMarker050"/> was written by individuals or micro teams, there was no clear separation between development, quality assurance, and operations. A person developed the code, tested it, and then put it into production. If anything went wrong, the same person investigated the issue, fixed it, and redeployed it to production. The way the development process is organized changed gradually; systems became larger and development teams grew. Then, engineers started to become specialized in one area. This made perfect sense as specialization caused a boost in productivity. However, the side effect was the communication overhead. This is especially visible if developers, QAs, and operations<a id="_idIndexMarker051"/> are in separate departments in the organization, sit in different buildings, or are outsourced to different countries. This organizational structure is not good for the CD process. We need something better; we need to adopt the DevOps culture.</p>
			<p>DevOps culture means, in a sense, going back to the roots. A single person or a team is responsible for all three areas, which are shown in the following diagram:</p>
			<div><div><img src="img/B18223_01_06.jpg" alt="Figure 1.6 – DevOps culture&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6 – DevOps culture</p>
			<p>The reason it's possible to move to the DevOps model without losing productivity is automation. Most of the tasks that are related to QA and operations are moved to the automated delivery pipeline, so they can be managed by the development team.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">A DevOps team doesn't necessarily need to consist of only developers. A very common scenario in many organizations that are transforming is to create teams with four developers, one QA, and one person from operations. However, they need to work closely together (sit in one area, have stand-ups together, and work on the same product).</p>
			<p>The culture of small DevOps teams affects the software architecture. Functional requirements have to be separated into (micro) services or modules so that each team can take care of an independent<a id="_idIndexMarker052"/> part.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">The impact of the organization's structure on the software architecture was observed in 1967 and formulated as Conway's law: "<em class="italic">Any organization that designs a system (defined broadly) will produce a design whose structure is a copy of the organization's communication structure</em>."</p>
			<h3>A client in the process</h3>
			<p>The role<a id="_idIndexMarker053"/> of a client (or a product owner) changes slightly during CD adoption. Traditionally, clients are involved in defining requirements, answering questions from developers, attending demos, and taking part in the UAT phase to determine whether what was built is what they had in mind.</p>
			<p>In CD, there is no UAT, and a client is essential in the process of writing acceptance tests. For some clients, who have already written their requirements in a testable manner, this is not a big shift. For others, it means changing their way of thinking to make the requirements more technically oriented.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">In the agile environment, some teams don't even accept user stories (requirements) without acceptance tests attached. These techniques, even though they may sound too strict, often lead to better development productivity.</p>
			<h3>Business decisions</h3>
			<p>In most companies, the business<a id="_idIndexMarker054"/> has an impact on the release schedule. After all, the decision of what features are delivered, and when, is related to different departments within the company (for example, marketing) and can be strategic for the enterprise. That is why the release schedule has to be re-approached and discussed between the business and the development teams.</p>
			<p>There are techniques, such as feature toggles or manual pipeline steps, that help with releasing features at the specified time. We will describe them later in this book. To be precise, the term <em class="italic">continuous delivery</em> is not the same as <em class="italic">continuous deployment</em>. The latter means that each commit to the repository is automatically released to production. Continuous delivery<a id="_idIndexMarker055"/> is less strict and means that each commit ends up with a release candidate, so it allows the last step (from release to production) to be manual.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Throughout the remainder of this book, we will use the terms continuous delivery and continuous deployment interchangeably.</p>
			<h2 id="_idParaDest-27"><a id="_idTextAnchor026"/>Technical and development prerequisites</h2>
			<p>From the technical<a id="_idIndexMarker056"/> side, there are a few requirements to keep in mind. We will discuss them throughout<a id="_idIndexMarker057"/> this book, so let's only mention them here without going into detail:</p>
			<ul>
				<li><strong class="bold">Automated build, test, package, and deploy operations</strong>: All operations need to be able to be automated. If we deal with a system that is non-automatable, for example, due to security reasons or its complexity, it is impossible to create a fully automated delivery pipeline.</li>
				<li><strong class="bold">Quick pipeline execution</strong>: The pipeline must be executed promptly, preferably in 5-15 minutes. If our pipeline execution takes hours or days, it will not be possible to run it after every commit to the repository.</li>
				<li><strong class="bold">Quick failure recovery</strong>: The possibility of a quick rollback or system recovery is necessary. Otherwise, we risk production health due to frequent releases.</li>
				<li><strong class="bold">Zero-downtime deployment</strong>: The deployment cannot have any downtime since we release it many times a day.</li>
				<li><strong class="bold">Trunk-based development</strong>: Developers must check into one main branch regularly. Otherwise, if everyone develops in their branches, integration is rare, which means that releases are rare, which is exactly the opposite of what we want to achieve.</li>
			</ul>
			<p>We will learn more about these prerequisites and how to address them throughout this book. With this in mind, let's move<a id="_idIndexMarker058"/> to the last section of this chapter<a id="_idIndexMarker059"/> and introduce what system we plan to build in this book and what tools we will use for that purpose.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Combining CD and microservices</h1>
			<p>We live in the world<a id="_idIndexMarker060"/> of microservices. Nowadays, every system is either microservice-based<a id="_idIndexMarker061"/> or in the process of becoming microservice-based. After the first publication of the bestseller<a id="_idIndexMarker062"/> book by Sam Newman, <em class="italic">Building Microservices</em>, the software world has shifted into the fine-grained modular systems in which all communication happens over the network. Some companies have gone one step further and realized that they need to consolidate some of the microservices as they created too many of them. Some other companies even take a step back and consolidate microservices into a monolith.</p>
			<p>While the topic of microservices is broad on its own and outside the scope of this book, it is important to understand how the microservice architecture affects the CD pipeline. Should we create a separate pipeline for each service? If yes, then how do we test the interaction between the services and the system as a whole?</p>
			<p>Before answering these questions, let's look at the following diagram, which represents a small microservice-based system:</p>
			<div><div><img src="img/B18223_01_07.jpg" alt="Figure 1.7 – Sample microservice system&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7 – Sample microservice system</p>
			<p>There are three services in our system, each with a database. A user only interacts with <em class="italic">Service 1</em>. As a more concrete example, this system could represent an online store, where <em class="italic">Service 1</em> could represent the checkout service, <em class="italic">Service 2</em> could represent the product catalog service, and <em class="italic">Service 3</em> could represent customer service.</p>
			<p>We could either implement<a id="_idIndexMarker063"/> one CD pipeline for the entire system<a id="_idIndexMarker064"/> or a separate CD pipeline for each microservice. Which approach is the right one? Let's consider both options. If we create one CD pipeline, this means that the automated acceptance testing phase runs against the entire system from the end user's perspective, which seems correct. However, one CD pipeline also means that we deploy all the services at the same time, which is completely against the microservice principles. Remember that in every microservice-based system, services are loosely coupled and should always be independently deployable.</p>
			<p>So, we need to take the second approach and create a separate CD pipeline for each service. However, in such a case, the automated acceptance testing phase never runs against the entire system. So, how can we be sure that everything works correctly from the end user's perspective? To answer this question, we need a little more context about the microservice architecture.</p>
			<p>In the microservice architecture, each service is a separate unit that's usually developed and maintained by a separate team. Services are loosely coupled, and they communicate over a well-defined API, which should always be kept backward compatible. In that context, each internal microservice does not differ much from an external service. That's why we should always be able to deploy a new service without testing other services. Note that it does not exclude the possibility of having a separate acceptance test for the entire system. All it explains is that the acceptance test of the entire system should not be a gatekeeper for deploying a single service.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">The CD process is suitable for both monolith and microservice-based systems. In the former case, we should always create a separate CD pipeline for each microservice.</p>
			<p>For the sake of simplicity, all the examples<a id="_idIndexMarker065"/> in this book present a system<a id="_idIndexMarker066"/> that consists of a single service.</p>
			<h1 id="_idParaDest-29"><a id="_idTextAnchor028"/>Building the CD process</h1>
			<p>So far, we've introduced the idea, benefits, and prerequisites concerning<a id="_idIndexMarker067"/> the CD process. In this section, we will describe the tools that will be used throughout this book and their place in the system as a whole.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">If you're interested in the idea of the CD process, have a look at the excellent book by <em class="italic">Jez Humble</em> and <em class="italic">David Farley</em>, called <em class="italic">Continuous Delivery: Reliable Software Releases through Build, Test, and Deployment Automation</em>.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor029"/>Introducing tools</h2>
			<p>First of all, the tool<a id="_idIndexMarker068"/> is always less important than understanding its role in the process. In other words, any tool can be replaced with another one that plays the same role. For example, Jenkins<a id="_idIndexMarker069"/> can be replaced with Atlassian Bamboo, and Chef can be used instead of Ansible. This is why each chapter will begin with a general description of why such a tool is necessary and its role in the whole process. Then, the tool will be described in comparison to its substitutes. This will give you the flexibility to choose the right one for your environment.</p>
			<p>Another approach could be to describe the CD process at the idea level; however, I strongly believe that giving an exact example, along with the code extract – something that you can run by yourself – results in a much better understanding of the concept.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">There are two ways to read this book. The first is to read and understand the concepts of the CD process. The second is to create an environment and execute all the scripts while reading to understand the details.</p>
			<p>Let's take a quick look at the tools<a id="_idIndexMarker070"/> we will use throughout this book. This section, however, is only a brief introduction to each technology – more details will be provided later in this book.</p>
			<h3>The Docker ecosystem</h3>
			<p>Docker, as the clear leader<a id="_idIndexMarker071"/> of the containerization movement, has dominated<a id="_idIndexMarker072"/> the software industry in recent years. It allows us to package an application in an environment-agnostic image and treats servers as a farm of resources, rather than machines that must be configured for each application. Docker was a clear choice for this book because it fits the (micro) service world and the CD process.</p>
			<p>Docker entails several additional technologies, as follows:</p>
			<ul>
				<li><strong class="bold">Docker Hub</strong>: This is a registry<a id="_idIndexMarker073"/> for Docker images</li>
				<li><strong class="bold">Kubernetes</strong>: This is a container<a id="_idIndexMarker074"/> orchestrator<p class="callout-heading">Information</p><p class="callout">In the first edition of this book, Docker Compose and Docker Swarm were presented as tools for clustering and scheduling multi-container applications. Since that time, however, Kubernetes has become the market leader and is used instead.</p></li>
			</ul>
			<h3>Jenkins</h3>
			<p>Jenkins is by far<a id="_idIndexMarker075"/> the most popular automation server<a id="_idIndexMarker076"/> on the market. It helps create CI and CD pipelines and, in general, any other automated sequence of scripts. Highly plugin-oriented, it has a great community that constantly extends<a id="_idIndexMarker077"/> it with new features. What's more, it allows us to write the pipeline as code and supports distributed<a id="_idIndexMarker078"/> build environments.</p>
			<h3>Ansible</h3>
			<p>Ansible is an automation tool<a id="_idIndexMarker079"/> that helps with software provisioning, configuration<a id="_idIndexMarker080"/> management, and application deployment. It is trending faster than any other configuration management engine and will soon overtake its two main competitors: Chef and Puppet. It uses an agentless architecture and integrates smoothly with Docker.</p>
			<h3>GitHub</h3>
			<p>GitHub is the best of all hosted version<a id="_idIndexMarker081"/> control systems. It provides a very<a id="_idIndexMarker082"/> stable system, a great web-based UI, and a free service for public repositories. Having said that, any source control management service or tool will work with CD, irrespective of whether it's in the cloud or self-hosted, and whether it's based on Git, SVN, Mercurial, or any other tool.</p>
			<h3>Java/Spring Boot/Gradle</h3>
			<p>Java has been the most<a id="_idIndexMarker083"/> popular programming language for years. That's why it will be used for most<a id="_idIndexMarker084"/> of the code examples<a id="_idIndexMarker085"/> in this book. Together<a id="_idIndexMarker086"/> with Java, most companies<a id="_idIndexMarker087"/> develop with the Spring<a id="_idIndexMarker088"/> framework, so we used it to create a simple web service to explain some concepts. Gradle is used as a build tool. It's still less popular than Maven, but it's trending much faster. As always, any programming language, framework, or build tool can be exchanged and the CD process would stay the same, so don't worry if your technology stack is different.</p>
			<h3>The other tools</h3>
			<p>Cucumber <a id="_idIndexMarker089"/>was chosen arbitrarily as the acceptance<a id="_idIndexMarker090"/> testing framework. Other similar solutions<a id="_idIndexMarker091"/> are FitNesse and Jbehave. For the<a id="_idIndexMarker092"/> database migration process, we will use Flyway, but any other tool would do, such as Liquibase.</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor030"/>Creating a complete CD system</h2>
			<p>You can look at how this book is organized from two perspectives.</p>
			<p>The first one is based on the steps of the automated deployment pipeline. Each chapter takes you closer<a id="_idIndexMarker093"/> to the complete CD process. If you look at the names of the chapters, some of them are even named like the pipeline phases:</p>
			<ul>
				<li>The CI pipeline</li>
				<li>Automated acceptance testing</li>
				<li>Configuration management with Ansible</li>
			</ul>
			<p>The rest of the chapters provide an introduction, summary, or additional information that's complementary to the process.</p>
			<p>There is also a second perspective to the content of this book. Each chapter describes one piece of the environment, which, in turn, is well prepared for the CD process. In other words, this book presents, step by step, technology by technology, how to build a complete system. To help you get a feel of what we plan to build throughout this book, let's have a look at how the system will evolve in each chapter.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Don't worry if you don't understand the concepts and terminology at this point. We will be learning everything from scratch in the corresponding chapters.</p>
			<h3>Introducing Docker</h3>
			<p>In <a href="B18223_02_ePub.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a>, <em class="italic">Introducing Docker</em>, we will start from the center of our system and build a working<a id="_idIndexMarker094"/> application that's been packaged as a Docker image. The output of this chapter is presented in the following diagram:</p>
			<div><div><img src="img/B18223_01_08.jpg" alt="Figure 1.8 – Introducing Docker&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8 – Introducing Docker</p>
			<p>A dockerized application (web service) is run<a id="_idIndexMarker095"/> as a container on a <strong class="bold">Docker Host</strong> and is reachable as it will run directly<a id="_idIndexMarker096"/> on the host machine. This is possible thanks to port forwarding (port publishing in Docker's terminology).</p>
			<h3>Configuring Jenkins</h3>
			<p>In <a href="B18223_03_ePub.xhtml#_idTextAnchor073"><em class="italic">Chapter 3</em></a>, <em class="italic">Configuring Jenkins</em>, we will prepare the Jenkins<a id="_idIndexMarker097"/> environment. Thanks to the support of multiple agent (slave) nodes, it can handle the heavy concurrent load. The result is presented in the following diagram:</p>
			<div><div><img src="img/B18223_01_09.jpg" alt="Figure 1.9 – Configuring Jenkins&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9 – Configuring Jenkins</p>
			<p>The <strong class="bold">Jenkins</strong> master accepts a build request, but the<a id="_idIndexMarker098"/> execution is started at one of the <strong class="bold">Jenkins Slave</strong> (agent) machines. Such an approach<a id="_idIndexMarker099"/> provides horizontal scaling of the Jenkins environment.</p>
			<h3>The CI pipeline</h3>
			<p>In <a href="B18223_04_ePub.xhtml#_idTextAnchor106"><em class="italic">Chapter 4</em></a>, <em class="italic">Continuous Integration Pipeline</em>, we'll show you how to create<a id="_idIndexMarker100"/> the first phase of the CD pipeline: the commit stage. The output of this chapter is shown in the following diagram:</p>
			<div><div><img src="img/B18223_01_10.jpg" alt="Figure 1.10 – The CI pipeline&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10 – The CI pipeline</p>
			<p>The application<a id="_idIndexMarker101"/> is a simple web service written in Java with the Spring Boot framework. Gradle is used as a build tool and GitHub is used as the source code repository. Every commit to GitHub automatically triggers the Jenkins build, which uses Gradle to compile Java code, run unit tests, and perform additional checks (code coverage, static code analysis, and so on). Once the Jenkins build is complete, a notification is sent to the developers.</p>
			<p>After this chapter, you will be able to create a complete CI pipeline.</p>
			<h3>Automated acceptance testing</h3>
			<p>In <a href="B18223_05_ePub.xhtml#_idTextAnchor133"><em class="italic">Chapter 5</em></a>, <em class="italic">Automated Acceptance Testing</em>, we'll merge the two technologies mentioned<a id="_idIndexMarker102"/> in this book's title: <em class="italic">Docker</em> and <em class="italic">Jenkins</em>. This will result in the system presented in the following diagram:</p>
			<div><div><img src="img/B18223_01_11.jpg" alt="Figure 1.11 – Automated acceptance testing&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11 – Automated acceptance testing</p>
			<p>The additional elements in the preceding diagram are related to the automated acceptance testing stage:</p>
			<ul>
				<li><strong class="bold">Docker Registry</strong>: After the CI phase, the application<a id="_idIndexMarker103"/> is packaged into a JAR file and then as a Docker<a id="_idIndexMarker104"/> image. That image is then pushed to the <strong class="bold">Docker Registry</strong>, which acts as storage for dockerized applications.</li>
				<li><strong class="bold">Docker Host</strong>: Before performing the acceptance<a id="_idIndexMarker105"/> test suite, the application<a id="_idIndexMarker106"/> must be started. Jenkins triggers a <strong class="bold">Docker Host</strong> machine to pull the dockerized application from the <strong class="bold">Docker Registry</strong> and starts it.</li>
				<li><strong class="bold">Cucumber</strong>: After the application<a id="_idIndexMarker107"/> is started on the <strong class="bold">Docker Host</strong>, Jenkins runs a suite of acceptance<a id="_idIndexMarker108"/> tests written in the <strong class="bold">Cucumber</strong> framework.</li>
			</ul>
			<h3>Clustering with Kubernetes</h3>
			<p>In <a href="B18223_06_ePub.xhtml#_idTextAnchor152"><em class="italic">Chapter 6</em></a>, <em class="italic">Clustering with Kubernetes</em>, we replace<a id="_idIndexMarker109"/> a single Docker host with a Kubernetes cluster and a single standalone application with two dependent containerized applications. The output is the environment shown in the following diagram:</p>
			<div><div><img src="img/B18223_01_12.jpg" alt="Figure 1.12 – Clustering with Kubernetes&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12 – Clustering with Kubernetes</p>
			<p>Kubernetes provides an abstraction layer for a set of Docker hosts and allows simple communication between dependent applications. We no longer have to think about which machine our applications are deployed on. All we care about is the number of instances.</p>
			<h3>Configuration management with Ansible</h3>
			<p>In <a href="B18223_07_ePub.xhtml#_idTextAnchor185"><em class="italic">Chapter 7</em></a>, <em class="italic">Configuration Management with Ansible</em>, we will create<a id="_idIndexMarker110"/> multiple environments using Ansible. The output is presented<a id="_idIndexMarker111"/> in the following diagram:</p>
			<div><div><img src="img/B18223_01_13.jpg" alt="Figure 1.13 – Configuration management with Ansible&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13 – Configuration management with Ansible</p>
			<p>Ansible takes care of the environments and lets you deploy the same applications on multiple machines. As a result, we have a mirrored environment for testing and production.</p>
			<p>In this chapter, we'll also touch on IaC and show you how to use Terraform if you use cloud environments.</p>
			<h3>The CD pipeline/advanced CD</h3>
			<p>In the last two chapters – that is, <a href="B18223_08_ePub.xhtml#_idTextAnchor218"><em class="italic">Chapter 8</em></a>, <em class="italic">Continuous Delivery Pipeline</em>, and <a href="B18223_09_ePub.xhtml#_idTextAnchor242"><em class="italic">Chapter 9</em></a>, <em class="italic">Advanced Continuous Delivery</em> – we will deploy the application to the staging<a id="_idIndexMarker112"/> environment, run the acceptance testing suite, and release the application to the production environment, usually in many instances. The final improvement is that we'll be able to automatically manage the database schemas using Flyway migrations that have been integrated into the delivery process. The final environment<a id="_idIndexMarker113"/> that will be created in this book is shown in the following diagram:</p>
			<div><div><img src="img/B18223_01_14.jpg" alt="Figure 1.14 – The CD pipeline/advanced CD&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14 – The CD pipeline/advanced CD</p>
			<p>I hope you are already excited by what we plan to build throughout this book. We will approach this step by step, explaining every detail and all the possible options to help you understand the procedures and tools. After reading this book, you will be able to introduce or improve the CD process in your projects.</p>
			<h1 id="_idParaDest-32"><a id="_idTextAnchor031"/>Summary</h1>
			<p>In this chapter, we introduced the CD process, including the idea behind it, its prerequisites, and the tools that will be used throughout this book. The key takeaway from this chapter is that the delivery process that's currently used in most companies has significant shortcomings and can be improved using modern automation tools. The CD approach provides several benefits, of which the most significant ones are fast delivery, a fast feedback cycle, and low-risk releases. The CD pipeline consists of three stages: CI, automated acceptance testing, and configuration management. Introducing CD usually requires the organization to change its culture and structure. The most important tools in the context of CD are Docker, Jenkins, and Ansible.</p>
			<p>In the next chapter, we'll introduce Docker and show you how to build a dockerized application.</p>
			<h1 id="_idParaDest-33"><a id="_idTextAnchor032"/>Questions</h1>
			<p>To test your knowledge of this chapter, please answer the following questions:</p>
			<ol>
				<li>What are the three phases of the traditional delivery process?</li>
				<li>What are the three main stages of the CD pipeline?</li>
				<li>Name at least three benefits of using CD.</li>
				<li>What are the types of tests that should be automated as part of the CD pipeline?</li>
				<li>Should we have more integration or unit tests? Explain why.</li>
				<li>What does the term DevOps mean?</li>
				<li>What software tools will be used throughout this book? Name at least four.</li>
			</ol>
			<h1 id="_idParaDest-34"><a id="_idTextAnchor033"/>Further reading</h1>
			<p>To learn more about the concept of CD and its background, please refer to the following resources:</p>
			<ul>
				<li><em class="italic">Continuous Delivery</em>, by Jez Humble and David Farley: <a href="https://continuousdelivery.com/">https://continuousdelivery.com/</a></li>
				<li><em class="italic">TestPyramid</em>, by Martin Fowler: <a href="https://martinfowler.com/bliki/TestPyramid.html">https://martinfowler.com/bliki/TestPyramid.html</a></li>
				<li><em class="italic">Succeeding with Agile: Software Development Using Scrum</em>, by Mike Cohn</li>
				<li><em class="italic">Building Microservices: Designing Fine-Grained Systems</em>, by Sam Newman</li>
			</ul>
		</div>
	</body></html>