- en: Chapter 6. Troubleshooting and Monitoring
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章 故障排除与监控
- en: In this chapter, we are going to look at commands which will come in useful
    when troubleshooting your containers, all the commands we will look at are part
    of the core Docker Engine, we will also look at a way by which you can debug your
    Dockerfiles.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将查看在故障排除容器时会非常有用的命令，所有我们将查看的命令都是 Docker 引擎的核心命令，我们还将研究一种调试 Dockerfile
    的方法。
- en: Once we have finished with the Troubleshooting commands, we will look at how
    we can monitor our containers using cAdvisor with a Prometheus backend fronted
    by a Grafana dashboard – don't worry, it is not as complicated as it sounds.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 完成故障排除命令后，我们将了解如何使用 cAdvisor 监控容器，并通过 Prometheus 后端和 Grafana 仪表板进行展示——别担心，这并不像听起来那么复杂。
- en: Note
  id: totrans-3
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we are going to be exposing services, some using default credentials I would
    recommend that you use your local Docker installation for this chapter.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将暴露服务，其中一些使用默认凭证，因此我建议您在本章中使用本地的 Docker 安装。
- en: Troubleshooting containers
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器故障排除
- en: Computer programs (software) sometimes fail to behave as expected. This is due
    to faulty code or due to the environmental changes between the development, testing,
    and deployment systems. Docker container technology eliminates the environmental
    issues between development, testing, and deployment as much as possible by containerizing
    all the application dependencies. Nonetheless, there could still be anomalies
    due to faulty code or variations in the kernel behavior, which needs debugging.
    Debugging is one of the most complex processes in the software engineering world
    and it becomes much more complex in the container paradigm because of the isolation
    techniques. In this section, we are going to learn a few tips and tricks to debug
    a containerized application using the tools native to Docker, as well as the tools
    provided by external sources.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序（软件）有时不能按预期行为运行。这通常是由于代码错误或开发、测试和部署系统之间的环境变化造成的。Docker 容器技术通过容器化所有应用程序的依赖项，尽可能消除开发、测试和部署之间的环境问题。然而，仍然可能由于代码错误或内核行为的变化而出现异常，这需要调试。调试是软件工程领域中最复杂的过程之一，而在容器化环境下，由于隔离技术的存在，调试变得更加复杂。在本节中，我们将学习如何使用
    Docker 原生工具以及外部工具调试容器化应用的一些技巧和窍门。
- en: 'Initially, many people in the Docker community individually developed their
    own debugging tools, but later Docker started supporting native tools, such as
    `exec`, `top`, `logs`, `events`, and many more. In this section, we will dive
    deep into the following Docker tools:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Docker 社区的许多人分别开发了自己的调试工具，但后来 Docker 开始支持原生工具，如 `exec`、`top`、`logs`、`events`
    等等。在本节中，我们将深入了解以下 Docker 工具：
- en: '`exec`'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`exec`'
- en: '`ps`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps`'
- en: '`top`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`top`'
- en: '`stats`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`stats`'
- en: '`events`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`events`'
- en: '`logs`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logs`'
- en: '`attach`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attach`'
- en: We shall also consider debugging a Dockerfile.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将考虑调试 Dockerfile。
- en: The exec command
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: exec 命令
- en: The `docker container exec` command provided the much-needed help to users,
    who are deploying their own web servers or other applications running in the background.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container exec` 命令为用户提供了极大的帮助，尤其是对于那些在容器中部署自己 web 服务器或后台运行其他应用的用户。'
- en: Now, it is not necessary to log in to run the SSH daemon in the container.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行容器中的 SSH 守护进程不再需要登录。
- en: 'First, launch a container:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，启动一个容器：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![The exec command](img/B06455_06_01.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![exec 命令](img/B06455_06_01.jpg)'
- en: 'Second, run the `docker container ps` command to get the container ID. Now
    you have the container ID you can run the `docker container exec` command to log
    in to the container using either the container ID or as we have named it `trainingapp`
    you can use that:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第二，运行 `docker container ps` 命令以获取容器 ID。现在你已经拥有了容器 ID，可以使用容器 ID 或我们为其命名的 `trainingapp`
    来运行 `docker container exec` 命令登录容器：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note, not every container will have bash installed, some such Alpine
    Linux don't have bash out of the box but instead uses sh, which bash was based
    on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，并非每个容器都安装了 bash，有些容器（如 Alpine Linux）默认没有 bash，而是使用基于 bash 的 sh。
- en: It is important to note that the `docker container exec` command can only access
    the running containers, so if the container stops functioning then you need to
    restart the stopped container to proceed. The `docker container exec` command
    spawns a new process in the target containers namespace using the Docker API and
    CLI.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，`docker container exec`命令只能访问正在运行的容器，所以如果容器停止工作，你需要重新启动停止的容器才能继续。`docker
    container exec`命令通过Docker API和CLI在目标容器的命名空间中生成一个新的进程。
- en: A containers name space is what separates the containers from each other, for
    example you can have several containers all running the same process, but because
    the processes have been launched within each of the containers namespace they
    are isolated from one another. A good example of this is are MySQL processes,
    on a traditional server trying to run more than one MySQL server process will
    mean that you need to start the process on different ports, use different lock,
    PID and log files as well as different init scripts.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的命名空间是将容器彼此隔离的机制，例如，你可以有多个容器同时运行相同的进程，但由于这些进程是启动在每个容器的命名空间内，它们彼此隔离。一个好的例子是MySQL进程，在传统服务器上尝试运行多个MySQL服务器进程意味着你需要在不同的端口上启动进程，使用不同的锁、PID和日志文件以及不同的初始化脚本。
- en: As Docker is isolating each MySQL server process all you need to worry about
    is that if you are exposing the MySQL port on the host machine is that you don't
    assign it on the same port as another container.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Docker隔离了每个MySQL服务器进程，你只需要担心的是，如果你在主机机器上暴露了MySQL端口，那么不要将其分配给与另一个容器相同的端口。
- en: 'So, if you run the `ps -aef` command inside the target container, it looks
    like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你在目标容器内运行`ps -aef`命令，结果如下：
- en: '![The exec command](img/B06455_06_04.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![exec命令](img/B06455_06_04.jpg)'
- en: Here, `python app.y` is the application that is already running in the target
    container, and the `docker container exec` command has added the `bash` process
    inside the container. If you run `kill -9 59` (replacing the `59` with the PID
    of your own `bash` process), you will be automatically logged out of the container.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`python app.y`是目标容器中已经运行的应用程序，而`docker container exec`命令在容器内部添加了`bash`进程。如果你运行`kill
    -9 59`（将`59`替换为你自己`bash`进程的PID），你将自动从容器中注销。
- en: It is recommended that you use the `docker container exec` command only for
    monitoring and diagnostic purposes, and I personally believe in the concept of
    one process per container, which is one of the best practices widely accentuated.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 建议你仅将`docker container exec`命令用于监控和诊断目的，我个人相信每个容器一个进程的概念，这是广泛强调的最佳实践之一。
- en: The ps command
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ps命令
- en: The `ps` command, which is available inside the container, is used to see the
    status of the process. This is like the standard `ps` command in the Linux environment
    and is not a `dockercontainerps` command that we run on the Docker host machine.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`ps`命令在容器内部可用，用于查看进程的状态。这与Linux环境中的标准`ps`命令类似，并不是我们在Docker主机上运行的`dockercontainerps`命令。'
- en: 'This command runs inside the Docker container:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令在Docker容器内运行：
- en: '![The ps command](img/B06455_06_06.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![ps命令](img/B06455_06_06.jpg)'
- en: Use `ps --help <simple|list|output|threads|misc|all>` or `ps --help <s|l|o|t|m|a>`
    for additional help text.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`ps --help <simple|list|output|threads|misc|all>`或`ps --help <s|l|o|t|m|a>`获取更多帮助信息。
- en: The top command
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: top命令
- en: 'You can run the top command from the Docker host machine using the following
    command:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下命令从Docker主机机器运行top命令：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This gives a list of the running processes of a container without logging into
    the container, as follows:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这会列出容器中运行的进程，而无需登录容器，如下所示：
- en: '![The top command](img/B06455_06_07.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![top命令](img/B06455_06_07.jpg)'
- en: 'The within the container the top command provides information about the CPU,
    memory, and swap usage just like any normal Linux host:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内，top命令提供关于CPU、内存和交换区使用情况的信息，就像任何正常的Linux主机一样：
- en: '![The top command](img/B06455_06_08.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![top命令](img/B06455_06_08.jpg)'
- en: In case you get the error as `error - TERM environment variable not set` while
    running the `top` command inside the container, perform the following steps to
    resolve it.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在容器内运行`top`命令时出现`error - TERM environment variable not set`错误，请按照以下步骤进行解决。
- en: 'Run `echo$TERM` and if you get the result `dumb`, then, run the following command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`echo$TERM`，如果返回结果是`dumb`，那么运行以下命令：
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will resolve your error and you can run the `top` command.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 这将解决你的错误，你可以运行`top`命令。
- en: The stats command
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: stats命令
- en: 'The `docker container stats` command provides you with the capability to view
    the memory, CPU, and the network usage of a container from a Docker host machine,
    as illustrated here. Running the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`docker container stats`命令允许你查看Docker主机上容器的内存、CPU和网络使用情况，如下所示。运行以下命令：'
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Gives you the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 给你以下输出：
- en: '![The stats command](img/B06455_06_09.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![stats命令](img/B06455_06_09.jpg)'
- en: 'You can run the `stats` command to also view the usage for multiple containers:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以运行`stats`命令来查看多个容器的使用情况：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '![The stats command](img/B06455_06_10.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![stats命令](img/B06455_06_10.jpg)'
- en: Since Docker 1.5, you have been able to access to container statistics *read
    only* parameters. This will streamline the CPU, memory, network IO, and block
    IO of your containers.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从Docker 1.5版本开始，你可以访问容器统计的*只读*参数。这将简化容器的CPU、内存、网络I/O和块I/O。
- en: This helps you choose the resource limits and in profiling. The Docker stats
    utility provides you with these resource usage details only for running containers.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于你选择资源限制和性能分析。Docker stats工具仅为运行中的容器提供这些资源使用详情。
- en: You can get detailed information using the endpoint APIs at the following URL
    [https://docs.docker.com/engine/api/v1.26/](https://docs.docker.com/engine/api/v1.26/).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下网址的端点API获取详细信息：[https://docs.docker.com/engine/api/v1.26/](https://docs.docker.com/engine/api/v1.26/)。
- en: The Docker events command
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Docker事件命令
- en: 'Docker containers will report the following real-time events: `create`, `destroy`,
    `die`, `export`, `kill`, `omm`, `pause`, `restart`, `start`, `stop`, and `unpause`.
    Let''s `pause` and `unpause` our container:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Docker容器将报告以下实时事件：`create`、`destroy`、`die`、`export`、`kill`、`omm`、`pause`、`restart`、`start`、`stop`和`unpause`。让我们`pause`和`unpause`我们的容器：
- en: '![The Docker events command](img/B06455_06_11.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![Docker事件命令](img/B06455_06_11.jpg)'
- en: If you specify an image it will also report the `untag` and `delete` events.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果指定了镜像，它还将报告`untag`和`delete`事件。
- en: 'Using multiple filters will be handled as an `AND` operation, for example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 使用多个过滤器将作为`AND`操作处理，例如：
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Preceding will display all `pause` and `unpause` events for the container `a245253db38b`
    for the last 12 hours:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将显示容器`a245253db38b`过去12小时内所有的`pause`和`unpause`事件：
- en: '![The Docker events command](img/B06455_06_12.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![Docker事件命令](img/B06455_06_12.jpg)'
- en: Currently, the supported filters are `container`, `event`, and `image`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，支持的过滤器有`container`、`event`和`image`。
- en: The logs command
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: logs命令
- en: 'This command fetches the log of a container without logging into the container.
    It batch-retrieves logs present at the time of execution. These logs are the output
    of STDOUT and STDERR. The general usage is shown in:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在不登录容器的情况下获取容器的日志。它批量检索执行时存在的日志。这些日志是STDOUT和STDERR的输出。一般用法如下：
- en: '[PRE7]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The `--follow` option will continue to provide the output till the Docker logs
    command is terminated printing any new log entries to the screen in real time,`-t`
    will provide the timestamp, and `--tail=<number of lines>` will show the number
    of lines of the log messages of your container:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`--follow`选项将继续提供输出，直到Docker日志命令终止，并实时打印任何新的日志条目，`-t`将提供时间戳，`--tail=<number
    of lines>`将显示容器日志消息的行数：'
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![The logs command](img/B06455_06_13.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![logs命令](img/B06455_06_13.jpg)'
- en: '[PRE9]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![The logs command](img/B06455_06_14.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![logs命令](img/B06455_06_14.jpg)'
- en: We also used the `docker container logs` command in previous chapters to view
    the logs of our database containers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的章节中也使用了`docker container logs`命令来查看数据库容器的日志。
- en: The attach command
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: attach命令
- en: 'This command attaches the running container and it is very helpful when you
    want to see what is written in `stdout` in real time, let''s launch new test container
    which outputs something to `stdout`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令附加到正在运行的容器，并且在你想要实时查看`stdout`中写入的内容时非常有用，接下来我们启动一个新的测试容器，它向`stdout`输出内容：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now we can attach to the container using the following command to see the output;
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令附加到容器以查看输出：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: By default, this command attaches `stdin` and proxies signals to the remote
    process. Options are available to control both behaviors. To detach from the process,
    use the default *Ctrl* + *Q* sequence.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，该命令会附加`stdin`并将信号代理到远程进程。可以使用选项来控制这两种行为。要从进程中分离，请使用默认的*Ctrl* + *Q*组合键。
- en: Debugging a Dockerfile
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试Dockerfile
- en: Every instruction we set in the Dockerfile is going to be built as a separate,
    temporary image for the other instruction to build itself on top of the previous
    instruction.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在Dockerfile中设置的每条指令都会作为一个单独的临时镜像构建，用于其他指令在其基础上构建。
- en: 'There is a Dockerfile in the repo at `/bootcamp/ch` `apter06/debu` `g`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在仓库的 `/bootcamp/ch` `apter06/debu` `g` 目录下有一个 Dockerfile：
- en: '[PRE12]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Building the image using the following command:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建镜像：
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Gives you the following output:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 给你以下输出：
- en: '![Debugging a Dockerfile](img/B06455_06_17.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Dockerfile](img/B06455_06_17.jpg)'
- en: So, there is an error in our Docker file. You may notice there is a line in
    the output which says `--->5f828f86eaa4`this is actually an image file which was
    built following the successful execution of the `RUN ls -lha /` `home` line.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们的 Dockerfile 中有一个错误。你可能会注意到输出中有一行显示 `--->5f828f86eaa4`，这实际上是一个镜像文件，它是在成功执行
    `RUN ls -lha /` `home` 行之后构建的。
- en: '![Debugging a Dockerfile](img/B06455_06_18.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Dockerfile](img/B06455_06_18.jpg)'
- en: 'This means that we can launch a container using this image:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们可以使用这个镜像来启动一个容器：
- en: '[PRE14]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Notice that as we are using Alpine Linux as our base we are using `/bin/sh`
    rather than `/bin/bash`
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们使用的是 Alpine Linux 作为基础镜像，因此我们使用 `/bin/sh` 而不是 `/bin/bash`
- en: 'We can then debug our application, which in this case is simple:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们可以调试我们的应用程序，在这种情况下非常简单：
- en: '![Debugging a Dockerfile](img/B06455_06_19.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Dockerfile](img/B06455_06_19.jpg)'
- en: Debugging is a process of analyzing what's going on and it's different for every
    situation, but usually the way we start debugging is by trying to manually make
    the instruction that fail work manually and understand the error. When I get the
    instruction to work, I usually exit the container, update my Dockerfile and repeat
    the process until I have something working.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 调试是一个分析正在发生的事情的过程，每种情况都不同，但通常我们开始调试的方法是通过手动执行失败的指令并理解错误。当我使指令工作时，我通常会退出容器，更新我的
    Dockerfile，然后重复这个过程，直到我得到一个可以正常工作的结果。
- en: 'Notice that when the line which is causing the error is corrected (by supplying
    the correct line `RUN ls -lha /var`) and we try the build again that Docker doesn''t
    create a new image for the one step which was successful:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当导致错误的那一行被更正（通过提供正确的行 `RUN ls -lha /var`）并且我们再次尝试构建时，Docker 并不会为成功的那一步创建一个新的镜像：
- en: '![Debugging a Dockerfile](img/B06455_06_20.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Dockerfile](img/B06455_06_20.jpg)'
- en: 'Once it has built the temporary image is removed and we are left with our final
    image:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦构建完成，临时镜像会被删除，我们只剩下最终的镜像：
- en: '![Debugging a Dockerfile](img/B06455_06_21.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![调试 Dockerfile](img/B06455_06_21.jpg)'
- en: That was quite a simple example, but it should give you an idea of how to debug
    a more complex Dockerfile.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当简单的例子，但它应该能让你了解如何调试更复杂的 Dockerfile。
- en: Monitoring containers
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 容器监控
- en: In the last section, we looked at how you can use the API built into Docker
    to gain an insight to what resources your containers are running by running the
    `docker container stats` and `docker container top` commands. Now, we are to see
    how we can take it to the next level by using **cAdvisor** from Google.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们介绍了如何使用 Docker 内置的 API 通过运行 `docker container stats` 和 `docker container
    top` 命令来获取容器运行时的资源信息。现在，我们将看看如何通过使用 **cAdvisor**（Google 提供的工具）将其提升到一个新层次。
- en: 'Google describes cAdvisor as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Google 对 cAdvisor 的描述如下：
- en: cAdvisor (Container Advisor) provides container users an understanding of the
    resource usage and performance characteristics of their running containers. It
    is a running daemon that collects, aggregates, processes, and exports information
    about running containers. Specifically, for each container, it keeps resource
    isolation parameters, historical resource usage, histograms of complete historical
    resource usage, and network statistics. This data is exported by a container and
    is machine-wide.
  id: totrans-109
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: cAdvisor（容器顾问）为容器用户提供了关于其正在运行的容器的资源使用情况和性能特征的理解。它是一个运行中的守护进程，收集、汇总、处理并导出有关正在运行的容器的信息。具体来说，对于每个容器，它保持资源隔离参数、历史资源使用情况、完整历史资源使用的直方图以及网络统计信息。这些数据由容器导出，并且是机器范围的。
- en: The project started off life as an internal tool at Google for gaining an insight
    into containers that had been launched using their own container stack.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目最初作为 Google 的一个内部工具，用于获取有关使用其自有容器栈启动的容器的深入信息。
- en: Note
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Google's own container stack was called "Let Me Contain That For You" or lmctfy
    for short. The work on lmctfy has been installed as a Google port functionality
    over to libcontainer that is part of the Open Container Initiative. Further details
    on lmctfy can be found at [https://github.com/google/lmctfy/](https://github.com/google/lmctfy/)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Google 自己的容器堆栈被称为 "Let Me Contain That For You" 或简称 lmctfy。lmctfy 项目的工作已被作为
    Google 在 libcontainer 上的移植功能，这也是 Open Container Initiative（OCI）的一部分。关于 lmctfy
    的更多细节可以在 [https://github.com/google/lmctfy/](https://github.com/google/lmctfy/)
    找到。
- en: cAdvisor is written in Go ([https://golang.org](https://golang.org)); you can
    either compile your own binary or you can use the pre-compiled binary that are
    supplied via a container, which is available from Google's own Docker Hub account.
    You can find this at [http://hub.docker.com/u/google/](http://hub.docker.com/u/google/).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 是用 Go 语言编写的 ([https://golang.org](https://golang.org))；你可以选择自行编译二进制文件，或者使用通过容器提供的预编译二进制文件，这些文件可通过
    Google 自家的 Docker Hub 账户获取。你可以在 [http://hub.docker.com/u/google/](http://hub.docker.com/u/google/)
    找到它。
- en: Once installed, cAdvisor will sit in the background and capture metrics that
    are like that of the `dockercontainer` `stats` command. We will go through these
    stats and understand what they mean later in this chapter.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，cAdvisor 会在后台运行并捕获类似于 `dockercontainer` `stats` 命令的指标。我们将在本章后续内容中详细了解这些指标及其含义。
- en: cAdvisor takes these metrics along with those for the host machine and exposes
    them via a simple and easy-to-use built-in web interface.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 会收集这些指标，并与主机机器的指标一起，通过一个简单且易于使用的内置网页界面进行展示。
- en: 'There are several ways to install cAdvisor; the easiest way to get started
    is to download and run the container image that contains a copy of a precompiled
    cAdvisor binary:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 cAdvisor 有多种方法；最简单的方式是下载并运行包含预编译 cAdvisor 二进制文件的容器镜像：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You should now have a cAdvisor container up and running on your host machine.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该在主机上成功启动了 cAdvisor 容器。
- en: Before we start looking at stats, let's look at cAdvisor in more detail by discussing
    why we have passed all the options to the container.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看统计数据之前，我们先更详细地了解一下 cAdvisor，讨论为什么我们要将所有选项传递给容器。
- en: The cAdvisor binary is designed to run on the host machine alongside the Docker
    binary, so by launching cAdvisor in a container, we are isolating the binary in
    its own environment. To give cAdvisor access to the resources it requires on the
    host machine, we have to mount several partitions and also give the container
    privileged access to let the cAdvisor binary think it is being executed on the
    host machine.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 二进制文件设计为与 Docker 二进制文件一起在主机上运行，因此通过在容器中启动 cAdvisor，我们将二进制文件隔离在它自己的环境中。为了让
    cAdvisor 访问它在主机上所需的资源，我们必须挂载多个分区，并且还需要为容器提供特权访问权限，让 cAdvisor 二进制文件认为它是在主机上执行的。
- en: So now, we have cAdvisor running; what do we need to do to configure the service
    in order to start collecting metrics?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经让 cAdvisor 正常运行；接下来我们需要做什么来配置服务以开始收集指标？
- en: The short answer is, nothing at all. When you started the cAdvisor process,
    it instantly started polling your host machine to find out what containers are
    running and gathered information on both the running containers and your host
    machine.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，什么也没有发生。当你启动 cAdvisor 进程时，它会立即开始轮询主机，查看有哪些容器在运行，并收集关于正在运行的容器和主机机器的信息。
- en: 'cAdvisor should be running on the 8080 port; if you open `http://localhost:8080/`,
    you should be greeted with the cAdvisor logo and an overview of your host machine:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 应该运行在 8080 端口上；如果你打开 `http://localhost:8080/`，你应该能看到 cAdvisor 的 logo
    和主机机器的概览：
- en: '![Monitoring containers](img/B06455_06_23.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_23.jpg)'
- en: This initial page streams live stats about the host machine, though each section
    is repeated when you start to drill down and view the containers. To start with,
    let's look at each section using the host information.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个初始页面会实时流式传输主机机器的统计信息，每个部分会在你开始深入查看容器时重复显示。首先，我们来看看使用主机信息的每个部分。
- en: 'The overview section gives you a bird''s-eye view of your system; it uses gauges
    so you can quickly get an idea of which resources are reaching their limits. In
    the following screenshot, there is very little in the way of CPU utilization and
    the file system usage is relatively low; however, we are using 66% of the available
    RAM:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 概览部分给出了你系统的全貌；它使用了仪表盘，让你能够快速了解哪些资源已经接近极限。在以下截图中，CPU 使用率很低，文件系统的使用也相对较低；然而，我们已经使用了
    66% 的可用 RAM：
- en: '![Monitoring containers](img/B06455_06_24.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_24.jpg)'
- en: 'Next up is the graph which shows the CPU utilization over the last minute:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是显示过去一分钟CPU利用率的图表：
- en: '![Monitoring containers](img/B06455_06_25.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_25.jpg)'
- en: 'Here is what each term means:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是每个术语的含义：
- en: '**Total Usage**: This shows an aggregate usage across all cores'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**总使用情况**：此项显示所有核心的总使用情况'
- en: '**Usage per Core**: This graph breaks down the usage per core'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**每个核心的使用情况**：此图表显示每个核心的使用情况'
- en: '**Usage Breakdown**: This shows aggregate usage across all cores, but breaks
    it down to what is being used by the kernel and what is being used by the user-owned
    processes'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用情况细分**：此项显示了所有核心的总体使用情况，但会将其分解为由内核和用户拥有的进程所使用的内存'
- en: The Memory section is split into two parts. The graph tells you the total amount
    of memory used by all the processes for the host or container; this is the total
    of the hot and cold memory. The Hot memory is the current working set; pages that
    have been touched by the kernel recently. The Cold memory is the page that hasn't
    been touched for a while and could be reclaimed if needed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 内存部分分为两部分。图表显示了所有进程在主机或容器中使用的总内存量；这是热内存和冷内存的总和。热内存是当前工作集；即内核最近访问过的页面。冷内存是长时间没有被访问的页面，如果需要，可以回收。
- en: The Usage Breakdown gives a visual representation of the total memory in the
    host machine, or allowance in the container, alongside the total and hot usage.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 使用情况细分提供了主机机器的总内存或容器中的配额的可视化表示，以及总使用量和热使用量。
- en: The network section shows the incoming and outgoing traffic over the last minute.
    You can change the interface using the drop-down box on the top-left.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 网络部分显示了过去一分钟的进出流量。你可以使用左上角的下拉框更改接口。
- en: There is also a graph that shows any networking errors. Typically, this graph
    should be flat. If it isn't, then you will be seeing performance issues with your
    host machine or container.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个图表显示任何网络错误。通常情况下，这个图表应该是平的。如果不是，那么说明你的主机或容器可能存在性能问题。
- en: The final section, filesystem, gives a breakdown of the filesystem usage. In
    the following screenshot, `/dev/vda1` is the boot partition, overlay is the main
    filesystem running your running containers.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一部分，文件系统，提供了文件系统使用情况的详细信息。在以下屏幕截图中，`/dev/vda1` 是启动分区，overlay 是运行容器的主要文件系统。
- en: Now we can look at our containers. At the top of the page, there is a link of
    your running containers, it says **Docker Containers**; you can either click on
    the link or go directly to `http://localhost:8080/docker/`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以查看我们的容器了。在页面顶部有一个链接，显示你正在运行的容器，名称为 **Docker 容器**；你可以点击链接，也可以直接访问 `http://localhost:8080/docker/`。
- en: Once the page loads, you should see a list of all your running containers, and
    also a detailed overview of your Docker process, and finally a list of the images
    you have downloaded.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 页面加载后，你应该能够看到所有正在运行的容器列表，以及有关 Docker 进程的详细概览，最后是你下载的镜像列表。
- en: 'Subcontainers shows a list of your containers; each entry is a clickable link
    that will take you to a page that will give you the following details:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 子容器显示了你的容器列表；每个条目都是一个可点击的链接，点击后将带你到一个页面，页面上会显示以下详细信息：
- en: '**Isolation**:'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离**：'
- en: '**CPU**: This shows you the CPU allowances of the container; if you have not
    set any resource limits, you will see the host''s CPU information'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：此项显示容器的 CPU 配额；如果没有设置任何资源限制，你将看到主机的 CPU 信息'
- en: '**Memory**: This shows you the memory allowances of the container; if you have
    not set any resource limits, your container will show an unlimited allowance'
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存**：此项显示了容器的内存配额；如果你没有设置任何资源限制，容器将显示为无限配额'
- en: '**Usage**:'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用情况**：'
- en: '**Overview**: This shows gauges so you can quickly see how close to any resource
    limits you are'
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**概览**：此项显示了仪表盘，你可以快速查看是否接近任何资源限制'
- en: '**Processes**: This shows the processes for just your selected container'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进程**：此项显示仅选定容器的进程'
- en: '**CPU**: This shows the CPU utilization graphs isolated to just your container'
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU**：此项显示仅限于你容器的 CPU 利用率图表'
- en: 'Memory: This shows the memory utilization of your container'
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存：此项显示了容器的内存利用情况
- en: The Driver status section gives the basic stats on your main Docker process,
    along with the information on the host machine's kernel, host name, and also the
    underlying operating system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 驱动状态部分提供了关于主 Docker 进程的基本统计信息，同时也包含主机机器内核、主机名以及底层操作系统的信息。
- en: It also gives information on the total number of containers and images. You
    may notice that the total number of images is a much larger figure than you expected
    to see; this is because it is counting each file system as an individual image.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 它还提供关于容器和镜像的总数的信息。你可能会注意到，镜像的总数远远超出你预期的数字；这是因为它将每个文件系统都当作一个独立的镜像来计算。
- en: Finally, you get a list of the Docker images which are available on the host
    machine. It lists the Repository, Tag, Size, and when the image was created, along
    with the images' unique ID. This lets you know where the image originated from
    (Repository), which version of the image you have downloaded (Tag) and how big
    the image is (Size).
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你将得到一个主机上可用的 Docker 镜像列表。它列出了仓库、标签、大小以及镜像的创建时间，还包括镜像的唯一 ID。这让你了解镜像的来源（仓库）、你下载的是哪个版本的镜像（标签）以及镜像的大小（大小）。
- en: This is all great, what's the catch?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都很好，那么问题是什么呢？
- en: So, you are maybe thinking to yourself that all this information available in
    your browser is really useful; being able to see real-time performance metrics
    in an easily readable format is a real plus.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，你也许在想，浏览器中提供的这些信息真的很有用；能够以易读的格式看到实时的性能指标，确实是一个很大的优势。
- en: The biggest drawback of using the web interface for cAdvisor, as you may have
    noticed, is that it only shows you one minute's worth of metrics; you can quite
    literally see the information disappearing in real time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 cAdvisor 的 Web 界面最大的缺点是，正如你可能已经注意到的，它只显示一分钟前的度量数据；你可以清晰地看到信息在实时消失。
- en: As a pane of glass gives a real-time view into your containers, cAdvisor is
    a brilliant tool; if you want to review any metrics that are older than one minute,
    you are out of luck.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一块窗户玻璃提供了容器的实时视图一样，cAdvisor 是一个非常棒的工具；不过，如果你想查看超过一分钟的数据，恐怕就没办法了。
- en: 'That is, unless you configure somewhere to store all your data; this is where
    Prometheus comes in.So what''s Prometheus? Its developers describe it as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，除非你配置某个地方存储所有数据；这就是 Prometheus 的作用。那么，Prometheus 到底是什么呢？它的开发者这样描述它：
- en: Prometheus is an open-source system's monitoring and alerting toolkit built
    at SoundCloud. Since its inception in 2012, it has become the standard for instrumenting
    new services at SoundCloud and is seeing growing external usage and contributions.
  id: totrans-158
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: Prometheus 是一个开源的系统监控和告警工具包，最初由 SoundCloud 开发。自 2012 年推出以来，它已经成为 SoundCloud
    为新服务提供监控的标准，并且在外部使用和贡献方面不断增长。
- en: OK, but what does that have to do with cAdvisor? Well, Prometheus has quite
    a powerful database backend that stores the data it imports as a time series of
    events.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，但这和 cAdvisor 有什么关系呢？嗯，Prometheus 有一个非常强大的数据库后端，它将导入的数据存储为事件的时间序列。
- en: 'One of the things cAdvisor does, by default, is expose all the metrics it is
    capturing on a single page at `/metrics`; you can see this at `http://localhost:8080/metricson`
    our cAdvisor installation. The metrics are updated each time the page is loaded,
    you should see something like:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: cAdvisor 默认做的一件事是将它捕获的所有度量数据显示在一个页面上，路径是`/metrics`；你可以在`http://localhost:8080/metricson`看到我们安装的
    cAdvisor。每次加载页面时，度量数据都会更新，你应该能看到如下内容：
- en: '![Monitoring containers](img/B06455_06_29.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_29.jpg)'
- en: As you can see in the preceding screenshot, this is just a single long page
    of raw text. The way Prometheus works is that you configure it to scrape the `/metrics`
    URL at a user-defined interval, let's say every five seconds; the text is in a
    format that Prometheus understands and it is ingested into the Prometheus's time
    series database.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在前面的截图中看到的，这只是一页长的原始文本。Prometheus 的工作方式是，你配置它以在用户定义的间隔（比如每五秒）抓取`/metrics`
    URL；这些文本的格式是 Prometheus 可识别的，并被导入到 Prometheus 的时间序列数据库中。
- en: What this means is that, using Prometheus's powerful built-in query language,
    you can start to drill down into your data. Let's look at getting Prometheus up
    and running.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，使用 Prometheus 强大的内置查询语言，你可以开始深入挖掘你的数据。接下来，让我们看看如何启动和运行 Prometheus。
- en: 'First of all, there is a work configuration file in the repo at `/bootcamp/chapter06/prometheus/`you
    will need to make sure you are in this folder as we are going to mounting the
    configuration file from within there:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，仓库中有一个工作配置文件，路径是`/bootcamp/chapter06/prometheus/`，你需要确保自己处于这个文件夹中，因为我们将从这里挂载配置文件：
- en: '[PRE16]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '![Monitoring containers](img/B06455_06_30.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_30.jpg)'
- en: 'The configuration file we have launched Prometheus with looks like the following:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们启动 Prometheus 时使用的配置文件如下所示：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we have launched our Prometheus container within the monitoring network our
    installation will be able scrape the metrics from `http://cadvisor:8080/`, also
    note that we haven't added `/metrics` to the URL as this added automatically by
    Prometheus.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在监控网络中启动了 Prometheus 容器，我们的安装将能够从 `http://cadvisor:8080/` 获取指标，同时请注意，我们没有在
    URL 中添加 `/metrics`，这是 Prometheus 自动添加的。
- en: 'Opening `http://localhost:9090/targets` in your browser should show you something
    like the following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在浏览器中打开 `http://localhost:9090/targets` 应该会显示类似以下内容：
- en: '![Monitoring containers](img/B06455_06_31.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_31.jpg)'
- en: 'Also, the status menu has links to the following information pages:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，状态菜单中有以下信息页面的链接：
- en: '**Runtime information&Build information**: This displays how long Prometheus
    has been up and polling data, if you have configured an end point and details
    of the version of Prometheus that you have been running'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时信息与构建信息**：这显示了 Prometheus 已运行并获取数据的时间，如果你配置了终端点，还会显示你运行的 Prometheus 版本信息'
- en: '**Command-Line Flags**: This shows all the runtime variables and their values'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**命令行标志**：这显示了所有运行时变量及其值'
- en: '**Configuration**: This is a copy of the configuration file we injected into
    the container when it was launched'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置**：这是我们在容器启动时注入的配置文件副本'
- en: '**Rules**: This is a copy of any rules we injected; these will be used for
    alerting'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**规则**：这是我们注入的任何规则的副本；这些规则将用于警报'
- en: As we only have a few containers up and running at the moment, let's launch
    one that runs Redis so we can start to look at the query language built into Prometheus.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 由于目前我们只有少数容器在运行，接下来让我们启动一个运行 Redis 的容器，以便我们可以开始查看 Prometheus 内置的查询语言。
- en: 'We will use the official Redis image for this and as we are only going to use
    this as an example we won''t need to pass it any user variables:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用官方的 Redis 镜像，作为示例我们不需要传递任何用户变量：
- en: '[PRE18]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We now have a container called my-redis-server running. cAdvisor should already
    be exposing metrics about the container to Prometheus; let's go ahead and see.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有一个名为 my-redis-server 的容器正在运行。cAdvisor 应该已经将容器的指标暴露给 Prometheus；让我们来看看。
- en: In the Prometheus web interface, go to the **Graph** link in the menu at the
    top of the page. Here, you will be presented with a text box into which you can
    enter your query. To start with, let's look at the CPU usage of the Redis container.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Prometheus Web 界面中，点击页面顶部菜单中的 **图表** 链接。你会看到一个文本框，你可以在其中输入查询。首先，让我们查看 Redis
    容器的 CPU 使用情况。
- en: 'In the box, enter the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在框中输入以下内容：
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, after clicking on Execute, you should have two results returned, listed
    in the Console tab of the page. If you remember, cAdvisor records the CPU usage
    of each of the CPU cores that the container has access to, which is why we have
    two values returned, one for `cpu00` and one for `cpu01`. Clicking on the **Graph**
    link will show you results over a period of time:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，点击执行后，你应该会看到两个结果，这些结果列在页面的控制台标签中。如果你还记得，cAdvisor 会记录容器访问的每个 CPU 核心的使用情况，因此我们会返回两个值，一个是
    `cpu00`，另一个是 `cpu01`。点击 **图表** 链接将显示一段时间内的结果：
- en: '![Monitoring containers](img/B06455_06_32.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_32.jpg)'
- en: As you can see in the preceding screenshot, we now have access to the usage
    graphs for the last 5 minutes, which is about how long ago I launched the Redis
    instance before generating the graph.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 如前面的截图所示，我们现在可以查看过去5分钟的使用情况图表，这大约是我在生成图表之前启动 Redis 实例的时间。
- en: 'Graphing, as you may have noticed, isn''t Prometheus''s strong point. Luckily
    Grafana has been able to use Prometheus as a data source for a while, let''s now
    launch a Grafana container:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，绘图并不是 Prometheus 的强项。幸运的是，Grafana 已经能够将 Prometheus 作为数据源使用一段时间了，现在让我们启动一个
    Grafana 容器：
- en: '[PRE20]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Monitoring containers](img/B06455_06_33.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_33.jpg)'
- en: Once the container has launched, go to `http://localhost:3000/` in your browser
    and you will be prompted to login, the default username and password is `admin`
    / `admin`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 容器启动后，在浏览器中访问 `http://localhost:3000/`，你会被提示登录，默认的用户名和密码是 `admin` / `admin`。
- en: 'Now you are logged in you should see something like the following page:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经登录，你应该会看到如下页面：
- en: '![Monitoring containers](img/B06455_06_34.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_34.jpg)'
- en: 'As you may have guessed, we need to click **Add data source**and the add then
    enter the following information:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所料，我们需要点击 **添加数据源**，然后输入以下信息：
- en: '**Name**: prometheus'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**：prometheus'
- en: '**Type**: <Select Prometheus from the drop down list>'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**类型**：<从下拉列表中选择 Prometheus>'
- en: '**Url**: `http://prometheus:9090`'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网址**：`http://prometheus:9090`'
- en: '**Access**: <Select proxy from the drop down list>'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**访问**：<从下拉列表中选择代理>'
- en: Leave everything else as is and then click on **Add**, after a second or two
    your data source should have successfully been added and the connection test passed.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 保持其他设置不变，然后点击**添加**，等待一两秒，您的数据源应该已经成功添加，并且连接测试通过。
- en: Now that we have our data source added we can add a dashboard. There are plenty
    of dashboards available, we are going to use the one published by Brian Christner
    which can be found at [https://grafana.net/dashboards/179/](https://grafana.net/dashboards/179/).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了数据源，可以添加一个仪表板。有很多现成的仪表板可用，我们将使用由 Brian Christner 发布的仪表板，您可以在 [https://grafana.net/dashboards/179/](https://grafana.net/dashboards/179/)
    找到。
- en: To import the dashboard,click on the **Grafana logo** in the top left, in the
    menu which opens go to **Dashboards** and then select **Import**. In the pop-up
    dialog which opens enter the URL for the dashboard, which is [https://grafana.net/dashboards/179/](https://grafana.net/dashboards/179/),
    into the **Grafana.net Dashboard** box and then click on the **Load** button.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要导入仪表板，点击左上角的**Grafana 标志**，在打开的菜单中选择**仪表板**，然后选择**导入**。在弹出的对话框中，输入仪表板的 URL
    [https://grafana.net/dashboards/179/](https://grafana.net/dashboards/179/)，然后点击**加载**按钮。
- en: That will load the dashboard configuration, on the next page you given two options,
    the **Name** is already filled in so just select **prometheus** from the dropdown
    **Prometheus** list and click the **Import** button.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这将加载仪表板配置，下一页将提供两个选项，**名称**已经填写好，只需从下拉菜单中选择**prometheus**，然后点击**导入**按钮。
- en: 'Once imported you should be greeted by a dashboard which looks similar (I have
    tweaked it for the screenshot) to the following:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 导入后，您应该会看到一个与以下内容类似的仪表板（我已为截图进行了调整）：
- en: '![Monitoring containers](img/B06455_06_35.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![监控容器](img/B06455_06_35.jpg)'
- en: You may notice from the screen above that we now have over an hour's worth of
    data from cAdvisor stored in Prometheus.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到从上面的屏幕中，我们现在已经从 cAdvisor 存储在 Prometheus 中的数据显示出超过一个小时的数据。
- en: It's worth pointing that the current experimental build of Docker has a built-in
    Prometheus endpoint much in the same way that cAdvisor has. Once this hits the
    stable release I expect to see this be a great out of the box solution for monitoring
    your Docker hosts.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，目前 Docker 的实验版本已内置 Prometheus 端点，类似于 cAdvisor 的方式。一旦发布稳定版，我预计这将成为监控 Docker
    主机的一个极好的开箱即用解决方案。
- en: 'However, this is just one way you monitor your containers as there are numerous
    other tools both of which are self-hosted or run as a software as a service in
    the cloud such as:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这只是监控容器的其中一种方式，还有许多其他工具可以使用，包括自托管和作为云中的软件即服务运行的工具，例如：
- en: Sysdig - [http://www.sysdig.org/](http://www.sysdig.org/)
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sysdig - [http://www.sysdig.org/](http://www.sysdig.org/)
- en: Sysdig Cloud - [https://sysdig.com/](https://sysdig.com/)
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sysdig Cloud - [https://sysdig.com/](https://sysdig.com/)
- en: Datadog - [http://docs.datadoghq.com/integrations/docker/](http://docs.datadoghq.com/integrations/docker/)
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Datadog - [http://docs.datadoghq.com/integrations/docker/](http://docs.datadoghq.com/integrations/docker/)
- en: New Relic - [https://newrelic.com/partner/docker](https://newrelic.com/partner/docker)
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: New Relic - [https://newrelic.com/partner/docker](https://newrelic.com/partner/docker)
- en: Coscale - [http://www.coscale.com/docker-monitoring](http://www.coscale.com/docker-monitoring)
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Coscale - [http://www.coscale.com/docker-monitoring](http://www.coscale.com/docker-monitoring)
- en: Elastic Metric Beat - [https://www.elastic.co/products/beats/metricbeat](https://www.elastic.co/products/beats/metricbeat)
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Elastic Metric Beat - [https://www.elastic.co/products/beats/metricbeat](https://www.elastic.co/products/beats/metricbeat)
- en: Summary
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: Hopefully now you should have an idea of where to start when it comes to looking
    into problems with containers, be it building them, checking logs, attaching to
    a container to further into issues or gathering performance metrics.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 希望现在您应该对如何开始排查容器问题有所了解，无论是构建容器、检查日志、连接容器深入问题，还是收集性能指标。
- en: In the next chapter, which is also our last, we will look at some of the different
    scenarios and use cases for both Docker and techniques we have covered in this
    and previous five chapters.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，也是我们的最后一章中，我们将探讨一些 Docker 和我们在本章及前五章中介绍的技术的不同场景和用例。
