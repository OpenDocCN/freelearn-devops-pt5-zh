- en: Chapter 6. Troubleshooting and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to look at commands which will come in useful
    when troubleshooting your containers, all the commands we will look at are part
    of the core Docker Engine, we will also look at a way by which you can debug your
    Dockerfiles.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have finished with the Troubleshooting commands, we will look at how
    we can monitor our containers using cAdvisor with a Prometheus backend fronted
    by a Grafana dashboard – don't worry, it is not as complicated as it sounds.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As we are going to be exposing services, some using default credentials I would
    recommend that you use your local Docker installation for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Computer programs (software) sometimes fail to behave as expected. This is due
    to faulty code or due to the environmental changes between the development, testing,
    and deployment systems. Docker container technology eliminates the environmental
    issues between development, testing, and deployment as much as possible by containerizing
    all the application dependencies. Nonetheless, there could still be anomalies
    due to faulty code or variations in the kernel behavior, which needs debugging.
    Debugging is one of the most complex processes in the software engineering world
    and it becomes much more complex in the container paradigm because of the isolation
    techniques. In this section, we are going to learn a few tips and tricks to debug
    a containerized application using the tools native to Docker, as well as the tools
    provided by external sources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, many people in the Docker community individually developed their
    own debugging tools, but later Docker started supporting native tools, such as
    `exec`, `top`, `logs`, `events`, and many more. In this section, we will dive
    deep into the following Docker tools:'
  prefs: []
  type: TYPE_NORMAL
- en: '`exec`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`top`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stats`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`events`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`logs`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`attach`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We shall also consider debugging a Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: The exec command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `docker container exec` command provided the much-needed help to users,
    who are deploying their own web servers or other applications running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is not necessary to log in to run the SSH daemon in the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, launch a container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '![The exec command](img/B06455_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Second, run the `docker container ps` command to get the container ID. Now
    you have the container ID you can run the `docker container exec` command to log
    in to the container using either the container ID or as we have named it `trainingapp`
    you can use that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please note, not every container will have bash installed, some such Alpine
    Linux don't have bash out of the box but instead uses sh, which bash was based
    on.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the `docker container exec` command can only access
    the running containers, so if the container stops functioning then you need to
    restart the stopped container to proceed. The `docker container exec` command
    spawns a new process in the target containers namespace using the Docker API and
    CLI.
  prefs: []
  type: TYPE_NORMAL
- en: A containers name space is what separates the containers from each other, for
    example you can have several containers all running the same process, but because
    the processes have been launched within each of the containers namespace they
    are isolated from one another. A good example of this is are MySQL processes,
    on a traditional server trying to run more than one MySQL server process will
    mean that you need to start the process on different ports, use different lock,
    PID and log files as well as different init scripts.
  prefs: []
  type: TYPE_NORMAL
- en: As Docker is isolating each MySQL server process all you need to worry about
    is that if you are exposing the MySQL port on the host machine is that you don't
    assign it on the same port as another container.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if you run the `ps -aef` command inside the target container, it looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The exec command](img/B06455_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, `python app.y` is the application that is already running in the target
    container, and the `docker container exec` command has added the `bash` process
    inside the container. If you run `kill -9 59` (replacing the `59` with the PID
    of your own `bash` process), you will be automatically logged out of the container.
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you use the `docker container exec` command only for
    monitoring and diagnostic purposes, and I personally believe in the concept of
    one process per container, which is one of the best practices widely accentuated.
  prefs: []
  type: TYPE_NORMAL
- en: The ps command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ps` command, which is available inside the container, is used to see the
    status of the process. This is like the standard `ps` command in the Linux environment
    and is not a `dockercontainerps` command that we run on the Docker host machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command runs inside the Docker container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The ps command](img/B06455_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use `ps --help <simple|list|output|threads|misc|all>` or `ps --help <s|l|o|t|m|a>`
    for additional help text.
  prefs: []
  type: TYPE_NORMAL
- en: The top command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can run the top command from the Docker host machine using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives a list of the running processes of a container without logging into
    the container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The top command](img/B06455_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The within the container the top command provides information about the CPU,
    memory, and swap usage just like any normal Linux host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The top command](img/B06455_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In case you get the error as `error - TERM environment variable not set` while
    running the `top` command inside the container, perform the following steps to
    resolve it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run `echo$TERM` and if you get the result `dumb`, then, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will resolve your error and you can run the `top` command.
  prefs: []
  type: TYPE_NORMAL
- en: The stats command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `docker container stats` command provides you with the capability to view
    the memory, CPU, and the network usage of a container from a Docker host machine,
    as illustrated here. Running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Gives you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The stats command](img/B06455_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can run the `stats` command to also view the usage for multiple containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '![The stats command](img/B06455_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since Docker 1.5, you have been able to access to container statistics *read
    only* parameters. This will streamline the CPU, memory, network IO, and block
    IO of your containers.
  prefs: []
  type: TYPE_NORMAL
- en: This helps you choose the resource limits and in profiling. The Docker stats
    utility provides you with these resource usage details only for running containers.
  prefs: []
  type: TYPE_NORMAL
- en: You can get detailed information using the endpoint APIs at the following URL
    [https://docs.docker.com/engine/api/v1.26/](https://docs.docker.com/engine/api/v1.26/).
  prefs: []
  type: TYPE_NORMAL
- en: The Docker events command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Docker containers will report the following real-time events: `create`, `destroy`,
    `die`, `export`, `kill`, `omm`, `pause`, `restart`, `start`, `stop`, and `unpause`.
    Let''s `pause` and `unpause` our container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker events command](img/B06455_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you specify an image it will also report the `untag` and `delete` events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using multiple filters will be handled as an `AND` operation, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Preceding will display all `pause` and `unpause` events for the container `a245253db38b`
    for the last 12 hours:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Docker events command](img/B06455_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Currently, the supported filters are `container`, `event`, and `image`.
  prefs: []
  type: TYPE_NORMAL
- en: The logs command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command fetches the log of a container without logging into the container.
    It batch-retrieves logs present at the time of execution. These logs are the output
    of STDOUT and STDERR. The general usage is shown in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--follow` option will continue to provide the output till the Docker logs
    command is terminated printing any new log entries to the screen in real time,`-t`
    will provide the timestamp, and `--tail=<number of lines>` will show the number
    of lines of the log messages of your container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '![The logs command](img/B06455_06_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '![The logs command](img/B06455_06_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also used the `docker container logs` command in previous chapters to view
    the logs of our database containers.
  prefs: []
  type: TYPE_NORMAL
- en: The attach command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This command attaches the running container and it is very helpful when you
    want to see what is written in `stdout` in real time, let''s launch new test container
    which outputs something to `stdout`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now we can attach to the container using the following command to see the output;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: By default, this command attaches `stdin` and proxies signals to the remote
    process. Options are available to control both behaviors. To detach from the process,
    use the default *Ctrl* + *Q* sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging a Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every instruction we set in the Dockerfile is going to be built as a separate,
    temporary image for the other instruction to build itself on top of the previous
    instruction.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a Dockerfile in the repo at `/bootcamp/ch` `apter06/debu` `g`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Building the image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Gives you the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a Dockerfile](img/B06455_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So, there is an error in our Docker file. You may notice there is a line in
    the output which says `--->5f828f86eaa4`this is actually an image file which was
    built following the successful execution of the `RUN ls -lha /` `home` line.
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a Dockerfile](img/B06455_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This means that we can launch a container using this image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that as we are using Alpine Linux as our base we are using `/bin/sh`
    rather than `/bin/bash`
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then debug our application, which in this case is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a Dockerfile](img/B06455_06_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debugging is a process of analyzing what's going on and it's different for every
    situation, but usually the way we start debugging is by trying to manually make
    the instruction that fail work manually and understand the error. When I get the
    instruction to work, I usually exit the container, update my Dockerfile and repeat
    the process until I have something working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that when the line which is causing the error is corrected (by supplying
    the correct line `RUN ls -lha /var`) and we try the build again that Docker doesn''t
    create a new image for the one step which was successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a Dockerfile](img/B06455_06_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once it has built the temporary image is removed and we are left with our final
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debugging a Dockerfile](img/B06455_06_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That was quite a simple example, but it should give you an idea of how to debug
    a more complex Dockerfile.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we looked at how you can use the API built into Docker
    to gain an insight to what resources your containers are running by running the
    `docker container stats` and `docker container top` commands. Now, we are to see
    how we can take it to the next level by using **cAdvisor** from Google.
  prefs: []
  type: TYPE_NORMAL
- en: 'Google describes cAdvisor as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: cAdvisor (Container Advisor) provides container users an understanding of the
    resource usage and performance characteristics of their running containers. It
    is a running daemon that collects, aggregates, processes, and exports information
    about running containers. Specifically, for each container, it keeps resource
    isolation parameters, historical resource usage, histograms of complete historical
    resource usage, and network statistics. This data is exported by a container and
    is machine-wide.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The project started off life as an internal tool at Google for gaining an insight
    into containers that had been launched using their own container stack.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Google's own container stack was called "Let Me Contain That For You" or lmctfy
    for short. The work on lmctfy has been installed as a Google port functionality
    over to libcontainer that is part of the Open Container Initiative. Further details
    on lmctfy can be found at [https://github.com/google/lmctfy/](https://github.com/google/lmctfy/)
  prefs: []
  type: TYPE_NORMAL
- en: cAdvisor is written in Go ([https://golang.org](https://golang.org)); you can
    either compile your own binary or you can use the pre-compiled binary that are
    supplied via a container, which is available from Google's own Docker Hub account.
    You can find this at [http://hub.docker.com/u/google/](http://hub.docker.com/u/google/).
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, cAdvisor will sit in the background and capture metrics that
    are like that of the `dockercontainer` `stats` command. We will go through these
    stats and understand what they mean later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: cAdvisor takes these metrics along with those for the host machine and exposes
    them via a simple and easy-to-use built-in web interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several ways to install cAdvisor; the easiest way to get started
    is to download and run the container image that contains a copy of a precompiled
    cAdvisor binary:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You should now have a cAdvisor container up and running on your host machine.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start looking at stats, let's look at cAdvisor in more detail by discussing
    why we have passed all the options to the container.
  prefs: []
  type: TYPE_NORMAL
- en: The cAdvisor binary is designed to run on the host machine alongside the Docker
    binary, so by launching cAdvisor in a container, we are isolating the binary in
    its own environment. To give cAdvisor access to the resources it requires on the
    host machine, we have to mount several partitions and also give the container
    privileged access to let the cAdvisor binary think it is being executed on the
    host machine.
  prefs: []
  type: TYPE_NORMAL
- en: So now, we have cAdvisor running; what do we need to do to configure the service
    in order to start collecting metrics?
  prefs: []
  type: TYPE_NORMAL
- en: The short answer is, nothing at all. When you started the cAdvisor process,
    it instantly started polling your host machine to find out what containers are
    running and gathered information on both the running containers and your host
    machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'cAdvisor should be running on the 8080 port; if you open `http://localhost:8080/`,
    you should be greeted with the cAdvisor logo and an overview of your host machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This initial page streams live stats about the host machine, though each section
    is repeated when you start to drill down and view the containers. To start with,
    let's look at each section using the host information.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overview section gives you a bird''s-eye view of your system; it uses gauges
    so you can quickly get an idea of which resources are reaching their limits. In
    the following screenshot, there is very little in the way of CPU utilization and
    the file system usage is relatively low; however, we are using 66% of the available
    RAM:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next up is the graph which shows the CPU utilization over the last minute:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Here is what each term means:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Total Usage**: This shows an aggregate usage across all cores'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage per Core**: This graph breaks down the usage per core'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage Breakdown**: This shows aggregate usage across all cores, but breaks
    it down to what is being used by the kernel and what is being used by the user-owned
    processes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Memory section is split into two parts. The graph tells you the total amount
    of memory used by all the processes for the host or container; this is the total
    of the hot and cold memory. The Hot memory is the current working set; pages that
    have been touched by the kernel recently. The Cold memory is the page that hasn't
    been touched for a while and could be reclaimed if needed.
  prefs: []
  type: TYPE_NORMAL
- en: The Usage Breakdown gives a visual representation of the total memory in the
    host machine, or allowance in the container, alongside the total and hot usage.
  prefs: []
  type: TYPE_NORMAL
- en: The network section shows the incoming and outgoing traffic over the last minute.
    You can change the interface using the drop-down box on the top-left.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a graph that shows any networking errors. Typically, this graph
    should be flat. If it isn't, then you will be seeing performance issues with your
    host machine or container.
  prefs: []
  type: TYPE_NORMAL
- en: The final section, filesystem, gives a breakdown of the filesystem usage. In
    the following screenshot, `/dev/vda1` is the boot partition, overlay is the main
    filesystem running your running containers.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can look at our containers. At the top of the page, there is a link of
    your running containers, it says **Docker Containers**; you can either click on
    the link or go directly to `http://localhost:8080/docker/`.
  prefs: []
  type: TYPE_NORMAL
- en: Once the page loads, you should see a list of all your running containers, and
    also a detailed overview of your Docker process, and finally a list of the images
    you have downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Subcontainers shows a list of your containers; each entry is a clickable link
    that will take you to a page that will give you the following details:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: This shows you the CPU allowances of the container; if you have not
    set any resource limits, you will see the host''s CPU information'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Memory**: This shows you the memory allowances of the container; if you have
    not set any resource limits, your container will show an unlimited allowance'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Usage**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Overview**: This shows gauges so you can quickly see how close to any resource
    limits you are'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processes**: This shows the processes for just your selected container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CPU**: This shows the CPU utilization graphs isolated to just your container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Memory: This shows the memory utilization of your container'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The Driver status section gives the basic stats on your main Docker process,
    along with the information on the host machine's kernel, host name, and also the
    underlying operating system.
  prefs: []
  type: TYPE_NORMAL
- en: It also gives information on the total number of containers and images. You
    may notice that the total number of images is a much larger figure than you expected
    to see; this is because it is counting each file system as an individual image.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you get a list of the Docker images which are available on the host
    machine. It lists the Repository, Tag, Size, and when the image was created, along
    with the images' unique ID. This lets you know where the image originated from
    (Repository), which version of the image you have downloaded (Tag) and how big
    the image is (Size).
  prefs: []
  type: TYPE_NORMAL
- en: This is all great, what's the catch?
  prefs: []
  type: TYPE_NORMAL
- en: So, you are maybe thinking to yourself that all this information available in
    your browser is really useful; being able to see real-time performance metrics
    in an easily readable format is a real plus.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest drawback of using the web interface for cAdvisor, as you may have
    noticed, is that it only shows you one minute's worth of metrics; you can quite
    literally see the information disappearing in real time.
  prefs: []
  type: TYPE_NORMAL
- en: As a pane of glass gives a real-time view into your containers, cAdvisor is
    a brilliant tool; if you want to review any metrics that are older than one minute,
    you are out of luck.
  prefs: []
  type: TYPE_NORMAL
- en: 'That is, unless you configure somewhere to store all your data; this is where
    Prometheus comes in.So what''s Prometheus? Its developers describe it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Prometheus is an open-source system's monitoring and alerting toolkit built
    at SoundCloud. Since its inception in 2012, it has become the standard for instrumenting
    new services at SoundCloud and is seeing growing external usage and contributions.
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: OK, but what does that have to do with cAdvisor? Well, Prometheus has quite
    a powerful database backend that stores the data it imports as a time series of
    events.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things cAdvisor does, by default, is expose all the metrics it is
    capturing on a single page at `/metrics`; you can see this at `http://localhost:8080/metricson`
    our cAdvisor installation. The metrics are updated each time the page is loaded,
    you should see something like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, this is just a single long page
    of raw text. The way Prometheus works is that you configure it to scrape the `/metrics`
    URL at a user-defined interval, let's say every five seconds; the text is in a
    format that Prometheus understands and it is ingested into the Prometheus's time
    series database.
  prefs: []
  type: TYPE_NORMAL
- en: What this means is that, using Prometheus's powerful built-in query language,
    you can start to drill down into your data. Let's look at getting Prometheus up
    and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, there is a work configuration file in the repo at `/bootcamp/chapter06/prometheus/`you
    will need to make sure you are in this folder as we are going to mounting the
    configuration file from within there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '![Monitoring containers](img/B06455_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The configuration file we have launched Prometheus with looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As we have launched our Prometheus container within the monitoring network our
    installation will be able scrape the metrics from `http://cadvisor:8080/`, also
    note that we haven't added `/metrics` to the URL as this added automatically by
    Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening `http://localhost:9090/targets` in your browser should show you something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, the status menu has links to the following information pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Runtime information&Build information**: This displays how long Prometheus
    has been up and polling data, if you have configured an end point and details
    of the version of Prometheus that you have been running'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Command-Line Flags**: This shows all the runtime variables and their values'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration**: This is a copy of the configuration file we injected into
    the container when it was launched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rules**: This is a copy of any rules we injected; these will be used for
    alerting'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we only have a few containers up and running at the moment, let's launch
    one that runs Redis so we can start to look at the query language built into Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use the official Redis image for this and as we are only going to use
    this as an example we won''t need to pass it any user variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now have a container called my-redis-server running. cAdvisor should already
    be exposing metrics about the container to Prometheus; let's go ahead and see.
  prefs: []
  type: TYPE_NORMAL
- en: In the Prometheus web interface, go to the **Graph** link in the menu at the
    top of the page. Here, you will be presented with a text box into which you can
    enter your query. To start with, let's look at the CPU usage of the Redis container.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the box, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, after clicking on Execute, you should have two results returned, listed
    in the Console tab of the page. If you remember, cAdvisor records the CPU usage
    of each of the CPU cores that the container has access to, which is why we have
    two values returned, one for `cpu00` and one for `cpu01`. Clicking on the **Graph**
    link will show you results over a period of time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, we now have access to the usage
    graphs for the last 5 minutes, which is about how long ago I launched the Redis
    instance before generating the graph.
  prefs: []
  type: TYPE_NORMAL
- en: 'Graphing, as you may have noticed, isn''t Prometheus''s strong point. Luckily
    Grafana has been able to use Prometheus as a data source for a while, let''s now
    launch a Grafana container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Monitoring containers](img/B06455_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once the container has launched, go to `http://localhost:3000/` in your browser
    and you will be prompted to login, the default username and password is `admin`
    / `admin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now you are logged in you should see something like the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you may have guessed, we need to click **Add data source**and the add then
    enter the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: prometheus'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Type**: <Select Prometheus from the drop down list>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Url**: `http://prometheus:9090`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Access**: <Select proxy from the drop down list>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leave everything else as is and then click on **Add**, after a second or two
    your data source should have successfully been added and the connection test passed.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our data source added we can add a dashboard. There are plenty
    of dashboards available, we are going to use the one published by Brian Christner
    which can be found at [https://grafana.net/dashboards/179/](https://grafana.net/dashboards/179/).
  prefs: []
  type: TYPE_NORMAL
- en: To import the dashboard,click on the **Grafana logo** in the top left, in the
    menu which opens go to **Dashboards** and then select **Import**. In the pop-up
    dialog which opens enter the URL for the dashboard, which is [https://grafana.net/dashboards/179/](https://grafana.net/dashboards/179/),
    into the **Grafana.net Dashboard** box and then click on the **Load** button.
  prefs: []
  type: TYPE_NORMAL
- en: That will load the dashboard configuration, on the next page you given two options,
    the **Name** is already filled in so just select **prometheus** from the dropdown
    **Prometheus** list and click the **Import** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once imported you should be greeted by a dashboard which looks similar (I have
    tweaked it for the screenshot) to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Monitoring containers](img/B06455_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You may notice from the screen above that we now have over an hour's worth of
    data from cAdvisor stored in Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth pointing that the current experimental build of Docker has a built-in
    Prometheus endpoint much in the same way that cAdvisor has. Once this hits the
    stable release I expect to see this be a great out of the box solution for monitoring
    your Docker hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, this is just one way you monitor your containers as there are numerous
    other tools both of which are self-hosted or run as a software as a service in
    the cloud such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Sysdig - [http://www.sysdig.org/](http://www.sysdig.org/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sysdig Cloud - [https://sysdig.com/](https://sysdig.com/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Datadog - [http://docs.datadoghq.com/integrations/docker/](http://docs.datadoghq.com/integrations/docker/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New Relic - [https://newrelic.com/partner/docker](https://newrelic.com/partner/docker)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coscale - [http://www.coscale.com/docker-monitoring](http://www.coscale.com/docker-monitoring)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Elastic Metric Beat - [https://www.elastic.co/products/beats/metricbeat](https://www.elastic.co/products/beats/metricbeat)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Hopefully now you should have an idea of where to start when it comes to looking
    into problems with containers, be it building them, checking logs, attaching to
    a container to further into issues or gathering performance metrics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, which is also our last, we will look at some of the different
    scenarios and use cases for both Docker and techniques we have covered in this
    and previous five chapters.
  prefs: []
  type: TYPE_NORMAL
