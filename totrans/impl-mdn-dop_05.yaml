- en: Infrastructure as Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we demonstrated how the new cloud data centers can
    help us create online resources (virtual machines, Docker repositories, cryptographic
    keys) in a very easy way, shortening the hardware provisioning cycle from weeks
    (buying, shipping, and installing new computers) to seconds. We have also seen
    that there are different providers in the market that can offer us very similar
    features with different strong points that we can take advantage of when building
    our systems.
  prefs: []
  type: TYPE_NORMAL
- en: You learned how to create resources through the web interface that they offer,
    but how scalable is that? Creating resources manually prevents us from keeping
    an automated inventory of resources that can be used for security purposes as
    well as manage our infrastructure as if it were software components.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you are going to learn how to build resources in the cloud
    first, through the SDK provided by the cloud data center vendor and then by a
    software component called **Terraform**, which is an industry standard for managing
    online resources. We are going to focus on **Google Cloud Platform** for several
    reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: The command-line interface, in my opinion, is easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: The Google Cloud Platform trial covers a good bunch of resources that you can
    use to experiment with throughout this book as you can create pretty much any
    resource in the full set of products.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this (April 2017), Google Cloud Platform is the best
    value for money when it comes to cloud data centers.
  prefs: []
  type: TYPE_NORMAL
- en: That said, AWS, Azure or any other provider also offer a very interesting range
    of trial accounts, but unfortunately, we cannot cover everything in a single book.
  prefs: []
  type: TYPE_NORMAL
- en: Google Cloud Platform SDK -  gcloud
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Google offers us a very comprehensive SDK that can be used for operating Google
    Cloud Platform as well as  installing software components related to cloud operations.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is install `gcloud`.
  prefs: []
  type: TYPE_NORMAL
- en: There are installers for Windows but, in general, for Unix-based systems (Linux
    and Mac mainly), we have an interactive installer that can be executed from the
    command line and the unattended mode (for automatic provisioning).
  prefs: []
  type: TYPE_NORMAL
- en: The different options can be found at [https://cloud.google.com/sdk/downloads](https://cloud.google.com/sdk/downloads).
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to install it (in my case, on Mac), the first thing we need to do
    is run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This will initiate the interactive installed in the online mode: we will be
    asked a number of questions during the installation process.'
  prefs: []
  type: TYPE_NORMAL
- en: The first one is the installation directory. By default, this is the home of
    the user, but you can change it to the folder of your choice. Once you have selected
    the folder, it will start downloading and installing the required base components.
  prefs: []
  type: TYPE_NORMAL
- en: The question is whether you want to help improve the Google Cloud SDK through
    the collection of anonymized data. Just answer as per your preferences.
  prefs: []
  type: TYPE_NORMAL
- en: Now, Google Cloud SDK will start installing the core components.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/13becb56-24c0-43c8-9d40-e14659b503b0.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding figure, Google SDK installs few packages that
    will be used to operate the basic services on Google Cloud Platform. Once it is
    finished (no need to do anything), it will ask you whether you want to modify
    the `PATH` variable of your system or not. Just reply `Y` and press *Enter* so
    that the `gcloud` command is available from the console. It will ask you in which
    file you want to modify the `PATH` variable. Usually, the default option that
    the installer provides you with is good enough. Before changing the file, the
    Google Cloud SDK installer will create a backup of the file with the same name
    with the `.backup` extension so you can revert the changes.
  prefs: []
  type: TYPE_NORMAL
- en: And we are done. It will ask you to start a new shell for the changes to take
    effect. Close your Terminal and open it again to check whether the `gcloud` command
    is available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have installed Google Cloud SDK, it is time to configure the authentication.
    Execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It will ask you to log in, so reply yes, which will open a browser window asking
    you to enter your Google credentials. Enter the ones associated with your trial
    account (if you didn't sign for the trial, do it before configuring your credentials).
    If you had a project already created in the Google Cloud Platform, it will ask
    you in the console to choose which one to use. In my case, I had one configured
    from [Chapter 2](6b4e8014-1c44-495b-b22b-e84fb1b944b8.xhtml), *Cloud Data Centers
    – The New Reality,* so I selected the one called `implementing-modern-devops`
    in my case.
  prefs: []
  type: TYPE_NORMAL
- en: The next topic is configuring the Google Compute Engine. Reply yes and select
    your availability zone. In my case, anywhere in Europe will work for me.
  prefs: []
  type: TYPE_NORMAL
- en: After this step, we are done. The prompt will tell us that we have a configuration
    called 'default' created. This means that the Google Cloud SDK can work with multiple
    credentials but, in this case, we are going to work with just one set of credentials
    and a single project.
  prefs: []
  type: TYPE_NORMAL
- en: Creating resources with Google Cloud SDK
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once we are set up, it is time to start creating resources. As you can guess,
    the commands for creating resources can be quite complicated or extremely simple
    depending on your requirements. Luckily,  Google engineers have thought about
    it when creating the interface for Google Cloud Platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing you need to do is log in to your Google Cloud Platform account.
    Once you are there, go to  Compute Engine and fill the form to create a new resource.
    Enter the name of the instance, choose your closest region (Europe in my case),
    machine type (the default one will do), API access (we don''t need that but the
    default is OK) and Allow HTTP traffic and Allow HTTPS traffic. Before clicking
    on create, take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a670c321-1e61-48ca-a059-276d7a0236ad.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If you take a look at the very bottom, below the Create button, there are two
    links:'
  prefs: []
  type: TYPE_NORMAL
- en: REST equivalent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For now, we are going to focus on the command line link. Click on it and you
    should get a window with a few commands. Let''s explain them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The first command creates the VM. As you can see, no one can expect to learn
    to create this command easily, but luckily, Google Cloud Platform provides it
    to you for every single resource that will be created for you so you can use the
    UI to generate the commands. That said, the preceding command sets every single
    potential setting that **Google Cloud** provides, so in other words, we will be
    able to run the preceding command with the same results no matter what settings
    we change in our cloud account.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a shorter version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This command does exactly the same as the very long command from earlier but
    assuming that the settings are the default (remember, you have already chosen
    some parameters, such as the default zone).
  prefs: []
  type: TYPE_NORMAL
- en: 'The other two commands are simpler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at this too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can guess, these commands allow the HTTP and the HTTPS traffic into our
    host as described in the UI form.
  prefs: []
  type: TYPE_NORMAL
- en: These are the basics of infrastructure as code. We could potentially write those
    commands on a bash script and off we go; our infrastructure is created automatically
    for us. In the same way, if we don't want to depend on Google Cloud SDK, we could
    choose the REST option that will show us the list of HTTP requests that we need
    to issue to Google Cloud in order to create the same resources. If you are familiar
    with languages such as Python, JavaScript (Node.js), and others, you know how
    easy is to issue HTTP requests in order to create the resources so you could manage
    your infrastructure as if it were code following the same life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a massive step forward in managing resources on the cloud, but it is
    still incomplete. Imagine this situation: you work in a company with a fairly
    complex setup, say, a few machines across different time zones and a fairly entangled
    network setup. How can you know at first glance which machines are running and
    what are the firewall rules are?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is simple: it is not possible with what we know today. In the next
    section, you are going to learn how to use something called **Terraform** from
    HashiCorp in order to manage not only the creation, but also the complete life
    cycle of online resources on different cloud providers.'
  prefs: []
  type: TYPE_NORMAL
- en: Terraform
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Terraform** is a product developed by **HashiCorp**. HashiCorp is a company
    with a strong focus on DevOps tools such as Consul, a highly available distributed
    key value storage, or Vagrant, a tool to reproduce development environments using
    the same provisioners as production.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Terraform, as the name hints, allows you to create infrastructure in cloud
    data centers in a declarative way, keeping track of what was created where, allowing
    you to apply changes to the infrastructure from the code perspective: your infrastructure
    is described as the code and, as such, it can follow its life cycle.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we need to do is download and install Terraform. Just open the
    [https://www.terraform.io/downloads.html](https://www.terraform.io/downloads.html)
    URL in a browser and select your platform, in my case, Mac. Terraform is a single
    binary compressed in a ZIP file (as far as I am aware, it is the same for every
    platform) that I unzip and place somewhere in my path, in my case, `in /usr/local/bin/terraform`.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful as some OSX setups do not include `/usr/local/bin/` in the PATH environment
    variable, so you might need to do it before being able to execute Terraform from
    any path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is installed and the `PATH` variable includes `/usr/local/bin/` as
    one of the values separated by semi colons, we can check whether everything works
    as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This should return the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This confirms that everything is correct. Also, be aware that DevOps tools
    move very quickly nowadays as they are required to do more things day by day.
    We are going to use the latest available version, 0.9.4, but by the time you are
    reading this book, a newer version might be available with new features and even
    some breaking changes. Luckily, Terraform comes with a very powerful documentation
    embedded in it. Let''s look at all the available commands. Just execute this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bd0e57a8-c830-4445-8c86-11004c148b2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, in order to display the help dialog on any of the commands, we just need
    to execute the command with the flag `-h`. For example, let''s display the help
    for `apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: It will output the list of all the options available for the command in the
    prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Creating resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have all the requirements installed, we are going to create our
    first resource in order to help us to understand how Terraform works and how powerful
    it is. Create a folder called `implementing-modern-devops` somewhere in your computer
    and add a file called `resources.tf` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the preceding snipped is very similar to JSON but it is actually
    called HCL: HashiCorp Configuration Language. Let''s explain what the code is
    doing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first section is where we configure our credentials. As you can see, Terraform
    is expecting a file called `xxx.json`, which we don''t have at the moment. If
    we check the official documentation of Terraform for Google Cloud Platform, it
    specifies that we need to create a Service account from the API Manager section
    of the Google Cloud Platform, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4bbdb6ed-997e-4caa-a022-cd899ba70420.png)'
  prefs: []
  type: TYPE_IMG
- en: Once we create it by choosing JSON as a format, a file will automatically be
    saved on our computer, containing the credentials that we need in order to operate
    Google Cloud Platform.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful. If you leak these credentials, someone could create or destroy resources
    on your behalf, which may lead to significant charges or data loss.
  prefs: []
  type: TYPE_NORMAL
- en: Copy the file to the previously created folder *(*`implementing-modern-devops`)
    and rename it to `xxx.json` so it matches our configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The second section is the description of our virtual machine, the instance to
    be created in Google Cloud. In this case, we are creating a resource called `my-first-instance`
    of the type `google_compute_instance`. We did not specify any configuration on
    purpose as I want to show you how to troubleshoot problems with Terraform, which,
    due to the high-quality error logs produced, is rather simple.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens. From the root of our project, the `implementing-modern-devops`
    folder, we run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This command will describe the steps required to create our infrastructure in
    Google Cloud. In this case, it is rather simple as we have only one machine, but
    it is going to be helpful to learn about Terraform.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at what happened and and how it has been explained in the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command failed. Basically, our compute instance requires four
    fields that we did not specify: `machine_type`, `name`, `zone`, and `disk`. In
    this case, we can specify them, but if you need to check extra parameters, all
    the documentation for the resource `google_compute_instance` can be found at [https://www.terraform.io/docs/providers/google/r/compute_instance.html](https://www.terraform.io/docs/providers/google/r/compute_instance.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Visit it and read around to get familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: We are also going to specify the network interface (basically the network we
    want to connect to our machine) as it will fail later on in the `apply` command
    if we don't do it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to fix the problems that we found on the first run. Replace
    the `google_compute_instance` block with the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to the Terminal and execute `terraform` plan'' again. The output will
    be similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: For space reasons, I have omitted an explanatory text that comes before the
    resource explanation but basically tells us that we can save this plan in a file
    in order to pass it as a parameter to the apply the command that we are going
    to run next.
  prefs: []
  type: TYPE_NORMAL
- en: This enables us to ensure that what is executed is what we have seen in the
    plan just in case someone else has modified the online infrastructure before calculating
    what needs to change, Terraform syncs the configuration in the resources files
    with the existing infrastructure in Google Cloud. So, it might be the case that
    we can execute `terraform plan`  and someone changes our cloud infrastructure
    (with another Terraform script or manually) and then our `terraform apply` command
    differs from the plan calculated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now once we have verified that our Terraform plan is to create a VM, execute
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'After a few seconds, the script should finish presenting the output of what
    was created, changed, or destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If everything went as per plan, we should have a file called `terraform.tfstate`
    in our folder which is the state of our virtual infrastructure created in the
    cloud. We also have the same file with the extension `backup`, which is the status
    of our infrastructure before running our last `apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: This file is important. Terraform is able to refresh it with changes made on
    the cloud, but it is not able to rebuild it. Some people keep this file alongside
    the Terraform scripts and some other people prefer to use a backend to store this
    file and manage the Terraform state.
  prefs: []
  type: TYPE_NORMAL
- en: Remote state management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A backend is a system that is going to store our status in a shared environment
    where everyone using the same configuration can quickly access it. Let''s look
    at how is this done using **Google Cloud Storage**. Just execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are a few considerations: we need to create a bucket called `my-terraform`
    in the Google Cloud Storage interface and we need to configure Application default
    credentials for Google Cloud. The easiest way to do this is by setting an environment
    variable called `GOOGLE_APPLICATION_CREDENTIALS` to the path where the `xxx.json`
    file that we have used to authenticate against GCP when running our infrastructure
    is. If you are in the same folder, just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Once this is done and the Terraform command succeeds, if we check our bucket
    in Google Cloud Storage, we have a new item with the content of `terraform.tfstate`
    that we had in our local file system.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can test that it works by altering our infrastructure and seeing how
    this is reflected in our bucket on Google Cloud Storage. You can do this easily
    by running `terraform destroy` and checking what happens to our remote state in
    Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful with the state files. They have very valuable information about your
    company's infrastructure and can be used as an attack vector.
  prefs: []
  type: TYPE_NORMAL
- en: 'This feature is used to share configuration across a team of engineers, and
    it is fully managed by Terraform: you don''t need to pull or push state files
    as Terraform will do it for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Modifying your infrastructure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have only created resources and stored the state of or cloud
    data center in an online bucket. Now you are going to learn how to modify the
    existing infrastructure from a project such as the one we built earlier on.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we started from a very simple example: create a single virtual
    machine with an ephemeral IP address (the default one assigned by Google, not
    fixed).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are going to create a static IP and assign it to our machine so it
    always uses the same IP. The way of doing this through Terraform is creating a
    resource of the type `google_compute_address`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can execute `terraform plan` to see what will change if we apply the
    infrastructure change. As you can see in your new execution plan, Terraform identifies
    that we need to create a new resource of type `google_compute_address`, but...
    how do we attach this IP to our VM? Let''s revisit the configuration of our VM:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the highlighted line of the code, you can see how simple it is to associate
    our VM with the new address that we are going to create: our created resource,
    the address, will have computed attributes (attributes calculated at runtime)
    that can be used in other resources. In Terraform, the syntax for interpolating
    values is `${}` with the value of the attribute to interpolate between the brackets,
    in this case, the IP address of the resource called `my-first-ip`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you head to the Google Cloud Console and open the external IP''s section,
    you can see something similar to what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d9b35cc2-225e-44b6-b738-fd528e8d8d00.png)'
  prefs: []
  type: TYPE_IMG
- en: The IP was associated with our VM, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One thing we did not mention earlier is the fact that Terraform can work with
    variables. Take a look at the following definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the configuration of our provider. There are few strings that, quite
    likely, are going to be used in other places, such as the region or the name of
    the project. Terraform has the concept of variable, which is a value that is susceptible
    to change so we can extract it into a separated file. Up until now, we have created
    a file called `resources.tf`. Let''s create a file called `vars.tf` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are going to use these variables in our files. By default, Terraform
    will look into all the files with the extension `.tf` in our current folder, build
    the knowledge base of all the facts that have been described, and start creating
    our infrastructure as appropriated (internally building a graph of dependencies
    that can be checked with the `terraform graph` command). This means that we don''t
    need to do anything special for Terraform to pick up our variables file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can use variables pretty much anywhere to facilitate our infrastructure creation.
    As you can see, the syntax is the same as the syntax used for interpolation; in
    fact, it is an interpolation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the variables file, we have specified the default values for the variables,
    but it is possible that we want to change them depending on the environment or
    even for tweaking the configuration. Terraform also allows you to override variables
    in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: On the command line
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a file called `terraform.tfvars`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With environment variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first way is as easy as passing extra flags to the `terraform` commands.
    For example, if we want to change `project_name` when applying the changes to
    our infrastructure, we just need to pass an extra flag with the value of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: And that's it. You can experiment by changing the project name or the zone and
    see how `terraform plan` creates new resources (as they don't exist in a different
    project).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method is using a file with the variable definitions. In order to
    test it, create a file called `terraform.tfvars` in the root of your project with
    the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Now, if you run `terraform plan`, you will see how Terraform plans to create
    new resources as they don't exist in a project called `my-new-project-name`. The
    filename does not need to be `terrafrom.tfvars`, but if you create it with a different
    name, Terraform won't pick it up by default and you will need to pass the flag
    -var-file in order to load it.
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to remove the `terraform.tfvars` file before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third way of overriding variables is via environment variables. This is
    particularly interesting as it easily allows you to manage the configuration of
    different environments by external factors. The convention is to define an environment
    variable with the same name as the variable in Terraform but prefixing it with
    `TF_VAR_`. For example, for the variable `project_name`, we would execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Terraform outputs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have worked with Terraform to create our infrastructure but
    we have little to no insight on what is going on in our cloud, in this case, on
    Google Cloud Platform. The engineers from HashiCorp have also thought about this,
    and they have created an element called output that allows us to print values
    of the resources created by our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`variables.tf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before proceeding, make sure that your online infrastructure is created by running
    `terraform apply` as we did earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are going to create another file called `outputs.tf`. This is not coincidental.
    In Terraform, this is the recommended layout for your projects as it facilitates
    the code readability as well as segregates responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following content to the `outputs.tf` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We will come back to this command later, but now, we need to rerun the apply
    command in order to let Terraform create the output for us. Something has changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Terraform apply needs to be run for your outputs for it to become available
    even if you did not change the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can see a new section called outputs, which contain the values that
    we have defined in the outputs file. If you want to see it again at any time,
    just run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, simply run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first one will show only the IP of the instance (this is particularly handy
    for using it as input for other commands). The second one shows all the outputs
    defined in your Terraform scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s explain how the outputs work. In this case, we have used the following
    string to identify what we want to output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The first two keys (separated by dots) are clear: the type and the name of
    our resource. Then, the IP belongs to `network_interface` in the `acccess_config`
    section and the value is stored in `nat_ip`*,* but what are those 0ses in there?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Easy; we can define more than one network interface by repeating the `network_interface`
    block as many times as you need: the first one in the code will be `0`, the second
    one will be `1`, and so on...'
  prefs: []
  type: TYPE_NORMAL
- en: 'This attribute path can be tricky to calculate sometimes, although the majority
    of the time is quite obvious from the configuration file. If you experience problems
    finding what you want to output, here is a shortcut: When you run `terraform apply`,
    in the output, you will see something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5112bd1-3f03-4a48-9966-e10f8b3912ce.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the list of all the attributes that you can show in your outputs; the
    key is the column on the left-hand side. For example, if we want to show the zone
    where our VM is created, it is as simple as this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the interpolation also works here, letting you mix strings with
    values of the Terraform resources.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Terraform is the basic tool that every DevOps engineer needs to master in order
    to work efficiently with cloud providers such as Google Cloud Platform or AWS
    as it allows you to manage the infrastructure as if code was, with a lifecycle
    the ability to deploy infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we saw the most important aspects of Terraform regarding the
    creation of virtual infrastructure. You learned enough to be able to, with the
    help of the online documentation, create resources and connect them in order to
    create much bigger projects.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the examples that we followed through this chapter were pretty basic,
    in the next chapter, we will create a more complex infrastructure and install
    the required software to run it in an automated fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We will also use more advanced Terraform capabilities such as modules to create
    highly reusable components that can be shared with different teams or even as
    open source components.
  prefs: []
  type: TYPE_NORMAL
