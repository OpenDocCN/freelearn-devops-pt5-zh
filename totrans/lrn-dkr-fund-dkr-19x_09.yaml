- en: Using Docker to Supercharge Automation
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Docker 来加速自动化
- en: In the last chapter, we introduced techniques commonly used to allow a developer
    to evolve, modify, debug, and test their code while running in a container. We
    also learned how to instrument applications so that they generate logging information
    that can help us to do root cause analysis of failures or misbehaviors of applications
    or application services that are running in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了常用的技术，帮助开发者在容器中运行时对代码进行演化、修改、调试和测试。我们还学习了如何对应用程序进行监控，使其生成日志信息，帮助我们进行故障根因分析，诊断在生产环境中运行的应用程序或应用服务的失败或异常行为。
- en: In this chapter, we will show how you can use tools to perform administrative
    tasks without having to install those tools on the host computer. We will also
    illustrate the use of containers that host and run test scripts or code used to
    test and validate application services running in containers. Finally, we will
    guide the reader through the task of building a simple Docker-based CI/CD pipeline.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将展示如何使用工具执行管理任务，而无需在主机上安装这些工具。我们还将说明如何使用容器托管并运行测试脚本或代码，用于测试和验证在容器中运行的应用服务。最后，我们将引导读者完成构建一个简单的基于
    Docker 的 CI/CD 流水线的任务。
- en: 'This is a quick overview of all of the subjects we are going to touch on in
    this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将在本章中涉及的所有主题的简要概述：
- en: Executing simple admin tasks in a container
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中执行简单的管理任务
- en: Using test containers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试容器
- en: Using Docker to power a CI/CD pipeline
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 来驱动 CI/CD 流水线
- en: 'After finishing this chapter, you will be able to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将能够执行以下操作：
- en: Run a tool not available on the host in a container
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行主机上不可用的工具
- en: Use a container to run test scripts or code against an application service
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用容器运行测试脚本或代码来测试应用服务
- en: Build a simple CI/CD pipeline using Docker
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Docker 构建一个简单的 CI/CD 流水线
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this section, if you want to follow along with the code, you need Docker
    for Desktop on your macOS or Windows machine and a code editor, preferably Visual
    Studio Code. The sample will also work on a Linux machine with Docker and VS Code
    installed.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，如果你想跟随代码进行操作，你需要在你的 macOS 或 Windows 机器上安装 Docker Desktop，并且需要一个代码编辑器，最好是
    Visual Studio Code。该示例同样适用于安装了 Docker 和 VS Code 的 Linux 机器。
- en: Executing simple admin tasks in a container
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中执行简单的管理任务
- en: 'Let''s assume you need to strip all leading whitespaces from a file and you
    found the following handy Perl script to do exactly that:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要去除文件中的所有前导空格，并且你找到了一个非常有用的 Perl 脚本来完成这一任务：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As it turns out, you don''t have Perl installed on your working machine. What
    can you do? Install Perl on the machine? Well, that would certainly be an option,
    and it''s exactly what most developers or system admins do. But wait a second,
    you already have Docker installed on your machine. Can''t we use Docker to circumvent
    the need to install Perl? Yes, we can. This is how we''re going to do it:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 结果证明，你的工作机器上没有安装 Perl。那么你该怎么办？在机器上安装 Perl 吗？这当然是一个选项，也是大多数开发者或系统管理员会采取的做法。但等等，你的机器上已经安装了
    Docker。难道我们不能用 Docker 来避免安装 Perl 吗？是的，我们可以。我们将按以下方式操作：
- en: 'Create a folder, `ch07/simple-task`, and navigate to it:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文件夹，`ch07/simple-task`，并进入该文件夹：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open VS Code from within this folder:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该文件夹中打开 VS Code：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this folder, create a `sample.txt` file with the following content:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中，创建一个`sample.txt`文件，内容如下：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Please note the whitespaces at the beginning of each line. Save the file.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意每一行开头的空格。保存文件。
- en: 'Now, we can run a container with Perl installed in it. Thankfully, there is
    an official Perl image on Docker Hub. We are going to use the slim version of
    the image:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行一个已经安装了 Perl 的容器。幸运的是，Docker Hub 上有一个官方的 Perl 镜像。我们将使用该镜像的精简版本：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding command runs a Perl container (`perl:slim`) interactively, maps
    the content of the current folder into the `/usr/src/app` folder of the container,
    and sets the working folder inside the container to `/usr/src/app`. The command
    that is run inside the container is `sh -c "cat sample.txt | perl -lpe 's/^\s*//'"`,
    basically spawning a Bourne shell and executing our desired Perl command.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令以交互方式运行一个 Perl 容器（`perl:slim`），将当前文件夹的内容映射到容器中的`/usr/src/app`文件夹，并将容器中的工作目录设置为`/usr/src/app`。在容器中运行的命令是`sh
    -c "cat sample.txt | perl -lpe 's/^\s*//'"`，基本上是启动一个 Bourne shell 并执行我们所需的 Perl
    命令。
- en: 'The output generated by the preceding command should look like this:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令生成的输出应如下所示：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Without needing to install Perl on our machine, we were able to achieve our
    goal.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不需要在机器上安装Perl的情况下，我们就能够实现目标。
- en: 'If that doesn''t convince you yet because if you''re on macOS, you already
    have Perl installed, then consider you''re looking into running a Perl script
    named `your-old-perl-script.pl` that is old and not compatible with the newest
    release of Perl that you happen to have installed on your system. Do you try to
    install multiple versions of Perl on your machine and potentially break something?
    No, you just run a container with the (old) version of Perl that is compatible
    with your script, as in this example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不能说服你，假设你正在运行一个名为`your-old-perl-script.pl`的Perl脚本，这个脚本已经过时并且与系统中最新版本的Perl不兼容。你是否会尝试在机器上安装多个版本的Perl，可能会导致一些问题？不，你只需要运行一个兼容脚本的（旧版）Perl版本的容器，如下所示：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, `<old-version>` corresponds to the tag of the version of Perl that you
    need to run your script. The nice thing is that, after the script has run, the
    container is removed from your system without leaving any traces because we used
    the `--rm` flag in the `docker container run` command.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`<old-version>`对应你需要运行脚本的Perl版本标签。好处是，脚本运行完后，容器会从系统中被移除，不会留下任何痕迹，因为我们在`docker
    container run`命令中使用了`--rm`标志。
- en: 'A lot of people use quick and dirty Python scripts or mini apps to automate
    tasks that are not easily coded with, say, Bash. Now if the Python script has
    been written in Python 3.7 and you only happen to have Python 2.7 installed, or
    no version at all on your machine, then the easiest solution is to execute the
    script inside a container. Let''s assume a simple example where the Python script
    counts lines, words, and letters in a given file and outputs the result to the
    console:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人使用快速且简陋的Python脚本或小型应用程序来自动化一些不容易用比如Bash脚本来编写的任务。如果这个Python脚本是用Python 3.7写的，而你机器上只安装了Python
    2.7，或者根本没有安装任何版本，那么最简单的解决方案就是在容器内执行脚本。假设有这样一个简单的例子：这个Python脚本统计一个给定文件中的行数、单词数和字母数，并将结果输出到控制台：
- en: 'Still in the `ch07/simple-task` folder add a `stats.py` file and add the following
    content:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在`ch07/simple-task`文件夹中，添加一个`stats.py`文件并加入以下内容：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After saving the file, you can run it with the following command:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件后，可以使用以下命令运行它：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note that, in this example, we are reusing the `sample.txt` file from before.
    The output in my case is as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在这个例子中，我们正在重新使用之前的`sample.txt`文件。我的输出结果如下：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The beauty of this approach is that this Python script will now run on any computer
    with any OS installed, as long as the machine is a Docker host and, hence, can
    run containers.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，这个Python脚本现在可以在任何安装了操作系统的计算机上运行，只要该机器是Docker主机，并且能够运行容器。
- en: Using test containers
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用测试容器
- en: 'For each serious software project out there, it is highly recommended to have
    plenty of tests in place. There are various test categories such as unit tests,
    integration tests, stress and load tests, and end-to-end tests. I have tried to
    visualize the different categories in the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个严肃的软件项目，强烈建议进行大量的测试。测试类别有很多种，例如单元测试、集成测试、压力和负载测试以及端到端测试。我试图在以下截图中可视化这些不同的类别：
- en: '![](img/f5d017fc-0214-43d4-9c0a-a701c9731c84.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5d017fc-0214-43d4-9c0a-a701c9731c84.png)'
- en: Categories of application tests
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 应用测试的类别
- en: Unit tests assert the correctness and quality of an individual, isolated piece
    of the overall application or application service. Integration tests make sure
    that pieces that are closely related work together as expected. Stress and load
    tests often take the application or service as a whole and assert a correct behavior
    under various edge cases such as high load through multiple concurrent requests
    handled by the service, or by flooding the service with a huge amount of data.
    Finally, end-to-end tests simulate a real user working with the application or
    application service. The typical tasks that a user would do are automated.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试用于断言单个、孤立的应用或应用服务部分的正确性和质量。集成测试确保相关的部分能够按预期一起工作。压力和负载测试通常是对整个应用或服务进行测试，验证其在各种边缘情况下（例如通过多个并发请求高负载，或用大量数据淹没服务）是否能够正常工作。最后，端到端测试模拟真实用户使用应用或应用服务的场景。用户的典型任务会被自动化。
- en: The code or component under test is often called a **System Under Test** (**SUT**).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 被测试的代码或组件通常被称为**待测试系统**（**SUT**）。
- en: Unit tests are in their nature tightly coupled to the actual code or SUT. It
    is, hence, necessary that those tests run in the same context as the code under
    test. Hence, the test code lives in the same container as the SUT. All external
    dependencies of the SUT are either mocked or stubbed.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试本质上与实际的代码或被测试系统（SUT）紧密耦合。因此，这些测试必须在与被测试代码相同的上下文中运行。因此，测试代码与SUT在同一个容器中运行。SUT的所有外部依赖项都要么是模拟的，要么是桩方法。
- en: 'Integration tests, stress and load tests, and end-to-end tests, on the other
    hand, act on public interfaces of the system under test and it is, hence, most
    common to run that test code in a separate container:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试、压力测试、负载测试和端到端测试，另一方面，作用于被测试系统的公共接口，因此，通常这些测试代码会运行在单独的容器中：
- en: '![](img/3e2a02c0-87e7-412b-b912-4060b337280f.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e2a02c0-87e7-412b-b912-4060b337280f.png)'
- en: Integration tests using containers
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用容器进行的集成测试
- en: In the preceding diagram, we can see the **Test Code** running in its own **Test
    Container**. The **Test Code** accesses the public interface of the **API** component
    that also runs in a dedicated container. The **API** component has external dependencies
    such as **Other** **Service** and **Database** that each run in their dedicated
    container. In this case, the whole ensemble of **API**, **Other** **Service**, and
    **Database **is our system under test, or SUT.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图表中，我们可以看到**测试代码**运行在自己的**测试容器**中。**测试代码**访问运行在专用容器中的**API**组件的公共接口。**API**组件有外部依赖项，如**其他服务**和**数据库**，它们各自运行在各自的容器中。在这种情况下，**API**、**其他服务**和**数据库**的整体组合就是我们的被测试系统（SUT）。
- en: 'What exactly would stress and load tests look like? Imagine a situation where
    we have a Kafka Streams application we want to put under test. The following diagram
    gives an idea of what exactly we could test, from a high level:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 压力测试和负载测试到底是什么样的呢？假设我们有一个Kafka Streams应用程序，我们希望对其进行测试。下面的图表给出了我们可以测试的内容的大致概念：
- en: '![](img/7b928ee2-e7df-4a26-9c6c-1504683653ee.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7b928ee2-e7df-4a26-9c6c-1504683653ee.png)'
- en: Stress and load test a Kafka Streams application
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对Kafka Streams应用程序进行压力测试和负载测试
- en: 'In a nutshell, a **Kafka Streams application** consumes data from one or more
    topics stored in Apache Kafka(R). The application filters, transforms, or aggregates
    the data. The resulting data is written back to one or several topics in Kafka.
    Typically, when working with Kafka, we deal with real-time data streaming into
    Kafka. Tests could now simulate the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，**Kafka Streams应用程序**从一个或多个存储在Apache Kafka(R)中的主题消费数据。该应用程序对数据进行过滤、转换或聚合。结果数据会写回到一个或多个Kafka主题中。通常，在与Kafka一起工作时，我们处理实时流入Kafka的数据。现在，测试可以模拟以下情况：
- en: Large topics with a huge amount of records
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大主题，包含大量记录
- en: Data flowing into Kafka with a very high frequency
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据以非常高的频率流入Kafka
- en: Data being grouped by the application under test, where there is a lot of distinct
    keys, each one with low cardinality
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据由被测试的应用程序进行分组，存在大量不同的键，每个键的基数较低
- en: Data aggregated by time windows where the size of the window is small, for example, each only
    a few seconds long
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按时间窗口聚合的数据，其中窗口的大小较小，例如，每个窗口只有几秒钟长
- en: End-to-end tests automate the users that interact with an application by the
    use of tools such as the Selenium Web Driver, which provides a developer means
    to automate actions on a given web page such as filling out fields in a form or
    clicking buttons.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 端到端测试通过使用像Selenium Web Driver这样的工具自动化与应用程序交互的用户操作，Selenium提供了一个开发人员自动化操作的手段，例如在表单中填写字段或点击按钮。
- en: Integration tests for a Node.js application
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Node.js应用程序的集成测试
- en: 'Let''s now have a look at a sample integration test implemented in Node.js.
    Here is the setup that we are going to look into:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一个在Node.js中实现的集成测试示例。以下是我们将要查看的设置：
- en: '![](img/b2695574-24aa-48e3-9760-f0ab1e9e8247.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2695574-24aa-48e3-9760-f0ab1e9e8247.png)'
- en: Integration tests for an Express JS Application
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Express JS应用程序的集成测试
- en: 'Following are the steps to create such an integration test:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是创建这种集成测试的步骤：
- en: 'Let''s first prepare our project folder structure. We create the project root
    and navigate to it:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先准备项目文件夹结构。我们创建项目根目录并进入该目录：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Within this folder, we create three subfolders, `tests`, `api`, and `database`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中，我们创建三个子文件夹，`tests`、`api`和`database`：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, we open VS Code from the project root:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们从项目根目录打开VS Code：
- en: '[PRE12]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To the `database` folder, add an `init-script.sql` file with the following
    content:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`database`文件夹中，添加一个`init-script.sql`文件，内容如下：
- en: '[PRE13]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The preceding script will create a `hobbies` table in our Postgres database
    that we are going to use and fill it with some seed data. Save the file.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 上述脚本将在我们的 Postgres 数据库中创建一个 `hobbies` 表，并将一些种子数据填充进去。保存文件。
- en: 'Now we can start the database. Of course, we are going to use the official
    Docker image for Postgres to run the database in a container. But first, we will
    create a Docker volume where the database will store its files. We will call the
    volume `pg-data`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以启动数据库了。当然，我们将使用 Postgres 的官方 Docker 镜像在容器中运行数据库。但首先，我们将创建一个 Docker 卷，用于存储数据库的文件。我们将此卷命名为
    `pg-data`：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, it''s time to run the database container. From within the project root
    folder (`integration-test-node`), run the following:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候启动数据库容器了。在项目根文件夹（`integration-test-node`）内，运行以下命令：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note that the folder from which you run the preceding command matters, due to
    the volume mounting we are using for the database initialization script, `init-script.sql`.
    Also note that we are using environment variables to define the name and user
    of the database in Postgres, and we are mapping port `5432` of Postgres to the
    equivalent port on our host machine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，运行上述命令时，文件夹位置很重要，因为我们正在使用数据库初始化脚本 `init-script.sql` 的卷挂载。同时，我们通过环境变量定义了
    Postgres 数据库的名称和用户，并将 Postgres 的端口 `5432` 映射到主机机器上的相应端口。
- en: 'After you have started the database container, double-check that it runs as
    expected by retrieving its logs:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动数据库容器后，双重检查它是否按预期运行，方法是检索其日志：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You should see something similar to this:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的内容：
- en: '[PRE17]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note, we have shortened the output for better readability. The important parts
    of the preceding output are the first few lines, where we can see that the database
    has picked up our initialization script, created the `hobbies` table and seeded
    it with five records. Also important is the last line, telling us that the database
    is ready to work. The container logs are always your first stop when troubleshooting
    problems!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了提高可读性，我们已简化了输出。前述输出的重点是前几行，我们可以看到数据库已经加载了我们的初始化脚本，创建了 `hobbies` 表并填充了五条记录。另一个重要的部分是最后一行，告诉我们数据库已经准备好工作。容器日志始终是排查问题的第一站！
- en: 'With that, our first piece of the SUT is ready. Let''s move on to the next
    one, which is our API implemented in Express JS:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，我们的第一个 SUT 部件已经准备好。接下来，我们将进入下一个部分，即我们在 Express JS 中实现的 API：
- en: 'In the Terminal window, navigate to the `api` folder:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端窗口中，导航到 `api` 文件夹：
- en: '[PRE18]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Then, run `npm init` to initialize the API project. Just accept all defaults:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，运行 `npm init` 来初始化 API 项目。只需接受所有默认选项：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The resulting `package.json` file should look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的 `package.json` 文件应该如下所示：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Modify the `scripts` node of the preceding file so that it contains a start
    command:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改上述文件中的 `scripts` 节点，使其包含启动命令：
- en: '![](img/6c851736-d5d7-4656-b565-8666cd016cf8.png)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6c851736-d5d7-4656-b565-8666cd016cf8.png)'
- en: Adding a start script to the package.json file
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 向 package.json 文件中添加启动脚本
- en: 'We then have to install Express JS and can do so with the following command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们需要安装 Express JS，可以使用以下命令：
- en: '[PRE21]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will install the library and all of its dependencies and add a dependencies node to
    our `package.json` file that looks similar to this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装该库及其所有依赖项，并在我们的 `package.json` 文件中添加一个类似于下面的依赖项节点：
- en: '![](img/6d01c027-f5be-4de4-be22-57af5ff422e0.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6d01c027-f5be-4de4-be22-57af5ff422e0.png)'
- en: Adding Express JS as a dependency to the API
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Express JS 作为依赖项添加到 API
- en: 'In the `api` folder, create a `server.js` file and add the following code snippet:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `api` 文件夹中，创建一个 `server.js` 文件，并添加以下代码片段：
- en: '![](img/55518a75-754f-4ef7-98bf-e93eb73332a7.png)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![](img/55518a75-754f-4ef7-98bf-e93eb73332a7.png)'
- en: Simple Express JS API
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的 Express JS API
- en: This is a simple Express JS API with only the `/` endpoint implemented. It serves
    as a starting point for our exploration into integration testing. Note that the
    API will be listening at port `3000`, on all endpoints inside the container (`0.0.0.0`).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的 Express JS API，仅实现了 `/` 端点。它作为我们探索集成测试的起点。请注意，API 将在端口 `3000` 上监听，且容器内的所有端点都使用
    `0.0.0.0`。
- en: 'Now we can start the API with `npm start` and then test the home endpoint,
    for example, with `curl`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过 `npm start` 启动 API，然后测试首页端点，例如，使用 `curl`：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After all of these steps, we're ready to scaffold the test environment.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 完成所有这些步骤后，我们已经准备好构建测试环境。
- en: 'We will be using `jasmine` to write our tests. Navigate to the `tests` folder
    and run `npm init` to initialize the test project:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用 `jasmine` 来编写我们的测试。导航到 `tests` 文件夹并运行 `npm init` 来初始化测试项目：
- en: '[PRE23]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Accept all of the defaults.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接受所有默认设置。
- en: 'Next, add `jasmine` to the project:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`jasmine`添加到项目中：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then initialize `jasmine` for this project:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后为该项目初始化`jasmine`：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We also need to change our `package.json` file so that the scripts block looks
    like this:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要更改`package.json`文件，使得`script`块看起来像这样：
- en: '![](img/f06ce569-69d4-47ab-9346-700ec2fa8eaf.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f06ce569-69d4-47ab-9346-700ec2fa8eaf.png)'
- en: Adding a test script for our integration tests
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的集成测试添加测试脚本
- en: 'We cannot run the tests any time by executing `npm test` from within the `tests`
    folder. The first time we run it, we will get an error since we have not yet added
    any tests:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们不能随时通过在`tests`文件夹中执行`npm test`来运行测试。第一次运行时，我们会得到一个错误，因为我们还没有添加任何测试：
- en: '![](img/fa888ef5-069b-4297-a38e-2af3a671686c.png)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fa888ef5-069b-4297-a38e-2af3a671686c.png)'
- en: The first run fails since no tests were found
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行失败，因为没有找到测试
- en: 'Now in the `spec/support` subfolder of the project, let''s create a `jasmine.json` file.
    This will contain the configuration settings for the `jasmine` test framework.
    Add the following code snippet to this file and save:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在项目的`spec/support`子文件夹中，让我们创建一个`jasmine.json`文件。它将包含`jasmine`测试框架的配置设置。将以下代码片段添加到此文件并保存：
- en: '[PRE26]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Since we are going to author integration tests we will want to access the SUT
    via its public interface, which, in our case, is a RESTful API. Hence, we need
    a client library that allows us to do so. My choice is the Requests library. Let''s
    add it to our project:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将编写集成测试，我们需要通过其公共接口访问SUT，在我们的案例中，接口是一个RESTful API。因此，我们需要一个客户端库来实现这一点。我的选择是Requests库。让我们将其添加到我们的项目中：
- en: '[PRE27]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add an `api-spec.js` file to the `spec` subfolder of the project. It will contain
    our test functions. Let''s start with the first one:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目的`spec`子文件夹中添加一个`api-spec.js`文件。它将包含我们的测试函数。让我们从第一个测试开始：
- en: '![](img/6f2f86bd-53a7-4447-ac3d-171f7955d2de.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6f2f86bd-53a7-4447-ac3d-171f7955d2de.png)'
- en: Sample test suite for the API
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: API的示例测试套件
- en: We are using the `request` library to make RESTful calls to our API (line `1`).
    Then, on line `3`, we're defining the base URL on which the API is listening.
    Note, the code that we use allows us to override the default of `http://localhost:3000`
    with whatever we define in an environment variable called `BASE_URL`. Line `5`
    defines our test suite, which, on line `6`, has a test for `GET /`. We then assert
    two outcomes, namely that the status code of a `GET` call to `/` is `200` (OK)
    and that the text returned in the body of the response is equal to `Sample API`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`request`库来向我们的API发出RESTful调用（第`1`行）。然后，在第`3`行，我们定义了API监听的基础URL。注意，我们使用的代码允许我们通过一个名为`BASE_URL`的环境变量来覆盖默认的`http://localhost:3000`。第`5`行定义了我们的测试套件，在第`6`行，它有一个针对`GET
    /`的测试。然后我们断言两个结果，即`GET`调用`/`的状态码是`200`（OK），并且响应体中返回的文本等于`Sample API`。
- en: 'If we run the test now, we get the following outcome:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果现在运行测试，我们将得到以下结果：
- en: '![](img/11d9290c-3d06-4c15-84ac-ae664f87ad9b.png)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![](img/11d9290c-3d06-4c15-84ac-ae664f87ad9b.png)'
- en: Successfully running Jasmine-based integration tests
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 成功运行基于Jasmine的集成测试
- en: We have two specifications—another word for tests—running; all of them are successful
    since we have zero failures reported.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个规格——测试的另一个说法——在运行；它们都是成功的，因为没有报告任何失败。
- en: Before we continue, please stop the API and remove the Postgres container with
    `docker container rm -f postgres`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们继续之前，请停止API并使用`docker container rm -f postgres`删除Postgres容器。
- en: 'So far so good, but now let''s bring containers to the table. That''s what
    we are most excited about, isn''t it? We''re excited to run everything, including
    test code in containers. If you recall, we are going to deal with three containers,
    the database, the API, and the container with the test code. For the database,
    we are just using the standard Postgres Docker image, but, for the API and tests,
    we will create our own images:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利，但现在让我们将容器引入到工作中。这才是我们最兴奋的部分，不是吗？我们很期待在容器中运行所有内容，包括测试代码。如果你还记得，我们将使用三个容器：数据库、API以及包含测试代码的容器。对于数据库，我们仅使用标准的Postgres
    Docker镜像，但对于API和测试，我们将创建自己的镜像：
- en: 'Let''s start with the API. To the `api` folder, add a `Dockerfile` file with
    this content:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从API开始。将以下内容添加到`api`文件夹中的`Dockerfile`文件：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This is just a very standard way of creating a container image for a Node.js
    based application. There's nothing special here.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是为基于Node.js的应用程序创建容器镜像的一种非常标准的方式。这里没有什么特别的。
- en: 'To the `tests` folder, also add a Dockerfile with this content:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`tests`文件夹中添加一个具有以下内容的Dockerfile：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we''re ready to run all three containers, in the right sequence. To simplify
    this task, let''s create a shell script that does exactly that. Add a `test.sh` file to
    the `integration-test-node` folder, our project root folder. Add the following
    content to this file and save:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好按正确顺序运行所有三个容器了。为了简化这个任务，我们创建一个执行此操作的 shell 脚本。将`test.sh`文件添加到`integration-test-node`文件夹，即我们的项目根文件夹。将以下内容添加到该文件并保存：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On the first two lines of the script, we make sure that the two container images
    for API and tests are built with the newest code. Then, we create a Docker network
    called `test-net` on which we will run all three containers. Don't worry about
    the details of this as we will explain networks in detail in [Chapter 10](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml),
    *Single Host Networking*. For the moment, suffice to say that if all containers
    run on the same network, then the applications running inside those containers
    can see each other as if they were running natively on the host, and they can
    call each other by name.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在脚本的前两行，我们确保 API 和测试的两个容器镜像使用的是最新的代码。然后，我们创建一个名为`test-net`的 Docker 网络，所有三个容器将在此网络上运行。不要担心这些细节，我们将在[第
    10 章](f3b1e24a-2ac4-473a-b9c8-270b97df6a8a.xhtml)中详细解释网络。此时只需了解，如果所有容器都运行在同一网络上，那么运行在这些容器中的应用程序可以像在主机上本地运行一样相互看到，并且可以通过名称互相调用。
- en: The next command starts the database container, followed by the command that
    starts the API. Then, we pause for a few seconds to give the database and the
    API time to completely start up and initialize, before we start the third and
    final container, the tests container.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下一条命令启动数据库容器，接着启动 API 的命令。然后，我们暂停几秒钟，给数据库和 API 完全启动和初始化的时间，之后我们启动第三个也是最后一个容器——测试容器。
- en: 'Make this file an executable with the following:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令使该文件可执行：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now you can run it:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以运行它：
- en: '[PRE32]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'If everything works as expected, you should see something along these lines
    (shortened for readability):'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切按预期工作，你应该会看到类似以下内容（为了可读性已简化）：
- en: '[PRE33]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can also create a script that cleans up after testing. For this, add a file
    called `cleanup.sh` and make it an executable the same way as you''ve done with
    the `test.sh` script. Add the following code snippet to this file:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以创建一个脚本，在测试完成后进行清理。为此，添加一个名为`cleanup.sh`的文件，并像你对待`test.sh`脚本一样，使其可执行。将以下代码片段添加到此文件中：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Line one removes the `postgres` and `api` containers. Line 2 removes the network
    we used for the third container, and finally, line 3 removes the volume used by
    Postgres. After each test run, execute this file with `./cleanup.sh`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行移除`postgres`和`api`容器。第二行移除我们为第三个容器使用的网络，最后，第三行移除 Postgres 使用的卷。每次测试运行后，执行此文件，使用`./cleanup.sh`。
- en: Now you can start adding more code to your API component and more integration
    tests. Each time you want to test new or modified code, just run the `test.sh`
    script.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以开始向 API 组件添加更多的代码和集成测试了。每次你想要测试新的或修改过的代码时，只需运行`test.sh`脚本。
- en: 'Challenge: How can you optimize this process further, so that fewer manual
    steps are required?'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战：你如何进一步优化这个过程，以减少手动操作步骤？
- en: Use what we have learned in [Chapter 6](b6647803-2c5c-4b9d-9a4a-a836ac356329.xhtml),
    *Debugging Code Running in Containers*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们在[第 6 章](b6647803-2c5c-4b9d-9a4a-a836ac356329.xhtml)中学到的内容，*调试在容器中运行的代码*。
- en: The Testcontainers project
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Testcontainers 项目
- en: 'If you''re a Java developer, then there is a nice project called Testcontainers
    ([https://testcontainers.org](https://testcontainers.org)). In their own words,
    the project can be summarized as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是 Java 开发者，那么有一个很棒的项目叫做 Testcontainers（[https://testcontainers.org](https://testcontainers.org)）。用他们的话说，这个项目可以总结如下：
- en: '"Testcontainers is a Java library that supports JUnit tests, providing lightweight,
    throwaway instances of common databases, Selenium web browsers, or anything else
    that can run in  Docker container."'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '"Testcontainers 是一个 Java 库，支持 JUnit 测试，提供轻量级、可丢弃的常见数据库、Selenium 浏览器实例，或者任何可以在
    Docker 容器中运行的东西。"'
- en: 'To experiment with Testcontainer follow along:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要实验 Testcontainers，按照以下步骤进行：
- en: 'First create a `testcontainer-node` folder and navigate to it:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个`testcontainer-node`文件夹并进入：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Next open VS Code from within that folder with `code .`. Create three subfolders, `database`,
    `api`, and `tests`, within the same folder. To the `api` folder, add a `package.json` file with
    the following content:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在该文件夹中打开 VS Code，使用命令`code .`。在同一文件夹内创建三个子文件夹，`database`、`api`和`tests`。在`api`文件夹中，添加一个包含以下内容的`package.json`文件：
- en: '![](img/7eb83bfd-88b9-4891-9349-2098351469b2.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7eb83bfd-88b9-4891-9349-2098351469b2.png)'
- en: Content of package.json for the API
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: API的package.json内容
- en: 'Add a `server.js` file to the `api` folder with this content:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个`server.js`文件添加到`api`文件夹，并使用以下内容：
- en: '![](img/e1dd1426-e8cf-48fb-8cc7-f79f5b4f6c95.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e1dd1426-e8cf-48fb-8cc7-f79f5b4f6c95.png)'
- en: The sample API using the pg library to access Postgres
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用pg库访问Postgres的示例API
- en: Here, we create an Express JS application listening at port `3000`. The application
    uses the `pg` library, which is a client library for Postgres, to access our database.
    On lines `8` through `15`, we are defining a connection pool object that will
    allow us to connect to Postgres and retrieve or write data. On lines `21` through
    `24`, we're defining a `GET` method on the `/hobbies` endpoint, which returns
    the list of hobbies that are retrieved from the database via the SQL query, `SELECT
    hobby FROM hobbies`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个监听`3000`端口的Express JS应用。该应用使用`pg`库，这是一个用于Postgres的客户端库，用于访问我们的数据库。在第`8`到`15`行，我们定义了一个连接池对象，使我们能够连接到Postgres并检索或写入数据。在第`21`到`24`行，我们定义了一个`GET`方法，位于`/hobbies`端点，该方法返回通过SQL查询`SELECT
    hobby FROM hobbies`从数据库中检索的爱好列表。
- en: 'Now add a Dockerfile to the same folder with this content:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加一个Dockerfile到同一文件夹，并使用以下内容：
- en: '![](img/b63beff8-619f-435f-801c-7fe06c7a1333.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b63beff8-619f-435f-801c-7fe06c7a1333.png)'
- en: Dockerfile for the API
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: API的Dockerfile
- en: This is exactly the same definition as we used in the previous example. With
    this, the API is ready to be used. Let's now continue with the tests that will
    use the `testcontainer` library to simplify container-based testing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们在之前示例中使用的定义完全相同。通过这个，API已准备好使用。现在让我们继续进行测试，使用`testcontainer`库简化基于容器的测试。
- en: 'In your Terminal, navigate to the `tests` folder that we created earlier and
    use `npm init` to initialize it as a Node.js project. Accept all of the defaults.
    Next, use `npm` to install the `request` library and the `testcontainers` library:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，导航到我们之前创建的`tests`文件夹，并使用`npm init`将其初始化为一个Node.js项目。接受所有默认选项。接下来，使用`npm`安装`request`库和`testcontainers`库：
- en: '[PRE36]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The result of this is a `package.json` file that should look similar to this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是一个`package.json`文件，应该类似于以下内容：
- en: '![](img/d2880fcf-f231-45d2-878b-3b4b2289f79f.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2880fcf-f231-45d2-878b-3b4b2289f79f.png)'
- en: The package.json file for the tests project
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 测试项目的package.json文件
- en: 'Now, still in the `tests` folder, create a `tests.js` file and add the following
    code snippet:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，仍然在`tests`文件夹中，创建一个`tests.js`文件，并添加以下代码片段：
- en: '[PRE37]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Note how we're requesting a new object such as the `request` object, which will
    help us to access the RESTful interface of our sample API component. We are also
    requesting the `GenericContainer` object from the `testcontainers` library that
    will allow us to build and run any container.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们如何请求一个新对象，比如`request`对象，它将帮助我们访问我们示例API组件的RESTful接口。我们还请求了`testcontainers`库中的`GenericContainer`对象，它将允许我们构建和运行任何容器。
- en: We then define an async self-invoking function, which will be the wrapper for
    our setup and test code. It has to be an async function since, inside it, we will
    be awaiting other async functions, such as the various methods used from the `testcontainers`
    library.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个异步自调用函数，它将作为我们设置和测试代码的包装器。它必须是一个异步函数，因为在其中我们将等待其他异步函数，例如从`testcontainers`库使用的各种方法。
- en: 'As a very first step, we want to use the `testcontainers` library to create
    a Postgres container with the necessary seed data loaded. Let''s add this code
    snippet after `//TODO`:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为第一步，我们希望使用`testcontainers`库创建一个Postgres容器，并加载必要的种子数据。让我们在`//TODO`之后添加以下代码片段：
- en: '[PRE38]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding snippet has some similarities with a Docker `run` command. That
    is no accident since we are instructing the `testcontainers` library to do exactly
    that and run an instance of PostgreSQL for us.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段与Docker的`run`命令有些相似。这并非偶然，因为我们正在指示`testcontainers`库做 exactly 这件事，并为我们运行一个PostgreSQL实例。
- en: 'Next, we need to find out to which host port the exposed port `5432` is mapped.
    We can do that with the following logic:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要找出暴露的端口`5432`映射到哪个主机端口。我们可以通过以下逻辑来做到这一点：
- en: '[PRE39]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We will need this information since the API component will have to access Postgres
    via this port.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要这些信息，因为API组件必须通过这个端口访问Postgres。
- en: 'We also need to know which IP address the host is reachable from within a container—note,
    localhost won''t work from within a container since that would map to the loopback
    adapter of the container''s own network stack. We can get this host IP address
    like this:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要知道从容器内能够访问主机的IP地址——请注意，从容器内无法使用localhost，因为这会映射到容器自身网络栈的回环适配器。我们可以通过以下方式获取主机的IP地址：
- en: '[PRE40]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `lookupPromise` function is a wrapper function to make the normal async
    `dns.lookup` function return a promise so that we can `await` it. Here is its
    definition:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`lookupPromise`函数是一个包装函数，用来使普通的异步`dns.lookup`函数返回一个promise，以便我们可以使用`await`。以下是它的定义：'
- en: '[PRE41]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now, with this information, we are ready to instruct the `testcontainer` library
    to first build the container image for the API and then run a container from this
    image. Let''s start with the build:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，有了这些信息，我们准备好指示`testcontainer`库首先为API构建容器镜像，然后从该镜像运行一个容器。我们先从构建开始：
- en: '[PRE42]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note how this command uses the Dockerfile that we defined in the `api` subfolder.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这个命令使用了我们在`api`子文件夹中定义的Dockerfile。
- en: 'Once we have the `apiContainer` variable referencing the new image, we can
    use this to run a container from it:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了指向新镜像的`apiContainer`变量，我们就可以使用它来运行一个容器：
- en: '[PRE43]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Once again, we need to find out to which host port the exposed port `3000`
    of the API component has been mapped. The `testcontainer` library makes this a
    breeze:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次强调，我们需要找出API组件的暴露端口`3000`被映射到了哪个主机端口。`testcontainer`库使这变得非常简单：
- en: '[PRE44]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With this last line, we have finished the test setup code and can now finally
    start implementing some tests. We start by defining the base URL for the API component
    that we want to access. Then, we use the `request` library to make an HTTP GET
    request to the `/hobbies` endpoint:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这一行代码，我们已经完成了测试设置代码，现在终于可以开始实现一些测试了。我们首先定义了我们想要访问的API组件的基本URL。然后，我们使用`request`库发出HTTP
    GET请求到`/hobbies`端点：
- en: '[PRE45]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Let''s now implement some assertions right after the `//Test code here...` comment:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`//Test code here...`注释之后实现一些断言：
- en: '[PRE46]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'First, we log our expectation to the console as a feedback when running tests.
    Then, we assert that the returned status code is `200`, and, if not, we log an
    error. The `logError` helper function just writes the given message in red to
    the console, and prefixes it with `***ERR`. Here is the definition of this function:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在控制台上记录我们的预期结果，以便在运行测试时提供反馈。然后，我们断言返回的状态码是`200`，如果不是，我们就记录一个错误。`logError`辅助函数只是将给定的消息以红色写入控制台，并以`***ERR`为前缀。以下是这个函数的定义：
- en: '[PRE47]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Let''s add two more assertions:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加两个断言：
- en: '[PRE48]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: I leave it up to you, dear reader, to find out what these assertions do exactly.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我将这个任务交给你，亲爱的读者，去弄清楚这些断言到底做了什么。
- en: 'At the end of the assertions, we have to clean up so that we''re ready for
    a next run:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有断言结束时，我们需要清理，以便为下一次运行做准备：
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What we're doing is just stopping the API and the database container. This will
    automatically remove them from memory too.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们要做的就是停止API和数据库容器。这也会自动将它们从内存中移除。
- en: 'Now we can run this test suite using the following command from within the
    `tests` subfolder:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以通过以下命令在`tests`子文件夹中运行这个测试套件：
- en: '[PRE50]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'The output in my case looks like this (note, I have sprinkled a few `console.log`
    statements in the code to more easily follow along what exactly is happening at
    a give time):'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的情况下，输出如下所示（请注意，我在代码中添加了几个`console.log`语句，以便更容易地跟踪在特定时刻发生的事情）：
- en: '![](img/ba68b227-ae11-4625-9b29-b37915043c4f.png)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ba68b227-ae11-4625-9b29-b37915043c4f.png)'
- en: Running the testcontainer-based integration tests
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 运行基于testcontainer的集成测试
- en: The full code is given in the sample code repository that you cloned from GitHub.
    If you have problems running your tests, please compare your implementation to
    the given sample solution.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在你从GitHub克隆的示例代码仓库中找到。如果你在运行测试时遇到问题，请将你的实现与给定的示例解决方案进行比较。
- en: Now that we have a good understanding of how to use containers to run our integration
    tests, we'll move on to another very popular use case for container based automation,
    namely, building a Continuous Integration and Continuous Deployment or Delivery
    (CI/CD) pipeline.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经很好地理解了如何使用容器来运行集成测试，接下来我们将讨论另一个非常流行的基于容器的自动化用例，即构建一个持续集成和持续部署或交付（CI/CD）管道。
- en: Using Docker to power a CI/CD pipeline
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Docker驱动CI/CD管道
- en: 'The goal of this section is to build a CI/CD pipeline that looks like this:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是构建一个像这样的CI/CD管道：
- en: '![](img/6e8eff3d-22ee-4c18-9b2b-30f7745a3e91.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6e8eff3d-22ee-4c18-9b2b-30f7745a3e91.png)'
- en: A simple CI/CD pipeline using Jenkins
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jenkins构建一个简单的CI/CD管道
- en: We are going to use Jenkins ([https://jenkins.io](https://jenkins.io)) as our
    automation server. Other automation servers such as TeamCity ([https://www.jetbrains.com/teamcity](https://www.jetbrains.com/teamcity))
    work equally well. When using Jenkins, the central document is the `Jenkinsfile`,
    which will contain the definition of the pipeline with its multiple stages.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple `Jenkinsfile` with the `Build`, `Test`, `Deploy to Staging`, and `Deploy
    to Production` stages could look like this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Of course, the preceding pipeline just outputs a message during each stage
    and does nothing else. It is useful though as a starting point from which to build
    up our pipeline:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a project folder named `jenkins-pipeline` and navigate to it:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let''s run Jenkins in a Docker container. Use the following command to
    do so:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Note that we are running as the `root` user inside the container and that we
    are mounting the Docker socket into the container (`-v /var/run/docker.sock:/var/run/docker.sock`)
    so that Jenkins can access Docker from within the container. Data produced and
    used by Jenkins will be stored in the Docker volume, `jenkins-data`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
- en: 'We can find the initial admin password generated automatically by Jenkins with
    the following command:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In my case, this outputs `7f449293de5443a2bbcb0918c8558689`. Save this password
    as you will be using it in the next step.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: In your browser, navigate to `http://localhost:8080` to access the graphical
    UI of Jenkins.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlock Jenkins with the admin password that you retrieved with the previous
    command.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, choose Install suggested plugins to have Jenkins automatically install
    the most useful plugins. Plugins include the GitHub integration, an email extension,
    Maven and Gradle integration, and so on.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As soon as the plugins are installed, create your first admin account. When
    asked to restart Jenkins, do so.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have configured your Jenkins server, start by creating a new project;
    you may need to click **New Item** in the main menu:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f64e3315-eaf5-43c9-8ffc-d8fd63e0cd4e.png)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
- en: Add a new project in Jenkins
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: Give the project the name `sample-pipeline`, select the `Pipeline` type, and
    click OK.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the configuration view, select the Pipeline tab and add the pipeline definition
    from the preceding into the Script textbox:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b96d4516-0374-453f-b7a2-b419e6815a24.png)'
  id: totrans-242
  prefs: []
  type: TYPE_IMG
- en: Defining the pipeline in our Jenkins project called sample-pipeline
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: 'Click Save and then, in the main menu of Jenkins, select Build Now. After a
    short moment, you should see this:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/009185ff-8c65-4336-82f3-1fb4673adc22.png)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
- en: Running our sample pipeline in Jenkins
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have prepared Jenkins, we can start to integrate our sample application.
    Let''s start with the build step. First, we initialize the `jenkins-pipeline` project
    folder as a Git project:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add a `package.json` file to this folder with this content:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: There is nothing exceptional in this file other the usual list of external dependencies,
    `express` and `jasmine`, in this case. Also, note the two scripts `start` and
    `test` that we define for use with `npm`.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `hobbies.js` file to the project, which implements the logic to retrieve
    hobbies as a JavaScript module called `hobbies`:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This code evidently is simulating a database by serving pre-canned data stored
    in the `hobbies` array. We do this for simplicity.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: 'Next add a `server.js` file to the folder that defines a RESTful API with the
    three endpoints, `GET /`,  `GET /hobbies`, and `GET /hobbies/:id`. The code uses
    the logic defined in the `hobbies` module to retrieve data:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now we need to define some unit tests. Create a `spec` subfolder in the project
    and add the `hobbies-spec.js` file to it with the following code that tests the `hobbies` module:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The last step is to add a `support/jasmine.json` file to configure our test
    framework, Jasmine. Add the following code snippet:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: This is all the code that we need for the moment.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now start to build the CI/CD pipeline:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: 'Commit the code just created locally with the following command:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'To avoid all of the node modules being saved to GitHub, add a `.gitignore` file to
    the project `root` folder with the following content:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, we need to define a repository on GitHub. Log in to your account on GitHub
    at [https://github.com](https://github.com).
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a new repository there and call it `jenkins-pipeline`:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/5bd043cb-4a05-4e38-b286-30d4c48a7b40.png)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
- en: Create a new GitHub repository for the Jenkins pipeline sample application
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: Note that my GitHub account is `gnschenker`. In your case, it will be your own
    account.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'After you have clicked the green button, **Create repository**, go back to
    you project and execute the following two commands from within the project `root`
    folder:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Make sure you replace `gnschenker` in the first line with your own GitHub account
    name. After this step, your code will be available on GitHub for further use.
    One of the users will be Jenkins, which will pull the code from this repository
    as we will show shortly.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
- en: The next thing is to go back to Jenkins (`localhost:8080`) and modify the configuration
    of the project. Log in to Jenkins if needed and select your project, `sample-pipeline`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, select Configure in the main menu. Select the Pipeline tab and modify
    the settings so that they look similar to this:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/c975f0de-984a-4fc0-b092-e4e848fd34dd.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
- en: Configuring Jenkins to pull source from GitHub
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we configure Jenkins to pull code from GitHub and use a `Jenkinsfile`
    to define the pipeline. `Jenkinsfile` is expected to be found in the `root` of
    the project. Note that for the repository URL path, we need to give the relative
    path to the `/home` directory where our project is located. Remember that, when
    running the Jenkins container, we mapped our own home folder on the host to the
    `/home` folder inside the Jenkins container with this: `-v "$HOME":/home`.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: Hit the green Save button to accept the changes.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have defined that `Jenkinsfile` needs to be in the project `root` folder.
    This is the foundation of **Pipeline-as-Code**, since the pipeline definition
    file will be committed to the GitHub repository along with the rest of the code.
    Hence, add a file called `Jenkinsfile` to the `jenkins-pipeline` folder and add
    this code to it:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'OK, let''s dive into this file one part at a time. At the top, we''re defining
    two environment variables that will be available throughout every stage of the
    pipeline. We will be using those variables in the `Build & Push Docker image` stage:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The first variable, `registry`, just contains the full name of the container
    image we will eventually produce and push to Docker Hub. Replace `gnschenker`
    with your own GitHub username. The second variable, `DOCKER_PWD`, is a bit more
    interesting. It will contain the password to log in to my Docker Hub account.
    Of course, I don't want to have the value hardcoded here in code, hence, I use
    the credentials function of Jenkins that gives me access to a secret stored under
    the name `docker-login-pwd` in Jenkins.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the agent we want to use to run the Jenkins pipeline on. In
    our case, it is based on a Docker image. We are using the `gnschenker/node-docker` image for
    this purpose. This is an image based on `node:12.10-alpine`, which has Docker
    and `curl` installed, as we will need these two tools in some of the stages:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: With the `args` parameter, we are also mapping the Docker socket into the container
    so that we can use Docker from within the agent.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'Ignore the options part for the moment. We then are defining three stages:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The first stage, `Build`, just runs `npm install` to make sure all external
    dependencies of our app can be installed. If this were, for example, a Java application,
    we would probably also compile and package the application in this step.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
- en: In the second stage, `Test`, we run `npm test`, which runs our unit tests that
    we have defined for the sample API.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'The third stage, `Build & Push Docker image`, is a bit more interesting. Now
    that we have successfully built and tested our application, we can create a Docker
    image for it and push it to a registry. We are using Docker Hub as our registry,
    but any private or public registry would work. In this stage, we define four steps:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: We use Docker to build the image. We use the `$registry` environment variable
    we have defined in the first part of the Jenkinsfile. The `$BUILD_NUMBER` variable is
    defined by Jenkins itself.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Before we can push something to the registry, we need to log in. Here, I am
    using the `$DOCKER_PWD` variable that I defined earlier on.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we're successfully logged in to the registry, we can push the image.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the image is now in the registry, we can delete it from the local cache
    to avoid wasting space.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Remember that all of the stages run inside our `gnschenker/node-docker` builder
    container. Hence, we're running Docker inside Docker. But, since we have mapped
    the Docker socket into the builder, the Docker commands act on the host.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add two more stages to the pipeline. The first one looks like this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Add it just after the `Build & Push Docker image` stage. This stage just executes
    a `deploy.sh` script located in the `jenkins/scripts` subfolder. We do not yet
    have such a file in our project.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, add this file to your project with the following content:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: OK, so this code does the following. First, it tries to remove any artifacts
    that might have been left over from an earlier, failed run of the pipeline. Then,
    it creates a Docker network called `test-net`. Next, it runs a container from
    the image we built in the previous step. This container is our Express JS API
    and is called `api` accordingly.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: This container and the application within it may take a moment to be ready.
    Hence, we define some logic that uses the `netcat` or `nc` tool to probe port
    `3000`. Once the application is listening at port `3000`, we continue with the
    smoke test. In our case, the smoke test is just making sure it can access the
    `/` endpoint of our API. We are using `curl` for this task. In a more realistic
    setup, you would run some more sophisticated tests here.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'As a last stage, we are adding a `Cleanup` step:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following snippet as a last stage to your `Jenkinsfile`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Once again, this `Cleanup` stage uses a script located in the `jenkins/script` subfolder.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: 'Please add such a file to your project with the following content:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: This script removes the `api` container and the Docker network, `test-net`,
    that we used to run our containers on.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to roll. Use `git` to commit your changes and push them to
    your repository:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Once the code is pushed to GitHub, go back to Jenkins.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: 'Select your `sample-pipeline` project and click Build now in the main menu.
    Jenkins will start to build the pipeline. If everything goes well, you should
    see something like this:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/09e00d85-9229-40a2-bad3-1fbf4e92e1bc.png)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
- en: Running our full code-based pipeline in Jenkins
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: Our pipeline is executed successfully and now has six steps. The checkout from
    GitHub has been automatically added as a first enabling step. To access the logs
    generated during the pipeline execution, you can click the little ball icon on
    the left side of the run under Build History. In the preceding screenshot, it
    is the bluish icon on the left of **#26**. This is especially helpful if the pipeline
    step fails to quickly find the root cause of the failure.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: To summarize, we have built a simple CI/CD pipeline where everything, including
    the automation server, Jenkins, is running in containers. We have only scratched
    the surface of what is possible.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to use Docker containers to optimize various
    kinds of automation tasks, from running a simple one-off task to building up a
    containerized CI/CD pipeline.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce advanced tips, tricks, and concepts useful
    when containerizing complex distributed applications or when using Docker to automate
    sophisticated tasks.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-324
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Name a few pros and cons for running a one-off task in a container instead of
    directly on the host machine.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: List two or three advantages of running tests in containers.
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sketch a high-level diagram of a containerized CI/CD pipeline, starting from
    the user producing code till the code being deployed into production.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Write Maintainable Integration Tests with Docker at [https://www.docker.com/blog/maintainable-integration-tests-with-docker/](https://www.docker.com/blog/maintainable-integration-tests-with-docker/)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Docker Workflow for .NET Developer - Part 2 (Integration Tests) at [https://gabrielschenker.com/index.php/2019/10/09/a-docker-workflow-for-net-developers-part-2/](https://gabrielschenker.com/index.php/2019/10/09/a-docker-workflow-for-net-developers-part-2/)
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins on Docker Hub at [https://hub.docker.com/_/jenkins/](https://hub.docker.com/_/jenkins/)
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins Tutorial Overview at [https://jenkins.io/doc/tutorials/](https://jenkins.io/doc/tutorials/)
  id: totrans-332
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
