<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Behind the Scenes – Basis of Git Basics</h1></div></div></div><p>
<em>Those who had an awestruck expression on their face after experiencing the awesomeness of Git would probably be wondering about the mechanisms behind the magic.</em>
</p><p>This chapter is dedicated to users who are serious about getting to know the intricacies of the following operations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">init</li><li class="listitem" style="list-style-type: disc">add</li><li class="listitem" style="list-style-type: disc">commit</li><li class="listitem" style="list-style-type: disc">status</li><li class="listitem" style="list-style-type: disc">clone</li><li class="listitem" style="list-style-type: disc">fetch</li><li class="listitem" style="list-style-type: disc">merge</li><li class="listitem" style="list-style-type: disc">remote</li><li class="listitem" style="list-style-type: disc">pull</li><li class="listitem" style="list-style-type: disc">push</li><li class="listitem" style="list-style-type: disc">tag</li><li class="listitem" style="list-style-type: disc">branch</li><li class="listitem" style="list-style-type: disc">checkout</li></ul></div><p>We begin by understanding the composition of a Git repository, followed by an analysis of the ways in which Git intelligently manages content, and finally take an overview of ways through which Git sees the relation between relations in order to store and transfer content.</p><div><div><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Two sides of Git: plumbing and porcelain</h1></div></div></div><p>Irrespective of the number of features highlighted in the sales brochure for your swanky new car, it has to have a user friendly interface through which you can really appreciate and enjoy the finer things it has to offer. Though the core work is done inside, the interface outside serves as an enabler.</p><p>Similarly Git works on both the inner and outer levels with the following commands:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Plumbing commands</strong>: These <a id="id501" class="indexterm"/> commands take care of the low level <a id="id502" class="indexterm"/> operations, which form the fundamental base on which Git is built</li><li class="listitem" style="list-style-type: disc"><strong>Porcelain commands</strong>: These <a id="id503" class="indexterm"/> are the ones that cover the <a id="id504" class="indexterm"/> underlying plumbing operations at a high level with easy and appealing names for end users</li></ul></div><p>The commands that we have learned in earlier chapters are of the porcelain type. Let's look behind the scenes for each one of them.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec83"/>Git init</h1></div></div></div><p>What you know is that this <a id="id505" class="indexterm"/> command creates a new subdirectory named <code class="literal">.git</code>, which is the source of versioning. Let's move one step further and explore the contents of the <a id="id506" class="indexterm"/> <code class="literal">.git</code> directory, which should have a directory structure as shown in the following screenshot:</p><div><img src="img/7522_08_01.jpg" alt="Git init"/></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec81"/>Hooks</h2></div></div></div><p>Hooks are <a id="id507" class="indexterm"/> customization scripts <a id="id508" class="indexterm"/> that can be injected into various Git commands and its operations. It is possible to write our own hook and such a hook has to go into this directory.</p><p>There are a bunch of sample hooks automatically created inside this directory as part of <code class="literal">git init</code> but not activated until we manually rename <code class="literal">hook_name.sample</code> to <code class="literal">hook_name</code>. To learn more about the various hooks present in the directory open up the help document by typing <code class="literal">git help hooks</code> in your command line.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec82"/>Info</h2></div></div></div><p>Additional <a id="id509" class="indexterm"/> information about the <a id="id510" class="indexterm"/> repository is recorded in this directory. Presently the only file inside would be the one called <code class="literal">exclude</code>. This file serves as a master list of the files to be excluded from being tracked by Git.</p><p>Sounds familiar, doesn't it? Indeed, the <code class="literal">.gitignore</code> file performs <a id="id511" class="indexterm"/> the same operation except for the fact that any exclusion pattern written in the exclude file is reflected only in the local repository and not in any subsequent clones; whereas when written on <code class="literal">.gitignore</code>, it becomes a part of your history, which can be subjected to other Git functions such as add, commit, merge, clone, pull, push, and others.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec83"/>Config</h2></div></div></div><p>The name <a id="id512" class="indexterm"/> conveys it all; this <a id="id513" class="indexterm"/> text file is our project/repository-specific configuration file. We would have covered the finer workings of this file in earlier chapters, but the content we'd need to cover would go beyond the scope of this book.</p><p>This is where Git maintains the entries for a remote section to or from wherever the repository is cloned or data is exchanged. It also contains some core settings such as whether the repository is a bare repository or not.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec84"/>Description</h2></div></div></div><p>There is a package <a id="id514" class="indexterm"/> called <a id="id515" class="indexterm"/> gitweb, which comes with your Git installation and will allow us to <a id="id516" class="indexterm"/> set up a web interface for our Git repositories. This means that the repository can be browsed using any web browser.</p><p>This description file contains a user-defined description of the repository, which is used by the gitweb program to <a id="id517" class="indexterm"/> display it to <a id="id518" class="indexterm"/> the clients who are requesting a listing of repositories.</p></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Objects</h2></div></div></div><p>As you have understood correctly, like any other VCS repository, a Git repository <a id="id519" class="indexterm"/> is nothing <a id="id520" class="indexterm"/> but a database containing all the data that is needed to retain, reproduce, and manage the revisions and history of your files, but the <a id="id521" class="indexterm"/> way Git handles these operations is what makes it stand apart from others.</p><p>And this is possible because of the way Git considers everything that goes into it as objects. There are four types of objects namely blobs, trees, commits, and tags with which it pulls such a trick.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec12"/>Blob</h3></div></div></div><p>I'm sure that you're familiar <a id="id522" class="indexterm"/> with the building blocks game; we've all played it at some point in our lives. When you think about it, you will recollect that irrespective of the type of structure you build, it's basically made up of several independent blocks put together. And when you are done with playing or want to preserve the incomplete structure to continue later on, we put it in a cover or a box and store it safely.</p><p>Similarly when it comes to handling data on a computer, irrespective of whether it's an image, or an audio or video clip, or a PDF document, it's basically constructed from several bits of binary data. A <strong>binary large object</strong> (<strong>blob</strong>) <a id="id523" class="indexterm"/> is nothing but a collection of binary data stored inside a box/cover as a single entity for later use.</p><p>Here, blobs store any type of data irrespective of their structure. They concentrate on the content alone and not on the metadata of that content – not even the location of the file or its name.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec13"/>Trees</h3></div></div></div><p>Tree objects <a id="id524" class="indexterm"/> are Git's internal <a id="id525" class="indexterm"/> representation of directories and the structure of your content. They're similar to a directory in your file system, which refers to files and/or other directories. Here, Git tree objects can refer to Git blobs and/or other Git tree objects.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec14"/>Commits</h3></div></div></div><p>The commit object <a id="id526" class="indexterm"/> holds all the metadata for changes introduced to the <a id="id527" class="indexterm"/> repository's content. Metadata includes the author for the change, the committer of the change (yes, it's possible to have two different people) along with their e-mail addresses, the date, and the time.</p></div><div><div><div><div><h3 class="title"><a id="ch08lvl3sec15"/>Tags</h3></div></div></div><p>The tag <a id="id528" class="indexterm"/> object <a id="id529" class="indexterm"/> carries a human readable name, which can be attached to other objects, usually a commit object for easy retrieval and other reasons that we saw under the tagging topic in previous chapters.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec86"/>HEAD</h2></div></div></div><p>HEAD is like a <a id="id530" class="indexterm"/> pointer which <a id="id531" class="indexterm"/> points the Git engine to the active branch (the branch we are currently working on) for further operations. When opened using a text editor, you will see the following if you are in the master branch:</p><div><pre class="programlisting">ref: refs/heads/master</pre></div><p>And you will see the following if you are presently working on the <code class="literal">test_release</code> branch, and so on and so forth:</p><div><pre class="programlisting">ref: refs/heads/test_release</pre></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec87"/>Refs</h2></div></div></div><p>If you have ever wondered <a id="id532" class="indexterm"/> 
 <a id="id533" class="indexterm"/> how reaching <a class="ulink" href="http://google.com">google.com</a> and <a class="ulink" href="http://173.194.35.39">173.194.35.39</a> from your browser both give you the same Google search page, you will realize that there should be a reference somewhere that maps these two. Another simple example: bring your attendance register where everybody's name is mapped to a unique employee/student ID, which can be used to identify one person amongst several others with the same name and vice versa.</p><p>Similarly the <code class="literal">refs</code> directory serves the purpose of referencing for Git on a few operations. It stores the SHA-1 IDs of important points in the repository, such as tags and branches. Metadata for the tags is stored inside another directory situated at <code class="literal">refs/tags</code> and metadata for branches is stored inside a different directory situated at <code class="literal">refs/heads</code>.</p><p>Each branch name is a file inside the <code class="literal">heads</code> directory, and the content of such files contains the SHA-1 ID <a id="id534" class="indexterm"/> of the commit from where that particular branch was created (the parent in Git terms). The same is the case for tags as well – each tag name is a file <a id="id535" class="indexterm"/> 
 <a id="id536" class="indexterm"/> inside the <code class="literal">tags</code> directory, which has a single SHA-1 ID for its reference.</p><div><div><div><div><h3 class="title"><a id="ch08lvl3sec16"/>Bumper alert – directories inside heads and tags</h3></div></div></div><p>We have spoken about files inside both the <code class="literal">tags</code> and <code class="literal">heads</code> directory, which represent the tag and branch names that you have created in the repository. Don't get puzzled if you happen to see one or more directory structures inside the <code class="literal">heads</code> and <code class="literal">tags</code> directory.</p><p>This is simply a representation of the hierarchically structured name that one would have given for the branch or tag. Things will get much clearer after looking at the following example, which focuses on the branching concept, which is also applicable for tags.</p><p>Create a branch with the name <code class="literal">mybranch</code> (<code class="literal">git branch mybranch</code>). This will create a file called <code class="literal">mybranch</code> located at <code class="literal">heads/mybranch</code>, whereas creating a branch with an hierarchical name like <code class="literal">kamia/kashin</code> (<code class="literal">git branch kamia/kashin</code>) will create a file called <code class="literal">kashin</code> located at <code class="literal">heads/kamia/kashin</code>.</p><p>So far, we have explored the important segments of a freshly initiated (new) Git repository that has no commits as yet. However there is one more key player called index, which gets created as soon as you add content to your repository.</p></div></div><div><div><div><div><h2 class="title"><a id="ch08lvl2sec88"/>Index</h2></div></div></div><p>The index file <a id="id537" class="indexterm"/> is where Git <a id="id538" class="indexterm"/> stores your staging area information to be committed. To put it simply, the content of the index file becomes your next commit. In other words this is the place where you keep your files that you want to be committed to your repository.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec84"/>Git – a content tracking system</h1></div></div></div><p>It's important for us to understand how <a id="id539" class="indexterm"/> Git perceives data; it is not through the filename or the file's location in the directory structure; rather, it emphasizes the file's content. This means that when two or more files, irrespective of where they are located inside the repository, have the same content, Git sees the relation between them through their hashes.</p><div><div><h3 class="title"><a id="note30"/>Note</h3><p>Computing the hash is the first task for Git before storing any data permanently. The hash value for a given content is unique across the globe. This means that the hash value for a file containing "Hello world" in your computer is the same as mine or anyone else's.</p></div></div><p>Finding out the similarities, Git puts the content under one single blob object and stores it. Note that only one copy of the content is stored in the background thus minimizing hardware usage and when asked to reproduce, it can bring out the exact storage pattern with the usage of its metadata stored with tree objects.</p><p>This hash computing happens whenever required, at various stages, thereby even a small change in one of those files will deliver a new hash, which makes Git store it separately. Since these processes revolve (with major emphasis) around the content irrespective of the file's name or location, Git <a id="id540" class="indexterm"/> is often called a <a id="id541" class="indexterm"/> content tracking system.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec85"/>Git add</h1></div></div></div><p>When <code class="literal">add</code> is <a id="id542" class="indexterm"/> executed, Git updates the index using the current content found in the working tree (staging your changes), and prepares the content staged for the next commit, which involves the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Computing the hash for the content.</li><li class="listitem">Deciding whether to create new content, or link to an existing blob object.</li><li class="listitem">Actual creation or linking of blob takes place.</li><li class="listitem">Creation of a tree object to track location of the content.</li></ol></div><p>At this point the index is said to hold a snapshot of the content in the working tree for the next commit.</p><p>As you already know, this command can be performed multiple times before a commit. It only adds the content of the specified file(s) at the time the <code class="literal">add</code> command is run; if you want subsequent changes included in the next commit, you must run <code class="literal">git add</code> again to add the new content to the index.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>More importance is to be given to the process where both the blob and tree objects get created and linked with their respective hash IDs, as shown in the following figure.</p></div></div><div><img src="img/7522_08_02.jpg" alt="Git add"/></div><p>As discussed earlier, a <a id="id543" class="indexterm"/> tree can not only point to a blob but also to another tree forming a hierarchical network, as shown in the following figure:</p><div><img src="img/7522_08_03.jpg" alt="Git add"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec86"/>Git commit</h1></div></div></div><p>When the <a id="id544" class="indexterm"/> <code class="literal">commit</code> command is executed, a commit object gets created with the metadata of the content/changes that were added earlier using the <a id="id545" class="indexterm"/> <code class="literal">git add</code> command. The metadata includes the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Name of the person who authored the change and the relevant date and time along with the time zone settings</li><li class="listitem" style="list-style-type: disc">Name of the person who committed the change and the relevant date and time along with the time zone settings</li></ul></div><p>Then the created commit object gets linked to the tree object, which has already linked with the blob thus completing the versioning process as shown in the following figure:</p><div><img src="img/7522_08_04.jpg" alt="Git commit"/></div><p>Note that the <a id="id546" class="indexterm"/> head contains the branch name and not the SHA-1 ID of the commit that it is pointing to. This is because it becomes tough to identify a branch with its commit IDs when the volume and position of commits inside a branch keep changing, hence the statement "branch moves".</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>Do not worry about the blob and tree objects, which are created as a part of the <code class="literal">add</code> operation when not committed; these are destroyed as part of the garbage collection process after a few months.</p></div></div><p>Now if you do a <code class="literal">git status</code> you will see that the changes you staged are not in the staged <a id="id547" class="indexterm"/> changes state any longer.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec87"/>Git status</h1></div></div></div><p>When the <code class="literal">status</code> command <a id="id548" class="indexterm"/> is executed, Git checks for the file's path and size. If there are no differences, it leaves it as it is, but if any differences are found, it goes ahead and computes the hash with which it checks for a relation to other hashes, as we saw earlier.</p><p>The file path comparison as such happens in the following stages:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Stage number</p>
</th><th style="text-align: left" valign="bottom">
<p>Comparison</p>
</th><th style="text-align: left" valign="bottom">
<p>Related status message</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>1</p>
</td><td style="text-align: left" valign="top">
<p>File path present in index versus recent commit (HEAD commit)</p>
</td><td style="text-align: left" valign="top">
<p>Changes to be committed</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>2</p>
</td><td style="text-align: left" valign="top">
<p>File path present in index versus working tree</p>
</td><td style="text-align: left" valign="top">
<p>Changes not staged for commit</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>3</p>
</td><td style="text-align: left" valign="top">
<p>Paths in the working tree that are not tracked by Git (and are not ignored by <code class="literal">gitignore</code> or the exclude file)</p>
</td><td style="text-align: left" valign="top">
<p>Changes not staged for commit</p>
</td></tr></tbody></table></div><p>The first status denotes changes that have already been added (staged) but not committed. So executing <code class="literal">git commit</code> would <a id="id549" class="indexterm"/> complete the versioning process.</p><p>The second and third statuses denote that the changes are not yet added (staged) for a commit. So to complete the versioning process, we need to add them first using <code class="literal">git add</code> and then <code class="literal">git commit</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec88"/>Git clone</h1></div></div></div><p>When the <a id="id550" class="indexterm"/> <code class="literal">clone</code> command is executed, the internal process order would be as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the destination directory if it does not <a id="id551" class="indexterm"/> exist and execute <code class="literal">git init</code> on it.</li><li class="listitem">Set up remote tracking branches in the destination repository for each branch present in the source repository (<code class="literal">git remote</code>).</li><li class="listitem">Fetch the objects, refs (inside the <code class="literal">.git</code> directory).</li><li class="listitem">Finally do a checkout.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec89"/>Git remote</h1></div></div></div><p>When the <a id="id552" class="indexterm"/> <code class="literal">remote</code> command is executed, Git lists down all the remotes added to the repository by reading it from the remote section of the local config file located at <code class="literal">.git/config</code>. An example of the content inside the config file is as follows:</p><div><pre class="programlisting">[remote "capsource"]
url = https://github.com/cappuccino/cappuccino
fetch = +refs/heads/*:refs/remotes/capsource/*</pre></div><p>The name <code class="literal">capsource</code> was the alias we gave preceding the URL while adding a new remote to the repository. Under this section two reference parameters are captured:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Reference parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">url</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is the URL of the remote repository that you want to track, share, and get content from, within your repository.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Fetch</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is to convey to Git the refs (branches and tags) from the remote that are to be tracked.</p>
<p>By default, it tracks all refs from the remote repository specified by <code class="literal">refs/heads/*</code>. These are placed under your local repository's directory <code class="literal">capsource</code> located at <code class="literal">refs/remotes/capsource/*</code>.</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec90"/>Git branch</h1></div></div></div><p>When the <a id="id553" class="indexterm"/> <code class="literal">branch</code> command is executed, it performs the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Collects all branch names from <code class="literal">.git/refs/heads/</code>.</li><li class="listitem">Finds the active/current working branch with the help of the entry in the HEAD located at <code class="literal">.git/HEAD</code>.</li><li class="listitem">Displays all the branches in ascending order with an asterisk (*) mark next to the active branch.</li></ol></div><p>Note that the branches listed this way are only local branches of your repository. When you want all branches listed inclusive of remote tracking branches, which are stored inside <code class="literal">.git/refs/remotes/</code>, you will use <code class="literal">git branch –a</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec91"/>Git tag</h1></div></div></div><p>When the <code class="literal">tag</code> command <a id="id554" class="indexterm"/> is executed, Git performs the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Gets the SHA-1 ID of the referred commit.</li><li class="listitem">Validates the given tag name with the existing tag names.</li><li class="listitem">If it's a new name, it validates the name with the naming conventions.</li><li class="listitem">If the name abides by the rules, a tag object gets created with the given name mapped to the acquired SHA-1 ID, which is found inside <code class="literal">.git/refs/tags/</code>.</li></ol></div><p>The following figure shows the association of the tag object along with other objects:</p><div><img src="img/7522_08_05.jpg" alt="Git tag"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec92"/>Git fetch</h1></div></div></div><p>When <code class="literal">fetch</code> is <a id="id555" class="indexterm"/> executed, Git performs the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Checks for the URL or remote name, which points to a valid Git repository specified in the command <code class="literal">git fetch remote_name</code> (or) <code class="literal">url</code>.</li><li class="listitem">If none is specified, it reads the config file to see if there is any default remote.</li><li class="listitem">If found, it fetches the named refs (heads and tags) from the remote repository along with their associated objects.</li><li class="listitem">The retrieved ref names are stored in <code class="literal">.git/FETCH_HEAD</code> to aid a possible merge operation in the future.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec93"/>Git merge</h1></div></div></div><p>While executing the <a id="id556" class="indexterm"/> <code class="literal">merge</code> command, Git will perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify both the merge candidates from the <code class="literal">heads</code> directory based on specified parameters.</li><li class="listitem">Find the common ancestor of both heads and load all their objects in memory.</li><li class="listitem">Perform a diff (difference) between the common ancestor and head one.</li><li class="listitem">Apply the diff with head two.</li><li class="listitem">If there are changes in common areas across heads, indicate the conflict with markers and inform the user about it (expecting the user to solve the conflict, add the changes, and make a commit).</li><li class="listitem">If there are no conflicts, merge those contents, and make a merge commit mentioning metadata stating this.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec94"/>Git pull</h1></div></div></div><p>On executing <a id="id557" class="indexterm"/> the <code class="literal">pull</code> command, Git internally performs the following operations:</p><div><ol class="orderedlist arabic"><li class="listitem"><code class="literal">Git fetch</code> with the <a id="id558" class="indexterm"/> given parameters.</li><li class="listitem">Calls <code class="literal">git merge</code> to <a id="id559" class="indexterm"/> merge the retrieved branch head into the current branch.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec95"/>Git push</h1></div></div></div><p>On executing the <a id="id560" class="indexterm"/> <code class="literal">push</code> command, Git will perform the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify current branch.</li><li class="listitem">Look up the existence of a default remote in the config file (if none is found, it prompts you to provide the remote name or URL as a parameter while executing <code class="literal">git push</code>).</li><li class="listitem">Get to know the remote's URL and the heads (branches) tracked.</li><li class="listitem">Check whether the remote has changed since the last time you fetched changes from it.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get the list of references from the remote repositories (using <code class="literal">git ls-remote</code>).</li><li class="listitem" style="list-style-type: disc">Check the existence of the entries from the list with the local history. If the reference from the remote is a part of the local repository's history, it's evident that there are no other changes since the last time you fetched/pulled from the remote. So Git will allow you to directly push your changes to the remote. If it's not a part of your local repository's history, Git understands that the remote repository has undergone some changes since the last time you fetched/pulled from it. So it will ask you to first do a <code class="literal">git fetch</code> or <code class="literal">git pull</code> before pushing.</li></ul></div></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec96"/>Git checkout</h1></div></div></div><p>When <code class="literal">checkout</code> is <a id="id561" class="indexterm"/> executed without any parameters, Git performs the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Fetches the named paths in the working tree.</li><li class="listitem">Fetches the related objects from the index.</li><li class="listitem">Updates the contents of the working tree with the ones from the index.</li></ol></div><p>However the behavior changes according to the parameters used.</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Parameter</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">-b</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is used to spawn a new branch from the checked out position mentioned with the commit ID.</p>
<p>
<code class="literal">git checkout –b &lt;your_branch_name&gt;</code> is a short form of <code class="literal">git checkout branch</code> followed <code class="literal">by git checkout &lt;branch_name&gt;</code>.</p>
<p>This command creates a new reference inside <code class="literal">.git/refs/heads/</code> with that particular commit ID.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">--track</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This parameter is used to set up the upstream configuration usually while creating a new branch with the <code class="literal">–b</code> parameter.</p>
<p>When executed, a separate section is added to the <code class="literal">.config</code> file inside the <code class="literal">.git</code> directory as follows:</p>
<div><pre class="programlisting">[branch "master"]
        remote = origin
        merge = refs/heads/master</pre></div><p>
</p>
<p>This <a id="id562" class="indexterm"/> happens when a command like <code class="literal">git checkout --track -b master origin/master</code> is executed.</p>
</td></tr></tbody></table></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec97"/>Relation across relations – Git packfiles</h1></div></div></div><p>We saw how Git sees the <a id="id563" class="indexterm"/> 
 <a id="id564" class="indexterm"/> relation across files through its content and intelligently chooses between whether to create a new blob for the content or have an existing blob referenced to it. We also understood that even a small change in content will cause Git to store a separate blob because the SHA-1 ID will change.</p><p>Think about a situation where you have two text files, 5 MB each, with the same content but in different locations. Git will accordingly create a single blob as the same content will result in the same SHA-1 ID, thus saving space.</p><p>Now, append a line to the content of one of the files. Git will now create a new blob (5+ MB in size) for the second file, which has changed. Observing this behavior of having two nearly identical blobs of 5 MB, a few questions might arise.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why does Git create a new blob for the entire content?</li><li class="listitem" style="list-style-type: disc">Why not still have the same old blob shared between both files, and additionally create a new blob for the difference brought into the second file alone, thus reducing storage and being more efficient?</li></ul></div><p>Well, these are <a id="id565" class="indexterm"/> 
 <a id="id566" class="indexterm"/> good questions; Git has an answer that addresses those with something called <strong>packfiles</strong>. The objects created as mentioned in the scenario we just discussed are called loose objects, and automatically but occasionally Git packs up several of these loose objects into a single binary called a packfile.</p><div><div><div><div><h2 class="title"><a id="ch08lvl2sec89"/>Transferring packfiles</h2></div></div></div><p>Git not only supports <a id="id567" class="indexterm"/> the transferring of refs and their associated plain blob, tree, commit, and tag objects but also packfiles on operations such as clone, fetch, push, and pull. Talking on a higher level, Git has two sets of protocols for transferring data between remotes.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">One for pushing data from the client to the server</li><li class="listitem" style="list-style-type: disc">Another for fetching data from the server to the client<div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Implemented side</p>
</th><th style="text-align: left" valign="bottom">
<p>Process invoked</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Server side</p>
</td><td style="text-align: left" valign="top">
<p>Upload-pack</p>
</td><td style="text-align: left" valign="top">
<p>Invoked by <code class="literal">git fetch-pack</code>, it learns what objects the other side is missing, and sends them after packing.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Client side</p>
</td><td style="text-align: left" valign="top">
<p>Fetch-pack</p>
</td><td style="text-align: left" valign="top">
<p>This is responsible for receiving missing packages from another repository.</p>
<p>This command is usually not called directly by the end user, instead <code class="literal">git fetch</code>, which is a higher level wrapper of this command, is executed.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Server side</p>
</td><td style="text-align: left" valign="top">
<p>Receive-pack</p>
</td><td style="text-align: left" valign="top">
<p>Invoked by <code class="literal">git send-pack</code>, this receives what is pushed into the repository.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Client side</p>
</td><td style="text-align: left" valign="top">
<p>Send-pack</p>
</td><td style="text-align: left" valign="top">
<p>This is responsible for pushing objects over Git protocol to another repository.</p>
<p>This command is usually not called directly by the end user, instead <code class="literal">git push</code>, which is a higher level wrapper of this command, is executed.</p>
</td></tr></tbody></table></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec98"/>Summary</h1></div></div></div><p>We have learned about the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The structure of a Git repository and the role each one of them plays in the versioning process</li><li class="listitem" style="list-style-type: disc">The different objects and how Git smartly manages the content using those objects</li></ul></div><p>Additionally, we have also learned in detail about the internals of commands such as <code class="literal">init</code>, <code class="literal">add</code>, <code class="literal">commit</code>, <code class="literal">status</code>, <code class="literal">clone</code>, <code class="literal">fetch</code>, <code class="literal">merge</code>, <code class="literal">remote</code>, <code class="literal">pull</code>, <code class="literal">push</code>, <code class="literal">tag</code>, <code class="literal">branch</code>, and <code class="literal">checkout</code>, which we have used in earlier chapters to master the versioning concept.</p><p>Not only that, we also viewed at a high level about how Git not only understands relations between files based on their complete content but also partial content in the form of packfiles.</p></div></body></html>