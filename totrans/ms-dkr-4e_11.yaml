- en: '*Chapter 11*'
  prefs: []
  type: TYPE_NORMAL
- en: Docker and Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be taking a look at Kubernetes. Like Docker Swarm,
    you can use Kubernetes to create and manage clusters that run your container-based
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be discussing the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Kubernetes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling Kubernetes in Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Kubernetes and Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kubernetes and other Docker tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes within Docker only supports by Docker for Mac and Docker for Windows
    desktop clients. If you are running Linux then in the next chapter, [*Chapter
    12*](B15659_12_Final_JM_ePub.xhtml#_idTextAnchor394)*, Discovering more Kubernetes
    options*, we are going to be looking at some options that will be |relevant to
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Like previous chapters, I will be using my preferred operating system, which
    is macOS. As before, some of the supporting commands, which will be few and far
    between, may only apply to macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3m1WRiw](https://bit.ly/3m1WRiw)'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Kubernetes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have been thinking about looking at containers, then you would have come
    across Kubernetes at some point on your travels, so before we enable it within
    our Docker desktop installation, let's take a moment to look at how Kubernetes
    started life.
  prefs: []
  type: TYPE_NORMAL
- en: '**Kubernetes**, pronounced **koo-ber-net-eez**, originates from the Greek name
    given to a helmsman or captain of a ship.'
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: The method of shortening the name adopted by the Kubernetes team is called a
    numeronym and was devised in the 80s, and is still used today. See [https://en.wikipedia.org/wiki/Numeronym](https://en.wikipedia.org/wiki/Numeronym)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes, which is also known as **K8s** – the number 8 in the K8s shorthand
    represents the number of letters between the K and S, the 'ubernete' part – is
    an open source project that originated at Google and allows you to automate the
    deployment, management, and scaling of your containerized applications.
  prefs: []
  type: TYPE_NORMAL
- en: A brief history of containers at Google
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Google has been working on Linux container-based solutions for quite a long
    time. It took its first steps in 2006 by working on the Linux kernel feature called
    **Control Groups**(**cgroups**). This feature was merged into the Linux kernel
    in 2008 within release 2.6.24\.
  prefs: []
  type: TYPE_NORMAL
- en: The feature allows you to isolate resources, such as CPU, RAM, networking, and
    disk I/O, or one or more processes. Control Groups remains a core requirement
    for Linux containers and is not only used by Docker but also other container tools.
  prefs: []
  type: TYPE_NORMAL
- en: Google next dipped their toes into the container waters with a container stack
    called **lmctfy**, which stands for **Let Me Contain That For You** and was an
    alternative to the **LXC** collection of tools and libraries. It was an open sourced
    version of Google's internal toolset, which they used to manage containers in
    their applications.
  prefs: []
  type: TYPE_NORMAL
- en: The next time Google hit the news about their container usage was following
    a talk given by *Joe Beda* at *Gluecon* in May 2014\. During the presentation,
    Beda revealed that pretty much everything within Google was container-based and
    that they were launching around 2 billion containers a week. It was stated that
    this number did not include any long-running containers, meaning that the containers
    were only active for a short amount of time. However, after some quick math, on
    average Google was launching around 3,000 containers per second!
  prefs: []
  type: TYPE_NORMAL
- en: Later in the talk, Beda mentioned that Google was using a scheduler, so they
    didn't have to manually manage 2 billion containers a week or even worry about
    where they were launched and, to a lesser extent, each container's availability.
  prefs: []
  type: TYPE_NORMAL
- en: Google also published a paper called *Large-scale cluster management at Google
    with Borg*. This paper not only let people outside of Google know the name of
    the scheduler they were using, **Borg**, but it also went into great detail about
    the design decisions they made when designing the scheduler.
  prefs: []
  type: TYPE_NORMAL
- en: The paper mentioned that as well as their internal tools, Google was running
    its customer-facing applications, such as Google Docs, Google Mail, and Google
    Search, in containers running clusters, which are managed by Borg.
  prefs: []
  type: TYPE_NORMAL
- en: '**Borg** was named after the alien race, the Borg, from the Star Trek: The
    Next Generation TV show. In the TV show, the Borg are a race of cybernetic beings
    whose civilization is founded on a hive mind known as the collective. This gives
    them not only the ability to share the same thoughts but also, through a sub-space
    network, ensure that each member of the collective is given guidance and supervision
    from the collective consciousness. I am sure you will agree, the characteristics
    of the Borg race matches that closely how you would want your cluster of containers
    to run.'
  prefs: []
  type: TYPE_NORMAL
- en: Borg was running within Google for several years and it was eventually replaced
    by a more modern scheduler called Omega. It was around this time that Google announced
    it that it would be taking some of the core functionality of Borg and reproducing
    it as a new open source project. This project, known internally as **Seven**,
    was worked on by several of the core contributors to Borg. It aimed to create
    a friendlier version of Borg that wasn't closely tied into Google's own internal
    procedures and ways of working.
  prefs: []
  type: TYPE_NORMAL
- en: '**Seven**, named after the *Star Trek: Voyager character* Seven of Nine, who
    was a Borg that broke away from the collective, would eventually be named **Kubernetes**
    by the time of its first public commit.'
  prefs: []
  type: TYPE_NORMAL
- en: So, now that we know how Kubernetes came to be, we can dig a little deeper into
    what Kubernetes is.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of Kubernetes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The bulk of the project, 90.7% at the time of writing this, is written in Go,
    which should come as no surprise as Go is a programming language that was developed
    internally at Google before it was open sourced in 2011\. The rest of the project
    files are made up of Python and Shell helper scripts and HTML documentation.
  prefs: []
  type: TYPE_NORMAL
- en: A typical Kubernetes cluster is made up of servers that take on either a master
    or node role. You can also run a standalone installation that takes on both roles.
  prefs: []
  type: TYPE_NORMAL
- en: The master role is where the magic happens, and it is the brains of the cluster.
    It is responsible for making decisions on where pods are launched and for monitoring
    the health of both the cluster itself and also of the pods running within the
    cluster. We will discuss pods once we have finished looking at the two roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Typically, the core components that are deployed to a host that has been given
    the role of a master are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kube-apiserver`: This component exposes the main Kubernetes API. It is designed
    to horizontally scale, which means that you can keep adding more instances of
    it to make your cluster highly available.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`etcd`: This is a highly available consistent key-value store. It is used to
    store the state of the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-scheduler`: This component is responsible for making the decisions on
    where pods are launched.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-controller-manager`: This component runs controllers. These controllers
    have several functions within Kubernetes, such as monitoring the nodes, keeping
    an eye on the replication, managing the endpoints, and generating service accounts
    and tokens.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cloud-controller-manager`: This component takes on the management of the various
    controllers, which interact with third-party clouds to launch and configure supporting
    services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now that we have our management components covered, we need to discuss what
    they are managing. A node is made up of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`kubelet`: This agent runs on each node within the cluster, and it is the means
    by which the managers interact with the nodes. It is also responsible for managing
    the pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kube-proxy`: This component manages all of the routing of requests and traffic
    for both the node and also the pods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`container runtime`: This could be Docker, CRI-O, or any other OCI-compliant
    runtime.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You may have noticed that I have not mentioned containers much so far. This
    is because Kubernetes doesn't actually directly interact with your containers;
    instead, it communicates with a pod. Think of a pod as a complete application,
    a little like when we looked at launching an application made up of multiple containers
    using Docker Compose.
  prefs: []
  type: TYPE_NORMAL
- en: How does Docker fit in with Kubernetes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker's relationship with Kubernetes is varied. To start with, Docker, the
    container engine, powers a lot of Kubernetes installations in one form or another,
    for example, as Docker or ContainerD.
  prefs: []
  type: TYPE_NORMAL
- en: However, Kubernetes was originally seen as a competitive technology to Docker
    Swarm, which was Docker's own clustering technology. However, over the last few
    years, Kubernetes has emerged as pretty much the de facto standard for container
    clustering/orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the major cloud providers provide Kubernetes-as-a-service. We have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Cloud**: **Google Kubernetes Engine** (**GKE**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft Azure**: **Azure Kubernetes Service** (**AKS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Amazon Web Services**: **Amazon Elastic Container Service for Kubernetes**
    (**EKS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IBM**: **IBM Cloud Kubernetes Service**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Oracle Cloud**: **Oracle Container Engine for Kubernetes**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DigitalOcean**: **Kubernetes on DigitalOcean**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: On the face of it, all of the major players supporting Kubernetes may not seem
    like that big a deal. However, consider that we now know a consistent way of deploying
    our containerized applications across multiple platforms. Traditionally, these
    platforms have been walled gardens and have very different ways of interacting
    with them.
  prefs: []
  type: TYPE_NORMAL
- en: While Docker's announcement of Kubernetes support in its desktop versions in
    October 2017 at DockerCon Europe initially came as a surprise, once the dust settled
    the announcement made perfect sense. Providing developers with an environment
    where they could work on their applications locally using Docker for Mac and Docker
    for Windows, and then using Docker Enterprise Edition to deploy and manage their
    own Kubernetes clusters, or even use one of the cloud services mentioned previously,
    fits in with trying to solve the 'works on my machine' problem we discussed in
    [*Chapter 1*](B15659_01_Final_JM_ePub.xhtml#_idTextAnchor046), *Docker Overview*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now take a look at how you can enable support in the Docker software and
    get stuck in using it.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Kubernetes in Docker Desktop
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker has made the installation process extremely simple. All you need to
    do to enable Kubernetes support is open **Preferences** and click on the **Kubernetes**
    tab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – The Kubernetes preferences in Docker for Mac'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0012.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – The Kubernetes preferences in Docker for Mac
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are three options. Tick the **Enable Kubernetes** box
    and then select **Deploy Docker Stacks to Kubernetes by default**. Leave **Show
    systems containers (advanced)** unticked for now; we look at this in a little
    more detail once we have enabled the service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking **Apply & Restart** will do just that, restart Docker and enable Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Enabling Kubernetes on Docker for Mac'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Enabling Kubernetes on Docker for Mac
  prefs: []
  type: TYPE_NORMAL
- en: 'It will take a short while for Docker to download, configure, and launch the
    cluster. Once complete, you should see Docker and Kubernetes listed in the bottom
    left of the settings window. Both should have a green dot next to them to indicate
    that the services are running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Kubernetes successfully enabled on Docker for Mac'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0032.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – Kubernetes successfully enabled on Docker for Mac
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This should show you that there is nothing out of the ordinary running. Run
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this shows nothing of interest; however, as you might have guessed,
    ticking the **Show system containers (advanced)** option in the **Settings** window
    will change this. Tick it now and then re-run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'As there is a lot of output when running the preceding command, the following
    screenshot shows just the names of the containers. To do this, I ran the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Running the command gave me the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Listing the containers that make up our Kubernetes installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0042.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Listing the containers that make up our Kubernetes installation
  prefs: []
  type: TYPE_NORMAL
- en: There are 20 running containers, which is why you have the option of hiding
    them. As you can see, nearly all of the components we discussed in the previous
    section are covered as well as a few additional components, which provide the
    integration with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It still doesn''t list any images, although we get a list of images that are
    being used by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from the following output, the images are sourced from both
    Docker and also the official Kubernetes images that are available from the Google
    Container Registry (k8s.gcr.io), and there are also some images that have been
    built locally:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Viewing the images being used to power the Kubernetes installation'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0052.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Viewing the images being used to power the Kubernetes installation
  prefs: []
  type: TYPE_NORMAL
- en: For now, I would recommend unticking the **Show system containers (advanced)**
    option, as we do not need to see a list of 20 containers running each time that
    we look at the running containers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other thing to note at this point is that the **Kubernetes** menu item
    in the Docker app now has content in it. This menu can be used for switching between
    Kubernetes clusters. As we only have one cluster active at the moment, there is
    only one listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Checking the Kubernetes menu item'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0062.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – Checking the Kubernetes menu item
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our local Kubernetes cluster up and running, we can start to
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: Using Kubernetes and Docker Desktop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have our Kubernetes cluster up and running on our Docker desktop
    installation, we can start to interact with it. To start with, we are going to
    look at the command line that was installed alongside the Docker desktop component,
    `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned, `kubectl` was installed alongside Docker. The following command
    will show some information about the client and also the cluster it is connected
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Like when running `docker version`, this should give you information on both
    the client and server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Checking the versions of the client and server'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0072.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – Checking the versions of the client and server
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can run the following to see if `kubectl` can see our node:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As we only have a single node, we should only see one listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Listing our nodes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0082.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – Listing our nodes
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our client interacting with our node, we can view the namespaces
    that are configured by default within Kubernetes by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can view the pods within a namespace with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows is the Terminal output I received when I ran the preceding commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Checking the namespaces'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0092.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.9 – Checking the namespaces
  prefs: []
  type: TYPE_NORMAL
- en: 'Namespaces within Kubernetes are a great way of isolating resources within
    your cluster. As you can see from the Terminal output, there are four namespaces
    within our cluster. There is the `default` namespace, which is typically empty.
    There are two namespaces for the main Kubernetes services: `docker` and `kube-system`.
    These contain the pods that make up our cluster and the final namespace, `kube-public`,
    like the default namespace, is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we launch our own pod, let''s take a quick look at how we can interact
    with the pods we have running, starting with how we can find more information
    about our pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will print out the details of the `kube-scheduler-docker-desktop`
    pod. You might notice that we had to pass the namespace using the `--namespace`
    flag. If we didn't, then `kubectl` would default to the default namespace where
    there isn't a pod called `kube-scheduler-docker-desktop` running.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full output of the command is shown here, starting with some basic information
    on the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Like Docker, you can apply labels to pods. This is shown in the following screenshot,
    along with some more details around the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'What follows next is information on the container running within the pod. The
    information here starts with basic information such as the container ID, images,
    and ports:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We then move on to the command that is being run within the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we see its current state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we have some information on its utilization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are back to information on the pod. Here, we can see the current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we see details on the volumes mounted by the pod and some other options
    such as **Quality of Service** (**QoS**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can see events listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, there is a lot of information about the pod, including a list
    of containers; we only have one called `kube-scheduler`. We can see the container
    ID, the image used, the flags the container was launched with, and also the data
    used by the Kubernetes scheduler to launch and maintain the pod.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know a container name, we can start to interact with it. For example,
    running the following command will print the logs for our one container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'I got the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Checking the logs on a container in a pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0102.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – Checking the logs on a container in a pod
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the following command would fetch the logs for each container in the
    pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Like Docker, you can also execute commands on your pods and containers.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Please ensure you add the space after the `--` in the following two commands.
    Failing to do so will result in errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following commands will run the `uname -a` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we have the option of running the command on a named container or across
    all containers within the pod:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Running a command across all the containers in a pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0112.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.11 – Running a command across all the containers in a pod
  prefs: []
  type: TYPE_NORMAL
- en: Let's find out a little more about our Kubernetes cluster by installing and
    logging into the web-based dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'While this does not ship with Docker by default, installing it using the definition
    file provided by the Kubernetes project is simple. We just need to run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as you run the command, you should see something like the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Deploying the web-based dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0122.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.12 – Deploying the web-based dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the services and deployments have been created, it will take a few minutes
    to launch. You can check on the status by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your output looks like the following, your dashboard should be installed
    and ready:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Checking the status of the deployment'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0131.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – Checking the status of the deployment
  prefs: []
  type: TYPE_NORMAL
- en: 'You may have noticed that the dashboard has its own namespace called `kubernetes-dashboard`.
    Now that we have our dashboard running, we will find a way to access it. We can
    do this using the inbuilt proxy service in `kubectl`. Just run the following command
    to start it up:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will open a long-running foreground process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Starting the proxy service'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0141.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.14 – Starting the proxy service
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the proxy service is running, opening your browser and going to [http://127.0.0.1:8001/version/](http://127.0.0.1:8001/version/)
    will show you some information on your cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Information on the cluster'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0151.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.15 – Information on the cluster
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it''s the dashboard we want to see. This can be accessed at the following
    URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/](http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see something like the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – The dashboard login screen'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0161.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.16 – The Dashboard login screen
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, it is asking for us to log in; however, we haven't yet created
    any credentials, so let's do that now.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: A service account is a system account, which in most cases uses a token to authenticate
    against the Kubernetes API to perform an action. Service accounts can be used
    for both services running within your Kubernetes cluster, as well as in our case,
    where we as a user want to access to the Dashboard using an API token.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a new Terminal window and enter the following command to create a service
    account:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The service account will be created in the default namespace; however, that
    is not going to be a problem as we are now going to assign the service account
    the `cluster-admin` role by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This should have created a secret, and we can find the name of the secret by
    running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Terminal output shows the steps taken so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Creating the service account, assigning permission, and viewing
    the secrets'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0171.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.17 – Creating the service account, assigning permission, and viewing
    the secrets
  prefs: []
  type: TYPE_NORMAL
- en: Now that our service account has been created, the correct permissions have
    been set, and we know the name of the secret (yours will differ as the secret
    name is affixed with a five-character random string), we can get a copy of the
    token we need to log in.
  prefs: []
  type: TYPE_NORMAL
- en: 'We simply need to run the following command, making sure that you update the
    secret name to match your own:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something similar to the following Terminal output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Viewing the secret'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_018.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.18 – Viewing the secret
  prefs: []
  type: TYPE_NORMAL
- en: 'Make a note of the token and enter it on the dashboard login page in the space
    provided for the token and then click on the **Sign in** button. Once logged in,
    you will be presented with something that looks like the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Dashboard first login'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_019.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.19 – Dashboard first login
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the dashboard uses the `default` namespace. Well, by default,
    clicking the namespace name will open a drop-down list containing all of the available
    namespaces. For now, select **All namespaces** from the top of the list, and you
    will notice that the view changes and a lot more information is now displayed
    on the overview page.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our cluster up and running, we can now look at launching a
    few sample applications.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes and other Docker tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we enabled Kubernetes, we selected the `docker stack` command to launch
    our Docker Compose files in Docker Swarm and, as you might have guessed, running
    those same commands will now launch our stack in our Kubernetes cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Docker Compose file we used looked like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we launch the application on Kubernetes, we need to make a slight adjustment
    and remove the `placement`, which leaves our file looking like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the file has been edited, running the following command will launch the
    stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, Docker waits until the stack is available before returning
    you to your prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.20 – Launching the stack'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_020.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.20 – Launching the stack
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also run the same commands we used to view some information about our
    stack as we did when we launched our stack on Docker Swarm:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The Terminal output gives us similar output to when we launched the stack using
    a Docker Swarm cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – Running the Docker stack commands'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.21 – Running the Docker stack commands
  prefs: []
  type: TYPE_NORMAL
- en: However, please note, at the time of writing there appears to be an issue with
    the `docker stack services` returning an error, this issue was introduced with
    an update to the version of Kubernetes that ships with Docker.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see details using `kubectl`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You may have noticed that this time we did not need to provide a namespace.
    This is because our stack was launched in the default namespace:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Viewing details about the deployment and services'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_022.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.22 – Viewing details about the deployment and services
  prefs: []
  type: TYPE_NORMAL
- en: Also, when the services were listed, a `localhost` and that the port is `80`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Opening `http://localhost/` in our browser shows the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Viewing the cluster application running in Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_023.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.23 – Viewing the cluster application running in Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still have the Dashboard open, you can explore your stack and even open
    a Terminal to one of the containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Opening a Terminal to a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_024.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.24 – Opening a Terminal to a container
  prefs: []
  type: TYPE_NORMAL
- en: 'This was done by selecting one of the six pods for the cluster deployment and
    then clicking on the **Exec into pod** button highlighted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.25 – Exec into pod'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_025.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.25 – Exec into pod
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove the stack by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: One last thing…you may be thinking to yourself, 'Great, I can run my Docker
    Compose files anywhere on a Kubernetes cluster.' Well, that is not strictly true.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned, when we first enabled Kubernetes, there are some Docker-only components
    launched. These are there to make sure that Docker is integrated as tightly as
    possible. However, as these components won't exist in non-Docker managed clusters,
    you won't be able to use the `docker stack` commands.
  prefs: []
  type: TYPE_NORMAL
- en: All is not lost though. There is a tool called **Kompose** provided as part
    of the Kubernetes project, which can take Docker Compose files and convert them
    on the fly to Kubernetes definition files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Kompose on macOS using Homebrew, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Windows 10 users can use Chocolatey.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs: []
  type: TYPE_NORMAL
- en: '`yum` or `apt-get` on Linux machines or `brew` on macOS.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To install Kompose using Chocolatey, you can run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Once it''s installed, you can launch your Docker Compose file by running the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'You will get something like the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.26 – Running kompose up'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_026.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.26 – Running kompose up
  prefs: []
  type: TYPE_NORMAL
- en: 'As suggested by the output, running the following command will give you details
    on the service and pod we just launched:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our Docker Compose application is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.27 – Checking the status of the application'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_027.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.27 – Checking the status of the application
  prefs: []
  type: TYPE_NORMAL
- en: 'You can remove the services and pods by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This should give you something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.28 – Running kompose down'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_028.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.28 – Running kompose down
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can use `kompose up` and `kompose down`, I would recommend generating
    the Kubernetes definition files and tweaking them as needed. To do this, simply
    run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that this command generates two files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.29 – Running kompose convert'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_029.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.29 – Running kompose convert
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be able to see quite a difference between the Docker Compose file
    and the two files generated. The `cluster-pod.yaml` file looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'You can then launch these files by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not following along, the following screenshot shows the Terminal
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.30 – Launching the application using cluster-pod.yaml and cluster-service.yaml'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_030.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.30 – Launching the application using cluster-pod.yaml and cluster-service.yaml
  prefs: []
  type: TYPE_NORMAL
- en: 'To remove the cluster pod and service, we just need to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: While we will continue to use this in the next two chapters, you may want to
    disable the Kubernetes integration within your Docker desktop installation as
    it does add a slight overhead to host machine when it is idle. To do this, just
    untick **Enable Kubernetes**. When you click **Apply**, Docker will stop all the
    containers it needed to run Kubernetes; it won't, however, remove the images so
    that when you re-enable it, it doesn't take as long.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at Kubernetes from the point of view of Docker desktop
    software. There is a lot more to Kubernetes than we have covered in this chapter,
    so please don't think this is all there is. After discussing the origins of Kubernetes,
    we looked at how you can enable it on your local machine using Docker for Mac
    or Docker for Windows.
  prefs: []
  type: TYPE_NORMAL
- en: We then discussed some basic usage of kubectl before looking at running how
    we can use `docker stack` commands to launch our applications as we did for Docker
    Swarm.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the chapter, we discussed Kompose, which is a tool from the Kubernetes
    project. It helps you convert your Docker Compose files for use with Kubernetes,
    allowing you to get a head start on moving your applications to pure Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: While we have referred to a Kubernetes cluster throughout this chapter, we have
    in actual fact been running a single node cluster, which really isn't a cluster
    at all.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a look at a few more options on how
    to launch Kubernetes locally. Here, we will welcome back Linux users and also
    look at options for launching more than one node.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'True or false: When `docker image ls` command.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which of the four namespaces hosts the containers used to run Kubernetes and
    enable support within Docker?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command would you run to find out details about a container running in
    a pod?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command would you use to launch a Kubernetes definition YAML file? Typically,
    which port does the `kubectl proxy` command open on your local machine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What was the original name of Google container orchestration platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Some of the Google tools, presentations, and white papers mentioned at the
    start of the chapter can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'cgroups: [http://man7.org/linux/man-pages/man7/cgroups.7.html](http://man7.org/linux/man-pages/man7/cgroups.7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'lmctfy: [https://github.com/google/lmctfy/](https://github.com/google/lmctfy/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Containers at Scale, Joe Beda''s slides from GluCon: [http://slides.eightypercent.net/GlueCon%202014%20-%20Containers%20At%20Scale.pdf](http://slides.eightypercent.net/GlueCon%202014%20-%20Containers%20At%20Scale.pdf)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Large-scale cluster management at Google with Borg: [https://ai.google/research/pubs/pub43438](https://ai.google/research/pubs/pub43438)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'LXC: [https://linuxcontainers.org/](https://linuxcontainers.org/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find details on the cloud services mentioned in the chapter here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Google Kubernetes Engine** (**GKE**): [https://cloud.google.com/kubernetes-engine](https://cloud.google.com/kubernetes-engine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure Kubernetes Service** (**AKS**): [https://azure.microsoft.com/en-gb/services/kubernetes-service/](https://azure.microsoft.com/en-gb/services/kubernetes-service/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Amazon **Elastic Container Service for Kubernetes** (**Amazon EKS**): [https://aws.amazon.com/eks/](https://aws.amazon.com/eks/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'IBM Cloud Kubernetes Service: [https://www.ibm.com/cloud/container-service](https://www.ibm.com/cloud/container-service)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Oracle Container Engine for Kubernetes: [https://cloud.oracle.com/containers/kubernetes-engine](https://cloud.oracle.com/containers/kubernetes-engine)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Kubernetes on DigitalOcean: [https://www.digitalocean.com/products/kubernetes/](https://www.digitalocean.com/products/kubernetes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can find Docker''s announcements about Kubernetes support here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker Platform and Moby Project add Kubernetes: [https://www.docker.com/blog/top-5-blogs-2017-docker-platform-moby-project-add-kubernetes/](https://www.docker.com/blog/top-5-blogs-2017-docker-platform-moby-project-add-kubernetes/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the home page for Kompose can be found here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Kompose: [http://kompose.io/](http://kompose.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
