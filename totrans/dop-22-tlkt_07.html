<html><head></head><body>
<div class="calibre6">
<h2 id="leanpub-auto-deploying-and-configuring-prometheus" class="calibre15">Deploying And Configuring Prometheus</h2>

<p class="calibre3">On the first look, deploying Prometheus is simple. Create a Compose file and execute <code class="calibre19">docker stack deploy</code> command. Complications emerge once we start integrating services with Prometheus. Soon, you will have a first-hand chance to experience the integration problems.</p>

<p class="calibre3">Like any good story, this chapter will start on a happy note. Among engineers, happy means that it’s simple and it works. Let’s see how simple looks in practice.</p>

<h3 id="leanpub-auto-deploying-prometheus-stack" class="calibre20">Deploying Prometheus Stack</h3>

<p class="calibre3">We’ll start by cloning <a href="https://github.com/vfarcic/docker-flow-monitor">vfarcic/docker-flow-monitor</a> repository. It contains all the scripts and Docker stacks we’ll use throughout this chapter.</p>

<aside class="information">
    <p class="calibre3">All the commands from this chapter are available in the <a href="https://gist.github.com/vfarcic/e597004e626fbffc47de72bdc75a3498">03-deploying-prometheus.sh</a> Gist.</p>

</aside>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>git clone <code class="se">\</code>
<code class="lineno">2 </code>    https://github.com/vfarcic/docker-flow-monitor.git
<code class="lineno">3 </code>
<code class="lineno">4 </code><code class="nb">cd</code> docker-flow-monitor
</pre></div>

</figure>

<aside class="tip">
    <p class="calibre3">The rest of the chapter will require Docker Machine. Please set it up using the <a href="https://docs.docker.com/machine/install-machine/">installation instructions</a>.</p>

</aside>

<aside class="warning">
    <p class="calibre3">If you are a Windows user, please run all the commands from <em class="calibre21">Git Bash</em> (installed through <em class="calibre21">Git</em>) or any other Bash you might have.</p>

</aside>

<p class="calibre3">Before we create a Prometheus service, we need to have a cluster. It will consist of three nodes created with Docker Machine.</p>

<aside class="tip">
    <p class="calibre3">Feel free to skip the commands that follow if you already have a working Swarm cluster.</p>

</aside>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>chmod +x scripts/dm-swarm.sh
<code class="lineno">2 </code>
<code class="lineno">3 </code>./scripts/dm-swarm.sh
<code class="lineno">4 </code>
<code class="lineno">5 </code><code class="nb">eval</code> <code class="k">$(</code>docker-machine env swarm-1<code class="k">)</code>
</pre></div>

</figure>

<p class="calibre3">The <code class="calibre19">dm-swarm.sh</code> script created the nodes and joined them into a Swarm cluster.</p>

<aside class="tip">
    <p class="calibre3">I will assume that you are already familiar with Docker Swarm and do not need an explanation of the script. If that’s not the case, please consider reading <a href="https://www.amazon.com/dp/1542468914">The DevOps 2.1 Toolkit: Docker Swarm: Building, testing, deploying, and monitoring services inside Docker Swarm clusters</a> for an in-depth examination of how Docker Swarm clusters work.</p>

</aside>

<p class="calibre3">Now we can create the first Prometheus service. We’ll start small and slowly move toward a more robust solution.</p>

<p class="calibre3">We’ll deploy the stack defined in <code class="calibre19">stacks/prometheus.yml</code>. It is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>version: "3"
<code class="lineno">2 </code>
<code class="lineno">3 </code>services:
<code class="lineno">4 </code>
<code class="lineno">5 </code>  prometheus:
<code class="lineno">6 </code>    image: prom/prometheus
<code class="lineno">7 </code>    ports:
<code class="lineno">8 </code>      - 9090:9090
</pre></div>

</figure>

<p class="calibre3">As you can see, it is as simple as it can get. It specifies the image and the port that should be opened.</p>

<p class="calibre3">Let’s deploy the stack.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker stack deploy <code class="se">\</code>
<code class="lineno">2 </code>    -c stacks/prometheus.yml <code class="se">\</code>
<code class="lineno">3 </code>    monitor
</pre></div>

</figure>

<p class="calibre3">Please wait a few moments until the image is pulled and deployed. You can monitor the status by executing the <code class="calibre19">docker stack ps monitor</code> command.</p>

<p class="calibre3">Let’s confirm that Prometheus service is indeed up-and-running.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">:9090"</code>
</pre></div>

</figure>

<aside class="information">
    <p class="calibre3">If you’re a Windows user, Git Bash might not be able to use the <code class="calibre19">open</code> command. If that’s the case, replace the <code class="calibre19">open</code> command with <code class="calibre19">echo</code>. As a result, you’ll get the full address that should be opened directly in your browser of choice.</p>

</aside>

<p class="calibre3">You should see the Prometheus Graph screen.</p>

<p class="calibre3">Let’s take a look at the configuration.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">:9090/config"</code>
</pre></div>

</figure>

<p class="calibre3">You should see the default config that does not define much more than intervals and internal scraping. In its current state, Prometheus is not very useful, so we’ll have to spice it up a bit.</p>


<figure class="image">
  <img src="../images/00008.jpeg" alt="Figure 3-1: Prometheus with the default configuration" class="calibre17"/>
  <figcaption class="calibre18">Figure 3-1: Prometheus with the default configuration</figcaption>
</figure>


<p class="calibre3">We should start fine tuning Prometheus. There are quite a few ways we can do that.</p>

<p class="calibre3">We can create a new Docker image that would extend the one we used and add our own configuration file. That solution has a distinct advantage of being immutable and, hence, very reliable. Since Docker image cannot be changed, we can guarantee that the configuration is exactly as we want it to be no matter where we deploy it. If the service fails, Swarm will reschedule it and, since the configuration is baked into the image, it’ll be preserved. The problem with that approach is that it is not suitable for microservices architecture. If Prometheus has to be reconfigured with every new service (or at least those that expose metrics), we would need to build it quite often and tie that build to CD processes executed for the services we’re developing. This approach is suitable only for a relatively static cluster and monolithic applications. Discarded!</p>


<figure class="image">
  <img src="../images/00009.jpeg" alt="Figure 3-2: Creating a new image every time Prometheus config change" class="calibre17"/>
  <figcaption class="calibre18">Figure 3-2: Creating a new image every time Prometheus config change</figcaption>
</figure>


<p class="calibre3">What would be the alternative approach?</p>

<p class="calibre3">We can enter a running Prometheus container, modify its configuration, and reload it. While this allows a higher level of dynamism, it is not fault-tolerant. If Prometheus fails, Swarm will reschedule it, and all the changes we made will be lost. Besides fault tolerance, modifying a config in a running container poses additional problems when running it as a service inside a cluster. We need to find out the node it is running in, SSH into it, figure out the ID of the container, and, only then, we can <code class="calibre19">exec</code> into it, modify the config, and send a reload request. While those steps are not overly complicated and can be scripted, they will pose an unnecessary operational complexity. Discarded!</p>


<figure class="image">
  <img src="../images/00010.jpeg" alt="Figure 3-3: Updating Prometheus configuration inside a container" class="calibre17"/>
  <figcaption class="calibre18">Figure 3-3: Updating Prometheus configuration inside a container</figcaption>
</figure>


<p class="calibre3">Among other reasons, we discarded the previous solution because it is not fault-tolerant.</p>

<p class="calibre3">We could mount a network volume to the service. That would solve persistence, but would still leave the problem created by a dynamic nature of a cluster. We still, potentially, need to change the configuration and reload Prometheus every time a new service is deployed or updated.</p>

<p class="calibre3">From the operational perspective, this solution is simpler than the previous solution we discussed. We do not need to find out the node it is running in, SSH into it, figure out the ID of the container, <code class="calibre19">exec</code> into it, and modify the config. Instead, we can alter the file on the network drive and send a reload request to Prometheus. While network drive simplifies the process, it does not make it as dynamic and independent from the services as it should be. We would need to make sure that the deployment pipeline of each of the services has the required steps that will reconfigure Prometheus. By doing that we would break one of our objectives. That is, our services would not contain all the information about themselves. Instead, we’d need to create a different pipeline for each and specify the targets, alerts, and other information we might need before reconfiguring Prometheus. We’ll discard this solution as well.</p>


<figure class="image">
  <img src="../images/00011.jpeg" alt="Figure 3-4: Updating Prometheus configuration stored on a network drive" class="calibre17"/>
  <figcaption class="calibre18">Figure 3-4: Updating Prometheus configuration stored on a network drive</figcaption>
</figure>


<p class="calibre3">What other options do we have? If we’re looking for an out-of-the-box solution that uses the official Prometheus image, all our options are exhausted. But we are engineers. We are used to extending other people solutions and adapting them to suit our needs. Let’s not limit our options and try to design a solution that would suit us well.</p>

<h3 id="leanpub-auto-designing-a-more-dynamic-monitoring-solution" class="calibre20">Designing A More Dynamic Monitoring Solution</h3>

<p class="calibre3">How can we improve Prometheus design to suit our purposes better? How can we make it more dynamic and more scheduler friendly?</p>

<p class="calibre3">One improvement we can make is the usage of environment variables. That would save us from having to create a new image every time we need to change its configuration. At the same time, environment variables would remove the need to use a network drive (at least for configuration).</p>

<aside class="tip">
    <p class="calibre3">When using containers, environment variables are a preferable way of passing configuration information to the processes running inside them.</p>

</aside>

<p class="calibre3">We can make a generic solution that will transform any environment variable into a Prometheus configuration entry or an initialization argument.</p>

<aside class="tip">
    <p class="calibre3">We’ll go through the code I created. It is written in go and should be relatively straightforward to understand even if you are not a Go developer. The goal of the walkthrough is to get familiar with a potential solution that you could write yourself in your favorite language. That does not mean that you should not adopt <em class="calibre21">Docker Flow Monitor</em> as a ready to go solution and skip the coding part, but, rather, that you should evaluate your options and make your own choice.</p>

</aside>

<p class="calibre3">To enable Prometheus configuration through environment variables, we need to distinguish those that should be used as command line arguments from those that will serve to create the configuration file. We’ll define a naming convention stating that every environment argument with a name that starts with <code class="calibre19">ARG_</code> is a startup argument.</p>

<p class="calibre3">The code can be as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="k">func</code> <code class="calibre19">Run</code><code class="calibre19">()</code> <code class="kt">error</code> <code class="calibre19">{</code>
<code class="lineno"> 2 </code>	<code class="calibre19">cmdString</code> <code class="o">:=</code> <code class="s">"prometheus"</code>
<code class="lineno"> 3 </code>	<code class="k">for</code> <code class="calibre19">_</code><code class="calibre19">,</code> <code class="calibre19">e</code> <code class="o">:=</code> <code class="k">range</code> <code class="calibre19">os</code><code class="calibre19">.</code><code class="calibre19">Environ</code><code class="calibre19">()</code> <code class="calibre19">{</code>
<code class="lineno"> 4 </code>		<code class="k">if</code> <code class="calibre19">key</code><code class="calibre19">,</code> <code class="calibre19">value</code> <code class="o">:=</code> <code class="calibre19">getArgFromEnv</code><code class="calibre19">(</code><code class="calibre19">e</code><code class="calibre19">,</code> <code class="s">"ARG"</code><code class="calibre19">);</code> <code class="nb">len</code><code class="calibre19">(</code><code class="calibre19">key</code><code class="calibre19">)</code> <code class="calibre19">&gt;</code> <code class="o">0</code> <code class="calibre19">{</code>
<code class="lineno"> 5 </code>			<code class="calibre19">cmdString</code> <code class="calibre19">=</code> <code class="calibre19">fmt</code><code class="calibre19">.</code><code class="calibre19">Sprintf</code><code class="calibre19">(</code><code class="s">"%s -%s=%s"</code><code class="calibre19">,</code> <code class="calibre19">cmdString</code><code class="calibre19">,</code> <code class="calibre19">key</code><code class="calibre19">,</code> <code class="calibre19">value</code><code class="calibre19">)</code>
<code class="lineno"> 6 </code>		<code class="calibre19">}</code>
<code class="lineno"> 7 </code>	<code class="calibre19">}</code>
<code class="lineno"> 8 </code>	<code class="calibre19">cmd</code> <code class="o">:=</code> <code class="calibre19">exec</code><code class="calibre19">.</code><code class="calibre19">Command</code><code class="calibre19">(</code><code class="s">"/bin/sh"</code><code class="calibre19">,</code> <code class="s">"-c"</code><code class="calibre19">,</code> <code class="calibre19">cmdString</code><code class="calibre19">)</code>
<code class="lineno"> 9 </code>	<code class="k">return</code> <code class="calibre19">cmdRun</code><code class="calibre19">(</code><code class="calibre19">cmd</code><code class="calibre19">)</code>
<code class="lineno">10 </code><code class="calibre19">}</code>
</pre></div>

</figure>

<p class="calibre3">It is a very simple function. It iterates through all the environment variables. If their names start with <code class="calibre19">ARG</code>, they will be added as arguments of the executable <code class="calibre19">prometheus</code>. Once the iteration is done, binary is launched with arguments.</p>

<p class="calibre3">We made Prometheus more <em class="calibre21">Docker-friendly</em> with only a few lines of code that sits on top of it.</p>

<p class="calibre3">The full source code can be found in the <a href="https://github.com/vfarcic/docker-flow-monitor/blob/master/prometheus/run.go">run.go</a> file.</p>

<p class="calibre3">We should do something similar with the configuration file. Specifically, we can make the global section of the configuration use environment variables prefixed with <code class="calibre19">GLOBAL_</code>.</p>

<p class="calibre3">The logic of the code is similar to the <code class="calibre19">Run</code> function we explored. Please go through <a href="https://github.com/vfarcic/docker-flow-monitor/blob/master/prometheus/config.go">config.go</a> for more details. The <code class="calibre19">GetGlobalConfig</code> function returns <code class="calibre19">global</code> section of the config while the <code class="calibre19">WriteConfig</code> function writes the configuration to the file.</p>

<p class="calibre3">Please consult <a href="https://prometheus.io/docs/operating/configuration/">Prometheus Configuration</a> for more information about the available options.</p>

<p class="calibre3">By using environment variables, we managed to get rid of the network drive. As far as configuration is concerned, it will be fault tolerant. If the service fails and gets rescheduled with Swarm, it will not lose its configuration since it is part of the service definition. There is a downside though. Every time we want to change the configuration, we’ll need to execute <code class="calibre19">docker service update</code> command or modify the stack file, and re-execute <code class="calibre19">docker stack deploy</code>. As a result, Docker will stop the currently running replica and start a new one thus producing a short downtime. However, since we are, at the moment, only dealing with global configuration and startup arguments, changes will be very uncommon. We’ll deal with more dynamic parts of the configuration later.</p>


<figure class="image">
  <img src="../images/00012.jpeg" alt="Figure 3-5: Prometheus configuration defined through environment variables" class="calibre17"/>
  <figcaption class="calibre18">Figure 3-5: Prometheus configuration defined through environment variables</figcaption>
</figure>


<p class="calibre3">I have the code compiled and available as <a href="https://hub.docker.com/r/vfarcic/docker-flow-monitor/">vfarcic/docker-flow-monitor/</a>. Let’s give it a spin.</p>

<aside class="warning">
    <p class="calibre3">Please note that you can choose not to use <em class="calibre21">Docker Flow Monitor</em> nor to create your own solution. What follows is still equally useful if you decide to use the “original” Prometheus. You will learn how to apply manually all the changes we’ll perform in a more dynamic fashion.</p>

</aside>

<h3 id="leanpub-auto-deploying-docker-flow-monitor" class="calibre20">Deploying Docker Flow Monitor</h3>

<p class="calibre3">Deploying <em class="calibre21">Docker Flow Monitor</em> is easy (as almost all Docker services are). We’ll start by creating a network called <code class="calibre19">monitor</code>. We could let Docker stack create it for us, but it is useful to have it defined externally so that we can easily attach it to services from other stacks.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker network create -d overlay monitor
</pre></div>

</figure>

<p class="calibre3">The stack is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code><code class="nn">version</code><code class="calibre19">:</code> <code class="s">"3"</code>
<code class="lineno"> 2 </code><code class="nn">services</code><code class="calibre19">:</code>
<code class="lineno"> 3 </code>  <code class="nn">monitor</code><code class="calibre19">:</code>
<code class="lineno"> 4 </code>    <code class="nn">image</code><code class="calibre19">:</code> <code class="s">vfarcic</code><code class="o">/</code><code class="s">docker</code><code class="o">-</code><code class="s">flow</code><code class="o">-</code><code class="nn">monitor</code><code class="calibre19">:</code><code class="err">$</code><code class="calibre19">{</code><code class="nv">TAG</code><code class="calibre19">:-</code><code class="s">latest</code><code class="calibre19">}</code>
<code class="lineno"> 5 </code>    <code class="nn">environment</code><code class="calibre19">:</code>
<code class="lineno"> 6 </code>      <code class="o">-</code> <code class="nv">GLOBAL_SCRAPE_INTERVAL</code><code class="o">=</code><code class="o">10</code><code class="s">s</code>
<code class="lineno"> 7 </code>    <code class="nn">networks</code><code class="calibre19">:</code>
<code class="lineno"> 8 </code>      <code class="o">-</code> <code class="s">monitor</code>
<code class="lineno"> 9 </code>    <code class="nn">ports</code><code class="calibre19">:</code>
<code class="lineno">10 </code>      <code class="o">-</code> <code class="o">9090</code><code class="s">:</code><code class="o">9090</code>
<code class="lineno">11 </code><code class="nn">networks</code><code class="calibre19">:</code>
<code class="lineno">12 </code>    <code class="nn">monitor</code><code class="calibre19">:</code>
<code class="lineno">13 </code>       <code class="nn">external</code><code class="calibre19">:</code> <code class="s">true</code>
</pre></div>

</figure>

<p class="calibre3">The environment variable <code class="calibre19">GLOBAL_SCRAPE_INTERVAL</code> shows the first improvement over the “original” Prometheus service. It allows us to define entries of its configuration as environment variables. That, in itself, is not a significant improvement but is a good start. More powerful additions will be explored later on.</p>

<aside class="tip">
    <p class="calibre3">Please visit <a href="http://monitor.dockerflow.com/config/#environment-variables">Environment Variables</a> section of the documentation for more information about configuration options.</p>

</aside>

<p class="calibre3">Now we’re ready to deploy the stack.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker stack rm monitor
<code class="lineno">2 </code>
<code class="lineno">3 </code>docker stack deploy <code class="se">\</code>
<code class="lineno">4 </code>    -c stacks/docker-flow-monitor.yml <code class="se">\</code>
<code class="lineno">5 </code>    monitor
</pre></div>

</figure>

<p class="calibre3">Please wait a few moments until Swarm pulls the image and starts the service. You can monitor the status by executing <code class="calibre19">docker stack ps monitor</code> command.</p>

<p class="calibre3">Once the service is running, we can confirm that the environment variable indeed generated the configuration.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">:9090/config"</code>
</pre></div>

</figure>


<figure class="image">
  <img src="../images/00013.jpeg" alt="Figure 3-6: Prometheus configuration defined through environment variables" class="calibre17"/>
  <figcaption class="calibre18">Figure 3-6: Prometheus configuration defined through environment variables</figcaption>
</figure>


<aside class="tip">
    <p class="calibre3">Please note that you do not have to use Docker Flow Monitor to accomplish the same Prometheus configuration. We are using it mostly as a fast and dynamic way to configure it. You can choose to do the same by changing its configuration manually.</p>

</aside>

<p class="calibre3">we are going to expose services url in pretty format, therefore we must get rid of port number (9090) in above url.</p>

<h3 id="leanpub-auto-integrating-docker-flow-monitor-with-docker-flow-proxy" class="calibre20">Integrating Docker Flow Monitor With Docker Flow Proxy</h3>

<p class="calibre3">Having a port opened (other than <code class="calibre19">80</code> and <code class="calibre19">443</code>) is, often, not a good idea. If for no other reason, at least it’s not user-friendly to remember a different port for each service. In general service might need to be accessible on its own subdomain, it might need SSL certificate, it might require some URL rewriting, it might need a basic authentication, and so on and so forth. I won’t go into details since you probably already know all that and you are probably already using some proxy in your organization.</p>

<p class="calibre3">We’ll integrate <a href="http://monitor.dockerflow.com/">Docker Flow Monitor</a> with <a href="http://proxy.dockerflow.com/">Docker Flow Proxy (DFP)</a>. If you haven’t used DFP before, please visit the <a href="http://proxy.dockerflow.com/">official documentation</a> for tutorials, setup, and configuration.</p>

<p class="calibre3">Before we apply the knowledge about new ways to configure Prometheus, we need to run the proxy.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker network create -d overlay proxy
<code class="lineno">2 </code>
<code class="lineno">3 </code>docker stack deploy <code class="se">\</code>
<code class="lineno">4 </code>    -c stacks/docker-flow-proxy.yml <code class="se">\</code>
<code class="lineno">5 </code>    proxy
</pre></div>

</figure>

<p class="calibre3">We created the <code class="calibre19">proxy</code> network and deployed the <code class="calibre19">docker-flow-proxy.yml</code> stack. We won’t go into details how <em class="calibre21">Docker Flow Proxy</em> works. The essence is that it will configure itself with each service that has specific labels. For any deeper explanation, please visit <a href="http://proxy.dockerflow.com/swarm-mode-stack/">Docker Flow Proxy Stack Tutorial</a> or any other tutorial available.</p>

<p class="calibre3">With the proxy up and running, we should redeploy our monitor.</p>

<p class="calibre3">We’ll replace the current monitor stack with a new one with in order to achieve this. The major difference is that this time we’ll define startup arguments as well as the labels that will allow the proxy to reconfigure itself to enable access to monitor. You’ll also notice that we will not expose port <em class="calibre21">9090</em>. It’ll be accessible through the proxy on port <em class="calibre21">80</em>, so there’s no reason to open any other port.</p>

<p class="calibre3">The stack is as follows.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno"> 1 </code>  <code class="nn">monitor</code><code class="calibre19">:</code>
<code class="lineno"> 2 </code>    <code class="nn">image</code><code class="calibre19">:</code> <code class="s">vfarcic</code><code class="o">/</code><code class="s">docker</code><code class="o">-</code><code class="s">flow</code><code class="o">-</code><code class="nn">monitor</code><code class="calibre19">:</code><code class="err">$</code><code class="calibre19">{</code><code class="nv">TAG</code><code class="calibre19">:-</code><code class="s">latest</code><code class="calibre19">}</code>
<code class="lineno"> 3 </code>    <code class="nn">environment</code><code class="calibre19">:</code>
<code class="lineno"> 4 </code>      <code class="o">-</code> <code class="nv">GLOBAL_SCRAPE_INTERVAL</code><code class="o">=</code><code class="o">10</code><code class="s">s</code>
<code class="lineno"> 5 </code>      <code class="o">-</code> <code class="nv">ARG_WEB_ROUTE</code><code class="o">-</code><code class="nv">PREFIX</code><code class="s">=/monitor</code>
<code class="lineno"> 6 </code>      <code class="o">-</code> <code class="nv">ARG_WEB_EXTERNAL</code><code class="o">-</code><code class="nv">URL</code><code class="o">=</code><code class="nn">http</code><code class="calibre19">:</code><code class="s">//</code><code class="err">$</code><code class="calibre19">{</code><code class="nv">DOMAIN</code><code class="calibre19">:-</code><code class="s">localhost</code><code class="calibre19">}</code><code class="o">/</code><code class="s">monitor</code>
<code class="lineno"> 7 </code>    <code class="nn">networks</code><code class="calibre19">:</code>
<code class="lineno"> 8 </code>      <code class="o">-</code> <code class="s">proxy</code>
<code class="lineno"> 9 </code>      <code class="o">-</code> <code class="s">monitor</code>
<code class="lineno">10 </code>    <code class="nn">deploy</code><code class="calibre19">:</code>
<code class="lineno">11 </code>      <code class="nn">labels</code><code class="calibre19">:</code>
<code class="lineno">12 </code>        <code class="o">-</code> <code class="s">com</code><code class="calibre19">.</code><code class="s">df</code><code class="calibre19">.</code><code class="s">notify</code><code class="o">=</code><code class="s">true</code>
<code class="lineno">13 </code>        <code class="o">-</code> <code class="s">com</code><code class="calibre19">.</code><code class="s">df</code><code class="calibre19">.</code><code class="s">distribute</code><code class="o">=</code><code class="s">true</code>
<code class="lineno">14 </code>        <code class="o">-</code> <code class="s">com</code><code class="calibre19">.</code><code class="s">df</code><code class="calibre19">.</code><code class="s">servicePath=/monitor</code>
<code class="lineno">15 </code>        <code class="o">-</code> <code class="s">com</code><code class="calibre19">.</code><code class="s">df</code><code class="calibre19">.</code><code class="s">serviceDomain=</code><code class="err">$</code><code class="calibre19">{</code><code class="nv">DOMAIN</code><code class="calibre19">:-</code><code class="s">localhost</code><code class="calibre19">}</code>
<code class="lineno">16 </code>        <code class="o">-</code> <code class="s">com</code><code class="calibre19">.</code><code class="s">df</code><code class="calibre19">.</code><code class="s">port</code><code class="o">=</code><code class="o">9090</code>
<code class="lineno">17 </code>
<code class="lineno">18 </code>
<code class="lineno">19 </code>  <code class="s">swarm</code><code class="o">-</code><code class="nn">listener</code><code class="calibre19">:</code>
<code class="lineno">20 </code>    <code class="nn">image</code><code class="calibre19">:</code> <code class="s">vfarcic</code><code class="o">/</code><code class="s">docker</code><code class="o">-</code><code class="s">flow</code><code class="o">-</code><code class="s">swarm</code><code class="o">-</code><code class="s">listener</code>
<code class="lineno">21 </code>    <code class="nn">networks</code><code class="calibre19">:</code>
<code class="lineno">22 </code>      <code class="o">-</code> <code class="s">monitor</code>
<code class="lineno">23 </code>    <code class="nn">volumes</code><code class="calibre19">:</code>
<code class="lineno">24 </code>      <code class="o">-</code> <code class="o">/</code><code class="s">var</code><code class="o">/</code><code class="s">run</code><code class="o">/</code><code class="s">docker</code><code class="calibre19">.</code><code class="nn">sock</code><code class="calibre19">:</code><code class="o">/</code><code class="s">var</code><code class="o">/</code><code class="s">run</code><code class="o">/</code><code class="s">docker</code><code class="calibre19">.</code><code class="s">sock</code>
<code class="lineno">25 </code>    <code class="nn">environment</code><code class="calibre19">:</code>
<code class="lineno">26 </code>      <code class="o">-</code> <code class="nv">DF_NOTIFY_CREATE_SERVICE_URL</code><code class="o">=</code><code class="nn">http</code><code class="calibre19">:</code><code class="o">//</code><code class="nn">monitor</code><code class="calibre19">:</code><code class="o">8080</code><code class="o">/</code><code class="s">v1</code><code class="o">/</code><code class="s">docker</code><code class="o">-</code><code class="s">flow</code><code class="o">-</code><code class="s">monitor/\</code>
<code class="lineno">27 </code><code class="s">reconfigure</code>
<code class="lineno">28 </code>      <code class="o">-</code> <code class="nv">DF_NOTIFY_REMOVE_SERVICE_URL</code><code class="o">=</code><code class="nn">http</code><code class="calibre19">:</code><code class="o">//</code><code class="nn">monitor</code><code class="calibre19">:</code><code class="o">8080</code><code class="o">/</code><code class="s">v1</code><code class="o">/</code><code class="s">docker</code><code class="o">-</code><code class="s">flow</code><code class="o">-</code><code class="s">monitor/\</code>
<code class="lineno">29 </code><code class="s">remove</code>
<code class="lineno">30 </code>    <code class="nn">deploy</code><code class="calibre19">:</code>
<code class="lineno">31 </code>      <code class="nn">placement</code><code class="calibre19">:</code>
<code class="lineno">32 </code>        <code class="nn">constraints</code><code class="calibre19">:</code> <code class="calibre19">[</code><code class="s">node</code><code class="calibre19">.</code><code class="s">role</code> <code class="o">==</code> <code class="s">manager</code><code class="calibre19">]</code>
<code class="lineno">33 </code>
<code class="lineno">34 </code><code class="nn">networks</code><code class="calibre19">:</code>
<code class="lineno">35 </code>  <code class="nn">monitor</code><code class="calibre19">:</code>
<code class="lineno">36 </code>    <code class="nn">external</code><code class="calibre19">:</code> <code class="s">true</code>
<code class="lineno">37 </code>  <code class="nn">proxy</code><code class="calibre19">:</code>
<code class="lineno">38 </code>    <code class="nn">external</code><code class="calibre19">:</code> <code class="s">true</code>
</pre></div>

</figure>

<p class="calibre3">This time we added a few additional environment variables. They will be used instead Prometheus’ default startup arguments.</p>

<p class="calibre3">We are specifying the route prefix (<code class="calibre19">ARG_WEB_ROUTE-PREFIX</code>) as well as the full external URL (<code class="calibre19">ARG_WEB_EXTERNAL-URL</code>).</p>

<blockquote class="calibre25">
  <p class="calibre3">Please visit <a href="http://monitor.dockerflow.com/config/#arg-variables">ARG Variables</a> section of the documentation for more information about environment variables that can be used as startup arguments.</p>
</blockquote>

<p class="calibre3">We also used the <code class="calibre19">com.df.*</code> service labels that will tell the proxy how to reconfigure itself so that Prometheus is available through the path <code class="calibre19">/monitor</code>.</p>

<p class="calibre3">The second service is <a href="http://swarmlistener.dockerflow.com/">Docker Flow Swarm Listener</a> that will listen to Swarm events and send reconfigure and remove requests to the monitor. You’ll see its usage later on. For now, just remember that we deployed it alongside the <code class="calibre19">monitor</code> service.</p>

<p class="calibre3">Let us deploy the new version of the monitor stack.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker stack rm monitor
<code class="lineno">2 </code>
<code class="lineno">3 </code><code class="nv">DOMAIN</code><code class="o">=</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code> <code class="se">\</code>
<code class="lineno">4 </code>    docker stack deploy <code class="se">\</code>
<code class="lineno">5 </code>    -c stacks/docker-flow-monitor-proxy.yml <code class="se">\</code>
<code class="lineno">6 </code>    monitor
</pre></div>

</figure>

<aside class="tip">
    <p class="calibre3">In the “real-world” situation, you should use your domain (e.g. <code class="calibre19">monitor.acme.com</code>) and would not need <code class="calibre19">ARG_WEB_ROUTE-PREFIX</code> and <code class="calibre19">com.df.servicePath</code> set to <code class="calibre19">/monitor</code>. However, since we do not have a domain for this exercise, we used the IP of <code class="calibre19">swarm-1</code> node instead.</p>

</aside>

<p class="calibre3">Please execute,
<code class="calibre19">docker stack ps monitor</code> 
to check the status of the stack. Once it’s up-and-running, we can confirm that the monitor is indeed integrated with the proxy.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>open <code class="s">"http://</code><code class="k">$(</code>docker-machine ip swarm-1<code class="k">)</code><code class="s">/monitor/flags"</code>
</pre></div>

</figure>

<p class="calibre3">By opening the <em class="calibre21">flags</em> screen, not only that we confirmed that the integration with <em class="calibre21">Docker Flow Proxy</em> worked but also that the arguments we specified as environment variables are properly propagated. You can observe that through the values of the <code class="calibre19">web.external-url</code> and <code class="calibre19">web.route-prefix</code> flags.</p>


<figure class="image">
  <img src="../images/00014.jpeg" alt="Figure 3-7: Prometheus flags screen with values passed through environment variables" class="calibre17"/>
  <figcaption class="calibre18">Figure 3-7: Prometheus flags screen with values passed through environment variables</figcaption>
</figure>


<p class="calibre3">Please note that we did not specify the port of the <code class="calibre19">monitor</code> service. As soon as the service was created, <code class="calibre19">swarm-listener</code> detected it and sent a request to the proxy to reconfigure itself. The information the proxy needs was obtained through the labels (e.g. <code class="calibre19">com.df.servicePath</code>).</p>

<p class="calibre3">There was a hidden reason behind the integration of the two. Apart from the need to have a proxy, I wanted to show you an existing implementation of the logic we are exploring. There was no need for a manual configuration of the proxy, nor we had to define the data proxy needs anywhere but inside the service definition itself. The <code class="calibre19">monitor</code> service contains all the information, and any other part of the system can fetch it. Everything related to the service is in a single location. By everything, I mean everything that we need for now. Later on, we’ll extend the definition of this and many other services.</p>

<aside class="tip">
    <p class="calibre3">Service labels are a precious asset that can be used as a single source of information for a service.</p>

</aside>

<h3 id="leanpub-auto-what-now-2" class="calibre20">What Now?</h3>

<p class="calibre3">Soon we’ll start exploring <em class="calibre21">exporters</em> and their integration with <em class="calibre21">Prometheus</em> and <em class="calibre21">Docker Flow Monitor</em>.</p>

<p class="calibre3">We’ll take a break and remove the machines we created. Every chapter will start from scratch. Don’t be scared. It’ll take only a couple of minutes to get back to the previous state.</p>

<figure class="code">
<div class="highlight"><pre class="calibre24"><code class="calibre19"/><code class="lineno">1 </code>docker-machine rm -f <code class="se">\</code>
<code class="lineno">2 </code>    swarm-1 swarm-2 swarm-3
</pre></div>

</figure>



</div>
</body></html>