- en: Orchestration - End-to-End Automation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '"The key to following the continuous delivery path is to continually question
    your own assumptions about what''s possible."'
  prefs: []
  type: TYPE_NORMAL
- en: '- Jeff Sussna'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will discuss different ways to automate application life
    cycle management, using orchestration available via open source and commercial
    alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: We will be using Jenkins plugins and Visual Studio Team Services tasks to orchestrate
    and automate all the activities that are performed during application life cycle
    management.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end automation orchestration of application life cycle management using
    Jenkins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end automation using Jenkins, Chef, and AWS EC2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end automation using Jenkins and AWS Elastic Beanstalk
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end automation using Jenkins and Microsoft Azure app services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end automation orchestration of application life cycle management using
    VSTS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end automation of application life cycle management using Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 2](part0047.html#1CQAE0-651ea628c0544d18a4415dfef8fe6271), *Continous
    Integration*, we created a build job that performs the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Static code analysis of the PetClinic web application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00194.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Successful execution of static code analysis will show a URL pointing to the
    SonaQube dashboard for a specific project in Jenkins dashboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verification of the Jenkins dashboard with all the analysis details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00206.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Compilation of source files and unit test execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Unit test results will be available in the Jenkins project dashboard itself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Creation of package files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once our package file is ready we can deploy it in the AWSEC2 instance, Microsoft
    Azure Virtual Machine, AWS Elastic Beanstalk, Microsoft Azure App Services, containers,
    or any physical machine that is accessible from the system that Jenkins is installed
    on.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end automation using Jenkins, Chef, and AWS EC2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will orchestrate different tasks using the Build Pipeline
    plugin available in Jenkins.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 4](part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271), *Cloud
    Computing and Configuration Management*, we installed a Chef workstation, configured
    the hosted Chef account, and installed knife plugins for AWS and Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created an instance in AWS EC2 using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We created a virtual machine in Microsoft Azure using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We verified the AWS EC2 instance and Microsoft Azure Virtual Machine registration
    in the hosted Chef.
  prefs: []
  type: TYPE_NORMAL
- en: We executed both the commands from the command prompt. In Jenkins, we can execute
    commands for Windows, Linux, or Mac. We can execute the same commands from a Jenkins
    build job by creating a freestyle job.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring SSH authentication using a key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A Chef workstation installed on a virtual machine is accessible from a system
    where we have installed Jenkins. We can create a virtual machine using a virtual
    box or a VMware workstation on a laptop; and can also then install CentOS 6 or
    7 and configure the Chef workstation the way we did in [Chapter 4](part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271),
    *Cloud Computing and Configuration Management*.
  prefs: []
  type: TYPE_NORMAL
- en: Before starting with the configuration of end-to-end automation and orchestration
    using a build pipeline plugin and upstream/downstream jobs, we will configure
    SSH authentication using a key.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main objective behind configuring SSH authentication is to allow the Jenkins
    virtual machine to connect to the Chef workstation virtual machine. By doing this
    we can execute commands from the Jenkins machine on the Chef workstation. This
    way we can create an instance in AWS or the Azure cloud using the Chef workstation,
    and install a runtime environment on it to deploy the PetClinic application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'If we try to access the Chef workstation from Jenkins, it won''t work, as we
    still need to configure a password-free configuration, because in the Jenkins
    job execution we can''t wait in the middle of a flow to give a password. Let''s
    configure password-free access on Jenkins to access the Chef workstation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a terminal in a virtual machine where Jenkins is installed. Use `ssh-keygen`
    to create a new key:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00016.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Verify the key on the local filesystem.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the key to the remote host where the Chef workstation is configured using
    `ssh-copy-id`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now try to access the Chef workstation VM using the Jenkins build job by executing
    commands from `execute` shell commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it fails, then try to access the Chef workstation from the Jenkins VM using
    the Terminal. If you get the Agent admitted failure to sign using key message,
    then execute the `ssh-add` command to fix the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the connection is successful in the Terminal, execute the `ifconfig` command
    to find the IP address so that we find out on which virtual machine that command
    is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00312.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: At this stage, our SSH connection is successful using a key that we created
    and configured instead of a password.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now we have access to the Chef workstation from Jenkins' VM so we can execute
    knife commands from Jenkins on the Chef workstation. Our next goal is to try to
    create an instance in AWS using the Jenkins build job and the Chef workstation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In a Jenkins build job, add a Build step, select Execute shell, and add the
    command shown here. We have already discussed `knife ec2` commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/00042.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Replace the Access Key ID and Secret Access Key with your own. Click on Save.
    Click on the Build now link to execute the build job.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to Console Output to check the progress:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00182.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Inspect the logs; AWS instance creation has started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify it in the AWS management console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00200.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Before execution can go further, check whether the AWS security group has an
    entry for SSH access:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00211.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once SSH access is available, it will start the Chef client installations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our case, it will start downloading the Chef client and installing it on
    the AWS instance that we have created using the Chef workstation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the Chef installation process on the console. Once the Chef client is
    installed on the AWS instance, it will start its first Chef client execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe the run list and synchronizing cookbooks. It will converge and start
    installing packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the package installations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will also display `conf.xml`, where port-related details can be verified
    based on the configuration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the package installation is finished, it will start service management.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, the Chef client execution has finished, and it will display related information
    for the AWS instance we created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00187.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Check the AWS management console for the successful status.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify the hosted Chef for the registered nodes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this stage, we have an AWS instance ready that has Tomcat and Java installed
    so we can deploy our application easily. Now, we have all the resources ready
    to configure the build pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to PetClinic-Code job and select Build other projects from add Post-build
    Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter PetClinic in Projects to build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00021.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here PetClinic-Code becomes an upstream project for PetClinic and PetClinic
    becomes a downstream project for PetClinic-Code. The Build Pipeline plugin needs
    relations established, using upstream and downstream projects for visualization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the PetClinic-Code job and select Build other projects from Add Post-build
    Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter PetClinic-CloudProvisioning in Projects to build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00032.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: If this build job has executed successfully, then it means the deployed virtual
    machine is ready with an installed runtime environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the PetClinic-CloudProvisioning job and select Build other projects from
    Add Post-build Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter PetClinic-Deploy in Projects to build:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the artifact copy operation has verified, configure the build job so we
    can deploy it as a manual operation. We will create a job with the String Parameter
    of a newly created instance''s domain name or IP address:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Configure the build job to execute deployment of a WAR file in an AWS instance
    by executing the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute this command from the Execute shell commands section in the Jenkins
    build job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00173.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once this build job ha executed successfully, it means that the application
    deployment is successful, so we can perform a functional test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure promotion on the PetClinic-FuncTest build using the Promotion plugin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00188.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After execution of PetClinic-FuncTest, our pipeline ends:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Save PetClinic-FuncTest and verify the upstream projects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install a Build Pipeline plugin from Manage Jenkins | Manage Plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the Jenkins Dashboard, click on the + sign.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Provide a View name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00215.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Select Initial Job in the Upstream / downstream config:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00116.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Click on Run to execute. Make sure that Tomcat and Sonar, which are configured
    in Jenkins, are running.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have configured PetClinic-Deploy as a downstream project in Build other
    projects (manual step). We have defined the parameters too:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Fig: Build pipeline for end-to-end automation of application life cycle management
  prefs: []
  type: TYPE_NORMAL
- en: 'Verify the parameter symbol:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00008.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Build pipeline with parameterized job'
  prefs: []
  type: TYPE_NORMAL
- en: Once the PetClinic-CloudProvisioning project has completed successfully, note
    the domain name and provide it as a default parameter in the PetClinic-Deploy
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Trigger:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00041.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Fig: Build pipeline with manual trigger'
  prefs: []
  type: TYPE_NORMAL
- en: Verify the end-to-end build pipeline execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So, with the use of the Build Pipeline plugin we can orchestrate the automation
    of different activities.
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end automation using Jenkins and AWS Elastic Beanstalk
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy the PetClinic Spring application in Amazon Elastic Beanstalk (PaaS),
    we need the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00166.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have PetClinic-Code, PetClinic, and PetClinic-Deploy-ElasticBeanstalk build
    jobs that we have created in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Configure PetClinic as a downstream job for PetClinic-Code; and configure PetClinic-Deploy-ElasticBeanstalk
    as a downstream job for the PetClinic build job.
  prefs: []
  type: TYPE_NORMAL
- en: End-to end aautomation using Jenkins and Microsoft Azure app services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To deploy thePetClinic Spring application in Microsoft Azure web apps (PaaS),
    we need the following flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00164.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have PetClinic-Code, PetClinic, and PetClinic-Deploy-Azure build jobs that
    we have created throughout this chapter. Configure PetClinic as a downstream job
    for PetClinic-Code; and configure PetClinic-Deploy-Azure as a downstream job for
    the PetClinic build job.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Microsoft Azure''s case, there is an alternative as well: we can use the
    Visual Studio Team server and TFS online for continuous integration, continuous
    delivery, and continuous deployment.'
  prefs: []
  type: TYPE_NORMAL
- en: End-to-end automation orchestration of application life cycle management using
    VSTS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In [Chapter 5](part0077.html#29DRA0-651ea628c0544d18a4415dfef8fe6271), *Continuous
    Delivery*, we saw how to deploy our web application using VSTS:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Releases and check the latest release definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look at the Build & Release column to verify the build number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double click on Release-22 to get more details on the release definition execution
    in VSTS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00170.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now let''s verify the details we have on the release definition execution in
    VSTS:'
  prefs: []
  type: TYPE_NORMAL
- en: In Details, verify the build number that triggered the execution of the release
    definition. It also provides details on the user who requested continuous deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The Environments section provides details on which the environment release
    definition has done deployment. It also shows the Deployment status: when the
    release definition was triggered, when it was completed, and whether or not there
    was any test execution. In our case, there are no test cases in the release definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00192.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: To get more details on the release definition execution, click on Logs. It will
    have a series of steps that have been executed during the release definition execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the approval mechanism is set, then it will ask for approval first; once
    approval is given, it will run on an agent. It will initialize the agent first;
    then, once the agent is available for the release definition execution, it will
    download the artifact or WAR file from the source folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We already know that we can't deploy the WAR file directly, so, based on our
    configuration, it will convert the WAR file into a ZIP file. Once we have a ZIP
    file of our package, then our Deploy Azure App Service task will deploy the application
    package into Azure Web Apps.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on each individual step to get a detailed log on the step execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see what the WAR Converter **/*.war step does.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Similarly, the Deploy Azure App Service step execution will give details on
    how the deployment process is executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00175.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As there is no Post-deployment approval configured, it is auto-approved and
    hence the build execution was successful:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00120.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We already know the Azure web application URL, or we can get it from the Azure
    portal. Visit it and check whether the application has deployed correctly or not.
  prefs: []
  type: TYPE_NORMAL
- en: So, up to this point, we have configured end-to-end automation for application
    life cycle management using continuous integration and continuous deployment.
  prefs: []
  type: TYPE_NORMAL
- en: We use deployment slots for different environments. So, we should create multiple
    environments here in the release definition and perform a deployment.
  prefs: []
  type: TYPE_NORMAL
- en: So, the next question should be how to create an environment so we can use it
    for package deployment in a specific deployment slot in Azure Web Apps?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the release definition, click on +Add environment and select Create new
    environment. We can select Clone selected environment if we want to use the same
    tasks of the existing environment in the new environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the new environment, let''s keep pre-deployment approval automatic:'
  prefs: []
  type: TYPE_NORMAL
- en: Select Trigger to Deploy automatically whenever a deployment to the environment
    Production is successful. We can rearrange or rename it once all the environments
    are configured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Hosted agent for the release definition execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Create.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the name of an environment by double-clicking on the Name of the environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Based on the environment, the rest of the deployment details can be configured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Change the existing environment name to Dev and click on (...). It will open
    a menu and select the Clone selected environment option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the case of a new environment, what if we want to keep approvals before the
    deployment process takes place?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Pre-deployment approval, select Specific users. All the users available
    in the VSTS account are eligible for approval rights. We can provide any name
    from that list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Trigger to Deploy automatically whenever a deployment to the environment
    Dev is successful. We can rearrange or rename it once all environments are configured.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Hosted agent for the release definition execution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on Create. Change the name of an environment as `QA` by double-clicking
    on the Name of the environment. Based on the environment, the rest of the deployment
    details can be configured:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00023.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Configure the UAT environment in a similar fashion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To assign approvals manually to any environment, select Environments, click
    on (...), and select Assign approvers....
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In Pre-deployment approval, we can specify users who can approve the execution
    of the release definition for the deployment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on OK.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to only configure where to deploy the WAR file in different environments
    that we have created recently:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00183.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with the Dev environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the Dev environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to Deploy Azure App Service task available in the release definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AzureRM Subscription and App Service Name are already configured, as we did
    that exercise earlier
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To deploy the WAR file into a specific slot, that is dev in this case, let's
    click on the Deploy to Slot checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will ask for the Resource Group: select the resource group from which the
    Azure web application is available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Slot list, all slots created for the Azure Web Apps will be listed. Select
    the dev slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep the rest of the details as they are and save the release definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00026.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s configure the QA environment:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the QA environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Deploy Azure App Service task available in the release definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: AzureRM Subscription and App Service Name are already configured as we did that
    exercise earlier too.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To deploy the WAR file into a specific slot, that is qa in this case, let's
    click on the Deploy to Slot checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will ask for the Resource Group: select the resource group from which the
    Azure web application is available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Slot list, all slots created for the Azure Web Apps will be listed. Select
    the qa slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep the rest of the details as they are and save the release definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00288.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To configure the UAT environment, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click on the UAT environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go to the Deploy Azure App Service task available in the release definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Azure RM Subscription and App Service Name are already configured, as we did
    that exercise earlier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To deploy the WAR file into a specific slot, that is `dev` in this case, let's
    click on the Deploy to Slot checkbox.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It will ask for the Resource Group: select the resource group in which the
    Azure Web App is available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Slot list, all slots created for the Azure Web Apps will be listed. Select
    the uat/stage slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Keep the rest of the details as they are and save the release definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00030.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'To deploy an application in the production slot or main Azure Web Apps, we
    need not select any slot. We just need to provide the Azure web application name
    and it will deploy into the main web application in Azure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Save the release definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the Release link:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We have set the approval process in the release definition execution so, until
    and unless the approver approves it, the execution of the release definition won't
    take place.
  prefs: []
  type: TYPE_NORMAL
- en: Look at the warning available in the summary section of the release definition
    execution. It says a pre-deployment approval is pending for the `dev` environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I have configured my own ID as the approver, the links are available to
    approve or reject the build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Let's click on the Approve or Reject link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It will open a small dialog box. We need to provide a comment in it and click
    on Approve or Reject. We can assign multiple approvers in this mechanism as well,
    and we can also set whether we want to have approval from either approver, or
    all approvers.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this case, we will click on Approve:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In Logs, now we can see that Pre-deployment approval has been given and the
    rest of the processes are about to be executed for application deployment in the
    Dev slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The artifact from the build definition will be downloaded so it can be converted
    to a ZIP file, and then we can deploy it into the Dev slot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00001.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Once deployment to the Dev environment is successful, the execution process
    will wait for the approval before it starts deployment into the QA slot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to provide approval to get the step execution going for the application
    deployment:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00044.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the releases, we can see that there are four different environments, as in
    our release definition we created those environments.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can see the current status of the release definition execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/00048.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Give approvals for the QA slot deployment and it will deploy a WAR file into
    the QA slot as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to remember that the process is going to be the same and nothing is
    going to change, except some parameters, during the application deployment in
    the different Azure web application deployment slots.
  prefs: []
  type: TYPE_NORMAL
- en: We need to remember that every slot is a live web application, so if we want
    to see where the application is deployed and what else is going on behind the
    scene, then we can go to the `Kudu` editor for each slot and verify that the operations
    have taken place for the deployment in each slot of the Azure web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, deploy into the UAT or Stage slot and Production slot too:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00050.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, as an exercise on your own, commit some changes in the code of the application
    and observe how the build definition is executed; how it triggers the release
    definition after successful execution of the build job; and how an application
    is deployed on different slots. Once that is done, visit a specific URL of the
    deployment slot of an Azure web application and check whether the application
    deployment in different environments has been successful or not.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to automate different tasks that are part
    of application life cycle management.
  prefs: []
  type: TYPE_NORMAL
- en: We have deployed an application using Jenkins on AWS and Microsoft Azure Cloud
    service providers. We used the Chef configuration management tool for installing
    runtime environment.
  prefs: []
  type: TYPE_NORMAL
- en: We also deployed an application on AWS Elastic Beanstalk using Jenkins, and
    used Visual Studio Team Services for end-to-end automation for deploying the application
    in Azure App Services, which is a PaaS offering from Microsoft.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn more about configuring security and monitoring
    related details. We will look further at role-based access to resources available
    in Jenkins, VSTS and Microsoft Azure.
  prefs: []
  type: TYPE_NORMAL
