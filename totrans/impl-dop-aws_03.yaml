- en: Chapter 3.  Bringing Your Infrastructure Under Configuration Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三章：将你的基础设施纳入配置管理
- en: As hinted at the end of the previous chapter, there is some more work to be
    done before we can claim to have fully implemented IaC.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 正如上一章结尾所暗示的那样，在我们能够宣称完全实现基础设施即代码（IaC）之前，还需要做一些工作。
- en: The first step was to describe the hardware side of our infrastructure in code;
    now it is time to look at the software or configuration aspect of it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是将我们基础设施的硬件部分描述成代码；现在是时候关注它的软件或配置部分了。
- en: Let us say we have provisioned a few EC2 nodes and would like to have certain
    packages installed on them, and relevant configuration files updated. Prior to
    **Configuration Management** (**CM**) tools gaining popularity, such tasks would
    have been performed manually by an engineer either following a checklist, running
    a collection of shell scripts, or both. As you can imagine, such methods do not
    scale well as they generally imply one engineer setting up one server at a time.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已经配置了几个 EC2 节点，并希望在它们上安装某些软件包，并更新相关的配置文件。在**配置管理**（**CM**）工具流行之前，这类任务通常是由工程师手动执行的，工程师要么按照检查清单操作，要么运行一系列
    Shell 脚本，或者两者兼而有之。正如你所想象的那样，这种方法扩展性较差，因为通常意味着一个工程师一次设置一台服务器。
- en: 'In addition, checklists or scripts:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，检查清单或脚本：
- en: Are hard to write when it comes to configuring a host plus a full application
    stack running on it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当涉及到配置主机以及在其上运行的完整应用程序栈时，编写脚本是非常困难的。
- en: Are usually targeted at a given host or application and are not very portable
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常是针对特定主机或应用程序的，且不具备很好的可移植性。
- en: Get progressively harder to comprehend the further you get from the person who
    originally wrote them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 越是远离最初编写它们的人，理解起来就越困难。
- en: Build scripts tend to get executed only once, usually at the time a host is
    provisioned, thus configuration starts to drift from that moment on
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建脚本通常只会在主机配置时执行一次，因此配置会从那时起开始漂移。
- en: 'Fortunately, not many people use these nowadays, as Configuration Management
    has become a common practice. Let us examine some of the benefits:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，现在很少有人使用这些，因为配置管理已经成为一种常见做法。让我们来看一下它的一些好处：
- en: CM allows us to declare the desired state of a machine once and then reproduce
    that state as often as necessary
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CM 使我们能够一次性声明机器的期望状态，然后根据需要反复重现该状态。
- en: Powerful abstraction takes care of specifics such as environment, hardware,
    and OS type, allowing us to write reusable CM code
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强大的抽象层处理了环境、硬件和操作系统类型等具体细节，使我们能够编写可重用的 CM 代码。
- en: The declared machine state code is easy to read, comprehend, and collaborate
    on.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明的机器状态代码易于阅读、理解和协作。
- en: A CM deployment can be performed on tens, hundreds, or thousands of machines
    simultaneously
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CM 部署可以同时在数十台、数百台或数千台机器上执行。
- en: In this age of DevOps, there are a variety of CM tools to choose from. You might
    have already heard of Puppet, Chef, Ansible, OpsWorks, or the one we are going
    to use-**SaltStack** (**the Salt Open project**).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DevOps 时代，有许多 CM 工具可以选择。你可能已经听说过 Puppet、Chef、Ansible、OpsWorks，或者我们将要使用的**SaltStack**（**Salt
    Open 项目**）。
- en: All of these are well developed, sophisticated CM solutions with active communities
    behind them. I find it hard to justify any reported claims of one being better
    than the rest as they all do the job pretty well, each with its own set of strengths
    and weaknesses. So which one you use, as is often the case, is up to personal
    preference.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是成熟且复杂的 CM 解决方案，背后有活跃的社区支持。我很难证明有任何一个比其他的更好，因为它们都能很好地完成工作，各有自己的优缺点。所以，最终选择使用哪一个，通常取决于个人偏好。
- en: 'Regardless of the tool you end up using, I would like to stress the importance
    of two points: naming conventions and code reusability.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你最终使用哪个工具，我想强调两点的重要性：命名规范和代码重用性。
- en: 'Following naming conventions when writing code is an obvious win as it guarantees
    other people will be able to understand your work with less effort. In addition
    to writing code however, CM involves executing it against your nodes and this
    is where naming also becomes important. Imagine you had four servers: **leonardo**,
    **donatello**, **michelangelo**, and **raphael**. Two of those are your frontend
    layer and two the backend, so you sit down and write your Configuration Management
    manifests respectively: *webserver-node* and *database-node*. So far, so good,
    given the number of hosts you can launch your CM tool and easily tell it to run
    the relevant manifest against each of them.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写代码时遵循命名约定显然是一个优势，因为它能保证其他人理解你的工作时所需的努力更少。然而，除了编写代码，CM 还涉及到对节点执行代码，而这时命名变得尤为重要。想象一下你有四台服务器：**leonardo**、**donatello**、**michelangelo**
    和 **raphael**。其中两台是前端层，两台是后端层，于是你坐下来分别为它们编写配置管理清单：*webserver-node* 和 *database-node*。到目前为止，一切都很好，考虑到主机数量，你可以启动你的
    CM 工具，并轻松地告诉它在每台机器上运行相应的清单。
- en: Now imagine 50, then 100 hosts, within a similar flat-naming schema, and you
    start to see the problem. As the size and complexity of your infrastructure grows,
    you will need a host-naming convention that naturally forms a hierarchy. Hostnames
    such as *webserver-{0..10}*, *db-{0..5}* and *cache-{0..5}* can be further grouped
    into frontend and backend and then represented in a structured, hierarchical way.
    Such a way of grouping nodes based on role or other properties is extremely useful
    when applying Configuration Management.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下 50 台，然后是 100 台主机，采用类似的扁平命名模式，你就会开始看到问题。当你的基础设施的规模和复杂性增加时，你将需要一种能够自然形成层次结构的主机命名约定。像
    *webserver-{0..10}*、*db-{0..5}* 和 *cache-{0..5}* 这样的主机名可以进一步分组为前端和后端，然后以结构化、层次化的方式表示。基于角色或其他属性对节点进行分组的这种方式，在应用配置管理时极为有用。
- en: Code reusability should already be on your mind when you start writing CM code
    (manifests). You will find that there are generally two ways of approaching this
    task. You could write a large, say, web server piece which contains instructions
    on how to set up the firewall, some CLI tools, NGINX, and PHP on a node, or you
    could break it down into smaller parts like iptables, utils, NGINX, PHP, and so
    on.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编写 CM 代码（清单）时，你应该已经开始考虑代码的重用性。你会发现，一般有两种方式来处理这个任务。你可以写一个大型的，例如，包含设置防火墙、一些
    CLI 工具、NGINX 和 PHP 的 web 服务器部分，或者你可以将其拆分为更小的部分，比如 iptables、utils、NGINX、PHP 等等。
- en: In my opinion, the latter design adds some overhead when writing the manifests,
    but the benefit of reusability is substantial. Instead of writing large sets of
    declarations dedicated to each server type, you maintain a collection of generic,
    small ones and cherry-pick from them to suit the machine in question.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，后者的设计在编写清单时增加了一些开销，但重用性的好处是相当可观的。与其为每种服务器类型编写一大堆特定的声明，不如维护一组通用的小声明，并从中挑选出适合当前机器的部分。
- en: 'To illustrate:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子：
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Or better:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 或者更好的方法是：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Introduction to SaltStack
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SaltStack 入门
- en: '**SaltStack** (see [https://saltstack.com/](https://saltstack.com/)), first
    released in 2011, is an automation suite which offers Configuration Management
    plus standard and/or event-driven orchestration. It is commonly used in a master-minion
    setup, where a master node provides centralized control across a compute estate.
    It is known for its speed and scalability thanks to the fast and lightweight message
    bus (**ZeroMQ**) used for communication between the salt-master and minions. It
    can also be used in an agentless fashion, where the minions are controlled over
    SSH, similarly to how Ansible operates.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**SaltStack**（见 [https://saltstack.com/](https://saltstack.com/)），首次发布于 2011
    年，是一个自动化套件，提供配置管理以及标准的和/或事件驱动的编排。它通常在主从架构中使用，其中主节点提供跨计算资源的集中控制。得益于用于盐主与从节点之间通信的快速且轻量级的消息总线（**ZeroMQ**），它以其速度和可扩展性而著称。它也可以以无代理的方式使用，在这种方式下，从节点通过
    SSH 被控制，这与 Ansible 的操作方式类似。'
- en: SaltStack is written in Python and is easily extensible. You can write your
    own modules for it, attach long-running processes to its event bus, and inject
    raw Python code in unusual places.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack 是用 Python 编写的，且易于扩展。你可以为其编写自己的模块，将长期运行的进程附加到它的事件总线上，并在不寻常的地方注入原始的
    Python 代码。
- en: The master-minion model is quite powerful, offers a lot of flexibility, and
    is the recommended approach if you are looking after anything more than a few
    dev nodes and want to take advantage of all the features SaltStack has to offer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 主从模型非常强大，提供了很多灵活性，如果你需要管理的不仅仅是几个开发节点，并且想充分利用 SaltStack 的所有功能，这是推荐的方式。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More on how to get a salt-master up and running can be found here: [https://docs.saltstack.com/en/latest/topics/configuration/index.html](https://docs.saltstack.com/en/latest/topics/configuration/index.html)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何启动和运行 salt-master 的更多信息可以在这里找到：[https://docs.saltstack.com/en/latest/topics/configuration/index.html](https://docs.saltstack.com/en/latest/topics/configuration/index.html)
- en: In our case, we are going to explore the power of Configuration Management using
    SaltStack in a standalone or masterless mode. We will reuse parts of the Terraform
    template from the previous chapter to launch a set of EC2 resources, bootstrap
    a SaltStack minion and have it configure itself to serve a web application.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们将探索使用 SaltStack 进行配置管理的强大功能，使用独立模式或无主模式。我们将复用上一章中的部分 Terraform 模板，启动一组
    EC2 资源，启动一个 SaltStack minion，并让它自行配置，以便提供 Web 应用程序服务。
- en: Provided all goes well, we should end up with a fully configured web server
    (EC2 node) behind a load-balancer (EC2 ELB).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们最终应该能够在负载均衡器（EC2 ELB）后面配置一个完全设置好的 Web 服务器（EC2 节点）。
- en: 'Here is our task-list:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们的任务列表：
- en: Prepare our SaltStack development environment.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备我们的 SaltStack 开发环境。
- en: Write the configuration that we would like SaltStack to apply to our node(s).
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写我们希望 SaltStack 应用到节点的配置。
- en: Compose the Terraform template describing our infrastructure.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写描述我们基础设施的 Terraform 模板。
- en: Deploy the infrastructure via Terraform and let SaltStack configure it.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过 Terraform 部署基础设施，并让 SaltStack 配置它。
- en: Preparation
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备
- en: 'SaltStack Configuration Management is performed using the following main components:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack 配置管理通过以下主要组件进行：
- en: '**States** are the files which describe the desired state of a machine. Here
    we write instructions for installing packages, modifying files, updating permissions,
    and so on.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**States** 是描述机器期望状态的文件。在这里，我们编写安装包、修改文件、更新权限等操作的指令。'
- en: '**Pillars** are the files in which we define variables to help make States
    more portable and flexible.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pillars** 是我们定义变量的文件，帮助让 States 更加便捷和灵活。'
- en: '**Grains** are pieces of information gathered on the minion host itself. These
    include details about the OS, environment, the hardware platform, and others.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Grains** 是在 minion 主机上收集的信息。这些信息包括操作系统、环境、硬件平台等详细信息。'
- en: The **Salt File Server** stores any files, scripts, or other artifacts which
    may be referenced in the States.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Salt 文件服务器** 存储任何可能在 States 中引用的文件、脚本或其他工件。'
- en: The Salt Top file(s) are used to map States and/or Pillars to minions.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Salt Top 文件用于将 States 和/或 Pillars 映射到 minions。
- en: In a master-minion setup, all of these components except the Grains would be
    hosted on and made available to the minions by the salt-master (other backends
    are also supported).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在主从模式下，除了 Grains 以外，所有这些组件都将由 salt-master 托管，并提供给 minions（其他后端也受到支持）。
- en: We are planning to run Salt in masterless mode however, meaning that we will
    need a way to transfer any States, Pillars, and related files from our local environment
    to the minion. Git? Good idea. We will write all Salt code locally, push it to
    a Git repository, and then have it checked out onto each minion at boot time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计划以无主模式运行 Salt，这意味着我们需要一种方式将任何 States、Pillars 和相关文件从本地环境传输到 minion。Git？好主意。我们将在本地编写所有
    Salt 代码，将其推送到 Git 仓库，然后在每个 minion 启动时将其检出。
- en: As for choosing a Git hosting solution, Github or Bitbucket are excellent services,
    but giving our minion EC2 nodes access to these will involve some key handling.
    In comparison, **CodeCommit** (the AWS Git solution) offers a much smoother integration
    with EC2 instances via IAM Roles.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 关于选择 Git 托管解决方案，Github 或 Bitbucket 都是非常优秀的服务，但让我们的 minion EC2 节点访问这些服务需要一些密钥管理。相比之下，**CodeCommit**（AWS
    的 Git 解决方案）通过 IAM 角色与 EC2 实例的集成更为顺畅。
- en: 'Let us start by creating a new IAM user and a CodeCommit Git repository. We
    will be using the user''s access keys to create the repository and a SSH key to
    clone and work with it:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的 IAM 用户和一个 CodeCommit Git 仓库。我们将使用用户的访问密钥来创建仓库，并使用 SSH 密钥克隆并与之工作：
- en: In the AWS Console, create an IAM user (write down the generated access keys)
    and attach the **AWSCodeCommitFullAccess** built-in / **Managed** IAM policy to
    it as shown in the following screenshot:![Preparation](img/image_02_004.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS控制台中，创建一个IAM用户（记下生成的访问密钥），并将**AWSCodeCommitFullAccess**内置/ **托管** IAM策略附加到它，如下图所示：![Preparation](img/image_02_004.jpg)
- en: On the same page, switch to the **Security Credentials** tab and click on the
    **Upload SSH public key** as shown in the following screenshot:![Preparation](img/image_03_002.jpg)
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一页面上，切换到**安全凭证**选项卡，并点击**上传SSH公钥**，如下面的截图所示：![Preparation](img/image_03_002.jpg)
- en: 'Configure `awscli`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 配置`awscli`：
- en: '[PRE2]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a repository:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个仓库：
- en: '[PRE3]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Clone the new repository locally:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本地克隆新仓库：
- en: '[PRE4]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, `SSH_KEY_ID` is the one we saw after uploading a public key in step 2.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`SSH_KEY_ID`是我们在步骤2上传公钥后看到的那个。
- en: Note
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more options on connecting to CodeCommit see [http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up.html](http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up.html)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有关连接到CodeCommit的更多选项，请参见[http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up.html](http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up.html)
- en: We are ready to start populating our empty, new Salt repository.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们准备开始填充我们空的、新的Salt仓库。
- en: Writing Configuration Management code
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写配置管理代码
- en: For SaltStack to help us configure our node as a web server, we need to tell
    it what one of those should look like. In Configuration Management terms, we need
    to describe the desired state of the machine.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让SaltStack帮助我们将节点配置为Web服务器，我们需要告诉它这些应该是什么样的。在配置管理术语中，我们需要描述机器的期望状态。
- en: 'In our example, we will be using a combination of SaltStack States, Pillars,
    Grains, and Top files to describe the processes of:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们将使用SaltStack状态、Pillars、Grains和Top文件的组合来描述以下过程：
- en: Creating Linux user accounts
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Linux用户帐户
- en: Installing services (NGINX and PHP-FPM)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装服务（NGINX和PHP-FPM）
- en: Configuring and running the installed services
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和运行已安装的服务
- en: States
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态
- en: A State contains a set of instructions which we would like to be applied to
    our EC2 minion(s). We will use `/srv/salt/states` on the minion as the root of
    the Salt State tree. States can be stored in there in the form of a single file,
    for example `/srv/salt/states/mystate.sls`, or organized into folders like so
    `/srv/salt/states/mystate/init.sls` . Later on, when we request that `mystate`
    is executed, Salt will look for either a `state_name.sls` or a `state_name/init.sls`
    in the root of the *State Tree*. I find the second approach tidier as it allows
    for other state-related files to be kept in the relevant folder.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个状态包含一组我们希望应用于EC2从节点的指令。我们将在从节点上使用`/srv/salt/states`作为Salt状态树的根目录。状态可以以单个文件的形式存储在其中，例如`/srv/salt/states/mystate.sls`，或者组织成文件夹，如`/srv/salt/states/mystate/init.sls`。稍后，当我们请求执行`mystate`时，Salt将查找状态树根目录中的`state_name.sls`或`state_name/init.sls`。我觉得第二种方式更整洁，因为它允许将其他与状态相关的文件保存在相关的文件夹中。
- en: 'We begin the Configuration Management of our web server node with a state for
    managing Linux user accounts. Inside our Salt Git repository, we create `states/users/init.sls`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从管理Linux用户帐户的状态开始配置我们的Web服务器节点。在我们的Salt Git仓库中，我们创建`states/users/init.sls`：
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/users](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/users).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/users](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/users)。
- en: '[PRE5]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We will use YAML to write most Salt configuration. You will notice three different
    state modules used in the preceding section:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用YAML编写大多数Salt配置。你会注意到在前一部分使用了三种不同的状态模块：
- en: '`user.present`: This module ensures that a given user account exists on the
    system or creates one if necessary'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user.present`：此模块确保指定的用户帐户在系统上存在，或在必要时创建该帐户'
- en: '`ssh_auth.present`: A module for managing the SSH `authorized_keys` file of
    a user'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ssh_auth.present`：用于管理用户SSH `authorized_keys`文件的模块'
- en: '`file.managed`: A module for creating/modifying files'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`file.managed`：用于创建/修改文件的模块'
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SaltStack's state modules offer rich functionality. For full details of each
    module see [https://docs.saltstack.com/en/latest/ref/states/all/](https://docs.saltstack.com/en/latest/ref/states/all/)
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack的状态模块提供了丰富的功能。有关每个模块的详细信息，请参见[https://docs.saltstack.com/en/latest/ref/states/all/](https://docs.saltstack.com/en/latest/ref/states/all/)
- en: To avoid hardcoding certain values under `user.present`, we make use of the
    SaltStack Pillars system. We will examine a pillar file shortly, but for now just
    note the syntax of referencing pillar values inside our state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在`user.present`下硬编码某些值，我们利用了SaltStack的Pillars系统。我们稍后会查看一个pillar文件，但现在只需注意在我们的状态中引用pillar值的语法。
- en: Two other points of interest here are the source of our key file and the `require`
    property. In this example, a `salt://` formatted source address refers to the
    Salt File Server which by default serves files from the State Tree (for supported
    backends, please see [https://docs.saltstack.com/en/latest/ref/file_server/](https://docs.saltstack.com/en/latest/ref/file_server/)).
    The `require` statement enforces an order of execution, ensuring that the user
    account is present before trying to create an `authorized_keys` file for it.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有另外两个要点值得关注：我们密钥文件的来源和`require`属性。在这个例子中，`salt://`格式的源地址指向Salt文件服务器，默认情况下从状态树中提供文件（有关支持的后端，请参见
    [https://docs.saltstack.com/en/latest/ref/file_server/](https://docs.saltstack.com/en/latest/ref/file_server/)）。`require`语句强制执行执行顺序，确保在尝试为其创建`authorized_keys`文件之前，用户帐户已经存在。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SaltStack follows an imperative execution model until such custom ordering is
    enforced, invoking a declarative mode (see [https://docs.saltstack.com/en/latest/ref/states/ordering.html](https://docs.saltstack.com/en/latest/ref/states/ordering.html)).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SaltStack 遵循一种命令式执行模型，直到强制执行自定义顺序时，才会调用声明式模式（见 [https://docs.saltstack.com/en/latest/ref/states/ordering.html](https://docs.saltstack.com/en/latest/ref/states/ordering.html)）。
- en: 'Thanks to the readability of YAML, one can easily tell what is going on here:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 得益于YAML的可读性，人们可以轻松地看出这里发生了什么：
- en: We create a new Linux user.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个新的Linux用户。
- en: We apply desired attributes (uid, password, group, and so on).
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们应用所需的属性（uid、密码、组等）。
- en: We deploy an SSH `authorized_keys` file for it.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为其部署一个SSH `authorized_keys`文件。
- en: We enable `sudo` for the wheel group of which the user is a member.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为用户所在的wheel组启用`sudo`。
- en: Perhaps you could try *edit this state* and *add a user* for yourself? It will
    be useful later after we deploy.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 或许你可以尝试*编辑这个状态*并为自己*添加一个用户*？这在我们部署之后会很有用。
- en: We will now move on to an NGINX installation via `states/nginx/init.sls`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将继续进行NGINX的安装，通过`states/nginx/init.sls`。
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/nginx](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/nginx).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/nginx](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/nginx)。
- en: 'We install NGINX using the `pkg.installed` module:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`pkg.installed`模块安装NGINX：
- en: '`pkg.installed: []`'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`pkg.installed: []`'
- en: 'Set the service to start on boot (`enable: True`), enable reloading instead
    of restarting when possible (`reload: True`), ensure the NGINX pkg has been installed
    (`require:`) before running the service (`service.running:`)'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '设置服务在启动时启动（`enable: True`），在可能的情况下启用重新加载而不是重新启动（`reload: True`），确保在运行服务（`service.running:`）之前安装了NGINX软件包（`require:`）。'
- en: '[PRE6]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then put a `config` file in place (`file.managed:`), ensuring the service waits
    for this to happen (`require_in:`) and also reloads each time the file is updated
    (`watch_in:`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 然后放置一个`config`文件（`file.managed:`），确保服务等待这个文件的存在（`require_in:`），并在每次文件更新时重新加载（`watch_in:`）：
- en: '[PRE7]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note the `require`/`require_in`, `watch`/`watch_in` pairs. The difference between
    each of these requisites and its `_in` counterpart lies in the direction in which
    they act.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意`require`/`require_in`和`watch`/`watch_in`的配对。每对中每个要求与其`_in`对应物的区别在于它们作用的方向。
- en: 'For example:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 例如：
- en: '[PRE8]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Has the same effect as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与以下效果相同：
- en: '[PRE9]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In both cases, the NGINX service restarts on `config` file changes; however,
    you can see how the second format can be potentially quite useful the further
    you get from the service block-say in a different file, as we will see in the
    next state.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，NGINX服务会在`config`文件更改时重新启动；然而，你可以看到第二种格式在你离开服务块（例如在不同的文件中）时可能会变得非常有用，正如我们将在下一个状态中看到的那样。
- en: 'Add in some PHP (`states/php-fpm/init.sls`):'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些PHP（`states/php-fpm/init.sls`）：
- en: Note
  id: totrans-105
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/php-fpm](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/php-fpm).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/php-fpm](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/php-fpm)。
- en: '[PRE10]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here you can better see the usefulness of an `_in` requisite. After we include
    the `nginx` state at the top, our `require_in` makes sure that `nginx` does not
    start before `php-fpm` does.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以更好地看到 `_in` 必要条件的有用性。当我们在顶部包含 `nginx` state 后，`require_in` 会确保 `nginx`
    在 `php-fpm` 启动之前不会启动。
- en: With NGINX and PHP-FPM now configured, let us add a quick test page (`states/phptest/init.sls`).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 配置好 NGINX 和 PHP-FPM 后，我们来添加一个简单的测试页面（`states/phptest/init.sls`）。
- en: Note
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/phptest](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/phptest).'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/phptest](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/phptest)。
- en: 'We set a few variables pulled from Grains (more on those shortly):'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了一些从 Grains 中提取的变量（稍后会详细介绍）：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then we deploy the test page and add `contents` to it directly:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们部署测试页面并直接向其中添加 `contents`：
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We will use this page post-deployment to check whether both NGINX and PHP-FPM
    are operational.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在部署后使用此页面检查 NGINX 和 PHP-FPM 是否正常运行。
- en: Pillars
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Pillars
- en: 'Now let us look at the main mechanism for storing variables in Salt-the Pillars.
    These are:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们来看一下 Salt 存储变量的主要机制——Pillars。它们是：
- en: YAML tree-like data structures
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类似树状的数据结构
- en: Defined/rendered on the salt-master, unless running masterless in which case
    they live on the minion
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 salt-master 上定义/渲染，除非在无主模式下运行，此时它们存在于 minion 上
- en: Useful for storing variables in a central place to be shared by the minions
    (unless they are masterless)
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于在中央位置存储变量，以便 minions 共享（除非它们是无主模式的）
- en: Helpful for keeping States portable
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有助于保持 States 的可移植性
- en: Appropriate for sensitive data (they can also be GPG encrypted; see [https://docs.saltstack.com/en/latest/ref/renderers/all/salt.renderers.gpg.html](https://docs.saltstack.com/en/latest/ref/renderers/all/salt.renderers.gpg.html))
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 适用于敏感数据（它们也可以进行 GPG 加密；请参见 [https://docs.saltstack.com/en/latest/ref/renderers/all/salt.renderers.gpg.html](https://docs.saltstack.com/en/latest/ref/renderers/all/salt.renderers.gpg.html)）
- en: 'We will be using `/srv/salt/pillars` as the root of our Pillar tree on the
    minion. Let us go back to the `users` state and examine the following lines:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 minion 上使用 `/srv/salt/pillars` 作为 Pillar 树的根目录。让我们回到 `users` state，查看以下几行：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `uid` and `password` attributes are set to be sourced from a pillar named
    `users`. And if we check our Pillar Tree, we find a `/srv/salt/pillars/users.sls`
    file containing:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`uid` 和 `password` 属性设置为从名为 `users` 的 pillar 中获取。如果我们检查我们的 Pillar 树，将会找到一个
    `/srv/salt/pillars/users.sls` 文件，其中包含：'
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It is now easy to see how the `users:veselin:password` reference inside the
    state file matches against this pillar's structure.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以轻松看到 `users:veselin:password` 在 state 文件中的引用是如何与该 pillar 结构匹配的。
- en: Note
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more details and examples on pillar usage, see: [https://docs.saltstack.com/en/latest/topics/tutorials/pillar.html](https://docs.saltstack.com/en/latest/topics/tutorials/pillar.html)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 pillar 使用的更多详细信息和示例，请参见：[https://docs.saltstack.com/en/latest/topics/tutorials/pillar.html](https://docs.saltstack.com/en/latest/topics/tutorials/pillar.html)
- en: Grains
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Grains
- en: 'Unlike Pillars, Grains are considered static data:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Pillars 不同，Grains 被认为是静态数据：
- en: They get generated minion-side and are not shared between different minions
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们在 minion 端生成，且不会在不同的 minions 之间共享
- en: They contain facts about the minion itself
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们包含关于 minion 本身的事实
- en: Typical examples are CPU, OS, network interfaces, memory, and kernels
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型示例有 CPU、操作系统、网络接口、内存和内核
- en: It is possible to add custom Grains to a minion
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以为一个 minion 添加自定义 Grains
- en: 'We have already made good use of Grains within our preceding test page (`states/phptest/init.sls`),
    getting various host details such as CPU, memory, network, and OS. Another way
    of using this data is when dealing with multi-OS environments. Let us look at
    the following example:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在前面的测试页面（`states/phptest/init.sls`）中很好地使用了 Grains，获取了包括 CPU、内存、网络和操作系统等各种主机详细信息。使用这些数据的另一种方式是在处理多操作系统环境时。我们来看下面的示例：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you see, Grains, much like Pillars, help make our States way more flexible.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，Grains 与 Pillars 类似，帮助使我们的 States 更加灵活。
- en: Top files
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Top 文件
- en: We now have our States ready, even supported by some Pillars and ideally would
    like to apply all of those to a host so we can get it configured and ready for
    use.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了 States，甚至支持了一些 Pillars，并且理想情况下希望将所有这些应用到主机上，以便进行配置并准备好使用。
- en: In SaltStack, the Top File provides the mapping between States/Pillars and the
    minions they should be applied onto. We have a Top file (`top.sls`) in the root
    of both the state and pillar trees. We happen to have a single environment (base),
    but we could easily add more (*dev*, *qa*, *prod*). Each could have a separate
    state and pillar trees with separate Top files which get compiled into one at
    runtime.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SaltStack 中，Top 文件提供了 States/Pillars 和它们应该应用的守卫之间的映射关系。我们在状态树和支柱树的根目录中都有一个
    Top 文件（`top.sls`）。我们碰巧只有一个环境（base），但我们可以轻松地添加更多（*dev*、*qa*、*prod*）。每个环境都可以有独立的状态和支柱树，以及独立的
    Top 文件，这些文件会在运行时编译成一个文件。
- en: Note
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please see [https://docs.saltstack.com/en/latest/ref/states/top.html](https://docs.saltstack.com/en/latest/ref/states/top.html)
    for more information on multi-environment setups.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于多环境设置的信息，请参见 [https://docs.saltstack.com/en/latest/ref/states/top.html](https://docs.saltstack.com/en/latest/ref/states/top.html)。
- en: 'Let us look at a `top.sls` example:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 `top.sls` 示例：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We are declaring that in our base (default) environment:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明在我们的基本（默认）环境中：
- en: All minions should have the core set of utilities, the monitoring and log forwarding
    agents installed
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有守卫应该安装核心工具集、监控和日志转发代理。
- en: Minions with an ID matching `webserver-*`, get the `nginx` and `php-fpm` States
    (in addition to the previous three)
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配 `webserver-*` 的守卫，将获得 `nginx` 和 `php-fpm` 状态（除了之前的三个）。
- en: 'Database nodes get applied: the common three plus `pgsql_server` and `pgbouncer`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库节点应用：三个常见的节点加上 `pgsql_server` 和 `pgbouncer`
- en: Minion targeting gets even more interesting when you include Pillars, Grains,
    or a mix of these (see [https://docs.saltstack.com/en/latest/ref/states/top.html#advanced-minion-targeting](https://docs.saltstack.com/en/latest/ref/states/top.html#advanced-minion-targeting)).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你包含 Pillars、Grains 或这些的混合时，守卫的目标定位变得更加有趣（请参见 [https://docs.saltstack.com/en/latest/ref/states/top.html#advanced-minion-targeting](https://docs.saltstack.com/en/latest/ref/states/top.html#advanced-minion-targeting)）。
- en: By specifying such state/pillar to a minion association, from a security standpoint
    we also create a useful isolation. Say our Pillars contained sensitive data, then
    this is how we could limit the group of minions who are allowed access to it.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过指定这样的状态/支柱与守卫的关联，从安全角度来看，我们也创建了一个有用的隔离。假设我们的 Pillars 包含敏感数据，那么我们可以通过这种方式限制可以访问这些数据的守卫群体。
- en: 'Back to our Salt repository, where we find two `top.sls` files:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的 Salt 仓库，我们发现有两个 `top.sls` 文件：
- en: '`salt/states/top.sls`:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salt/states/top.sls`：'
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '`salt/pillars/top.sls`:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`salt/pillars/top.sls`：'
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can allow ourselves to target `*`, as we are running in masterless mode and
    essentially all our States/Pillars are intended for the local minion.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以允许自己使用 `*` 作为目标，因为我们在无主模式下运行，实际上我们所有的 States/Pillars 都是针对本地守卫的。
- en: We enable this mode with a few settings in a minion configuration file (`/etc/salt/minion.d/masterless.conf`).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在守卫配置文件（`/etc/salt/minion.d/masterless.conf`）中设置几个选项来启用此模式。
- en: Note
  id: totrans-160
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_03_CodeFiles/CodeCommit/salt/minion.d/masterless.conf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_03_CodeFiles/CodeCommit/salt/minion.d/masterless.conf).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_03_CodeFiles/CodeCommit/salt/minion.d/masterless.conf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_03_CodeFiles/CodeCommit/salt/minion.d/masterless.conf)。
- en: These effectively tell the salt-minion process that the Salt Fileserver, the
    state tree and the pillar tree are all to be found on the local filesystem. You
    will see how this configuration file gets deployed via UserData in a moment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这些有效地告诉盐守卫进程，Salt 文件服务器、状态树和支柱树都位于本地文件系统中。稍后你将看到如何通过 UserData 部署此配置文件。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'More on running masterless can be found at: [https://docs.saltstack.com/en/latest/topics/tutorials/standalone_minion.html](https://docs.saltstack.com/en/latest/topics/tutorials/standalone_minion.html)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于运行无主模式的信息，请访问：[https://docs.saltstack.com/en/latest/topics/tutorials/standalone_minion.html](https://docs.saltstack.com/en/latest/topics/tutorials/standalone_minion.html)
- en: This concludes our SaltStack internals session. As you get more comfortable,
    you may want to look into Salt Engines, Beacons, writing your own modules and/or
    Salt Formulas. And those are only some of the ninja features being constantly
    added to the project.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这结束了我们的 SaltStack 内部工作会议。当你更熟悉后，你可能想深入了解 Salt 引擎、Beacons、自定义模块和/或 Salt 配方。这些只是项目中不断添加的“忍者”功能的一部分。
- en: At this stage we already know how to use Terraform to deploy and now SaltStack
    to configure.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一阶段，我们已经知道如何使用 Terraform 来部署，现在使用 SaltStack 来进行配置。
- en: Bootstrapping nodes under Configuration Management (end-to-end IaC)
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在配置管理下启动节点（端到端 IaC）
- en: Without further delay, let us get our old VPC re-deployed along with a configuration-managed
    web service inside it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 不再耽搁，让我们重新部署旧的 VPC，并在其中配置一个配置管理的 web 服务。
- en: Terraform will spawn the VPC, ELB, and EC2 nodes then bootstrap the SaltStack
    workflow with the use of EC2 UserData. Naturally, we strive to reuse as much code
    as possible; however, our next deployment requires some changes to the TF templates.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Terraform 将创建 VPC、ELB 和 EC2 节点，然后通过 EC2 UserData 引导 SaltStack 工作流。自然地，我们力求复用尽可能多的代码；然而，我们的下一次部署需要对
    TF 模板进行一些修改。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform).'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform)。
- en: '`resources.tf`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`resources.tf`：'
- en: We do not need the private subnets/route tables, NAT, nor RDS resources this
    time, so we have removed these, making the deployment a bit faster.
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这次我们不需要私有子网/路由表、NAT，也不需要 RDS 资源，因此我们已将这些内容移除，使得部署速度稍微加快了一些。
- en: We will be using an IAM Role to grant permission to the EC2 node to access the
    CodeCommit repository.
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用 IAM 角色授予 EC2 节点访问 CodeCommit 仓库的权限。
- en: 'We have declared the role:'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已声明了角色：
- en: '[PRE19]'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have added and associated a policy (granting read access to CodeCommit)
    with that role:'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已为该角色添加并关联了一个策略（授予对 CodeCommit 的读取权限）：
- en: '[PRE20]'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We have created and associated an instance profile with the role:'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已为该角色创建并关联了实例配置文件：
- en: '[PRE21]'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have updated the Auto Scaling launch-configuration with the instance profile
    ID:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已更新 Auto Scaling 启动配置，加入了实例配置文件 ID：
- en: '[PRE22]'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We have updated the UserData script with some SaltStack bootstrap instructions,
    to install Git and SaltStack, checkout and put our Salt code in place and finally
    run Salt:'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们已更新了 UserData 脚本，加入了部分 SaltStack 引导指令，用于安装 Git 和 SaltStack，检出并部署我们的 Salt 代码，最后运行
    Salt：
- en: '[PRE23]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`variables.tf`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '`variables.tf`：'
- en: We have removed all RDS related variables.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已移除所有与 RDS 相关的变量。
- en: '`outputs.tf`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`outputs.tf`：'
- en: We have removed RDS and NAT related outputs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已移除与 RDS 和 NAT 相关的输出。
- en: '`iam_user_policy.json`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`iam_user_policy.json`：'
- en: This document will become useful shortly as we will need to create a new user
    for the deployment. We have removed RDS permissions and added IAM ones from it.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这份文档很快会派上用场，因为我们需要为部署创建一个新用户。我们已移除 RDS 权限，并从中添加了 IAM 权限。
- en: 'We are now ready for deployment. Pre-flight check:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好进行部署了。飞行前检查：
- en: Updated Terraform templates
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新了 Terraform 模板
- en: Note
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform))
    are available locally in our designated terraform folder'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请参阅：[https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform)）这些文件已在我们指定的
    terraform 文件夹中本地保存。
- en: Created/updated our Terraform IAM account with the new set of permissions as
    per `iam_user_policy.json`
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据 `iam_user_policy.json` 中的新权限集，创建/更新了我们的 Terraform IAM 账户。
- en: Ensured we have a copy of the `terraform ec2 keypair` (for SSH-ing later)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保我们拥有 `terraform ec2 keypair` 的副本（以后用于 SSH 登录）
- en: 'All our SaltStack code has been pushed up to the Salt CodeCommit repository
    (Please refer to: [https://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt))'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的所有 SaltStack 代码已推送到 Salt CodeCommit 仓库中（请参阅：[https://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt)）
- en: 'Let us export our credentials and launch Terraform:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们导出凭据并启动 Terraform：
- en: '[PRE24]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Allow 3-5 minutes for output `t2.nano` to come into shape and then browse to
    the ELB URI from the following output:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 请等待 3-5 分钟，直到输出的 `t2.nano` 实例就绪，然后从以下输出的 ELB URI 进行访问：
- en: '![Bootstrapping nodes under Configuration Management (end-to-end IaC)](img/image_03_003.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![在配置管理下启动节点（端到端 IaC）](img/image_03_003.jpg)'
- en: Victory!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 胜利！
- en: Try increasing the *autoscaling-group-minsize* and *autoscaling-group-maxsize*
    in `terraform.tfvars`, then re-applying the template. You should start seeing
    different IPs when the page is refreshed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在 `terraform.tfvars` 中增加 *autoscaling-group-minsize* 和 *autoscaling-group-maxsize*
    的值，然后重新应用模板。刷新页面后，你应该能看到不同的 IP 地址。
- en: Given the preceding test page, we can be reasonably confident that Salt bootstrapped
    and applied our set of States successfully.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 根据前面的测试页面，我们可以合理地相信Salt已经成功地引导并应用了我们的States配置。
- en: We did, however, enable SSH access in order to be able to experiment more with
    Salt, so let us do that.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们确实启用了SSH访问，以便能更进一步地实验Salt，所以让我们开始吧。
- en: We see the public IP of the node on our test page. You could SSH into it with
    either the `terraform ec2 keypair` or the default `ec2-user` Linux account, or
    if you dared create one for yourself in the `users/init.sls` state earlier, you
    could use it now.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在测试页面上看到了节点的公共IP。您可以使用`terraform ec2 keypair`或者默认的`ec2-user` Linux账户通过SSH登录，或者如果您之前在`users/init.sls`状态中为自己创建了一个账户，现在也可以使用它。
- en: 'Once connected, we can use the `salt-call` command (as root) to interact with
    Salt locally:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，我们可以使用`salt-call`命令（以root身份）与Salt进行本地交互：
- en: 'How about some Pillars:'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 那么，Pillars呢：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Or let us see what Grains we have:'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或者让我们看看有什么Grains可用：
- en: '[PRE26]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Run individual States:'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行单独的States：
- en: '[PRE27]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Or execute a full run, that is of all assigned States as per the Top file:'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 或执行完整的运行，即根据Top文件执行所有分配的States：
- en: '[PRE28]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After playing with our new deployment for a bit, I suspect you are going to
    want to try adding or changing States/Pillars or other parts of the Salt code.
    As per the IaC rules we agreed upon earlier, every change we make goes through
    Git, but let us examine what options we have for deploying those changes afterwards:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试了一段时间的新部署后，我猜您会想尝试添加或更改States/Pillars或Salt代码的其他部分。根据我们之前商定的IaC规则，我们做的每个更改都需要通过Git，但让我们检查一下之后部署这些更改的选项：
- en: Pull the changes down to each minion and run `salt-call`
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将更改拉取到每个minion并运行`salt-call`
- en: Provision new minions which will pull down the latest code
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置新的minions，拉取最新的代码
- en: Push changes via a Salt-master
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Salt-master推送更改
- en: It is easy to see that the first option will work with the couple of nodes we
    use for testing, but is quickly going to become hard to manage at scale.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出，第一种选项在我们用于测试的几个节点上会有效，但在大规模使用时很快就会变得难以管理。
- en: Provisioning new minions on each deployment is a valid option if masterless
    Salt setup is preferred; however, you need to consider the frequency of deployments
    in your environment and the associated cost of replacing EC2 nodes. One benefit
    worth nothing here is that of blue/green deployments. By provisioning new minions
    to serve your code changes, you get to keep the old ones around for a while which
    allows you to shift traffic gradually and roll back safely if needed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 每次部署时配置新的minions是一个有效的选项，如果更倾向于使用无主Salt设置；然而，您需要考虑您环境中部署的频率以及替换EC2节点的相关成本。这里值得一提的一个好处是蓝绿部署。通过配置新的minions来服务您的代码更改，您可以保留旧的minions一段时间，这样可以逐步切换流量，并在需要时安全地回滚。
- en: Having a Salt-master would be my recommended approach for any non-dev environments.
    The Salt code is kept on it, so any Git changes you make, need to be pulled down
    only once. You can then deploy the changed States/Pillars by targeting the minions
    you want from the Salt-master. You could still do blue/green for major releases
    or you could choose to deploy to your current minions directly if it is just a
    minor, safe amendment, or perhaps something critical that needs to reach all minions
    as soon as possible.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个Salt-master是我推荐的任何非开发环境的方式。Salt代码保存在其中，因此您所做的任何Git更改，只需要拉取一次。然后，您可以通过Salt-master部署已更改的States/Pillars到您想要的minions。您仍然可以对重大版本使用蓝绿部署，或者如果只是一个小的安全修复或可能需要立即传递给所有minions的关键更改，您也可以直接部署到当前的minions。
- en: Another powerful feature of the Salt-master is orchestration, more specifically-remote
    execution. With all your minions connected to it, the salt-master becomes a command
    center from which you have more or less full control over them.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Salt-master的另一个强大功能是协调，具体来说是远程执行。通过将所有的minion连接到它，salt-master成为一个指挥中心，从中你可以或多或少地完全控制它们。
- en: 'Executing commands on the minions is done via modules from generic ones such
    as `cmd.run`, which essentially allows you to run arbitrary shell commands to
    more specialized ones such as `nginx`, `postfix`, `selinux`, or `zfs`. The list
    is quite long as you can see here: [https://docs.saltstack.com/en/latest/ref/modules/all/index.html](https://docs.saltstack.com/en/latest/ref/modules/all/index.html).'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在minions上执行命令是通过模块完成的，从通用的`cmd.run`模块（本质上允许您运行任意的shell命令）到更专业的模块，如`nginx`、`postfix`、`selinux`或`zfs`。正如您在这里看到的，模块列表相当长：[https://docs.saltstack.com/en/latest/ref/modules/all/index.html](https://docs.saltstack.com/en/latest/ref/modules/all/index.html)。
- en: 'And if you recall the earlier section on hostnames and naming conventions,
    this is where one can appreciate their value. It is quite convenient to be able
    to execute statements like:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得之前关于主机名和命名约定的部分，你会更能体会到它们的价值。在此，能够执行如下命令非常方便：
- en: '[PRE29]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You can also use Pillars and/or Grains to add tags to your hosts, so you could
    further group them per location, role, department, or something similar.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以使用 Pillars 和/或 Grains 给你的主机添加标签，以便你可以根据位置、角色、部门或类似的条件进一步将它们分组。
- en: 'In brief, here are a few key points of masterless versus a salt-master arrangement:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，以下是 masterless 和 salt-master 布局的一些关键点：
- en: '| **Salt Master** | **Masterless** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '| **Salt Master** | **Masterless** |'
- en: '|'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: A powerful, centralized control platform (must be secured adequately) which
    allows for quick, parallel access to a vast network of minions
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个强大的集中式控制平台（必须得到充分安全保护），允许快速并行地访问庞大的 minions 网络
- en: Advanced features such as Salt Engines, Runners, Beacons, the Reactor System
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级功能，如 Salt 引擎、Runners、Beacons、反应器系统
- en: API access
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 访问
- en: '|'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: No salt-master node to maintain
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无需维护 salt-master 节点
- en: Not having a single node which provides full access to the rest of them is more
    secure in some sense
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 没有一个节点提供对其他所有节点的完全访问权限，从某种意义上来说，这更安全
- en: Simpler Salt operation
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更简便的 Salt 操作
- en: After the initial Salt execution, the minions can be considered immutable
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在初始的 Salt 执行后，minions 可以被视为不可变的
- en: '|'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: For many *FOR LOOP gurus* out there, parallel execution tools like Salt are
    very appealing. It allows you to rapidly reach out to nodes at a massive scale,
    whether you simply want to query their uptime, reload a service, or react to a
    threat alert by stopping sshd across your cluster.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多 *FOR LOOP 大师* 来说，像 Salt 这样的并行执行工具非常有吸引力。它允许你以大规模迅速访问节点，无论你是想查询它们的运行时间、重新加载服务，还是在发生威胁警报时通过停止集群中的
    sshd 来做出反应。
- en: Note
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Before you go, please remember to delete any AWS resources used in the preceding
    examples (VPC, ELB, EC2, IAM, CodeCommit, and so on) to avoid unexpected charges.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在你离开之前，请记得删除前面示例中使用的任何 AWS 资源（VPC、ELB、EC2、IAM、CodeCommit 等），以避免产生意外费用。
- en: Summary
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we examined the second part of *Infrastructure as Code*, namely
    **Configuration Management**.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了 *基础设施即代码* 的第二部分，即 **配置管理**。
- en: 'We learned about a few different components of the CM solution SaltStack: States,
    Pillars, Grains, and the Top File. We learned how to use them and how to write
    code for them.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 我们了解了 CM 解决方案 SaltStack 的几个不同组件：States、Pillars、Grains 和 Top File。我们学习了如何使用它们以及如何为它们编写代码。
- en: We then combined our previous knowledge of how to deploy infrastructure using
    Terraform with that of how to configure it using SaltStack, resulting in our first
    end-to-end IaC deployment.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将之前使用 Terraform 部署基础设施的知识与使用 SaltStack 配置基础设施的知识结合起来，最终完成了我们的第一次端到端 IaC
    部署。
- en: 'Next, we are going to look into *Continuous Integration*: what it is and how
    to setup a *CI* pipeline on AWS.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将深入探讨 *持续集成*：它是什么，如何在 AWS 上设置 *CI* 管道。
