- en: Chapter 3.  Bringing Your Infrastructure Under Configuration Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As hinted at the end of the previous chapter, there is some more work to be
    done before we can claim to have fully implemented IaC.
  prefs: []
  type: TYPE_NORMAL
- en: The first step was to describe the hardware side of our infrastructure in code;
    now it is time to look at the software or configuration aspect of it.
  prefs: []
  type: TYPE_NORMAL
- en: Let us say we have provisioned a few EC2 nodes and would like to have certain
    packages installed on them, and relevant configuration files updated. Prior to
    **Configuration Management** (**CM**) tools gaining popularity, such tasks would
    have been performed manually by an engineer either following a checklist, running
    a collection of shell scripts, or both. As you can imagine, such methods do not
    scale well as they generally imply one engineer setting up one server at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition, checklists or scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: Are hard to write when it comes to configuring a host plus a full application
    stack running on it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are usually targeted at a given host or application and are not very portable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get progressively harder to comprehend the further you get from the person who
    originally wrote them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build scripts tend to get executed only once, usually at the time a host is
    provisioned, thus configuration starts to drift from that moment on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Fortunately, not many people use these nowadays, as Configuration Management
    has become a common practice. Let us examine some of the benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: CM allows us to declare the desired state of a machine once and then reproduce
    that state as often as necessary
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Powerful abstraction takes care of specifics such as environment, hardware,
    and OS type, allowing us to write reusable CM code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The declared machine state code is easy to read, comprehend, and collaborate
    on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A CM deployment can be performed on tens, hundreds, or thousands of machines
    simultaneously
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this age of DevOps, there are a variety of CM tools to choose from. You might
    have already heard of Puppet, Chef, Ansible, OpsWorks, or the one we are going
    to use-**SaltStack** (**the Salt Open project**).
  prefs: []
  type: TYPE_NORMAL
- en: All of these are well developed, sophisticated CM solutions with active communities
    behind them. I find it hard to justify any reported claims of one being better
    than the rest as they all do the job pretty well, each with its own set of strengths
    and weaknesses. So which one you use, as is often the case, is up to personal
    preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the tool you end up using, I would like to stress the importance
    of two points: naming conventions and code reusability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following naming conventions when writing code is an obvious win as it guarantees
    other people will be able to understand your work with less effort. In addition
    to writing code however, CM involves executing it against your nodes and this
    is where naming also becomes important. Imagine you had four servers: **leonardo**,
    **donatello**, **michelangelo**, and **raphael**. Two of those are your frontend
    layer and two the backend, so you sit down and write your Configuration Management
    manifests respectively: *webserver-node* and *database-node*. So far, so good,
    given the number of hosts you can launch your CM tool and easily tell it to run
    the relevant manifest against each of them.'
  prefs: []
  type: TYPE_NORMAL
- en: Now imagine 50, then 100 hosts, within a similar flat-naming schema, and you
    start to see the problem. As the size and complexity of your infrastructure grows,
    you will need a host-naming convention that naturally forms a hierarchy. Hostnames
    such as *webserver-{0..10}*, *db-{0..5}* and *cache-{0..5}* can be further grouped
    into frontend and backend and then represented in a structured, hierarchical way.
    Such a way of grouping nodes based on role or other properties is extremely useful
    when applying Configuration Management.
  prefs: []
  type: TYPE_NORMAL
- en: Code reusability should already be on your mind when you start writing CM code
    (manifests). You will find that there are generally two ways of approaching this
    task. You could write a large, say, web server piece which contains instructions
    on how to set up the firewall, some CLI tools, NGINX, and PHP on a node, or you
    could break it down into smaller parts like iptables, utils, NGINX, PHP, and so
    on.
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, the latter design adds some overhead when writing the manifests,
    but the benefit of reusability is substantial. Instead of writing large sets of
    declarations dedicated to each server type, you maintain a collection of generic,
    small ones and cherry-pick from them to suit the machine in question.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Introduction to SaltStack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SaltStack** (see [https://saltstack.com/](https://saltstack.com/)), first
    released in 2011, is an automation suite which offers Configuration Management
    plus standard and/or event-driven orchestration. It is commonly used in a master-minion
    setup, where a master node provides centralized control across a compute estate.
    It is known for its speed and scalability thanks to the fast and lightweight message
    bus (**ZeroMQ**) used for communication between the salt-master and minions. It
    can also be used in an agentless fashion, where the minions are controlled over
    SSH, similarly to how Ansible operates.'
  prefs: []
  type: TYPE_NORMAL
- en: SaltStack is written in Python and is easily extensible. You can write your
    own modules for it, attach long-running processes to its event bus, and inject
    raw Python code in unusual places.
  prefs: []
  type: TYPE_NORMAL
- en: The master-minion model is quite powerful, offers a lot of flexibility, and
    is the recommended approach if you are looking after anything more than a few
    dev nodes and want to take advantage of all the features SaltStack has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More on how to get a salt-master up and running can be found here: [https://docs.saltstack.com/en/latest/topics/configuration/index.html](https://docs.saltstack.com/en/latest/topics/configuration/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: In our case, we are going to explore the power of Configuration Management using
    SaltStack in a standalone or masterless mode. We will reuse parts of the Terraform
    template from the previous chapter to launch a set of EC2 resources, bootstrap
    a SaltStack minion and have it configure itself to serve a web application.
  prefs: []
  type: TYPE_NORMAL
- en: Provided all goes well, we should end up with a fully configured web server
    (EC2 node) behind a load-balancer (EC2 ELB).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our task-list:'
  prefs: []
  type: TYPE_NORMAL
- en: Prepare our SaltStack development environment.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write the configuration that we would like SaltStack to apply to our node(s).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compose the Terraform template describing our infrastructure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deploy the infrastructure via Terraform and let SaltStack configure it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SaltStack Configuration Management is performed using the following main components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**States** are the files which describe the desired state of a machine. Here
    we write instructions for installing packages, modifying files, updating permissions,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pillars** are the files in which we define variables to help make States
    more portable and flexible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grains** are pieces of information gathered on the minion host itself. These
    include details about the OS, environment, the hardware platform, and others.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **Salt File Server** stores any files, scripts, or other artifacts which
    may be referenced in the States.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Salt Top file(s) are used to map States and/or Pillars to minions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a master-minion setup, all of these components except the Grains would be
    hosted on and made available to the minions by the salt-master (other backends
    are also supported).
  prefs: []
  type: TYPE_NORMAL
- en: We are planning to run Salt in masterless mode however, meaning that we will
    need a way to transfer any States, Pillars, and related files from our local environment
    to the minion. Git? Good idea. We will write all Salt code locally, push it to
    a Git repository, and then have it checked out onto each minion at boot time.
  prefs: []
  type: TYPE_NORMAL
- en: As for choosing a Git hosting solution, Github or Bitbucket are excellent services,
    but giving our minion EC2 nodes access to these will involve some key handling.
    In comparison, **CodeCommit** (the AWS Git solution) offers a much smoother integration
    with EC2 instances via IAM Roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us start by creating a new IAM user and a CodeCommit Git repository. We
    will be using the user''s access keys to create the repository and a SSH key to
    clone and work with it:'
  prefs: []
  type: TYPE_NORMAL
- en: In the AWS Console, create an IAM user (write down the generated access keys)
    and attach the **AWSCodeCommitFullAccess** built-in / **Managed** IAM policy to
    it as shown in the following screenshot:![Preparation](img/image_02_004.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the same page, switch to the **Security Credentials** tab and click on the
    **Upload SSH public key** as shown in the following screenshot:![Preparation](img/image_03_002.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Configure `awscli`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Clone the new repository locally:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `SSH_KEY_ID` is the one we saw after uploading a public key in step 2.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more options on connecting to CodeCommit see [http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up.html](http://docs.aws.amazon.com/codecommit/latest/userguide/setting-up.html)
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to start populating our empty, new Salt repository.
  prefs: []
  type: TYPE_NORMAL
- en: Writing Configuration Management code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For SaltStack to help us configure our node as a web server, we need to tell
    it what one of those should look like. In Configuration Management terms, we need
    to describe the desired state of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we will be using a combination of SaltStack States, Pillars,
    Grains, and Top files to describe the processes of:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating Linux user accounts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Installing services (NGINX and PHP-FPM)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring and running the installed services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: States
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A State contains a set of instructions which we would like to be applied to
    our EC2 minion(s). We will use `/srv/salt/states` on the minion as the root of
    the Salt State tree. States can be stored in there in the form of a single file,
    for example `/srv/salt/states/mystate.sls`, or organized into folders like so
    `/srv/salt/states/mystate/init.sls` . Later on, when we request that `mystate`
    is executed, Salt will look for either a `state_name.sls` or a `state_name/init.sls`
    in the root of the *State Tree*. I find the second approach tidier as it allows
    for other state-related files to be kept in the relevant folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin the Configuration Management of our web server node with a state for
    managing Linux user accounts. Inside our Salt Git repository, we create `states/users/init.sls`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/users](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/users).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will use YAML to write most Salt configuration. You will notice three different
    state modules used in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '`user.present`: This module ensures that a given user account exists on the
    system or creates one if necessary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ssh_auth.present`: A module for managing the SSH `authorized_keys` file of
    a user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`file.managed`: A module for creating/modifying files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SaltStack's state modules offer rich functionality. For full details of each
    module see [https://docs.saltstack.com/en/latest/ref/states/all/](https://docs.saltstack.com/en/latest/ref/states/all/)
  prefs: []
  type: TYPE_NORMAL
- en: To avoid hardcoding certain values under `user.present`, we make use of the
    SaltStack Pillars system. We will examine a pillar file shortly, but for now just
    note the syntax of referencing pillar values inside our state.
  prefs: []
  type: TYPE_NORMAL
- en: Two other points of interest here are the source of our key file and the `require`
    property. In this example, a `salt://` formatted source address refers to the
    Salt File Server which by default serves files from the State Tree (for supported
    backends, please see [https://docs.saltstack.com/en/latest/ref/file_server/](https://docs.saltstack.com/en/latest/ref/file_server/)).
    The `require` statement enforces an order of execution, ensuring that the user
    account is present before trying to create an `authorized_keys` file for it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SaltStack follows an imperative execution model until such custom ordering is
    enforced, invoking a declarative mode (see [https://docs.saltstack.com/en/latest/ref/states/ordering.html](https://docs.saltstack.com/en/latest/ref/states/ordering.html)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Thanks to the readability of YAML, one can easily tell what is going on here:'
  prefs: []
  type: TYPE_NORMAL
- en: We create a new Linux user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We apply desired attributes (uid, password, group, and so on).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We deploy an SSH `authorized_keys` file for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We enable `sudo` for the wheel group of which the user is a member.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perhaps you could try *edit this state* and *add a user* for yourself? It will
    be useful later after we deploy.
  prefs: []
  type: TYPE_NORMAL
- en: We will now move on to an NGINX installation via `states/nginx/init.sls`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/nginx](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/nginx).
  prefs: []
  type: TYPE_NORMAL
- en: 'We install NGINX using the `pkg.installed` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '`pkg.installed: []`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Set the service to start on boot (`enable: True`), enable reloading instead
    of restarting when possible (`reload: True`), ensure the NGINX pkg has been installed
    (`require:`) before running the service (`service.running:`)'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then put a `config` file in place (`file.managed:`), ensuring the service waits
    for this to happen (`require_in:`) and also reloads each time the file is updated
    (`watch_in:`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note the `require`/`require_in`, `watch`/`watch_in` pairs. The difference between
    each of these requisites and its `_in` counterpart lies in the direction in which
    they act.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Has the same effect as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In both cases, the NGINX service restarts on `config` file changes; however,
    you can see how the second format can be potentially quite useful the further
    you get from the service block-say in a different file, as we will see in the
    next state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add in some PHP (`states/php-fpm/init.sls`):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/php-fpm](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/php-fpm).'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here you can better see the usefulness of an `_in` requisite. After we include
    the `nginx` state at the top, our `require_in` makes sure that `nginx` does not
    start before `php-fpm` does.
  prefs: []
  type: TYPE_NORMAL
- en: With NGINX and PHP-FPM now configured, let us add a quick test page (`states/phptest/init.sls`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/phptest](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/CodeCommit/salt/states/phptest).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We set a few variables pulled from Grains (more on those shortly):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we deploy the test page and add `contents` to it directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We will use this page post-deployment to check whether both NGINX and PHP-FPM
    are operational.
  prefs: []
  type: TYPE_NORMAL
- en: Pillars
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now let us look at the main mechanism for storing variables in Salt-the Pillars.
    These are:'
  prefs: []
  type: TYPE_NORMAL
- en: YAML tree-like data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defined/rendered on the salt-master, unless running masterless in which case
    they live on the minion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Useful for storing variables in a central place to be shared by the minions
    (unless they are masterless)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Helpful for keeping States portable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Appropriate for sensitive data (they can also be GPG encrypted; see [https://docs.saltstack.com/en/latest/ref/renderers/all/salt.renderers.gpg.html](https://docs.saltstack.com/en/latest/ref/renderers/all/salt.renderers.gpg.html))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will be using `/srv/salt/pillars` as the root of our Pillar tree on the
    minion. Let us go back to the `users` state and examine the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `uid` and `password` attributes are set to be sourced from a pillar named
    `users`. And if we check our Pillar Tree, we find a `/srv/salt/pillars/users.sls`
    file containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It is now easy to see how the `users:veselin:password` reference inside the
    state file matches against this pillar's structure.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For more details and examples on pillar usage, see: [https://docs.saltstack.com/en/latest/topics/tutorials/pillar.html](https://docs.saltstack.com/en/latest/topics/tutorials/pillar.html)'
  prefs: []
  type: TYPE_NORMAL
- en: Grains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike Pillars, Grains are considered static data:'
  prefs: []
  type: TYPE_NORMAL
- en: They get generated minion-side and are not shared between different minions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They contain facts about the minion itself
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typical examples are CPU, OS, network interfaces, memory, and kernels
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is possible to add custom Grains to a minion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have already made good use of Grains within our preceding test page (`states/phptest/init.sls`),
    getting various host details such as CPU, memory, network, and OS. Another way
    of using this data is when dealing with multi-OS environments. Let us look at
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you see, Grains, much like Pillars, help make our States way more flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Top files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now have our States ready, even supported by some Pillars and ideally would
    like to apply all of those to a host so we can get it configured and ready for
    use.
  prefs: []
  type: TYPE_NORMAL
- en: In SaltStack, the Top File provides the mapping between States/Pillars and the
    minions they should be applied onto. We have a Top file (`top.sls`) in the root
    of both the state and pillar trees. We happen to have a single environment (base),
    but we could easily add more (*dev*, *qa*, *prod*). Each could have a separate
    state and pillar trees with separate Top files which get compiled into one at
    runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Please see [https://docs.saltstack.com/en/latest/ref/states/top.html](https://docs.saltstack.com/en/latest/ref/states/top.html)
    for more information on multi-environment setups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a `top.sls` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We are declaring that in our base (default) environment:'
  prefs: []
  type: TYPE_NORMAL
- en: All minions should have the core set of utilities, the monitoring and log forwarding
    agents installed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minions with an ID matching `webserver-*`, get the `nginx` and `php-fpm` States
    (in addition to the previous three)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Database nodes get applied: the common three plus `pgsql_server` and `pgbouncer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minion targeting gets even more interesting when you include Pillars, Grains,
    or a mix of these (see [https://docs.saltstack.com/en/latest/ref/states/top.html#advanced-minion-targeting](https://docs.saltstack.com/en/latest/ref/states/top.html#advanced-minion-targeting)).
  prefs: []
  type: TYPE_NORMAL
- en: By specifying such state/pillar to a minion association, from a security standpoint
    we also create a useful isolation. Say our Pillars contained sensitive data, then
    this is how we could limit the group of minions who are allowed access to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back to our Salt repository, where we find two `top.sls` files:'
  prefs: []
  type: TYPE_NORMAL
- en: '`salt/states/top.sls`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '`salt/pillars/top.sls`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can allow ourselves to target `*`, as we are running in masterless mode and
    essentially all our States/Pillars are intended for the local minion.
  prefs: []
  type: TYPE_NORMAL
- en: We enable this mode with a few settings in a minion configuration file (`/etc/salt/minion.d/masterless.conf`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_03_CodeFiles/CodeCommit/salt/minion.d/masterless.conf](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_03_CodeFiles/CodeCommit/salt/minion.d/masterless.conf).'
  prefs: []
  type: TYPE_NORMAL
- en: These effectively tell the salt-minion process that the Salt Fileserver, the
    state tree and the pillar tree are all to be found on the local filesystem. You
    will see how this configuration file gets deployed via UserData in a moment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More on running masterless can be found at: [https://docs.saltstack.com/en/latest/topics/tutorials/standalone_minion.html](https://docs.saltstack.com/en/latest/topics/tutorials/standalone_minion.html)'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our SaltStack internals session. As you get more comfortable,
    you may want to look into Salt Engines, Beacons, writing your own modules and/or
    Salt Formulas. And those are only some of the ninja features being constantly
    added to the project.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage we already know how to use Terraform to deploy and now SaltStack
    to configure.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping nodes under Configuration Management (end-to-end IaC)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Without further delay, let us get our old VPC re-deployed along with a configuration-managed
    web service inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Terraform will spawn the VPC, ELB, and EC2 nodes then bootstrap the SaltStack
    workflow with the use of EC2 UserData. Naturally, we strive to reuse as much code
    as possible; however, our next deployment requires some changes to the TF templates.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform).'
  prefs: []
  type: TYPE_NORMAL
- en: '`resources.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: We do not need the private subnets/route tables, NAT, nor RDS resources this
    time, so we have removed these, making the deployment a bit faster.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will be using an IAM Role to grant permission to the EC2 node to access the
    CodeCommit repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We have declared the role:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We have added and associated a policy (granting read access to CodeCommit)
    with that role:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We have created and associated an instance profile with the role:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We have updated the Auto Scaling launch-configuration with the instance profile
    ID:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'We have updated the UserData script with some SaltStack bootstrap instructions,
    to install Git and SaltStack, checkout and put our Salt code in place and finally
    run Salt:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`variables.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: We have removed all RDS related variables.
  prefs: []
  type: TYPE_NORMAL
- en: '`outputs.tf`:'
  prefs: []
  type: TYPE_NORMAL
- en: We have removed RDS and NAT related outputs.
  prefs: []
  type: TYPE_NORMAL
- en: '`iam_user_policy.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: This document will become useful shortly as we will need to create a new user
    for the deployment. We have removed RDS permissions and added IAM ones from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready for deployment. Pre-flight check:'
  prefs: []
  type: TYPE_NORMAL
- en: Updated Terraform templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Please refer to: [https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform](https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_03_CodeFiles/Terraform))
    are available locally in our designated terraform folder'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Created/updated our Terraform IAM account with the new set of permissions as
    per `iam_user_policy.json`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensured we have a copy of the `terraform ec2 keypair` (for SSH-ing later)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All our SaltStack code has been pushed up to the Salt CodeCommit repository
    (Please refer to: [https://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt](https://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt))'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let us export our credentials and launch Terraform:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Allow 3-5 minutes for output `t2.nano` to come into shape and then browse to
    the ELB URI from the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrapping nodes under Configuration Management (end-to-end IaC)](img/image_03_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Victory!
  prefs: []
  type: TYPE_NORMAL
- en: Try increasing the *autoscaling-group-minsize* and *autoscaling-group-maxsize*
    in `terraform.tfvars`, then re-applying the template. You should start seeing
    different IPs when the page is refreshed.
  prefs: []
  type: TYPE_NORMAL
- en: Given the preceding test page, we can be reasonably confident that Salt bootstrapped
    and applied our set of States successfully.
  prefs: []
  type: TYPE_NORMAL
- en: We did, however, enable SSH access in order to be able to experiment more with
    Salt, so let us do that.
  prefs: []
  type: TYPE_NORMAL
- en: We see the public IP of the node on our test page. You could SSH into it with
    either the `terraform ec2 keypair` or the default `ec2-user` Linux account, or
    if you dared create one for yourself in the `users/init.sls` state earlier, you
    could use it now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once connected, we can use the `salt-call` command (as root) to interact with
    Salt locally:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How about some Pillars:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Or let us see what Grains we have:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Run individual States:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Or execute a full run, that is of all assigned States as per the Top file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'After playing with our new deployment for a bit, I suspect you are going to
    want to try adding or changing States/Pillars or other parts of the Salt code.
    As per the IaC rules we agreed upon earlier, every change we make goes through
    Git, but let us examine what options we have for deploying those changes afterwards:'
  prefs: []
  type: TYPE_NORMAL
- en: Pull the changes down to each minion and run `salt-call`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Provision new minions which will pull down the latest code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Push changes via a Salt-master
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to see that the first option will work with the couple of nodes we
    use for testing, but is quickly going to become hard to manage at scale.
  prefs: []
  type: TYPE_NORMAL
- en: Provisioning new minions on each deployment is a valid option if masterless
    Salt setup is preferred; however, you need to consider the frequency of deployments
    in your environment and the associated cost of replacing EC2 nodes. One benefit
    worth nothing here is that of blue/green deployments. By provisioning new minions
    to serve your code changes, you get to keep the old ones around for a while which
    allows you to shift traffic gradually and roll back safely if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Having a Salt-master would be my recommended approach for any non-dev environments.
    The Salt code is kept on it, so any Git changes you make, need to be pulled down
    only once. You can then deploy the changed States/Pillars by targeting the minions
    you want from the Salt-master. You could still do blue/green for major releases
    or you could choose to deploy to your current minions directly if it is just a
    minor, safe amendment, or perhaps something critical that needs to reach all minions
    as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Another powerful feature of the Salt-master is orchestration, more specifically-remote
    execution. With all your minions connected to it, the salt-master becomes a command
    center from which you have more or less full control over them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Executing commands on the minions is done via modules from generic ones such
    as `cmd.run`, which essentially allows you to run arbitrary shell commands to
    more specialized ones such as `nginx`, `postfix`, `selinux`, or `zfs`. The list
    is quite long as you can see here: [https://docs.saltstack.com/en/latest/ref/modules/all/index.html](https://docs.saltstack.com/en/latest/ref/modules/all/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'And if you recall the earlier section on hostnames and naming conventions,
    this is where one can appreciate their value. It is quite convenient to be able
    to execute statements like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: You can also use Pillars and/or Grains to add tags to your hosts, so you could
    further group them per location, role, department, or something similar.
  prefs: []
  type: TYPE_NORMAL
- en: 'In brief, here are a few key points of masterless versus a salt-master arrangement:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Salt Master** | **Masterless** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: A powerful, centralized control platform (must be secured adequately) which
    allows for quick, parallel access to a vast network of minions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced features such as Salt Engines, Runners, Beacons, the Reactor System
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: No salt-master node to maintain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not having a single node which provides full access to the rest of them is more
    secure in some sense
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simpler Salt operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After the initial Salt execution, the minions can be considered immutable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: For many *FOR LOOP gurus* out there, parallel execution tools like Salt are
    very appealing. It allows you to rapidly reach out to nodes at a massive scale,
    whether you simply want to query their uptime, reload a service, or react to a
    threat alert by stopping sshd across your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Before you go, please remember to delete any AWS resources used in the preceding
    examples (VPC, ELB, EC2, IAM, CodeCommit, and so on) to avoid unexpected charges.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the second part of *Infrastructure as Code*, namely
    **Configuration Management**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned about a few different components of the CM solution SaltStack: States,
    Pillars, Grains, and the Top File. We learned how to use them and how to write
    code for them.'
  prefs: []
  type: TYPE_NORMAL
- en: We then combined our previous knowledge of how to deploy infrastructure using
    Terraform with that of how to configure it using SaltStack, resulting in our first
    end-to-end IaC deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to look into *Continuous Integration*: what it is and how
    to setup a *CI* pipeline on AWS.'
  prefs: []
  type: TYPE_NORMAL
