<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Exploring Docker</h1></div></div></div><p>After reading this chapter, you will find yourself more comfortable talking about and using Docker. The following topics will be covered here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Docker image</li><li class="listitem" style="list-style-type: disc">The Docker container</li><li class="listitem" style="list-style-type: disc">The Docker command-line interface</li><li class="listitem" style="list-style-type: disc">The Docker Registry Hub</li></ul></div><p>You will find these topics important when building your PaaS, and you will use and interact with all of them throughout this book.</p><div><div><div><div><h1 class="title"><a id="ch02lvl1sec14"/>The Docker image</h1></div></div></div><p>In the<a class="indexterm" id="id72"/> beginning, it can be hard to understand the difference between a Docker image and a Docker (or Linux) container.</p><p>Imagine that our Linux kernel is layer zero. Whenever we run a Docker image, a layer is put on top of our kernel layer. This image, layer one, is a read-only image and cannot be changed or cannot hold a state.</p><p>A Docker image can build on top of another Docker image that builds on top of another Docker image<a class="indexterm" id="id73"/> and so on. The first image layer is called a <strong>base image</strong>, and <a class="indexterm" id="id74"/>all other layers except the last image<a class="indexterm" id="id75"/> layer <a class="indexterm" id="id76"/>are called <strong>parent images</strong>. They inherit all the properties and settings of their parent images and add their own configuration in the Dockerfile.</p><p>Docker images are identified by an image ID, which is a 64-character long hexadecimal string, but when working with images, we will almost never reference an image by this ID but use the image names instead. To list all our locally available Docker images, we use the <code class="literal">docker images</code> command. Take a look at the following image to see how the images are listed:</p><div><img alt="The Docker image" src="img/3946_02_01.jpg"/></div><p>Images <a class="indexterm" id="id77"/>can be distributed with different versions for us to choose from, and the <a class="indexterm" id="id78"/>mechanism for this is called <strong>tags</strong>. The preceding screenshot illustrates this with the <strong>neo4j</strong> image that has a <strong>latest</strong> and a <strong>2.1.5</strong> tag. This is how the command used to pull a specific tag looks:</p><div><pre class="programlisting">
<strong>docker pull ubuntu:14.04</strong>
<strong>docker pull ubuntu:12.02</strong>
</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec15"/>The Docker container</h1></div></div></div><p>A Docker container<a class="indexterm" id="id79"/> is created the moment we execute <code class="literal">docker run imagename</code>. A writeable layer is added on top of all the image layers. This layer has processes running on the CPU and can have two different states: running or exited. This is the container. When we start a container with the Docker run command, it enters the running state until it, for some reason, stops by itself or is stopped by us and then enters the exited state.</p><p>When we have a container running, all the changes we make to its filesystem are permanent between start and stop. Remember that changes made to the container's filesystem are not written to the underlying Docker image.</p><p>We can start as many instances of running containers as we want from the same image; they will all live side by side, totally separated by each other. All the changes we make to a container are limited to that container only.</p><p>If changes are made to the container's underlying image, the running container is unaffected and there is no autoupdate happening. If we want to update our container to a newer version of its image, we have to be careful and make sure that we have set up the data structure in a correct way, otherwise we have the risk of losing all the data in the container. Later in this book, I will show you where to keep important data without the risk of losing it.</p><p>The corresponding screenshot is shown as follows:</p><div><img alt="The Docker container" src="img/3946_02_02.jpg"/></div><p>A 64-character long hexadecimal <a class="indexterm" id="id80"/>string called <strong>container ID</strong> identifies<a class="indexterm" id="id81"/> Docker containers. This ID can be used when interacting with the container, and depending on how many containers we have running, we will usually only have to type the first four characters of the container ID. We can use the container name as well, but it's often easier to type the beginning of the ID.</p></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec16"/>The Docker command-line interface</h1></div></div></div><p>The command line interface<a class="indexterm" id="id82"/> is where we communicate with the daemon using the Docker command. The Docker daemon is the background process that receives the commands that are typed by us.</p><p>In the previous chapter, we ran a few Docker commands to start and stop containers as well as to list containers and images. Now, we are going to learn a few more that will help us when handling containers for our PaaS, as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">docker logs &lt;container-ID|name&gt;</code>: Everything that is written to the <code class="literal">STDOUT</code> containers will end up in the file that can be accessed via this command. This is a very handy way to output information from within a container, as shown here:<div><img alt="The Docker command-line interface" src="img/3946_02_03.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">docker export &lt;container-ID|name&gt;</code>: If you have a container that holds data that<a class="indexterm" id="id83"/> you want to export, this is the command to be used. This creates a tar archive and sends it to <code class="literal">STDOUT</code>:<div><img alt="The Docker command-line interface" src="img/3946_02_04.jpg"/></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">docker cp CONTAINER:PATH HOSTPATH</code>: If you don't want the whole file system from a container but just one directory or a file, you can use <code class="literal">docker cp</code> instead of <code class="literal">export</code>, as shown in the following screenshot:<div><img alt="The Docker command-line interface" src="img/3946_02_05.jpg"/></div></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec17"/>The Docker Registry Hub</h1></div></div></div><p>One important <a class="indexterm" id="id84"/>part of Docker's popularity is its community and the ease with which you can share, find, and extend Docker images. The central place <a class="indexterm" id="id85"/>for this is the Docker Registry Hub that can be found at <a class="ulink" href="https://hub.docker.com/">https://hub.docker.com/</a>.</p><div><div><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Browsing repositories</h2></div></div></div><p>Here, we <a class="indexterm" id="id86"/>can search and, in many ways, browse <a class="indexterm" id="id87"/>for image repositories to find exactly what we're after. If we take a look at the popular ones, we will see what others are using the most.</p><p>If we click on the Ubuntu repository, we will see lots of information about the image, the tags that are available, users' comments, the number of stars it has, and when it was updated.</p><p>The screenshot is displayed as follows:</p><div><img alt="Browsing repositories" src="img/3946_02_06.jpg"/></div><p>If we click<a class="indexterm" id="id88"/> on a tag in the main view, we'll see<a class="indexterm" id="id89"/> something<a class="indexterm" id="id90"/> called the <code class="literal">Dockerfile</code>. This is the image description that runs when an image is being created. Further in this book, we'll write our own.</p><p>If you're interested in an image in the Docker hub, I recommend that you read the Information/README as well as the other users' comments. Often, you will find valuable information there that will help you to choose the right image and show you how to run it in the way the maintaining developer intended to.</p><p>Often, you<a class="indexterm" id="id91"/> will find images that almost fit your<a class="indexterm" id="id92"/> needs since most images are quite general, but as a developer, you might need specific settings or services installed.</p></div><div><div><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Exploring published images</h2></div></div></div><p>Take the <a class="indexterm" id="id93"/>official WordPress Docker image, for<a class="indexterm" id="id94"/> example (<a class="ulink" href="https://registry.hub.docker.com/_/wordpress/">https://registry.hub.docker.com/_/wordpress/</a>). You'll find it on the Docker hub's browse <a class="indexterm" id="id95"/>page or you can search for it.</p><p>Let's forget about these shortcomings for now and see what the information page says:</p><div><img alt="Exploring published images" src="img/3946_02_07.jpg"/></div><p>This image reads the settings from the Docker container's environment variables. This means that image has to be started with the environment variables injected using the <code class="literal">docker run –e</code> command, or you can <code class="literal">--link</code> another container to it that injects these variables. We'll <a class="indexterm" id="id96"/>discuss container<a class="indexterm" id="id97"/> linking more later in this book.</p><p>Let's see what we'll get if we were to pull this image. Click on the link to the Dockerfile in the apache directory:</p><div><pre class="programlisting">
<strong>FROM php:5.6-apache</strong>

<strong>RUN a2enmod rewrite</strong>

<strong># install the PHP extensions we need</strong>
<strong>RUN apt-get update &amp;&amp; apt-get install -y libpng12-dev libjpeg-dev &amp;&amp; rm -rf /var/lib/apt/lists/* \</strong>
<strong>    &amp;&amp; docker-php-ext-configure gd --with-png-dir=/usr --with-jpeg-dir=/usr \</strong>
<strong>    &amp;&amp; docker-php-ext-install gd</strong>
<strong>RUN docker-php-ext-install mysqli</strong>

<strong>VOLUME /var/www/html</strong>

<strong>ENV WORDPRESS_VERSION 4.1.1</strong>
<strong>ENV WORDPRESS_UPSTREAM_VERSION 4.1.1</strong>
<strong>ENV WORDPRESS_SHA1 15d38fe6c73121a20e63ccd8070153b89b2de6a9</strong>

<strong># upstream tarballs include ./wordpress/ so this gives us /usr/src/wordpress</strong>
<strong>RUN curl -o wordpress.tar.gz -SL https://wordpress.org/wordpress-${WORDPRESS_UPSTREAM_VERSION}.tar.gz \</strong>
<strong>    &amp;&amp; echo "$WORDPRESS_SHA1 *wordpress.tar.gz" | sha1sum -c - \</strong>
<strong>    &amp;&amp; tar -xzf wordpress.tar.gz -C /usr/src/ \</strong>
<strong>    &amp;&amp; rm wordpress.tar.gz</strong>

<strong>COPY docker-entrypoint.sh /entrypoint.sh</strong>

<strong># grr, ENTRYPOINT resets CMD now</strong>
<strong>ENTRYPOINT ["/entrypoint.sh"]</strong>
<strong>CMD ["apache2-foreground"]</strong>
</pre></div><p>Ok, we<a class="indexterm" id="id98"/> see that it builds on Debian Wheezy and installs Apache2, PHP5, and some other stuff. After that, it sets a bunch of <a class="indexterm" id="id99"/>environment variables and then downloads WordPress.</p><p>We see a few lines starting with the command <code class="literal">COPY</code>. This means that files are shipped with the Docker image and are copied to the inside of the container when it's started. This is how the <code class="literal">docker-apache.conf</code> file shipped with the WordPress image looks:</p><div><pre class="programlisting">
<strong>&lt;VirtualHost *:80&gt;</strong>
<strong>  DocumentRoot /var/www/html</strong>
<strong>  &lt;Directory /var/www/html&gt;</strong>
<strong>    AllowOverride all</strong>
<strong>  &lt;/Directory&gt;</strong>
<strong>&lt;/VirtualHost&gt;</strong>
<strong># vim: syntax=apache ts=4 sw=4 sts=4 sr noet</strong>
</pre></div><p>The preceding line of code tells Apache where to look for files.</p><p>What about the <code class="literal">docker-entrypoint.sh</code> file?</p><p>The <code class="literal">ENTRYPOINT</code> keyword tells the Docker daemon that if nothing else is specified, this file should be executed whenever the container is run. It is as if the whole container is an executable file.</p><p>If we take a look at what is present inside this file, we'll see that it basically sets up the connection to the MySQL database and configures <code class="literal">.htaccess</code> and WordPress:</p><div><pre class="programlisting">
<strong>#!/bin/bash</strong>
<strong>set -e</strong>
<strong>if [ -z "$MYSQL_PORT_3306_TCP" ]; then</strong>
<strong>  echo &gt;&amp;2 'error: missing MYSQL_PORT_3306_TCP environment variable'</strong>
<strong>  echo &gt;&amp;2 '  Did you forget to --link some_mysql_container:mysql ?'</strong>
<strong>  exit 1</strong>
<strong>fi</strong>
</pre></div><p>The first thing that is done is to check whether the user has set environment variables for the MySQL connection. If not, it exits and writes some info to <code class="literal">STDERR</code>.</p><p>Why don't <a class="indexterm" id="id100"/>you try and see whether <a class="indexterm" id="id101"/>you can trigger the MySQL error that writes <strong>error: missing MYSQL_PORT_3306_TCP environment variable</strong> to the <code class="literal">STDERR</code>, as follows:</p><div><pre class="programlisting">
<strong>docker run –-name some-wordpress –d wordpress</strong>
</pre></div><div><img alt="Exploring published images" src="img/3946_02_08.jpg"/></div><p>The <code class="literal">--name some-wordpress</code> command names the container, so we can reference it by this name later. Also, the <code class="literal">–d</code> argument tells the container to run in detached mode, which means that it does not listen to commands from where we started it anymore. The last <code class="literal">wordpress</code> argument is the name of the Docker image we want to run.</p><p>If we check the log for our new container, we'll see what the screenshot shows us: the expected error message.</p><p>Let's run a MySQL container and see whether we can get it to work. Navigate to <a class="ulink" href="https://registry.hub.docker.com/_/mysql/">https://registry.hub.docker.com/_/mysql/</a> in order to get to the official MySQL docker repository<a class="indexterm" id="id102"/> on the Docker registry hub. Here, it states that in order to start a MySQL instance, we need to invoke <strong>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql</strong>
<code class="literal"> </code>in the shell. Since we are doing <a class="indexterm" id="id103"/>this for educational purposes<a class="indexterm" id="id104"/> at the moment, we don't have to choose a strong root user password. After some dependent images are downloaded, we should be able to see our running container when we execute <code class="literal">docker ps</code>. If we do, have a look at the installation log by running <code class="literal">docker logs some-mysql</code>, as shown here:</p><div><img alt="Exploring published images" src="img/3946_02_09.jpg"/></div><p>Great, now we have a running MySQL container that is needed to start a WordPress instance. Let's start a new WordPress instance with the MySQL link in place:</p><div><pre class="programlisting">
<strong>docker run --name some-wordpress --link some-mysql:mysql –p 80 -d wordpress</strong>
</pre></div><p>The <code class="literal">--link</code> parameter exposes the <code class="literal">some-mysql</code> containers' environment variables, interface, and exposed ports via the environment variables injected to the <code class="literal">some-wordpress</code> container.</p><p>To open<a class="indexterm" id="id105"/> a port that can be reached <a class="indexterm" id="id106"/>from the outside, port 80 is exposed via the <code class="literal">–p 80</code> parameter.</p><p>If you get an error message saying <strong>Error response from daemon: Conflict, The name some-wordpress is already assigned to a11c101cacaf.</strong>, you have to delete (or rename) that container to be able to assign <code class="literal">some-wordpress</code> to a container again. You need to give the new container a new name or delete the old (failing) WordPress container. Invoke <code class="literal">docker rm some-wordpress</code> to delete the old container using the desired name.</p><p>When you have the container running, invoke <code class="literal">docker ps</code> command to find out which of our ports was assigned to the container's private port 80.</p><p>We can either look at the ports column in the container list, or we can invoke <code class="literal">docker port some-wordpress 80</code> to explicitly find it, as shown here:</p><div><img alt="Exploring published images" src="img/3946_02_10.jpg"/></div><p>In my case, it was port <strong>49155</strong>.</p><p>Enter your Docker hosts' <strong>ip:port</strong> in your web browser to see whether you can reach it. If you're on your local computer running Windows or OS X, you can find your Docker IP by invoking <code class="literal">boot2docker ip</code>. If you're on a local Linux, <strong>127.0.0.1</strong> should be fine.</p><p>I'm doing this on Amazon EC2, so I have to go to the EC2 Management console to get my public IP or public DNS.</p><p>Point your web browser to <code class="literal">http://yourip:yourport</code> (in my case, <code class="literal">http://myamazon-dns.com:49155</code>) and you should be presented with this:</p><div><img alt="Exploring published images" src="img/3946_02_11.jpg"/></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>The<a class="indexterm" id="id107"/> default Amazon AWS security policy is to block the default Docker public ports, so we have to change<a class="indexterm" id="id108"/> this in the <strong>Security Groups</strong> section in the EC2 dashboard. See the <em>Docker on Amazon EC2</em> section in <a class="link" href="ch01.html" title="Chapter 1. Installing Docker">Chapter 1</a>, <em>Installing Docker,</em> for how to do this.</p></div></div><p>Wonderful, it works!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Summary</h1></div></div></div><p>The Docker image can be seen as a read-only template for containers, specifying what's supposed to be installed, copied, configured, and exposed when a container is started.</p><p>We learned more about how we can interact with the Docker daemon and with individual Docker containers to read logs, copy files, and export the complete filesystem.</p><p>The Docker hub was introduced and we looked at what the official WordPress Docker image consisted of and how they configured the OS in the Dockerfile as well as in an <code class="literal">ENTRYPOINT</code> file to some extent.</p><p>We downloaded and ran the WordPress image that failed as expected, and we fixed it by linking the required MySQL container to it.</p><p>In the next chapter, we will create a Dockerfile and publish a Docker image to the Docker registry hub so that we have a way to get our customized Docker images to wherever we decide to place our PaaS.</p></div></body></html>