<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Creating Our First PaaS Image</h1></div></div></div><p>You are now ready to write your own Dockerfiles, publish them to the Docker Registry Hub, and create containers for them. In this chapter you will:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Build your own image on top of another</li><li class="listitem" style="list-style-type: disc">Host your Dockerfiles in your GitHub account</li><li class="listitem" style="list-style-type: disc">Publish an image on the Docker Registry Hub</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>The WordPress image</h1></div></div></div><p>For this<a class="indexterm" id="id109"/> project, we are going to use the official WordPress Docker image as a base, which has Apache2 as its web server.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>If you plan to host sites with a lot of traffic, I would recommend using an image based on Nginx instead of Apache2 as the web server. I have had great success running WordPress sites with Nginx and the memcached plugin, WP-FFPC. It can be a bit tricky to set up, and that's why it's out of the scope of this book.</p></div></div><p>First of all, let's run a MySQL container and a WordPress container and link to them to see what happens:</p><div><pre class="programlisting">
<strong>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql</strong>
<strong>docker run --name some-wordpress --link some-mysql:mysql -d -p 80 wordpress</strong>
</pre></div><p>The <code class="literal">–p 80</code> option tells Docker to expose the private port <code class="literal">80</code> to the outer world. To find out which public port is bound to the private port <code class="literal">80</code>, run <code class="literal">docker ps</code> command and look in the ports column or invoke the <code class="literal">docker port &lt;container-ID|name&gt;</code> <code class="literal">80</code> command.</p><p>The screenshot is shown below:</p><div><img alt="The WordPress image" src="img/3946OT_03_01.jpg"/></div><p>In my<a class="indexterm" id="id110"/> case, the public port is <strong>49154</strong>. Enter the full URL in the form of <code class="literal">http://public_ip:public_port</code> in your web browser. I'm doing this on an Amazon EC2 instance. I get a public domain, which is <code class="literal">http://ec2-54-187-234-27.us-west-2.compute.amazonaws.com:49154</code> in my case.</p><p>The screenshot is displayed below:</p><div><img alt="The WordPress image" src="img/3946OT_03_02.jpg"/></div><p>The WordPress <a class="indexterm" id="id111"/>installation page welcomes us, which means that the WordPress and the MySQL containers are working properly.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Moving from the defaults</h1></div></div></div><p>Now we have a default installation of WordPress run on Apache2. Some WordPress plugins require<a class="indexterm" id="id112"/> you to make changes to the web server's configuration. How can we do that? What if we want to edit some of the files in the WordPress directory?</p><p>The first thing we need to do is to get our own copy of the official WordPress repository so that we can explore the Dockerfile. The current URL that is used to get the repository is <a class="ulink" href="https://github.com/docker-library/wordpress">https://github.com/docker-library/wordpress</a>. Click on this link from the WordPress repo page on the Docker Registry Hub.</p><p>You can clone, fork, or just download the source for this Docker image. It doesn't matter how you get it because we're not going to use it later on. This image is for testing and exploring<a class="indexterm" id="id113"/> purposes. I used my EC2 instance to do this.</p><div><img alt="Moving from the defaults" src="img/3946OT_03_03.jpg"/></div><p>Open the file in any text editor to view its content. If you are—like me—using the terminal, you can use <code class="literal">vi apache/Dockerfile</code> to open it in the <code class="literal">vi</code> file editor. The current Dockerfile for the official WordPress image looks like this:</p><div><pre class="programlisting">
<strong>FROM php:5.6-apache</strong>

<strong>RUN a2enmod rewrite</strong>

<strong># install the PHP extensions we need</strong>
<strong>RUN apt-get update &amp;&amp; apt-get install -y libpng12-dev libjpeg-dev &amp;&amp; rm -rf /var/lib/apt/lists/* \</strong>
<strong>    &amp;&amp; docker-php-ext-configure gd --with-png-dir=/usr --with-jpeg-dir=/usr \</strong>
<strong>    &amp;&amp; docker-php-ext-install gd</strong>
<strong>RUN docker-php-ext-install mysqli</strong>

<strong>VOLUME /var/www/html</strong>

<strong>ENV WORDPRESS_VERSION 4.1.1</strong>
<strong>ENV WORDPRESS_UPSTREAM_VERSION 4.1.1</strong>
<strong>ENV WORDPRESS_SHA1 15d38fe6c73121a20e63ccd8070153b89b2de6a9</strong>

<strong># upstream tarballs include ./wordpress/ so this gives us /usr/src/wordpress</strong>
<strong>RUN curl -o wordpress.tar.gz -SL https://wordpress.org/wordpress-${WORDPRESS_UPSTREAM_VERSION}.tar.gz \</strong>
<strong>    &amp;&amp; echo "$WORDPRESS_SHA1 *wordpress.tar.gz" | sha1sum -c - \</strong>
<strong>    &amp;&amp; tar -xzf wordpress.tar.gz -C /usr/src/ \</strong>
<strong>    &amp;&amp; rm wordpress.tar.gz</strong>

<strong>COPY docker-entrypoint.sh /entrypoint.sh</strong>

<strong># grr, ENTRYPOINT resets CMD now</strong>
<strong>ENTRYPOINT ["/entrypoint.sh"]</strong>
<strong>CMD ["apache2-foreground"]</strong>
</pre></div><p>This image<a class="indexterm" id="id114"/> uses the <code class="literal">php:5.6-apache</code> image as a base and downloads and extracts WordPress 4.1 to <code class="literal">/usr/src/wordpress</code>. Then it adds an <code class="literal">ENTRYPOINT</code> and starts Apache2 in the foreground.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Our objective</h1></div></div></div><p>To make this <a class="indexterm" id="id115"/>WordPress image useable for more than demo purposes, we need to modify the Dockerfile in three ways. Our objectives are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Preparing Apache for caching (through the WP Super Cache plugin)</li><li class="listitem" style="list-style-type: disc">Raising the upload limit in both PHP and Apache2</li><li class="listitem" style="list-style-type: disc">Installing two plugins: WP Super Cache and WP Mail SMTP</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>Preparing for caching</h2></div></div></div><p>There are two <a class="indexterm" id="id116"/>small steps to be <a class="indexterm" id="id117"/>performed to obtain website caching through WP Super Cache—we need to enable the <code class="literal">mod_headers</code> and <code class="literal">mod_expires</code> modules in Apache2.</p><p>On line 5 in the Dockerfile, you can see <code class="literal">RUN a2enmod rewrite</code>. The <code class="literal">a2enmod</code> command enables modules in Apache2, and modules are disabled by the <code class="literal">a2dismod</code> command. Enabling our desired modules is as easy as appending them to that line:</p><div><pre class="programlisting">
<strong>RUN a2enmod rewrite expires headers</strong>
</pre></div><p>We make those edits, build a new image, and see what happens. It takes a long time to build these images, since PHP is built from source. What we are looking for are lines that state that our modules are enabled. They will show up for just a few seconds in the build process.</p><p>You initiate a build from a Dockerfile by executing this:</p><div><pre class="programlisting">
<strong>docker build –t mod-wp .</strong>
</pre></div><p>The <code class="literal">–t mod-wp</code> command sets the name of our new image to <code class="literal">mod-wp</code>.</p><p>The<a class="indexterm" id="id118"/> screenshot is shown <a class="indexterm" id="id119"/>below:</p><div><img alt="Preparing for caching" src="img/3946OT_03_04.jpg"/></div><p>The build should run through the whole process without any errors, and then the preparation for the cache plugin is done.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>Raising the upload limit</h2></div></div></div><p>The default<a class="indexterm" id="id120"/> upload size is limited to 2 MB by PHP. This limit is too low, especially since blogging from mobile phones is popular and the size of a mobile phone photo or video is often bigger than this. I would like to have the option to upload videos directly on my blogs, and they can be up to 32 MB.</p><p>For this limit to be raised, we need to change the limit for two parameters in the PHP configuration file: <code class="literal">upload_max_filesize</code> and <code class="literal">post_max_size</code>.</p><p>Looking <a class="indexterm" id="id121"/>at the php:5.6-Apache image, which is the base image of the WordPress image, Dockerfile we see that it runs Debian and PHP configuration files are supposed to be in the <code class="literal">/usr/local/etc/php/conf.d/</code> directory. This means that if we add a file to that directory, it should get read in and parsed.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>The Dockerfile for PHP 5.6<a class="indexterm" id="id122"/> can be found at <a class="ulink" href="https://github.com/docker-library/php/blob/master/5.6/Dockerfile">https://github.com/docker-library/php/blob/master/5.6/Dockerfile</a>.</p></div></div><p>To verify that the upload limit is as low as said before, I started and installed an unmodified WordPress container. Then I clicked on the <strong>Add new media</strong> button.</p><div><img alt="Raising the upload limit" src="img/3946OT_03_05.jpg"/></div><p>It says that the upload limit is 2 MB.</p><p>Let's add a configuration file named <code class="literal">upload-limit.ini</code> to the configuration directory, and add the two parameters to the file.</p><p>These <a class="indexterm" id="id123"/>commands, all of which should be on a single line, are added to our Dockerfile right above the line we modified when preparing Apache for caching:</p><div><pre class="programlisting">
<strong>RUN touch /usr/local/etc/php/conf.d/upload-limit.ini \</strong>
<strong>        &amp;&amp; echo "upload_max_filesize = 32M" &gt;&gt; /usr/local/etc/php/conf.d/upload-limit.ini \</strong>
<strong>        &amp;&amp; echo "post_max_size = 32M" &gt;&gt; /usr/local/etc/php/conf.d/upload-limit.ini</strong>
<strong>#Paste above this line.</strong>
<strong>RUN a2enmod rewrite expires headers</strong>
</pre></div><p>Once again, build the image to ensure that no errors are produced. If you get an error saying that the image name already exists, you can delete the old image with the <code class="literal">docker rmi mod-wp</code> command or change the name to <code class="literal">mod-wp:latest</code>, which will update the image's tag to <code class="literal">latest</code>.</p><p>When the build finishes, we run a new container from the new image to check out what the WordPress administration interface says. We can run a container from our new image, like this:</p><div><pre class="programlisting">
<strong>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql</strong>
<strong>docker run --name some-wordpress --link some-mysql:mysql -d -p 80 mod-wp:latest</strong>
</pre></div><div><img alt="Raising the upload limit" src="img/3946OT_03_06.jpg"/></div><p>We can <a class="indexterm" id="id124"/>now see that we can upload bigger files. Just to verify, if you upload a file bigger than 2 MB, it will prove that the limit has been raised.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Plugin installation</h2></div></div></div><p>Here, we <a class="indexterm" id="id125"/>are going to download <a class="indexterm" id="id126"/>and install two plugins<a class="indexterm" id="id127"/> that we want in all our future WordPress sites. All the<a class="indexterm" id="id128"/> tasks for these plugins will be done in the <a class="indexterm" id="id129"/>entry point file, since we have to edit a few files in the <a class="indexterm" id="id130"/>WordPress installation.</p><p>The first plugin is WP Super Cache. We prepared Apache2 for this earlier, and now it's time to use that. With this plugin, our site will run faster and demand fewer resources from our host.</p><p>The second plugin is WP Mail SMTP, with the help of which WordPress can send outgoing e-mails. This container does not (and should not) include a mail server. With this plugin, we can make WordPress send e-mails via an external SMTP (Gmail, your ISPs, or anything else).</p>
 <div><div><h3 class="title"><a id="note10"/>Note</h3><p>Even though I have hosted and managed my own mail server for a few years now, it is a hassle with keeping it up to date and managing spam filters and redundancy. We're better off leaving that to the specialists.</p></div></div><p>All plugins <a class="indexterm" id="id131"/>will be downloaded <a class="indexterm" id="id132"/>with CURL and unpacked <a class="indexterm" id="id133"/>with unzip. CURL is already installed but unzip is <a class="indexterm" id="id134"/>not, so we have to add it to our Dockerfile, close to the top where the <code class="literal">apt-get install</code> command is running:</p><div><pre class="programlisting">RUN apt-get update &amp;&amp; apt-get install -y unzip rsync &amp;&amp; rm -r /var/lib/apt/lists/*</pre></div><p>If we <a class="indexterm" id="id135"/>don't do this, we will get error messages during <a class="indexterm" id="id136"/>the build process.</p><p>Since there are two plugins we have to download, extract, and activate, we will create a function in the <code class="literal">docker-entrypoint.sh</code> file.</p><p>This function will go to Wordpress' plugin site and look for the download URL for the latest version of the plugin. It will download and then extract it to the plugin folder in our Wordpress installation:</p><div><pre class="programlisting">dl_and_move_plugin() {
  name="$1"
  curl -O $(curl -i -s "https://wordpress.org/plugins/$name/" | egrep -o "https://downloads.wordpress.org/plugin/[^']+")
  unzip -o "$name".*.zip -d $(pwd)/wp-content/plugins
}</pre></div><p>Now that we have the function there, we can add these lines near the end of the file, just above the line that says <code class="literal">chown –R www-data:www-data ..</code>:</p><div><pre class="programlisting">
<strong>dl_and_move_plugin "wp-super-cache"</strong>
<strong>dl_and_move_plugin "wp-mail-smtp"</strong>
</pre></div><p>Place the function and the function calls close to the bottom—in the <code class="literal">docker-entrypoint.sh</code> file, just above the <code class="literal">exec</code> command.</p><p>We will build the image again and start a container so that we can verify that everything is working as we want:</p><div><pre class="programlisting">
<strong>docker build –t mod-wp:latest</strong>
</pre></div><p>This will take a while, and when it's ready, you can fire up a MySQL container and a <code class="literal">mod-wp</code> container:</p><div><pre class="programlisting">
<strong>docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql</strong>
<strong>docker run --name some-wordpress --link some-mysql:mysql -d -p 80 mod-wp:latest</strong>
</pre></div><p>If you get an error that tells you that you already have a container with that name, either remove<a class="indexterm" id="id137"/> the old container with <code class="literal">docker rm some-wordpress</code> or <a class="indexterm" id="id138"/>use another name for the new container.</p><p>Get the<a class="indexterm" id="id139"/> port by invoking <code class="literal">docker ps</code>, and look for the port binding to port <code class="literal">80</code> on the WordPress container. Then <a class="indexterm" id="id140"/>load the URL into<a class="indexterm" id="id141"/> your browser. This time, install WordPress, log<a class="indexterm" id="id142"/> in, and go to the plugins page, as shown in the following screenshot:</p><div><img alt="Plugin installation" src="img/3946OT_03_07.jpg"/></div><p>This looks just like we want it to! Great!</p><p>Let's go <a class="indexterm" id="id143"/>ahead and activate<a class="indexterm" id="id144"/> and set up these plugins just to verify that they <a class="indexterm" id="id145"/>work. Start with<a class="indexterm" id="id146"/> the <a class="indexterm" id="id147"/>WP Mail SMTP plugin. I will use my Gmail account as the sender, but you can choose which SMTP you want. Here is a screenshot showing the <a class="indexterm" id="id148"/>settings for Gmail:</p><div><img alt="Plugin installation" src="img/3946OT_03_08.jpg"/></div><p>From the bottom of this page, you can send a test e-mail. I strongly recommend doing this because Gmail sometimes blocks new SMTP clients. If you get an error message saying <strong>Please log in via your web browser and then try again</strong>, you've triggered that. In that case, you'll soon get an e-mail from Google explaining suspicious activity and asking you to go through a few steps to make it work. This is annoying but it's a good thing.</p><p>Now let's move on to the WP Super Cache plugin. Go ahead and activate the plugin from the plugin<a class="indexterm" id="id149"/> page. Before we can <a class="indexterm" id="id150"/>enable it, we have to <a class="indexterm" id="id151"/>go to <strong>Settings</strong> | <strong>Permalinks</strong>, check the <strong>Post name</strong> button, and<a class="indexterm" id="id152"/> save.</p><p>Then go<a class="indexterm" id="id153"/> to <strong>Settings</strong> | <strong>WP Super Cache</strong>.</p><p>Click<a class="indexterm" id="id154"/> on <strong>Caching On</strong> and then on <strong>Update Status</strong>. Now click on the <strong>Advanced</strong> tab and enable <strong>mod_rewrite caching</strong>, as shown:</p><div><img alt="Plugin installation" src="img/3946OT_03_09.jpg"/></div><p>Scroll<a class="indexterm" id="id155"/> down <a class="indexterm" id="id156"/>to<a class="indexterm" id="id157"/> the<a class="indexterm" id="id158"/> <strong>Miscellaneous</strong> section and check the<a class="indexterm" id="id159"/> boxes that are shown in the following screenshot. If <a class="indexterm" id="id160"/>you want to know exactly what all of these checkboxes do, you can refer to the plugins' documents.</p><div><img alt="Plugin installation" src="img/3946OT_03_10.jpg"/></div><p>When you've saved this, you'll get a notice at the top saying that you need to update the rewrite rules, as shown:</p><div><img alt="Plugin installation" src="img/3946OT_03_11.jpg"/></div><p>Scroll <a class="indexterm" id="id161"/>down the page and <a class="indexterm" id="id162"/>click on the <strong>Update Mod_Rewrite Rules</strong> button <a class="indexterm" id="id163"/>to update the rewrite rules, as shown:</p><div><img alt="Plugin installation" src="img/3946OT_03_12.jpg"/></div><p>The <a class="indexterm" id="id164"/>cache<a class="indexterm" id="id165"/> plugins' <a class="indexterm" id="id166"/>status should now be green, and all of the setup should be done. Since we are logged in to this web browser, we will not be served cached pages. This is important to know, and the advantage is that you won't have to disable the whole cache plugin just to see the uncached version of your site. Open another web browser (not just another window or tab in your current browser, unless you are using incognito or private mode) and go to your WordPress instance. Click on the <strong>Hello World</strong> title on the post. Go back to the start page. Click on the title again. It feels pretty<a class="indexterm" id="id167"/> fast, right?</p><p>To verify that it works, you can open the development tools in your browser. Make sure that you don't have caching disabled in your browser when the development tolls are open. Click <a class="indexterm" id="id168"/>on the <strong>Network</strong> tab, then<a class="indexterm" id="id169"/> click on the<a class="indexterm" id="id170"/> post's <a class="indexterm" id="id171"/>title again, and<a class="indexterm" id="id172"/> then inspect that call, as shown in the following screenshot:</p><div><img alt="Plugin installation" src="img/3946OT_03_13.jpg"/></div><p>This is just what we wanted to see. Great!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Making our changes persist</h1></div></div></div><p>Now that we have made our changes, we want to create our own Dockerfile to build on top of the official WordPress <a class="indexterm" id="id173"/>image.</p><p>This is what the Dockerfile should look like:</p><div><pre class="programlisting">
<strong>FROM wordpress:latest</strong>
<strong>RUN apt-get update &amp;&amp; apt-get install -y unzip &amp;&amp; rm -r /var/lib/apt/lists/*</strong>
<strong>RUN touch /usr/local/etc/php/conf.d/upload-limit.ini \</strong>
<strong>        &amp;&amp; echo "upload_max_filesize = 32M" &gt;&gt; /usr/local/etc/php/conf.d/upload-limit.ini \</strong>
<strong>        &amp;&amp; echo "post_max_size = 32M" &gt;&gt; /usr/local/etc/php/conf.d/upload-limit.ini</strong>
<strong>RUN a2enmod expires headers</strong>
<strong>VOLUME /var/www/html</strong>
<strong>COPY docker-entrypoint.sh /entrypoint.sh</strong>
<strong>ENTRYPOINT ["/entrypoint.sh"]</strong>
<strong>CMD ["apache2", "-DFOREGROUND"]</strong>
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Hosting image sources on GitHub</h1></div></div></div><p>The Docker Registry Hub has very good support for automatic fetching of image updates from both <a class="indexterm" id="id174"/>Bitbucket and GitHub. You can pick <a class="indexterm" id="id175"/>whatever you want, but for this book, I will use GitHub. I have accounts on both services and they are both excellent.</p><div><img alt="Hosting image sources on GitHub" src="img/3946OT_03_14.jpg"/></div><p>At GitHub, create <a class="indexterm" id="id176"/>a new empty repository called <code class="literal">my-docker-images</code> and add an appropriate license if you like.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>This book will not go into how to add your SSH keys to GitHub and so on. There are <a class="indexterm" id="id177"/>excellent guides for this online. GitHub has a great guide at <a class="ulink" href="https://help.github.com/articles/generating-ssh-keys/">https://help.github.com/articles/generating-ssh-keys/</a>.</p></div></div><p>Let's <a class="indexterm" id="id178"/>create a branch and copy our files for the modified Docker image to it.</p><p>Clone the repository locally so that you can add files to it. Make sure you are not inside your <code class="literal">wordpress-master</code> directory, but on the same level as it is:</p><div><pre class="programlisting">
<strong>git clone git@github.com:yourusername/my-docker-images.git</strong>
</pre></div><p>The output of this command is as follows:</p><div><img alt="Hosting image sources on GitHub" src="img/3946OT_03_15.jpg"/></div><p>We'll <a class="indexterm" id="id179"/>execute these commands one by one:</p><div><pre class="programlisting">
<strong>cd my-docker-images</strong>
<strong>git checkout -b wordpress</strong>
<strong>git add .</strong>
<strong>git commit –m "Adding new files."</strong>
<strong>git push origin wordpress</strong>
</pre></div><p>Go to <a class="indexterm" id="id180"/>your GitHub page and try to find the WordPress branch.</p><p>For every new Docker image we want to create and publish on the Docker Registry Hub, we need to create a new branch in this GitHub repository. If you have a lot of Docker images and the images have a lot of versions, you might want to consider a different structure, but for this book, this approach will be great!</p><div><img alt="Hosting image sources on GitHub" src="img/3946OT_03_16.jpg"/></div><p>All files<a class="indexterm" id="id181"/> are in place, and you can click on them to <a class="indexterm" id="id182"/>verify that the contents are what we would expect.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Publishing an image on the Docker Registry Hub</h1></div></div></div><p>If you're <a class="indexterm" id="id183"/>not a member of the Docker Registry Hub (<a class="ulink" href="https://hub.docker.com">https://hub.docker.com</a>), now is the time to register so that you can publish your images on the public Docker repository, which can be accessed from anywhere.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Automated builds</h2></div></div></div><p>When<a class="indexterm" id="id184"/> you add a repository, you should choose the <strong>Automated Build</strong> option so that you can fetch code from GitHub (or Bitbucket), as shown in the following screenshot:</p><div><img alt="Automated builds" src="img/3946OT_03_17.jpg"/></div><p>We'll connect with our GitHub account and select the repository we just created and pushed to <code class="literal">my-docker-images</code>.</p><p>We will<a class="indexterm" id="id185"/> start to add our WordPress image, so let's set the repository name to <code class="literal">wordpress</code> on the next screen. It's important that you enter this name correctly, since it cannot be changed later.</p><p>At this time, we will just use one tag for our image—the <strong>latest</strong> tag. Ensure that the source: <strong>Type</strong> is set to <strong>Branch</strong> and that you've entered <code class="literal">wordpress</code>
<strong> </strong>as its name.</p><p>Choose to add this as a public repository and check the <strong>active</strong> checkbox. This means that if you push any updates to this on GitHub, the Registry Hub will automatically pull it and publish its changes, as shown in the following screenshot:</p><div><img alt="Automated builds" src="img/3946OT_03_18.jpg"/></div><p>The <a class="indexterm" id="id186"/>Registry Hub will now pull your branch and try to build your Docker image to verify that it works. You can head over to the <strong>Build Details</strong> tab to see the progress. Since it's the official WordPress image base, it should go pretty fast if they cache the images on their build servers. If not, it could take a few minutes, since PHP is compiled from source.</p><p>This is shown in the following screenshot:</p><div><img alt="Automated builds" src="img/3946OT_03_19.jpg"/></div><p>Wow! We've just published an image on the Docker Registry Hub, which means that anyone<a class="indexterm" id="id187"/> can fetch and run containers on top of it. The status will go from <strong>Building</strong> to <strong>Finished</strong> when the image is published.</p><p>The next step would be to actually pull it ourselves to verify that it works as expected:</p><div><pre class="programlisting">docker pull oskarhane/wordpress
docker images
docker run --name mysql -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql
docker run --name my-wordpress --link mysql:mysql -d -p 80 oskarhane/wordpress
docker ps</pre></div><p>Open your web browser and head over to your new container. You should be presented with the WordPress setup page.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Summary</h1></div></div></div><p>In this chapter, you learned quite a lot. The most part was about modifying the Dockerfile and <code class="literal">ENTRYPOINT</code> files in order to get the Docker image that we wanted. Bash knowledge and programming skills are very convenient, but since all of this is mostly about installation, moving files, and editing settings files, very basic knowledge can be enough.</p><p>GitHub is an excellent place to host your Docker repositories, and it's very easy to set up a new repository to get started. The Docker Registry Hub takes your GitHub repository and lets you pick a branch. This branch will be the source for a public Docker image that anyone can pull and use.</p><p>One question arises though; what about our data? It's trapped inside these MySQL and WordPress containers. The next chapter will show you how to handle your data.</p></div></body></html>