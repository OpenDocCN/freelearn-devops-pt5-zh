<html><head></head><body>
        

                            
                    <h1 class="header-title">Putting Them All Together</h1>
                
            
            
                
<p>In this chapter, we will walk through an example to demonstrate serverless platforms working together on a Docker cluster, and we will demonstrate several serverless/FaaS use cases.</p>
<p>We will discuss a mobile payment scenario and implement it using functions but, unusually at this level of infrastructure, we will connect all three FaaS platforms together. The main ideas demonstrated by the content of this chapter are the concept of using functions as a <strong>Glue</strong>, using functions to wrap the legacy web-based application, and using functions as a data stream processing program.</p>
<p>In the next section, we will start with the settings and scenario used by this chapter.</p>
<p>The topics covered in this chapter are:</p>
<ul>
<li>A mobile payment scenario</li>
<li>A Parse platform as a backend</li>
<li>Preparing a WebHook in Fn</li>
<li>An event state machine with a blockchain</li>
<li>Wrapping a legacy with a function</li>
<li>Using a function as a Glue</li>
<li>A stream processor</li>
<li>Inter-FaaS platform networking</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">A mobile payment scenario</h1>
                
            
            
                
<p class="mce-root">We are using a mobile payment with a money transfer allowed between two banks as the scenario for this chapter. With the money transfer, the business logic is easy to understand. So, we do not need to worry about this part. Let's focus on the complexity of the architecture.</p>
<p>Money transfer between two different banks with different underlying implementations is hard. This is because we cannot directly apply the <em>concept of traditional transactions</em> to cope with external systems. The system is presented in the following diagram:</p>
<div><img src="img/57635715-e3eb-4413-88e3-e60b8ef6b792.png"/></div>
<p>Figure 8.1: The overall block diagram of the mobile payment system</p>
<p>What are we not covering in this chapter?</p>
<p>The UI parts are out beyond scope of this book, so they are not available. The <strong>Receipt Generator</strong> and the <strong>Receipt Storage</strong> are optional. They are left for you to implement, if interested.</p>
<p>What do we implement and demonstrate? Let's discuss:</p>
<ul>
<li>The Parse platform, as a backend for the UI.</li>
<li>The <strong>Bank Routing</strong> function. It is written in Java and deployed on Fn. This component is called <kbd>routing_fn</kbd>.</li>
<li><strong>Bank #1</strong> and its function calling to a legacy web-based system. The function here is written in Node.js using the <kbd>chromeless</kbd> library (<a href="https://github.com/graphcool/chromeless">https://github.com/graphcool/chromeless</a>). The function connects to a headless Chrome instance, our familiar web browser. The function drives Chrome to navigate and create a transaction for us on a real ERP system. We use Moqui as our ERP backend. Actually, Moqui comes with a complete set of REST APIs, but we intentionally use its web base to simulate the scenario where we need to modernize some legacy systems. The function of this part is called <kbd>hivectl</kbd>.</li>
<li><strong>Bank #2</strong> and its function, <kbd>account_ctl</kbd>, connecting to a REST-based bank system. The function is written using <kbd>Go</kbd> and will be running on OpenWhisk. The mock bank server behind this component is a simple one written using the Grails/Spring Boot framework. We use this component to demonstrate how to write a FaaS function to wrap and simplify a REST-based API. The <strong>Bank Routing</strong> function, <kbd>routing_fn</kbd>, will be selectively called by each bank. This <strong>Bank #2</strong> component will be used together with <strong>Bank #1</strong> there.</li>
<li>A set of smart contracts written in <strong>Solidity</strong> to maintain the mapping of mobile numbers to bank accounts. Also, another set of smart contracts will be used to maintain the state of the money transfer of each transaction.</li>
<li>An agent written in Java and the RxJava library to demonstrate a data stream processing component that calls a function and diverts the event to other parts of the system.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">A Parse platform as a backend</h1>
                
            
            
                
<p class="mce-root">What is Parse? Similar to Firebase, Parse is a <strong>Backend as a Service</strong> (<strong>BaaS</strong>) platform. With Parse, developers do not need to code the backend system themselves for their UIs or mobile applications. Parse is used by mobile application developers to help accelerate the development process. Together with the Parse dashboard, they provide an easy UI to craft all data entities, called <em>classes</em>, needed to process basic business logic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparation</h1>
                
            
            
                
<p>Here's how to create a Docker network and deploy a set of Docker compose files. We use the concept of metastack to deploy multiple stacks and have some labels and naming conventions to group them together:</p>
<pre><strong>$ docker network create \</strong><br/><strong>  --driver=weaveworks/net-plugin:2.1.3 \</strong><br/><strong>  --subnet=10.32.2.0/24 \</strong><br/><strong>  --attachable \</strong><br/><strong>  parse_net</strong><br/><br/><strong>$ docker volume create mongo_data</strong><br/><br/><strong>$ docker stack deploy -c mongodb.yml         parse_01</strong><br/><strong>$ docker stack deploy -c parse.yml           parse_02</strong><br/><strong>$ docker stack deploy -c parse_dashboard.yml parse_03</strong><br/><strong>$ docker stack deploy -c ingress.yml         parse_04</strong></pre>
<p>While deploying things on production, we do not set up the network and volumes with any Docker compose files. All stacks should refer to external volumes and networks.</p>
<p>Starting with MongoDB, we have already set up a volume for it. The following is the setup of the MongoDB server:</p>
<pre>version: '3.3'<br/><br/>services:<br/>  mongo:<br/>    image: mongo:3.6.1-jessie<br/>    volumes:<br/>      - mongo_data:/data/db<br/><br/>volumes:<br/>  mongo_data:<br/>    external: true<br/><br/>networks:<br/>  default:<br/>    external:<br/>      name: parse_net</pre>
<p>We move to the next component, the Parse platform. To make the container work with Træfik, we put some labels to the service, saying that it will be on the <kbd>parse_net</kbd> network and will expose port <kbd>1337</kbd> to Træfik's ingress.</p>
<p>We add a rule to allow every HTTP method, also to define the custom entrypoint, and allow <kbd>Origin=*</kbd> to enable the Parse dashboard, the next section, to be able to connect to the Parse server:</p>
<pre>version: '3.3'<br/><br/>services:<br/><br/>  parse_server:<br/>    image: parseplatform/parse-server:2.6.5<br/>    command: --appId APP1 --masterKey MASTER_KEY --databaseURI mongodb://mongo/prod<br/>    deploy:<br/>      labels:<br/>        - "traefik.docker.network=parse_net"<br/>        - "traefik.port=1337"<br/>        - "traefik.frontend.rule=Method: GET,POST,PUT,DELETE,OPTIONS,HEAD,CONNECT"<br/>        - "traefik.frontend.entryPoints=parse_server"<br/>        - "traefik.frontend.headers.customresponseheaders.Access-Control-Allow-Origin=*"<br/><br/>networks:<br/>  default:<br/>    external:<br/>      name: parse_net</pre>
<p>Here's the Parse dashboard and its configuration. The current version of the dashboard is <kbd>1.1.2</kbd>. It will be exposed to port <kbd>4040</kbd> via Træfik's ingress:</p>
<pre>version: '3.3'<br/><br/>services:<br/><br/>  parse_dashboard:<br/>    image: parseplatform/parse-dashboard:1.1.2<br/>    environment:<br/>      - PARSE_DASHBOARD_ALLOW_INSECURE_HTTP=true<br/>    deploy:<br/>      labels:<br/>        - "traefik.docker.network=parse_net"<br/>        - "traefik.port=4040"<br/>        - "traefik.frontend.rule=Method: GET,POST,PUT,DELETE,OPTIONS,HEAD,CONNECT"<br/>        - "traefik.frontend.entryPoints=parse_dashboard"<br/>        - "traefik.frontend.headers.customresponseheaders.Access-Control-Allow-Origin=*"<br/>    configs:<br/>      - source: config.json<br/>        target: /src/Parse-Dashboard/parse-dashboard-config.json<br/><br/>configs:<br/>  config.json:<br/>    file: ./config.json<br/><br/>networks:<br/>  default:<br/>    external:<br/>      name: parse_net</pre>
<p>The configuration defines the default username and password, and also says that the server allows a connection via HTTP. Setting <kbd>INSECURE</kbd> to be <kbd>true</kbd> is fine, as we could do SSL simply at the ingress layer, using Træfik:</p>
<pre>{<br/>  "apps": [<br/>    {<br/>      "serverURL": "http://localhost:1337/parse",<br/>      "appId": "APP1",<br/>      "masterKey": "MASTER_KEY",<br/>      "appName": "APP1",<br/>      "iconName": "MyAppIcon.png",<br/>      "supportedPushLocales": ["en", "ru", "fr"]<br/>    }<br/>  ],<br/>  "users": [<br/>    {<br/>      "user":"admin",<br/>      "pass":"password"<br/>    }<br/>  ],<br/>  "iconsFolder": "icons",<br/>  "allowInsecureHTTP": true<br/>}</pre>
<p>The following YAML code is to define the L7 Træfik ingress for Parse and Parse dashboard. We have to expose Parse to the outside too, as the dashboard is a fat client, rather than server-side rendering. This is the main reason we need to set <kbd>Allow-Origin=*</kbd>:</p>
<pre>version: '3.3'<br/><br/>services:<br/><br/>  l7:<br/>    image: traefik:1.5.2<br/>    command: --docker<br/>      --docker.swarmmode<br/>      --docker.watch<br/>      --docker.endpoint=tcp://docker-api:2375<br/>      --entryPoints="Name:parse_server Address::1337"<br/>      --entryPoints="Name:parse_dashboard Address::4040"<br/>      --web --logLevel=DEBUG<br/>    ports:<br/>      - published: 1337<br/>        target: 1337<br/>        protocol: tcp<br/>        mode: host<br/>      - published: 4040<br/>        target: 4040<br/>        protocol: tcp<br/>        mode: host<br/><br/>networks:<br/>  default:<br/>    external:<br/>      name: parse_net</pre>
<p class="mce-root">If everything goes well, we can open our favorite browser and navigate to <kbd>localhost:4040</kbd> for the Parse dashboard, as shown in the following screenshot. The default Username and Password are: <kbd>admin</kbd>/<kbd>password</kbd>:</p>
<div><img src="img/53abdb83-15a5-4ccb-916c-1e125c67c894.png" style="width:31.67em;height:30.17em;"/></div>
<p>Figure 8.2: The login page of the Parse dashboard</p>
<p>Here, in the following screenshot, the dashboard of our Parse platform APP1 connects to the Parse instance at <kbd>http://localhost:1337</kbd>:</p>
<div><img src="img/a2972412-fb81-44e9-8b3d-6458a1cacb17.png"/></div>
<p>Figure 8.3: The Parse application screen showing the core part</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Defining a transfer entity</h1>
                
            
            
                
<p class="mce-root">On the left-hand side navigation pane, we see the Core | Browser menu. This is where we can see all the data on our Parse platform. There are already some built-in classes, but we are going to define a new class to help do the money transfer.</p>
<p class="mce-root">Click on Create a class in the Core | Browser menu. A dialog box, as shown in the following screenshot, will appear. We will use it to name our new class, <kbd>Transfer</kbd>. This will be our main entity responsible for mobile payment and, of course, money transfer:</p>
<div><img src="img/503a0e46-cad1-42ff-a1ea-957de650b2db.png" style="width:40.67em;height:17.67em;"/></div>
<p>Figure 8.4: A dialog for defining a new class in Parse</p>
<p>Then we need to set up some new columns for this entity. We define the following columns:</p>
<ul>
<li>from: The mobile number to pay money.</li>
<li>to: The mobile number to receive money.</li>
<li>amount: The amount of money to pay.</li>
<li>sent: A flag needs to be set to <kbd>true</kbd> when we want to start to process the transaction. If this field is <kbd>null</kbd> or <kbd>false</kbd>, the WebHook (see next) will just receive data and do nothing.</li>
<li>processed: A flag will be automatically set to <kbd>true</kbd> if the transaction is finished processing.</li>
</ul>
<p class="mce-root">How can we use this class? Using the dashboard, as shown in the following screenshot, we set mobile numbers for the  from, to, and amount columns. Then, when we are ready, just set the sent column to <kbd>true</kbd>.</p>
<p>If the processing goes wrong, the sent flag will be reset to <kbd>null</kbd> automatically by the WebHook:</p>
<div><img src="img/ed892941-46b9-4d16-8b48-648816a47400.png" style="text-align: center;color: #333333;font-size: 1em;"/></div>
<p>Figure 8.5: Browsing the Transfer class using the dashboard</p>


            

            
        
    

        

                            
                    <h1 class="header-title">WebHook</h1>
                
            
            
                
<p>The Parse platform provides an extensible mechanism to allow us to process business logic externally. This is where functions come in. This mechanism is called <strong>WebHook</strong>.</p>
<p>We may have functions running as external processes, outside the Parse platform, and use them in conjunction with Parse's WebHook to perform complex business logic. As in the previous example, we already have the <kbd>Transfer </kbd>class. We then define a WebHook for this class to call an external function every time, before each of the <kbd>Transfer</kbd> entities is saved. We specify a URL to a FaaS gateway for this WebHook. The <kbd>HTTP POST</kbd> method will be made to the specified URL with the JSON as its request body. The request body contains the data of the current <kbd>Transfer</kbd> entity.</p>
<p>A WebHook in Parse can be created by going to Core | Webhooks and clicking on the small Create a webhook option:</p>
<div><img src="img/80730e70-8319-4198-ac6f-4bb09ef55b48.png"/></div>
<p>Figure 8.6: A screen for listing the existing WebHooks</p>
<p class="mce-root">There are two kinds of WebHook in Parse: Cloud Code functions and triggers. The kind we are using in this chapter is the <strong>trigger</strong>. A WebHook trigger can hook into many places, such as beforeSave, afterSave, beforeDelete, and afterDelete.</p>
<p class="mce-root">In the example we are discussing in this chapter, the beforeSave trigger will be used as shown in the following screenshot. We choose Transfer as the target class of this hook. Then we need to specify the Webhook URL, a bank routing function deployed to Fn:</p>
<div><img src="img/df3b761c-1a87-4a66-bee0-77c6c56c0e38.png" style="width:28.75em;height:21.00em;"/></div>
<p>Figure 8.7: A dialog for defining a new WebHook; beforeSave for class Transfer</p>
<p class="mce-root">We will talk about the bank routing WebHook in the next section, but let's see it in action briefly before we explore its details.</p>
<p class="mce-root">We test the WebHook by sending data by creating a new instance of the <kbd>Transfer</kbd> class. In the following screenshot, mobile number <kbd>+661234567</kbd> is not registered yet. So it cannot be looked up, and the WebHook returns an error message:</p>
<div><img src="img/620a7f5d-f115-4692-9702-645daf12fedd.png"/></div>
<p>Figure 8.8: An error message sent back from the WebHook will pop up on the bottom right</p>
<p>To see error logs, click on Core | Logs, as shown in the following screenshot. Here is an example of the Webhook returning the following JSON:</p>
<pre>{"error": "Could not lookup number: +661234567"}</pre>
<div><img src="img/e1f81644-29a1-4eff-8a32-57cd24e3c0c8.png"/></div>
<p>Figure 8.9: Info-level log screen displaying all kind of logs, including errors</p>
<p>The specifications of the returning messages are <kbd>{"success": object}</kbd> to update data back to the Parse platform, and <kbd>{"error":"msg"}</kbd> to display the error message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing a WebHook in Fn</h1>
                
            
            
                
<p>The Fn Project works best with functions written in Java. When calling a function, the framework would be able to automatically transform the body of the request as a parameter of the entrypoint method. In the following example, the JSON from the request will be converted into a string for the <kbd>handleRequest</kbd> method, the entrypoint method of this Fn function:</p>
<pre>public Object handleRequest(String body) {<br/>    if (body == null || body.isEmpty()) {<br/>        body = "{}";<br/>    }<br/>     Input input;<br/>    try {<br/>        val mapper = new ObjectMapper();<br/>        input = mapper.readValue(body, Input.class);<br/>    } catch (IOException e) {<br/>        return new Error(e.getMessage());<br/>    }<br/>     if (input == null) {<br/>        return new Error(body);<br/>     }<br/>     /* process the rest of business logic */<br/>}</pre>
<p>Here's the list of <strong>data transfer object</strong> (<strong>DTO</strong>) classes to properly encode and decode Parse's WebHook messages inside an Fn function. With help from Project Lombok and Jackson, we can dramatically reduce numbers of lines of code. An <kbd>Input</kbd> object is the wrapper for a Java's <kbd>Transfer</kbd> object, that contains all columns similar to the <kbd>Transfer</kbd> class, which we have defined on the Parse platform.</p>
<p>Please note that we have a <strong>Transfer</strong> class on both sides of the system, on the Parse platform, and also on the Fn platform.</p>
<p>The <kbd>Success</kbd> and <kbd>Error</kbd> class are for returning processing results back to Parse:</p>
<pre>@Data<br/>@AllArgsConstructor<br/>@JsonIgnoreProperties(ignoreUnknown = true)<br/>public static class <strong>Input</strong> {<br/>    private Transfer object;<br/>}<br/><br/>@Data<br/>@NoArgsConstructor<br/>@JsonIgnoreProperties(ignoreUnknown = true)<br/>public static class <strong>Transfer</strong> {<br/>    private String objectId;<br/>    private String from;<br/>    private String to;<br/>    private Double amount;<br/>    private Boolean sent;<br/>    private Boolean processed;<br/>}<br/><br/>@Data<br/>@AllArgsConstructor<br/>public static class <strong>Success</strong> {<br/>    private Transfer success;<br/>}<br/><br/>@Data<br/>@AllArgsConstructor<br/>public static class <strong>Error</strong> {<br/>    private String error;<br/>}</pre>
<p>As it is a Java project, we do not need to build it inside the container. Here's the Gradle build file, which could be built using the <kbd>gradle installDist</kbd> command:</p>
<pre>plugins {<br/>    id 'io.franzbecker.gradle-lombok' version '1.11'<br/>    id 'java'<br/>    id 'groovy'<br/>    id 'application'<br/>}<br/><br/>mainClassName = 'App'<br/><br/>dependencies {<br/>    // FN Project<br/>    compile 'com.fnproject.fn:api:1.0.56'<br/><br/>    // JSON encoding<br/>    compile 'com.fasterxml.jackson.core:jackson-annotations:2.9.4'<br/>    compile 'com.fasterxml.jackson.core:jackson-databind:2.9.4'<br/><br/>    // REST client<br/>    compile 'com.squareup.okhttp3:okhttp:3.9.1'<br/><br/>    // Simplify Java syntax<br/>    compile group: 'org.projectlombok', name: 'lombok-maven',<br/>            version: '1.16.20.0', ext: 'pom'<br/><br/>    // Ethereum Client<br/>    compile 'org.web3j:core:3.2.0'<br/><br/>    // Testing<br/>    testCompile 'com.fnproject.fn:testing:1.0.56'<br/>    testCompile 'junit:junit:4.12'<br/>    testCompile 'org.codehaus.groovy:groovy-all:2.4.12'<br/>    testCompile 'org.spockframework:spock-core:1.0-groovy-2.4'<br/>}<br/><br/>repositories {<br/>    mavenCentral()<br/>    jcenter()<br/>    maven {<br/>        url "https://dl.bintray.com/fnproject/fnproject"<br/>    }<br/>}</pre>
<p>The following is the Dockerfile to build an image for the Fn Project. It needs to inherit from <kbd>fn-java-fdk</kbd>. We use <kbd>jdk9-1.0.56</kbd> for the demo in this book. What you do is copy all JAR files from the <kbd>build</kbd> directory to the <kbd>/function/app</kbd> inside the container image:</p>
<pre>FROM fnproject/fn-java-fdk:jdk9-1.0.56<br/><br/>WORKDIR /function<br/><br/>COPY ./build/install/routing_fn/lib/*.jar /function/app/<br/><br/>CMD ["com.example.fn.TransferFunction::handleRequest"]</pre>
<p>The following steps are to prepare the Fn server, and then we build our function with the <kbd>gradle</kbd> command. Then we build and push its Docker image onto the hub before redefining it as an Fn route.</p>
<p>First, we deploy an Fn Server manually with the following <kbd>docker run</kbd> command. Also, we attach Fn to the <kbd>parse_net</kbd>. There is a special hack to Fn so that we can make every container started by Fn be in the same network, as specified by <kbd>FN_NETWORK</kbd> there:</p>
<pre><strong>docker run \</strong><br/><strong>  --name fnserver \</strong><br/><strong>  --detach \</strong><br/><strong>  -v /var/run/docker.sock:/var/run/docker.sock \</strong><br/><strong>  -v fn_vol:/app/data \</strong><br/><strong>  -p 28080:8080 \</strong><br/><strong>  --network=parse_net \</strong><br/><strong>  --network-alias=fn_gateway \</strong><br/><strong>  -e FN_LOG_LEVEL=debug \</strong><br/><strong>  -e FN_NETWORK=parse_net \</strong><br/><strong>  fnproject/fnserver</strong></pre>
<p>Here's the build and push script. Save the following scripts as <kbd>./buildAndPush</kbd>:</p>
<pre><strong>./gradlew installDist</strong><br/><br/><strong>VERSION=$1</strong><br/><br/><strong>docker build -t chanwit/routing_fn:$VERSION .</strong><br/><strong>docker push chanwit/routing_fn:$VERSION</strong><br/><br/><strong>fn routes delete demo /routing_fn</strong><br/><strong>fn routes create /routing_fn -i chanwit/routing_fn:$VERSION demo</strong></pre>
<p>Then we can start the build and push process by calling the script with a certain version number, as in the following:</p>
<pre><strong>./buildAndPush v1</strong></pre>
<p>In the next section, we will discuss how the WebHook function looks up account data from a blockchain and how we can track the states of each money transfer transaction.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">An event state machine with a blockchain</h1>
                
            
            
                
<p>We use an <em>Ethereum blockchain</em> as the event state machine for the money transfer system. A blockchain in this role is used for storing the following:</p>
<ul>
<li>The mapping between telephone numbers and bank accounts</li>
<li>The overall state of each transfer transaction</li>
</ul>
<p>Inside the blockchain, there are two kinds of smart contracts. The first one implements the <strong>repository pattern</strong>, and the second one implements the <strong>entity model</strong>.</p>
<p>We use Truffle (<a href="http://truffleframework.com/">http://truffleframework.com/</a>) to create this event state machine. Look at the subproject named <em>eventmachine</em> in the GitHub repository (<a href="https://github.com/chanwit/eventmachine">https://github.com/chanwit/eventmachine</a>).</p>
<p>Here's a smart contract under the <kbd>entities/</kbd> directory, <kbd>TransferState.sol</kbd>. This smart contract maintains the states of each transfer transaction. Each transaction is initialized with <strong>NONE</strong>, then <strong>STARTED</strong>, <strong>PENDING</strong>, and finally <strong>COMPLETED</strong>. The following diagram illustrates the smart contract <kbd>TransferState</kbd> working together with its repository implementation:</p>
<div><img src="img/458cdcbd-30fe-49e6-8f7b-c1524b9a2b75.png" style="width:41.75em;height:31.33em;"/></div>
<p>Figure 8.10: Flow of state transition and event emission by smart contracts</p>
<p>We then explore its code for a bit. When moving to the next state, we use the <kbd>require</kbd> statement to check and let the smart contract throw an exception, if the pre-condition is not met:</p>
<pre>contract TransferState {<br/><br/>  enum State { NONE, STARTED, PENDING, COMPLETED }<br/><br/>  string txId;<br/>  State state;<br/><br/>  function TransferState(string _txId) {<br/>    state = State.NONE;<br/>    txId = _txId;<br/>  }<br/><br/>  function start() public {<br/>    require(state == State.NONE);<br/>    state = State.STARTED;<br/>  }<br/><br/>  function pending() public {<br/>    require(state == State.STARTED);<br/>    state = State.PENDING;<br/>  }<br/><br/>  function complete() public {<br/>    require(state == State.PENDING);<br/>    state = State.COMPLETED;<br/>  }<br/><br/>  function currentState() public constant returns (uint8) {<br/>    return uint8(state);<br/>  }<br/>}</pre>
<p>As previously mentioned, the <kbd>TransferState</kbd> is managed by the smart contract <kbd>TransferStateRepository</kbd>. Basically, this is an implementation of the repository pattern (<a href="https://hub.packtpub.com/domain-driven-design/">https://hub.packtpub.com/domain-driven-design/</a>). Additionally, this smart contract naturally runs on the blockchain. To allow it to communicate with the outside world, every smart contract has to emit a kind of event. In the case of this <kbd>TransferStateRepository</kbd>, it has been designed to emit events when each transaction changes its status to <kbd>STARTED</kbd>, <kbd>PENDING</kbd>, and also <kbd>COMPLETED</kbd>. See the event signatures there in <em>Figure 8.10</em>:</p>
<pre>contract TransferStateRepository {<br/><br/>    event TransferStarted(string txId);<br/>    event TransferPending(string txId);<br/>    event TransferCompleted(string txId);<br/><br/>    mapping(bytes32 =&gt; address) states;<br/><br/>    function start(string txId) public {<br/>        /* register the state, set to STARTED */<br/>        TransferStarted(txId);<br/>    }<br/><br/>    function pending(string txId) public {<br/>        /* check the state, set to PENDING */<br/>        TransferPending(txId);<br/>    }<br/><br/>    function complete(string txId) public {<br/>        /* check the state, set to COMPLETED */<br/>        TransferCompleted(txId);<br/>    }<br/><br/>    function getStateOf(string txId) public constant returns (string) {<br/>        /**/<br/>        if (state == 0) return "NONE";<br/>        else if (state == 1) return "STARTED";<br/>        else if (state == 2) return "PENDING";<br/>        else if (state == 3) return "COMPLETED";<br/>    }<br/>}</pre>
<p>The mapping between telephone numbers and bank accounts is maintained by <kbd>RegistrationRepository</kbd>. This smart contract uses the same technique to communicate with the outside world, emitting events.</p>
<p>There are four events designed for <kbd>RegistrationRepository</kbd>. The <kbd>Registered</kbd> event is fired when we register a new telephone number into the mapping. If we try to register the same number again, the <kbd>AlreadyExisted</kbd> event is fired from the blockchain.</p>
<p><kbd>RegistrationFound</kbd> is the event fired when we find a mobile number by name via the <kbd>findTelByNo</kbd> function and when this function cannot find any registration matched by the input mobile number, the <kbd>RegistrationNotFound</kbd> event is emitted:</p>
<pre>contract RegistrationRepository {<br/><br/>    mapping(bytes32 =&gt; address) registrations;<br/><br/>    event Registered(string telNo, address registration);<br/>    event AlreadyExisted(string telNo);<br/>    event RegistrationFound(string telNo, string bank, string accNo);<br/>    event RegistrationNotFound(string telNo);<br/><br/>    function register(string telNo, string bank, string accNo) public {<br/>        /**/<br/>        Registered(telNo, address(r));<br/>    }<br/><br/>    function findByTelNo(string telNo) public returns (address) {<br/>        /**/<br/>        Registration r = Registration(registrations[key]);<br/>        RegistrationFound(telNo, to_s(r.bank()), to_s(r.accNo()));<br/><br/>        return address(r);<br/>    }<br/><br/>}</pre>
<p>Using the Truffle framework, we are allowed to initialize some data with JavaScript during the development. Here's one of the migration scripts, found under the <kbd>migrations/</kbd> directory, that is used for deploying smart contracts to the blockchain and registering two mobile numbers. The first number links to an account managed by an account managed by <strong>Bank #1</strong>, the OpenFaaS bank. The second mobile number is registered and linked to <strong>Bank #2</strong>, the OpenWhisk bank. In all banks, we already have accounts containing deposits:</p>
<pre>var RegistrationRepository = artifacts.require(<br/>  "./v2/repository/RegistrationRepository.sol");<br/>var TransferStateRepository = artifacts.require(<br/>  "./v2/repository/TransferStateRepository.sol");<br/><br/>module.exports = function(deployer) {<br/><br/>  deployer.deploy(TransferStateRepository);<br/><br/>  deployer.deploy(RegistrationRepository).then(function() {<br/>    RegistrationRepository.deployed().then(function(repo){<br/>      repo.register("+661234567", "faas", "55700").then();<br/>      repo.register("+661111111", "whisk", "A1234").then();<br/>    });<br/>  });<br/><br/>};</pre>
<p>We set up an Ethereum blockchain network with Parity, one of the most stable Ethereum clients. Here's the setup. We attach the running Parity container to the same network of both Fn and the Parse platform:</p>
<pre><strong>docker run --rm --name=parity_dev -d -p 8545:8545 -p 8180:8180 \</strong><br/><strong>   --network=parse_net \</strong><br/><strong>   --network-alias=blockchain \</strong><br/><strong>   parity/parity:stable-release \</strong><br/><strong>   --geth --chain dev --force-ui \</strong><br/><strong>   --reseal-min-period 0 \</strong><br/><strong>   --jsonrpc-cors http://localhost \</strong><br/><strong>   --jsonrpc-apis all \</strong><br/><strong>   --jsonrpc-interface 0.0.0.0 \</strong><br/><strong>   --jsonrpc-hosts all</strong></pre>
<p>For the production private blockchain network, we need to set things up differently. For example, we need to set up our own genesis block and the mining behavior of the network. Anyway, it is beyond the scope of this book. We then deploy the smart contract via Truffle:</p>
<pre><strong>$ cd eventmachine</strong><br/><strong>$ truffle exec scripts/unlock.js</strong><br/><strong>$ truffle migrate</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How the WebHook uses the blockchain</h1>
                
            
            
                
<p>We will regularly go back to the WebHook after discussing each component around it.</p>
<p>We already know how our blockchain and smart contracts work. They record mobile number registration, and maintain states of transfer transactions. In this section, we discuss how the WebHook function interacts with the blockchain. The following is the snippet from the WebHook function. The lookup method inside the function obtains the smart contract <kbd>RegistrationRepository</kbd> and then invokes <kbd>findByTelNo()</kbd> on the blockchain. The result is then available inside a transaction receipt. We check what kind of event is stored inside that receipt. If it is an <kbd>RegistrationFound</kbd> event, then this method returns a result object containing information regarding the bank name and account number.</p>
<p>There is room for improving this check.<br/>
<br/>
How should the reader optimize the smart contract to fire only one event and meaningfully check whether the telephone number is already registered or not?</p>
<p>That is basically about the lookup part:</p>
<pre>@Data<br/>@AllArgsConstructor<br/>static class RegistrationResult {<br/>    private String bankName;<br/>    private String accountId;<br/>}<br/><br/>public RegistrationResult lookup(String telNo) throws Exception {<br/>    val repo = ContractRegistry.registrationRepository();<br/>    val receipt = repo.findByTelNo(telNo).send();<br/>    val foundEvents = repo.getRegistrationFoundEvents(receipt);<br/>    if (foundEvents.isEmpty() == false) {<br/>        val reg = foundEvents.get(0);<br/>        return new RegistrationResult(reg.bank, reg.accNo);<br/>    } else {<br/>        val notFoundEvents = repo.getRegistrationNotFoundEvents(receipt);<br/>        if(notFoundEvents.isEmpty() == false) {<br/>            val reg = notFoundEvents.get(0);<br/>            return null;<br/>        }<br/>    }<br/><br/>    throw new Exception("Lookup does not find any event in receipt.");<br/>}</pre>
<p>The transfer state management part is implemented inside a set of methods whose names start with <kbd>transfer</kbd>.</p>
<p>Here's the method to tell that we start new transactions with ID <kbd>txId</kbd>. It uses the <kbd>ContractRegistry</kbd> to obtain the smart contract, <kbd>TransferStateRepository</kbd>. Then we create a new transaction state and set its state to be <kbd>STARTED</kbd>. If everything is OK, we should get a transaction receipt from the call with an event, <kbd>TransferStartedEvent</kbd>, embedded in the receipt:</p>
<pre>private boolean transferStart(String txId) {<br/>    try {<br/>        val repo = ContractRegistry.transferStateRepository();<br/>        val receipt = repo.start(txId).send();<br/>        val events = repo.getTransferStartedEvents(receipt);<br/>        if (events.isEmpty()) {<br/>            return false;<br/>        }<br/>        return true;<br/>    } catch (Exception e) {<br/>        return false;<br/>    }<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Wrapping a legacy with a function</h1>
                
            
            
                
<p class="mce-root">In this section, we will demonstrate how to write a wrapper function for a legacy web-based system. To achieve this, we use the <kbd>chromeless</kbd> library (<a href="https://github.com/graphcool/chromeless">https://github.com/graphcool/chromeless</a>) to connect to a headless Chrome instance. Then the <kbd>chromeless</kbd> script drives the Chrome browser to do the rest for us.</p>
<p class="mce-root">The following diagram shows the working mechanism of this part of the system:</p>
<div><img src="img/6952b6d1-50d6-4266-a91f-94e898a097eb.png"/></div>
<p>Figure 8.11: Diagram of implementing an OpenFaaS function to wrap around a UI-based ERP</p>
<p class="mce-root">What does <kbd>chromeless</kbd> do? <kbd>chromeless</kbd> is a Node.js library that can be used to perform browser automation, similar to PhantomJS or Selenium. But it is really fast. Together with headless Chrome instances, <kbd>chromeless</kbd> yields a very fast performance. So it could be used as a serverless function.</p>
<p class="mce-root">We start by using FaaS CLI to create a project. We call this function <kbd>hivectl</kbd>, a program to control an ERP program built with the Moqui framework, HiveMind. We will talk about HiveMind shortly after setting up this function:</p>
<pre><strong>$ faas new hivectl --lang node</strong><br/><strong>2018/03/04 22:28:49 No templates found in current directory.</strong><br/><strong>2018/03/04 22:28:50 Attempting to expand templates from https://github.com/openfaas/templates.git</strong><br/><strong>2018/03/04 22:28:55 Fetched 11 template(s) : [csharp dockerfile go go-armhf node node-arm64 node-armhf python python-armhf python3 ruby] from https://github.com/openfaas/templates.git</strong><br/><strong>Folder: hivectl created.</strong><br/><br/><strong>$ cd hivectl</strong></pre>
<p class="mce-root">Here's the content of <kbd>hivectl.yml</kbd>, the OpenFaaS function descriptor for the <kbd>hivectl</kbd> function:</p>
<pre class="mce-root">provider:<br/>  name: faas<br/>  gateway: http://localhost:8080<br/><br/>functions:<br/>  hivectl:<br/>    lang: node<br/>    handler: ./hivectl<br/>    image: chanwit/hivectl:0.4</pre>
<p>Here's a sample configuration to make <kbd>chromeless</kbd> connect to headless Chrome running inside another container on the same network. The trick is to set <kbd>launchChrome</kbd> to <kbd>false</kbd>, and set <kbd>cdp</kbd>, <strong>Chrome DevTool Protocol</strong>, pointing to <kbd>host:'chrome', port: 9222</kbd>:</p>
<pre>const chromeless = new Chromeless({<br/>  launchChrome: false,<br/>  cdp: { host: 'chrome', port: 9222, secure: false, closeTab: true }<br/>})</pre>
<p class="mce-root">Here is the main <kbd>chromeless</kbd> script to remotely control a headless Chrome instance. We will put the program into <kbd>hivectl/handler.js</kbd>:</p>
<pre>const { Chromeless } = require('chromeless')<br/>const url = 'http://hivemind/vapps/hmadmin/Accounting/FinancialAccount/FinancialAccountTrans?finAccountId='<br/><br/>module.exports = (content, callback) =&gt; {<br/><br/>  async function run(accountId, amount) {<br/><br/>    const chromeless = new Chromeless({<br/>      launchChrome: false,<br/>      cdp: { host: 'chrome', port: 9222, secure: false, closeTab: true }<br/>    })<br/><br/>    const screenshot = await chromeless<br/>      .goto('http://hivemind/Login/logout')<br/>      .click('#TestLoginLink_button')<br/>      .wait('.btn-danger')<br/>      .goto(url + accountId)<br/>      .wait('#AdjustDialog-button')<br/>      .click('#AdjustDialog-button')<br/>      .type(amount, '#AdjustFinancialAccount_amount')<br/>      .mousedown('#select2-AdjustFinancialAccount_reasonEnumId-container')<br/>      .mouseup('#select2-AdjustFinancialAccount_reasonEnumId-container')<br/>      .press(40, 5)<br/>      .press(13)<br/>      .click('#AdjustFinancialAccount_submitButton')<br/>      .screenshot()<br/>      .catch(e =&gt; {<br/>        console.log('{"error":"' + e.message + '"}')<br/>        process.exit(1);<br/>      })<br/><br/>    console.log('{"success": "ok", "screenshot":"' + screenshot + '"}')<br/><br/>    await chromeless.end()<br/>  }<br/><br/>  const opt = JSON.parse(content)<br/>  run(opt.accountId, opt.amount).catch(console.error.bind(console))<br/><br/>};</pre>
<p>With OpenFaaS, we can simply build the function container with the following command:</p>
<pre><strong>$ faas build -f ./hivectl.yml</strong><br/><strong>...</strong><br/><strong>Successfully built 1f7cc398fc61</strong><br/><strong>Successfully tagged chanwit/hivectl:0.4</strong><br/><strong>Image: chanwit/hivectl:0.4 built.</strong><br/><strong>[0] &lt; Building hivectl done.</strong><br/><strong>[0] worker done.</strong></pre>
<p class="mce-root">Next, we will define the function in OpenFaaS. On the OpenFaaS UI, define a new function and the dialog will allow us to attach the new function to a specific network, <kbd>parse_net</kbd> in this case:</p>
<ul>
<li><strong>Image</strong>: <kbd>chanwit/hivectl:0.4</kbd></li>
<li><strong>Name</strong>: <kbd>hivectl</kbd></li>
<li><strong>Network</strong>: <kbd>parse_net</kbd></li>
</ul>
<p class="mce-root">We start a headless Chrome instance, exposing it as <kbd>chrome</kbd> on the same network as the caller function. This Chrome headless will be listening on TCP port <kbd>9222</kbd>:</p>
<pre class="mce-root"><strong>docker run -d --network=parse_net \</strong><br/><strong>   --network-alias=chrome \</strong><br/><strong>   --cap-add=SYS_ADMIN \</strong><br/><strong>   justinribeiro/chrome-headless</strong></pre>
<p class="mce-root">We now start an ERP system. It is the HiveMind ERP built using the Moqui framework. We can download it from the Moqui repository on GitHub (<a href="https://github.com/moqui/moqui-framework">https://github.com/moqui/moqui-framework</a>). Fortunately, the Moqui team also prepares a Docker image for use. So just run it and attach it to the main <kbd>parse_net</kbd>. Port <kbd>10000</kbd> is published only for debugging purposes:</p>
<pre class="mce-root"><strong>$ docker run -p 10000:80 \</strong><br/><strong>  -d --network=parse_net \</strong><br/><strong>  --network-alias=hivemind \</strong><br/><strong>  moqui/hivemind</strong></pre>
<p>The following screenshot shows the financial account page that will be processed by the <kbd>chromeless</kbd> function:</p>
<div><img src="img/b1b53acf-c7a6-4e20-af65-c1b31c66afb1.png"/></div>
<p>Figure 8.12: The HiveMind financial account page</p>
<p class="mce-root">Going back to the <strong>back routing</strong>, here's the code inside the WebHook (running on Fn) calling to the <kbd>hivectl</kbd> function (running on OpenFaaS). The WebHook code creates an HTTP client, then sends two parameters, <kbd>accountId</kbd> and <kbd>amount</kbd>, to the <kbd>hivectl</kbd> function:</p>
<pre>public boolean faasAdjust(String txId, <br/>                          String accountId, <br/>                          Double amount) throws Exception {<br/>    val env = System.getenv("FAAS_GATEWAY_SERVICE");<br/>    val faasGatewayService = (env == null? "http://gateway:8080" : env);<br/><br/>    val JSON = MediaType.parse("application/json; charset=utf-8");<br/>    val client = new OkHttpClient();<br/>    val json = new ObjectMapper().writeValueAsString(new HashMap&lt;String,String&gt;(){{<br/>        put("accountId", accountId);<br/>        put("amount", String.valueOf(amount));<br/>    }});<br/>    val body = RequestBody.create(JSON, json);<br/>    val request = new Request.Builder()<br/>            .url(faasGatewayService + "/function/hivectl")<br/>            .post(body)<br/>            .build();<br/>    val response = client.newCall(request).execute();<br/>    System.out.println(response);<br/><br/>    if(response.code() == 200) {<br/>        val str = response.body().string();<br/>        return true;<br/>    }<br/><br/>     throw new Exception(response.toString());<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">A function as a Glue</h1>
                
            
            
                
<p class="mce-root">Besides writing a simple processor, the technique in this section is one of the simplest forms of using functions. We have a bank backend with REST APIs exposed. So we write a function as a Glue to hide the complex interface of the backend. In this example, we use <kbd>Go</kbd> as the language to implement the function.</p>
<p class="mce-root">The scenario is that we have a REST API server and we want to unify it with another similar service. In the example in this chapter, we have two banking backends with different ways of interaction. The first one is a web-based UI without a REST interface, another one is the REST API in this section:</p>
<pre class="mce-root">func main() {<br/>  input := os.Args[1]<br/><br/>  // OpenWhisk params are key/value paris<br/>  params := map[string]interface{}{}<br/>  err := json.Unmarshal([]byte(input), params)<br/>  if err != nil {<br/>    fmt.Printf(`{"error":"%s", "input": "%s"}`, err.Error(), string(input))<br/>    os.Exit(-1)<br/>  }<br/><br/>  entry := Entry{<br/>    Account: Account{<br/>      Id: params["accountId"].(string),<br/>    },<br/>    Amount: params["amount"].(float64),<br/>  }<br/><br/>  jsonValue, err := json.Marshal(entry)<br/>  if err != nil {<br/>    fmt.Printf(`{"error":"%s"}`, err.Error())<br/>    os.Exit(-1)<br/>  }<br/><br/>  accountService := os.Getenv("ACCOUNT_SERVICE")<br/>  if accountService == "" {<br/>    accountService = "http://accounting:8080/entries"<br/>  }<br/><br/>  resp, err := http.Post(accountService,<br/>    "application/json",<br/>    bytes.NewBuffer(jsonValue))<br/><br/>  if err != nil {<br/>    fmt.Printf(`{"error":"%s"}`, err.Error())<br/>    os.Exit(-1)<br/>  }<br/><br/>  if resp.StatusCode &gt;= 200 resp.StatusCode &lt;= 299 {<br/>    fmt.Println(`{"success": "ok"}`)<br/>    os.Exit(0)<br/>  }<br/><br/>  fmt.Printf(`{"error": "%s"}`, resp.Status)<br/>}</pre>
<p class="mce-root">We use the multi-stage build. The <kbd>go build</kbd> command used here in the first stage is to produce static binary. Then we copy it to the second stage, <kbd>/action/exec</kbd>:</p>
<pre class="mce-root"># Stage 0<br/>FROM golang:1.8.5-alpine3.6<br/><br/>WORKDIR /go/src/app<br/>COPY account_ctl.go .<br/><br/>RUN CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -a -tags netgo -ldflags '-extldflags "-static"' -o exec account_ctl.go<br/><br/># Stage 1<br/>FROM openwhisk/dockerskeleton<br/><br/>ENV FLASK_PROXY_PORT 8080<br/><br/>COPY --from=0 /go/src/app/exec /action/<br/>RUN chmod +x /action/exec<br/><br/>CMD ["/bin/bash", "-c", "cd actionProxy python -u actionproxy.py"]</pre>
<p>Do not forget to push the image onto Docker Hub before proceeding to the next step.</p>
<p class="mce-root">Then we define the function using <kbd>wsk</kbd> CLI commands:</p>
<pre class="mce-root"><strong>$ docker build -t chanwit/account_ctl:v1 .</strong><br/><strong>$ docker push chanwit/account_ctl:v1</strong><br/><br/><strong>$ wsk -i action delete account_ctl</strong><br/><strong>$ wsk -i action create --docker=chanwit/account_ctl:v1 account_ctl</strong></pre>
<p class="mce-root">To make a container able to talk to other FaaS platform gateways, we need to change the OpenWhisk invoker's configuration to start every container inside the <kbd>parse_net</kbd> network. The invoker image is fixed to <kbd>3a7dce</kbd> and the OpenWhisk network configuration in the environment variable section of the invoker service, <kbd>CONFIG_whisk_containerFactory_containerArgs_network</kbd>, is set to <kbd>parse_net</kbd>:</p>
<pre class="mce-root">invoker:<br/>    <strong>image: openwhisk/invoker@sha256:3a7dcee078905b47306f3f06c78eee53372a4a9bf47cdd8eafe0194745a9b8d6</strong><br/>    command: /bin/sh -c "exec /init.sh 0 &gt;&gt; /logs/invoker-local_logs.log 2&gt; 1"<br/>    privileged: true<br/>    pid: "host"<br/>    userns_mode: "host"<br/>    links:<br/>      - db:db.docker<br/>      - kafka:kafka.docker<br/>      - zookeeper:zookeeper.docker<br/>    depends_on:<br/>      - db<br/>      - kafka<br/>    env_file:<br/>      - ./docker-whisk-controller.env # env vars shared<br/>      - ~/tmp/openwhisk/local.env # generated during make setup<br/>    environment:<br/>      COMPONENT_NAME: invoker<br/>      SERVICE_NAME: invoker0<br/>      PORT: 8085<br/><br/>      KAFKA_HOSTS: kafka.docker:9092<br/>      ZOOKEEPER_HOSTS: zookeeper.docker:2181<br/><br/>      DB_PROVIDER: CouchDB<br/>      DB_PROTOCOL: http<br/>      DB_PORT: 5984<br/>      DB_HOST: db.docker<br/>      DB_USERNAME: whisk_admin<br/>      DB_PASSWORD: some_passw0rd<br/><br/>      EDGE_HOST: ${DOCKER_COMPOSE_HOST}<br/>      EDGE_HOST_APIPORT: 443<br/><br/>      <strong>CONFIG_whisk_containerFactory_containerArgs_network: parse_net</strong><br/><br/>      WHISK_API_HOST_NAME: ${DOCKER_COMPOSE_HOST}<br/>    volumes:<br/>      - ~/tmp/openwhisk/invoker/logs:/logs<br/>      - /var/run/docker.sock:/var/run/docker.sock<br/>      - /var/lib/docker/containers:/containers<br/>      - /sys/fs/cgroup:/sys/fs/cgroup<br/>    ports:<br/>      - "8085:8085"</pre>
<p class="mce-root">To unify them, we create a function to wrap around the REST API and make both of the interfaces as similar as possible.</p>
<p>To start the REST API server, we use the <kbd>docker run</kbd> command and attach it to the <kbd>parse_net</kbd> with the accounting alias. Port <kbd>18080</kbd> is published for debugging purposes only:</p>
<pre><strong>docker run -p 18080:8080 -d \</strong><br/><strong>  --network=parse_net \</strong><br/><strong>  --network-alias=accounting \</strong><br/><strong>  --name accounting \</strong><br/><strong>  chanwit/accounting:0.1</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">A stream processor</h1>
                
            
            
                
<p class="mce-root">Another use case of a function is to use it as a processor for data streams. A stream may be sent out from any kind of sources, such as data buses or event buses. Kafka, Twitter, or blockchain (in our case, Ethereum) could be a source of data streams. An Ethereum blockchain could emit events specific to some smart contracts when a certain action is taken.</p>
<p class="mce-root">To observe these events in the form of data streams efficiently, we need to use a kind of reactive client. RxJava is one of them. Fortunately, <kbd>web3j</kbd>, the Ethereum client we are using, already has RxJava observables to receive streaming data from an Ethereum blockchain.</p>
<p class="mce-root">We call this component <kbd>listener</kbd>. The following diagram shows what we will implement around the Event Listener:</p>
<div><img src="img/798286f5-8ade-4476-8764-b5183e1bfc15.png" style="width:39.42em;height:20.50em;"/></div>
<p>Figure 8.13: Diagram illustrating relations around the Event Listener</p>
<p class="mce-root">A requirement is that we run the agent (<strong>Event Listener</strong>) as a container on the same network as the blockchain. We use the agent to divert each transaction information to other endpoints. In this example, we have two endpoints. The first one is the record inside Parse. Another one is the S3-compatible storage, Minio. We upload a file to Minio when the transaction is completed.</p>
<p>The following shows how to use a contract observable to listen to blockchain events:</p>
<pre>public class Main {<br/><br/>    public static void main(String[] args) throws Exception {<br/><br/>        val tsrContract = ContractRegistry.unlock((web3j, tm) -&gt; {<br/>            return TransferStateRepository.load(<br/>                        "0x62d69f6867a0a084c6d313943dc22023bc263691",<br/>                        web3j, tm, ManagedTransaction.GAS_PRICE, Contract.GAS_LIMIT);<br/>        });<br/><br/>        tsrContract.transferCompletedEventObservable(<br/>            DefaultBlockParameterName.LATEST,<br/>            DefaultBlockParameterName.LATEST).subscribe(event -&gt; {<br/><br/>            System.out.printf("Transfer completed: %s\n", event.txId );<br/><br/>        });<br/>    }<br/><br/>}</pre>
<p>We use a simple Gradle build script for this component. The project can be built using the <kbd>gradle installDist</kbd> command as usual:</p>
<pre>plugins {<br/>    id 'io.franzbecker.gradle-lombok' version '1.11'<br/>    id 'java'<br/>    id 'application'<br/>}<br/><br/>mainClassName = "event.listener.Main"<br/><br/>repositories {<br/>    mavenCentral()<br/>    jcenter()<br/>}<br/><br/>dependencies {<br/>    compile 'org.slf4j:slf4j-api:1.7.21'<br/>    compile 'org.web3j:core:3.2.0'<br/><br/>    testCompile 'junit:junit:4.12'<br/>}</pre>
<p>Here's the Dockerfile for this component:</p>
<pre>FROM openjdk:8u151-jdk-alpine<br/><br/>RUN mkdir /app<br/>COPY ./build/install/listener/lib/*.jar /app/<br/><br/>ENV BLOCKCHAIN_SERVICE http://blockchain:8545/<br/><br/>WORKDIR /app<br/>CMD ["java", "-cp", "*", "event.listener.Main"]</pre>
<p>This is the Gradle build step, <kbd>docker build</kbd> and <kbd>docker push</kbd> command:</p>
<pre>$ gradle installDist<br/><br/>$ docker build -t chanwit/listener:v1 .<br/>$ docker push chanwit/listener:v1</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Inter-FaaS platform networking</h1>
                
            
            
                
<p class="mce-root">To make all functions of different platforms able to talk together, we need to set up a proper container network. The demo project discussed in this chapter is not a simple FaaS example. It is a complex scenario where functions are allowed to call other functions on the different FaaS platforms.</p>
<p class="mce-root">Normally, on some serverless platforms such as Lambda, we may sometimes assume that all functions run on the flat network of the provider. In contrast, when we run functions on our own platforms, we could segment the networks ourselves and function networking will become a challenge. However, networking will be relatively simple because the networking model in Docker and Swarm is the flat network.</p>
<p class="mce-root">How can we achieve this? By the following:</p>
<ol>
<li class="mce-root">We create an attachable Swarm-scoped network</li>
<li class="mce-root">We start a FaaS framework and make its gateway attach to that network</li>
<li class="mce-root">We also need to tell the framework that it must attach that network to every container it created</li>
</ol>
<p>In OpenFaas, it allows you to create a function to run on a specific network. In OpenWhisk, we can specify this with a configuration of an invoker. For the Fn Project, we need an additional hack. Here's the change required to patch to Fn in order to make it able to attach function containers to a specified network (<kbd>FN_NETWORK</kbd>):</p>
<pre>var networkingConfig *docker.NetworkingConfig<br/>fnNetwork := os.Getenv("FN_NETWORK")<br/>if fnNetwork != "" {<br/>    log.Debugf("Env FN_NETWORK found: %s. Create container %s with network.", <br/>               fnNetwork, task.Id())<br/>    networkingConfig = docker.NetworkingConfig{<br/>        EndpointsConfig: map[string]*docker.EndpointConfig{<br/>            fnNetwork: {<br/>                Aliases: []string{task.Id()},<br/>            },<br/>        },<br/>    }<br/>}<br/>container := docker.CreateContainerOptions{<br/>    Name: task.Id(),<br/>    Config: docker.Config{<br/>        Env: envvars,<br/>        Cmd: cmd,<br/>        Memory: int64(task.Memory()),<br/>        MemorySwap: int64(task.Memory()),<br/>        KernelMemory: int64(task.Memory()),<br/>        CPUShares: drv.conf.CPUShares,<br/>        Hostname: drv.hostname,<br/>        Image: task.Image(),<br/>        Volumes: map[string]struct{}{},<br/>        OpenStdin: true,<br/>        AttachStdin: true,<br/>        StdinOnce: true,<br/>    },<br/>    HostConfig: docker.HostConfig{<br/>        LogConfig: docker.LogConfig{<br/>            Type: "none",<br/>        },<br/>    },<br/>    NetworkingConfig: networkingConfig,<br/>    Context: ctx,<br/>}</pre>
<p>The version with the function networking patch is available at <a href="https://github.com/chanwit/fn">https://github.com/chanwit/fn</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<p>This chapter covers a lot of practices and hacks to make the whole stack of the demo project, a mobile payment system, work. Please go through the content of all the sections in this chapter:</p>
<ol>
<li>Why do we need to hack the Fn to build a custom version of an Fn server?</li>
<li>What is the concept of inter-FaaS platform networking? Why is it important?</li>
<li>What are the two roles of an Ethereum block in the demo project?</li>
<li>What is the data type of the parameters of an OpenWhisk function?</li>
<li>How can we encode JSON in Java with Fn?</li>
<li>How can we encode JSON in Golang?</li>
<li>What is the Parse platform?</li>
<li>What is the role of Parse WebHook?</li>
<li>What is the concept of a Glue function?</li>
<li>How can we write a function to wrap a legacy web-based application?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter demonstrated a use case by showing how we can develop a mobile payment system on FaaS platforms.</p>
<p>We used Parse as a UI backend. Then we connected Parse to a bank routing function running on Fn via the Parse WebHook mechanism. We then demonstrated that with functions, it was relatively easy to make a call to a modern infrastructure such as blockchain. We simulated two banks to show use cases of a function, a function as a Glue, and a function that wrapped legacy systems. Then we demonstrated how a function was used in conjunction with a streaming agent to process data streams.</p>
<p>All of the three FaaS platforms were linked together and run on the same Docker Swarm cluster. It was quite simple to link OpenWhisk and OpenFaaS functions together, but in the case of Fn, it was a bit of a hack because the current version of Fn doesn't allow you to define a container network.</p>
<p>The next chapter will be the final chapter of this book. We will conclude the concept of a function and look forward to see what's next beyond the world of FaaS.</p>


            

            
        
    </body></html>