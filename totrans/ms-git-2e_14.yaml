- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing Subprojects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative Development
    with Git*, we learned how to manage multiple repositories, while [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*, taught us various development techniques utilizing
    multiple branches, and multiple lines of development in these repositories. Up
    until now, these multiple repositories were all being developed independently
    of each other. Repositories of the different projects were autonomous.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will explain and show different ways to connect different subprojects
    in one single repository of the framework project, from the strong inclusion by
    embedding the code of one project in the other (subtrees) to the light connection
    between projects by nesting repositories (submodules). You will learn how to add
    a subproject to a master project, how to update the superproject state, and how
    to update a subproject. We will find out how to send our changes upstream, backport
    them to the appropriate project, and push them to the appropriate repository.
    Different techniques of managing subprojects have different advantages and drawbacks
    here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing library and framework dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Dependency management tools: managing dependencies outside of Git'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing code into a superproject as a subtree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using subtree merges; the **git-subtree** and **git-stree** tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Nested repositories (submodules): a subproject inside a superproject'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Internals of submodules: gitlinks, **.gitmodules**, and the **.****git** file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for subtrees and submodules; comparison of approaches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative third-party solutions and tools/helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a living framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various reasons to join an external project to your own project. As
    there are different reasons to include a project (let’s call it a **subproject**,
    or a **module**) inside another project (let’s call it a **superproject**, or
    a **master project**), there are different types of inclusions geared toward different
    circumstances. They all have their advantages and disadvantages, and it is important
    to understand these to be able to choose the correct solution for your problem.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that you work on a web application and that your web app uses JavaScript
    (perhaps working as a single-page app). To make it easier to develop, you probably
    use some JavaScript library or a web framework, such as React.
  prefs: []
  type: TYPE_NORMAL
- en: Such a library is a separate project. You would want to be able to pin it to
    a known working version (to avoid problems where future changes to the library
    would make it stop working for your project), while also being able to review
    changes and automatically update it to the new version. Perhaps you would want
    to make your own changes to the library and send the proposed changes to the upstream.
    Of course, you would want users of your project to be able to use the library
    with your out-of-tree fixes, even if they are not yet accepted by original developers.
    Conceivably, you might have customizations and changes that you don’t want to
    publish (send to the upstream), but you might still make them available.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is all possible in Git. There are two main solutions for including subprojects:
    importing code into your project with the **subtree** merge strategy and linking
    subprojects with **submodules**.'
  prefs: []
  type: TYPE_NORMAL
- en: Both submodules and subtrees aim to reuse the code from another project, which
    usually has its own repository, putting it somewhere inside your own repository’s
    working directory tree. The goal is usually to benefit from the central maintenance
    of the reused code across a number of container repositories, without having to
    resort to clumsy, unreliable manual maintenance (usually by copy-pasting).
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, it is more complicated. The typical situation in many companies is
    that they use many in-house produced applications, which depend on the common
    utility library, or a set of libraries. You would often want to develop each of
    such applications separately, use it together with others, branch and merge, and
    apply your own changes and customizations, all in their own separate Git repositories.
    But there are also advantages to having a single **monolithic repository** (**monorepo**),
    such as simplified organizations, dependencies, cross-project changes, and tooling
    if you can get away with it.
  prefs: []
  type: TYPE_NORMAL
- en: The mechanism used by submodules and subtrees solutions (of having separate
    Git repositories for each application, framework, or library) is not without problems.
    The development gets more complex because you now have multiple repositories to
    interact with. If the library gets improved, you would want to update your subproject
    and need to test whether this new version correctly works with your code, then
    decide whether to use it in your superproject. On the other hand, at some point
    in time, you would want to send your changes to the library itself to share their
    changes with other developers, if only to share the burden of maintaining these
    features (the out-of-tree patches bring maintenance costs to keep them current).
  prefs: []
  type: TYPE_NORMAL
- en: What to do in those cases? This chapter describes a few strategies used to manage
    subprojects. For each technique, we will detail how to add such subprojects to
    superprojects, how to keep them up to date, how to create your own changes, and
    how to publish selected changes upstream.
  prefs: []
  type: TYPE_NORMAL
- en: Subdirectory requirement
  prefs: []
  type: TYPE_NORMAL
- en: Note that all the solutions require that all the files of a subproject be contained
    in a single subdirectory of a superproject. No currently available solution allows
    you to mix the subproject files with other files, or have them occupy more than
    one directory.
  prefs: []
  type: TYPE_NORMAL
- en: However you manage subprojects, be it subtrees, submodules, third-party tools,
    or dependency management outside Git, you should strive for the module code to
    remain independent of the particularities of the superproject (or at least, handle
    such particularities using an external, possibly non-versioned configuration).
    Using superproject-specific modifications goes against modularization and encapsulation
    principles, unnecessarily coupling the two projects.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, sharing common components, libraries, and tooling, and keeping
    them the same for all the distinct but related projects might be more important
    than the autonomy of those projects (for example, if they are all developed by
    the same company). It might be the case with the polyrepo setup that introducing
    a new feature always makes it necessary to create multiple commits in multiple
    repositories, instead of requiring only a single commit. In those cases, monorepo
    might be a better solution.
  prefs: []
  type: TYPE_NORMAL
- en: Managing dependencies outside of Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many cases, the development stack used allows you to simply use **packaging**
    and **formal dependency management**. If it is possible, it is usually preferable
    to go this route. Using dependency management solutions lets you split your code
    base better and avoid a number of side effects, complications, and pitfalls that
    litter the submodule and subtree solution space (with different complications
    for different techniques). It removes the version control systems from the managing
    modules. It also lets you benefit from versioning schemes, such as **semantic
    versioning**, for your dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a reminder, here’s a partial list (in alphabetical order) of the main languages
    and development stacks, and their dependency management/packaging systems and
    registries (see the full comparison at [www.modulecounts.com](http://www.modulecounts.com)):'
  prefs: []
  type: TYPE_NORMAL
- en: Go has GoDoc
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java has Maven Central (Maven and Gradle)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript has npm (for Node.js) and Bower
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET has NuGet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Objective-C has CocoaPods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perl has **Comprehensive Perl Archive Network** (**CPAN**) and carton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PHP has Composer, Packagist, and good old PEAR and PECL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Python has **Python Package Index** (**PyPI**) and pip
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby has Bundler and RubyGems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rust has Crates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, just using the official package registry is not enough. You might
    need to apply some out-of-tree patches (changes) to customize the module (subproject)
    for your needs. Sometimes, however, for many reasons, you might be unable to publish
    these changes upstream to have them accepted. Perhaps the changes are relevant
    only to your specific project, or the upstream is slow to respond to the proposed
    changes, or perhaps there are license considerations. Maybe the subproject in
    question is an in-house module that cannot be made public, but which you are required
    to use for your company projects.
  prefs: []
  type: TYPE_NORMAL
- en: In all these cases, you need the **custom package registry** (the package repository)
    to be used in addition to the default one, or you need to let subprojects be managed
    as private packages, which these systems often allow. If there is no support for
    private packages, a tool to manage the private registry, such as Pinto or CPAN::Mini
    for Perl, would be also needed.
  prefs: []
  type: TYPE_NORMAL
- en: Manually importing the code into your project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, the library or a tool that you want to include in your project is
    not available in the package registry (perhaps because of the software stack;
    for example, package registries for C++ such as Conan or vcpkg are quite a new
    thing).
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, let’s take a look at one of the other possibilities: why don’t we
    simply import the library into some subdirectory in our project? If you need to
    bring it up to date, you can just copy the new version as a new set of files.
    In this approach, the subproject code is embedded inside the code of the superproject.'
  prefs: []
  type: TYPE_NORMAL
- en: The simplest solution would be to just overwrite the contents of the subproject’s
    directory each time we want to update the superproject to use the new version.
    If the project you want to import doesn’t use Git, or if it doesn’t use a **version
    control system** (**VCS**) at all, or if the repository it uses is not public,
    this will indeed be the only possible solution.
  prefs: []
  type: TYPE_NORMAL
- en: Using repositories from a foreign VCS as a remote
  prefs: []
  type: TYPE_NORMAL
- en: If the project you want to import (to embed) uses a VCS other than Git but there
    is a good conversion mechanism (for example, with a fast import stream), you can
    use **remote helpers** to set up a foreign VCS repository as a remote repository
    (via automatic conversion). You can check [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140),
    *Collaborative Development with Git*, and [*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320),
    *Customizing and Extending Git*, for more information.
  prefs: []
  type: TYPE_NORMAL
- en: This can be done, for example, with the Mercurial and Bazaar repositories, thanks
    to the **git-remote-hg** and **git-remote-bzr** helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving to the new version of the imported library is quite simple (and the
    mechanism is easy to understand). Remove all the files from the directory, add
    files from the new version of the library (for example, by extracting them from
    the archive), then use the `git add` command to the directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This method works quite well in simple cases with the following caveats:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Git history of your project, you have only the versions of the library
    at the time of import. On the one hand, this makes your project history clean
    and easy to understand; on the other hand, you don’t have access to the fine-grained
    history of a subproject. For example, when using **git bisect**, you would only
    be able to find that it was introduced by upgrading the library, but not the exact
    commit in the history of the library that introduced the bug in question.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to customize the code of the library, fitting it to your project
    by adding the changes dependent on your application, you would need to reapply
    that customization in some way after you import a new version. You could extract
    your changes with **git diff** (comparing it to the unchanged version at the time
    of import) and then use **git apply** after upgrading the library. Or, you could
    use a rebase, an interactive rebase, or some patch management interface; see [*Chapter
    10*](B21194_10_split_000.xhtml#_idTextAnchor247), *Keeping History Clean*. Git
    won’t do this automatically.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each importing of the new version of the library requires running a specific
    sequence of commands to update the superproject: removing the old version of files,
    adding new ones, and committing the change. It is not as easy as running **git
    pull**, though you can use scripts or aliases to help.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Git subtree solution for embedding the subproject code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a slightly more advanced solution, you can use the **subtree merge** to join
    the history of a subproject to the history of a superproject. This is only somewhat
    more complicated than an ordinary pull (at least, after the subproject is imported),
    but provides a way to automatically merge changes together.
  prefs: []
  type: TYPE_NORMAL
- en: 'Depending on your requirements, this method might fit well with your needs.
    It has the following advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: You would always have the correct version of the library, never using the wrong
    library version by accident.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method is simple to explain and understand, using only the standard (and
    well-known) Git features. As you will see, the most important and most commonly
    used operations are easy to do and easy to understand, and it is hard to go wrong.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The repository of your application is always self-contained; therefore, cloning
    it (with plain old **git clone**) will always include everything that’s needed.
    This means that this method is a good fit for the *required dependencies*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to apply patches (for example, customizations) to the library inside
    your repository, even if you don’t have the commit rights to the upstream repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a new branch in your application also creates a new branch for the
    library; it is the same for switching branches. That’s the behavior you expect.
    This is contrasted with the submodule’s behavior (the other technique for managing
    subprojects).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are using the **subtree** merge strategy (described shortly in [*Chapter
    9*](B21194_09.xhtml#_idTextAnchor229), *Merging Changes Together*), for example,
    with **git pull -s subtree**, then getting a new library version will be as easy
    as updating all the other parts of your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unfortunately, however, this technique is not without its disadvantages. For
    many people and for many projects, these disadvantages do not matter. The simplicity
    of the subtree-based method usually prevails over its faults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are the problems with the subtree approach:'
  prefs: []
  type: TYPE_NORMAL
- en: Each application using the library doubles its files. There is no easy and safe
    way to share its objects among different projects and different repositories.
    (See the following callout about the possibility of sharing the Git object database.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each application using the library has its files checked out in the working
    area, though you can change it with the help of the **sparse checkout** (which
    will be described in the next chapter: [*Chapter 12*](B21194_12.xhtml#_idTextAnchor302),
    *Handling* *Large Repositories*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your application introduces changes to its copy of the library, it is not
    that easy to publish these changes and send them upstream. Third-party tools such
    as **git subtree** or **git stree** can help here. They have specialized subcommands
    to extract the subproject’s changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because of the lack of separation between the subproject files and the superproject
    files, it is quite easy to mix the changes to the library and the changes to the
    application in one commit. In such cases, you might need to rewrite the history
    (or the copy of a history), as described in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping* *History Clean*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first two issues mean that subtrees are not a good fit to manage the subprojects
    that are *optional dependencies* (needed only for some extra features) or *optional
    components* (such as themes, extensions, or plugins), especially those that are
    installed by a mere presence in the appropriate place in the filesystem hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Sharing objects between forks (copies) with alternates
  prefs: []
  type: TYPE_NORMAL
- en: You can mitigate the duplication of objects in the repository with **alternates**
    or, in other words, with **git clone --reference**. However, then you would need
    to take greater care about garbage collection. The problematic parts are those
    parts of the history that are referenced in the borrower repository (that is,
    one with alternates set up), but are not referenced in the lender reference’s
    repository. The description and explanation of the alternate mechanisms will be
    presented in [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349), *Git Administration*.
  prefs: []
  type: TYPE_NORMAL
- en: There are different technical ways to handle and manage the subtree-imported
    subprojects. You can use classic Git commands, just using the appropriate options
    while affecting the subproject, such as `--strategy=subtree` (or the `subtree`
    option to the default `recursive` merge strategy, `--strategy-option=subtree=<path>`)
    for `merge`, `cherry-pick`, and related operations. This manual approach works
    everywhere, is actually quite simple in most cases, and offers the best degree
    of control over operations. However, it requires a good understanding of the underlying
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In modern Git (since version 1.7.11), there is the `git subtree` command available
    among installed binaries. It comes from the `contrib/` area and is not fully integrated
    (for example, with respect to its documentation). This script is well tested and
    robust, but some of its notions are rather peculiar or confusing, and this command
    does not support the whole range of possible subtree operations. Additionally,
    this tool supports only the *import with history* workflow (which will be defined
    later), which some say clutters the history graph.
  prefs: []
  type: TYPE_NORMAL
- en: There are also other third-party scripts that help with subtrees; among them
    is `git-subrepo`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a remote for a subproject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Usually, while importing a subproject, you would want to be able to update
    the embedded files easily. You would want to continue interacting with the subproject.
    For this, you would add that subproject (for example, the common library) as a
    **remote reference** in your own (super)project and fetch it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note that, in this example, progress messages were removed for simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can then examine the `mylib_repo/master` remote-tracking branch, which
    can be done either by checking it out into the detached `HEAD` with `git checkout
    mylib_repo/master`, or by creating a local branch out of it and checking this
    local branch out with `git checkout -b mylib_branch mylib_repo/master`. Alternatively,
    you can just list its files with `git ls-tree -r --abbrev mylib repo/master`.
    You will see then that the subproject has a different project root from your superproject.
    Additionally, as can be seen from the **warning: no common commits** message,
    this remote-tracking branch contains a completely different history coming from
    a separate project.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding a subproject as a subtree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are not using specialized tools such as `git subtree` but a manual approach,
    the next step will be a bit complicated and will require you to use some advanced
    Git concepts and techniques. Fortunately, it needs to be done only once.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, if you want to import the *subproject history*, you would need to create
    a merge commit that will import the subproject in question. You need to have the
    files of the subproject in the given directory in a superproject. Unfortunately
    (at least, with the current version of Git as of writing this chapter), using
    the `-Xsubtree=mylib/` merge strategy option would not work as expected. We would
    have to do it in two steps: prepare the parents and then prepare the contents.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step would then be to prepare a merge commit using the `ours` merge
    strategy, but without creating it (writing it to the repository). This strategy
    joins histories, but takes the current version of the files from the current branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you want to have *simple history*, similar to the one we get from just copying
    files, you can skip this step.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to update our index (the staging area for the commits) with the
    contents of the `master` branch from the library repository and update our working
    directory with it. All this needs to happen in the proper subfolder too. This
    can be done with the low-level (plumbing) `git` `read-tree` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We have used the `-u` option, so the working directory is updated along with
    the index. We then need simply to finalize the merge with `git commit`, as Git
    tells us.
  prefs: []
  type: TYPE_NORMAL
- en: Important note!
  prefs: []
  type: TYPE_NORMAL
- en: It is important to not forget the trailing slash in the argument of the **--prefix**
    option. Checked-out files are literally prefixed with it.
  prefs: []
  type: TYPE_NORMAL
- en: This set of steps is described in the HOWTO section of the Git documentation,
    namely, in **How to use the subtree merge strategy**. This HOWTO is available
    at [https://kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html](https://kernel.org/pub/software/scm/git/docs/howto/using-merge-subtree.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'It is much easier to use tools such as `git subtree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `git subtree` command would fetch the subtree’s remote when necessary; there’s
    no need for the manual fetch that you had to perform in the manual solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you examine the history, for example, with `git log --oneline --graph --decorate`,
    you will see that this command merged the library’s history with the history of
    the application (of the superproject). If you don’t want this, tough luck. The
    `--squash` option that `git subtree` offers on its `add`, `pull`, and `merge`
    subcommands won’t help here. One of the peculiarities of this tool is that this
    option doesn’t create a **squash merge**, but simply merges the squashed subproject’s
    history (as if it were squashed with an interactive rebase). The commit message
    would look like this: **Squashed ‘mylib/’ content from commit 5e28a71**. See *Figure
    11**.2(b)* later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want a subtree without its history attached to the superproject history,
    as in *Figure 11**.2(c)*, consider using the external tool, `git-subrepo`. It
    has the additional advantage that it remembers the subtree settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The information about the subproject repository URL, the main branch, the original
    commit, and so on, is stored in the `.gitrepo` file in the directory with the
    subproject. All subsequent `git subrepo` commands refer to the embedded subproject
    by the name of the directory it is in (which is `mylib/` in the preceding example).
  prefs: []
  type: TYPE_NORMAL
- en: You can achieve similar results with the external `git-stree` tool, which was
    deprecated in favor of `git-subrepo`.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning and updating superprojects with subtrees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All right! Now that we have our project with a library embedded as a subtree,
    what do we need to do to get it? Because the concept behind subtrees is to have
    just one repository (the container), you can simply clone this repository.
  prefs: []
  type: TYPE_NORMAL
- en: To get an up-to-date repository, you just need a regular pull; this would bring
    both the superproject (the container) and subproject (the library) up to date.
    This works regardless of the approach taken, the tool used, and the manner in
    which the subtree was added. It is a great advantage of the subtrees approach.
  prefs: []
  type: TYPE_NORMAL
- en: Getting updates from subprojects with a subtree merge
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s see what happens if there are some new changes in the subproject since
    we imported it. It is easy to bring the version embedded in the superproject up
    to date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: You could have fetched and then merged instead, which allows for greater control.
    Or, you could have rebased instead of merging, if you prefer; that works too.
  prefs: []
  type: TYPE_NORMAL
- en: Importance of selecting subtree merge strategy
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget to select the merge strategy with **-s subtree** while pulling
    a subproject. Merging could work even without it because Git does rename detection
    and would usually be able to discover that the files were moved from the root
    directory (in the subproject) to a subdirectory (in the superproject we are merging
    into). The problematic case is when there are conflicting files inside and outside
    of the subproject. Potential candidates are Makefiles and other standard filenames.
  prefs: []
  type: TYPE_NORMAL
- en: If there are some problems with Git detecting the correct directory to merge
    into, or if you need advanced features of an ordinary **ort** merge strategy (which
    is the default), you can instead use **-Xsubtree=<path/to/subproject>**, the **subtree**
    option of the **ort** merge strategy.
  prefs: []
  type: TYPE_NORMAL
- en: You may need to adjust other parts of the application code to work properly
    with the updated code of the library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that, with this solution, you have a subproject history attached to your
    application history, as you can see in *Figure 11**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 11.1 – History of a superproject with a subtree-merged subproject\
    \ inside the ‘maps/’ directory. Subproject history is available \uFEFFin the superproject\
    \ via relevant remote-tracking branch](img/B21194_11_01.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – History of a superproject with a subtree-merged subproject inside
    the ‘maps/’ directory. Subproject history is available in the superproject via
    relevant remote-tracking branch
  prefs: []
  type: TYPE_NORMAL
- en: 'If you don’t want to have the history of a subproject entangled in the history
    of a master project and prefer a simpler-looking history (as shown in *Figure
    11**.1*), you can use the `--squash` option of the `git merge` (or `git pull`)
    command to squash it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Squash merge is described in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging* *Changes Together*.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, in the history, you would have only the fact that the version
    of the subproject had changed, which has its advantages and disadvantages. You
    get *simpler* history but also *simplified* history.
  prefs: []
  type: TYPE_NORMAL
- en: With the `git subtree` or `git subrepo` tools, it is enough to use their `pull`
    subcommand; they supply the `subtree` merge strategy themselves. However, currently,
    `git subtree pull` requires you to respecify `--prefix` and the entire subtree
    settings.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Different types of subtree merges: (a) subtree merge, (b) subtree
    merge of squashed commits, (c) squashed subtree merge](img/B21194_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2 – Different types of subtree merges: (a) subtree merge, (b) subtree
    merge of squashed commits, (c) squashed subtree merge'
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `git subtree` command always merges, even with the `--squash`
    option; it simply squashes the subproject commits before merging (such as the
    `squash` instruction in the interactive rebase). In turn, `git subrepo pull` always
    squashes the merge (such as `git merge --squash`), which keeps the superproject
    history and subproject history separated without polluting the graph of the history.
    All this can be seen in *Figure 11**.2*. Note that the dotted line in *(c)* denotes
    how commits **C2** and **C4** were made, and not that it is the parent commit.
  prefs: []
  type: TYPE_NORMAL
- en: Showing changes between a subtree and its upstream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find out the differences between the subproject and the current version in
    the working directory, you need nontypical selector syntax for `git diff`. This
    is because all the files in the subproject (for example, in the `mylib_repo/master`
    remote-tracking branch) are in the root directory, while they are in the `mylib/`
    directory in the superproject (for example, in `master`). We need to select the
    subdirectory to be compared with `master`, putting it after the revision identifier
    and the colon (skipping it would mean that it would be compared with the root
    directory of the superproject).
  prefs: []
  type: TYPE_NORMAL
- en: 'The command looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, to check after the subtree merge whether the commit we just created
    (`HEAD`) has the same contents in the `mylib/` directory as the merged in the
    commit, that is, `HEAD^2`, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sending changes to the upstream of a subtree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, the subtree code of a subproject can only be used or tested inside
    the container code; most themes and plugins have such constraints. In this situation,
    you’ll be forced to evolve your subtree code straight inside the master project
    code base, before you finally backport it to the subproject upstream.
  prefs: []
  type: TYPE_NORMAL
- en: These changes often require adjustments in the rest of the superproject code;
    though it is recommended to make two separate commits (one for the subtree code
    change and one for the rest), it is not strictly necessary. You can tell Git to
    extract only the subproject changes. The problem is with the commit messages of
    the split changes, as Git is not able to automatically extract relevant parts
    of the changeset description.
  prefs: []
  type: TYPE_NORMAL
- en: Another common occurrence, which is best avoided but is sometimes necessary,
    is the need to customize the subproject’s code in a container-specific way (configure
    it specifically for a master project), usually without pushing these changes back
    upstream. You should carefully distinguish between both situations, keeping each
    use case’s changes (backportable and non-backportable) in their own commits.
  prefs: []
  type: TYPE_NORMAL
- en: There are different ways to deal with this issue. You can avoid the problem
    of extracting changes to be sent upstream by requiring that all the subtree changes
    have to be done in a separate module-only repository. If it is possible, we can
    even require that all the subproject changes have to be sent upstream first, and
    we can get the changes into the container only through upstream acceptance.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to be able to extract the subtree changes, then one possible solution
    is to utilize `git filter-branch --directory-filter` (or `--index-filter` with
    the appropriate script). Another simple solution is to just use `git subtree push`.
    Both of the methods, however, backport *every* commit that touches the subtree
    in question.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to send upstream only a selection of the changes to the subproject
    of those that made it into the master project repository, then the solution is
    a bit more complicated. One possibility is to create a local branch meant specifically
    for backporting out of the subproject remote-tracking branch. Forking it from
    said subtree-tracking branch means that it has the subtree as the root and it
    would include only the submodule files.
  prefs: []
  type: TYPE_NORMAL
- en: This branch, intended for backporting changes to the subproject, would need
    to have the appropriate branch in the remote of the subproject upstream repository
    as its upstream branch. With such a setup, we would then be able to use `git cherry-pick
    --strategy=subtree` the commits we’re interested in sending to the subproject’s
    upstream onto it. Then, we can simply `git push` this branch into the subproject’s
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: Cherry picking and submodules
  prefs: []
  type: TYPE_NORMAL
- en: It is prudent to specify **--strategy=subtree** even if **cherry-pick** would
    work without it, to make sure that the files outside the subproject’s directory
    (outside **subtree**) will get quietly ignored. This can be used to extract the
    subtree changes from the mixed commit; without this option, Git will refuse to
    complete the cherry-pick.
  prefs: []
  type: TYPE_NORMAL
- en: This requires much more steps than ordinary `git push`. Fortunately, you need
    to face this problem only while sending the changes made in the superproject repository
    back to the subproject. As you have seen, fetching changes from the subproject
    into the superproject is much, much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, using `git-stree` would make this trivial; you just need to list the
    commits to be pushed to backport:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In fact, this tool internally uses the same technique, creating and using a
    backport-specific local branch for the subproject.
  prefs: []
  type: TYPE_NORMAL
- en: The Git submodules solution – a repository inside a repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The subtrees method of importing the code (and possibly also the history) of
    a subproject into the superproject has its disadvantages. In many cases, the subproject
    and the container are two different projects: your application depends on the
    library, but it is obvious that they are separate entities. Joining the histories
    of the two doesn’t look like the best solution.'
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the embedded code and imported history of a subproject are always
    here. Therefore, the subtrees technique is not a good fit for optional dependencies
    and components (such as plugins or themes). It also doesn’t allow you to have
    different access controls for the subproject’s history, with the possible exception
    of restricting write access to the subproject (actually to the subdirectory of
    a subproject), by using Git repository management solutions such as `gitolite`
    (you can find more in [*Chapter 14*](B21194_14.xhtml#_idTextAnchor349), *Git Administration*).
  prefs: []
  type: TYPE_NORMAL
- en: The submodule solution is to keep the subproject code and history in its own
    repository and to embed this repository inside the working area of a superproject,
    but not to add its files as superproject files.
  prefs: []
  type: TYPE_NORMAL
- en: Gitlinks, .git files, and the git submodule command
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Git includes the command named `git submodule`, which is intended to work with
    submodules. However, to utilize it correctly, you need to understand at least
    some of the details of its operation. It is a combination of two distinct features:
    the so-called `git submodule` tool itself.'
  prefs: []
  type: TYPE_NORMAL
- en: Both in the subtree solution and the submodule solution, subprojects need to
    be contained in their own folder inside the working directory of the superproject.
    But while, with subtrees, the code of the subproject belongs to the superproject
    repository, this is not the case for submodules. With submodules, each subproject
    has instead its own repository somewhere inside its container repository. The
    code of the submodule belongs to its repository, and the superproject itself simply
    stores the meta-information required to get appropriate revisions of the subproject
    files.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, in modern Git, submodules use a simple `.git` file with a single
    `gitdir:` line containing a relative path to the actual repository folder. The
    submodule repository is actually located inside the superproject’s `.git/modules`
    folder (and has `core.worktree` set up appropriately). This is done mostly to
    handle the case when the superproject has branches that don’t have a submodule
    at all. It allows us to avoid having to scrap the submodule’s repository while
    switching to the superproject revision without it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'You can think of the **.git** file with the **gitdir:** line as a symbolic
    reference equivalent for the **.git** directories, an OS-independent symbolic
    link replacement. The path to the repository doesn’t need to be a relative path:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Be that as it may, the contained superproject and the subproject module truly
    act as (and, in fact, are) independent repositories: they have their own history,
    their own staging area, and their own current branch. Therefore, you should take
    care while typing commands, minding whether you’re inside the submodule or outside
    it, as the context and impact of your commands differ drastically!'
  prefs: []
  type: TYPE_NORMAL
- en: The main idea behind the typical use of submodules is that the superproject
    commit remembers the *exact* revision of the subproject; this reference uses the
    SHA1 identifier of the subproject commit. Instead of using a manifest-like file
    as in some dependency management tools, the submodules solution stores this information
    in a tree object using so-called gitlinks. **Gitlink** is a reference from a **tree
    object** (in the superproject repository) to a **commit object** (usually, in
    the submodule repository); see *Figure 11**.3*. The faint shade of submodule files
    on the left-hand side denotes that they are present as files in the working directory
    of the superproject, but are not in the superproject repository themselves.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – The history of a superproject with a subproject linked as a
    submodule inside the ‘maps/’ subdirectory. Subproject history is separate](img/B21194_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – The history of a superproject with a subproject linked as a submodule
    inside the ‘maps/’ subdirectory. Subproject history is separate
  prefs: []
  type: TYPE_NORMAL
- en: Recall that, following the description of the types of objects in the repository
    database from [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247), *Keeping
    History Clean*, each commit object (representing a revision of a project) points
    exactly to one tree object with the snapshot of the repository contents. Each
    tree object references blobs and trees, representing file contents and directory
    contents, respectively. The tree object referenced by the commit object uniquely
    identifies the set of file contents, filenames, and file permissions contained
    in a revision associated with the commit object.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s remember that the commit objects themselves are connected with each other,
    creating the **Directed Acyclic Graph** (**DAG**) of revisions. Each commit object
    references zero or more parent commits, which together describe the history of
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: Each type of reference mentioned earlier took part in the reachability check.
    If the object pointed to was missing, it means that the repository is corrupt.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is not so for gitlinks. Entries in the tree object pointing to the commits
    refer to the objects in the other separate repository, namely, in the subproject
    (submodule) repository. The fact that the submodule commit being unreachable is
    not an error is what allows us to optionally include submodules: no submodule
    repository, no commit referenced in gitlink.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The results of running `git ls-tree --abbrev HEAD` on a project with all the
    types of objects is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Compare it with the contents of the working area (with `ls -l -``o -F`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Adding a subproject as a submodule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To manage submodules there is the `git submodule` command. It was created to
    help manage the filesystem contents, the metadata, and the configuration of your
    submodules, as well as inspect their status and update them.
  prefs: []
  type: TYPE_NORMAL
- en: With subtrees, the first step was usually to add a subproject repository as
    a remote, which meant that objects from the subproject repository were fetched
    into the *superproject* object database.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the given repository as a submodule at a specific directory in the superproject,
    use the `add` subcommand of the `git submodule`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Note about adding subprojects via a path to their repository
  prefs: []
  type: TYPE_NORMAL
- en: While using paths instead of URLs for remotes, you need to remember that the
    relative paths for remotes are interpreted relative to our main remote, not to
    the root directory of our repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'This command stores the information about the submodule, for example, the URL
    of the repository, in the `.gitmodules` file. It creates a `.gitmodules` file
    if it does not exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that a submodule gets a name equal to its path. You can set the name explicitly
    with the `--name` option (or by editing the configuration); `git mv` on a submodule
    directory will change the submodule path but keep the same name.
  prefs: []
  type: TYPE_NORMAL
- en: Reuse of authentication while fetching submodules
  prefs: []
  type: TYPE_NORMAL
- en: While storing the URL of a remote repository, it is often acceptable and useful
    to store the username with the subproject information (for example, storing the
    username in a URL, such as **user@git.company.com:mylib.git**).
  prefs: []
  type: TYPE_NORMAL
- en: However, remembering the username as a part of the URL is undesirable in **.gitmodules**,
    as this file must be visible to other developers (which often use different usernames
    for authentication). Fortunately, the commands that descend into submodules can
    reuse the authentication from cloning (or fetching) a superproject.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `add` subcommand also runs an equivalent of `git submodule init` for you,
    assuming that if you have added a submodule, you are interested in it. This adds
    some submodule-specific settings to the local configuration of the master project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Why the duplication? Why store the same information in `.gitmodules` and in
    `.git/ config`? Well, because while the `.gitmodules` file is meant for all developers,
    we can fit our local configuration to specific local circumstances. The other
    reason for using two different files is that while the presence of the submodule
    information in `.gitmodules` means only that the subproject is available, having
    it also in `.git/ config` implies that we are interested in a given submodule
    (and that we want it to be present).
  prefs: []
  type: TYPE_NORMAL
- en: You can create and edit the `.gitmodules` file by hand or with `git config -``f
    .gitmodules`.
  prefs: []
  type: TYPE_NORMAL
- en: This file is usually committed to the superproject repository (similar to `.gitignore`
    and `.gitattributes` files), where it serves as the list of possible subprojects.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the other subcommands require the `.gitmodules` file to be present; for
    example, if we would run `git submodule update` before adding it, we would get
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That’s why `git submodule add` stages both the `.gitmodules` file and the submodule
    itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that the whole submodule, which is a directory, looks to `git status` like
    the new file. By default, most Git commands are limited to the active container
    repository only and do not descend to the nested repositories of the submodules.
    As we will see, this is configurable.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning superprojects with submodules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One important issue is that, by default, if you clone the superproject repository,
    you will not get any submodules. All the submodules will be missing from the working
    duplicated directory; only their base directories are here. This behavior is the
    basis of the optionality of submodules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need then to tell Git that we are interested in a given submodule. This
    is done by calling the `git submodule init` command. What this command does is
    copy the submodule settings from the `.gitmodules` file into the superproject’s
    repository configuration, namely, `.git/config`, registering the submodule:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `init` subcommand adds the following two lines to the `.``git/config` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This separate local configuration for the submodules you are interested in allows
    you also to configure your local submodules to point to a different location URL
    (perhaps, a per-company reference clone of a subproject’s repository) from the
    one that is present in the `.``gitmodules` file.
  prefs: []
  type: TYPE_NORMAL
- en: This mechanism also makes it possible to provide a new URL if the repository
    of a subproject has moved. That’s why the local configuration overrides the one
    that is recorded in `.gitmodules`; otherwise, you would not be able to fetch from
    the current URL when switched to the version before the URL change. On the other
    hand, if the repository moved and the `.gitmodules` file was updated accordingly,
    we can re-extract the new URL from `.gitmodules` into local configuration with
    `git` `submodule sync`.
  prefs: []
  type: TYPE_NORMAL
- en: We have told Git that we are interested in the given submodule. However, we
    have still not fetched the submodule commits from its remote and neither have
    we checked it out and have its files present in the working directory of the superproject.
    We can do this with `git` `submodule update`.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcut command
  prefs: []
  type: TYPE_NORMAL
- en: In practice, while dealing with submodules using repositories, we usually group
    the two commands (**init** and **update**) into one with **git submodule update
    --init**; unless we need to customize the URL.
  prefs: []
  type: TYPE_NORMAL
- en: If you are interested in all the submodules, you can use `git clone --recursive`
    (or `git clone --recurse-submodules`) to automatically initialize and update each
    submodule right after cloning.
  prefs: []
  type: TYPE_NORMAL
- en: To temporarily remove a submodule, retaining the possibility of restoring it
    later, you can mark it as not interesting with `git remote deinit`. This just
    affects `.git/config`. To permanently remove a submodule, you need to first deinitialize
    it, and then remove it from `.gitmodules` and from the working area (with `git
    rm`).
  prefs: []
  type: TYPE_NORMAL
- en: Updating submodules after superproject changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update the submodule so that the working directory contents reflect the
    state of a submodule in the current version of the superproject, you need to perform
    `git submodule update`. This command updates the files of the subproject or, if
    necessary, clones the initial submodule repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `git submodule update` command goes to the repository referenced by `.git/config`,
    fetches the ID of the commit found in the index (`git ls-tree HEAD -- plugins/demo`),
    and checks out this version into the directory given by `.git/config`. You can,
    of course, specify the submodule you want to update, giving the path to the submodule
    as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Because we are here checking out the revision given by gitlink, and not by a
    branch, `git submodule update` detaches the subproject’s `HEAD` (see *Figure 11**.3*).
    This command rewinds the subproject straight to the version recorded in the supermodule.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few more things that you need to know:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are changing the current revision of a superproject in any way, either
    by changing a branch, importing a branch with **git pull**, or rewinding the history
    with **git reset**, you need to run **git submodule update** to get the matching
    content to submodules. This is not done automatically by default, because it could
    lead to potentially losing your work in a submodule.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Conversely, if you switch to another branch, or otherwise change the current
    revision in a superproject, and do not run **git submodule update**, Git would
    consider that you changed your submodule directory deliberately to point to a
    new commit (while it is really an old commit that you used before but forgot to
    update). If, in this situation, you would run **git commit -a**, then by accident,
    you will change the gitlink, leading to having an incorrect version of a submodule
    stored in the superproject history.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can upgrade the gitlink reference simply by fetching (or switching to) the
    version of a submodule you want to have by using ordinary Git commands inside
    the subproject and then committing this version in the supermodule. You don’t
    need to use the **git submodule** command here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can have Git automatically fetch the initialized submodules while pulling
    the updates from the master project’s remote repository. This behavior can be
    configured using `fetch.recurseSubmodules` (or `submodule.<name>.fetchRecurseSubmodules`).
    The default value for this configuration is `on-demand` (to fetch if gitlink changes
    and the submodule commit that it points to is missing). You can set it to `yes`
    or `no` to turn recursively fetching submodules on or off unconditionally. The
    corresponding command-line option is `--recurse-submodules`.
  prefs: []
  type: TYPE_NORMAL
- en: You can pass the `--recurse-submodules` command-line option to many Git commands,
    including the `git pull` command, which would then fetch initialized modules and
    update working trees of active submodules.
  prefs: []
  type: TYPE_NORMAL
- en: Always recursing into active submodules
  prefs: []
  type: TYPE_NORMAL
- en: To make those Git commands that support it use the **--recurse-submodules**
    option by default, you can set the **submodule.recurse** configuration option
    to **true**. The **checkout**, **fetch**, **grep**, **pull**, **push**, **read-tree**,
    **reset**, **restore**, and **switch** commands are supported.
  prefs: []
  type: TYPE_NORMAL
- en: Note that instead of checking out the gitlinked revision on the detached `HEAD`,
    we can merge the commit recorded in the superproject into the current branch in
    the submodule with `--merge`, or rebase the current branch on top of the gitlink
    with `--rebase`, just like with `git pull`. The submodule repository branch used
    defaults to `master`, but the branch name may be overridden by setting the `submodule.<name>.branch`
    option in either `.gitmodules` or `.git/config`, with the latter taking precedence.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, using gitlinks and the `git submodule` command is quite complicated.
    Fundamentally, the concept of gitlink might fit well with the relationship between
    subprojects and your superproject, but using this information correctly is harder
    than you think. On the other hand, it gives great flexibility and power.
  prefs: []
  type: TYPE_NORMAL
- en: Examining changes in a submodule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the status, logs, and `diff` output are based solely on the state
    of the active repository and do not descend into submodules. This is often problematic;
    you would need to remember to run `git submodule summary`. It is easy to miss
    a regression if you are limited to this view: you can see that the submodule has
    changed but you can’t see how.'
  prefs: []
  type: TYPE_NORMAL
- en: You can, however, set up Git to make it use a `status.submoduleSummary` configuration
    variable. If it is set to a nonzero number, this number will provide the `--summary-limit`
    restriction; a value of `true` or `-1` will mean an unlimited number.
  prefs: []
  type: TYPE_NORMAL
- en: 'After setting this configuration, you would get something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The status extends the always present information that the submodule changed
    (`plugins/demo` got three new commits, and showing the summary for the last one
    (`>`) preceding the summary line means that the commit was added, that is, present
    in the working area but not (yet) in the superproject commit.
  prefs: []
  type: TYPE_NORMAL
- en: Trivia
  prefs: []
  type: TYPE_NORMAL
- en: Actually, this added part is just the **git submodule** **summary** output.
  prefs: []
  type: TYPE_NORMAL
- en: For the submodule in question, a series of commits in the submodule between
    the submodule version in the given superproject’s commit and the submodule version
    in the index or the working tree (the former shown by using `--cached`) are listed.
    There is also `git submodule status` for short information about each module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `git diff` command’s default output also doesn’t tell much about the change
    in the submodule, just that it is different:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Fortunately, there is the `--submodule=log` command-line option (which you
    can enable by default with the `diff.submodule` configuration setting) that lets
    us see something more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Instead of using `log`, we can use the `short` format that shows just the names
    of the commits, which is the default if the format is not given (that is, with
    just `git diff --submodule`). Alternatively, we can use the `diff` format to show
    an inline `diff` of the changed contents of the submodule.
  prefs: []
  type: TYPE_NORMAL
- en: Getting updates from the upstream of the submodule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To remind you, the submodule commits are referenced in gitlinks using the SHA1
    identifier, which always resolves to the same revision; it is not a volatile (inconstant)
    reference such as a branch name. Because of this, a submodule in a superproject
    does not automatically upgrade (which could possibly be breaking the application).
    However, sometimes, you may want to update the subproject to its upstream.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s assume that the subproject repository got new revisions published and,
    for our superproject, we want to update to the new version of a submodule.
  prefs: []
  type: TYPE_NORMAL
- en: To achieve this, we need to update the local repository of a submodule, move
    the version we want to the working directory of the superproject, and, finally,
    commit the submodule change in the superproject.
  prefs: []
  type: TYPE_NORMAL
- en: We can do this manually, starting by first changing the current directory to
    be inside the working directory of the submodule. Then, inside the submodule,
    we perform `git fetch` to get the data to the local clone of the repository (in
    `.git/modules/` in the superproject). After verifying what we have with `git log`,
    we can then update the working directory. If there are no local changes, you can
    simply check out the desired revision. Finally, you need to create a commit in
    a superproject.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the finer-grained control, this approach has the added benefit
    of working regardless of your current state (whether you are on an active branch
    or on a detached `HEAD`).
  prefs: []
  type: TYPE_NORMAL
- en: Another way to go about this would be, working from the container repository,
    to explicitly upgrade the submodule to its tracked remote branch with `git submodule
    update --remote`. Similarly to the ordinary update command, you can choose to
    merge or rebase instead of checking out a branch; you can configure the default
    way of updating with the `submodule.<name>.update` configuration variable, and
    the default upstream branch with `submodule.<name>.branch`.
  prefs: []
  type: TYPE_NORMAL
- en: Variants of git submodule update
  prefs: []
  type: TYPE_NORMAL
- en: In short, **submodule update --remote --merge** will merge the upstream’s subproject
    changes into the submodule, while **submodule update --merge** will merge the
    superproject gitlink changes into the submodule.
  prefs: []
  type: TYPE_NORMAL
- en: The `git submodule update --remote` command would fetch new changes from the
    submodule remote site automatically unless told not to with `--no-fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending submodule changes upstream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the major dangers in making changes live directly in a submodule (and
    not via its standalone repository) is forgetting to push the submodule. A good
    practice for submodules is to commit changes to the submodule first, push the
    module changes, and only then get back to the container project, commit it, and
    push the container changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only push to the supermodule repository, forgetting about the submodule
    push, then other developers will get an error while trying to get the updates.
    Though Git does not complain while fetching the superproject, you would see the
    problem in the `git submodule summary` output (and in the `git status` output,
    if properly configured) and while trying to update the working area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: You can plainly see how important it is to remember to push the submodule. You
    can ask Git to automatically push the submodules while pushing the superproject,
    if it is necessary, with `git push --recurse-submodules=on-demand` (the other
    option is just to check). You can also use the `push.` `recurseSubmodules` configuration
    option.
  prefs: []
  type: TYPE_NORMAL
- en: Transforming a subfolder into a subtree or submodule
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first issue that comes to mind while thinking of the use cases of subprojects
    in Git is about having the source code of the base project ready for such division.
  prefs: []
  type: TYPE_NORMAL
- en: Submodules and subtrees are always expressed as subdirectories of the superproject
    (the master project). You can’t mix files from different subsystems in one directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Experience shows that most systems use such a directory hierarchy, even in
    monolithic repositories, which is a good beginning for modularization efforts.
    Therefore, transforming a subfolder into a real submodule/subtree is fairly easy
    and can be done in the following sequence of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the subdirectory in question outside the working area of a superproject
    to have it beside the top directory of the superproject. If it is important to
    keep the history of a subproject, consider using **git subtree split**, or **git
    filter-branch --subdirectory-filter** or its equivalent, perhaps together with
    tools such as **reposurgeon** to clean up the history. See [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*, for more details.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the directory with the subproject repository to better express the essence
    of the extracted component. For example, a subdirectory originally named **refresh**
    could be renamed **refresh-client-app-plugin**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the public repository (upstream) for the subproject as a first-class
    project (for example, create a new project on GitHub to keep extracted code, either
    under the same organization as a superproject, or under a specialized organization
    for application plugins).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a self-sufficient and standalone plugin as a Git repository with
    **git init**. If, in *step 1*, you have extracted the history of the subdirectory
    into some branch, then push this branch into the just-created repository. Set
    up the public repository created in *step 3* as a default remote repository and
    push the initial commit (or the whole history) to the just-created URL to store
    the subproject code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the superproject, read the subproject you have just extracted but, this time,
    as a proper submodule or subtree, whichever solution is a better fit and whichever
    method you prefer to use. Use the URL of the just-created public repository for
    the subproject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Commit the changes in the superproject and push them to its public repository,
    in the case of submodules, including the newly created (or the just modified)
    **.****gitmodules** file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The recommended practice for the transformation of a subdirectory into a standalone
    submodule is to use a read-only URL for cloning (adding back) a submodule. This
    means that you can use either the `git://` protocol (warning: in this case, the
    server is unauthenticated) or `https://` without a username. The goal of this
    recommendation is to enforce separation by moving the work on a submodule code
    to a standalone separate subproject repository. In order to ensure that the submodule
    commits are available to all other developers, every change should go through
    the public repository for a subproject.'
  prefs: []
  type: TYPE_NORMAL
- en: If this recommendation (best practice) is met with a categorical refusal, in
    practice, you could work on the subproject source code directly inside the superproject,
    though it is more error-prone. You would need to remember to commit and push in
    the submodule first, doing it from inside of the nested submodule subdirectory;
    otherwise, other developers would be not able to get the changes. This combined
    approach might be simpler to use, but it loses the true separation between implementing
    and consuming changes, which should be better assumed while using submodules.
  prefs: []
  type: TYPE_NORMAL
- en: Subtrees versus submodules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In general, subtrees are easier to use and less tricky. Many people go with
    submodules, because of the better built-in tooling (they have their own Git command,
    namely, `git submodule`), detailed documentation, and similarity to the Subversion
    externals, making them feel falsely familiar. Adding a submodule is very simple
    (just run `git submodule add`), especially compared to adding a subtree without
    the help of third-party tools such as `git subtree` or `git subrepo`.
  prefs: []
  type: TYPE_NORMAL
- en: The major difference between subtrees and submodules is that, with subtrees,
    there’s only one repository, which means just one life cycle. Submodules and similar
    solutions use nested repositories, each with its own lifeline.
  prefs: []
  type: TYPE_NORMAL
- en: Though submodules are easy to set up and fairly flexible, they are also fraught
    with peril, and you need to practice vigilance while working with them. The fact
    that the submodules are opt-in also means that the changes touching the submodules
    demand a manual update by every collaborator. Subtrees are always there, so getting
    the superproject’s changes means getting the subproject’s too.
  prefs: []
  type: TYPE_NORMAL
- en: Commands such as `status`, `diff`, and `log` display precious little information
    about submodules, unless properly configured to cross the repository boundary;
    it is easy to miss a change. With subtrees, `status` works normally, while `diff`
    and `log` need some care because the subproject commits have a different root
    directory. The latter assumes that you did not decide to not include the subproject
    history (by squashing subtree merges). Then, the problem is only with the remote-tracking
    branches in the subproject’s repository, if any.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because the life cycles of different repositories are separate, updating a
    submodule inside its containing project requires two commits and two pushes. Updating
    a subtree-merged subproject is very simple: only one commit and one push. On the
    other hand, publishing the subproject changes upstream is much easier with submodules,
    while it requires changeset extraction with subtrees (here, tools such as `git
    subtree` help a lot).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next major issue, and a source of problems, is that the submodule has two
    sources of the current revision: the gitlink in the superproject and the branches
    in the submodule’s clone of the repository. This means that `git remote update`
    works a bit like a sideways push into a non-bare repository (see [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced Branching Techniques*). Submodule heads are, therefore, generally detached,
    so any local update requires various preparatory actions to avoid creating a lost
    commit. There is no such issue with subtrees. All the revision changing commands
    work as usual with subtrees, bringing the subproject directory to the correct
    version without the requirement of any additional action. Getting changes from
    the subproject repository is just a subtree merge away. The only difference between
    ordinary pull is the `-s` `subtree` option.'
  prefs: []
  type: TYPE_NORMAL
- en: Still, sometimes, submodules are the right choice. Compared to subtrees, they
    allow for a subproject (a module) to be not fetched, which is helpful when your
    code base is massive. Submodules are also useful when the heavy modularization
    is not natively handled, or not well natively handled, by the development stack’s
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Submodules might also themselves be superprojects for other submodules, creating
    a hierarchy of subprojects. Using nested submodules is made easier thanks to the
    `git submodule status`, `update`, `foreach`, and `sync` subcommands all supporting
    the `--``recursive` switch.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for subtrees
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With subtrees, there is only one repository (no nested repositories), just like
    a regular code base. This means that there is just one life cycle. One of the
    key benefits of subtrees is being able to mix container-specific customizations
    with general-purpose fixes and enhancements.
  prefs: []
  type: TYPE_NORMAL
- en: Projects can be organized and grouped together in whatever way you find to be
    most logically consistent. Using a single repository also reduces the overhead
    of managing dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: The basic example of using subtrees is managing the customized version of a
    library, a *required dependency*. It is easy to get a development environment
    set up to run builds and tests. Monorepo makes it also viable to have one universal
    version number for all the projects. Atomic cross-submodule commits are possible;
    therefore, a repository can always be in a consistent state.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use subtrees for *embedding related projects*, such as a GUI or
    a web interface, inside a superproject. In fact, many use cases for submodules
    can also apply to the subtrees solution, with the exception of the cases where
    there is a need for a subproject to be optional, or to have different access permissions
    than a master project. In those cases, you need to use submodules.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for monorepo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If all subprojects are managed by a single organization or a company, then it
    might be advantageous to have all those inter-related projects in a single repository,
    which we call monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: One of the advantages is simplified organization. You can group and organize
    projects in whatever way you find to be most logically consistent. You don’t need
    to consider how to split them into separate repositories, and how to join them
    into a superproject. It is also easier to navigate and search the history and
    the contents if all is in the single repository.
  prefs: []
  type: TYPE_NORMAL
- en: Because atomic cross-project commits are possible with monorepo, the repository
    can be always in a consistent state. It is easier to ensure that everything uses
    the same version of a specific component. Making cross-repository/cross-project
    changes in a polyrepo setting (multiple repositories, one per project, managed
    with a subtree or submodule strategy) is much more difficult than in a monorepo.
  prefs: []
  type: TYPE_NORMAL
- en: It is also easier to keep consistent tooling and a common **continuous integration**
    (**CI**) infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases for submodules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The strongest argument for the use of submodules is the issue of modularization.
    Here, the main area of use for submodules is handling plugins and extensions.
    Some programming ecosystems, such as ANSI C and C++ and also Objectve-C, lack
    good and standard support for managing version-locked multimodule projects. In
    this case, a plugin-like code can be included in the application (superproject)
    using submodules, without sacrificing the ability to easily update to the latest
    version of a plugin from its repository. The traditional solution of putting instructions
    about how to copy plugins in the README disconnects it from the historical metadata.
  prefs: []
  type: TYPE_NORMAL
- en: This schema can be extended also to the non-compiled code, such as the Emacs
    Lisp settings, configuration in dotfiles, (including frameworks such as `oh-my-zsh`),
    and themes (also for web applications). In these situations, what is usually needed
    to use a component is the physical presence of a module code at conventional locations
    inside the master project tree, which is mandated by the technology or framework
    being used. For instance, themes and plugins for WordPress, Magento, and so on
    are often de facto installed this way. In many cases, you need to be in a superproject
    to test these optional components.
  prefs: []
  type: TYPE_NORMAL
- en: Yet another particular use case for submodules is the division based on *access
    control and visibility restriction* of a complex application. For example, the
    project might use a cryptographic code with license restrictions, limiting access
    to it to a small subset of developers. With this code in a submodule with restricted
    access to its repository, other developers would simply be unable to clone this
    submodule. In this solution, the common build system needs to be able to skip
    cryptographic components if it is not available. On the other hand, the dedicated
    build server can be configured in such a way that the client gets the application
    built with crypto enabled.
  prefs: []
  type: TYPE_NORMAL
- en: A similar visibility restriction purpose, but in reverse, is making the source
    code of examples available long before it was to be published. This allows for
    better code thanks to the social input. The main repository for a book itself
    can be closed (private), but having an `examples/` directory contain a submodule
    intended for a sample source code allows you to make this subrepository public.
    While generating the book in the PDF and EPUB (and perhaps also MOBI) formats,
    the build process can then embed these examples (or fragments of them), as if
    they were ordinary subdirectories.
  prefs: []
  type: TYPE_NORMAL
- en: Third-party subproject management solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you don’t find a good fit in either `git subtree` or `git submodule`, you
    can try to use one of the many third-party projects to manage dependencies, subprojects,
    or collections of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: One such tool is `repo` ([https://android.googlesource.com/tools/repo/](https://android.googlesource.com/tools/repo/))
    used by the Android open source project to unify the many Git repositories for
    cross-network operations.
  prefs: []
  type: TYPE_NORMAL
- en: Another tool is `gil` (gitlinks) ([https://github.com/chronoxor/gil](https://github.com/chronoxor/gil))
    to manage complex recursive repositories dependencies, with cross references and
    cycles. Compared to submodules, `gil` avoids including the same dependency multiple
    times if the superproject and its subproject use the same library as a dependency.
    This tool also makes it easier to contribute changes upstream than with `git subtree`.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to split a single monolithic repository into many standalone repositories,
    besides `git subtree split`, you can use a third-party `splitsh-lite` tool. If,
    on the other hand, you have multiple separate repositories that you want to merge
    into a single monorepo, you can use the `tomono` tool.
  prefs: []
  type: TYPE_NORMAL
- en: You can find many other such tools.
  prefs: []
  type: TYPE_NORMAL
- en: Important consideration
  prefs: []
  type: TYPE_NORMAL
- en: When choosing between native support and one of the many tools to manage many
    repositories together, you should check whether the tool in question uses a subtree-like
    or submodule-like approach to find whether it would be a good fit for your project.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter provided all the tools you need to manage multicomponent projects
    with Git, from libraries and graphical interfaces, through plugins and themes,
    to frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: You learned about the concept behind the subtrees technique and how to use it
    to manage subprojects. You know how to create, update, examine, and manage subprojects
    using subtrees.
  prefs: []
  type: TYPE_NORMAL
- en: You got to know the submodule approach of nested repositories for optional dependencies.
    You learned the ideas behind gitlinks, `.gitmodules`, and `.git` files. You encountered
    the pitfalls and traps for the unwary that you need to be vigilant about while
    using submodules. You know the reason for these problems and understand the notions
    behind them. You know how to create, update, examine, and manage subprojects using
    submodules.
  prefs: []
  type: TYPE_NORMAL
- en: You learned when to use subtrees and submodules, and their advantages and disadvantages.
    You know a few use cases for each technique.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how to use Git effectively in a variety of circumstances and
    have learned the high-level ideas behind Git behavior that help you understand
    it, it’s time to tackle how to make Git easier to use in [*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320),
    *Customizing and* *Extending Git*.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What are subtrees, and what are their advantages and disadvantages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are submodules, and what are their advantages and disadvantages?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why is the information about submodules duplicated between **.gitmodules** and
    project configuration?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to the questions given above:'
  prefs: []
  type: TYPE_NORMAL
- en: With subtree merging, the history of the subproject (or its summary) is included
    in the superproject repository, and subproject files are put directly in a subirectory
    of the superproject and are superproject files. Subtrees can be used only for
    required dependencies, as they are embedded in a superproject. They are simpler
    to understand and use.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With submodules, repositories and the histories of superproject and subproject
    are kept separate. A superproject includes a link to the commit in a subproject.
    Submodules can be initialized and active, but can also be kept inactive, thus
    they can be used for optional dependencies. To include a change, you need to make
    a change in a subproject and to include it in a commit in a superproject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The information in the project configuration file about submodules is local
    to the repository and, among others, defines which submodules are active and which
    are not.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*git-submodule* – Initialize, update, or inspect submodules: [https://git-scm.com/docs/git-submodule](https://git-scm.com/docs/git-submodule)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*git-subtree* – Merge subtrees together and split the repository into subtrees:
    [https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt](https://github.com/git/git/blob/master/contrib/subtree/git-subtree.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Git documentation HOWTO – *How to use the subtree merge* *strategy*: [https://github.com/git/git/blob/master/Documentation/howto/using-merge-subtree.txt](https://github.com/git/git/blob/master/Documentation/howto/using-merge-subtree.txt)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scott Chacon, Ben Straub: *Pro Git*, 2nd Edition (2014) [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chapter *7.11 Git Tools -* *Submodules*
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Eric Pidoux, *Git Best Practices Guide* (2014), Packt Publishing Ltd
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 4*, *Going Deeper into Git, Managing* *Git Submodules*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Johan Abildskov, *Practical Git: Confident Git Through Practice* (2020), Apress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 8*, *Additional Git Features –* *Git Submodules*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Everything you need to know about monorepos and the tools to build them: [https://monorepo.tools/](https://monorepo.tools/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
