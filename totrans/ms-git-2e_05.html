<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-81"><a id="_idTextAnchor083" class="pcalibre1 pcalibre calibre6"/>4</h1>
<h1 id="_idParaDest-82" class="calibre5"><a id="_idTextAnchor084" class="pcalibre1 pcalibre calibre6"/>Exploring Project History</h1>
<p class="calibre3">One of the important <a id="_idIndexMarker272" class="pcalibre1 pcalibre calibre6"/>parts of mastering a <strong class="bold">version control system</strong> (<strong class="bold">VCS</strong>) is exploring project history and making use of the fact that with the VCS, we have an archive of every version that has ever existed. For example, you might want to examine what other developers did or remind yourself what you are about to publish.</p>
<p class="calibre3">In this chapter, you will learn how to select and view a revision or a range of revisions, as well as how to refer to them. The following chapter will continue this topic and explain how to find revisions using different criteria, as well as how to search through selected revisions; it will also describe how to search through project content.</p>
<p class="calibre3">This chapter will also introduce the concept of <strong class="bold">Directed Acyclic Graph</strong> (<strong class="bold">DAG</strong>) of revisions and explain how this concept relates to the idea of the project history, as well as the ideas of branches, tags, and the current branch in Git.</p>
<p class="calibre3">Here is the list of topics we will cover in this chapter:</p>
<ul class="calibre16">
<li class="calibre15">DAG of revisions as a way of representing history</li>
<li class="calibre15">Different ways of revision selection</li>
<li class="calibre15">Selecting starting branches and tags</li>
<li class="calibre15">Using data from reflog to select revisions</li>
<li class="calibre15">Double-dot (A..B) and triple-dot notation (A…B) for revision range selection</li>
<li class="calibre15">Advanced revision range selection</li>
</ul>
<p class="calibre3">The purpose of this chapter is to teach you how to select relevant parts of project history. The next chapter will explain how to investigate this further by searching through what you’ve selected.</p>
<h1 id="_idParaDest-83" class="calibre5"><a id="_idTextAnchor085" class="pcalibre1 pcalibre calibre6"/>DAGs</h1>
<p class="calibre3">What makes VCSs different from backup applications is <em class="italic">the ability to represent more than linear history</em>. This is necessary both to support the simultaneous parallel development by different <a id="_idIndexMarker273" class="pcalibre1 pcalibre calibre6"/>developers (each developer in their own clone of the repository) and to allow independent parallel lines of development – branches. For example, with a VCS, you might want to keep the ongoing development and the work on bug fixes for the stable version isolated. You can do this by using individual branches for those separate lines of development. So, the VCS needs to be able to model such a non-linear way of development and needs to have some structure to represent it.</p>
<p class="calibre3">The structure that Git uses (on the abstract level) to represent the possibly non-linear history of a project is called a <strong class="bold">Directed Acyclic </strong><strong class="bold">Graph (DAG)</strong>.</p>
<p class="calibre3">The following diagram (<em class="italic">Figure 4</em><em class="italic">.1</em>) shows an example of a DAG, drawn in two different ways. The same graph is represented on both sides of the figure: using the free-form layout on the left and the left-to-right layout on the right.</p>
<div><div><img alt="Figure 4.1 – Generic example of a DAG, with the same graph drawn with different layouts" src="img/B21194_04_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Generic example of a DAG, with the same graph drawn with different layouts</p>
<p class="calibre3">A <strong class="bold">directed graph</strong> is a data<a id="_idIndexMarker274" class="pcalibre1 pcalibre calibre6"/> structure from computer science and mathematics that’s composed of <em class="italic">nodes</em> (vertices) connected with <em class="italic">directed edges</em> (arrows). A directed graph is <em class="italic">acyclic</em> if it doesn’t contain any cycles, which means that there is no way to start at <a id="_idIndexMarker275" class="pcalibre1 pcalibre calibre6"/>some node and follow a sequence of directed edges to end up at the starting node again.</p>
<p class="calibre3">Understanding this topic, in my opinion, helps with mastering the art of exploring, searching, and shaping the <a id="_idIndexMarker276" class="pcalibre1 pcalibre calibre6"/>project history. You might want to read it more times to internalize this knowledge. It is not, however, required to be able to use Git successfully, so this section can be skipped on the first pass.</p>
<p class="calibre3">In a specific realization of a graph, each node represents some object (or a piece of data), and each edge from one node to another represents some kind of relationship between the objects it connects (or <a id="_idIndexMarker277" class="pcalibre1 pcalibre calibre6"/>between data represented by nodes).</p>
<p class="calibre3">The DAG of revisions in <strong class="bold">distributed version control systems</strong> (<strong class="bold">DVCSs</strong>) uses the following representation:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Nodes</strong>: In DVCSs, each <a id="_idIndexMarker278" class="pcalibre1 pcalibre calibre6"/>node represents one <strong class="bold">revision</strong> (one version) of a project (of the entire tree). Those objects are called <strong class="bold">commits</strong>.</li>
<li class="calibre15"><strong class="bold">Directed edges</strong>: In DVCSs, each edge represents the <em class="italic">this revision is based on that revision</em> relationship<a id="_idIndexMarker279" class="pcalibre1 pcalibre calibre6"/> between two revisions. The arrow goes from a later <strong class="bold">child</strong> revision to an earlier <strong class="bold">parent</strong> revision it was based on – that is, the revision it was created from. This is <em class="italic">the reverse</em> of the way most people like to think of <em class="italic">the arrow of time</em> – that is, the arrow pointing from an earlier commit to a later one.</li>
</ul>
<p class="calibre3">Because directed edges represent the <em class="italic">is based on</em> causal relationship between revisions, the arrows in the DAG of revisions cannot form a cycle. Usually, the DAG of revisions is laid out left-to-right (root nodes on the left, leaves on the right) or bottom-to-top (most recent revisions on the top). The figures in this book and ASCII-art examples in the Git documentation use the left-to-right convention, while the Git command line uses bottom-to-top, which is the most recent first convention.</p>
<p class="calibre3">There are two special types of nodes in any DAG (see <em class="italic">Figure 4</em><em class="italic">.1</em>):</p>
<ul class="calibre16">
<li class="calibre15"><strong class="bold">Root nodes</strong> (or <strong class="bold">roots</strong>): These are nodes (revisions) that have no parents (have no outgoing edges). There is at <a id="_idIndexMarker280" class="pcalibre1 pcalibre calibre6"/>least one root node in the DAG of revisions, which represents the initial (starting) version of a project.</li>
<li class="calibre15"><strong class="bold">Leaf nodes</strong> (or <strong class="bold">leaves</strong>): These are <a id="_idIndexMarker281" class="pcalibre1 pcalibre calibre6"/>nodes that have no children (no incoming edges); there is at least one <a id="_idIndexMarker282" class="pcalibre1 pcalibre calibre6"/>such node. They represent the most recent versions of the project, not having any work based on them. Usually, each leaf in the DAG of revisions has a branch head pointing to it.</li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">There can be more than one root node in Git’s DAG of revisions. Additional root nodes can be created when you’re joining two formerly originally independent projects together; each joined project brings its own root node. As this is a very rare occasion, with modern Git, you need to pass the <strong class="source-inline1">--allow-unrelated-histories</strong> option to the <strong class="source-inline1">git merge</strong> or <strong class="source-inline1">git pull</strong> command to do so, to help avoid mistakes.</p>
<p class="callout">Another source of root nodes is <strong class="bold">orphan branches</strong> – that is, disconnected branches with no history in common. They <a id="_idIndexMarker283" class="pcalibre1 pcalibre calibre6"/>are, for example, used by GitHub to manage a project’s web pages together in one repository with the code (in the <strong class="source-inline1">gh-pages</strong> branch), and by the Git project itself to store pre-generated documentation (the <strong class="source-inline1">man</strong> and <strong class="source-inline1">html</strong> branches) and related projects (the <strong class="source-inline1">todo</strong> branch). To create such a branch, you need to use the <strong class="source-inline1">--orphan</strong> option in <strong class="source-inline1">git checkout</strong> or <strong class="source-inline1">git switch</strong>.</p>
<p class="calibre3">The fact that the DAG can have more than one leaf node means that there is no inherent notion of the latest version, as it was in the linear history<a id="_idTextAnchor086" class="pcalibre1 pcalibre calibre6"/> paradigm.</p>
<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor087" class="pcalibre1 pcalibre calibre6"/>Whole-tree commits</h2>
<p class="calibre3">In DVCSs, each node of the DAG of revisions (DVCS’s model of history) represents a version of the project as <a id="_idIndexMarker284" class="pcalibre1 pcalibre calibre6"/>a whole single entity: a <strong class="bold">snapshot</strong> of the <a id="_idIndexMarker285" class="pcalibre1 pcalibre calibre6"/>whole directory tree contents of a project.</p>
<p class="calibre3">This means that by default, each developer will get the history of all the files in their clone of the repository. Where needed, they can choose to get only a part of the history (shallow clone and/or cloning only selected branches), they can checkout only selected files (sparse checkout), or they can use the partial clone feature (with, for example, different versions of files contents loaded on demand). Those special cases, and more, will be described in <a href="B21194_12.xhtml#_idTextAnchor302" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing </em><em class="italic">Large Repositories</em>.</p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor088" class="pcalibre1 pcalibre calibre6"/>Branches and tags</h2>
<p class="calibre3">A <code>maintenance</code>, to help in managing bug fixes to the released stable version of a project, while isolating this activity from the rest of the development.</p>
<p class="calibre3">A <code>v1.3-rc3</code> tag, among others, to be able to go back to this specific version, check the validity of bug reports from your testers, and find the sources of reported bugs.</p>
<p class="calibre3">Both branches and tags, sometimes <a id="_idIndexMarker290" class="pcalibre1 pcalibre calibre6"/>called <strong class="bold">references</strong> (<strong class="bold">refs</strong>) when used together, have the same meaning and almost the same representation within the DAG of revisions. They are external references (pointers) to the graph of revisions, as shown <a id="_idTextAnchor089" class="pcalibre1 pcalibre calibre6"/>in <em class="italic">Figure 4</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 4.2 – Example DAG of revisions in a VCS with two branches, a single tag, one fork point, and a single merge commit" src="img/B21194_04_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Example DAG of revisions in a VCS with two branches, a single tag, one fork point, and a single merge commit</p>
<p class="calibre3">A <code>v1.3-rc3</code> in <em class="italic">Figure 4</em><em class="italic">.2</em>. It always points to the same object; it doesn’t change. The idea behind having tags is to be able to refer to the given<a id="_idIndexMarker292" class="pcalibre1 pcalibre calibre6"/> revision with a symbolic name and to have<a id="_idIndexMarker293" class="pcalibre1 pcalibre calibre6"/> this symbolic name mean the same for every developer. Checking out or viewing the given tag should provide the same results for everyone.</p>
<p class="calibre3">A <code>maint</code> and <code>master</code>.)</p>
<p class="calibre3">The branch in the DAG is, as a line of development, the subgraph of the DAG composed of those revisions that can be <strong class="bold">reached</strong> from the tip of the branch (from the branch head) – in other words, of those revisions that you can walk to by following the parent edges starting from the branch head.</p>
<p class="calibre3">Git needs to know which branch tip to advance when creating a new commit. It needs to know which branch is the current one and is <code>HEAD</code> points directly to a node in the DAG.</p>
<h3 class="calibre9">Full names of references (branches and tags)</h3>
<p class="calibre3">Originally, Git stored branches and tags in files inside the <code>.git</code> administrative area, in the <code>.git/refs/heads/</code> and <code>.git/refs/tags/</code> directories, respectively. Modern Git can store information about tags <a id="_idIndexMarker296" class="pcalibre1 pcalibre calibre6"/>and branches inside the <code>.git/packed-refs</code> file to avoid handling a very large number of small files. Nevertheless, active references use the original <em class="italic">loose</em> format – one file per reference.</p>
<p class="calibre3">The <code>HEAD</code> pointer (denoting the current branch) is stored in <code>.git/HEAD</code>. It is usually a symbolic reference – for example, <strong class="bold">ref: refs/heads/master</strong>.</p>
<p class="calibre3">The <code>master</code> branch is stored in <code>.git/refs/heads/master</code> and has <code>refs/heads/master</code> as its full name (in other words, branches reside in the <code>refs/heads/</code> namespace). The tip of the branch is referred to as the <strong class="bold">head</strong> of a branch, hence the name of this namespace. In <em class="italic">loose</em> format, the file contents are an SHA-1 identifier of the most current<a id="_idIndexMarker297" class="pcalibre1 pcalibre calibre6"/> revision on the branch (the <strong class="bold">branch tip</strong>), in plain text as hexadecimal digits. It is sometimes required to use the full name if there is ambiguity among refs.</p>
<p class="calibre3">The remote-tracking branch, <code>origin/master</code>, which remembers the last seen position of the <code>master</code> branch in the remote repository, <code>origin</code>, is stored in <code>.git/refs/remotes/origin/master</code> and has <code>refs/remotes/origin/master</code> as its full name. The concept of <strong class="bold">remotes</strong> will be explained in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>, while <strong class="bold">remote-tracking branches</strong> will be covered in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced </em><em class="italic">Branching Techniques</em>.</p>
<p class="calibre3">The <code>v1.3-rc3</code> tag has <code>refs/tags/v1.3-rc3</code> as its full name (tags reside in the <code>refs/tags/</code> namespace). To be more precise, in the case of <strong class="bold">annotated</strong> and <strong class="bold">signed tags</strong>, this file stores a reference to the <strong class="bold">tag object</strong>, which, in turn, points to the node in the DAG, and not directly to a commit. This is the only type of ref that can point to any type of object; branches and remote-tracking branches always point to a commit.</p>
<p class="calibre3">These full names (fully qualified names) can be seen <a id="_idIndexMarker298" class="pcalibre1 pcalibre calibre6"/>when using <a id="_idIndexMarker299" class="pcalibre1 pcalibre calibre6"/>commands intended for scripts (so-called <code>git show-ref</code>:</p>
<pre class="console">
$ git show-ref
98cbfdf5c1be9a4f6c0f7e3b97608b39274463df refs/heads/master
d81ce7b6aeedb51aa2d5e18d110333aea080fdd4 refs/stash</pre>
<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor090" class="pcalibre1 pcalibre calibre6"/>Branch points</h2>
<p class="calibre3">When you create a new branch <a id="_idIndexMarker300" class="pcalibre1 pcalibre calibre6"/>starting at a given version, the lines of development usually diverge. The act of creating a divergent branch is denoted in the DAG by a commit that has more than one child – that is, a node pointed to by more than one arrow.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Git does not track information about creating (forking) a branch and does not mark branch points in any way that they’re preserved across clones and pushes. There is information about this event in the <strong class="bold">reflog</strong> (<strong class="bold">branch: Created from HEAD</strong>), but this is local to the repository where branching occurred and is temporary. However, if you know that the <strong class="source-inline1">B</strong> branch started from the <strong class="source-inline1">A</strong> branch, you can find the branching point with <strong class="source-inline1">git merge-base A B</strong>. In modern Git, you can use the <strong class="source-inline1">--fork-point</strong> option to make this command use the information from the reflog, when available.</p>
<p class="calibre3">In <em class="italic">Figure 4</em><em class="italic">.2</em>, the <code>34ac2</code> commit is a <a id="_idIndexMarker301" class="pcalibre1 pcalibre calibre6"/>branching point, or a <code>master</code> and <code>maint</code> branches.</p>
<h2 id="_idParaDest-87" class="calibre7"><a id="_idTextAnchor091" class="pcalibre1 pcalibre calibre6"/>Merge commits</h2>
<p class="calibre3">Typically, when you’ve used branches <a id="_idIndexMarker302" class="pcalibre1 pcalibre calibre6"/>to enable independent parallel development, you will want to join them later. For example, you would want bug fixes that have been applied to the stable (maintenance) branch so that they’re included in the main line of development as well (if they’re applicable and weren’t fixed accidentally during the main line development).</p>
<p class="calibre3">You would also want to merge changes created in parallel by different developers working simultaneously on the same project, each using their own clone of the repository, and creating their own lines of commits.</p>
<p class="calibre3">Such a <strong class="bold">merge operation</strong> will create a <a id="_idIndexMarker303" class="pcalibre1 pcalibre calibre6"/>new revision, joining two lines of development. The result of this operation will be based on more than one commit. The node in the DAG representing said revision will have more than one parent and more than one outgoing edge. Such an object is called a <strong class="bold">merge commit</strong>.</p>
<p class="calibre3">You can see a merge commit, <code>3fb00</code>, in <em class="italic">Figure 4</em><em class="italic">.2</em>.</p>
<h1 id="_idParaDest-88" class="calibre5"><a id="_idTextAnchor092" class="pcalibre1 pcalibre calibre6"/>Single revision selection</h1>
<p class="calibre3">During development, often, you’ll want to select a single revision in the history of the project so that you can examine it or<a id="_idIndexMarker304" class="pcalibre1 pcalibre calibre6"/> compare it with the current version. The ability to select a revision is also the basis for selecting a revision range – for example, selecting a subsection of history to examine.</p>
<p class="calibre3">Many Git commands take revision parameters as arguments, which are typically denoted by <code>&lt;rev&gt;</code> in the Git reference documentation. Git allows you to specify a commit or a range of commits in several ways. This will be described in this and the next section.</p>
<h2 id="_idParaDest-89" class="calibre7"><a id="_idTextAnchor093" class="pcalibre1 pcalibre calibre6"/>HEAD – the implicit revision</h2>
<p class="calibre3">Most, but not all, Git commands that require the revision parameter default to using <code>HEAD</code>. For example, <code>git log</code> and <code>git log HEAD</code> will show the same information. You can also use <code>@</code> alone as a shortcut for <code>HEAD</code>.</p>
<p class="calibre3">Here, <code>HEAD</code> denotes the <strong class="bold">current branch</strong>, or in other <a id="_idIndexMarker305" class="pcalibre1 pcalibre calibre6"/>words, the commit that was checked out into the working directory and forms a base of current work (a current revision).</p>
<p class="calibre3">There are a few other references that are similar to <code>HEAD</code>:</p>
<ul class="calibre16">
<li class="calibre15"><strong class="source-inline1">FETCH_HEAD</strong>: This records the information about the remote branches that were fetched from a remote repository with your last <strong class="source-inline1">git fetch</strong> or <strong class="source-inline1">git pull</strong> invocation. It is very useful for one-off fetching, with a repository to fetch from given by a URL (<strong class="source-inline1">git fetch &lt;URL&gt;</strong>), unlike when we’re fetching from a named repository such as <strong class="source-inline1">origin</strong>, where we can use a remote tracking branch instead, such as <strong class="source-inline1">origin/master</strong>. Moreover, with named repositories, we can use the reflog for the remote-tracking branch – for example, <strong class="source-inline1">origin/master@{1}</strong> – to get the position before the fetch. Note that <strong class="source-inline1">FETCH_HEAD</strong> is overwritten by each fetch from any repository.</li>
<li class="calibre15"><strong class="source-inline1">ORIG_HEAD</strong>: This records the previous position of the current branch. This reference is created by commands that move the current branch in a drastic way (creating a new commit doesn’t set <strong class="source-inline1">ORIG_HEAD</strong>) to record the position of <strong class="source-inline1">HEAD</strong> before the operation. This is very useful if you want to undo or abort such an operation. However, nowadays, the same can be done using reflogs, which store additional information that can be examined in their use; see the <em class="italic">Reflogging shortnames</em> section for more details.</li>
</ul>
<p class="calibre3">You can also stumble upon the short-lived temporary references that are used during specific operations:</p>
<ul class="calibre16">
<li class="calibre15">During a merge, before creating a merge commit, <strong class="source-inline1">MERGE_HEAD</strong> records the commit(s) that you’re merging into your branch. It vanishes after creating a merge commit</li>
<li class="calibre15">During a cherry-pick, before <a id="_idIndexMarker306" class="pcalibre1 pcalibre calibre6"/>creating a commit that copies picked changes into another branch, <strong class="source-inline1">CHERRY_PICK_HEAD</strong> records the commit that you’ve selected for cherry-picking</li>
</ul>
<h2 id="_idParaDest-90" class="calibre7"><a id="_idTextAnchor094" class="pcalibre1 pcalibre calibre6"/>Branch and tag references</h2>
<p class="calibre3">The most straightforward and commonly used way to specify a revision is to use symbolic names: branches, naming the line of development, pointing to the tip of said line; and tags, naming the <a id="_idIndexMarker307" class="pcalibre1 pcalibre calibre6"/>specific revision. This way of specifying revisions can be used to view the history of a line of development, examine the most current revision (current work) on a given branch, or compare a branch or a tag with the current work.</p>
<p class="calibre3">You can use any of the <em class="italic">refs</em> (external references to the DAG of revisions) to select a commit. You can use a branch name, a tag name, and a remote-tracking branch name in any Git command that requires a revision as a parameter.</p>
<p class="calibre3">Usually, it is enough to give the <em class="italic">short</em> name of a branch or tag, such as <code>git log master</code>, to view the history of a <code>master</code> branch, or <code>git log v1.3-rc3</code> to see how version <code>v1.3-rc1</code> came about. It can, however, happen that there are different types of refs with the same name, such as both the branch and tag being named <code>dev</code> (though it is recommended to avoid such situations. Alternatively, you could have created (usually by accident) the local <code>origin/master</code> branch when there was a remote-tracking branch with a short named <code>origin/master</code>, tracking where the <code>master</code> branch was in the remote repository named <code>origin</code>.</p>
<p class="calibre3">In such a situation, when the ref name is ambiguous, it is disambiguated by taking the first match in the following rules (this is a shortened and simplified version – for the full list, see the <strong class="bold">gitrevisions(7)</strong> manpage):</p>
<ol class="calibre14">
<li class="calibre15">The top-level symbolic name – for example, <strong class="source-inline1">HEAD</strong>.</li>
<li class="calibre15">Otherwise, the name of the tag (the <strong class="source-inline1">refs/tags/</strong> namespace).</li>
<li class="calibre15">Otherwise, the name of the local branch (the <strong class="source-inline1">refs/heads/</strong> namespace).</li>
<li class="calibre15">Otherwise, the name of the remote-tracking branch (the <strong class="source-inline1">refs/remotes/</strong> namespace).</li>
<li class="calibre15">Otherwise, the name<a id="_idIndexMarker308" class="pcalibre1 pcalibre calibre6"/> of the remote if a default branch exists for it; the revision is said to be the default branch (for example, <strong class="source-inline1">refs/remotes/origin/HEAD</strong> for <strong class="source-inline1">origin</strong> as a parameter).</li>
</ol>
<h2 id="_idParaDest-91" class="calibre7"><a id="_idTextAnchor095" class="pcalibre1 pcalibre calibre6"/>The --branches, --tags, and similar options</h2>
<p class="calibre3">If you want to see the whole graph of revisions, you need a way to specify all the refs – that is, branches, remote-tracking <a id="_idIndexMarker309" class="pcalibre1 pcalibre calibre6"/>branches, and tags. That’s what the <code>--all</code> option to the <code>git log</code> command is for. With this option, Git pretends as if all the<a id="_idIndexMarker310" class="pcalibre1 pcalibre calibre6"/> refs in the <code>refs/</code> namespace, along with <code>HEAD</code>, were listed as starting points for revision traversal (for viewing the history of a project).</p>
<p class="calibre3">If you want to limit yourself to branches, remote-tracking branches, or tags, you can use the <code>--branches</code>, <code>--remotes</code>, or <code>--tags</code> option, respectively. All of those options take an optional <code>&lt;pattern&gt;</code> parameter, which limits respective refs to ones matching the given shell glob. If the pattern lacks glob wildcards (that is, <code>*</code>, <code>?</code>, or <code>[</code>), then <code>/*</code> at the end of the pattern is implied. For example, to pretend as if all topic branches (with hierarchical names that begin with author initials) and all remote-tracking branches for the <code>origin</code> remote were listed on the command line, you can use the following command:</p>
<pre class="console">
$ git log --branches=??/* --remotes=origin</pre>
<p class="calibre3">The <code>--all</code> option with the <code>&lt;pattern&gt;</code> parameter is named <code>--glob=&lt;pattern&gt;</code>.</p>
<p class="callout-heading">Glob patterns</p>
<p class="callout">In computer science, <strong class="bold">glob patterns</strong> are used to <a id="_idIndexMarker311" class="pcalibre1 pcalibre calibre6"/>match strings using a specific set of wildcard characters. This is the syntax that’s used by UNIX shells and is described on the <strong class="bold">glob(7)</strong> manpage. It is simpler but less expressive than <strong class="bold">regular expressions</strong>.</p>
<p class="callout">The most common glob wildcards are <strong class="source-inline1">*</strong>, <strong class="source-inline1">?</strong>, and <strong class="source-inline1">[…]</strong>. The <strong class="source-inline1">*</strong> wildcard character matches any number of characters including none, <strong class="source-inline1">?</strong> matches a single character, and <strong class="source-inline1">[abc]</strong> matches one character from the one listed inside brackets. You can simplify the list of characters using the character range – for example, <strong class="source-inline1">[a-z]</strong>.</p>
<p class="calibre3">Pattern matching can <a id="_idIndexMarker312" class="pcalibre1 pcalibre calibre6"/>be enhanced with the help of the <code>--exclude=&lt;pattern&gt;</code> option, which affects <code>--all</code>, <code>--branches</code>, <code>--tags</code>, <code>--remotes</code>, and <code>--glob</code>, excluding refs that the next such option would otherwise consider. This option can be given <a id="_idIndexMarker313" class="pcalibre1 pcalibre calibre6"/>multiple times, accumulating exclusion patterns. For example, to include all topic branches but exclude your own topic branches (which have names starting with <code>jn/</code>), you can use the following command:</p>
<pre class="console">
$ git log --exclude=jn/* --branches=??/*</pre>
<h2 id="_idParaDest-92" class="calibre7"><a id="_idTextAnchor096" class="pcalibre1 pcalibre calibre6"/>SHA-1 and the shortened SHA-1 identifier</h2>
<p class="calibre3">In Git, each revision<a id="_idIndexMarker314" class="pcalibre1 pcalibre calibre6"/> is given a<a id="_idIndexMarker315" class="pcalibre1 pcalibre calibre6"/> unique identifier (object name), which is a <code>git </code><code>log</code> output:</p>
<pre class="console">
$ git log
commit 50f84e34a1b0bb893327043cb0c491e02ced9ff5
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Mon Jun 9 11:39:43 2014 -0700
    Update draft release notes to 2.1
    Signed-off-by: Junio C Hamano &lt;gitster@pobox.com&gt;
commit 07768e03b5a5efc9d768d6afc6246d2ec345cace
Merge: 251cb96 eb07774
Author: Junio C Hamano &lt;gitster@pobox.com&gt;
Date:   Mon Jun 9 11:30:12 2014 -0700
    Merge branch 'jc/shortlog-ref-exclude'</pre>
<p class="calibre3">It isn’t necessary to give the full 40 characters of the SHA-1 identifier. Git is smart enough to figure out what you<a id="_idIndexMarker317" class="pcalibre1 pcalibre calibre6"/> meant if you provide it with the first few characters of the SHA-1 revision<a id="_idIndexMarker318" class="pcalibre1 pcalibre calibre6"/> identifier, so long as the partial SHA-1 is at least 4 characters long. To be able to use a shortened SHA-1 to select revision, it must be long enough to be unambiguous – that is, there must <a id="_idIndexMarker319" class="pcalibre1 pcalibre calibre6"/>be one and only one commit object where the SHA-1 identifier begins with given characters.</p>
<p class="calibre3">For example, both <code>dae86e1950b1277e545cee180551750029cfe735</code> and <code>dae86e</code> name the same commit object, assuming, of course, that that there is no other object in your repository whose object name starts with <code>dae86e</code>. If there is any ambiguity, Git will tell us about all the choices, like so:</p>
<pre class="console">
error: short object ID dae86e is ambiguous
hint: The candidates are:
hint:   dae86e19 commit 2021-03-17 – README: Add CI badges
hint:   dae86e1f tree
hint:   dae86ebf blob
fatal: ambiguous argument 'dae86e': unknown revision or path not in the working tree.
Use '--' to separate paths from revisions, like this:
'git &lt;command&gt; [&lt;revision&gt;...] -- [&lt;file&gt;...]'</pre>
<p class="calibre3">In many places, Git shows unambiguously shortened SHA-1 identifiers in its command output. For example, in the preceding example of the <code>git log</code> output, we can see the shortened SHA-1 identifiers in<a id="_idIndexMarker320" class="pcalibre1 pcalibre calibre6"/> the <code>Merge:</code> line.</p>
<p class="calibre3">You can also request<a id="_idIndexMarker321" class="pcalibre1 pcalibre calibre6"/> that Git use the shortened SHA-1 in place of the full SHA-1 revision identifiers with the <code>--abbrev-commit</code> option. By default, Git will use at least 7 characters for the shortened SHA-1; you can change this with the optional parameter – for example, <code>--abbrev-commit=12</code>.</p>
<p class="calibre3">Note that Git will use as many characters as is required for the shortened SHA-1 to be unique at the time the command was issued. The parameter to <code>--abbrev-commit</code> (and the similar <code>--abbrev</code> option) is <a id="_idIndexMarker322" class="pcalibre1 pcalibre calibre6"/>the minimal length of the abbreviation.</p>
<p class="callout-heading">A short note about shortened SHA-1</p>
<p class="callout">Generally, 8 to 10 characters is more than<a id="_idIndexMarker323" class="pcalibre1 pcalibre calibre6"/> enough for the shortened SHA-1 (for the SHA-1 prefix)to be unique within a project. One of the largest Git projects, the Linux kernel, is beginning to need 12 characters out of the possible 40 to stay unique. While a hash collision, which means having two revisions (two objects) that have the same full SHA-1 identifier, is extremely unlikely (with <em class="italic">1/2^80 ≈ 1/1.2×10^24</em> probability), the formerly unique shortened SHA-1 identifier may stop being unique due to repository growth.</p>
<p class="calibre3">The SHA-1 and the shortened SHA-1 are often copied from the command output and pasted as revision <a id="_idIndexMarker324" class="pcalibre1 pcalibre calibre6"/>parameters in another command. They can also<a id="_idIndexMarker325" class="pcalibre1 pcalibre calibre6"/> be used to communicate between developers in case of doubt or ambiguity as SHA-1 identifiers are the same in any clone of the repository. <em class="italic">Figure 4</em><em class="italic">.2</em> uses a five-character shortened SHA-1 to identify revisions in the DAG.</p>
<h2 id="_idParaDest-93" class="calibre7"><a id="_idTextAnchor097" class="pcalibre1 pcalibre calibre6"/>Ancestry references</h2>
<p class="calibre3">The other main way to<a id="_idIndexMarker326" class="pcalibre1 pcalibre calibre6"/> specify a revision is via its <code>HEAD</code>, a branch head, or a tag), and then follow through parent relationships to the commit in question. There is a special suffix syntax to specify such ancestry paths.</p>
<p class="calibre3">If you place <code>^</code> at the end of a revision name, Git resolves it to mean a (first) parent of that revision. For example, <code>HEAD^</code> means the parent of <code>HEAD</code> – that is, the previous commit.</p>
<p class="calibre3">This is a shortcut syntax. For merge commits, which have more than one parent, you might want to follow any of the parents. To select a parent, put its number after the <code>^</code> character: using the <code>^&lt;n&gt;</code> suffix means the <em class="italic">n-th</em> parent of a revision. We can see that <code>^</code> is a short version of <code>^1</code>.</p>
<p class="calibre3">As a special case, <code>^0</code> means the commit itself; it is only important when a command behaves differently when you’re using the branch name as a parameter and when you’re using other revision specifiers. It can be also used to get the commit that an annotated (or a signed) tag points to; compare <code>git show v0.9</code> and <code>git show v0.9^0</code>. Note that you can do the latter operation with <code>&lt;tag&gt;^{commit}</code>; in most cases, it is what <code>&lt;tag&gt;^{}</code> would do (follow this until you find an object that isn’t a tag).</p>
<p class="calibre3">This suffix syntax is composable. You can use <code>HEAD^^</code> to mean the grandparent of <code>HEAD</code> and the parent of <code>HEAD^</code>. There is another shortcut syntax for specifying a chain of first parents. Instead of writing <em class="italic">n</em> times the <code>^</code> suffix – that is, <code>^^…^</code> or <code>^1^1…^1</code> – you can simply use <code>~&lt;n&gt;</code>. As a special case, <code>~</code> is equivalent to <code>~1</code>, so <code>HEAD~</code> and <code>HEAD^</code> are equivalent. In a similar vein, <code>HEAD~2</code> means the first parent of the first parent or the grandparent <a id="_idIndexMarker328" class="pcalibre1 pcalibre calibre6"/>and is equivalent to <code>HEAD^^</code>.</p>
<p class="calibre3">You can also combine everything. For example, you can get the second parent of a great-grandparent of <code>HEAD</code> (assuming it was a merge commit) by using <code>HEAD~3^2</code>, and so on. You can use <code>git name-rev</code> or <code>git describe --contains</code> to find out how a revision is related to local refs, like so:</p>
<pre class="console">
$ git log | git name-rev --stdin
commit 82006acd359717624fb33a7ae554cba6be717911 (master)
Merge: 20cfc7c 3a59408
Author: Bob Hacker &lt;bob@company.com&gt;
Date:   Sun May 30 00:58:23 2021 +0200
    Merge branch 'master' of https://git.company.com/random
commit 20cfc7c25ff82e36d6e72b6a31f5839331f270e7 (master~1)
Author: Bob Hacker &lt;bob@company.com&gt;
Date:   Sun May 30 00:44:59 2021 +0200
    Added COPYRIGHT
[…]</pre>
<p class="calibre3">As you can see, with <code>git name-rev --stdin</code> used as a filter for <code>git log</code>, after each SHA-1 identifier, you<a id="_idIndexMarker329" class="pcalibre1 pcalibre calibre6"/> get its ancestry reference in parentheses – for example, <strong class="bold">(master~1)</strong>.</p>
<h2 id="_idParaDest-94" class="calibre7"><a id="_idTextAnchor098" class="pcalibre1 pcalibre calibre6"/>Reverse ancestry references – git-describe output</h2>
<p class="calibre3">The ancestry reference<a id="_idIndexMarker330" class="pcalibre1 pcalibre calibre6"/> describes how a historic version relates to the current branches and tags. It depends on the position of the starting revision. For example, <code>HEAD^</code> would usually mean a completely different commit next month.</p>
<p class="calibre3">Sometimes, we want to describe how the current version relates to the prior named version. For example, we might want to have a human-readable name of the current version to store in the generated binary application. We want this name to refer to the same revision for everybody. This is the task of <code>git describe</code>.</p>
<p class="calibre3">Here, <code>git describe</code> finds the most recent tag that can be reached from a given revision (by default, from <code>HEAD</code>) and uses it to describe that version. If the found tag points to the given commit, then (by default) only the tag is shown. Otherwise, <code>git describe</code> suffixes the tag name with the number of additional commits on top of the tagged object and uses the abbreviated SHA-1 identifier of the given revision. For example, <code>v1.0.4-14-g2414721</code> means that the given commit was based on the named (tagged) version <code>v1.0.4</code>, which was 14 commits ago, and that it has <code>2414721</code> as a shortened SHA-1. Without the SHA-1 abbreviation, the notation would be ambiguous; in the presence <a id="_idIndexMarker331" class="pcalibre1 pcalibre calibre6"/>of non-linear history, there can be many revisions that are 14 commits away from the given tag.</p>
<p class="calibre3">Git understands this output format as a revision specifier.</p>
<h2 id="_idParaDest-95" class="calibre7"><a id="_idTextAnchor099" class="pcalibre1 pcalibre calibre6"/>Reflogging shortnames</h2>
<p class="calibre3">To help you recover from some types of mistakes, and to be able to undo changes (to go back to the state<a id="_idIndexMarker332" class="pcalibre1 pcalibre calibre6"/> before the change), Git keeps a <code>HEAD</code> and branch references have been for the last few months, and how they got there, as described in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>. The default is to keep reflog entries up to 90 days; 30 days for revisions that can only be reached through reflog (for example, amended commits). This can be configured on a ref-by-ref basis; see <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing </em><em class="italic">and </em><em class="italic">Extending Git</em>.</p>
<p class="calibre3">You can examine and manipulate your reflog with the <code>git reflog</code> command and its subcommands. You can also display history with <code>git log -g</code> (or <code>git </code><code>log --walk-reflog</code>):</p>
<pre class="console">
$ git reflog
ba5807e HEAD@{0}: pull: Merge made by the 'recursive' strategy.
3b16f17 HEAD@{1}: reset: moving to HEAD@{2}
2b953b4 HEAD@{2}: reset: moving to HEAD^
69e0d3d HEAD@{3}: reset: moving to HEAD^^
3b16f17 HEAD@{4}: commit: random.c was too long to type</pre>
<p class="calibre3">Every time <code>HEAD</code> and your branch head are updated for any reason, Git stores that information for you in this local<a id="_idIndexMarker333" class="pcalibre1 pcalibre calibre6"/> temporary log of ref history. The data from the reflog can be used to specify references (and therefore to specify revisions):</p>
<ul class="calibre16">
<li class="calibre15">To specify the <em class="italic">n</em>th prior value of <strong class="source-inline1">HEAD</strong> in your local repository, you can use <strong class="source-inline1">HEAD@{n}</strong> notation that you can see in the <strong class="source-inline1">git reflog</strong> output. It’s the same with the <em class="italic">n</em>th prior value of the given branch – for example, <strong class="source-inline1">master@{n}</strong>. The special syntax, <strong class="source-inline1">@{n}</strong>, means the <em class="italic">n</em>th prior value of the current branch, which can be different from <strong class="source-inline1">HEAD@{n}</strong>.</li>
<li class="calibre15">You can also use this syntax to see where a branch was some specific amount of time ago. For instance, to denote where your <strong class="source-inline1">master</strong> branch was yesterday in your local<a id="_idIndexMarker334" class="pcalibre1 pcalibre calibre6"/> repository, you can use <strong class="source-inline1">master@{yesterday}</strong>.</li>
<li class="calibre15">You can use the <strong class="source-inline1">@{-n}</strong> syntax to refer to the <em class="italic">n</em>th branch that was checked out (used) before the current one. In some places, you can simply use <strong class="source-inline1">– (dash)</strong> in place of <strong class="source-inline1">@{-1}</strong>. For example<strong class="source-inline1">, git checkout –</strong> or <strong class="source-inline1">git switch –</strong> will switch to the previous branch.</li>
</ul>
<h2 id="_idParaDest-96" class="calibre7"><a id="_idTextAnchor100" class="pcalibre1 pcalibre calibre6"/>Upstreaming remote-tracking branches</h2>
<p class="calibre3">The local repository that <a id="_idIndexMarker335" class="pcalibre1 pcalibre calibre6"/>you use to work doesn’t usually live in isolation. It interacts with other repositories, usually at least with the <code>origin</code> repository it was cloned from (unless it was started from scratch with <code>git init</code>).</p>
<p class="callout-heading">Note</p>
<p class="callout">The name of the default remote can be set using <strong class="source-inline1">clone.defaultRemoteName</strong>.</p>
<p class="calibre3">For these remote repositories with which you interact often, Git will track where their branches were at the time of the last contact.</p>
<p class="calibre3">To follow the movement of branches in the remote repository, Git uses <code>some-branch</code>, then the <code>git checkout &lt;some-branch&gt;</code> command will create a local branch based on this remote-tracking branch for you.</p>
<p class="calibre3">For example, when working on a line of development that is to be ultimately published to the <code>next</code> branch in the <code>origin</code> repository, which is tracked by the <code>origin/next</code> remote-tracking branch, you would create a local <code>next</code> branch. We say that <code>origin/next</code> is upstream of the <code>next</code> branch, and we can refer to it as <code>next@{upstream}</code>.</p>
<p class="calibre3">The <code>@{upstream}</code> suffix (short form <code>&lt;refname&gt;@{u}</code>), which can only be applied to a local branch name, selects the <a id="_idIndexMarker336" class="pcalibre1 pcalibre calibre6"/>branch that the ref is set to build on top of. A missing ref defaults to the current branch –  that is, <code>@{u}</code> is the upstream for the current branch.</p>
<p class="calibre3">There is also <code>[&lt;branch&gt;]@{push}</code>, which is useful for triangular workflows, where the repository you push your changes to is different from the repository you get updates from.</p>
<h2 id="_idParaDest-97" class="calibre7"><a id="_idTextAnchor101" class="pcalibre1 pcalibre calibre6"/>Selecting revisions via a commit message</h2>
<p class="calibre3">You can specify the revision by matching its commit message with a regular expression. The <code>:/&lt;pattern&gt;</code> notation (for example, <code>:/^Bugfix</code>) specifies the youngest matching commit that can be <a id="_idIndexMarker337" class="pcalibre1 pcalibre calibre6"/>reached from any ref, while <code>&lt;rev&gt;^{/&lt;pattern&gt;}</code> (for example, <code>next^{/fix bug}</code>) specifies the youngest matching commit that can be reached from <code>&lt;rev&gt;</code>:</p>
<pre class="console">
$ git log 'origin/pu^{/^Merge branch .rs/ref-transactions}'</pre>
<p class="calibre3">This revision specifier gives similar results to the <code>--grep=&lt;pattern&gt;</code> option to <code>git log</code>, but it’s composable. This means that it can be combined with other components, such as ancestry references. On the other hand, it only returns the first (youngest) matching revision, while the <code>--grep</code> option returns all matching revisions.</p>
<h1 id="_idParaDest-98" class="calibre5"><a id="_idTextAnchor102" class="pcalibre1 pcalibre calibre6"/>Selecting the revision range</h1>
<p class="calibre3">Now that you can<a id="_idIndexMarker338" class="pcalibre1 pcalibre calibre6"/> specify individual revisions in multiple ways, let’s learn how to specify ranges of revisions, a subset of the DAG we want to examine. <strong class="bold">Revision ranges</strong> are particularly useful for viewing selected parts of the history of a project.</p>
<p class="calibre3">For example, you can use range specifications to answer questions such as, “What work is on this branch that I haven’t yet merged into my main branch?”, “What works on my main branch I haven’t yet published?”, or simply “What was done on this branch since its creation?”</p>
<h2 id="_idParaDest-99" class="calibre7"><a id="_idTextAnchor103" class="pcalibre1 pcalibre calibre6"/>Single revision as a revision range</h2>
<p class="calibre3">History traversing commands such as <code>git log</code> operate on a set of commits, walking down a chain of revisions <a id="_idIndexMarker339" class="pcalibre1 pcalibre calibre6"/>from child to parent. These kinds of commands, given a single revision as an argument (as described in the <em class="italic">Single revision selection</em> section of this chapter), will show the set of commits that can be reached from that revision, following the commit ancestry chain, all the way down to root commits. Thanks to Git using pager by default, Git will stop after one full page – that is, one full screen of commits.</p>
<p class="calibre3">For example, <code>git log master</code> would show all commits that can be found from the tip of a <code>master</code> branch (all revisions that are or were based on the current work on the said branch), which means that it would show the whole <code>master</code> branch – that is, the whole line of development.</p>
<h2 id="_idParaDest-100" class="calibre7"><a id="_idTextAnchor104" class="pcalibre1 pcalibre calibre6"/>Double-dot notation</h2>
<p class="calibre3">The most common<a id="_idIndexMarker340" class="pcalibre1 pcalibre calibre6"/> range specification is the double-dot syntax, <code>A..B</code>. For a linear history, it means all revisions between <code>A</code> and <code>B</code>, or to be more exact all the commits that are in <code>B</code> but not in <code>A</code>, as shown in <em class="italic">Figure 4</em><em class="italic">.3</em>. For example, the <code>HEAD~4..HEAD</code> range means four commits: <code>HEAD</code>, <code>HEAD^</code>, <code>HEAD^^</code>, and <code>HEAD^^^</code>. In other words, it means <code>HEAD~0</code>, <code>HEAD~1</code>, <code>HEAD~2</code>, and <code>HEAD~3</code>, assuming that there is no merge commit between the current branch and its fourth ancestor:</p>
<div><div><img alt="Figure 4.3 – Double-dot notation A..B for linear history. The selected revision range is marked with a thin halo (with an outline)" src="img/B21194_04_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Double-dot notation A..B for linear history. The selected revision range is marked with a thin halo (with an outline)</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you want to include a starting commit (in the general case, boundary commits), which Git considers uninteresting by default, you can use the <strong class="source-inline1">--boundary</strong> option with <strong class="source-inline1">git log</strong>.</p>
<p class="calibre3">The situation is more complicated for a history that is not a straight line. One such case is when <code>A</code> is not the<a id="_idIndexMarker341" class="pcalibre1 pcalibre calibre6"/> ancestor of <code>B</code> (there is no path in the DAG of revisions leading from <code>B</code> to <code>A</code>), but both have a common ancestor, as shown in <em class="italic">Figure 4</em><em class="italic">.4</em>:</p>
<div><div><img alt="Figure 4.4 – Double-dot notation A..B for non-linear history, where revision A is not an ancestor of revision B, showing the case with a divergent history (with a fork point)" src="img/B21194_04_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Double-dot notation A..B for non-linear history, where revision A is not an ancestor of revision B, showing the case with a divergent history (with a fork point)</p>
<p class="calibre3">Another situation with non-linear history is when the path from <code>B</code> to <code>A</code> is not a simple line – that is, when there are merge commits between <code>A</code> and <code>B</code>, as shown in <em class="italic">Figure 4</em><em class="italic">.5</em>. In the view of nonlinear history, the double-dot notation, <code>A..B</code>, or <em class="italic">between A and B</em>, is defined as those commits that can be reached from <code>A</code> while being not reachable from <code>B</code>:</p>
<div><div><img alt="Figure 4.5 – Double-dot notation A..B for a non-linear history, with merge commit between A and B. To exclude commits marked with *, use the --strict-ancestor option" src="img/B21194_04_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Double-dot notation A..B for a non-linear history, with merge commit between A and B. To exclude commits marked with *, use the --strict-ancestor option</p>
<p class="calibre3">For Git, <code>A..B</code> means a range of all commits that can be reached from one revision (<code>B</code>) but can’t be reached from another revision (<code>A</code>) while following the ancestry chain. In the case of divergent <code>A</code> and <code>B</code>, as shown in <em class="italic">Figure 4</em><em class="italic">.4</em>, this is simply all commits in <code>B</code> from the branch point of <code>A</code>.</p>
<p class="calibre3">For example, say your <code>master</code> and <code>experiment</code> branches diverge. You want to see what’s in your <code>experiment</code> branch that hasn’t been merged into your <code>master</code> branch yet. You can ask Git to show you a log of just those commits with <code>master..experiment</code>.</p>
<p class="calibre3">If, on the other hand, you want to<a id="_idIndexMarker342" class="pcalibre1 pcalibre calibre6"/> see the opposite – all the commits in <code>master</code> that aren’t in <code>experiment</code> – you can reverse the branch names. The <code>experiment..master</code> notation shows you everything in <code>master</code> that can’t be reached from <code>experiment</code>.</p>
<p class="calibre3">Another example is that <code>origin/master..HEAD</code> shows what you’re about to push to a remote repository (commits in your current branch that are not yet present in the <code>master</code> branch in <code>origin</code>), while <code>HEAD..origin/master</code> can show what you have fetched but not yet merged in.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can also leave off one side of the syntax to have Git assume <strong class="source-inline1">HEAD</strong>: <strong class="source-inline1">origin/master..</strong> is <strong class="source-inline1">origin/master..HEAD</strong> and <strong class="source-inline1">..origin/master</strong> is <strong class="source-inline1">HEAD..origin/master</strong>; Git substitutes <strong class="source-inline1">HEAD</strong> if one side is missing.</p>
<p class="calibre3">Git uses double-dot notation in many places, such as in the output of <code>git fetch</code> and <code>git push</code> for ordinary fast-forward cases. Here, you can just copy and paste a fragment of output as parameters to <code>git log</code>. In this case, the beginning of the range is the ancestor of the end of the range – that is, the range is linear:</p>
<pre class="console">
$ git push
To https://git.company.com/random
   8c4ceca..493e222  master -&gt; master</pre>
<h2 id="_idParaDest-101" class="calibre7"><a id="_idTextAnchor105" class="pcalibre1 pcalibre calibre6"/>Creating the range by including and excluding revisions</h2>
<p class="calibre3">The double-dot <code>A..B</code> syntax is very useful and quite intuitive, but it is a shorthand notation. Usually, it’s enough, but<a id="_idIndexMarker343" class="pcalibre1 pcalibre calibre6"/> sometimes, you might want more than it provides. Perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are present in any of several branches that aren’t in the branch you’re currently on. Perhaps you want to see only those changes on the <code>master</code> branch that aren’t in any of the other long-lived branches.</p>
<p class="calibre3">Git allows you to exclude the commits that can be reached from a given revision by <em class="italic">prefixing</em> said revision with <code>^</code>. For example, to view all revisions that are on <code>maint</code> or <code>master</code>, but are not in <code>next</code>, you can use <code>git log maint master ^next</code>. This means that the <code>A..B</code> notation is just a shorthand for <code>B ^A</code>.</p>
<p class="calibre3">Instead of having to use the <code>^</code> character as a prefix for each of the revisions we want to exclude, Git allows us to use the <code>--not</code> option, which <em class="italic">negates</em> all the following revisions. For example, <code>B ^A ^C</code> might be written as <code>B --not A C</code>. This is useful, for example, when we’re generating excluded revisions programmatically.</p>
<p class="calibre3">Thus, these three commands are equivalent:</p>
<pre class="console">
$ git log A..B
$ git log B ^A
$ git log B --not A</pre>
<h2 id="_idParaDest-102" class="calibre7"><a id="_idTextAnchor106" class="pcalibre1 pcalibre calibre6"/>The revision range for a single revision</h2>
<p class="calibre3">There is another useful shortcut, <code>A^!</code>, that is a range composed of a single commit. For non-merge commits, it is<a id="_idIndexMarker344" class="pcalibre1 pcalibre calibre6"/> simply <code>A^..A</code>.</p>
<p class="calibre3">For merge commits, <code>A^!</code> excludes all the parents. With the help of yet another special notation, namely <code>A^@</code>, denoting all the parents of <code>A</code> (that is, <code>A^1</code>, <code>A^2</code>,… <code>A^n</code>), we can say that <code>A^!</code> is a shortcut for <code>A --</code><code>not A^@</code>.</p>
<h2 id="_idParaDest-103" class="calibre7"><a id="_idTextAnchor107" class="pcalibre1 pcalibre calibre6"/>Triple-dot notation</h2>
<p class="calibre3">The last major syntax for specifying revision ranges is the triple-dot syntax, <code>A...B</code>. It selects all the commits that can<a id="_idIndexMarker345" class="pcalibre1 pcalibre calibre6"/> be reached by either of two references, but not by both of them; see <em class="italic">Figure 4</em><em class="italic">.6</em>. In mathematics, this notation is called the <strong class="bold">symmetric difference of A </strong><strong class="bold">and B</strong>:</p>
<div><div><img alt="Figure 4.6 – A triple-dot notation, A...B, for a non-linear history, where the selected range is shown with a thin outline, and O is the boundary commit – the merge base of A and B" src="img/B21194_04_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.6 – A triple-dot notation, A...B, for a non-linear history, where the selected range is shown with a thin outline, and O is the boundary commit – the merge base of A and B</p>
<p class="calibre3">It is a shortcut notation for <code>A B --not $(git merge-base --all A B)</code>, where <code>$(…)</code> denotes shell <code>git merge-base</code> command to find out all the best common ancestors (all merge bases), and then paste its output on the command line so that it can be negated.</p>
<p class="calibre3">A common switch to the <code>git log</code> command to use with the triple dot notation is <code>--left-right</code>. This option makes Git show which side of the range each commit is in by prefixing commits from the left-hand side (<code>A</code> in <code>A...B</code>) with <code>&lt;</code>, and those from the right (<code>B</code> in <code>A...B</code>) with <code>&gt;</code>, as shown in <em class="italic">Figure 4</em><em class="italic">.6</em> and the following example. This helps make the data more useful:</p>
<pre class="console">
$ git log --oneline --left-right 37ec5ed...8cd8cf8
&gt;8cd8cf8 Merge branch 'fc/remote-helper-refmap' into next
&gt;efcd02e Merge branch 'rs/more-starts-with' into next
&gt;831aa30 Merge branch 'jm/api-strbuf-doc' into next
&gt;1aeca19 Merge branch 'jc/count-parsing' into next
&lt;1a7e8e8 Revert "replace: add --graft option"
&lt;7a30690 t9001: avoid non-portable '\n' with sed
&gt;5cc3268 fetch doc: remove "short-cut" section</pre>
<p class="callout-heading">Important note</p>
<p class="callout">If the <strong class="source-inline1">--left-right</strong> option is combined with <strong class="source-inline1">--boundary</strong>, these normally uninteresting boundary commits are prefixed with <strong class="source-inline1">-</strong>.</p>
<p class="callout">In the case of using the triple-dot <strong class="source-inline1">A...B</strong> revision range, these boundary commits are <strong class="source-inline1">git merge-base --all </strong><strong class="source-inline1">A B</strong>.</p>
<p class="calibre3">Git uses triple-dot notation in <code>git fetch</code> and <code>git push</code> output when there is a <strong class="bold">forced update</strong>, in cases where <a id="_idIndexMarker346" class="pcalibre1 pcalibre calibre6"/>the old version (left-hand side) and the updated version (right-hand side) diverged, and the new version was forced to overwrite the old version:</p>
<pre class="console">
$ git fetch
From git://git.kernel.org/pub/scm/git/git
 + 37ec5ed...8cd8cf8 next   -&gt; origin/next  (forced update)
 + 9478935...16067c9 pu     -&gt; origin/pu  (forced update)
   d0b0081..1f58507  todo   -&gt; origin/todo</pre>
<p class="callout-heading">Using the revision range notation in diff</p>
<p class="callout">To make it easier to copy and paste between the <strong class="source-inline1">log</strong> and <strong class="source-inline1">diff</strong> commands, Git allows us to use the <em class="italic">revision range</em> double-dot notation, <strong class="source-inline1">A..B</strong>, and triple-dot, <strong class="source-inline1">A...B</strong>, as a <em class="italic">set of revisions (endpoints)</em> in the <strong class="source-inline1">git </strong><strong class="source-inline1">diff</strong> command.</p>
<p class="callout">For Git, using <strong class="source-inline1">git diff A..B</strong> is the same as <strong class="source-inline1">git diff A B</strong>, which means the difference between revision <strong class="source-inline1">A</strong> and revision <strong class="source-inline1">B</strong>. If the revision on either side of the double dot is omitted, it will have the same effect as using <strong class="source-inline1">HEAD</strong> instead. For example, <strong class="source-inline1">git diff A..</strong> is equivalent to <strong class="source-inline1">git diff </strong><strong class="source-inline1">A HEAD</strong>.</p>
<p class="callout">The <strong class="source-inline1">git diff A...B</strong> notation is<a id="_idIndexMarker347" class="pcalibre1 pcalibre calibre6"/> intended to show incoming changes on branch <strong class="source-inline1">B</strong>. Incoming changes mean revisions up to <strong class="source-inline1">B</strong>, starting at a common ancestor – that is, a merge base of both <strong class="source-inline1">A</strong> and <strong class="source-inline1">B</strong>. Thus, writing <strong class="source-inline1">git diff A...B</strong> is equivalent to <strong class="source-inline1">git diff $(git merge-base A B) B</strong>; note that <strong class="source-inline1">git merge-base</strong> is without <strong class="source-inline1">--all</strong> here. The result of this convention makes it so that a copy and paste of the <strong class="source-inline1">git fetch</strong> output (whether with double-dot or triple-dot) as an argument to <strong class="source-inline1">git diff</strong> will always show fetched changes. Note, however, that it doesn’t include changes that were made on <strong class="source-inline1">A</strong> since divergence at all!</p>
<p class="callout">With modern Git, you can use the less cryptic <strong class="source-inline1">git diff --merge-base A B</strong> instead of using triple-dot notation – that is, <strong class="source-inline1">git </strong><strong class="source-inline1">diff A...B</strong>.</p>
<p class="callout">Additionally, this feature makes it possible to use <strong class="source-inline1">git diff A^!</strong> to view how revi<a id="_idTextAnchor108" class="pcalibre1 pcalibre calibre6"/>sion <strong class="source-inline1">A</strong> differs from its parent (it’s the shortcut for <strong class="source-inline1">git diff </strong><strong class="source-inline1">A^ A</strong>).</p>
<h1 id="_idParaDest-104" class="calibre5"><a id="_idTextAnchor109" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter covered the various ways you can explore project history: to find relevant revisions, select revisions to display, and for further analysis.</p>
<p class="calibre3">We started by describing the conceptual model of project history: the DAG of revisions. Understanding this concept is very important because many selection tools refer directly or indirectly to the DAG.</p>
<p class="calibre3">Then, you learned how to select a single revision and range of revisions, as well as how the concept of revision range works for a non-linear history. We can use this knowledge to see what changes were made on a branch since its divergence from the base branch, and vice versa; we can also examine what happened to both branches since their divergence.</p>
<p class="calibre3">Selecting revisions is an important first step in searching through project history. This will be described in the next chapter.</p>
<h1 id="_idParaDest-105" class="calibre5"><a id="_idTextAnchor110" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">How would you list all revisions that are present upstream for the current branch but are not present in the current branch (are not integrated)?</li>
<li class="calibre15">How would you list all revisions that you would send using <strong class="source-inline1">git push</strong>, allowing for a triangular workflow (remote to push to is different from remote to pull from)?</li>
<li class="calibre15">How can you find all divergent changes in two branches, <strong class="source-inline1">A</strong> and <strong class="source-inline1">B</strong>, starting from a fork point, and show which changeset is present on which branch?</li>
<li class="calibre15">How can you list all commits that were made on any remote-tracking branch whose name starts with <strong class="source-inline1">fix-</strong>, from any remote repository?</li>
<li class="calibre15">What is the simplest way of switching to the previous branch, and how does it work?</li>
</ol>
<h1 id="_idParaDest-106" class="calibre5"><a id="_idTextAnchor111" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to this chapter’s questions:</p>
<ol class="calibre14">
<li class="calibre15">Combine the double-dot notation with the notation for the upstream branch: <strong class="source-inline1">git </strong><strong class="source-inline1">log ..@</strong><strong class="source-inline1">{upstream}</strong>.</li>
<li class="calibre15">Use <strong class="source-inline1">git log @{push}..HEAD</strong>, combining double-dot notation with the “where to push to” notation. Note that for simple workflows, <strong class="source-inline1">@{push}</strong> is the same as <strong class="source-inline1">@{upstream}</strong>.</li>
<li class="calibre15">Use the triple-dot notation and the appropriate <strong class="source-inline1">git log</strong> option: <strong class="source-inline1">git log --left-right  </strong><strong class="source-inline1">A...B</strong>.</li>
<li class="calibre15">Use the <strong class="source-inline1">--remotes[=&lt;pattern&gt;]</strong> option with the appropriate glob pattern: <strong class="source-inline1">git </strong><strong class="source-inline1">log --remotes=*/fix-*</strong>.</li>
<li class="calibre15">Use <strong class="source-inline1">git checkout –</strong> or <strong class="source-inline1">git switch -</strong>. In those commands, <strong class="source-inline1">-</strong> means <strong class="source-inline1">@{-1}</strong>, which uses the reflog to find the previous value of the current branch.</li>
</ol>
<h1 id="_idParaDest-107" class="calibre5"><a id="_idTextAnchor112" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">gitrevisions(7) – specifying revisions and ranges for Git: <a href="https://git-scm.com/docs/gitrevisions" class="pcalibre1 pcalibre calibre6">https://git-scm.com/docs/gitrevisions</a></li>
<li class="calibre15">Scott Chacon, Ben Straub: <em class="italic">Pro Git</em>, 2nd Edition (2014), Apress <em class="italic">Chapter 2</em><em class="italic">.3: Git Basics - Viewing the Commit </em><em class="italic">History</em>: <a href="https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History</a></li>
<li class="calibre15"><em class="italic">glob(7)</em> – globbing pathnames (shell wildcard patterns): <a href="https://man7.org/linux/man-pages/man7/glob.7.html" class="pcalibre1 pcalibre calibre6">https://man7.org/linux/man-pages/man7/glob.7.html</a></li>
<li class="calibre15">Jan Goyvaerts: <em class="italic">Regular Expressions Tutorial: Learn How to Use and Get The Most out of Regular </em><em class="italic">Expressions</em>: <a href="https://www.regular-expressions.info/tutorial.html" class="pcalibre1 pcalibre calibre6">https://www.regular-expressions.info/tutorial.html</a></li>
</ul>
</div>
</body></html>