- en: Chapter 3. Automating Docker Deployments with Chef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By this time, we already know the various aspects of the Docker ecosystem. The
    Docker host has several configuration parameters. However, manually configuring
    Docker hosts is a slow and error-prone process. We will have problems scaling
    our Docker deployments in production if we don't have an automation strategy in
    place.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the concept of configuration management to solve
    this problem. We will use Chef, a configuration management software, to manage
    Docker hosts in scale. This chapter will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The importance of configuration management
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Chef
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatically configuring Docker hosts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying Docker containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alternative automation tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to configuration management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker engine has several parameters to tune, such as cgroups, memory, CPU,
    filesystems, networking, and so on. Identifying which Docker containers run on
    which Docker hosts is another aspect of configuration. The Docker containers themselves
    need to be configured differently with cgroups settings, shared volumes, linked
    containers, public ports, and so on. Getting the combination of parameters to
    optimize our application will take time.
  prefs: []
  type: TYPE_NORMAL
- en: Replicating all the preceding configuration items to another Docker host is
    difficult to perform manually. We might not remember all the steps required to
    create a host, and it is an error-prone and slow process. Creating a "documentation"
    to get this process captured doesn't help either because such artifacts tend to
    get stale over time.
  prefs: []
  type: TYPE_NORMAL
- en: If we cannot provision new Docker hosts in a timely and reliable manner, we
    will have no space to scale out our Docker application. It is just as important
    to prepare and configure our Docker hosts in a consistent and fast manner. Otherwise,
    Docker's ability to create container packages for our application will become
    useless very fast.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configuration management is a strategy to manage the changes happening in all
    aspects of our application, and it reports and audits the changes made to our
    system. This does not only apply when developing our application. For our case,
    it records all the changes to Docker hosts and the running of the Docker containers
    itself. Docker, in a sense, accomplishes the following aspects of configuration
    management for our application:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker containers reproduce any environment for our application, from development
    to staging, testing, and production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building Docker images is a simple way to make application changes and have
    them deployed to all environments.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker enables all team members to get information about our application and
    make the needed changes to deliver the software efficiently to customers. By inspecting
    the `Dockerfile`, they can know which part of the application needs to be updated
    and what it needs in order to properly run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker tracks any change in our environment to a particular Docker image. Then,
    it traces it back to the corresponding version of the `Dockerfile`. It traces
    what the change is, who made it, and when it was made.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, what about the Docker host running our application? Just as how a `Dockerfile`
    allows us to manage our application's environment in version control, configuration
    management tools can describe our Docker hosts in code. It simplifies the process
    to create Docker hosts. In the case of scaling out our Docker application, we
    can recreate a new Docker host from scratch easily. When there is a hardware failure,
    we can bring up new Docker hosts somewhere else from their known configuration.
    If we want to deploy a new version of our Docker containers, we can just update
    the Docker host's configuration code to point to the new image. Configuration
    management enables us to manage our Docker deployments in scale.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chef
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Chef is a configuration management tool that provides a domain-specific language
    to model the configuration of our infrastructure. Each configuration item in our
    infrastructure is modeled as a resource. A resource is basically a Ruby method
    that accepts several parameters in a block. The following example resource describes
    installing the `docker-engine` package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These resources are then written together in Ruby source files called recipes.
    When running a recipe against a server (a Docker host in our case), all the defined
    resources are executed to reach its desired state configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Some Chef recipes may depend on other supplemental items, such as configuration
    templates and other recipes. All this information is gathered in cookbooks together
    with the recipes. A cookbook is the fundamental unit of distributing configuration
    and policy to our servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write Chef recipes to represent the desired state configuration of
    our Docker hosts. Our recipes will be organized in Chef cookbooks to distribute
    them to our infrastructure. However, first, let''s prepare our Chef environment
    so that we can start describing our Docker-based infrastructure in recipes. A
    Chef environment consists of three things:'
  prefs: []
  type: TYPE_NORMAL
- en: A Chef server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A workstation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next few subsections will give you a detailed description of each component.
    Then, we will set them up to prepare our Chef environment to be able to manage
    our Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are more details of setting up a Chef environment that are out of this
    chapter's scope. More information can be found at the Chef documentation website
    at [http://docs.chef.io](http://docs.chef.io).
  prefs: []
  type: TYPE_NORMAL
- en: Signing up for a Chef server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Chef server is the central repository of cookbooks and other policy items
    governing our entire infrastructure. It contains metadata about the infrastructure
    that we are managing. In our case, the Chef server contains the cookbook, policy,
    and metadata on our Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare a Chef server, we will simply sign up for a hosted Chef server.
    A free Chef server account allows us to manage up to five nodes in our infrastructure.
    Follow the next few steps to prepare a hosted Chef server account:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to [https://manage.chef.io/signup](https://manage.chef.io/signup) and fill
    out the form for our account details as shown in the following screenshot:![Signing
    up for a Chef server](img/00007.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After creating a user account, the hosted Chef server will now prompt us to
    create an organization. Organizations are simply used to manage role-based access
    control for our Chef server. Create an organization by providing the details on
    the form and click on the **Create Organization** button:![Signing up for a Chef
    server](img/00008.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are now almost done getting our hosted Chef server account. Finally, click
    on **Download Starter Kit**. This will download a zip file containing our starter
    chef-repo. We will talk more about the chef-repo in the next section.![Signing
    up for a Chef server](img/00009.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Setting up our workstation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The second part of our Chef environment is the workstation. The workstation
    is used to interact with the Chef server. This is where we will do most of the
    preparation work and create the code to send to the Chef server. In our workstation,
    we will prepare the configuration items of our infrastructure in a Chef repository.
  prefs: []
  type: TYPE_NORMAL
- en: The Chef repository contains all the information needed to interact and synchronize
    with the Chef server. It contains the private key and other configuration files
    needed to authenticate and interact with the Chef server. These files will be
    found in the `.chef` directory of our Chef repository. It also contains the cookbooks
    that we will write and synchronize later with the Chef server in the `cookbooks/`
    directory. There are other files and directories inside a Chef repository, such
    as data bags, roles, and environments as well. However, it is enough for now to
    know about the cookbooks and authentication files to be able to configure our
    Docker host.
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember that starter kit we downloaded in the previous section? Unzip
    this file to extract our chef-repo. We should have the following files described
    in the directory tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our workstation](img/00010.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Another important component in our workstation is the Chef development kit.
    It contains all the programs needed to read all the configuration in our chef-repo
    and interact with the Chef server. Convenient programs to create, develop, and
    test our cookbooks are also available in the Chef development kit. We will use
    various programs in the development kit throughout the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's download the Chef development kit from [https://downloads.chef.io/chef-dk](https://downloads.chef.io/chef-dk)
    according to our workstation's platform.
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up our workstation](img/00011.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, open the downloaded installer. Install the Chef development kit according
    to the prompts from our platform. Finally, confirm that the installation was successful
    with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have set up our workstation, let's go to our `chef-repo/` directory
    to prepare the last component of our Chef environment.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap nodes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last part of our Chef environment is nodes. A node is any computer that
    is managed by Chef. It can be a physical machine, virtual machine, a server in
    the cloud, or a networking device. In our case, our Docker host is a node.
  prefs: []
  type: TYPE_NORMAL
- en: 'The central component for any node to be managed by Chef is the chef-client.
    It connects to the Chef server to download the necessary files to bring our node
    to its configuration state. When a chef-client is run on our node, it performs
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: It registers and authenticates the node with the Chef server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It gathers system information in our node to create a node object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, it synchronizes the Chef cookbooks needed by our node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It compiles the resources by loading our node's needed recipes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, it executes all the resources and performs the corresponding actions to
    configure our node.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, it reports the result of the chef-client run back to the Chef server
    and other configured notification endpoints.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s prepare our Docker host as a node by bootstrapping it from our
    workstation. The bootstrapping process installs and configures the chef-client.
    Run the following command to get this bootstrap process started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can note in the preceding command, the bootstrapping process did two things.
    First, it installed and configured the chef-client on our Docker host node. Next,
    it started the chef-client to synchronize its desired state with our Chef server.
    As we haven't assigned any designed state yet to our Docker host, it didn't do
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can customize this bootstrap process according to our needs. More information
    on how to use `knife bootstrap` can be found at [http://docs.chef.io/knife_bootstrap.html](http://docs.chef.io/knife_bootstrap.html).
  prefs: []
  type: TYPE_NORMAL
- en: In some cases, cloud providers have a deep Chef integration already out of the
    box. So, instead of `knife bootstrap`, we will just use the cloud provider's SDK.
    There, we just need to specify that we want to have Chef integrated. We will provide
    it with the information, such as the chef-client's `client.rb` configuration and
    validation keys' credentials.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Docker host is now properly registered to the Chef server, ready to grab
    its configuration. Go to [https://manage.chef.io/organizations/dockerorg/nodes/dockerhost](https://manage.chef.io/organizations/dockerorg/nodes/dockerhost)
    to check our Docker host as a node in our Chef environment, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Bootstrap nodes](img/00012.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring the Docker host
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have all the components of our Chef environment properly set up,
    we can now start writing Chef recipes to actually describe what configuration
    our Docker host should have. In addition, we will leapfrog our productivity by
    taking advantage of existing Chef cookbooks in the Chef ecosystem. As Docker is
    a popular infrastructure stack to deploy, we can use cookbooks in the wild that
    allow us to configure our Docker hosts. Chef cookbooks provided by the community
    can be found in the Chef supermarket. We can go to [http://supermarket.chef.io](http://supermarket.chef.io)
    to discover other cookbooks that we can readily use.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to write Chef recipes and apply it to our
    node. Follow the next few steps to write the recipe for our Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the Chef development kit''s `chef generate cookbook` command to generate
    a boilerplate for our cookbook. After entering the cookbooks directory, issue
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The boilerplate cookbook directory structure will look similar to the following
    screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Configuring the Docker host](img/00013.jpeg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Next, we will prepare to edit our cookbook. Change our working directory to
    the cookbook we created earlier using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Install the following cookbooks from the Chef supermarket as dependencies:
    `apt` and `docker`. These cookbooks provide additional resource definitions that
    can be used in our recipes. We will use them later as building blocks to set up
    our Docker host. To add the dependencies, update the `metadata.rb` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `metadata.rb` file provides metadata about our Chef cookbooks. The information
    in the metadata provides hints to the Chef server so that the cookbook can be
    properly deployed to our nodes. For more information on how to configure metadata
    to our Chef cookbooks, visit [http://docs.chef.io/config_rb_metadata.html](http://docs.chef.io/config_rb_metadata.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have our dependencies declared, we can download them by issuing
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we will write the Chef recipe equivalent to the installation instructions
    found at [http://blog.docker.com/2015/07/new-apt-and-yum-repos](http://blog.docker.com/2015/07/new-apt-and-yum-repos).
    We will use the `apt_repository` resource provided by the **apt** dependency cookbook
    we added earlier. Then, add the following lines to `recipes/default.rb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we are done preparing our `dockerhost/` Chef cookbook. The final step
    is to apply it to our Docker host so that it can pick its desired configuration.
    Follow the next remaining steps to perform this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, upload the Chef cookbook to our Chef server. Note that in the output
    of the following command, the `apt` and `docker` cookbooks that we depend on will
    also be automatically uploaded:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, apply the `dockerhost` recipe we wrote earlier to the node (that is,
    the Docker host) by setting its `run_list` via the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, run the chef-client in `dockerhost`. The chef-client will fetch the
    Docker host''s node object and apply the desired state configuration we applied
    in the previous steps, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we have Docker installed and configured in our Docker host using Chef.
    Whenever we need to add another Docker host, we can just create another server
    in our cloud provider and bootstrap it to have the `dockerhost` Chef recipe written
    earlier. When we want to update how the Docker daemons are configured in all our
    Docker hosts, we will just update the Chef cookbook and rerun the chef-client.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a production environment, the goal of having configuration management software
    installed in our Docker host is to never have the need to log in to it just to
    perform configuration updates. Running the chef-client manually is only half the
    automation.
  prefs: []
  type: TYPE_NORMAL
- en: We will want to run the chef-client as a daemon process so that we don't have
    to run it every time we perform an update. The chef-client daemon will poll the
    Chef server to check whether there are any updates to the node it is managing.
    By default, this polling interval is set to 30 minutes.
  prefs: []
  type: TYPE_NORMAL
- en: For more information on how to configure the chef-client as a daemon, refer
    to the Chef documentation at [https://docs.chef.io/chef_client.html](https://docs.chef.io/chef_client.html).
  prefs: []
  type: TYPE_NORMAL
- en: Deploying Docker containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step to manage Docker in scale is to deploy Docker containers to our
    pool of Docker hosts automatically. By now, we have built a few Docker applications
    already. We have a rough architectural sketch of how these containers communicate
    with and consume each other. Chef recipes can be used to represent this architectural
    topology in code, which is essential to managing our whole application and infrastructure
    in scale. We can identify which Docker containers need to run and know how each
    container connects with other containers. We can locate where our Docker containers
    should be deployed. Having the whole architecture in code allows us to place an
    orchestration strategy for our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we will create a Chef recipe to orchestrate the deployment
    of the Nginx Docker image to our Docker host. We will use the Chef resources provided
    by the `docker` cookbook we added in the previous section to configure our Docker
    host. Follow the next few steps to perform the deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create the Chef recipe that we will work on. The following command
    will create the `recipes/containers.rb` recipe file in our `dockerhost/` cookbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, pull the official Nginx Docker image at [https://registry.hub.docker.com/_/nginx](https://registry.hub.docker.com/_/nginx)
    to our Docker host. Write the following code in `recipes/containers.rb`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After downloading the Docker image, configure the Docker host to run the container.
    As of version 0.40.3 of the `docker` cookbook, we need to specify that our Debian
    Jessie Docker host deployment uses `systemd` as its `init` system. Add the following
    lines to the `recipes/containers.rb` as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `docker_container` and `docker_image` has several other options that we
    can tune to specify what we want to do with our container. The `docker` cookbook
    also has other resources to work with our Docker hosts. More information on options
    and further usage can be found on its project page at [https://github.com/bflad/chef-docker](https://github.com/bflad/chef-docker).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will prepare the new version of our cookbook for release. Bump the
    version information in `metadata.rb` to do this, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `Berksfile.lock` file to pin the versions of all the cookbooks we
    will upload to the Chef server in the next step. Type the following command to
    perform the update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that all the artifacts for our new cookbook are ready, we will type the
    following command to upload the updated cookbook to our Chef server. Note how
    the berks upload command automatically recognizes that only the `dockerhost` cookbook
    needs updating as it skips uploading the `apt` and `docker` cookbooks:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the `recipes/containers.rb` to the run list of our Docker host. Type
    the following command to update the node representing our Docker host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, rerun the chef-client to pick up the new configuration for our Docker
    host. We can also wait for the rerun of the chef-client if we configure the chef-client
    to run as a daemon process. Execute the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now have our Docker host running the nginx Docker container. We can confirm
    that it is working by going to `http://dockerhost`. We should be able to get the
    following page in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Deploying Docker containers](img/00014.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Alternative methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are other general-purpose configuration management tools that allow us
    to configure our Docker host. The following is a short list of the other tools
    that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Puppet**: Refer to [http://puppetlabs.com](http://puppetlabs.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ansible**: This can be found at [http://ansible.com](http://ansible.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**CFEngine**: This is available at [http://cfengine.com](http://cfengine.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SaltStack**: You can find more on this at [http://saltstack.com](http://saltstack.com).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The Docker machine**: This is a very specific configuration management tool
    that allows us to provision and configure Docker hosts in our infrastructure.
    More information about Docker machine can be found on the Docker documentation
    page at [https://docs.docker.com/machine](https://docs.docker.com/machine).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we do not want to manage our Docker host infrastructure at all, we can use
    Docker hosting services. Popular cloud providers started offering Docker hosts
    as a preprovisioned cloud image that we can use. Others offer a more comprehensive
    solution that allows us to interact with all the Docker hosts in the cloud as
    a single virtual Docker host. The following is a list of links of the popular
    cloud providers describing their integration with the Docker ecosystem:'
  prefs: []
  type: TYPE_NORMAL
- en: Google Container Engine ([https://cloud.google.com/container-engine](https://cloud.google.com/container-engine))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amazon EC2 Container Service ([http://aws.amazon.com/documentation/ecs](http://aws.amazon.com/documentation/ecs))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Azure Docker VM Extension ([https://github.com/Azure/azure-docker-extension](https://github.com/Azure/azure-docker-extension))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Joyent Elastic Container Service ([https://www.joyent.com/public-cloud](https://www.joyent.com/public-cloud))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In terms of deploying Docker containers, there are several container tools
    that allow you to do this. They provide APIs to run and deploy our Docker containers.
    Some of the offered APIs are even compatible with the Docker engine itself. This
    allows us to interact with our pool of Docker hosts as if it is a single virtual
    Docker host. The following is a list of a few tools that allow us to orchestrate
    the deployment of our containers to a pool of Docker hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Swarm ([https://www.docker.com/docker-swarm](https://www.docker.com/docker-swarm))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Kubernetes ([http://kubernetes.io](http://kubernetes.io))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoreOS fleet ([https://coreos.com/fleet](https://coreos.com/fleet))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mesophere Marathon ([https://mesosphere.github.io/marathon](https://mesosphere.github.io/marathon))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SmartDataCenter Docker Engine ([https://github.com/joyent/sdc-docker](https://github.com/joyent/sdc-docker))
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, we still need configuration management tools such as Chef to deploy
    and configure our orchestration systems at the top of our pool of Docker hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how to automate the configuration of our Docker
    deployments. Using Chef allows us to configure and provision multiple Docker hosts
    in scale. It also enabled us to deploy and orchestrate Docker containers for our
    application to our pool of Docker hosts. From this point on, you can write Chef
    recipes to persist all the Docker optimization techniques you will learn in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce instrumentation to monitor our whole
    Docker infrastructure and application. This will give us further feedback on how
    to better optimize our Docker deployments for higher performance.
  prefs: []
  type: TYPE_NORMAL
