- en: Chapter 3. Automating Docker Deployments with Chef
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 使用Chef自动化Docker部署
- en: By this time, we already know the various aspects of the Docker ecosystem. The
    Docker host has several configuration parameters. However, manually configuring
    Docker hosts is a slow and error-prone process. We will have problems scaling
    our Docker deployments in production if we don't have an automation strategy in
    place.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经了解了Docker生态系统的各个方面。Docker主机有几个配置参数。然而，手动配置Docker主机是一个缓慢且容易出错的过程。如果我们没有自动化策略，Docker部署在生产环境中的扩展就会遇到问题。
- en: 'In this chapter, we will learn the concept of configuration management to solve
    this problem. We will use Chef, a configuration management software, to manage
    Docker hosts in scale. This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习配置管理的概念，以解决这个问题。我们将使用Chef，一款配置管理软件，来大规模管理Docker主机。本章将涵盖以下主题：
- en: The importance of configuration management
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置管理的重要性
- en: An introduction to Chef
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Chef简介
- en: Automatically configuring Docker hosts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动配置Docker主机
- en: Deploying Docker containers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 部署Docker容器
- en: Alternative automation tools
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 替代自动化工具
- en: An introduction to configuration management
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置管理简介
- en: The Docker engine has several parameters to tune, such as cgroups, memory, CPU,
    filesystems, networking, and so on. Identifying which Docker containers run on
    which Docker hosts is another aspect of configuration. The Docker containers themselves
    need to be configured differently with cgroups settings, shared volumes, linked
    containers, public ports, and so on. Getting the combination of parameters to
    optimize our application will take time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Docker引擎有几个需要调整的参数，如cgroups、内存、CPU、文件系统、网络等。确定哪些Docker容器运行在哪些Docker主机上是配置的另一个方面。Docker容器本身也需要使用不同的cgroups设置、共享卷、链接容器、公用端口等进行配置。找到优化应用程序的参数组合需要一些时间。
- en: Replicating all the preceding configuration items to another Docker host is
    difficult to perform manually. We might not remember all the steps required to
    create a host, and it is an error-prone and slow process. Creating a "documentation"
    to get this process captured doesn't help either because such artifacts tend to
    get stale over time.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有前述配置项复制到另一个Docker主机是手动执行非常困难的。我们可能无法记住创建主机所需的所有步骤，而且这也是一个容易出错且缓慢的过程。创建一份“文档”来记录这个过程也没有帮助，因为这样的文档往往随着时间的推移而变得过时。
- en: If we cannot provision new Docker hosts in a timely and reliable manner, we
    will have no space to scale out our Docker application. It is just as important
    to prepare and configure our Docker hosts in a consistent and fast manner. Otherwise,
    Docker's ability to create container packages for our application will become
    useless very fast.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不能及时、可靠地配置新的Docker主机，就没有空间扩展我们的Docker应用程序。以一致和快速的方式准备和配置Docker主机同样重要。否则，Docker为我们的应用程序创建容器包的能力很快就会变得毫无意义。
- en: 'Configuration management is a strategy to manage the changes happening in all
    aspects of our application, and it reports and audits the changes made to our
    system. This does not only apply when developing our application. For our case,
    it records all the changes to Docker hosts and the running of the Docker containers
    itself. Docker, in a sense, accomplishes the following aspects of configuration
    management for our application:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理是一种管理我们应用程序各方面变化的策略，它报告并审计我们系统所做的更改。这不仅仅适用于开发应用程序的过程中。在我们的案例中，它记录了所有Docker主机的更改以及Docker容器本身的运行情况。从某种意义上说，Docker实现了我们应用程序的配置管理的以下几个方面：
- en: Docker containers reproduce any environment for our application, from development
    to staging, testing, and production.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker容器可以复制我们应用程序的任何环境，从开发到预发布、测试、生产等环境。
- en: Building Docker images is a simple way to make application changes and have
    them deployed to all environments.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建Docker镜像是一种简单的方式，能够对应用程序进行更改并将其部署到所有环境。
- en: Docker enables all team members to get information about our application and
    make the needed changes to deliver the software efficiently to customers. By inspecting
    the `Dockerfile`, they can know which part of the application needs to be updated
    and what it needs in order to properly run.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker使得所有团队成员都能获得有关我们应用程序的信息，并进行所需的更改，以高效地将软件交付给客户。通过查看`Dockerfile`，他们可以了解应用程序的哪个部分需要更新，以及为了正常运行，应用程序需要哪些内容。
- en: Docker tracks any change in our environment to a particular Docker image. Then,
    it traces it back to the corresponding version of the `Dockerfile`. It traces
    what the change is, who made it, and when it was made.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker 跟踪我们环境中任何 Docker 镜像的变化。然后，它将变化追溯到相应版本的 `Dockerfile`。它追踪变化的内容、是谁做的、以及何时做的。
- en: However, what about the Docker host running our application? Just as how a `Dockerfile`
    allows us to manage our application's environment in version control, configuration
    management tools can describe our Docker hosts in code. It simplifies the process
    to create Docker hosts. In the case of scaling out our Docker application, we
    can recreate a new Docker host from scratch easily. When there is a hardware failure,
    we can bring up new Docker hosts somewhere else from their known configuration.
    If we want to deploy a new version of our Docker containers, we can just update
    the Docker host's configuration code to point to the new image. Configuration
    management enables us to manage our Docker deployments in scale.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，运行我们应用程序的 Docker 主机怎么办？就像 `Dockerfile` 允许我们在版本控制中管理我们应用的环境一样，配置管理工具也可以用代码描述我们的
    Docker 主机。它简化了创建 Docker 主机的过程。在扩展我们的 Docker 应用时，我们可以轻松地从头开始重新创建一个新的 Docker 主机。当发生硬件故障时，我们可以从已知配置中在其他地方启动新的
    Docker 主机。如果我们想部署一个新的 Docker 容器版本，只需更新 Docker 主机的配置代码以指向新的镜像。配置管理使我们能够大规模管理 Docker
    部署。
- en: Using Chef
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Chef
- en: 'Chef is a configuration management tool that provides a domain-specific language
    to model the configuration of our infrastructure. Each configuration item in our
    infrastructure is modeled as a resource. A resource is basically a Ruby method
    that accepts several parameters in a block. The following example resource describes
    installing the `docker-engine` package:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 是一个配置管理工具，它提供了一种领域特定语言来建模我们基础设施的配置。我们基础设施中的每个配置项都被建模为一个资源。资源基本上是一个 Ruby
    方法，它接受一个代码块中的多个参数。以下示例资源描述了安装 `docker-engine` 包：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: These resources are then written together in Ruby source files called recipes.
    When running a recipe against a server (a Docker host in our case), all the defined
    resources are executed to reach its desired state configuration.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这些资源随后将一起写入 Ruby 源文件中，称为食谱（recipes）。当在服务器（在我们的案例中是 Docker 主机）上运行食谱时，所有定义的资源将被执行，以达到所需的状态配置。
- en: Some Chef recipes may depend on other supplemental items, such as configuration
    templates and other recipes. All this information is gathered in cookbooks together
    with the recipes. A cookbook is the fundamental unit of distributing configuration
    and policy to our servers.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些 Chef 食谱可能依赖于其他补充项目，如配置模板和其他食谱。所有这些信息都与食谱一起收集在烹饪书中。烹饪书是将配置和策略分发到我们服务器的基本单元。
- en: 'We will write Chef recipes to represent the desired state configuration of
    our Docker hosts. Our recipes will be organized in Chef cookbooks to distribute
    them to our infrastructure. However, first, let''s prepare our Chef environment
    so that we can start describing our Docker-based infrastructure in recipes. A
    Chef environment consists of three things:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将编写 Chef 食谱，以表示我们 Docker 主机的所需状态配置。我们的食谱将组织在 Chef 烹饪书中，并分发到我们的基础设施中。然而，首先，让我们准备我们的
    Chef 环境，以便开始用食谱描述基于 Docker 的基础设施。Chef 环境由三部分组成：
- en: A Chef server
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 Chef 服务器
- en: A workstation
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个工作站
- en: A node
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个节点
- en: The next few subsections will give you a detailed description of each component.
    Then, we will set them up to prepare our Chef environment to be able to manage
    our Docker host.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几个子章节将详细描述每个组件。然后，我们将设置它们以准备我们的 Chef 环境，以便管理我们的 Docker 主机。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are more details of setting up a Chef environment that are out of this
    chapter's scope. More information can be found at the Chef documentation website
    at [http://docs.chef.io](http://docs.chef.io).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 Chef 环境的更多细节超出了本章的范围。更多信息可以在 Chef 文档网站 [http://docs.chef.io](http://docs.chef.io)
    找到。
- en: Signing up for a Chef server
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册一个 Chef 服务器
- en: The Chef server is the central repository of cookbooks and other policy items
    governing our entire infrastructure. It contains metadata about the infrastructure
    that we are managing. In our case, the Chef server contains the cookbook, policy,
    and metadata on our Docker host.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Chef 服务器是烹饪书和其他治理我们整个基础设施的政策项的中央存储库。它包含关于我们所管理的基础设施的元数据。在我们的案例中，Chef 服务器包含了烹饪书、策略和关于我们的
    Docker 主机的元数据。
- en: 'To prepare a Chef server, we will simply sign up for a hosted Chef server.
    A free Chef server account allows us to manage up to five nodes in our infrastructure.
    Follow the next few steps to prepare a hosted Chef server account:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要准备一个Chef服务器，我们只需要注册一个托管的Chef服务器账户。免费的Chef服务器账户允许我们在基础架构中管理最多五个节点。请按照以下步骤准备一个托管的Chef服务器账户：
- en: Go to [https://manage.chef.io/signup](https://manage.chef.io/signup) and fill
    out the form for our account details as shown in the following screenshot:![Signing
    up for a Chef server](img/00007.jpeg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问[https://manage.chef.io/signup](https://manage.chef.io/signup)，并按照以下截图填写账户信息：![注册Chef服务器](img/00007.jpeg)
- en: After creating a user account, the hosted Chef server will now prompt us to
    create an organization. Organizations are simply used to manage role-based access
    control for our Chef server. Create an organization by providing the details on
    the form and click on the **Create Organization** button:![Signing up for a Chef
    server](img/00008.jpeg)
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用户账户后，托管的Chef服务器会提示我们创建一个组织。组织用于管理Chef服务器的基于角色的访问控制。通过填写表单中的详细信息并点击**创建组织**按钮来创建一个组织：![注册Chef服务器](img/00008.jpeg)
- en: We are now almost done getting our hosted Chef server account. Finally, click
    on **Download Starter Kit**. This will download a zip file containing our starter
    chef-repo. We will talk more about the chef-repo in the next section.![Signing
    up for a Chef server](img/00009.jpeg)
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了托管Chef服务器账户的创建。最后，点击**下载启动工具包**。这将下载一个包含我们启动chef-repo的zip文件。我们将在下一部分详细讨论chef-repo。![注册Chef服务器](img/00009.jpeg)
- en: Setting up our workstation
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置我们的工作站
- en: The second part of our Chef environment is the workstation. The workstation
    is used to interact with the Chef server. This is where we will do most of the
    preparation work and create the code to send to the Chef server. In our workstation,
    we will prepare the configuration items of our infrastructure in a Chef repository.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Chef环境的第二部分是工作站。工作站用于与Chef服务器进行交互。这是我们进行大部分准备工作并编写代码以发送到Chef服务器的地方。在工作站中，我们将准备基础架构的配置项，并将它们放入Chef仓库中。
- en: The Chef repository contains all the information needed to interact and synchronize
    with the Chef server. It contains the private key and other configuration files
    needed to authenticate and interact with the Chef server. These files will be
    found in the `.chef` directory of our Chef repository. It also contains the cookbooks
    that we will write and synchronize later with the Chef server in the `cookbooks/`
    directory. There are other files and directories inside a Chef repository, such
    as data bags, roles, and environments as well. However, it is enough for now to
    know about the cookbooks and authentication files to be able to configure our
    Docker host.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Chef仓库包含了与Chef服务器交互和同步所需的所有信息。它包含用于认证和与Chef服务器交互的私钥以及其他配置文件。这些文件将位于我们Chef仓库中的`.chef`目录下。它还包含我们稍后编写并与Chef服务器同步的食谱（cookbooks），这些文件位于`cookbooks/`目录下。Chef仓库中还有其他文件和目录，如数据包（data
    bags）、角色（roles）和环境（environments）等。不过，目前了解食谱和认证文件就足够了，它们可以帮助我们配置Docker主机。
- en: 'Do you remember that starter kit we downloaded in the previous section? Unzip
    this file to extract our chef-repo. We should have the following files described
    in the directory tree:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我们在上一部分下载的启动工具包吗？解压这个文件，提取我们的chef-repo。我们应该在目录树中看到以下文件：
- en: '![Setting up our workstation](img/00010.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的工作站](img/00010.jpeg)'
- en: Another important component in our workstation is the Chef development kit.
    It contains all the programs needed to read all the configuration in our chef-repo
    and interact with the Chef server. Convenient programs to create, develop, and
    test our cookbooks are also available in the Chef development kit. We will use
    various programs in the development kit throughout the rest of this chapter.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 工作站中的另一个重要组成部分是Chef开发工具包。它包含了所有必要的程序，帮助我们读取chef-repo中的所有配置并与Chef服务器进行交互。Chef开发工具包中还提供了创建、开发和测试食谱的便捷程序。我们将在本章的其余部分中使用开发工具包中的各种程序。
- en: Now, let's download the Chef development kit from [https://downloads.chef.io/chef-dk](https://downloads.chef.io/chef-dk)
    according to our workstation's platform.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，根据我们工作站的操作系统平台，从[https://downloads.chef.io/chef-dk](https://downloads.chef.io/chef-dk)下载Chef开发工具包。
- en: '![Setting up our workstation](img/00011.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![设置我们的工作站](img/00011.jpeg)'
- en: 'Next, open the downloaded installer. Install the Chef development kit according
    to the prompts from our platform. Finally, confirm that the installation was successful
    with the following commands:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，打开下载的安装程序。根据我们的平台提示安装Chef开发工具包。最后，通过以下命令确认安装成功：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that we have set up our workstation, let's go to our `chef-repo/` directory
    to prepare the last component of our Chef environment.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置好了工作站，接下来让我们进入`chef-repo/`目录，准备Chef环境的最后一个组件。
- en: Bootstrap nodes
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 启动节点
- en: The last part of our Chef environment is nodes. A node is any computer that
    is managed by Chef. It can be a physical machine, virtual machine, a server in
    the cloud, or a networking device. In our case, our Docker host is a node.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们Chef环境的最后一部分是节点。节点是任何由Chef管理的计算机。它可以是物理机器、虚拟机、云中的服务器或网络设备。在我们的案例中，我们的Docker主机就是一个节点。
- en: 'The central component for any node to be managed by Chef is the chef-client.
    It connects to the Chef server to download the necessary files to bring our node
    to its configuration state. When a chef-client is run on our node, it performs
    the following steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 任何节点被Chef管理的核心组件是chef-client。它连接到Chef服务器，下载必要的文件以将我们的节点带到其配置状态。当chef-client在我们的节点上运行时，它执行以下步骤：
- en: It registers and authenticates the node with the Chef server.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它将节点注册并认证到Chef服务器。
- en: It gathers system information in our node to create a node object.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它收集我们节点的系统信息以创建节点对象。
- en: Then, it synchronizes the Chef cookbooks needed by our node.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它同步我们节点所需的Chef食谱。
- en: It compiles the resources by loading our node's needed recipes.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过加载我们节点所需的配方来编译资源。
- en: Next, it executes all the resources and performs the corresponding actions to
    configure our node.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，它执行所有资源并执行相应的操作以配置我们的节点。
- en: Finally, it reports the result of the chef-client run back to the Chef server
    and other configured notification endpoints.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将chef-client运行的结果报告回Chef服务器以及其他已配置的通知端点。
- en: 'Now, let''s prepare our Docker host as a node by bootstrapping it from our
    workstation. The bootstrapping process installs and configures the chef-client.
    Run the following command to get this bootstrap process started:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过从工作站启动Docker主机来准备它作为一个节点。启动过程将安装并配置chef-client。运行以下命令开始启动过程：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can note in the preceding command, the bootstrapping process did two things.
    First, it installed and configured the chef-client on our Docker host node. Next,
    it started the chef-client to synchronize its desired state with our Chef server.
    As we haven't assigned any designed state yet to our Docker host, it didn't do
    anything.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们在前面的命令中所见，启动过程做了两件事。首先，它在我们的Docker主机节点上安装并配置了chef-client。接下来，它启动了chef-client以将其期望的状态与我们的Chef服务器进行同步。由于我们尚未为Docker主机分配任何设计状态，因此它没有执行任何操作。
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We can customize this bootstrap process according to our needs. More information
    on how to use `knife bootstrap` can be found at [http://docs.chef.io/knife_bootstrap.html](http://docs.chef.io/knife_bootstrap.html).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以根据需要定制此启动过程。关于如何使用`knife bootstrap`的更多信息，请参见[http://docs.chef.io/knife_bootstrap.html](http://docs.chef.io/knife_bootstrap.html)。
- en: In some cases, cloud providers have a deep Chef integration already out of the
    box. So, instead of `knife bootstrap`, we will just use the cloud provider's SDK.
    There, we just need to specify that we want to have Chef integrated. We will provide
    it with the information, such as the chef-client's `client.rb` configuration and
    validation keys' credentials.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，云服务提供商已经深度集成了Chef。因此，我们将不使用`knife bootstrap`，而是使用云服务提供商的SDK。在那里，我们只需指定希望集成Chef即可。我们将为其提供必要的信息，如chef-client的`client.rb`配置和验证密钥的凭据。
- en: 'Our Docker host is now properly registered to the Chef server, ready to grab
    its configuration. Go to [https://manage.chef.io/organizations/dockerorg/nodes/dockerhost](https://manage.chef.io/organizations/dockerorg/nodes/dockerhost)
    to check our Docker host as a node in our Chef environment, as shown in the following
    screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的Docker主机现在已正确注册到Chef服务器，准备获取其配置。请访问[https://manage.chef.io/organizations/dockerorg/nodes/dockerhost](https://manage.chef.io/organizations/dockerorg/nodes/dockerhost)查看我们的Docker主机作为Chef环境中的一个节点，如下图所示：
- en: '![Bootstrap nodes](img/00012.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![Bootstrap节点](img/00012.jpeg)'
- en: Configuring the Docker host
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置Docker主机
- en: Now that we have all the components of our Chef environment properly set up,
    we can now start writing Chef recipes to actually describe what configuration
    our Docker host should have. In addition, we will leapfrog our productivity by
    taking advantage of existing Chef cookbooks in the Chef ecosystem. As Docker is
    a popular infrastructure stack to deploy, we can use cookbooks in the wild that
    allow us to configure our Docker hosts. Chef cookbooks provided by the community
    can be found in the Chef supermarket. We can go to [http://supermarket.chef.io](http://supermarket.chef.io)
    to discover other cookbooks that we can readily use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经正确设置了所有 Chef 环境组件，可以开始编写 Chef 配方，实际描述我们的 Docker 主机应该具备什么样的配置。此外，我们将通过利用
    Chef 生态系统中现有的 Chef 烹饪书来提升我们的生产力。由于 Docker 是一个流行的基础设施堆栈，用于部署容器，我们可以使用一些现成的烹饪书来配置我们的
    Docker 主机。社区提供的 Chef 烹饪书可以在 Chef 超市中找到。我们可以访问[http://supermarket.chef.io](http://supermarket.chef.io)来发现其他可以直接使用的烹饪书。
- en: 'In this section, you will learn how to write Chef recipes and apply it to our
    node. Follow the next few steps to write the recipe for our Docker host:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何编写 Chef 配方并将其应用于我们的节点。请按照以下步骤为我们的 Docker 主机编写配方：
- en: 'Use the Chef development kit''s `chef generate cookbook` command to generate
    a boilerplate for our cookbook. After entering the cookbooks directory, issue
    the following command:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Chef 开发工具包的 `chef generate cookbook` 命令来生成我们烹饪书的样板文件。在进入烹饪书目录后，发出以下命令：
- en: '[PRE3]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The boilerplate cookbook directory structure will look similar to the following
    screenshot:'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 标准的烹饪书目录结构将类似于以下截图：
- en: '![Configuring the Docker host](img/00013.jpeg)'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![配置 Docker 主机](img/00013.jpeg)'
- en: 'Next, we will prepare to edit our cookbook. Change our working directory to
    the cookbook we created earlier using the following command:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将准备编辑我们的烹饪书。通过以下命令将工作目录更改为我们之前创建的烹饪书所在的目录：
- en: '[PRE4]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Install the following cookbooks from the Chef supermarket as dependencies:
    `apt` and `docker`. These cookbooks provide additional resource definitions that
    can be used in our recipes. We will use them later as building blocks to set up
    our Docker host. To add the dependencies, update the `metadata.rb` file, as follows:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 Chef 超市安装以下烹饪书作为依赖项：`apt` 和 `docker`。这些烹饪书提供了可以在我们的配方中使用的额外资源定义。稍后我们将使用它们作为构建块来设置我们的
    Docker 主机。要添加依赖项，请更新 `metadata.rb` 文件，如下所示：
- en: '[PRE5]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `metadata.rb` file provides metadata about our Chef cookbooks. The information
    in the metadata provides hints to the Chef server so that the cookbook can be
    properly deployed to our nodes. For more information on how to configure metadata
    to our Chef cookbooks, visit [http://docs.chef.io/config_rb_metadata.html](http://docs.chef.io/config_rb_metadata.html).
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`metadata.rb` 文件提供有关我们的 Chef 烹饪书的元数据。元数据中的信息为 Chef 服务器提供提示，以便烹饪书可以正确部署到我们的节点。有关如何配置
    Chef 烹饪书的元数据，请访问[http://docs.chef.io/config_rb_metadata.html](http://docs.chef.io/config_rb_metadata.html)。'
- en: 'Now that we have our dependencies declared, we can download them by issuing
    the following command:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经声明了依赖关系，可以通过发出以下命令来下载它们：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Finally, we will write the Chef recipe equivalent to the installation instructions
    found at [http://blog.docker.com/2015/07/new-apt-and-yum-repos](http://blog.docker.com/2015/07/new-apt-and-yum-repos).
    We will use the `apt_repository` resource provided by the **apt** dependency cookbook
    we added earlier. Then, add the following lines to `recipes/default.rb`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将编写与[http://blog.docker.com/2015/07/new-apt-and-yum-repos](http://blog.docker.com/2015/07/new-apt-and-yum-repos)中找到的安装说明等效的
    Chef 配方。我们将使用之前添加的**apt** 依赖烹饪书提供的 `apt_repository` 资源。然后，将以下内容添加到 `recipes/default.rb`
    文件中：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, we are done preparing our `dockerhost/` Chef cookbook. The final step
    is to apply it to our Docker host so that it can pick its desired configuration.
    Follow the next remaining steps to perform this:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经完成了 `dockerhost/` Chef 烹饪书的准备工作。最后一步是将其应用于我们的 Docker 主机，以便它可以选择所需的配置。请按照以下剩余步骤进行操作：
- en: 'First, upload the Chef cookbook to our Chef server. Note that in the output
    of the following command, the `apt` and `docker` cookbooks that we depend on will
    also be automatically uploaded:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将 Chef 烹饪书上传到我们的 Chef 服务器。请注意，在以下命令的输出中，我们依赖的 `apt` 和 `docker` 烹饪书也会自动上传：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, apply the `dockerhost` recipe we wrote earlier to the node (that is,
    the Docker host) by setting its `run_list` via the following command:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过设置其 `run_list` 来将我们之前编写的 `dockerhost` 配方应用于节点（即 Docker 主机），使用以下命令：
- en: '[PRE9]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, run the chef-client in `dockerhost`. The chef-client will fetch the
    Docker host''s node object and apply the desired state configuration we applied
    in the previous steps, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `dockerhost` 上运行 chef-client。chef-client 将获取 Docker 主机的节点对象，并应用我们在前面步骤中所设置的期望状态配置，如下所示：
- en: '[PRE10]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, we have Docker installed and configured in our Docker host using Chef.
    Whenever we need to add another Docker host, we can just create another server
    in our cloud provider and bootstrap it to have the `dockerhost` Chef recipe written
    earlier. When we want to update how the Docker daemons are configured in all our
    Docker hosts, we will just update the Chef cookbook and rerun the chef-client.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经通过 Chef 在 Docker 主机上安装并配置了 Docker。每当我们需要添加另一个 Docker 主机时，只需在云服务提供商中创建另一个服务器，并使用之前编写的
    `dockerhost` Chef 配方进行初始化配置。当我们想要更新所有 Docker 主机中 Docker 守护进程的配置时，只需更新 Chef cookbook
    并重新运行 chef-client。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: In a production environment, the goal of having configuration management software
    installed in our Docker host is to never have the need to log in to it just to
    perform configuration updates. Running the chef-client manually is only half the
    automation.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中，安装配置管理软件的目的是让我们的 Docker 主机无需登录即可进行配置更新。手动运行 chef-client 只是自动化的一半。
- en: We will want to run the chef-client as a daemon process so that we don't have
    to run it every time we perform an update. The chef-client daemon will poll the
    Chef server to check whether there are any updates to the node it is managing.
    By default, this polling interval is set to 30 minutes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望将 chef-client 作为守护进程运行，这样我们就不必每次执行更新时都运行它。chef-client 守护进程将定期轮询 Chef 服务器，检查是否有任何更新需要应用到它所管理的节点。默认情况下，轮询间隔设置为
    30 分钟。
- en: For more information on how to configure the chef-client as a daemon, refer
    to the Chef documentation at [https://docs.chef.io/chef_client.html](https://docs.chef.io/chef_client.html).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有关如何将 chef-client 配置为守护进程的更多信息，请参阅 Chef 文档：[https://docs.chef.io/chef_client.html](https://docs.chef.io/chef_client.html)。
- en: Deploying Docker containers
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署 Docker 容器
- en: The next step to manage Docker in scale is to deploy Docker containers to our
    pool of Docker hosts automatically. By now, we have built a few Docker applications
    already. We have a rough architectural sketch of how these containers communicate
    with and consume each other. Chef recipes can be used to represent this architectural
    topology in code, which is essential to managing our whole application and infrastructure
    in scale. We can identify which Docker containers need to run and know how each
    container connects with other containers. We can locate where our Docker containers
    should be deployed. Having the whole architecture in code allows us to place an
    orchestration strategy for our application.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 管理大规模 Docker 的下一步是自动化将 Docker 容器部署到我们的 Docker 主机池。到目前为止，我们已经构建了一些 Docker 应用程序，并且大致了解这些容器如何相互通信并相互消费。Chef
    配方可以用来在代码中表示这种架构拓扑，这对于大规模管理我们的整个应用程序和基础设施至关重要。我们可以识别出需要运行的 Docker 容器，并了解每个容器如何与其他容器连接。我们可以确定
    Docker 容器的部署位置。将整个架构用代码表示，可以为我们的应用程序制定编排策略。
- en: 'In this section, we will create a Chef recipe to orchestrate the deployment
    of the Nginx Docker image to our Docker host. We will use the Chef resources provided
    by the `docker` cookbook we added in the previous section to configure our Docker
    host. Follow the next few steps to perform the deployment:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个 Chef 配方，用于编排将 Nginx Docker 镜像部署到我们的 Docker 主机。我们将使用在上一节中添加的 `docker`
    cookbook 提供的 Chef 资源来配置我们的 Docker 主机。请按照以下步骤进行部署：
- en: 'To begin, create the Chef recipe that we will work on. The following command
    will create the `recipes/containers.rb` recipe file in our `dockerhost/` cookbook:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建我们将要使用的 Chef 配方。以下命令将在我们的 `dockerhost/` cookbook 中创建 `recipes/containers.rb`
    配方文件：
- en: '[PRE11]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Next, pull the official Nginx Docker image at [https://registry.hub.docker.com/_/nginx](https://registry.hub.docker.com/_/nginx)
    to our Docker host. Write the following code in `recipes/containers.rb`:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将官方 Nginx Docker 镜像从 [https://registry.hub.docker.com/_/nginx](https://registry.hub.docker.com/_/nginx)
    拉取到我们的 Docker 主机。请在 `recipes/containers.rb` 中编写以下代码：
- en: '[PRE12]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'After downloading the Docker image, configure the Docker host to run the container.
    As of version 0.40.3 of the `docker` cookbook, we need to specify that our Debian
    Jessie Docker host deployment uses `systemd` as its `init` system. Add the following
    lines to the `recipes/containers.rb` as well:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下载Docker镜像后，配置Docker主机以运行容器。从`docker`菜谱的版本0.40.3开始，我们需要指定我们的Debian Jessie Docker主机部署使用`systemd`作为其`init`系统。还需要将以下内容添加到`recipes/containers.rb`中：
- en: '[PRE13]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `docker_container` and `docker_image` has several other options that we
    can tune to specify what we want to do with our container. The `docker` cookbook
    also has other resources to work with our Docker hosts. More information on options
    and further usage can be found on its project page at [https://github.com/bflad/chef-docker](https://github.com/bflad/chef-docker).
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`docker_container`和`docker_image`有其他一些选项，我们可以调整这些选项来指定我们想对容器执行的操作。`docker`菜谱还包含其他资源，可以与我们的Docker主机进行交互。有关选项和进一步使用的信息，可以在其项目页面[https://github.com/bflad/chef-docker](https://github.com/bflad/chef-docker)找到。'
- en: 'Next, we will prepare the new version of our cookbook for release. Bump the
    version information in `metadata.rb` to do this, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为发布准备新版本的菜谱。为此，请在`metadata.rb`中更新版本信息，具体如下：
- en: '[PRE14]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Update the `Berksfile.lock` file to pin the versions of all the cookbooks we
    will upload to the Chef server in the next step. Type the following command to
    perform the update:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`Berksfile.lock`文件，以固定我们将在下一步上传到Chef服务器的所有菜谱的版本。输入以下命令以执行更新：
- en: '[PRE15]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now that all the artifacts for our new cookbook are ready, we will type the
    following command to upload the updated cookbook to our Chef server. Note how
    the berks upload command automatically recognizes that only the `dockerhost` cookbook
    needs updating as it skips uploading the `apt` and `docker` cookbooks:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们的新菜谱的所有工件已经准备好，我们将输入以下命令将更新后的菜谱上传到我们的Chef服务器。请注意，`berks upload`命令会自动识别出只有`dockerhost`菜谱需要更新，并跳过上传`apt`和`docker`菜谱：
- en: '[PRE16]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, add the `recipes/containers.rb` to the run list of our Docker host. Type
    the following command to update the node representing our Docker host:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`recipes/containers.rb`添加到Docker主机的运行列表中。输入以下命令以更新表示Docker主机的节点：
- en: '[PRE17]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, rerun the chef-client to pick up the new configuration for our Docker
    host. We can also wait for the rerun of the chef-client if we configure the chef-client
    to run as a daemon process. Execute the following command:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，重新运行chef-client以获取Docker主机的新配置。如果我们将chef-client配置为以守护进程方式运行，我们也可以等待chef-client的重新运行。执行以下命令：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We now have our Docker host running the nginx Docker container. We can confirm
    that it is working by going to `http://dockerhost`. We should be able to get the
    following page in the screenshot:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经让Docker主机运行了nginx Docker容器。我们可以通过访问`http://dockerhost`来确认它是否正常工作。我们应该能够看到如下图所示的页面：
- en: '![Deploying Docker containers](img/00014.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![部署Docker容器](img/00014.jpeg)'
- en: Alternative methods
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他方法
- en: 'There are other general-purpose configuration management tools that allow us
    to configure our Docker host. The following is a short list of the other tools
    that we can use:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他通用的配置管理工具，可以配置我们的Docker主机。以下是我们可以使用的其他工具的简短列表：
- en: '**Puppet**: Refer to [http://puppetlabs.com](http://puppetlabs.com).'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Puppet**：请参阅[http://puppetlabs.com](http://puppetlabs.com)。'
- en: '**Ansible**: This can be found at [http://ansible.com](http://ansible.com).'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Ansible**：可以在[http://ansible.com](http://ansible.com)找到。'
- en: '**CFEngine**: This is available at [http://cfengine.com](http://cfengine.com).'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CFEngine**：可以在[http://cfengine.com](http://cfengine.com)找到。'
- en: '**SaltStack**: You can find more on this at [http://saltstack.com](http://saltstack.com).'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SaltStack**：可以在[http://saltstack.com](http://saltstack.com)找到更多信息。'
- en: '**The Docker machine**: This is a very specific configuration management tool
    that allows us to provision and configure Docker hosts in our infrastructure.
    More information about Docker machine can be found on the Docker documentation
    page at [https://docs.docker.com/machine](https://docs.docker.com/machine).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker机器**：这是一个非常特定的配置管理工具，允许我们在基础设施中配置和管理Docker主机。有关Docker机器的更多信息，请参阅Docker文档页面[https://docs.docker.com/machine](https://docs.docker.com/machine)。'
- en: 'If we do not want to manage our Docker host infrastructure at all, we can use
    Docker hosting services. Popular cloud providers started offering Docker hosts
    as a preprovisioned cloud image that we can use. Others offer a more comprehensive
    solution that allows us to interact with all the Docker hosts in the cloud as
    a single virtual Docker host. The following is a list of links of the popular
    cloud providers describing their integration with the Docker ecosystem:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想管理 Docker 主机基础设施，我们可以使用 Docker 托管服务。流行的云服务提供商已经开始提供作为预配置云镜像的 Docker 主机，我们可以使用它们。其他提供商则提供更全面的解决方案，让我们能够将所有云中的
    Docker 主机当作一个虚拟 Docker 主机来交互。以下是一些流行的云服务提供商及其与 Docker 生态系统集成的链接：
- en: Google Container Engine ([https://cloud.google.com/container-engine](https://cloud.google.com/container-engine))
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Container Engine ([https://cloud.google.com/container-engine](https://cloud.google.com/container-engine))
- en: Amazon EC2 Container Service ([http://aws.amazon.com/documentation/ecs](http://aws.amazon.com/documentation/ecs))
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Amazon EC2 容器服务 ([http://aws.amazon.com/documentation/ecs](http://aws.amazon.com/documentation/ecs))
- en: Azure Docker VM Extension ([https://github.com/Azure/azure-docker-extension](https://github.com/Azure/azure-docker-extension))
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure Docker VM 扩展 ([https://github.com/Azure/azure-docker-extension](https://github.com/Azure/azure-docker-extension))
- en: Joyent Elastic Container Service ([https://www.joyent.com/public-cloud](https://www.joyent.com/public-cloud))
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joyent 弹性容器服务 ([https://www.joyent.com/public-cloud](https://www.joyent.com/public-cloud))
- en: 'In terms of deploying Docker containers, there are several container tools
    that allow you to do this. They provide APIs to run and deploy our Docker containers.
    Some of the offered APIs are even compatible with the Docker engine itself. This
    allows us to interact with our pool of Docker hosts as if it is a single virtual
    Docker host. The following is a list of a few tools that allow us to orchestrate
    the deployment of our containers to a pool of Docker hosts:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署 Docker 容器方面，有几种容器工具可以帮助我们实现这一目标。它们提供 API 来运行和部署我们的 Docker 容器。某些提供的 API 甚至与
    Docker 引擎本身兼容。这让我们可以像操作一个虚拟 Docker 主机一样与 Docker 主机池进行交互。以下是一些可以帮助我们协调容器部署到 Docker
    主机池的工具：
- en: Docker Swarm ([https://www.docker.com/docker-swarm](https://www.docker.com/docker-swarm))
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Docker Swarm ([https://www.docker.com/docker-swarm](https://www.docker.com/docker-swarm))
- en: Google Kubernetes ([http://kubernetes.io](http://kubernetes.io))
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Kubernetes ([http://kubernetes.io](http://kubernetes.io))
- en: CoreOS fleet ([https://coreos.com/fleet](https://coreos.com/fleet))
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CoreOS fleet ([https://coreos.com/fleet](https://coreos.com/fleet))
- en: Mesophere Marathon ([https://mesosphere.github.io/marathon](https://mesosphere.github.io/marathon))
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Mesophere Marathon ([https://mesosphere.github.io/marathon](https://mesosphere.github.io/marathon))
- en: SmartDataCenter Docker Engine ([https://github.com/joyent/sdc-docker](https://github.com/joyent/sdc-docker))
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SmartDataCenter Docker 引擎 ([https://github.com/joyent/sdc-docker](https://github.com/joyent/sdc-docker))
- en: However, we still need configuration management tools such as Chef to deploy
    and configure our orchestration systems at the top of our pool of Docker hosts.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们仍然需要像 Chef 这样的配置管理工具来部署和配置我们的编排系统，以管理我们 Docker 主机池之上的系统。
- en: Summary
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we learned how to automate the configuration of our Docker
    deployments. Using Chef allows us to configure and provision multiple Docker hosts
    in scale. It also enabled us to deploy and orchestrate Docker containers for our
    application to our pool of Docker hosts. From this point on, you can write Chef
    recipes to persist all the Docker optimization techniques you will learn in this
    book.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何自动化配置我们的 Docker 部署。使用 Chef 使我们能够配置和提供多个 Docker 主机的规模。它还使我们能够为应用程序部署并协调
    Docker 容器到我们的 Docker 主机池。从此以后，你可以编写 Chef 配方来保持本书中你将学习到的所有 Docker 优化技术。
- en: In the next chapter, we will introduce instrumentation to monitor our whole
    Docker infrastructure and application. This will give us further feedback on how
    to better optimize our Docker deployments for higher performance.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍如何对整个 Docker 基础设施和应用程序进行监控。这将帮助我们进一步了解如何优化 Docker 部署，以提高性能。
