- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and Consuming Collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you were familiar with Ansible releases before 2.9, so far, much of this
    book will have looked very familiar to you. If you’re a newcomer to the world
    of Ansible automation, then, of course, all of this will look new and shiny. Regardless
    of your experience with Ansible to date, no book on this would be complete without
    an in-depth look at collections. Collections are the solution to the problems
    that started to manifest as a result of Ansible’s own popularity and success,
    and they are now at the heart of every modern Ansible installation. Whether you
    realized it or not, you’ve been working with them throughout this book so far,
    and they are here to stay, so it benefits us to take a deep dive into them.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore collections in depth, looking in more detail
    at the problem that they solve and how they came about, before taking a more technical
    look at their structure and makeup. We will conclude the chapter with a hands-on
    example of creating your own collection so that you have a solid understanding
    of how they are created, built, maintained, and used. As a result, you will be
    able to work with this powerful new addition to Ansible with ease and take advantage
    of collections in your own automation solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Ansible collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding fully qualified collection names
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing collections on your control node
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating your Ansible collections and core installation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating your own collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started
    with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 8.0 and `ansible-core` 2.15\. This chapter
    also assumes that you have at least one additional host to test against, and this
    should be Linux-based. Although we will give specific examples of hostnames in
    this chapter, you are free to substitute them with your own hostnames and/or IP
    addresses, and details of how to do this will be provided in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code bundle for this chapter is available here: https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter
    6'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Ansible collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we’ve mentioned some of this earlier in this book, our goal is for
    this to be a complete one-stop source of information for collections – thus, if
    you’ve skipped directly to this chapter, don’t worry – we’ve got you covered.
    Let’s start with some history as this is important to understand the intention
    behind collections.
  prefs: []
  type: TYPE_NORMAL
- en: With Ansible releases prior to 2.9, everything was managed in one huge monolithic
    code base. While the core Ansible team owned this code base, the modules that
    really form the lifeblood of Ansible (after all, they are what enable it to automate
    so many disparate systems with ease) were not. Let’s say a network device vendor
    wanted to release a new module. Perhaps they added a new feature or fixed a bug
    in a prior release. They would have to make these changes, test them, and then
    submit them as a pull request to the main Ansible repository – not only is this
    a significant undertaking, depending on the number of **Pull Requests** (**PRs**)
    and amount of code to be merged, but it can also take a long time, slowing down
    release cycles.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the owners of the repository would have to merge the code, test
    it themselves, and perform a release. This way of working was fine in the early
    days of Ansible, but as its adoption got greater, it became impossible to scale
    in this manner. Imagine that a large enterprise user of Ansible has a problem
    with an Ansible module and they need a fix now, or perhaps the vendor has an exciting
    new launch coming up and they want Ansible support from day one. Neither of these
    was possible with this way of working. Coupled with the fact that Ansible 2.8
    had thousands of modules, the task of managing Ansible code became an unenviable
    task.
  prefs: []
  type: TYPE_NORMAL
- en: This assumes, of course, that code was eligible to be integrated into the main
    code base. If something was confidential in nature, or needed distributing in
    a hurry to fix a problem, then there was no easy way to integrate it into the
    Ansible installation (to be clear, there were methods, but they were not as simple
    and straightforward as collections have made this process).
  prefs: []
  type: TYPE_NORMAL
- en: 'It was out of these needs that collections were born. In brief, collections
    empower individual teams and vendors to develop, test, and release contributions
    to Ansible at their own pace, and independent of the release cycle of the core
    Ansible code. To be specific, collections provide a mechanism to package and distribute
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As with all aspects of Ansible, the design of collections is simple and easy
    to work with. A collection is simply a set of directories containing the files
    that contain the required functionality. These are then packaged up into a gzipped
    tarball (a well-known and understood file format) for easy distribution. Collections
    can be installed and managed locally (as we shall see later, in the *Managing
    collections on your control node* section) and via Ansible Galaxy ([https://galaxy.ansible.com](https://galaxy.ansible.com)).
  prefs: []
  type: TYPE_NORMAL
- en: Anyone familiar with Ansible from its pre-collection days will know that roles
    were distributed via Ansible Galaxy and were easy to manage using the `ansible-galaxy`
    command-line utility. Thus, a valid question might be, if you develop your own
    role, should you distribute it as a role, or a role contained within a collection?
    After all, both are currently viable solutions, and both can be distributed via
    Ansible Galaxy. Although both routes are entirely possible at this time, it is
    the opinion of the author that, in time, roles will be distributed as collections,
    as these offer much greater scope for expansion – for example, if you need to
    develop a plugin to extend the capabilities of your role, then you can add this
    to the collection you have already created. On the other hand, distributing the
    role as is would necessitate a later migration to a collection, and thus, you
    future-proof your code by packaging it as a collection in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: It is very easy for developers, vendors, and enterprises to build their Ansible
    functionality into collections for packaging and distribution. They can then contribute
    this back to the community if they so desire (and in the spirit of open source
    software, this is certainly the goal), but if they contain confidential information,
    they are just as easy to host and maintain in an internal repository.
  prefs: []
  type: TYPE_NORMAL
- en: With this introduction complete, you have gained a good idea of what a collection
    is and its intended purpose. We will now proceed in the next section of this chapter
    to begin a look at the practical aspects of creating and consuming collections
    to further your understanding.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding fully qualified collection names
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before collections existed, every module that was created and contributed to
    Ansible had to have a unique name. Thus, it was very common to see modules named
    like this (both were taken from the Ansible 2.8 release):'
  prefs: []
  type: TYPE_NORMAL
- en: '`ios_bgp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eos_bgp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fortios_router_bgp`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All three of these modules are to modify the `bgp` to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Ensure their names are unique
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure Ansible coders can understand what their code does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collections remove the need for unique module names, so it is now possible for
    contributors to create modules with names that overlap. This is valuable because
    it removes the need for such long and verbose module names, but it creates the
    risk of unexpected code behavior. For example, we often use the `debug` module
    to understand what our playbook code does and print something out during the execution.
    It would be entirely possible for us to create our own collection with a module
    called `debug`, which does something slightly (or entirely) different. Imagine
    the confusion that would result if your playbook performed differently on different
    control nodes, or didn’t work at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is for this reason that throughout this book, in earlier versions of Ansible
    code, you would be used to seeing code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This still works in Ansible today (you are welcome to test this!), and support
    for short-form module names has been retained for backward compatibility so that
    any legacy code that you have can be run. While this is valuable in empowering
    users to upgrade their Ansible code at their own pace without needing multiple
    versions of Ansible on the control node, the risk of unexpected behavior due to
    a module name clash is not insignificant, so it is important to start using fully
    qualified collection names as soon as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, in place of the previously provided example code, we would now
    write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The functionality of this code is identical, but the risk of module name clash
    is now removed because the fully qualified collection name has been specified.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a **Fully Qualified Collection Name** (**FQCN**) though? The best way
    to explain this is to break it down into its component parts, which look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Let’s start with the namespace – this is a unique namespace used to identify
    the developer of the collections. This might be your name if you are an individual
    developer, or the name of a company if you are contributing to a vendor. All namespaces
    must be unique, and this is reasonable as a limitation – when you look on Ansible
    Galaxy, you want to know that modules with the `cisco` namespace are all managed
    by Cisco, and thus, you can be certain of who owns and manages the code. Similarly,
    the `ansible` namespace (from which we make use of `ansible.builtin.debug`) is
    owned and managed by the Ansible project itself.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it’s also safe to assume that each namespace will have one or more collections.
    It makes sense for collections to be divided up by functionality; otherwise, we
    head back to the problems of monolithic code base management we discussed earlier
    in this chapter. For example, within the `cisco` namespace, there is an `ios`
    collection to manage Cisco IOS devices and a separate `asa` collection to manage
    their `asa`, but I could not put it in the `cisco` namespace on Ansible Galaxy.
  prefs: []
  type: TYPE_NORMAL
- en: The third and final part of the FQCN is the module name itself. This serves
    the same function as it always has in Ansible and must be unique within a collection.
    We have already used modules a number of times in this book, and we will continue
    to do so; thus, we will assume here that you are happy with the concept of an
    Ansible module.
  prefs: []
  type: TYPE_NORMAL
- en: Putting this all together, whereas in Ansible 2.8 (or earlier) you would have
    used the `ios_bgp` module for BGP configuration on a Cisco IOS device, the FQCN
    for this module is now `cisco.ios.ios_bgp`. A valid question you may be asking
    about this FQCN is, why, given the unique namespace and collection name within
    it, is the module still called `ios_bgp` and not simply `bgp`? The answer lies
    in backward compatibility – Ansible 8.0 still supports playbooks written for 2.8
    and earlier and, as such, still supports module names that are not fully qualified.
    Thus, if Cisco changed the module name to `bgp`, they would break backward compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: Despite this backward compatibility functionality, it is important to start
    making friends with FQCNs as soon as possible. Module names must be unique within
    a collection, but that is the only limitation. There is nothing to stop me from
    creating my own module called `ios_bgp`, in my own `ios` collection, and calling
    it something like `practicalansible.ios.ios_bgp`. In this instance, you could
    not guarantee which module you were calling if you only specified the module by
    the name `ios_bgp` in your playbooks and roles, and as such, it is vital to use
    FQCNs to make sure you don’t come across any unexpected or erroneous behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Although these concepts relating to FQCNs are simple, they are foundational
    knowledge, and we will rely on this understanding as we proceed through this chapter,
    so it is important that we get them out of the way early on. Now that we’ve achieved
    this, we’ll look in the next section at how to manage collections on your control
    node.
  prefs: []
  type: TYPE_NORMAL
- en: Managing collections on your control node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting
    Started with Ansible*, when you install Ansible, it actually installs a set of
    collections, providing equivalent functionality to the latest 2.x release so that
    backward compatibility is maintained (alongside `ansible-core`, of course). This
    process is invisible to the user, and this accompanying collection set also gets
    updated as you update your Ansible installation.
  prefs: []
  type: TYPE_NORMAL
- en: Given this, you could be forgiven for wondering why you need to learn about
    managing collections at all – after all, Ansible comes with a huge set by default,
    and the collections get updated as you update your installation. Yet this is the
    beauty of collections – if they do exactly what you need to do, then you need
    to take further action. In contrast, if you actually do need to extend the functionality
    of your Ansible control node, you can do just that – the power lies in the choice
    and flexibility, just as it always has with Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: To help us understand the management of our collections, let’s start by looking
    at the locations in which they get installed. Like everything in Ansible, the
    paths in which collections get installed are configurable, and you can install
    collections wherever you like (provided you’ve set the correct setting of course).
  prefs: []
  type: TYPE_NORMAL
- en: 'If we log into our demo node, where I installed Ansible under my local user
    account using `pip3`, I can query the Ansible collection paths as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'What you can see here is that the `COLLECTIONS_PATHS` environment variable
    is not set (denoted by `(default)` displayed in the output), and thus, it has
    defaulted to two known locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`~/.``ansible/collections`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/``usr/share/ansible/collections`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The collections paths are searched in the order specified, so the location
    under my home directory will be searched prior to the path under `/usr/share`.
    You can set the location for your collections by setting the environment variable
    we just queried previously, or you can create an entry in your `ansible.cfg` file
    in the `[default]` section, using the `collections_paths` key. Please refer to
    this link for more information: [https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths](https://docs.ansible.com/ansible/latest/reference_appendices/config.xhtml#collections-paths).'
  prefs: []
  type: TYPE_NORMAL
- en: 'On my demo node, I have not performed any work on collections so far, and as
    a result, if I try to list the previous paths, I will find that neither of them
    exists. Nonetheless, let’s try and install the `gns3` collection from user `davidban77`
    and see what happens ([https://galaxy.ansible.com/davidban77/gns3](https://galaxy.ansible.com/davidban77/gns3)):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that the collection was installed successfully, and the `ansible-galaxy`
    tool even tells us helpfully where it was installed. However, note that it was
    installed only for my local user account, so if another user on this box wants
    to make use of this collection, they must install their own copy. This is fine,
    but it risks creating issues further down the road if they install a different
    version (which might happen because they install the same collection but later
    on, after an update has been made).
  prefs: []
  type: TYPE_NORMAL
- en: 'However, we can get around this. The first way is to install the collection(s)
    you need centrally so that all users can access them. We know that, by default,
    the `COLLECTIONS_PATHS` variable will search `/usr/share/ansible/collections`,
    and this will be accessible to all users, so any collections that need to be available
    globally can be installed here. The path won’t exist by default, but you can easily
    create it and install the collection here by running the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `chmod` command used is a blunt-force method to grant all users
    access to install collections in this shared directory. It is recommended that
    you set up suitable access controls to this directory as is appropriate for your
    environment, but as this will differ in every scenario, this is left as an exercise
    for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: What you will notice now is that we added the `-p` flag to the command we ran
    before, telling `ansible-galaxy` to install our collection in a different location
    than the default (which is the first entry in the `COLLECTIONS_PATHS` variable).
    As such, we have successfully installed the collection in a central location for
    all users to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can validate this using the following command (output truncated for readability):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note how the output of this command lists the collections in each of its known
    locations, which includes all paths listed by the `COLLECTIONS_PATHS` variable,
    and also the install location of Ansible (which is included first and is implicit
    in the configuration – you do not need to specify this).
  prefs: []
  type: TYPE_NORMAL
- en: 'There is no uninstall option when it comes to collections, but the beauty of
    Ansible has always been in its simplicity, and collections, like roles, are simply
    a set of directories and files in a known structure (there’ll be more on this
    later in the chapter). As a result, if we wanted to uninstall the centrally available
    `davidban77.gns3` collection, you would simply run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If you rerun the collection listing, you’ll see that this collection no longer
    appears in the output. What happens if you want to install a specific version
    of a collection though? Well, say you wanted to install the `1.4.0` release of
    the collection we’ve been testing with – you would simply run this command to
    install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have successfully installed version `1.4.0` of this collection, and
    it has overwritten version `1.5.0`, which we installed earlier. Upgrading collections
    is as simple as either specifying the latest version in place of the earlier one
    we used previously, or forcing a reinstallation (which, by its very nature, installs
    the latest version of the collection):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can even specify version ranges – if, for example, we’ve established we
    need to use a version of this collection newer than the `1.2.0` release, but older
    than the `1.5.0` release, we can run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, the latest version within the range we specified has been installed –
    a very useful and powerful feature to maintain dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This discussion on installing and maintaining collection versions brings us
    neatly back to our original concern – how to ensure users are all installing the
    correct version of collections required (or sanctioned) for playbook development.
    We’ve established that you can install collections centrally, and this is certainly
    one viable route. However, this method breaks down as soon as someone starts developing
    and/or running playbooks on another machine. It is clear then that a different
    method will be required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thankfully, the `ansible-galaxy` command also supports working with requirements
    files – these are simply a list of the required collections (and versions) that
    you need to have installed, and as they are simple text files, they can be committed
    to source control along with all your other automation code. Then, all the people
    involved in your playbook need to do is run a single command to install the required
    collection, and they can then proceed with development and/or running the playbooks
    with the confidence that they have the correct collections installed, and with
    the correct versions. Let’s add one more collection to the previous example and
    create a file called `requirements.yml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In this file, we state that we need the `davidban77.gns3` collection with the
    version constraints we tested earlier, and also the `marmorag.ansodium` collection.
    You can see that we omitted the `name:` key with the second collection – this
    is only required if you specify additional parameters such as `version:`; thus,
    a useful shorthand if you don’t need this is to simply create a list of collection
    names. Once you have this file, you can ensure the collections meet the stated
    requirements by running the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that the requirements for the `davidban77.gns3` collection
    were already met, so no further action was taken. However, the `marmorag.ansodium`
    collection, which we didn’t previously install, now gets installed.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, all the collections we are working from here are publicly available
    at [https://galaxy.ansible.com](https://galaxy.ansible.com) – however, it is important
    to note that you can also specify your own server or even a local tarball to install
    collections with, and we shall see examples of the latter in action later in the
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes our look at managing collections on your control node, and armed
    with this information, you should be able to set up a consistent environment for
    all your automation needs. In the next section, we will look at a subtle variation
    on this theme – how to update the collections that were installed at the time
    you installed the Ansible package.
  prefs: []
  type: TYPE_NORMAL
- en: Updating your Ansible collections and core installation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may very well be asking what happens to the collections you installed at
    the time of installing Ansible – how do you maintain or upgrade them? Naturally,
    one way is to wait for the next release of the `ansible` package, and then upgrade
    it with `pip` – however, this is a brute-force method and may not provide you
    with the results you are looking for. Let’s take a more fine-grained approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you want to get access to the latest features in the `amazon.aws`
    collection, which is bundled with the `ansible` package when you install it –
    you would simply install it (again!) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you query the installed collections, you will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Thus, you can see that the original version of the collection has been retained,
    but the newer version has been installed in our local collections directory (as
    specified by `COLLECTIONS_PATHS`). Ansible will use manually installed collections
    in locations specified by this variable in precedence over the originally installed
    collections, so this way, it is easy to upgrade collections that are bundled with
    the Ansible package. If you feel at all nervous about which collection is used,
    there is a handy `lookup` plugin that you can use to query the version of a collection
    being used by Ansible. Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Most of this code should now be familiar to you. All we do here is use a `lookup`
    plugin called `community.general.collection_version`, passing it the value of
    the collection name we want to query (in our case, `amazon.aws`). If we run this,
    it will kindly reassure us that we’re on the version we just installed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we downgrade the collection to an older version than that installed with
    the `ansible` package (an unlikely scenario, but just for example), we can see
    then that Ansible faithfully adheres to its path search order and does not default
    to the `amazon.aws` collection that was installed as part of the Ansible installation,
    even though this version is newer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Although simple, this management of collections installed at the time of installing
    Ansible is fundamental to maintaining your control nodes, and as such, it is important
    that we cover it. Now that you’ve learned all about collections, what they are,
    why they are important, and how to administer them, let’s create our very own
    collection to work with in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating your own collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned a great deal about collections and how to manage and maintain
    them. Let’s now complete your knowledge on this topic by creating your own one
    from scratch, thus giving you a full overview of how they are put together and
    how they work.
  prefs: []
  type: TYPE_NORMAL
- en: As with roles (see [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks
    and Roles*), collections are simply an organized set of files within directories.
    Although you can look up all these directories and create them by hand, we can
    also get the `ansible-galaxy` utility to create a blank template for us to work
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start with the fundamentals. We know that we need both a namespace and
    a collection name. If we publish on the Ansible Galaxy website, then the namespace
    will be our GitHub handle, as Ansible Galaxy takes this and uses it as your namespace.
    In our case, we won’t be publishing to Ansible Galaxy, so I’ll choose the namespace
    `practicalansible`, but feel free to substitute this with your GitHub handle in
    all the following example code and commands if you want to publish your work.
  prefs: []
  type: TYPE_NORMAL
- en: Once we’ve decided on the namespace, the next step is a collection name. Normally,
    this would be used to indicate what a collection is for, and here, we will use
    this to amalgamate examples found elsewhere in this book, so we’ll simply call
    the collection `examples`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll create an empty directory to work in to separate this from the rest of
    our code, and then we’ll create the skeleton directory structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, you can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The top-level directory is the namespace we chose.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next-level directory is the collection name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Under these top-level directories, we have the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `README.md` file (mandatory documentation if you submit to Ansible Galaxy,
    and advisable in just about every scenario)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A `galaxy.yml` file that will contain important metadata about the role, such
    as tags, a license, and a documentation page so that your entry on Ansible Galaxy
    is populated correctly
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We then have a `docs/` directory – this should be used for all documentation
    and will be referenced by the `ansible-doc` command, so it should be populated
    according to best practices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is also a `meta/` directory – this is prepopulated with a `runtime.yml`
    file that is used for submissions to Ansible Galaxy and contains important information
    about the minimum version of `ansible-core` required, as well as other artifacts
    related to deprecation and code upgrade.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Last but by no means least, we have the `plugins/` and `roles/` directories,
    and this is where the code that you are going to distribute will be placed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not created in the skeleton directory structure are two directories called `playbooks/`
    and `tests/`. The `playbooks/` directory is used to distribute playbooks with
    the collection (yes, you can even do this!), which you can run directly from the
    command line (provided you’re using `ansible-core` 2.11 or newer) or via the `import_playbook`
    statement within a playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `tests/` directory is used to contain automated tests for your code, to
    be run by the `ansible-test` tool. We won’t focus on these in this book, but if
    you’d like to learn more about this topic, this is a great place to start: [https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml](https://docs.ansible.com/ansible/latest/dev_guide/developing_collections_testing.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: As not everyone will be able to (or want to) submit to Ansible Galaxy, our focus
    in this chapter will be on the use of collections to distribute and use code such
    as modules and roles. Let’s get started on this.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book so far, you have already seen many examples of running modules
    from collections – this is the most common use case for most users, so we will
    start here.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming*,
    we created a simple module to test called `remotecopy`. We know that collections
    are the standard way to distribute these, so let’s integrate this into our new
    collection. We do this by creating a directory called `modules/` under the `plugins/`
    directory and then copying our code there. The end results should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we didn’t change the code at all in the module from that used in
    [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming*. No
    modifications to your code are necessary to work with collections – it’s simply
    a matter of making sure you put your files in the correct subdirectory. With that
    done, we can now package up our collection for testing. This is done by changing
    to the root directory of the collection itself and then issuing the `ansible-galaxy
    collection` `build` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Note that Ansible has appended a version number of `1.0.0` to the filename –
    this was obtained from the `galaxy.yml` file and is the default value. We’ll edit
    this in a future example, but for now, it serves our purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the collection built, it’s time to test it. First of all, we need to create
    an empty directory to work in. Once we’re in there, we can use the `ansible-galaxy`
    command to install our new collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Congratulations! You’ve just created and installed your very first collection!
    From here, we need to create a playbook to test it out. We will create this in
    the same way we did before, making sure to use the FQCN of our newly built and
    installed collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will run the playbook in the normal manner – again, no other special
    commands or configurations are required, even though we’ve just built and installed
    our own collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: We can see that our module works perfectly, and thus, you can feel accomplished
    that you have just successfully built, installed, and integrated your first collection
    using code we already provided in the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also query the documentation that was built into this module in the
    normal manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we’ve built our first collection but also written a separate playbook
    as a test harness for it. In many cases, you wouldn’t just write a simple test
    harness as we have here – you would write a playbook to solve an actual use case,
    or even provide some example code to show how the collection can be used. Let’s
    do this now by adding our playbook to the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Although we don’t modify the playbook code, our playbook has a hardcoded `hosts`
    line in the play definition set to `localhost` – you’d probably never do this
    in a real collection, and the Ansible documentation itself recommends using a
    variable to define the hosts so that users can specify their own pattern here.
    We’re just distributing example code via the collection though, so in our case,
    we can justify this decision.
  prefs: []
  type: TYPE_NORMAL
- en: 'While not changing the playbook file contents, we change the filename as part
    of the `cp` command. This is done because Ansible does not support the use of
    hyphens (`-`) in filenames when you refer to objects in a collection – an important
    point that might trip you up later! Also, note here that we’ve used the `sed`
    command to change the version number in the `galaxy.yml` file to make it easy
    to read the code in the book, but you are welcome to edit it with your favorite
    text editor. With this done, we can repackage the collection in the same manner
    as we did before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now run the playbook from the command line by simply providing the
    fully qualified playbook name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: You have now successfully added a playbook to your collection, bumped up the
    version number, and upgraded your local installation. You’ve even run the playbook
    from the collection directly rather than from a local file, as we have throughout
    all other examples in the book. We hope you feel a sense of accomplishment at
    this point! Let’s now extend our collection with another example – integrating
    a plugin. Once again, we’ll make use of code provided elsewhere in this book –
    specifically, [*Chapter 7*](B20846_07.xhtml#_idTextAnchor343), *Creating and*
    *Consuming* *Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we need to copy the code we need into our collection. While you
    would expect plugins to go under the `plugins/` directory, they must actually
    be placed under a subdirectory within this, named by the plugin type. We will
    copy over a `lookup` plugin, so we must create a directory called `lookup/` before
    we can copy the plugin code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Once again, we haven’t modified the plugin code at all – we have just placed
    it into our directory structure. Again, we’ve bumped up the version number of
    the collection using `sed` to edit the `galaxy.yml` file in place. With this done,
    we can build and install the new version of the collection in the normal manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'With that completed, it is once again time to test our newly enhanced collection
    via a playbook. This time, we won’t build the playbook into the collection – we’ll
    simply create it and run it from the test directory we created earlier. The playbook
    code should look like the following – again, you should find it unchanged from
    [*Chapter 7*](B20846_07.xhtml#_idTextAnchor343), *Creating and Consuming* *Plugins*,
    except that we’ve put the FQCN of the `lookup` plugin into the playbook rather
    than the short form name you might otherwise use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember to also create a file called `testdoc.txt` in the same directory as
    the playbook for the `lookup` plugin to reference – our example contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the playbook in the normal manner, and you should find that the
    plugin works as desired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, our `lookup` plugin works perfectly as part of our newly expanded
    collection. To round off our look at building our own collection, we will expand
    it further still by adding a role to it.
  prefs: []
  type: TYPE_NORMAL
- en: To provide a little background, `ansible-galaxy` (both the tool and the Ansible
    Galaxy website) were originally envisaged to be used to manage, distribute, and
    install roles. Given that the processes for managing collections, and that their
    purpose as reusable Ansible code artifacts is very similar to the original roles
    for which they were designed, it makes perfect sense to use the same tooling for
    collection management.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing, the Galaxy tools and website support both roles and
    collections and are likely to for the foreseeable future. However, collections
    provide a number of advantages, including the option to package multiple roles
    in a single collection, and you also can use them to distribute any plugins (or
    even modules) that might be needed for the roles.
  prefs: []
  type: TYPE_NORMAL
- en: The process to migrate a role to a collection is incredibly easy, and if you
    have a simple role that only includes objects such as tasks, files, templates,
    handlers, and variables, then you can copy the code over as is (to the correct
    place, naturally) without any modifications. However, special care needs to be
    taken if you included plugins with your role previously, as these will need to
    be moved aside from the role and integrated into the collection itself at the
    top level (in exactly the same way as we integrated our demo `lookup` plugin a
    little earlier in this section).
  prefs: []
  type: TYPE_NORMAL
- en: 'To extend our example, we’ll take one of the roles that we demonstrated in
    [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks and Roles*, to show
    how it can be integrated and tested. As before, we need to change to our collection
    directory and copy the role over (retaining its directory structure) into a `roles/`
    directory within the collection. You can do this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the role is now copied into place and retains the same structure
    as before, under the `roles/` subdirectory within the collection. With this complete,
    we can now build the new collection (we have incremented the version number again)
    and install it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'With the newly updated role in place, all that remains to do is test it. We
    will borrow the same playbook we used to test it before, with a small modification
    to call the role from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As this is a role to install Apache on external nodes, we will need to copy
    over the inventory we used before – if you use the GitHub repository that accompanies
    this book, that has been done for you. All that remains is to run the code, which
    should return something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: No changes will be made if you ran this role previously as part of [*Chapter
    4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks and Roles*, but you can clearly
    see from the preceding that we successfully call the role from the collection
    and it works perfectly.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have successfully integrated a plugin, a module, a playbook, and
    a role into a collection, taking you through the entire process of building and
    adding to your own collection. That wraps up our look at collections in depth,
    but I hope that this has given you enough information to proceed with your own
    testing and development, ultimately building your own collections.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collections are now a vitally important part of Ansible’s overall architecture,
    and they provide an easy and effective mechanism for all code to be distributed
    and managed on control nodes everywhere. Learning about collections is vital to
    your understanding of the architecture of any modern version of Ansible, and armed
    with this information, you can manage, build, and maintain collections on your
    control nodes, even contributing them back to the community if you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the history of collections, how they came
    about, and why they are so important to Ansible. You then learned how to reference
    objects from within collections using FQCNs, before moving on to learning about
    the installation and management of collections on your control node. Finally,
    we looked at the process involved in building, installing, and testing your own
    collection, such that you can progress to contributing collections to the wider
    Ansible community if you so desire.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to consume and create our very own plugins,
    providing you with the skills you need to expand the capabilities of Ansible to
    suit your own bespoke environments and contribute to the community.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Collections are an optional feature of Ansible versions later than 2.9:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the acronym FQCN stand for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fully Qualified Collection Namespace
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Fully Qualified Control Node
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Fully Qualified Collection Name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Fully Qualified Control Name
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Collections are installed and managed with which command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible-galaxy`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible-collection`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`collection-manager`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ansible-galaxy` and its documentation can be found here: [https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/)'
  prefs: []
  type: TYPE_NORMAL
