<html><head></head><body>
        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Containers and Docker Overview</h1>
                
            
            <article>
                
<p class="calibre2">This book is much more than just the fundamentals of OpenShift. It's about the past, present, and the future of microservices and containers in general. In this book, we are going to cover OpenShift and its surroundings; this includes topics such as the fundamentals of containers, Docker basics, and studying sections where we will work with both Kubernetes and <span class="calibre11">OpenShift in order to feel more comfortable with them. </span></p>
<p class="calibre2">During our OpenShift journey, we will walk you through all the main and most of the advanced components of OpenShift. We are going to cover OpenShift security and networking and also application development for OpenShift using the most popular and built-in OpenShift DevOps tools, such as CI/CD with Jenkins and <strong class="calibre4">Source-to-Image</strong> (<strong class="calibre4">S2I</strong>) in conjunction with GitHub.</p>
<p class="calibre2">We will also learn about the most critical part for every person who would like to actually implement OpenShift in their company—the design part. We are going to show you how to properly design and implement OpenShift, examining the most common mistakes made by those who have just started working with OpenShift.</p>
<p class="calibre2">The chapter is focused on container and Docker technologies. We will describe container concepts and Docker basics, from the architecture to low-level technologies. In this chapter, we will learn how to use Docker CLI and manage Docker containers and Docker images. A significant part of the chapter is focused on building and running Docker container images. As a part of the chapter, you are asked to develop a number of <span class="calibre11">Dockerfiles</span> and to containerize several applications.</p>
<p class="calibre2">In this chapter, we will look at the following:</p>
<ul class="calibre9">
<li class="calibre10">Containers overview     </li>
<li class="calibre10">Docker container architecture </li>
<li class="calibre10">Understanding Docker images and layers</li>
<li class="calibre10">Understanding Docker Hub and Docker registries</li>
<li class="calibre10">Installing and configuring Docker software</li>
<li class="calibre10">Using the Docker command line</li>
<li class="calibre10">Managing images via Docker CLI</li>
<li class="calibre10"><span>Managing containers via Docker CLI</span> </li>
<li class="calibre10"><span>Understanding the importance of environment variables inside Docker containers</span></li>
<li class="calibre10"><span>Managing persistent storage for Docker containers</span></li>
<li class="calibre10">Building a custom <span>Docker</span><span> </span>image</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Technical requirements</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we are going to use the following technologies and software:</p>
<ul class="calibre9">
<li class="calibre10">Vagrant</li>
<li class="calibre10">Bash Shell</li>
<li class="calibre10">GitHub</li>
<li class="calibre10">Docker</li>
<li class="calibre10">Firefox (recommended) or any other browser</li>
</ul>
<p class="calibre2">The Vagrant installation and all the code we use in this chapter are located on GitHub at <a href="https://github.com/PacktPublishing/Learn-OpenShift" class="calibre8">https://github.com/PacktPublishing/Learn-OpenShift</a>.</p>
<p class="calibre2">Instructions on how to install and configure Docker are provided in this chapter as we learn.</p>
<p class="calibre2">Bash Shell will be used as a part of your virtual environment based on CentOS 7.</p>
<p class="calibre2">Firefox or any other browser can be used to navigate through Docker Hub. </p>
<p class="calibre2">As a prerequisite, you will need a stable internet connection from your laptop.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Containers overview</h1>
                
            
            <article>
                
<p class="calibre2">Traditionally, software applications were developed following a monolithic architecture approach, meaning all the services or components were locked to each other. You could not take out a part and replace it with something else. That approach changed over time and became the N-tier approach. The N-tier application approach is one step forward in container and microservices architecture.  </p>
<p class="calibre2">The major drawbacks of the monolith architecture were its lack of reliability, scalability, and high availability. It was really hard to scale monolith applications due to their nature. The reliability of these applications was also questionable because you could rarely easily operate and upgrade these applications without any downtime. There was no way you could efficiently scale out monolith applications, meaning you could not just add another one, five, or ten applications back to back and let them coexist with each other.</p>
<p class="calibre2">We had monolith applications in the past, but then people and companies started thinking about application scalability, security, reliability, and <strong class="calibre4">high availability</strong> (<strong class="calibre4">HA</strong>). And that is what created N-tier design. The N-tier design is a standard application design like 3-tier web applications where we have a web tier, application tier, and database backend. It's pretty standard. Now it is all evolving into microservices. Why do we need them? The short answer is <em class="calibre17">for better numbers</em>. It's cheaper, much more scalable, and secure. Containerized applications bring you to a whole new level and this is where you can benefit from automation and DevOps.</p>
<div class="title-page-name">
<p class="calibre2">Containers are a new generation of virtual machines. That brings software development to a whole new level. Containers are an isolated set of different rules and resources inside a single operating system. This means that containers can provide the same benefits as virtual machines but use far less CPU, memory, and storage. There are several popular container providers including LXC, Rockt, and Docker, which we are going to focus on this book.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Container features and advantages</h1>
                
            
            <article>
                
<p class="calibre2">This architecture brings a lot of advantages to software development.</p>
<p class="calibre2">Some of the major advantages of containers are as follows:</p>
<ul class="calibre9">
<li class="calibre20">Efficient hardware resource consumption</li>
<li class="calibre20">Application and service isolation</li>
<li class="calibre20">Faster deployment</li>
<li class="calibre20">Microservices architecture</li>
<li class="calibre20">The stateless nature of containers</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Efficient hardware resource consumption</h1>
                
            
            <article>
                
<p class="calibre2">Whether you run containers natively on a bare-metal server or use virtualization techniques, using containers allows you to utilize resources (CPU, memory, and storage) in a better and much more efficient manner. In the case of a bare-metal server, containers allow you to run tens or even hundreds of the same or different containers, providing better resource utilization in comparison to usually one application running on a dedicated server. We have seen in the past that some server utilization at peak times is only 3%, which is a waste of resources. And if you are going to run several of the same or different applications on the same servers, they are going to conflict with each other. Even if they work, you are going to face a lot of problems during day-to-day operation and troubleshooting.</p>
<p class="calibre2">If you are going to isolate these applications by introducing popular virtualization techniques such as KVM, VMware, XEN, or Hyper-V, you will run into a different issue. There is going to be a lot of overhead because, in order to virtualize your app using any hypervisor, you will need to install an operating system on top of your hypervisor OS. This operating system needs CPU and memory to function. For example, each VM has its own kernel and kernel space associated with it. A perfectly tuned container platform can give you up to four times more containers in comparison to standard VMs. It may be insignificant when you have five or ten VMs, but when we talk hundreds or thousands, it makes a huge difference.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Application and service isolation</h1>
                
            
            <article>
                
<p class="calibre2">Imagine a scenario where we have ten different applications hosted on the same server. Each application has a number of dependencies (such as packages, libraries, and so on). If you need to update an application, usually it involves updating the process and its dependencies. If you update all related dependencies, most likely it will affect the other application and services. It may cause these applications not to work properly. Sure, to a degree these issues are addressed by environment managers such as <kbd class="calibre12">virtualenv</kbd> for Python and <kbd class="calibre12">rbenv</kbd>/<kbd class="calibre12">rvm</kbd> for Ruby—and dependencies on shared libraries can be isolated via <kbd class="calibre12">LD_LIBRARY_PATH</kbd>—but what if you need different versions of the same package? Containers and virtualization solve that issue. Both VMs and containers provide environment isolation for your applications.</p>
<p class="calibre2">But, in comparison to bare-metal application deployment, container technology (for example, Docker) provides an efficient way to isolate applications, and other computer resources libraries from each other. It not only provides these applications with the ability to co-exist on the same OS, but also provides efficient security, which is a big must for every customer-facing and content-sensitive application. It allows you to update and patch your containerized applications independently of each other.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Faster deployment</h1>
                
            
            <article>
                
<p class="calibre2">Using container images, discussed later in this book, allows us speed up container deployment. We are talking about seconds to completely restart a container versus minutes or tens of minutes with bare-metal servers and VMs. The main reason for this is that a container does not need to restart the whole OS, it just needs to restart the application itself.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Microservices architecture</h1>
                
            
            <article>
                
<p class="calibre2">Containers bring application deployment to a whole new level by introducing microservices architecture. What it essentially means is that, if you have a monolith or N-tier application, it usually has many different services communicating with each other. Containerizing your services allows you to break down your application into multiple pieces and work with each of them independently. Let's say you have a standard application that consists of a web server, application, and database. You can probably put it on one or three different servers, three different VMs, or three simple containers, running each part of this application. All these options require a different amount of effort, time, and resources. Later in this book, you will see how simple it is to do using containers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">The stateless nature of containers</h1>
                
            
            <article>
                
<p class="calibre2">Containers are stateless, which means that you can bring containers up and down, create or destroy them at any time, and this will not affect your application performance. That is one of the greatest features of containers. We are going to delve into this later in this book.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker container architecture</h1>
                
            
            <article>
                
<p class="calibre2">Docker is one of the most popular application containerization technologies these days. So why do we want to use Docker if there are other container options available? Because collaboration and contribution are key in the era of open source, and Docker has made many different things that other technologies have not been able to in this area.</p>
<p class="calibre2">For example, Docker partnered with other container developers such as Red Hat, Google, and Canonical to jointly work on its components. Docker also contributed it's software container format and runtime to the Linux Foundation's open container project. Docker has made containers very easy to learn about and use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker architecture</h1>
                
            
            <article>
                
<p class="calibre2">As we mentioned already, Docker is the most popular container platform. It allows for creating, sharing, and running applications inside Docker containers. Docker separates running applications from the infrastructure. It allows you to speed up the application delivery process drastically. Docker also brings application development to an absolutely new level. In the diagram that follows, you can see a high-level overview of the Docker architecture:</p>
<p class="cdpaligncenter"><img src="../images/00005.jpeg" class="calibre21"/></p>
<div class="cdpaligncenter1">Docker architecture</div>
<p class="calibre2">Docker uses a client-server type of architecture:</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Docker server</strong>: This is a service running as a daemon in an operating system. This service is responsible for downloading, building, and running containers.</li>
<li class="calibre20"><strong class="calibre1">Docker client</strong>: The CLI tool is responsible for communicating with Docker servers using the REST API.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker's main components</h1>
                
            
            <article>
                
<p class="calibre2">Docker uses three main components:</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Docker containers</strong>: Isolated user-space environments running the same or different applications and sharing the same host OS. Containers are created from Docker images.</li>
<li class="calibre20"><strong class="calibre1">Docker images</strong>: Docker templates that include application libraries and applications. Images are used to create containers and you can bring up containers immediately. You can create and update your own custom images as well as download build images from Docker's public registry.</li>
<li class="calibre20"><strong class="calibre1">Docker registries</strong>: This is a images store. Docker registries can be public or private, meaning that you can work with images available over the internet or create your own registry for internal purposes. One popular public Docker registry is Docker Hub, discussed later in this chapter.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linux containers</h1>
                
            
            <article>
                
<p class="calibre2">As mentioned in the previous section, Docker containers are secured and isolated from each other. In Linux, Docker containers use several standard features of the Linux kernel. This includes:</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Linux namespaces</strong>: It is a feature of Linux kernel to isolate resources from each other. This allows one set of Linux processes to see one group of resources while allowing another set of Linux processes to see a different group of resources. There are several kinds of namespaces in Linux: <strong class="calibre1">Mount</strong> (<strong class="calibre1">mnt</strong>), <strong class="calibre1">Process ID</strong> (<strong class="calibre1">PID</strong>), <strong class="calibre1">Network</strong> (<strong class="calibre1">net</strong>), <strong class="calibre1">User ID</strong> (<strong class="calibre1">user</strong>), <strong class="calibre1">Control group</strong> (<strong class="calibre1"><span>cgroup</span></strong>), and <strong class="calibre1">Interprocess Communication</strong> (<strong class="calibre1">IPC</strong>). The kernel can place specific system resources that are normally visible to all processes into a namespace. Inside a namespace, a process can see resources associated with other processes in the same namespace. You can associate a process or a group of processes with their own namespace or, if using network namespaces, you can even move a network interface to a network namespace. For example, two processes in two different mounted namespaces may have different views of what the mounted root file system is. Each container can be associated with a specific set of namespaces, and these namespaces are used inside these containers only.</li>
<li class="calibre20"><strong class="calibre1">Control groups</strong> (<strong class="calibre1">cgroups</strong>): These provide an effective mechanism for resource limitation. With cgroups, you can control and manage system resources per Linux process, increasing overall resource utilization efficiency. Cgroups allow Docker to control resource utilization per container.</li>
<li class="calibre20"><strong class="calibre1">SELinux</strong>: <strong class="calibre1">Security Enhanced Linux</strong> (<strong class="calibre1">SELinux</strong>) is <strong class="calibre1">mandatory access control</strong> (<strong class="calibre1">MAC</strong>) used for granular system access, initially developed by the <strong class="calibre1">National Security Agency</strong> (<strong class="calibre1">NSA</strong>). It is an additional security layer for Debian and RHEL-based distributions like Red Hat Enterprise Linux, CentOS, and Fedora. Docker uses SELinux for two main reasons: host protection and to isolate containers from each other. Container processes run with limited access to the system resources using special SELinux rules.</li>
</ul>
<p class="calibre2">The beauty of Docker is that it leverages the aforementioned low-level kernel technologies, but hides all complexity by providing an easy way to manage your containers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Understanding Docker images and layers</h1>
                
            
            <article>
                
<p class="calibre2">A Docker image is a read-only template used to build containers. An image consists of a number of layers that are combined into a single virtual filesystem accessible for Docker applications. This is achieved by using a special technique which combines multiple layers into a single view. Docker images are immutable, but you can add an extra layer and save them as a new image. Basically, you can add or change the Docker image content without changing these images directly. Docker images are the main way to ship, store, and deliver containerized applications. Containers are created using Docker images; if you do not have a Docker image, you need to download or build one.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Container filesystem</h1>
                
            
            <article>
                
<p class="calibre2">The container filesystem, used for every Docker image, is represented as a list of read-only layers stacked on top of each other. These layers eventually form a base root filesystem for a container. In order to make it happen, different storage drivers are being used. All the changes to the filesystem of a running container are done to the top level image layer of a container. This layer is called a Container layer. What it basically means is that several containers may share access to the same underlying level of a Docker image, but write the changes locally and uniquely to each other. This process is shown in the following diagram:</p>
<p class="cdpaligncenter"><img class="alignnone1" src="../images/00006.jpeg"/></p>
<div class="cdpaligncenter1">Docker layers</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker storage drivers</h1>
                
            
            <article>
                
<p class="calibre2">A Docker storage driver is the main component to enable and manage container images. Two main technologies are used for that—copy-on-write and stackable image layers. The storage driver is designed to handle the details of these layers so that they interact with each other. There are several drivers available. They do pretty much the same job, but each and every one of them does it differently. The most common storage drivers are AUFS, Overlay/Overlay2, Devicemapper, Btrfs, and ZFS. All storage drivers can be categorized into three different types:</p>
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Storage driver category</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Storage drivers</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Union filesystems</p>
</td>
<td class="calibre25">
<p class="calibre2">AUFS, Overlay, Overlay2</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Snapshotting filesystems</p>
</td>
<td class="calibre25">
<p class="calibre2">Btrfs, ZFS</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Copy-on-write block devices</p>
</td>
<td class="calibre25">
<p class="calibre2">Devicemapper</p>
</td>
</tr>
</tbody>
</table>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Container image layers</h1>
                
            
            <article>
                
<p class="calibre2">As previously mentioned, a Docker image contains a number of layers that are combined into a single filesystem using a storage driver. The layers (also called intermediate images) are generated when commands are executed during the Docker image build process. Usually, Docker images are created using a Dockerfile, the syntax of which will be described later. Each layer represents an instruction in the image's Dockerfile.</p>
<p class="calibre2">Each layer, except the very last one, is read-only:</p>
<div class="cdpaligncenter2"><img class="alignnone2" src="../images/00007.gif"/></div>
<div class="cdpaligncenter1">Docker image layers</div>
<p class="calibre2">A Docker image usually consists of several layers, stacked one on top of the other. The top layer has read-write permissions, and all the remaining layers have read-only permissions. This concept is very similar to the copy-on-write technology. So, when you run a container from the image, all the changes are done to this top writable layer. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker registries</h1>
                
            
            <article>
                
<p class="calibre2">As mentioned earlier, a Docker image is a way to deliver applications. You can create a Docker image and share it with other users using a public/private registry service. A registry is a stateless, highly scalable server-side application which you can use to store and download Docker images. Docker registry is an open source project, under the permissive Apache license. Once the image is available on a Docker registry service, another user can download it by pulling the image and can use this image to create new Docker images or run containers from this image.</p>
<p class="calibre2">Docker supports several types of docker registry:</p>
<ul class="calibre9">
<li class="calibre20">Public registry</li>
<li class="calibre20">Private registry</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Public registry</h1>
                
            
            <article>
                
<p class="calibre2">You can start a container from an image stored in a public registry. By default, the Docker daemon looks for and downloads Docker images from Docker Hub, which is a public registry provided by Docker. However, many vendors add their own public registries to the Docker configuration at installation time. For example, Red Hat has its own <em class="calibre17">proven and blessed</em> public Docker registry which you can use to pull Docker images and to build containers.  </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Private registry</h1>
                
            
            <article>
                
<p class="calibre2">Some organization or specific teams don't want to share their custom container images with everyone for a reason. They still need a service to share Docker images, but just for internal usage. In that case, a private registry service can be useful. A private registry can be installed and configured as a service on a dedicated server or a virtual machine inside your network.</p>
<p class="calibre2">You can easily install a private Docker registry by running a Docker container from a public registry image. The private Docker registry installation process is no different from running a regular Docker container with additional options.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Accessing registries</h1>
                
            
            <article>
                
<p class="calibre2">A Docker registry is accessed via the Docker daemon service using a Docker client. The Docker command line uses a RESTful API to request process execution from the daemon. Most of these commands are translated into HTTP requests and may be transmitted using <kbd class="calibre12">curl</kbd>.</p>
<p class="calibre2">The process of using Docker registries is shown in the following section.</p>
<p class="calibre2">A developer can create a Docker image and put it into a private or public registry. Once the image is uploaded, it can be immediately used to run containers or build other images.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker Hub overview</h1>
                
            
            <article>
                
<p class="calibre2">Docker Hub is a cloud-based registry service that allows you to build your images and test them, push these images, and link to Docker cloud so you can deploy images on your hosts. Docker Hub provides a centralized resource for container image discovery, distribution and change management, user and team collaboration, and workflow automation throughout the development pipeline.</p>
<p class="calibre2">Docker Hub is the public registry managed by the Docker project, and it hosts a large set of container images, including those provided by major open source projects, such as MySQL, Nginx, Apache, and so on, as well as customized container images developed by the community.</p>
<p class="calibre2">Docker Hub provides some of the following features:</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Image repositories</strong>: You can find and download images managed by other Docker Hub users. You can also push or pull images from private image libraries you have access to.</li>
<li class="calibre20"><strong class="calibre1">Automated builds</strong>: You can automatically create new images when you make changes to a source code repository.</li>
<li class="calibre20"><strong class="calibre1">Webhooks</strong>: The action trigger that allows you to automate builds when there is a push to a repository.</li>
<li class="calibre20"><strong class="calibre1">Organizations</strong>: The ability to create groups and manage access to image repositories.</li>
</ul>
<p class="calibre2">In order to start working with Docker Hub, you need to log in to Docker Hub using a Docker ID. If you do not have one, you can create your Docker ID by following the simple registration process. It is completely free. The link to create your Docker ID if you do not have one is <a href="https://hub.docker.com/" class="calibre8">https://hub.docker.com/</a>.</p>
<p class="calibre2">You can search for and pull Docker images from Docker Hub without logging in; however, to push images you must log in. Docker Hub gives you the ability to create public and private repositories. Public repositories will be publicly available for anyone and private repositories will be restricted to a set of users of organizations.</p>
<p class="calibre2">Docker Hub contains a number of official repositories. These are public, certified repositories from different vendors and Docker contributors. It includes vendors like Red Hat, Canonical, and Oracle.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker installation and configuration</h1>
                
            
            <article>
                
<p class="calibre2">Docker software is available in two editions: <strong class="calibre4">Community Edition</strong> (<strong class="calibre4">CE</strong>) and <strong class="calibre4">Enterprise Edition</strong> (<strong class="calibre4">EE</strong>).</p>
<p class="calibre2"><strong class="calibre4">Docker CE</strong> is a good point from which to start learning Docker and using containerized applications. It is available on different platforms and operating systems. Docker CE comes with an installer so you can start working with containers immediately. Docker CE is integrated and optimized for infrastructure so you can maintain a native app experience while getting started with Docker.</p>
<p class="calibre2"><strong class="calibre4">Docker Enterprise Edition</strong> (<strong class="calibre4">EE</strong>) is a <strong class="calibre4">Container-as-a-Service</strong> (<strong class="calibre4">CaaS</strong>) platform for IT that manages and secures diverse applications across disparate infrastructures, both on-premises and in a cloud. In other words, Docker EE is similar to Docker CE in that it is supported by Docker Inc.</p>
<p class="calibre2">Docker software supports a number of platforms and operating systems. The packages are available for most popular operating systems such as Red Hat Enterprise Linux, Fedora Linux, CentOS, Ubuntu Linux, Debian Linux, macOS, and Microsoft Windows.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker installation</h1>
                
            
            <article>
                
<p class="calibre2">The Docker installation process is dependent on the particular operating system. In most cases, it is well described on the official Docker portal—<a href="https://docs.docker.com/install/" class="calibre8">https://docs.docker.com/install/</a>. As a part of this book, we will be working with Docker software on CentOS 7.x. Docker installation and configuration on other platforms is not part of this book. If you still need to install Docker on another operating system, just visit the official Docker web portal.</p>
<p class="calibre2">Usually, the Docker node installation process looks like this:</p>
<ol class="calibre13">
<li value="1" class="calibre20">Installation and configuration of an operating system</li>
<li value="2" class="calibre20">Docker packages installation</li>
<li value="3" class="calibre20">Configuring Docker settings</li>
<li value="4" class="calibre20">Running the Docker service</li>
</ol>
<div class="packt_infobox">We assume that our readers have sufficient knowledge to install and configure a CentOS-based <strong class="calibre1">virtual machine</strong> (<strong class="calibre1">VM</strong>) or bare-metal host. If you do not know how to use Vagrant, please follow the guidelines at <a href="https://www.vagrantup.com/intro/getting-started/" class="calibre6">https://www.vagrantup.com/intro/getting-started/</a>.<br class="title-page-name"/>
<br class="title-page-name"/>
Once you properly install Vagrant on your system, just run <kbd class="calibre26">vagrant init centos/7</kbd> followed by <kbd class="calibre26">vagrant up</kbd>. You can verify whether vagrant is up with the <kbd class="calibre26">vagrant status</kbd> command, and finally you can <kbd class="calibre26">ssh</kbd> into VM by using <kbd class="calibre26">vagrant ssh</kbd> command. <br class="title-page-name"/>
<span>Since Docker is supported on even the most popular OSes, you have an option to install Docker directly on your desktop OS. We advise you to either use Vagrant or any other virtualization provider such as VMware or KVM, because we have done all the tests inside the virtual environment on CentOS 7. If you still want to install Docker on your desktop OS, follow the link: <a href="https://docs.docker.com/install/" class="calibre6">https://docs.docker.com/install/</a>.</span></div>
<p class="calibre2">Docker CE is available on CentOS 7 with standard repositories. The installation process is focused on the <kbd class="calibre12">docker</kbd> package installation:</p>
<pre class="calibre18"><strong class="calibre1"># yum install docker -y</strong><br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...<br class="title-page-name"/>Installed:<br class="title-page-name"/>docker.x86_64 2:1.12.6-71.git3e8e77d.el7.centos.1<br class="title-page-name"/>Dependency Installed:<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...</pre>
<p class="calibre2">Once the installation is completed, you need to run the Docker daemon to be able to manage your containers and images. On RHEL7 and CentOS 7, this just means starting the Docker service like so:</p>
<pre class="calibre18"><strong class="calibre1"># systemctl start docker</strong><br class="title-page-name"/><strong class="calibre1"># systemctl enable docker</strong><br class="title-page-name"/>Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</pre>
<p class="calibre2">You can verify that your Docker daemon works properly by showing Docker information provided by the <kbd class="calibre12">docker info</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1"># docker info</strong><br class="title-page-name"/>Containers: 0<br class="title-page-name"/>Running: 0<br class="title-page-name"/>Paused: 0<br class="title-page-name"/>Stopped: 0<br class="title-page-name"/>Images: 0<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...<br class="title-page-name"/>Registries: docker.io (secure)</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker configuration</h1>
                
            
            <article>
                
<p class="calibre2">Docker daemon configuration is managed by the Docker configuration file (<kbd class="calibre12">/etc/docker/daemon.json</kbd>) and Docker daemon startup options are usually controlled by the <kbd class="calibre12">systemd</kbd> unit named Docker. On Red Hat-based operating systems, some configuration options are available at <kbd class="calibre12">/etc/sysconfig/docker</kbd> and <kbd class="calibre12">/etc/sysconfig/docker-storage</kbd>. Modification of the mentioned file will allow you to change Docker parameters such as the UNIX socket path, <kbd class="calibre12">listen</kbd> on TCP sockets, registry configuration, storage backends, and so on.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using the Docker command line</h1>
                
            
            <article>
                
<p class="calibre2">In order to start using Docker CLI, you need to configure and bring up a Vagrant VM. If you are using macOS, the configuration process using Vagrant will look like this:</p>
<pre class="calibre18"><strong class="calibre1">$ mkdir vagrant; cd vagrant<br class="title-page-name"/></strong><strong class="calibre1">$ cat Vagrantfile</strong><br class="title-page-name"/>Vagrant.configure(2) do |config|<br class="title-page-name"/> config.vm.box = "centos/7"<br class="title-page-name"/> config.vm.hostname = 'node1.example.com'<br class="title-page-name"/> config.vm.network "private_network", type: "dhcp"<br class="title-page-name"/> config.vm.provision "shell", inline: "groupadd docker; usermod -aG docker vagrant; yum install docker -y; systemctl enable docker; systemctl start docker"<br class="title-page-name"/>end<br class="title-page-name"/><strong class="calibre1">$ vagrant up </strong><br class="title-page-name"/><strong class="calibre1">$ vagrant ssh</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Docker man, help, info</h1>
                
            
            <article>
                
<p class="calibre2">The Docker daemon listens on <kbd class="calibre12">unix:///var/run/docker.sock</kbd> but you can bind Docker to another host/port or a Unix socket. The Docker client (the <kbd class="calibre12">docker</kbd> utility) uses the Docker API to interact with the Docker daemon.</p>
<p class="calibre2">The Docker client supports dozens of commands, each with numerous options, so an attempt to list them all would just result in a copy of the CLI reference from the official documentation. Instead, we will provide you with the most useful subsets of commands to get you up and running.</p>
<p class="calibre2">You can always check available man pages for all Docker sub-commands using:</p>
<pre class="calibre18"><strong class="calibre1"><span>$ man -k docker</span></strong></pre>
<p class="calibre2">You will be able to see a list of man pages for Docker and all the sub-commands available:</p>
<div class="title-page-name">
<pre class="calibre18"><span><strong class="calibre1">$ man docker</strong><br class="title-page-name"/><strong class="calibre1">$ man docker-info</strong><br class="title-page-name"/><strong class="calibre1">$ man Dockerfile</strong><br class="title-page-name"/></span></pre>
<p class="calibre2"><span class="calibre11">Another way to get information regarding a command is to use <kbd class="calibre12">docker COMMAND --help</kbd>:</span></p>
</div>
<div class="title-page-name">
<div class="title-page-name">
<pre class="calibre18"><strong class="calibre1"># docker info --help</strong><br class="title-page-name"/>Usage: docker info<br class="title-page-name"/>Display system-wide information<br class="title-page-name"/>--help             Print usage</pre></div>
</div>
<p class="calibre2">The <kbd class="calibre12">docker</kbd> utility allows you to manage container infrastructure. All sub-commands can be grouped as follows:</p>
<div class="title-page-name">
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Activity type</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Related subcommands</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Managing images</p>
</td>
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">search</kbd>, <kbd class="calibre12">pull</kbd>, <kbd class="calibre12">push</kbd>, <kbd class="calibre12">rmi</kbd>, <kbd class="calibre12">images</kbd>, <kbd class="calibre12">tag</kbd>, <kbd class="calibre12">export</kbd>, <kbd class="calibre12">import</kbd>, <kbd class="calibre12">load</kbd>, <kbd class="calibre12">save</kbd></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Managing containers</p>
</td>
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">run</kbd>, <kbd class="calibre12">exec</kbd>, <kbd class="calibre12">ps</kbd>, <kbd class="calibre12">kill</kbd>, <kbd class="calibre12">stop</kbd>, <kbd class="calibre12">start</kbd></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Building custom images</p>
</td>
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">build</kbd>, <kbd class="calibre12">commit</kbd></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2">Information gathering</p>
</td>
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">info</kbd>, <kbd class="calibre12">inspect</kbd></p>
</td>
</tr>
</tbody>
</table>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing images using Docker CLI</h1>
                
            
            <article>
                
<p class="calibre2">The first step in running and using a container on your server or laptop is to search and pull a Docker image from the Docker registry using the <kbd class="calibre12">docker search</kbd> command.</p>
<p class="calibre2">Let's search for the web server container. The command to do so is:</p>
<pre class="calibre18"><strong class="calibre1">$ docker search httpd</strong><br class="title-page-name"/>NAME DESCRIPTION STARS OFFICIAL AUTOMATED<br class="title-page-name"/>httpd ... 1569 [OK]<br class="title-page-name"/>hypriot/rpi-busybox-httpd ... 40<br class="title-page-name"/>centos/httpd 15 [OK]<br class="title-page-name"/>centos/httpd-24-centos7 ... 9</pre>
<p class="calibre2">Alternatively, we can go to <a href="https://hub.docker.com/" class="calibre8">https://hub.docker.com/</a> and type <kbd class="calibre12">httpd</kbd> in the search window. It will give us something similar to the <kbd class="calibre12">docker search httpd</kbd> results:</p>
<div class="cdpaligncenter2"><img class="alignnone3" src="../images/00008.jpeg"/></div>
<div class="cdpaligncenter1">Docker Hub search results</div>
<p class="calibre2">Once the container image is found, we can pull this image from the Docker registry in order to start working with it. To pull a container image to your host, you need to use the <kbd class="calibre12">docker pull</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker pull httpd</strong></pre>
<p class="calibre2">The output of the preceding command is as follows:</p>
<div class="cdpaligncenter2"><img class="alignnone4" src="../images/00009.jpeg"/></div>
<p class="calibre2">Note that Docker uses concepts from union filesystem layers to build Docker images. This is why you can see seven layers being pulled from Docker Hub. One stacks up onto another, building a final image.</p>
<p class="calibre2">By default, Docker will try to pull the image with the latest tag, but we can also download an older, more specific version of an image we are interested in using different tags. The best way to quickly find available tags is to go to <a href="https://hub.docker.com/" class="calibre8">https://hub.docker.com/</a>, search for the specific image, and click on the image details:</p>
<div class="cdpaligncenter2"><img class="alignnone5" src="../images/00010.jpeg"/></div>
<div class="cdpaligncenter1">Docker Hub image details</div>
<p class="calibre2">There we are able to see all the image tags available for us to pull from Docker Hub. There are ways to achieve the same goal using the <kbd class="calibre12">docker search</kbd> CLI command, which we are going to cover later in this book.</p>
<pre class="calibre18"><strong class="calibre1">$ docker pull httpd:2.2.29</strong></pre>
<p class="calibre2">The output of the preceding code should look something like the following:</p>
<div class="cdpaligncenter2"><img class="alignnone6" src="../images/00011.jpeg"/></div>
<p class="calibre2">You may notice that the download time for the second image was significantly lower than for the first image. It happens because the first image we pulled (<kbd class="calibre12">docker:latest</kbd>) has most layers in common with the second image (<kbd class="calibre12">httpd:2.2.29</kbd>). So there is no need to download all the layers again. This is very useful and saves a lot of time in large environments.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Working with images</h1>
                
            
            <article>
                
<p class="calibre2">Now we want to check the images available on our local server. To do this, we can use the <kbd class="calibre12">docker images</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker images</strong></pre>
<p class="calibre2">The output of the preceding command will be as shown in the following screenshot:</p>
<div class="cdpaligncenter2"><img class="alignnone7" src="../images/00012.jpeg"/><br class="title-page-name"/></div>
<p class="calibre2">If we downloaded a wrong image, we can always delete it from the local server by using the <kbd class="calibre12">docker rmi</kbd> command: <strong class="calibre4">ReMove Image</strong> (<strong class="calibre4">RMI</strong>). In our case, we have two versions of the same image, so we can specify a tag for the image we want to delete:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rmi httpd:2.2.29</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone8" src="../images/00013.jpeg"/></div>
<p class="calibre2">At this point, we have only one image left, which is <kbd class="calibre12">httpd:latest</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ docker images</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone9" src="../images/00014.jpeg"/><br class="title-page-name"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Saving and loading images</h1>
                
            
            <article>
                
<p class="calibre2">The Docker CLI allows us to export and import Docker images and container layers using export/import or save/load Docker commands. The difference between save/load and export/import is that the first one works with images including metadata, but the export/import combination uses only container layers and doesn't include any image metadata information such as name, tags, and so on. In most cases, the save/load combination is more relevant and works properly for images without special needs. The <kbd class="calibre12">docker save</kbd> command packs the layers and metadata of all the chains required to build the image. You can then load this <em class="calibre17">saved</em> images chain into another Docker instance and create containers from these images.</p>
<p class="calibre2">The <kbd class="calibre12">docker export</kbd> will fetch the whole container, like a snapshot of a regular VM. It saves the OS, of course, but also any change a you made and any data file written during the container life. This one is more like a traditional backup:</p>
<pre class="calibre18"><strong class="calibre1">$ docker save httpd -o httpd.tar<br class="title-page-name"/><br class="title-page-name"/></strong><strong class="calibre1">$ ls -l httpd.tar<br class="title-page-name"/></strong></pre>
<div class="cdpaligncenter2"><img class="alignnone10" src="../images/00015.jpeg"/></div>
<p class="calibre2">To load the image back from the file, we can use the <kbd class="calibre12">docker load</kbd> command. Before we do that, though, let's remove the httpd image from the local repository first:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rmi httpd:latest</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone11" src="../images/00016.jpeg"/></div>
<p class="calibre2">We verify that we do not have any images in the local repository:</p>
<pre class="calibre18"><strong class="calibre1"> $ docker images</strong><br class="title-page-name"/> REPOSITORY TAG IMAGE ID CREATED SIZE</pre>
<p class="calibre2">Load the image file we previously saved with the <kbd class="calibre12">docker save</kbd> command. Like <kbd class="calibre12">docker export</kbd> and docker import, this command forms a pair with Docker save and thus is used for loading a saved container archive with all intermediate layers and metadata to the Docker cache:</p>
<pre class="calibre18"><strong class="calibre1">$ docker load -i httpd.tar</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<p class="cdpaligncenter"><img class="alignnone12" src="../images/00017.jpeg"/></p>
<p class="calibre2">Check the local docker images with <kbd class="calibre12">docker image</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker images</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone13" src="../images/00018.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Uploading images to the Docker registry</h1>
                
            
            <article>
                
<p class="calibre2">Now we know how to search, pull, remove, save, load, and list available images. The last piece we are missing is how to push images back to Docker Hub or a private registry.</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">To upload an image to Docker Hub, we need to do a few tricks and follow these steps:</p>
<ol class="calibre13">
<li value="1" class="calibre20">Log in to Docker Hub:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ docker login</strong><br class="title-page-name"/>Username: <strong class="calibre1">#Enter your username here</strong><br class="title-page-name"/>Password: <strong class="calibre1">#Enter your password here</strong><br class="title-page-name"/>Login Succeeded</pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Copy the Docker image you want to push to a different path in the Docker repository on your server:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ docker tag httpd:latest flashdumper/httpd:latest</strong></pre>
<div class="packt_tip">Note that <kbd class="calibre26">flashdumper</kbd> is your Docker Hub username.</div>
<ol start="3" class="calibre13">
<li value="3" class="calibre20">Finally, push the copied image back to Docker Hub:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ docker push flashdumper/httpd:latest</strong></pre>
<p class="calibre27"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone14" src="../images/00019.jpeg"/></div>
<p class="calibre2">Now the image is pushed to your Docker Hub and available for anyone to download. </p>
<pre class="calibre19"><strong class="calibre1">$ docker search flashdumper/*</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<p class="cdpaligncenter"><img class="alignnone15" src="../images/00020.jpeg"/></p>
<p class="calibre2">You can check the same result using a web browser. If you go to <a href="https://hub.docker.com/" class="calibre8">https://hub.docker.com/</a> you should be able to see this <kbd class="calibre12">httpd</kbd> image available under your account:</p>
<p class="cdpaligncenter"><img class="alignnone16" src="../images/00021.jpeg"/></p>
<div class="cdpaligncenter1">Docker Hub account images</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Managing containers using Docker CLI</h1>
                
            
            <article>
                
<p class="calibre2">The next step is to actually run a container from the image we pulled from Docker Hub or a private registry in the previous chapter. We are going to use the <kbd class="calibre12">docker run</kbd> command to run a container. Before we do that, let's check if we have any containers running already by using the <kbd class="calibre12">docker ps</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAME</pre>
<p class="calibre2">Run a container with the <kbd class="calibre12">docker run</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run httpd</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone17" src="../images/00022.jpeg"/></div>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">The container is running, but we cannot leave the terminal and continue working in the foreground. And the only way we can escape it is by sending a TERM signal (<em class="calibre17">Ctrl</em> + <em class="calibre17">C</em>) and killing it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker ps and logs</h1>
                
            
            <article>
                
<p class="calibre2">Run the <kbd class="calibre12">docker ps</kbd> command to show that there are no running containers:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</pre>
<p class="calibre2">Run <kbd class="calibre12">docker ps -a</kbd> to show both running and stopped containers:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps -a</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone18" src="../images/00023.jpeg"/></div>
<p class="calibre2">There are a few things to note here. The <kbd class="calibre12">STATUS</kbd> field says that container <kbd class="calibre12">5e3820a43ffc</kbd> exited about one minute ago. In order to get container log information, we can use the <kbd class="calibre12">docker logs</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker logs 5e3820a43ffc</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone19" src="../images/00024.jpeg"/></div>
<p class="calibre2">The last message says <kbd class="calibre12">caught SIGTERM, shutting down</kbd>. It happened after we pressed <em class="calibre17">Ctrl </em>+ <em class="calibre17">C</em>. In order to run a container in background mode, we can use the <kbd class="calibre12">-d</kbd> option with the <kbd class="calibre12">docker run</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d httpd</strong><br class="title-page-name"/>5d549d4684c8e412baa5e30b20697b72593d87130d383c2273f83b5ceebc4af3</pre>
<p class="calibre2">It generates a random ID, the first 12 characters of which are used for the container ID. Along with the generated ID, a random container name is also generated.</p>
<p class="calibre2">Run <kbd class="calibre12">docker ps</kbd> to verify the container ID, name, and status:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps</strong></pre>
<p class="calibre2"><span class="calibre11">The output of the preceding command will be as shown in the following screenshot:</span></p>
<div class="cdpaligncenter2"><img class="alignnone20" src="../images/00025.jpeg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Executing commands inside a container</h1>
                
            
            <article>
                
<p class="calibre2">From the output, we can see that the container status is <kbd class="calibre12">UP</kbd>. Now we can execute some commands inside the container using the <kbd class="calibre12">docker exec</kbd> command with different options:</p>
<pre class="calibre18"><strong class="calibre1">$ docker exec -i 00f343906df3 ls -l /</strong><br class="title-page-name"/>total 12<br class="title-page-name"/>drwxr-xr-x. 2 root root 4096 Feb 15 04:18 bin<br class="title-page-name"/>drwxr-xr-x. 2 root root 6 Nov 19 15:32 boot<br class="title-page-name"/>drwxr-xr-x. 5 root root 360 Mar 6 21:17 dev<br class="title-page-name"/>drwxr-xr-x. 42 root root 4096 Mar 6 21:17 etc<br class="title-page-name"/>drwxr-xr-x. 2 root root 6 Nov 19 15:32 home<br class="title-page-name"/>...<br class="title-page-name"/>Output truncated for brevity<br class="title-page-name"/>...</pre>
<p class="calibre2">Option <kbd class="calibre12">-i</kbd> (<kbd class="calibre12">--interactive</kbd>) allows you to run a Docker without dropping inside the container. But we can easily override this behavior and enter this container by using <kbd class="calibre12">-i</kbd> and <kbd class="calibre12">-t</kbd> (<kbd class="calibre12">--tty</kbd>) options (or just <kbd class="calibre12">-it</kbd>):</p>
<pre class="calibre18"><strong class="calibre1">$ docker exec -it 00f343906df3 /bin/bash</strong><br class="title-page-name"/><strong class="calibre1">root@00f343906df3:/usr/local/apache2#</strong></pre>
<p class="calibre2">We should fall into container bash CLI. From here, we can execute other general Linux commands. This trick is very useful for troubleshooting. To exit the container console, just type <kbd class="calibre12">exit</kbd> or press <em class="calibre17">Ctrl </em>+ <em class="calibre17">D</em>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Starting and stopping containers</h1>
                
            
            <article>
                
<p class="calibre2">We can also stop and start running containers by running <kbd class="calibre12">docker stop</kbd> and <kbd class="calibre12">docker start</kbd> commands:</p>
<p class="calibre2"/>
<p class="calibre2"/>
<p class="calibre2">Enter the following command to stop the container:</p>
<pre class="calibre18"><strong class="calibre1">$ docker stop 00f343906df3</strong><br class="title-page-name"/>00f343906df3 </pre>
<p class="calibre2"><span class="calibre11">Enter the following command to start the container:</span></p>
<pre class="calibre18"><strong class="calibre1">$ docker start 00f343906df3</strong><br class="title-page-name"/>00f343906df3</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Docker port mapping</h1>
                
            
            <article>
                
<p class="calibre2">In order to actually benefit from the container, we need to make it publicly accessible from the outside. This is where we will need to use the <kbd class="calibre12">-p</kbd> option with a few arguments while running the <kbd class="calibre12">docker run</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d -p 8080:80 httpd</strong><br class="title-page-name"/>3b1150b5034329cd9e70f90ee21531b8b1ab1d4a85141fd3a362cd40db80e193</pre>
<p class="calibre2">Option <kbd class="calibre12">-p</kbd> maps container port <kbd class="calibre12">80</kbd> to your server port <kbd class="calibre12">8080</kbd>. Verify that you have a <kbd class="calibre12">httpd</kbd> container exposed and a web server running:</p>
<pre class="calibre18"><strong class="calibre1">$ curl localhost:8080</strong><br class="title-page-name"/>&lt;html&gt;&lt;body&gt;&lt;h1&gt;It works!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Inspecting the Docker container</h1>
                
            
            <article>
                
<p class="calibre2">While the container is running, we can inspect its parameters by using the <kbd class="calibre12">docker inspect</kbd> command. The output is provided in JSON format and it gives us a very comprehensive output:</p>
<pre class="calibre18"><strong class="calibre1">$ docker inspect 00f343906df3</strong><br class="title-page-name"/>[<br class="title-page-name"/>   {<br class="title-page-name"/>       "Id": "00f343906df3f26c24e02cd61d6a37bbc36106b3b0372073673c2983cb6f",<br class="title-page-name"/>       ...<br class="title-page-name"/>       output truncated for brevity<br class="title-page-name"/>       ...<br class="title-page-name"/>   }<br class="title-page-name"/>]</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Removing containers</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">In order to delete a container, you can use the <kbd class="calibre12">docker rm</kbd> command. If the container you want to delete is running, you can stop and delete it or use the <kbd class="calibre12">-f</kbd> option and it will do the job:</span></p>
<pre class="calibre18"><strong class="calibre1">$ docker rm 3b1150b50343</strong><br class="title-page-name"/>Error response from daemon: You cannot remove a running container 3b1150b5034329cd9e70f90ee21531b8b1ab1d4a85141fd3a362cd40db80e193. Stop the container before attempting removal or force remove<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre2">Let's try using <kbd class="calibre12">-f</kbd> option.</p>
<pre class="calibre18"><strong class="calibre1">$ docker rm  -f 3b1150b50343</strong></pre>
<p class="calibre2">Another trick you can use to delete all containers, both stopped and running, is the following command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rm -f $(docker ps -qa)</strong><br class="title-page-name"/>830a42f2e727<br class="title-page-name"/>00f343906df3<br class="title-page-name"/>5e3820a43ffc<br class="title-page-name"/>419e7ce2567e</pre>
<p class="calibre2">Verify that all the containers are deleted:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps  -a</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using environment variables</h1>
                
            
            <article>
                
<p class="calibre2"><span class="calibre11">Due to the dynamic and stateless nature of containers, applications cannot rely on either fixed IP addresses or DNS hostnames while communicating with middleware and other application services. Docker lets you store data such as configuration settings, encryption keys, and external resource addresses in environment variables.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Passing environment variables to a container</h1>
                
            
            <article>
                
<p class="calibre2">At runtime, environment variables are exposed to the application inside the container. You can set environment variables in a service's containers with the <em class="calibre17">environment</em> key, just like with <kbd class="calibre12">docker run -e VARIABLE=VALUE</kbd>. You can also pass environment variables from your shell straight through to a service's containers with the environment key by not giving them a value, just like with <kbd class="calibre12">docker run -e VARIABLE</kbd>.</p>
<p class="calibre2">Environment variables are used to set specific application parameters, like IP addresses, for a server to connect the database server address with login credentials.</p>
<p class="calibre2">Some container startup scripts use environment variables to perform the initial configuration of an application.</p>
<p class="calibre2">For example, a <kbd class="calibre12">mariadb</kbd> image is created to use several environment variables to start a container and create users/databases at the start time. This image uses the following important parameters, among others:</p>
<div class="title-page-name">
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Parameter</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Description</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">MYSQL_ROOT_PASSWORD</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">This variable is mandatory and specifies the password that will be set for the MariaDB <kbd class="calibre12">root</kbd> superuser account.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">MYSQL_DATABASE</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">This variable is optional and allows you to specify the name of a database to be created on image startup. If a user/password was supplied (parameters in the row below) then that user will be granted superuser access (corresponding to <kbd class="calibre12">GRANT ALL</kbd>) to this database.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">MYSQL_USER</kbd> and <kbd class="calibre12">MYSQL_PASSWORD</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">These variables are optional and used in conjunction to create a new user and to set that user's password. This user will be granted superuser permissions for the database specified by the <kbd class="calibre12">MYSQL_DATABASE</kbd> variable. Both variables are required for a user to be created.</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="calibre2"> </p>
<p class="calibre2">First, we can try to pull and start a <kbd class="calibre12">mariadb</kbd> container without specifying the password/user/database-related information. It will fail since the image expects the parameters. In this example, we are starting a container in the foreground to be able to see all error messages:</p>
<pre class="calibre18"><strong class="calibre1">$ docker pull mariadb</strong><br class="title-page-name"/>latest: Pulling from docker.io/library/mariadb<br class="title-page-name"/>       ...<br class="title-page-name"/>       output truncated for brevity<br class="title-page-name"/>       ...<br class="title-page-name"/>Digest: sha256:d5f0bc88ba397233677ff75b7b1de693d5e84527ecf2b4f59adebf8d0bcac3c4</pre>
<p class="calibre2">Now try to run <kbd class="calibre12">mariadb</kbd> container without any options and arguments.</p>
<pre class="calibre18"><strong class="calibre1">$ docker run mariadb</strong><br class="title-page-name"/>error: database is uninitialized and password option is not specified<br class="title-page-name"/>You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD</pre>
<p class="calibre2">The <kbd class="calibre12">docker run</kbd> command failed because the MariaDB image initial startup script was not able to find the required variables. This script expects us to have at least the <span class="calibre11">MariaDB</span> root password to start a database server. Let's try to start a database container again by providing all required variables:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d --name mariadb -e MYSQL_ROOT_PASSWORD=password -e MYSQL_DATABASE=example -e </strong>MYSQL_USER=example_user -e MYSQL_PASSWORD=password mariadb<br class="title-page-name"/>721dc752ed0929dbac4d8666741b15e1f371aefa664e497477b417fcafee06ce<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre2">Run the <kbd class="calibre12">docker ps</kbd> command to verify that the container is up and running:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br class="title-page-name"/>721dc752ed09 mariadb "docker-entrypoint.sh" 10 seconds ago Up 9 seconds 3306/tcp mariadb</pre>
<p class="calibre2">The container was created successfully. Run the verification command to check that <kbd class="calibre12">example_user</kbd> has access to the <kbd class="calibre12">example</kbd> database:</p>
<pre class="calibre18"><strong class="calibre1">$ docker exec -it mariadb mysql -uexample_user -ppassword example -e "show databases;"</strong><br class="title-page-name"/>+--------------------+<br class="title-page-name"/>| Database           |<br class="title-page-name"/>+--------------------+<br class="title-page-name"/>| example            |<br class="title-page-name"/>| information_schema |<br class="title-page-name"/>+--------------------+</pre>
<p class="calibre2">The startup script created a user named <kbd class="calibre12">example_user</kbd> with the password <kbd class="calibre12">password</kbd> as we specified in the environment variables. It also configured a password for the root user. The full list of MariaDB image variables you can specify is located at <a href="https://hub.docker.com/_/mariadb/" class="calibre8">https://hub.docker.com/_/mariadb/</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Linking containers</h1>
                
            
            <article>
                
<p class="calibre2">Environment variables adjust settings for a single container. The same approach can be used to start a multi-tier application where one container or application works alongside the other:</p>
<div class="cdpaligncenter2"><img class="alignnone21" src="../images/00026.jpeg"/></div>
<div class="cdpaligncenter1">Multi-tier application example</div>
<p class="calibre2">In a multi-tier application, both the application server container and database server container may need to share variables such as database login credentials. Of course, we can pass all database connectivity settings to the application container using environment variables. It is very easy to make a mistake while passing multiple <kbd class="calibre12">-e</kbd> options to the <kbd class="calibre12">docker run</kbd> command, and it is very time-consuming, not to mention that it is very ineffective. Another option is to use container IP addresses to establish connections. We can gather IP address information using <kbd class="calibre12">docker inspect</kbd> but it will be difficult to track this information in a multi-container environment.</p>
<p class="calibre2">This means that using environment variables is just not enough to build multi-tier applications where containers depend on each other.</p>
<p class="calibre2">Docker has a featured called <em class="calibre17">linked containers</em> to solve this problem. It automatically copies all environment variables from one container to another. Additionally, by linking containers, we can define environment variables based on the other container's IP address and exposed ports.</p>
<p class="calibre2">Using linked containers is done by simply adding the <kbd class="calibre12">--link container:alias</kbd> option to the <kbd class="calibre12">docker run</kbd> command. For example, the following command links to a container named MariaDB using the DB alias:</p>
<pre class="calibre18"><strong class="calibre1"><span>$ docker run --link mariadb:db --name my_application  httpd</span></strong></pre>
<p class="calibre2">The new <kbd class="calibre12">my_application</kbd> container will then get all variables defined from the linked container <kbd class="calibre12">mariadb</kbd>. Those variable names are prefixed by <kbd class="calibre12">DB_ENV_</kbd> so as not to conflict with the new container's own environment variables.</p>
<div class="packt_infobox"><span>Please be aware that the aliases are all uppercase.</span></div>
<p class="calibre2">Variables providing information about container IP addresses and ports are named according to the following scheme:</p>
<ul class="calibre9">
<li class="calibre20"><kbd class="calibre12">{ALIAS}_PORT_{exposed-port}_TCP_ADDR</kbd></li>
<li class="calibre20"><kbd class="calibre12">{ALIAS}_PORT_{exposed-port}_TCP_PORT</kbd></li>
</ul>
<p class="calibre2">Continuing with the MariaDB image example, the application container would get the following variables:</p>
<ul class="calibre9">
<li class="calibre20"><kbd class="calibre12">DB_PORT_3306_TCP_ADDR</kbd></li>
<li class="calibre20"><kbd class="calibre12">DB_PORT_3306_TCP_PORT</kbd></li>
</ul>
<p class="calibre2">If the linked container exposes multiple ports, each of them generates a set of environment variables.</p>
<p class="calibre2">Let's take an example. We will be creating a WordPress container which needs access to a database server. This integration will require shared database access credentials. The first step in creating this application is to create a database server:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rm -f $(docker ps -qa)</strong><br class="title-page-name"/><strong class="calibre1">$ docker run -d --name mariadb -e MYSQL_ROOT_PASSWORD=wordpress -e MYSQL_DATABASE=wordpress -e </strong>MYSQL_USER=wordpress -e MYSQL_PASSWORD=password mariadb<br class="title-page-name"/>221462288bc578511154fe79411de002e05f08642b63a72bc7a8f16f7102e52b</pre>
<p class="calibre2">The next step is to run a WordPress container. In that command, we will link the <kbd class="calibre12">wordpress</kbd> container with the <kbd class="calibre12">mariadb</kbd> container:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d --name wordpress --link mariadb:mysql -p 8080:80 wordpress</strong><br class="title-page-name"/>Unable to find image 'wordpress:latest' locally<br class="title-page-name"/>Trying to pull repository docker.io/library/wordpress ...<br class="title-page-name"/>latest: Pulling from docker.io/library/wordpress<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...<br class="title-page-name"/>Digest: sha256:670e4156377063df1a02f036354c52722de0348d46222ba30ef6a925c24cd46a<br class="title-page-name"/>1f69aec1cb88d273de499ca7ab1f52131a87103d865e4d64a7cf5ab7b430983a</pre>
<p class="calibre2">Let's check container environments with the <kbd class="calibre12">docker exec</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker exec -it wordpress env|grep -i mysql</strong><br class="title-page-name"/>MYSQL_PORT=tcp://172.17.0.2:3306<br class="title-page-name"/>MYSQL_PORT_3306_TCP=tcp://172.17.0.2:3306<br class="title-page-name"/>MYSQL_PORT_3306_TCP_ADDR=172.17.0.2<br class="title-page-name"/>MYSQL_PORT_3306_TCP_PORT=3306<br class="title-page-name"/>MYSQL_PORT_3306_TCP_PROTO=tcp<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...</pre>
<div class="packt_infobox">You can see all these variables because the WordPress container startup script handles the <kbd class="calibre26">mysql</kbd> link. We can see here that the link set a number of <kbd class="calibre26">MYSQL_ENV</kbd> and <kbd class="calibre26">MYSQL_PORT</kbd> variables, which are used by the WordPress startup script.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using persistent storage</h1>
                
            
            <article>
                
<p class="calibre2">In the previous sections, we saw that containers can be created and deleted easily. But when a container is deleted, all the data associated with that container disappears too. That is why a lot of people refer to containers as a stateless architecture. But we can change this behavior and keep all the data by using persistent volumes. In order to enable persistent storage for a Docker container, we need to use the <kbd class="calibre12">-v</kbd> option, which binds the container filesystem to the host filesystem that runs that container.</p>
<p class="calibre2">In the next example, we will create a MariaDB container with persistent storage in the <kbd class="calibre12">/mnt/data</kbd> folder on the host. Then, we delete the MariaDB container and recreate it again using the same persistent storage.</p>
<p class="calibre2">First, remove all previously created containers:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rm -f $(docker ps -aq)</strong></pre>
<p class="calibre2">We have to prepare persistent storage on the node before we begin. Be aware that we need to give read/write permissions to the persistent storage directory. The MariaDB application works with a MySQL user with <em class="calibre17">UID=999</em> inside the container. Also, it is important to mention that the special SE Linux security context <kbd class="calibre12">svirt_sandbox_file_t</kbd> is required. This can be achieved using the following commands:</p>
<pre class="calibre18"><strong class="calibre1"># mkdir /mnt/data</strong><br class="title-page-name"/><strong class="calibre1"># chown 999:999 /mnt/data</strong><br class="title-page-name"/><strong class="calibre1"># chcon -Rt svirt_sandbox_file_t /mnt/data</strong></pre>
<p class="calibre2">The next step is to create the container running the MariaDB service:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d -v /mnt/data:/var/lib/mysql --name mariadb -e MYSQL_ROOT_PASSWORD=password mariadb</strong><br class="title-page-name"/>41139532924ef461420fbcaaa473d3030d10f853e1c98b6731840b0932973309<strong class="calibre1"><br class="title-page-name"/></strong></pre>
<p class="calibre2">Run the <kbd class="calibre12">docker ps</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker ps</strong><br class="title-page-name"/>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES<br class="title-page-name"/>41139532924e mariadb "docker-entrypoint.sh" 4 seconds ago Up 3 seconds 3306/tcp mariadb</pre>
<p class="calibre2">Create a new database and verify the existence of this new DB:</p>
<pre class="calibre18"><strong class="calibre1">$ docker exec -it mariadb mysql -uroot -ppassword -e "create database persistent;"</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ docker exec -it mariadb mysql -uroot -ppassword -e "show databases;"</strong><br class="title-page-name"/>+--------------------+<br class="title-page-name"/>| Database           |<br class="title-page-name"/>+--------------------+<br class="title-page-name"/>| information_schema |<br class="title-page-name"/>| mysql              |<br class="title-page-name"/>| performance_schema |<br class="title-page-name"/>| persistent         |<br class="title-page-name"/>+--------------------+</pre>
<p class="calibre2">Verify that there is new data in the <kbd class="calibre12">/mnt/data</kbd> directory created by the <kbd class="calibre12">mariadb</kbd> container. This is how we make the data persistent:</p>
<pre class="calibre18"><strong class="calibre1">$ ls -l /mnt/data/</strong><br class="title-page-name"/>drwx------. 2 polkitd ssh_keys 4096 Mar 6 16:18 mysql<br class="title-page-name"/>drwx------. 2 polkitd ssh_keys 20 Mar 6 16:18 performance_schema<br class="title-page-name"/>drwx------. 2 polkitd ssh_keys 20 Mar 6 16:23 persistent<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...</pre>
<p class="calibre2">Delete the <kbd class="calibre12">mariadb</kbd> container and verify that all files will be kept:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rm -f mariadb</strong><br class="title-page-name"/>mariadb<br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">$ ls -l /mnt/data/</strong><br class="title-page-name"/>drwx------. 2 polkitd ssh_keys 4096 Mar 6 16:18 mysql<br class="title-page-name"/>drwx------. 2 polkitd ssh_keys 20 Mar 6 16:18 performance_schema<br class="title-page-name"/>drwx------. 2 polkitd ssh_keys 20 Mar 6 16:23 persistent<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...</pre>
<p class="calibre2">We are going to rerun the container and verify whether the previously created database <em class="calibre17">persistent</em> survived container removal and creation:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d -v /mnt/data:/var/lib/mysql --name mariadb mariadb</strong><br class="title-page-name"/>c12292f089ccbe294cf3b9a80b9eb44e33c1493570415109effa7f397579b235</pre>
<p class="calibre2">As you can see, <span class="calibre11">the database with the name </span><kbd class="calibre12">persistent</kbd> is still here.</p>
<p class="calibre2">Remove all the containers before you proceed to the next section:</p>
<pre class="calibre18"><strong class="calibre1">$ docker rm -f $(docker ps -aq)</strong></pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Creating a custom Docker image</h1>
                
            
            <article>
                
<p class="calibre2">The Docker community has Docker images for most popular software applications. These include, for example, images for web servers (Apache, Nginx, and so on), enterprise application platforms (JBoss EAP, Tomcat), images with programming languages (Perl, PHP, Python), and so on.</p>
<p class="calibre2">In most cases, you do not need to build your own Docker images to run standard software. But if you have a business need that requires having a custom application, you probably need to create your own Docker image.</p>
<p class="calibre2">There are a number of ways to create a new docker image:</p>
<ul class="calibre9">
<li class="calibre20"><strong class="calibre1">Commit</strong>: Creating a Docker image from a running container. Docker allows you to <em class="calibre28">convert</em> a working container to a Docker image using the <kbd class="calibre12">docker commit</kbd> command. This means that image layers will be stored as a separate docker image. This approach is the easiest way to create a new image.</li>
<li class="calibre20"><strong class="calibre1">Import/Export</strong>: This is similar to the first one but uses another Docker command. Running container layers will be saved to a filesystem using docker export and then the image will be recreated using docker import. We do not recommend this method for creating a new image since the first one is simpler.</li>
<li class="calibre20"><strong class="calibre1">Dockerfile</strong>: Building a Docker image using a Dockerfile. Dockerfile is a plain text file that contains a number of steps sometimes called instructions. These instructions can run a particular command inside a container or copy files to a container. A user can initiate a build process using Dockerfile and the Docker daemon will run all instructions in the Dockerfile in a temporary container. Then this container is converted to a docker image. This is the most common way to create a new docker image. Building custom docker images from Dockerfile will be described in details in a later chapter.</li>
<li class="calibre20"><strong class="calibre1">From scratch</strong>: Building a base Docker image. In the two previous methods, Docker images are created using Docker images, and these docker images were created from a base Docker image. You cannot modify this base image unless you create one yourself. If you want to know what is inside your image, you might want to create a base image instead. There are two ways to do so:
<ul class="calibre29">
<li class="calibre20">Create a base image layer using the <kbd class="calibre12">tar</kbd> command.</li>
<li class="calibre20">Use special Dockerfile instructions (from scratch). Both methods will be described in later chapters.</li>
</ul>
</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Customizing images using docker commit</h1>
                
            
            <article>
                
<p class="calibre2">The general recommendation is that all Docker images should be built from a Dockerfile to create clean and proper image layers without unwanted temporary and log files, despite the fact that some vendors deliver their Docker images without an available Dockerfile . If there is a need to modify that existing image, you can use the standard <kbd class="calibre12">docker commit</kbd> functionality to convert an existing container to a new image.</p>
<p class="calibre2">As an example, we will try to modify our existing httpd container and make an image from it.</p>
<p class="calibre2">First, we need to get the httpd image:</p>
<pre class="calibre18"><strong class="calibre1">$ docker pull httpd</strong><br class="title-page-name"/>Using default tag: latest<br class="title-page-name"/>Trying to pull repository docker.io/library/httpd ...<br class="title-page-name"/>latest: Pulling from docker.io/library/httpd<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...<br class="title-page-name"/>Digest: sha256:6e61d60e4142ea44e8e69b22f1e739d89e1dc8a2764182d7eecc83a5bb31181e</pre>
<p class="calibre2">Next, we need a container to be running. That container will be used as a template for a future image</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d --name httpd httpd</strong><br class="title-page-name"/>c725209cf0f89612dba981c9bed1f42ac3281f59e5489d41487938aed1e47641</pre>
<p class="calibre2">Now we can connect to the container and modify its layers. As an example, we will update <kbd class="calibre12">index.html</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ docker exec -it httpd /bin/sh</strong><br class="title-page-name"/><strong class="calibre1"># echo "This is a custom image" &gt; htdocs/index.html</strong><br class="title-page-name"/><strong class="calibre1"># exit</strong></pre>
<p class="calibre2">Let's see the changes we made using the <kbd class="calibre12">docker diff</kbd> command. This command shows you all files that were modified from the original image. The output looks like this:</p>
<pre class="calibre18"><strong class="calibre1">$ docker diff httpd</strong><br class="title-page-name"/>C /usr<br class="title-page-name"/>C /usr/local<br class="title-page-name"/>C /usr/local/apache2<br class="title-page-name"/>C /usr/local/apache2/htdocs<br class="title-page-name"/>C /usr/local/apache2/htdocs/index.html<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...</pre>
<p class="calibre2">The following table shows the file states of the <kbd class="calibre12">docker diff</kbd> command:</p>
<div class="title-page-name">
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Symbol</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Description</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">A</strong></p>
</td>
<td class="calibre25">
<p class="calibre2">A file or directory was added</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">D</strong></p>
</td>
<td class="calibre25">
<p class="calibre2">A file or directory was deleted</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">C</strong></p>
</td>
<td class="calibre25">
<p class="calibre2">A file or directory was changed</p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="calibre2"> </p>
<p class="calibre2">In our case, <kbd class="calibre12">docker diff httpd</kbd> command shows that <kbd class="calibre12"><span>index.html</span></kbd> was changed<span class="calibre11">.</span></p>
<p class="calibre2">Create a new image from the running container:</p>
<pre class="calibre18"><strong class="calibre1">$ docker commit httpd custom_image</strong><br class="title-page-name"/>sha256:ffd3a523f9848776d65de8302253de9dc78e4948a792569ee46fad5c099312f6</pre>
<p class="calibre2">Verify that the new image has been created:</p>
<pre class="calibre18"><strong class="calibre1">$ docker images</strong><br class="title-page-name"/>REPOSITORY TAG IMAGE ID CREATED SIZE<br class="title-page-name"/>custom_image latest ffd3a523f984 3 seconds ago 177.4 MB<br class="title-page-name"/>docker.io/httpd latest 01154c38b473 2 weeks ago 177.4 MB</pre>
<p class="calibre2">The final step is to verify that the image works properly:</p>
<pre class="calibre18"><strong class="calibre1">$ docker run -d --name custom_httpd -p 80:8080 custom_image</strong><br class="title-page-name"/>78fc5731d62e5a6377a7de152c0ba25d350603e6d97fa26967e06a82c8257e71</pre>
<pre class="calibre18"><strong class="calibre1">$ curl localhost:8080</strong><br class="title-page-name"/>This is a custom image</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Dockerfile build</h1>
                
            
            <article>
                
<p class="calibre2">Usually, those who use Docker containers expect to have a high-level of automation, and the <kbd class="calibre12">docker commit</kbd> command is difficult to automate. Luckily, Docker can build images automatically by reading instructions from a special file usually called a Dockerfile. A Dockerfile is a text document that contains all the commands a user can call on the command line to assemble an image. Using docker build, users can create an automated build that executes several command-line instructions in succession. On CentOS 7, you can learn a lot more using the Dockerfile built-in documentation page <kbd class="calibre12">man Dockerfile</kbd>.</p>
<p class="calibre2">A Dockerfile has a number of instructions that help Docker to build an image according to your requirements. <span class="calibre11">Here is a Dockerfile example, which allows us to achieve the same result as in the previous section:</span></p>
<pre class="calibre18"><strong class="calibre1">$ cat Dockerfile</strong><br class="title-page-name"/>FROM httpd<br class="title-page-name"/>RUN echo "This is a custom image" &gt; /usr/local/apache2/htdocs/index.html</pre>
<p class="calibre2">Once this Dockerfile is created, we can build a custom image using the <kbd class="calibre12">docker build</kbd> command:</p>
<pre class="calibre18"><strong class="calibre1">$ docker build -t custom_image2 .</strong> <br class="title-page-name"/>Sending build context to Docker daemon 2.048 kB<br class="title-page-name"/>Step 1 : FROM httpd<br class="title-page-name"/> ---&gt; 01154c38b473<br class="title-page-name"/>Step 2 : RUN echo "This is a custom image" &gt; /usr/local/apache2/htdocs/index.html<br class="title-page-name"/> ---&gt; Using cache<br class="title-page-name"/> ---&gt; 6b9be8efcb3a<br class="title-page-name"/>Successfully built 6b9be8efcb3a</pre>
<div class="packt_infobox">Please note that the <kbd class="calibre26">.</kbd> at the end of the first line is important as it specifies the working directory. Alternatively, you can use <kbd class="calibre26">./</kbd> or even <kbd class="calibre26">$(pwd)</kbd>. So the full commands are going to be: <br class="title-page-name"/>
<br class="title-page-name"/>
<kbd class="calibre26"><span>docker build -t custom_image2 .</span></kbd><br class="title-page-name"/>
or<br class="title-page-name"/>
<br class="title-page-name"/>
<kbd class="calibre26">docker build -t custom_image2 ./</kbd><br class="title-page-name"/>
<span>or<br class="title-page-name"/></span><br class="title-page-name"/>
<kbd class="calibre26">docker build -t custom_image2 $(pwd)</kbd></div>
<pre class="calibre18"><strong class="calibre1">$ docker images</strong><br class="title-page-name"/>REPOSITORY TAG IMAGE ID CREATED SIZE<br class="title-page-name"/>custom_image2 latest 6b9be8efcb3a 2 minutes ago 177.4 MB<br class="title-page-name"/>custom_image latest ffd3a523f984 19 minutes ago 177.4 MB<br class="title-page-name"/>docker.io/httpd latest 01154c38b473 2 weeks ago 177.4 MB</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Using Docker history </h1>
                
            
            <article>
                
<p class="calibre2">We can check the history of image modifications using <kbd class="calibre12">docker history</kbd>:</p>
<pre class="calibre18"><strong class="calibre1">$ docker history custom_image2</strong><br class="title-page-name"/>IMAGE CREATED CREATED BY SIZE COMMENT<br class="title-page-name"/>6b9be8efcb3a 21 hours ago /bin/sh -c echo "This is a custom image" &gt; /u 23 B<br class="title-page-name"/>01154c38b473 2 weeks ago /bin/sh -c #(nop) CMD ["httpd-foreground"] 0 B<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...</pre>
<p class="calibre2">Note that a new layer, <kbd class="calibre12">6b9be8efcb3a</kbd>, is added. This is where we change the content of the <kbd class="calibre12">index.html</kbd> file in comparison to the original <kbd class="calibre12">httpd</kbd> image.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Dockerfile instructions </h1>
                
            
            <article>
                
<p class="calibre2">Some Dockerfile instructions are shown in the table:</p>
<div class="title-page-name">
<table border="1" class="calibre22">
<tbody class="calibre23">
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Instruction</strong></p>
</td>
<td class="calibre25">
<p class="calibre2"><strong class="calibre4">Description and examples</strong></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">FROM image[:tag]</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">It sets the base image used in the build process.</p>
<p class="calibre2">Examples:</p>
<p class="calibre2">FROM httpd</p>
<p class="calibre2">FROM httpd:2.2</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">RUN &lt;command&gt; &lt;parameters&gt;</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">The RUN instruction executes any commands in a new layer on top of the current image and commits the results.</p>
<p class="calibre2">Examples:</p>
<p class="calibre2">RUN <kbd class="calibre12">yum install -y httpd &amp;&amp;\</kbd></p>
<p class="calibre2"> <kbd class="calibre12">echo "custom answer" &gt;/var/www/html/index.html</kbd></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">RUN ["command", "param1", "param2"]</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">This is the same as the last one but in Docker format.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">COPY &lt;src&gt; &lt;dst&gt;</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">The COPY instruction copies new files from <kbd class="calibre12">&lt;src&gt;</kbd> and adds them to the filesystem of the container at the path <kbd class="calibre12">&lt;dest&gt;</kbd>. The <kbd class="calibre12">&lt;src&gt;</kbd> must be the path to a file or directory relative to the source directory that is being built (the context of the build) or a remote file URL.</p>
<p class="calibre2">Examples:</p>
<p class="calibre2">COPY <kbd class="calibre12">index.html /var/www/html/index.html</kbd></p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">ENTRYPOINT ["executable", "param1", "param2"]</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">An ENTRYPOINT helps you configure a container that can be run as an executable. When you specify an ENTRYPOINT, the whole container runs as if it were only that executable.</p>
<p class="calibre2">Examples:</p>
<p class="calibre2">ENTRYPOINT <kbd class="calibre12">["/usr/sbin/httpd","-D","FOREGROUND"]</kbd></p>
<p class="calibre2">In most cases the default value of ENTRYPOINT is <kbd class="calibre12">/bin/sh -c</kbd>, which means that CMD will be interpreted as a command to run</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">EXPOSE &lt;port&gt;</kbd></p>
</td>
<td class="calibre25">
<p class="calibre2">This instruction informs a Docker daemon that an application will be listening on this port at runtime. This is not very useful when working with standalone Docker containers because port publishing is performed via the <kbd class="calibre12">-p</kbd> argument of the CLI, but it is used by OpenShift when creating a service for a new application deployed from a Docker image and by Docker itself when exporting default environment variables inside a container.</p>
</td>
</tr>
<tr class="calibre24">
<td class="calibre25">
<p class="calibre2"><kbd class="calibre12">CMD ["executable", "param1", "param2"]</kbd></p>
<br class="title-page-name"/>
<p class="calibre2"> </p>
</td>
<td class="calibre25">
<p class="calibre2">Provides arguments to an <kbd class="calibre12">ENTRYPOINT</kbd> command and can be overridden at runtime with the <kbd class="calibre12">docker run</kbd> command.</p>
<p class="calibre2">Example:</p>
<p class="calibre2"><kbd class="calibre12">CMD  ["/usr/sbin/httpd","-D","FOREGROUND"]</kbd></p>
</td>
</tr>
</tbody>
</table>
</div>
<p class="calibre2"> </p>
<p class="calibre2">When the <kbd class="calibre12">docker build</kbd> command is run, Docker reads the provided Dockerfile from top to bottom, creating a separate layer for every instruction and placing it in the internal cache. If an instruction from Dockerfile is updated, it invalidates the respective caching layer and every subsequent one, forcing Docker to rebuild them when the docker build command is run again. Therefore, it's more effective to place the most malleable instructions at the end of Dockerfile, so that the number of invalidated layers is minimized and cache usage is maximized. For example, suppose we have a Dockerfile with the following contents:</p>
<pre class="calibre18"><strong class="calibre1">$ cat Dockerfile</strong><br class="title-page-name"/>FROM centos:latest<br class="title-page-name"/>RUN yum -y update<br class="title-page-name"/>RUN yum -y install nginx, mariadb, php5, php5-mysql<br class="title-page-name"/>RUN yum -y install httpd<br class="title-page-name"/>CMD ["nginx", "-g", "daemon off;"]</pre>
<p class="calibre2">In the example, if you choose to use MySQL instead of MariaDB, the layer created by the second RUN command, as well as the third one, will be invalidated, which for complex images means a noticeably longer build process.</p>
<p class="calibre2">Consider the following example. Docker includes images for minimal OSes. These base images can be used to build custom images on top of them. In the example, we will be using a CentOS 7 base image to create a web server container from scratch:</p>
<ol class="calibre13">
<li value="1" class="calibre20">First, we need to create a <kbd class="calibre12">project</kbd> directory:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ mkdir custom_project; cd custom_project</strong></pre>
<p class="calibre27">Then, we create a Dockerfile with the following content:</p>
<pre class="calibre19"><strong class="calibre1">$ cat Dockerfile</strong><br class="title-page-name"/>FROM centos:7<br class="title-page-name"/>RUN yum install httpd -y<br class="title-page-name"/>COPY index.html /var/www/html/index.html<br class="title-page-name"/>ENTRYPOINT ["/usr/sbin/httpd","-D","FOREGROUND"]</pre>
<ol start="2" class="calibre13">
<li value="2" class="calibre10">Create the <kbd class="calibre12">index.html</kbd> file:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ echo "A new cool image" &gt; index.html</strong></pre>
<ol start="3" class="calibre13">
<li value="3" class="calibre10">Build the image using <kbd class="calibre12">docker build</kbd>:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ docker build -t new_httpd_image .</strong><br class="title-page-name"/>Sending build context to Docker daemon 3.072 kB<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...<br class="title-page-name"/>Successfully built 4f2f77cd3026</pre>
<ol start="4" class="calibre13">
<li value="4" class="calibre10">Finally, we can check that the new image exists and has all the required image layers:</li>
</ol>
<pre class="calibre19"><strong class="calibre1">$ docker history new_httpd_image</strong><br class="title-page-name"/>IMAGE CREATED CREATED BY SIZE COMMENT<br class="title-page-name"/>4f2f77cd3026 20 hours ago /bin/sh -c #(nop) ENTRYPOINT ["/usr/sbin/htt 0 B<br class="title-page-name"/>8f6eaacaae3c 20 hours ago /bin/sh -c #(nop) COPY file:318d7f73d4297ec33 17 B<br class="title-page-name"/>e19d80cc688a 20 hours ago /bin/sh -c yum install httpd -y 129 MB<br class="title-page-name"/>...<br class="title-page-name"/>output truncated for brevity<br class="title-page-name"/>...</pre>
<div class="packt_infobox">The top three layers are the instructions we added in the Dockerfile.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            <article>
                
<p class="calibre2">In this chapter, we have discussed container architecture, worked with Docker images and containers, examined different Docker registries, learned how to manage persistent storage for containers, and finally looked at how to build a Docker image with Dockerfile. All these skills will be required in <a target="_blank" href="part0093.html#2OM4A0-78aafb146b304cdeb9b3261a70edabde" class="calibre8">Chapter 3</a>, <em class="calibre17">CRI-O Overview</em>, where we start working with Kubernetes. Kubernetes is an essential and critical OpenShift component. It all works like a snowball: Docker skills are required by Kubernetes, and Kubernetes skills are required by Openshift.  </p>
<p class="calibre2">In the next chapter, we are going to work with Kubernetes. Kubernetes is an industry-standard orchestration layer for Docker containers. This is where you are going to install and run some basic Docker containers using Kubernetes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Questions</h1>
                
            
            <article>
                
<ol class="calibre13">
<li value="1" class="calibre10">What are the three main Docker components? choose one:
<ol class="calibre14">
<li value="1" class="calibre10">Docker Container, Docker Image, Docker Registry</li>
<li value="2" class="calibre10">Docker Hub, Docker Image, Docker <span>Registry</span></li>
<li value="3" class="calibre10">Docker Runtime, Docker Image, Docker <span>Hub</span></li>
<li value="4" class="calibre10">Docker Container, Docker Image, Docker <span>Hub</span></li>
</ol>
</li>
<li value="2" class="calibre10">Choose two valid registry types:
<ol class="calibre14">
<li value="1" class="calibre10">Personal Registry</li>
<li value="2" class="calibre10">Private Registry</li>
<li value="3" class="calibre10">Public Registry</li>
<li value="4" class="calibre10">Security Registry</li>
</ol>
</li>
<li value="3" class="calibre10">The main purpose of Docker Persistent Storage is to make sure that an application data is saved if a container dies:
<ol class="calibre14">
<li value="1" class="calibre10">True</li>
<li value="2" class="calibre10">False</li>
</ol>
</li>
<li value="4" class="calibre10">What Linux feature controls resource limitations for a Docker container? choose one:
<ol class="calibre14">
<li value="1" class="calibre10">Cgroups</li>
<li value="2" class="calibre10">Namespaces</li>
<li value="3" class="calibre10">SELinux</li>
<li value="4" class="calibre10">chroot</li>
</ol>
</li>
<li value="5" class="calibre10">What commands can be used to build a custom image from a Dockerfile? choose two: 
<ol class="calibre14">
<li value="1" class="calibre10">docker build -t new_httpd_image .</li>
<li value="2" class="calibre10">docker build -t new_httpd_image .\</li>
<li value="3" class="calibre10">docker build -t new_httpd_image ($pwd)</li>
<li value="4" class="calibre10">docker build -t new_httpd_image ./</li>
</ol>
</li>
<li value="6" class="calibre10">The <kbd class="calibre12">docker commit</kbd> command saves Docker images to an upstream repository:
<ol class="calibre14">
<li value="1" class="calibre10">True</li>
<li value="2" class="calibre10">False</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    </header><h1 class="header-title" id="calibre_pb_0">Further reading</h1>
                
            
            <article>
                
<p class="calibre2">Since we are covering the very basics of Docker containers, you may be interested in diving into specific topics. Here's a list of links that may be helpful to look through to learn more about Docker and containers in general:</p>
<ul class="calibre9">
<li class="calibre10"><strong class="calibre1">Docker overview</strong>: <a href="https://docs.docker.com/engine/docker-overview/" class="calibre8">https://docs.docker.com/engine/docker-overview/</a></li>
<li class="calibre10"><strong class="calibre1">Docker CLI</strong>: <a href="https://docs.docker.com/engine/reference/commandline/cli/" class="calibre8">https://docs.docker.com/engine/reference/commandline/cli/</a></li>
<li class="calibre10"><strong class="calibre1">Docker Storage</strong>: <a href="https://docs.docker.com/storage/volumes/" class="calibre8">https://docs.docker.com/storage/volumes/</a></li>
<li class="calibre10"><strong class="calibre1">Docker storage drivers</strong>: <a href="https://docs.docker.com/storage/storagedriver/select-storage-driver/" class="calibre8">https://docs.docker.com/storage/storagedriver/select-storage-driver/</a></li>
</ul>


            </article>

            
        </section>
    </body></html>