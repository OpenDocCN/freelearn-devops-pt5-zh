<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch08"/>Chapter 8. What's Next?</h1></div></div></div><p>So far, we have run our PaaS on a single host, which can be a problem if we need to scale out. There is a lot happening in this space, and I have selected a few projects that I will introduce in this chapter. These projects vary a lot in how mature they are, one is ready for use in production while the other is in a prototype state. In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is a Twelve-Factor app?</li><li class="listitem" style="list-style-type: disc">Flynn</li><li class="listitem" style="list-style-type: disc">Deis</li><li class="listitem" style="list-style-type: disc">Rocket</li><li class="listitem" style="list-style-type: disc">Orchestration tools</li></ul></div><div><div><div><div><h1 class="title"><a id="ch08lvl1sec49"/>What is a Twelve-Factor app?</h1></div></div></div><p>Many of today's apps are, in fact, web apps that you run in your web browser. Gmail, Slack, Wunderlist, Trello, and so on are all web apps or software-as-a-service.</p><p>It is these kind of apps that are suitable to be run on a PaaS.</p><p>The Twelve-Factor app <a class="indexterm" id="id373"/>is a methodology for building software-as-a-service apps that fulfill the following criteria:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use declarative formats to set up automation as well as to minimize the time and cost for new developers who join the project</li><li class="listitem" style="list-style-type: disc">Have a clean contract with the underlying operating system, offering maximum portability between execution environments</li><li class="listitem" style="list-style-type: disc">Suitable for deployment on modern cloud platforms, obviating the need for servers and systems administration</li><li class="listitem" style="list-style-type: disc">Minimize divergence between development and production, enabling continuous deployment for maximum agility</li><li class="listitem" style="list-style-type: disc">Scale up without significant changes to tooling, architecture, or development practices</li></ul></div><p>The Twelve Factors are <a class="indexterm" id="id374"/>defined as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Codebase</strong> (One codebase tracked in revision control, many deploys): This puts your <a class="indexterm" id="id375"/>code in a version control system such as Git.</li><li class="listitem" style="list-style-type: disc"><strong>Dependencies</strong> (Explicitly declare and isolate dependencies): This lists all the versions <a class="indexterm" id="id376"/>of all the libraries that your app depends on in a single place.</li><li class="listitem" style="list-style-type: disc"><strong>Config</strong> (Store config in the environment): Since config will vary between environments<a class="indexterm" id="id377"/> such as the username or pass to a database, it should not be part of the code. You can set the config file in environment variables and have your app read them in at runtime.</li><li class="listitem" style="list-style-type: disc"><strong>Backing Services</strong> (Treat backing services as attached resources): These have all the backing services, such as mail server, database, and cache system, among <a class="indexterm" id="id378"/>others. These will be referenced by a URL endpoint. This way your code doesn't have to care whether the backing service is running on the same machine or across the world.</li><li class="listitem" style="list-style-type: disc"><strong>Build, release, run</strong> (Strictly separate build and run stages): The build stage creates <a class="indexterm" id="id379"/>bundles, assets, and binaries. This is the developer's<a class="indexterm" id="id380"/> job. When you've placed a package on a<a class="indexterm" id="id381"/> server, you are ready to enter the run stage by starting your application and making it available on the server. This stage should be as easy as possible so that anyone can do it.</li><li class="listitem" style="list-style-type: disc"><strong>Processes</strong> (Execute the app as one or more stateless processes): As stated earlier in<a class="indexterm" id="id382"/> this book, you should separate your application data from your application service, that is, it makes the service stateless. All the states should be in the shared storages and databases.</li><li class="listitem" style="list-style-type: disc"><strong>Port binding</strong> (Export services via port binding): An example is backing services; your <a class="indexterm" id="id383"/>service should be reachable via a URL endpoint.</li><li class="listitem" style="list-style-type: disc"><strong>Concurrency</strong> (Scale out via the process model): This keeps every process as an independent <a class="indexterm" id="id384"/>service. This way you can scale just the parts of your app that really need to be scaled.</li><li class="listitem" style="list-style-type: disc"><strong>Disposability</strong> (Maximize robustness with a fast startup and graceful shutdown): This<a class="indexterm" id="id385"/> is for app startup, which should be fast, and your app should be able to recover from a crash by itself.</li><li class="listitem" style="list-style-type: disc"><strong>Dev/prod parity</strong> (Keep development, staging, and production as similar as possible): This keeps your development environment and setup as equal as possible to <a class="indexterm" id="id386"/>your production environment and setup. Docker really excels here.</li><li class="listitem" style="list-style-type: disc"><strong>Logs</strong> (Treat logs as event streams): Place your app's error logs into a central place <a class="indexterm" id="id387"/>where you get notified when a new error has occurred.</li><li class="listitem" style="list-style-type: disc"><strong>Admin processes</strong> (Run admin/management tasks as one-off processes): If you are <a class="indexterm" id="id388"/>doing administrative tasks, run them on a machine in the production environment with the latest code base. You should run queries directly against the database.</li></ul></div><p>I encourage you to go to <a class="ulink" href="http://12factor.net">http://12factor.net</a> in order to read more about each one of the<a class="indexterm" id="id389"/> Twelve Factors. It's a good read; you will get an understanding of why some design decisions were made on the following projects.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec50"/>Flynn</h1></div></div></div><div><img alt="Flynn" src="img/3946OT_08_01.jpg"/></div><p>The guy who<a class="indexterm" id="id390"/> created Dokku, Jeff Lindsay, has also co-created Flynn. Flynn is like a super-Dokku that, among other things, lets you run your PaaS on multiple hosts.</p><div><blockquote class="blockquote"><p><em>"Flynn is two things:</em></p><p><em>A distribution of components that out-of-the-box gives companies a reasonable starting point for an internal platform for running their applications and services.</em></p><p><em>The banner for a collection of independent projects that together make up a toolkit or loose framework for building distributed systems.</em></p><p><em>Flynn is both a whole and many parts, depending on what is most useful for you. The common goal is to democratize years of experience and best practices in building distributed systems. It is the software layer between operators and developers that makes both their lives easier."</em></p></blockquote></div><p>I have tried using Flynn a few times, but I have always gone back to using Dokku again because I find Dokku <a class="indexterm" id="id391"/>easier to use, and my clients don't need the extra features <a class="indexterm" id="id392"/>such as multihost PaaS.</p><p>URL: <a class="ulink" href="http://flynn.io">http://flynn.io</a>
</p><p>Status: This is not suitable for use in the production environment because it's in a beta stage.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec51"/>Deis</h1></div></div></div><div><img alt="Deis" src="img/3946OT_08_02.jpg"/></div><p>Deis is built <a class="indexterm" id="id393"/>on a lightweight Linux distribution that is built to run containers, called CoreOS, and on Docker to take advantage of the distributed services, such as etcd, available there.</p><div><blockquote class="blockquote"><p><em>"Deis is a lightweight application platform that deploys and scales Twelve-Factor apps as Docker containers across a cluster of CoreOS machines."</em></p></blockquote></div><p>I found Deis to be a very promising project and would like to work with it more. I have barely touched it but what I have seen so far looks good.</p><p>Deis can deploy any language or framework running on Linux using Docker, and it also includes Heroku buildpacks for Ruby, Python, Node.js, Java, Clojure, Scala, Play, PHP, Perl, Dart, and Go.</p><p>The workflow is Heroku-like and you just need to deploy twelve-factor apps, that is, save the application state in a backing service.</p><p>
<strong>Fun fact</strong>: Deis financially backs/supports Dokku.</p><p>
<strong>URL</strong>: <a class="ulink" href="http://deis.io">http://deis.io</a>
</p><p>
<strong>State</strong>: Deis is <a class="indexterm" id="id394"/>ready for production from version 1.0.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec52"/>Rocket</h1></div></div></div><div><img alt="Rocket" src="img/3946OT_08_03.jpg"/></div><p>CoreOS has been one of the most popular ways to run a multihost Docker PaaS. They have done excellent <a class="indexterm" id="id395"/>work and have built some multihost PaaS tools, such as Deis, that use CoreOS tools and services to deliver their version of PaaS.</p><p>In December 2014, the CoreOS team decided to announce their own container runtime: Rocket. Rocket is a direct competitor to the original Docker. The reason why they are launching Rocket is because they believe Docker has lost its initial idea: running reusable standard containers. The CoreOS team believes that Docker is stepping away from the initial idea by adding more and more features and services around the Docker environment.</p><div><blockquote class="blockquote"><p><em>"Rocket is a new container runtime, designed for composability, security, and speed. Today we are releasing a prototype version on GitHub to begin gathering feedback from our community and explain why we are building Rocket."</em></p></blockquote></div><p>According to the CoreOS team, they will continue to have CoreOS to be the perfect thing to run Docker. I guess <a class="indexterm" id="id396"/>we will see what happens in the future, but I hope they stand by their words.</p><p>
<strong>URL</strong>: <a class="ulink" href="https://github.com/coreos/rocket">https://github.com/coreos/rocket</a>
</p><p>
<strong>State</strong>: Rocket is in its very early state and not ready for production.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec53"/>Orchestration tools</h1></div></div></div><p>The tools I have <a class="indexterm" id="id397"/>introduced now are tools that will help you keep your mind on the code and give you an easy way to deploy your apps to production. If you are more interested in an orchestration tool—a tool that helps you manage container clusters—there are a few of them out there as well. The tools that currently come to mind are Google's Kubernetes, Apache Mesos/Marathon, CoreOS Fleet, and the soon to be released Swarm from Docker.</p></div>
<div><div><div><div><h1 class="title"><a id="ch08lvl1sec54"/>Summary</h1></div></div></div><p>When you feel it's time to move your PaaS from a single host to scale across multiple hosts, these tools are what you should be looking for. I'm sure some worthy competitors will pop up in the future since this is a hot area right now.</p></div></body></html>