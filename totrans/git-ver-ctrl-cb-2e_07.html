<html><head></head><body>
        

                            
                    <h1 class="header-title">Enhancing Your Daily Work with Git Hooks, Aliases, and Scripts</h1>
                
            
            
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Using a branch description in a commit message</li>
<li>Creating a dynamic commit message template</li>
<li>Using external information in a commit message</li>
<li>Preventing the push of specific commits</li>
<li>Configuring and using Git aliases</li>
<li>Configuring and using Git scripts</li>
<li>Setting up and using a commit template</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In order to work efficiently in a corporate environment, there are certain prerequisites, or rules, regarding any code that is produced. It should be able to compile and pass specific sets of unit tests. There should also be certain documentation in the commit messages, such as references to a bug fix ID or an instance. Most of these rules can be automated using scripts. But why not put these rules into the process? In this chapter, you will see some examples of how to transfer data from one location to a commit message before you see the message. You will also learn how you can verify whether you are pushing your code to the right location. Finally, you will see how you can add scripts to Git.</p>
<p>A hook in Git is a script that will be triggered on events, such as pushing, committing, or rebasing. If these scripts exit with a non-zero value, it is probably best to cancel the current Git operation. You can find these hook scripts in the <kbd>.git/hooks</kbd> folder in any Git clone. If they have the <kbd>.sample</kbd> file extension, they are not active.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using a branch description in a commit message</h1>
                
            
            
                
<p>In <a href="05533902-404c-4c14-9755-7137337e8190.xhtml">Chapter 3</a>, <em>Branching, Merging, and Options</em>, we mentioned that you can set a description on your branch, and this information can be retrieved from a script using the <kbd>git config --get branch.&lt;branchname&gt; description</kbd> command. In this example, we will take this information and use it for the commit message.</p>
<p>We will be using the <kbd>prepare-commit-msg</kbd> hook. The <kbd>prepare-commit-msg</kbd> hook is executed every time you want to commit, and the hook can be set to anything you wish to check, before you actually see the commit message editor.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We need a clone and a branch to get started on this exercise, hence we will clone <kbd>jgit</kbd> again to the <kbd>chapter7.5</kbd> folder, as follows:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit chapter7.5</strong>
<strong>Cloning into 'chapter7.5'...</strong>
<strong>remote: Counting objects: 2170, done</strong>
<strong>remote: Finding sources: 100% (364/364)</strong>
<strong>remote: Total 45977 (delta 87), reused 45906 (delta 87)</strong>
<strong>Receiving objects: 100% (45977/45977), 10.60 MiB | 1.74 MiB/s, done.</strong>
<strong>Resolving deltas: 100% (24651/24651), done.</strong>
<strong>Checking connectivity... done.</strong>
<strong>Checking out files: 100% (1577/1577), done.</strong></pre>
<p>Check out a local <kbd>descriptioInCommit</kbd> branch that tracks the <kbd>origin/stable-3.2</kbd> branch:</p>
<pre><strong>$ cd chapter7.5</strong>
<strong>$ git checkout -b descriptioInCommit  --track origin/stable-3.2</strong>
<strong>Branch descriptioInCommit set up to track remote branch stable-3.2 from origin.</strong>
<strong>Switched to a new branch 'descriptioInCommit'</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will start by setting the description of our local branch. Then, we will create the hook that can extract this information and put it in the commit message.</p>
<p>We have our local <kbd>descriptioInCommit</kbd> branch, for which we need to set a description. We will use the <kbd>--edit-description</kbd> Git branch to add a description to our local branch. This opens the description editor, and you can type in a message by performing the following steps:</p>
<ol>
<li>When you execute the command, the description editor will open and you can type in a message:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git branch --edit-description descriptioInCommit</strong></pre>
<ol start="2">
<li>Now, type in the following message:</li>
</ol>
<pre style="padding-left: 60px"><strong>Remote agent not connection to server
    
When the remote agent is trying to connect
it will fail as network services are not up
and running when remote agent tries the first time</strong></pre>
<ol start="3">
<li>You should write your branch description just as you write your commit messages. It make sense then to reuse the description in the commit. Now, we will verify whether we have a message with the following description:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --get branch.descriptioInCommit.description</strong>
<strong>Remote agent not connection to server</strong>
    
<strong>When the remote agent is trying to connect</strong>
<strong>it will fail as network services are not up</strong>
<strong>and running when remote agent tries the first time</strong></pre>
<ol start="4">
<li>As expected, we have the desired output. Now, we can continue creating the hook that will take the description and use it.</li>
</ol>
<p style="padding-left: 90px">Next, we will check whether we have a description for the hook and, if we do, we will use that description as the commit message.</p>
<ol start="5">
<li>First, we will ensure that we can get the information into the commit message at our desired position. There are many ways to do this and we have settled on the following method: open the <kbd>.git/hook/prepare-commit-msg</kbd> hook file, type in the following script, and make it executable (<kbd>chmod +x</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>BRANCH=$(git branch | grep '*'| sed 's/*//g'|  sed 's/ //g')</strong>
<strong>DESCRIPTION=$(git config --get branch.${BRANCH}.description)</strong>
<strong>if [ -z "$DESCRIPTION" ]; then</strong>
<strong>  echo "No desc for branch using default template"</strong>
<strong>else</strong>
<strong>  # replacing # with n</strong>
<strong>  DESCRIPTION=$(echo "$DESCRIPTION" | sed 's/#/\n/g')</strong>
<strong>  # replacing the first \n with \n\n</strong>
<strong>  DESCRIPTION=$(echo "$DESCRIPTION" | sed 's/\n/\n\n/')</strong>
<strong># append default commit message</strong><br/><strong>DESCRIPTION=$(echo "$DESCRIPTION" &amp;&amp; cat $1)</strong><br/><strong># and write it all to the commit message</strong>
<strong>echo "$DESCRIPTION" &gt; $1</strong>
<strong>fi</strong></pre>
<ol start="6">
<li>Now, we can try to create a commit and see whether the message is being displayed as predicted. Use <kbd>git commit --allow-empty</kbd> to generate an empty commit, but also to trigger the prepare-commit-msg hook:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --allow-empty</strong></pre>
<ol start="7">
<li>You should get the message editor with our branch description as the commit message, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>Remote agent not connection to server</strong>
    
<strong>When the remote agent is trying to connect</strong>
<strong>it will fail as network services are not up</strong>
<strong>and running when remote agent tries the first time</strong>
    
<strong># Please enter the commit message for your changes. Lines starting</strong>
<strong># with '#' will be ignored, and an empty message aborts the commit.</strong>
<strong># On branch descriptioInCommit</strong>
<strong># Your branch is up-to-date with 'origin/stable-3.2'.</strong>
<strong>#</strong>
<strong># Untracked files:</strong>
<strong>#       hen the remote agent is trying to connect</strong>
<strong>#</strong></pre>
<ol start="8">
<li>This is as we expected. Save the commit message and close the editor. Try using the <kbd>git log -1</kbd> command to verify whether we have the following message in our commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit 92447c6aac2f6d675f8aa4cb88e5abdfa46c90b0</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Sat Mar 15 00:19:35 2014 +0100</strong>
    
   <strong>Remote agent not connection to server</strong></pre>
<pre style="padding-left: 60px">   <strong>When the remote agent is trying to connect</strong>
   <strong>it will fail as network services are not up</strong>
   <strong>and running when remote agent tries the first time</strong></pre>
<ol start="9">
<li>You should get something similar to a commit message that is the same as our branch description. However, what about an empty branch description? How will our hook handle that? We can try again with a new branch named <kbd>noDescriptionBranch</kbd>. Use <kbd>git checkout</kbd> to create it, and check it as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b noDescriptionBranch</strong>
<strong>Switched to a new branch 'noDescriptionBranch'</strong></pre>
<ol start="10">
<li>Now, we will make yet another empty commit to see whether the commit message is as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --allow-empty</strong></pre>
<ol start="11">
<li>You should get the commit message editor with the default commit message text, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong># Please enter the commit message for your changes. Lines starting</strong>
<strong># with '#' will be ignored, and an empty message aborts the commit.<br/></strong><strong>#</strong>
<strong># On branch noDescriptionBranch</strong></pre>
<p>This is all as we expected. This script can be combined with the next exercise, which will take content from a defective system as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a dynamic commit message template</h1>
                
            
            
                
<p>Developers can be encouraged to do the right thing, or developers can be forced to do the right thing. However, in the end, developers need to spend time coding. So, if a good commit message is required, we can use the <kbd>prepare-commit-msg</kbd> hook to assist the developer.</p>
<p>In this example, we will create a commit message for developers that contains information about the state of the work area. It will also insert some information from a web page. This could just as well be defect information from Bugzilla.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To start this exercise, we will not be cloning a repository, but creating one. To do this, we will be using <kbd>git init</kbd>, as shown in the following code. You can use <kbd>git init &lt;directory&gt;</kbd> to create a new repository somewhere, or you can go to a directory and execute <kbd>git init</kbd> and Git will create a repository for you.</p>
<pre><strong>$ git init chapter7</strong>
<strong>Initialized empty Git repository in /Users/JohnDoe/repos/chapter7/.git/</strong>
<strong>$ cd chapter7</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We have our <kbd>chapter7</kbd> directory, where we just initialized our repository. In this directory, the hooks are already available. Just look in the <kbd>.git/hooks</kbd> directory. We will be using the <kbd>prepare-commit-msg</kbd> hook. Perform the following steps:</p>
<ol>
<li>Start by looking in the folder with the following hooks:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ ls .git/hooks/</strong>
<strong>applypatch-msg.sample  pre-applypatch.sample  </strong>
<strong>pre-rebase.sample      commit-msg.sample</strong>
<strong>pre-commit.sample      prepare-commit-msg.sample</strong>
<strong>post-update.sample     pre-push.sample        </strong>
<strong>update.sample</strong></pre>
<ol start="2">
<li>As you can see, there are plenty of hooks in each of the hook files. There is an example script, and a short explanation of what the hook does and when it is executed. To enable <kbd>prepare-commit-msg</kbd>, rename the file as shown in the following code:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cd .git/hooks/</strong>
<strong>$ mv prepare-commit-msg.sample prepare-commit-msg</strong>
<strong>$ cd -</strong></pre>
<ol start="3">
<li>Open the <kbd>prepare-commit-msg</kbd> file in your preferred editor.</li>
<li>You can read the information in the file, but for our examples, we will clear the file so that we can include the script.</li>
<li>Now, include the following command in the file:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash </strong>
<strong>echo "I refuse to commit"</strong>
<strong>exit 1</strong></pre>
<ol start="6">
<li>Save the file.</li>
<li>Finally, try to commit either something or nothing. Usually, you cannot make a commit that is empty, but with the <kbd>--allow-empty</kbd> option, you can create an empty commit as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --allow-empty</strong>
<strong>I refuse to commit</strong></pre>
<ol start="8">
<li>As you can see, we get the message we put in the <kbd>prepare-commit-msg</kbd> script file. You can check whether or not we have a commit by using <kbd>git log -1</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1<br/>fatal: your current branch 'master' does not have any commits yet</strong></pre>
<p style="padding-left: 60px">There is no commit, and we get an error message that we have not seen before. The message has to be there because there is no commit so far in this repository. Before we make further changes to the script, we should know that the <kbd>prepare-commit-msg</kbd> hook takes some arguments, depending on the situation. The first argument is always <kbd>.git/COMMIT_EDITMSG</kbd>, and the second argument can be merge, commit, squash, or template, depending on the situation. We can use these in the script.</p>
<ol start="9">
<li>Change the script so that we can reject amending commits as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>if [ "$2" == "commit" ]; then </strong>
  <strong>echo "Not allowed to amend"</strong>
  <strong>exit 1</strong>
<strong>fi</strong></pre>
<ol start="10">
<li>Now that we have changed the script, let's create a commit and try to amend it as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "alot of fish" &gt; fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit -m "All my fishes are belong to us"</strong>
<strong>[master (root-commit) f605886] All my fishes are belong to us</strong>
<strong>1 file changed, 1 insertion(+)</strong>
<strong>create mode 100644 fishtank.txt</strong></pre>
<ol start="11">
<li>Now that we have a commit, let's try to amend it using <kbd>git commit --amend</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --amend</strong>
<strong>Not allowed to amend</strong></pre>
<ol start="12">
<li>As we expected, we were not allowed to amend the commit. If we wish to extract some information, for instance, from a bug handling system, we will have to put this information into the file before opening the editor. So, again, we will change the script as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>if [ "$2" == "commit" ]; then </strong>
  <strong>echo "Not allowed to amend"</strong>
  <strong>exit 1</strong>
<strong>fi</strong>
<strong>MESSAGE=$(curl -s http://whatthecommit.com/index.txt)</strong>
<strong>echo</strong> "<strong>$MESSAGE" &gt; $1</strong></pre>
<ol start="13">
<li>This script downloads a commit message from <kbd>http://www.whatthecommit.com/</kbd> and inserts it into the commit message. Every time you commit, you will get a new message from the web page. Let's give it a try by using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "gravel, plants, and food" &gt;&gt;fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit</strong></pre>
<ol start="14">
<li>When the commit message editor opens, you should see a message from <kbd>whatthecommit.com</kbd>. Close the editor and, using <kbd>git log -1</kbd>, verify whether we have the commit, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit c087f75665bf516af2fe30ef7d8ed1b775bcb97d</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Wed Mar 5 21:12:13 2014 +0100</strong>
    
   <strong>640K ought to be enough for anybody</strong></pre>
<ol start="15">
<li>As expected, we have succeeded with the commit. Obviously, this is not the best message to have for the committer. A more typical usage is to list the bugs assigned to the developer, as follows, in the commit message:</li>
</ol>
<pre style="padding-left: 60px"><strong># You have the following artifacts assigned</strong>
<strong># Remove the # to add the artifact ID to the commit message</strong>
    
<strong>#[artf23456] Error 02 when using update handler on wlan</strong>
<strong>#[artf43567] Enable Unicode characters for usernames</strong>
<strong>#[artf23451] Use stars instead of &amp; when keying pword</strong></pre>
<ol start="16">
<li>This way, the developer can easily select the correct bug ID, or the artefact ID, from TeamForge in this case, using the correct format for the other systems that will look into the commit messages.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>You can extend the functionality of the <kbd>prepare-commit-msg</kbd> hook easily, but you should bear in mind that the waiting time for fetching some information should be worth the benefits. One thing that is usually easy to check is a dirty work area.</p>
<p>Here, we need to use the <kbd>git status</kbd> command in the prepare commit message hook, and we need to predict whether we will have modified files after the commit:</p>
<ol>
<li>To check this, we need to have something staged for committing and some unstaged changes, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong>
<strong>On branch master</strong>
<strong>nothing to commit, working directory clean</strong></pre>
<ol start="2">
<li>Now, modify the <kbd>fishtank.txt</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "saltwater" &gt;&gt; fishtank.txt</strong></pre>
<ol start="3">
<li>Use <kbd>git status --porcelain</kbd> to check the work area:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status --porcelain</strong>
<strong>M fishtank.txt</strong></pre>
<ol start="4">
<li>Add the file to the staging area using <kbd>git add</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add fishtank.txt</strong></pre>
<ol start="5">
<li>Now try <kbd>git status --porcelain</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status --porcelain</strong>
<strong>M  fishtank.txt</strong></pre>
<ol start="6">
<li>What you should note is the space before <kbd>M</kbd> the first time we use the <kbd>--porcelain</kbd> option for Git status. The <kbd>porcelain</kbd> option provides a machine-friendly output that shows the state of the files for Git status. The first character is the status in the staging area, whereas the second character is the status in the work area. So, <kbd>MM fishtank.txt</kbd> would mean the file is modified in the work area and in the staging area. So, if you modify <kbd>fishtank.txt</kbd> again, the following is the result you can expect:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "sharks and oysters" &gt;&gt; fishtank.txt</strong>
<strong>$ git status --porcelain</strong>
<strong>MM fishtank.txt</strong></pre>
<ol start="7">
<li>As expected, the output from Git status is <kbd>MM fishtank.txt</kbd>. We can use this in the hook to tell whether or not the work area will have uncommitted changes after we commit. Add the following command to the <kbd>prepare-commit-msg</kbd> file:</li>
</ol>
<pre style="padding-left: 60px"><strong>for file in $(git status --porcelain)</strong>
<strong>do</strong>
<strong>  if [ ${file:1:1} ]; then </strong>
    <strong>DIRTY=1</strong>
  <strong>fi</strong>
  <strong>done</strong>
  <strong>if [ "${DIRTY}" ]; then<br/>    # -i '' is not needed on Linux </strong>
    <strong>sed -i '' "s/# Please/You have a dirty workarea are you sure you wish to commit ?&amp;/" $1</strong>
  <strong>fi</strong></pre>
<ol start="8">
<li>First, we list all the files that have changed with <kbd>git status --porcelain</kbd>. Then, for each of these files, we check whether there is a second character. If this is true, we will have a dirty work area after the commit. In the end, we just insert the message into the commit message so that it is available for the developer to see. Let's try and commit the change by using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit</strong></pre>
<ol start="9">
<li>Check that you have a message similar to the following. The first line might be different, as we still have the message from <kbd>http://www.whatthecommit.com/</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>somebody keeps erasing my changes.</strong>
<strong>You have a dirty workarea are you sure you wish to commit ?</strong>
<strong># Please enter the commit message for your changes. Lines starting</strong>
<strong># with '#' will be ignored, and an empty message aborts the commit.</strong>
<strong># On branch master</strong>
<strong># Changes to be committed:</strong>
<strong>#       modified:   fishtank.txt</strong>
<strong>#  </strong>
<strong># Changes not staged for commit:</strong>
<strong>#       modified:   fishtank.txt</strong>
<strong>#</strong></pre>
<ol start="10">
<li>Saving the file and closing the editor will create the commit. Verify this with <kbd>git log -1</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit 70cad5f7a2c3f6a8a4781da9c7bb21b87886b462</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Thu Mar 6 08:25:21 2014 +0100</strong>
    
    <strong>somebody keeps erasing my changes.</strong>
    <strong>You have a dirty workarea are you sure you wish to commit ?</strong></pre>
<ol start="11">
<li>We have the information we expected. The text about the dirty work area is in the commit message . To clean up nicely before the next exercise, we should reset our work area to <kbd>HEAD</kbd>, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard HEAD</strong>
<strong>HEAD is now at 70cad5f somebody keeps erasing my changes.</strong></pre>
<p>Now, it is just a matter of finding out what suits you. Is there any information you would like to check before you commit and potentially push the code to a remote branch? This may include:</p>
<ul>
<li>Style checks in code</li>
<li>Using Pylint to check your Python scripts</li>
<li>Checking for files that you are not allowed to add to Git</li>
</ul>
<p>This list is not exhaustive; there is probably something to add for every organization or development team in the world. However, this clearly is one way of taking tedious manual work away from the developer so that he or she can focus on coding.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using external information in a commit message</h1>
                
            
            
                
<p>The commit hook is executed when you close the commit message editor. It can, among other things, be used to manipulate the commit message or do an automatic review of the commit message to check whether it has a specific format.</p>
<p>In this recipe, we will be manipulating and checking the content of a commit message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To start this exercise, we just need to create a branch and check it out. We need to disable the current <kbd>prepare-commit-msg</kbd> hook; we can do this by simply renaming it. Now, we can start working on the <kbd>commit-msg</kbd> hook by using the following command:</p>
<pre><strong>$ git checkout -b commit-msg-example</strong>
<strong>Switched to a new branch 'commit-msg-example'</strong>
<strong>$ mv .git/hooks/prepare-commit-msg .git/hooks/prepare-commit-msg.example</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>What we want to do in the first example is to check whether or not the defect information is correct. There is no need to release a commit that refers to a defect that does not exist:</p>
<ol>
<li>We will start by testing the <kbd>commit-msg</kbd> hook. First, make a copy of the current hook, then we will force the hook to exit with a non-zero value that will abort the creation of the commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cp .git/hooks/commit-msg.sample .git/hooks/commit-msg</strong></pre>
<ol start="2">
<li>Now, open the file in your preferred editor and add the following lines to the file:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>echo "you are not allowed to commit"</strong>
<strong>exit 1</strong></pre>
<ol start="3">
<li>Now, we will try to make a commit and see what happens, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "Frogs, scallops, and coco shell" &gt;&gt; fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit</strong></pre>
<ol start="4">
<li>The editor will open, you can write a small commit message, and then close the editor. You should see the <kbd>you are not allowed to commit</kbd> message, and if you check with <kbd>git log -1</kbd>, you will see that you don't have a commit with the message you just wrote, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>you are not allowed to commit</strong>
<strong>$ git log -1</strong>
<strong>commit 70cad5f7a2c3f6a8a4781da9c7bb21b87886b462</strong></pre>
<pre style="padding-left: 60px"><strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Thu Mar 6 08:25:21 2014 +0100</strong>
    
    <strong>somebody keeps erasing my changes.</strong>
<strong>You have a dirty workarea are you sure you wish to commit ?</strong></pre>
<ol start="5">
<li>As you can see, the commit message hook is executed after you close the message editor, whereas the <kbd>prepare-commit-msg</kbd> hook is executed before the message editor. To validate, if we have a proper reference to the hook in our commit message, we will be checking whether a specific error is available for the Jenkins-CI project. Replace the lines in the <kbd>commit-msg</kbd> hook so that it looks like the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>JIRA_ID=$(cat $1 | grep jenkins | sed 's/jenkins //g')</strong>
<strong>ISSUE_INFO=$(curl -g "https://issues.jenkins-ci.org/browse/JENKINS-${JIRA_ID}")</strong>
<strong>if [ -z "${ISSUE_INFO}" ]; then </strong>
  <strong>echo "Jenkins issue ${JIRA_ID} does not exist"</strong>
  <strong>echo "Please try again"</strong>
  <strong>exit 1</strong>
<strong>else</strong>
  <strong>TITLE=$(curl -g "https://issues.jenkins-ci.org/browse/JENKINS-$JIRA_ID}" | grep -E "&lt;title&gt;.*&lt;/title&gt;")</strong>
  <strong>echo "Jenkins issue ${JIRA_ID}"</strong>
  <strong>echo "${TITLE}"</strong>
  <strong>exit 0</strong>
<strong>fi</strong></pre>
<ol start="6">
<li>We are using curl to retrieve the web page and, if it is empty, we know that the ID does not exist. Now, we should create a commit and see what happens if we put in the wrong ID, <kbd>jenkins 384895</kbd>, or an ID that exists as <kbd>jenkins 3157</kbd>. To check this, we will create a commit as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "more water" &gt;&gt; fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit</strong></pre>
<ol start="7">
<li>In the commit message, write something such as <kbd>Feature cascading...</kbd> as a commit message subject. Then, in the body of the commit message, insert <kbd>jenkins 384895</kbd>. This is the important part, as the hook will use that number to look it up on the Jenkins issue tracker:</li>
</ol>
<pre style="padding-left: 60px"><strong>Feature: Cascading...</strong>
    
<strong>jenkins 384895</strong></pre>
<ol start="8">
<li>You should end up with the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>Jenkins issue 384895 does not exist</strong>
<strong>Please try again</strong></pre>
<ol start="9">
<li>This is what we expected. Now, verify whether the change has been committed or not with <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git status</strong>
<strong>On branch commit-msg-example</strong>
<strong>Changes to be committed:</strong>
<strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
  <strong>modified:   fishtank.txt</strong></pre>
<ol start="10">
<li>Now, we will try to commit again; this time, we will be using the correct JIRA ID:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit</strong></pre>
<ol start="11">
<li>Key in a commit message like the previous one; this time, make sure the Jenkins issue ID is one that exists. You can use <kbd>51444</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>Feature: Cascading...</strong>
    
<strong>jenkins 51444</strong></pre>
<ol start="12">
<li>Saving the commit message should result in an output as follows. We can clean it some more by removing the title HTML tags:</li>
</ol>
<pre style="padding-left: 60px"><strong>&lt;title&gt;[#JENKINS-51444] Maven Parser creates errors during affectedFilesResolving - Jenkins JIRA&lt;/title&gt;</strong>
<strong>[commit-msg-example 3d39ca3] Feature: Cascading...</strong>
<strong>1 file changed, 2 insertions(+)</strong></pre>
<ol start="13">
<li>As you can see, we can get information to output. We could also add this information to the commit message itself. Then, we can change and insert this as the <kbd>else</kbd> clause in the script:</li>
</ol>
<pre style="padding-left: 60px"><strong>TITLE=$(curl https://issues.jenkins-ci.org/browse/JENKINS-${JIRA_ID} | grep -E "&lt;title&gt;.*&lt;/title&gt;")</strong>
<strong>TITLE=$(echo ${TITLE} | sed 's/^&lt;title&gt;//' | sed 's/&lt;\/title&gt;$//')</strong>
<strong>echo "${TITLE}" &gt;&gt; $1</strong>
<strong>echo "Jenkins issue ${JIRA_ID}"</strong>
<strong>echo "${TITLE}"</strong>
<strong>exit 0</strong></pre>
<ol start="14">
<li>To test this, we will create a commit again, and, in the message, we need to specify the JIRA ID that exists:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "Shrimps and mosquitos" &gt;&gt; fishtank.txt</strong>
<strong>$ git add fishtank.txt</strong>
<strong>$ git commit</strong>
<strong>After saving the commit message editor you will get an output similar like this. </strong>
<strong>Jenkins issue 51444</strong>
<strong>[JENKINS-51444] Maven Parser creates errors during affectedFilesResolving - Jenkins JIRA</strong>
<strong>[commit-msg-example 6fa2cb4] Feature: Cascading...</strong>
<strong>1 file changed, 1 insertion(+)</strong></pre>
<ol start="15">
<li>To verify whether we got the information in the message, we will use <kbd>git log -1</kbd> again:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit 6fa2cb47989e12b05cd2689aa92244cb244426fc</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Thu Mar 6 09:46:18 2014 +0100</strong>
    
    <strong>Feature: Cascading...</strong>
    
    <strong>jenkins 51444</strong>
    <strong>[#JENKINS-51444] Maven Parser creates errors during affectedFilesResolving - Jenkins JIRA</strong></pre>
<p>As expected, we have the information at the end of the commit. In these examples, we are just discarding the commit message if the JIRA ID does not exist. This is a little harsh to the developer. So, you can combine this with the <kbd>prepare-commit-msg</kbd> hook. If <kbd>commit-msg</kbd> halts the commit process, then save the message temporarily so that the <kbd>prepare-commit-msg</kbd> hook can use that message when the developer tries again.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preventing the push of specific commits</h1>
                
            
            
                
<p>The pre-push hooks are triggered whenever you use the push command and the script execution happens before the push. So, we can prevent a push if we find a reason to reject it.</p>
<p>One reason could be that you have a commit with the <kbd>nopush</kbd> text in the commit message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To use the Git pre-push, we need to have a remote repository. We will be cloning <kbd>jgit</kbd> again, as follows:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit chapter7.1</strong>
<strong>Cloning into 'chapter7.1'...</strong>
  <strong>remote: Counting objects: 2429, done</strong>
  <strong>remote: Finding sources: 100% (534/534)</strong>
  <strong>remote: Total 45639 (delta 145), reused 45578 (delta 145)</strong>
  <strong>Receiving objects: 100% (45639/45639), 10.44 MiB | 2.07 MiB/s, done.</strong>
  <strong>Resolving deltas: 100% (24528/24528), done.</strong>
  <strong>Checking connectivity... done.</strong>
  <strong>Checking out files: 100% (1576/1576), done.</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We want to be able to push to a remote branch but, unfortunately, Git will try to authenticate through HTTPS for the <kbd>jgit</kbd> repository before the hooks are executed. Because of this, we will create a local clone from the <kbd>chapter7.1</kbd> directory, as follows. This will make our remote a local folder:</p>
<pre><strong>$ git clone --branch master ./chapter7.1/ chapter7.2</strong>
<strong>Cloning into ' chapter7.2'...</strong>
<strong>done.</strong>
<strong>Checking out files: 100% (1576/1576), done.</strong>
<strong>$ cd chapter7.2<br/></strong><strong>$ git branch</strong><br/><strong>* master<br/></strong></pre>
<p>We are cloning the <kbd>chapter7.1</kbd> directory in a folder named <kbd>chapter7.2</kbd>, and will check the <kbd>master</kbd> branch when the clone has finished.</p>
<p>What we now want to do is to create a commit with a commit message that has <kbd>nopush</kbd> as part of it. By adding this word to the commit message, the code in the hook will automatically stop the push. We will be doing this on top of a branch. So, to start with, you should check out a <kbd>prepushHook</kbd> branch that tracks the <kbd>origin/master</kbd> branch and then creates a commit.</p>
<p>We will try to push it to the remote when we have the pre-push commit in place, as follows:</p>
<ol>
<li>Start by creating a new branch named <kbd>prepushHook</kbd>, which tracks <kbd>origin/master</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b prepushHook  --track origin/master</strong>
<strong>Branch prepushHook set up to track remote branch master from origin.</strong>
<strong>Switched to a new branch 'prepushHook'</strong></pre>
<ol start="2">
<li>Now, we use <kbd>reset</kbd> to go back to an earlier commit. It is not important how far back we go. So, we have just selected a random commit as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git reset --hard 2e0d178</strong>
<strong>HEAD is now at 2e0d178 Add recursive variant of Config.getNames() methods</strong></pre>
<ol start="3">
<li>Now we can create a commit. We will do a simple inline replace with <kbd>sed</kbd>, and then add <kbd>pom.xml</kbd> and commit it:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ sed -i '' 's/2.9.1/3.0.0/g' pom.xml</strong>
<strong>$ git add pom.xml</strong>
<strong>$ git commit -m "Please nopush"</strong>
<strong>[prepushHook 69d571e] Please nopush</strong>
<strong>1 file changed, 1 insertion(+), 1 deletion(-)</strong></pre>
<ol start="4">
<li>To verify whether we have the commit with the text, run <kbd>git log -1</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit 1269d14fe0c32971ea33c95126a69ba6c0d52bbf</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Thu Mar 6 23:07:54 2014 +0100</strong>
    
   <strong>Please nopush</strong></pre>
<ol start="5">
<li>We have what we want in the commit message. Now, we just need to prepare the hook. We will start by copying the sample hook to the real name so that it will be executed on push:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ cp .git/hooks/pre-push.sample .git/hooks/pre-push</strong></pre>
<ol start="6">
<li>Edit the hook so that its code is as shown in the following snippet:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>echo "You are not allowed to push"</strong>
<strong>exit 1</strong></pre>
<ol start="7">
<li>Now we are ready to push. We will be pushing our current branch <kbd>HEAD</kbd> to the <kbd>master</kbd> branch in the remote:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git push origin HEAD:refs/heads/master</strong>
<strong>You are not allowed to push</strong>
<strong>error: failed to push some refs to '../chapter7.1/'</strong></pre>
<ol start="8">
<li>As expected, the hook is being executed, and the push is being denied by the hook. Now, we can implement the check we want to carry out. If we have the word <kbd>nopush</kbd> in any commit message, we want to exit. We can use <kbd>git log --grep</kbd> to search for commits with the keyword <kbd>nopush</kbd> in the commit message, as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --grep "nopush"</strong>
<strong>commit 51201284a618c2def690c9358a07c1c27bba22d5</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Thu Mar 6 23:07:54 2014 +0100</strong>
    
    <strong>Please nopush</strong></pre>
<ol start="9">
<li>We have our newly created commit with the keyword <kbd>nopush</kbd>. Now, we will perform a simple check for this in the hook and edit the pre-push hook so that it has the following text:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>COMMITS=$(git log --grep "nopush")</strong>
<strong>if [ "$COMMITS" ]; then </strong>
  <strong>echo "You have commit(s) with nopush message"</strong>
  <strong>echo "aborting push"</strong>
  <strong>exit 1</strong>
<strong>fi</strong></pre>
<ol start="10">
<li>Now we can try to push again to see what the result will be. We will try to push our <kbd>HEAD</kbd> to the master branch on the remote <kbd>origin</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git push origin HEAD:refs/heads/master</strong>
<strong>You have commit(s) with nopush message</strong>
<strong>aborting push</strong>
<strong>error: failed to push some refs to '/Users/JohnDoe/repos/./chapter7.1/'</strong></pre>
<p>As expected, we are not allowed to push as we have the <kbd>nopush</kbd> message in the commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Having a hook to prevent you from pushing commits that you don't want to push is very handy. You can specify any keywords you want. Words such as <kbd>reword</kbd>, <kbd>temp</kbd>, <kbd>nopush</kbd>, <kbd>temporary</kbd>, or <kbd>hack</kbd> can all be things you want to stop, but sometimes you want to get them through anyway.</p>
<p>What you can do is have a small checker that checks for specific words, then lists the commits, and asks if you want to push anyway.</p>
<p>If you change the script to the following snippet, the hook will try to find commits with the keyword <kbd>nopush</kbd> and list them. If you wish to push them in any case, you can answer the question and Git will push anyway:</p>
<pre><strong>#!/bin/bash</strong>
<strong>COMMITS=$(git log --grep "nopush" --format=format:%H)</strong>
<strong>if [ "$COMMITS" ]; then</strong>
  <strong>exitmaybe=1</strong>
<strong>fi</strong>
<strong>if [ $exitmaybe -eq 1 ]; then</strong>
<strong>while true</strong>
<strong>do</strong>
  <strong>clear</strong>
<strong>for commit in $COMMITS</strong>
<strong>do</strong>
  <strong>echo "$commit has no push in the message"</strong>
<strong>done</strong>
   <strong>echo "Are you sure you want to push the commit(s) "</strong>
    <strong>read -r REPLY &lt;&amp;1</strong>
    <strong>case $REPLY in</strong>
    <strong>[Yy]* ) break;;</strong>
    <strong>[Nn]* ) exit 1;;</strong>
  <strong>* ) echo "Please answer yes or no.";;</strong>
<strong>esac</strong>
<strong>done</strong>
<strong>fi</strong></pre>
<p>Try it with the <kbd>git push</kbd> command again, as shown in the following snippet:</p>
<pre><strong>$ git push origin HEAD:refs/heads/master</strong>
<strong>Commit 70fea355bac0c65fd51f4874d75e65b4a29ad763 has nopush in message</strong>
<strong>Are you sure you want to push the commit(s)</strong></pre>
<p>Type <kbd>n</kbd> and press <em>Enter</em>. Then, expect the push to be aborted with the following message:</p>
<pre><strong>error: failed to push some refs to '/Users/JohnDoe/repos/./chapter7.1/'</strong></pre>
<p>As predicted, it will not push. However, if you press y, Git will push to the remote. Try this now using the following command:</p>
<pre><strong>$ git push origin HEAD:refs/heads/master</strong>
<strong>054c5f78fdc82141e9d73e6b6955c38ff79c8b2e has no push in the message</strong>
<strong>Are you sure you want to push the commit(s)</strong>
<strong>y</strong>
<strong>To /Users/JohnDoe/repos/./chapter7.1/</strong>
<strong>! [rejected]        HEAD -&gt; master (non-fast-forward)</strong>
<strong>error: failed to push some refs to 'c:/Users/Rasmus/repos/./chapter7.1/'</strong>
<strong>hint: Updates were rejected because a pushed branch tip is behind its remote</strong>
<strong>hint: counterpart. Check out this branch and integrate the remote changes</strong>
<strong>hint: (e.g. 'git pull ...') before pushing again.</strong>
<strong>hint: See the 'Note about fast-forwards' in 'git push --help' for details.</strong></pre>
<p>As predicted, the push will be tried, but, as you can see from the output, it is rejected by the remote. This is because we diverged, and the push was not working at the tip of the master branch.</p>
<p>So, with this hook, you can make your life a little easier by having the hook prevent you from accidentally pushing something you are not interested in being pushed. This example also considers commits that have been released; so, if you select a different keyword, then other commits—not only the locally created ones—will be taken into consideration by the script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring and using Git aliases</h1>
                
            
            
                
<p>Git aliases, like Unix aliases, are short commands that can be configured on a global level or for each repository. It is a simple way of renaming some Git commands to use short abbreviations, for example, <kbd>git checkout</kbd> could be <kbd>git co</kbd>, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>It's very simple and straightforward to create an alias. You simply need to configure it with <kbd>git config</kbd>.</p>
<p>What we will do is check a branch and then create its aliases one by one and execute them to view their output by performing the following steps:</p>
<ol>
<li>So, we will start by checking a branch named <kbd>gitAlias</kbd>, which tracks the<br/>
<kbd>origin/stable-3.2</kbd> branch:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git checkout -b gitAlias --track origin/stable-3.2</strong>
<strong>Branch gitAlias set up to track remote branch stable-3.2 from origin.</strong>
<strong>Switched to a new branch 'gitAlias'</strong></pre>
<ol start="2">
<li>After this, we can start creating some aliases. We will start with the following one, which will simply just amend your commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.amm 'commit --amend'</strong></pre>
<ol start="3">
<li>Executing this alias will open the commit message editor with the following message from the <kbd>HEAD</kbd> commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git amm</strong>
<strong>Prepare post 3.2.0 builds</strong>
    
<strong>Change-Id: Ie2bfdee0c492e3d61d92acb04c5bef641f5f132f</strong>
<strong>Signed-off-by: Matthias Sohn matthias.sohn@sap.com</strong></pre>
<ol start="4">
<li>As you can see, it can be very simple to speed up the process of your daily workflow with Git aliases. The following command will just work on the last 10 commits using <kbd>--oneline</kbd> as an option for <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.lline 'log --oneline -10'</strong></pre>
<ol start="5">
<li>Using the alias will give you the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git lline</strong>
<strong>314a19a Prepare post 3.2.0 builds</strong>
<strong>699900c JGit v3.2.0.201312181205-r</strong>
<strong>0ff691c Revert "Fix for core.autocrlf=input resulting in mo</strong>
<strong>1def0a1 Fix for core.autocrlf=input resulting in modified f</strong>
<strong>0ce61ca Canonicalize worktree path in BaseRepositoryBuilder</strong>
<strong>be7942f Add missing @since tags for new public methods ig</strong>
<strong>ea04d23 Don't use API exception in RebaseTodoLine</strong>
<strong>3a063a0 Merge "Fix aborting rebase with detached head" into </strong>
<strong>e90438c Fix aborting rebase with detached head</strong>
<strong>2e0d178 Add recursive variant of Config.getNames() methods</strong></pre>
<ol start="6">
<li>You can also perform a simple checkout. Thus, instead of using the Git checkout, you can use <kbd>git co &lt;branch&gt;.</kbd> Configure it as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.co checkout</strong></pre>
<ol start="7">
<li>You will see that the aliases take arguments, just as the regular Git command does. Let's try the alias using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git co master</strong>
<strong>Switched to branch 'master'</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
<strong>$ git co gitAlias</strong>
<strong>Switched to branch 'gitAlias'</strong>
<strong>Your branch and 'origin/stable-3.2' have diverged,</strong>
<strong>and have 1 and 1 different commit each, respectively.</strong>
<strong>(use "git pull" to merge the remote branch into yours)</strong></pre>
<ol start="8">
<li>The command works as expected. You may wonder why we diverged after checking out the <kbd>gitAlias</kbd> branch again. Then, we diverged when we amended the <kbd>HEAD</kbd> commit. The next alias is creating a commit with everything that has not been committed in the work area, except for the untracked files:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.ca 'commit -a -m "Quick commit"'</strong></pre>
<ol start="9">
<li>Before we can test the alias, we should create a file and modify it to show what it actually does. So, create a file as shown in the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "Sharks" &gt; aquarium</strong>
<strong>$ echo "New HEADERTEXT" &gt; pom.xml</strong></pre>
<ol start="10">
<li>To verify what you want, run <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>Changes not staged for commit:</strong>
<strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
<strong>    modified:   pom.xml</strong>
    
  <strong>Untracked files:</strong>
    <strong>  (use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
    <strong>  aquarium</strong>
    
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong></pre>
<ol start="11">
<li>Now, we can test the alias using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git ca</strong>
<strong>[gitAlias ef9739d] Quick commit</strong>
<strong>1 file changed, 1 insertion(+), 606 deletions(-)</strong>
<strong>rewrite pom.xml (100%)</strong></pre>
<ol start="12">
<li>To verify whether the <kbd>aquarium</kbd> file was part of the commit or not, use <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>Untracked files:</strong>
  <strong>(use "git add &lt;file&gt;..." to include in what will be committed)</strong>
    
  <strong>aquarium</strong>
    
  <strong>nothing added to commit but untracked files present (use "git add" to track)</strong></pre>
<ol start="13">
<li>You can also use <kbd>git log -1</kbd> to see the commit we just created:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -1</strong>
<strong>commit ef9739d0bffe354c75b82f3b785780f5e3832776</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Thu Mar 13 00:01:49 2014 +0100</strong>
    
 <strong>   Quick commit</strong></pre>
<ol start="14">
<li>The output is just as we expected. The next alias is a little different, as it will count the number of commits in the repository, and this can be done with the <kbd>wc</kbd> (<kbd>wordcount</kbd>) tool. However, since this is not a built-in Git tool, we have to use the exclamation mark and also specify Git:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.count '!git log --all --oneline | wc -l'</strong></pre>
<ol start="15">
<li>Let's try it with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git count</strong>
    <strong>3008</strong></pre>
<ol start="16">
<li>So, currently, we have <kbd>3008</kbd> commits in the repository. This also means you can execute external tools as if they were Git tools just by creating a Git alias; for instance, if you are using Windows, Mac, or Linux, you can create an alias as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.wa '!explorer .' # Windows</strong>
<strong>$ git config alias.wa '!open .' # MacOS<br/>$ git config alias.wa '!xdg-open .' # Linux</strong></pre>
<ol start="17">
<li>This alias will open up an Window Explorer at the path you are currently at. The next one shows what changed in the <kbd>HEAD</kbd> commit. It executes this with the <kbd>--name-status</kbd> option for <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config alias.gl1 'log -1 --name-status'</strong></pre>
<ol start="18">
<li>Now try it using the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git gl1</strong>
<strong>commit ef9739d0bffe354c75b82f3b785780f5e3832776</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Thu Mar 13 00:01:49 2014 +0100</strong>
    
<strong>    Quick commit</strong>
    
    <strong>M       pom.xml</strong></pre>
<ol start="19">
<li>As you can see, it simply lists the commit and the files, including what happened to the files in the commit. As the aliases take arguments, we can actually reuse this functionality to list the information for another branch. Let's try it with the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git gl1 origin/stable-2.1</strong>
<strong>commit 54c4eb69acf700fdf80304e9d0827d3ea13cbc6d</strong>
<strong>Author: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
<strong>Date:   Wed Sep 19 09:00:33 2012 +0200</strong>
    
    <strong>Prepare for 2.1 maintenance changes</strong>
    
    <strong>Change-Id: I436f36a7c6dc86916eb4cde038b27f9fb183465a</strong>
    <strong>Signed-off-by: Matthias Sohn &lt;matthias.sohn@sap.com&gt;</strong>
    
<strong>M       org.eclipse.jgit.ant.test/META-INF/MANIFEST.MF</strong>
<strong>M       org.eclipse.jgit.ant.test/pom.xml</strong>
<strong>M       org.eclipse.jgit.ant/META-INF/MANIFEST.MF</strong>
<strong>M       org.eclipse.jgit.ant/pom.xml</strong>
<strong>M       org.eclipse.jgit.console/META-INF/MANIFEST.MF</strong>
<strong>M       org.eclipse.jgit.console/pom.xml</strong>
<strong>M       org.eclipse.jgit.http.server/META-INF/MANIFEST.MF</strong>
<strong>M       org.eclipse.jgit.http.server/pom.xml<br/></strong><strong>... more output</strong></pre>
<p>As you can see, we get the expected output. So, for instance, if you have been using a specific set of options for <kbd>git diff</kbd>, then you can make it an alias to use it with ease.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>It is as simple as inserting text in the <kbd>config</kbd> file. So, you can try and open the <kbd>.git/config</kbd> configuration file, or you can list the configuration with <kbd>git config -list</kbd>:</p>
<pre><strong>$ git config --list  | grep alias</strong>
<strong>alias.amm=commit --amend</strong>
<strong>alias.lline=log --oneline -10</strong>
<strong>alias.co=checkout</strong>
<strong>alias.ca=commit -a -m "Quick commit"</strong>
<strong>alias.count=!git log --all --oneline | wc -l</strong></pre>
<p>The <kbd>alias</kbd> feature is very strong, and the idea behind it is that you should use it to shorten those long one-liners that you often use. You can also use this feature to cut down those one-liners to shorter aliases so that you can use the command frequently and with more precision. If you have a long and complex Git comment as an alias, you will run it the same way every time, where keying a long command is bound to fail once in a while.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuring and using Git scripts</h1>
                
            
            
                
<p>Yes, we have aliases, and aliases do what they do best – take short one-liners and convert them into short, useful Git commands. However, when it comes to longer scripts that are also a part of your process, and you would like to incorporate them into Git, you can simply name the script <kbd>git-scriptname</kbd>, and then use it as <kbd>git scriptname</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>There are a few things to remember. The script has to be in your path so that Git can use the script. Besides this, only imagination sets the boundaries:</p>
<ol>
<li>Open your favorite editor and insert the following lines into the file:</li>
</ol>
<pre style="padding-left: 60px"><strong>#!/bin/bash</strong>
<strong>NUMBEROFCOMMITS=$(git log --all --oneline | wc -l)</strong><br/><strong>while :</strong><br/><strong>WHICHCOMMIT=$(( ( RANDOM % $NUMBEROFCOMMITS ) + 1 ))</strong><br/><strong>COMMITSUBJECT=$(git log --oneline --all -${WHICHCOMMIT} | tail -n1)</strong><br/><strong>COMMITSUBJECT_=$(echo "$COMMITSUBJECT" | cut -b1-60)</strong><br/><strong>do</strong><br/><strong>    if [ $RANDOM -lt 14000 ]; then </strong><br/><strong>        echo "${COMMITSUBJECT_} PASSED"</strong><br/><strong>    elif [ $RANDOM -gt 15000 ]; then </strong><br/><strong>        echo "${COMMITSUBJECT_} FAILED"</strong><br/><strong>    fi </strong><br/><strong>done</strong></pre>
<ol start="2">
<li>Save the file with the name <kbd>git-likeaboss</kbd>. This is a very simple script that will list random commit subjects with either passed or failed as the result. It will not stop until you press <em>Ctrl</em> + <em>C</em>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git likeaboss</strong>
<strong>5ec4977 Create a MergeResult for deleted/modified    PASSED</strong>
<strong>fcc3349 Add reflog message to TagCommand             PASSED</strong>
<strong>591998c Do not allow non-ff-rebase if there are ed   PASSED</strong>
<strong>0d7dd66 Make sure not to overwrite untracked notfil  PASSED</strong>
<strong>5218f7b Propagate IOException where possible where   FAILED</strong>
<strong>f5fe2dc Teach PackWriter how to reuse an existing s  FAILED</strong></pre>
<ol start="3">
<li>Note that you can also tab complete these commands, and Git will take them into consideration when you slightly misspell commands, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git likeboss</strong>
<strong>git: 'likeboss' is not a git command. See 'git --help'.</strong>
    
<strong>Did you mean this?</strong>
  <strong>likeaboss</strong></pre>
<p>Obviously, this script, in itself, is not so useful in a day-to-day environment, but we hope you get the point we are trying to make. All scripts revolve around the software delivery chain and you can name them Git as they are part of Git. This makes it much easier to remember which of the scripts you have are available for your job.</p>
<p>Both Git aliases and Git scripts will show up as Git commands when using tab completion. Type in <kbd>git &lt;tab&gt; &lt;tab&gt;</kbd> to see the list of possible Git commands.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up and using a commit template</h1>
                
            
            
                
<p>In this chapter, we have been using dynamic templates, but Git also has the option of a static commit template. A static template is essentially just a text file configured as a template. Using the template is very easy and straightforward.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>First of all, we need a template. This has to be a text file that you know the location of. Create a file with the following content:</p>
<pre><strong>#subject no more than 74 characters please</strong>
   
<strong>#BugFix id in the following formats</strong>
<strong>#artf [123456]</strong>
<strong>#PCP [AN12354365478]</strong>
<strong>#Bug: 123456</strong>
<strong>#Descriptive text about what you have done </strong>
<strong>#Also why you have chosen to do in that way as </strong>
<strong>#this will make it easier for reviewers and other</strong>
<strong>#developers.</strong></pre>
<p>This is our take on a simple commit message template. You might find that there are other templates out there that prefer to have the bug in the title or at the bottom of the commit message. The reason for having this at the top is that people often tend not to read the important parts of the text! The important part here is the formatting of the references to systems outside Git. If we get these references correct, we can automatically update the defect system as well. Save the file as <kbd>~/committemplate</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will configure our newly created template, and then we will make a commit that will utilize the template.</p>
<p>To configure the template, we need to use <kbd>git config commit.template &lt;pathtofile&gt;</kbd> to set it, and, as soon as it is set, we can try to create a commit and see how it works:</p>
<ol>
<li>Start by configuring the template as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config commit.template  ~/committemplate</strong></pre>
<ol start="2">
<li>Now list the <kbd>config</kbd> file to see that it has been set:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git config --list | grep template</strong>
<strong>commit.template=/Users/JohnDoe/committemplate</strong></pre>
<ol start="3">
<li>As we predicted, the configuration was a success. The template, just like any other configuration, can be set at a global level using <kbd>git config --global</kbd>, or it can be set at a local repository level by leaving out the <kbd>--global</kbd> option. We configured our commit template for this repository only. Let's try and make a commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit --allow-empty</strong></pre>
<ol start="4">
<li>Now, the commit message editor should open, and you should see our template in the commit message editor:</li>
</ol>
<pre style="padding-left: 60px"><strong>#subject no more than 74 characters please</strong>
    
<strong>#BugFix id in the following formats</strong>
<strong>#artf [123456]</strong>
<strong>#PCP [AN12354365478]</strong>
<strong>#Bug: 123456</strong>
<strong>#Descriptive text about what you have done</strong>
<strong>#Also why you have chosen to do in that way as</strong>
<strong>#this will make it easier for reviewers and other</strong>
<strong>#developers.</strong></pre>
<p>It's really as simple as that.</p>
<p>In this chapter, we have seen how to prevent pushing when there are special words in commit messages. We have also seen how you can dynamically create a commit message with valid information for you or another developer when you are committing.<br/>
We went on to see how you can build functionality into your own Git by adding short scripts or aliases that are all executed using Git. Hopefully, this information will help you to work smarter instead of harder.</p>


            

            
        
    </body></html>