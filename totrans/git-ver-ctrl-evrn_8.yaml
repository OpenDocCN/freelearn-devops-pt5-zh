- en: Chapter 8. Behind the Scenes – Basis of Git Basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Those who had an awestruck expression on their face after experiencing the
    awesomeness of Git would probably be wondering about the mechanisms behind the
    magic.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is dedicated to users who are serious about getting to know the
    intricacies of the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: init
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: add
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: clone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: fetch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: merge
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: remote
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: pull
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: push
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: tag
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: checkout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We begin by understanding the composition of a Git repository, followed by an
    analysis of the ways in which Git intelligently manages content, and finally take
    an overview of ways through which Git sees the relation between relations in order
    to store and transfer content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Two sides of Git: plumbing and porcelain'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Irrespective of the number of features highlighted in the sales brochure for
    your swanky new car, it has to have a user friendly interface through which you
    can really appreciate and enjoy the finer things it has to offer. Though the core
    work is done inside, the interface outside serves as an enabler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly Git works on both the inner and outer levels with the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Plumbing commands**: These commands take care of the low level operations,
    which form the fundamental base on which Git is built'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Porcelain commands**: These are the ones that cover the underlying plumbing
    operations at a high level with easy and appealing names for end users'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The commands that we have learned in earlier chapters are of the porcelain type.
    Let's look behind the scenes for each one of them.
  prefs: []
  type: TYPE_NORMAL
- en: Git init
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What you know is that this command creates a new subdirectory named `.git`,
    which is the source of versioning. Let''s move one step further and explore the
    contents of the `.git` directory, which should have a directory structure as shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Git init](img/7522_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Hooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Hooks are customization scripts that can be injected into various Git commands
    and its operations. It is possible to write our own hook and such a hook has to
    go into this directory.
  prefs: []
  type: TYPE_NORMAL
- en: There are a bunch of sample hooks automatically created inside this directory
    as part of `git init` but not activated until we manually rename `hook_name.sample`
    to `hook_name`. To learn more about the various hooks present in the directory
    open up the help document by typing `git help hooks` in your command line.
  prefs: []
  type: TYPE_NORMAL
- en: Info
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Additional information about the repository is recorded in this directory. Presently
    the only file inside would be the one called `exclude`. This file serves as a
    master list of the files to be excluded from being tracked by Git.
  prefs: []
  type: TYPE_NORMAL
- en: Sounds familiar, doesn't it? Indeed, the `.gitignore` file performs the same
    operation except for the fact that any exclusion pattern written in the exclude
    file is reflected only in the local repository and not in any subsequent clones;
    whereas when written on `.gitignore`, it becomes a part of your history, which
    can be subjected to other Git functions such as add, commit, merge, clone, pull,
    push, and others.
  prefs: []
  type: TYPE_NORMAL
- en: Config
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The name conveys it all; this text file is our project/repository-specific configuration
    file. We would have covered the finer workings of this file in earlier chapters,
    but the content we'd need to cover would go beyond the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: This is where Git maintains the entries for a remote section to or from wherever
    the repository is cloned or data is exchanged. It also contains some core settings
    such as whether the repository is a bare repository or not.
  prefs: []
  type: TYPE_NORMAL
- en: Description
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is a package called gitweb, which comes with your Git installation and
    will allow us to set up a web interface for our Git repositories. This means that
    the repository can be browsed using any web browser.
  prefs: []
  type: TYPE_NORMAL
- en: This description file contains a user-defined description of the repository,
    which is used by the gitweb program to display it to the clients who are requesting
    a listing of repositories.
  prefs: []
  type: TYPE_NORMAL
- en: Objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you have understood correctly, like any other VCS repository, a Git repository
    is nothing but a database containing all the data that is needed to retain, reproduce,
    and manage the revisions and history of your files, but the way Git handles these
    operations is what makes it stand apart from others.
  prefs: []
  type: TYPE_NORMAL
- en: And this is possible because of the way Git considers everything that goes into
    it as objects. There are four types of objects namely blobs, trees, commits, and
    tags with which it pulls such a trick.
  prefs: []
  type: TYPE_NORMAL
- en: Blob
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: I'm sure that you're familiar with the building blocks game; we've all played
    it at some point in our lives. When you think about it, you will recollect that
    irrespective of the type of structure you build, it's basically made up of several
    independent blocks put together. And when you are done with playing or want to
    preserve the incomplete structure to continue later on, we put it in a cover or
    a box and store it safely.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly when it comes to handling data on a computer, irrespective of whether
    it's an image, or an audio or video clip, or a PDF document, it's basically constructed
    from several bits of binary data. A **binary large object** (**blob**) is nothing
    but a collection of binary data stored inside a box/cover as a single entity for
    later use.
  prefs: []
  type: TYPE_NORMAL
- en: Here, blobs store any type of data irrespective of their structure. They concentrate
    on the content alone and not on the metadata of that content – not even the location
    of the file or its name.
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Tree objects are Git's internal representation of directories and the structure
    of your content. They're similar to a directory in your file system, which refers
    to files and/or other directories. Here, Git tree objects can refer to Git blobs
    and/or other Git tree objects.
  prefs: []
  type: TYPE_NORMAL
- en: Commits
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The commit object holds all the metadata for changes introduced to the repository's
    content. Metadata includes the author for the change, the committer of the change
    (yes, it's possible to have two different people) along with their e-mail addresses,
    the date, and the time.
  prefs: []
  type: TYPE_NORMAL
- en: Tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The tag object carries a human readable name, which can be attached to other
    objects, usually a commit object for easy retrieval and other reasons that we
    saw under the tagging topic in previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: HEAD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'HEAD is like a pointer which points the Git engine to the active branch (the
    branch we are currently working on) for further operations. When opened using
    a text editor, you will see the following if you are in the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'And you will see the following if you are presently working on the `test_release`
    branch, and so on and so forth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Refs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have ever wondered how reaching [google.com](http://google.com) and
    [173.194.35.39](http://173.194.35.39) from your browser both give you the same
    Google search page, you will realize that there should be a reference somewhere
    that maps these two. Another simple example: bring your attendance register where
    everybody''s name is mapped to a unique employee/student ID, which can be used
    to identify one person amongst several others with the same name and vice versa.'
  prefs: []
  type: TYPE_NORMAL
- en: Similarly the `refs` directory serves the purpose of referencing for Git on
    a few operations. It stores the SHA-1 IDs of important points in the repository,
    such as tags and branches. Metadata for the tags is stored inside another directory
    situated at `refs/tags` and metadata for branches is stored inside a different
    directory situated at `refs/heads`.
  prefs: []
  type: TYPE_NORMAL
- en: Each branch name is a file inside the `heads` directory, and the content of
    such files contains the SHA-1 ID of the commit from where that particular branch
    was created (the parent in Git terms). The same is the case for tags as well –
    each tag name is a file inside the `tags` directory, which has a single SHA-1
    ID for its reference.
  prefs: []
  type: TYPE_NORMAL
- en: Bumper alert – directories inside heads and tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We have spoken about files inside both the `tags` and `heads` directory, which
    represent the tag and branch names that you have created in the repository. Don't
    get puzzled if you happen to see one or more directory structures inside the `heads`
    and `tags` directory.
  prefs: []
  type: TYPE_NORMAL
- en: This is simply a representation of the hierarchically structured name that one
    would have given for the branch or tag. Things will get much clearer after looking
    at the following example, which focuses on the branching concept, which is also
    applicable for tags.
  prefs: []
  type: TYPE_NORMAL
- en: Create a branch with the name `mybranch` (`git branch mybranch`). This will
    create a file called `mybranch` located at `heads/mybranch`, whereas creating
    a branch with an hierarchical name like `kamia/kashin` (`git branch kamia/kashin`)
    will create a file called `kashin` located at `heads/kamia/kashin`.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have explored the important segments of a freshly initiated (new)
    Git repository that has no commits as yet. However there is one more key player
    called index, which gets created as soon as you add content to your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Index
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The index file is where Git stores your staging area information to be committed.
    To put it simply, the content of the index file becomes your next commit. In other
    words this is the place where you keep your files that you want to be committed
    to your repository.
  prefs: []
  type: TYPE_NORMAL
- en: Git – a content tracking system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important for us to understand how Git perceives data; it is not through
    the filename or the file's location in the directory structure; rather, it emphasizes
    the file's content. This means that when two or more files, irrespective of where
    they are located inside the repository, have the same content, Git sees the relation
    between them through their hashes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computing the hash is the first task for Git before storing any data permanently.
    The hash value for a given content is unique across the globe. This means that
    the hash value for a file containing "Hello world" in your computer is the same
    as mine or anyone else's.
  prefs: []
  type: TYPE_NORMAL
- en: Finding out the similarities, Git puts the content under one single blob object
    and stores it. Note that only one copy of the content is stored in the background
    thus minimizing hardware usage and when asked to reproduce, it can bring out the
    exact storage pattern with the usage of its metadata stored with tree objects.
  prefs: []
  type: TYPE_NORMAL
- en: This hash computing happens whenever required, at various stages, thereby even
    a small change in one of those files will deliver a new hash, which makes Git
    store it separately. Since these processes revolve (with major emphasis) around
    the content irrespective of the file's name or location, Git is often called a
    content tracking system.
  prefs: []
  type: TYPE_NORMAL
- en: Git add
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `add` is executed, Git updates the index using the current content found
    in the working tree (staging your changes), and prepares the content staged for
    the next commit, which involves the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Computing the hash for the content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deciding whether to create new content, or link to an existing blob object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Actual creation or linking of blob takes place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creation of a tree object to track location of the content.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point the index is said to hold a snapshot of the content in the working
    tree for the next commit.
  prefs: []
  type: TYPE_NORMAL
- en: As you already know, this command can be performed multiple times before a commit.
    It only adds the content of the specified file(s) at the time the `add` command
    is run; if you want subsequent changes included in the next commit, you must run
    `git add` again to add the new content to the index.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More importance is to be given to the process where both the blob and tree objects
    get created and linked with their respective hash IDs, as shown in the following
    figure.
  prefs: []
  type: TYPE_NORMAL
- en: '![Git add](img/7522_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As discussed earlier, a tree can not only point to a blob but also to another
    tree forming a hierarchical network, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Git add](img/7522_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Git commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `commit` command is executed, a commit object gets created with the
    metadata of the content/changes that were added earlier using the `git add` command.
    The metadata includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Name of the person who authored the change and the relevant date and time along
    with the time zone settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Name of the person who committed the change and the relevant date and time along
    with the time zone settings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then the created commit object gets linked to the tree object, which has already
    linked with the blob thus completing the versioning process as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Git commit](img/7522_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the head contains the branch name and not the SHA-1 ID of the commit
    that it is pointing to. This is because it becomes tough to identify a branch
    with its commit IDs when the volume and position of commits inside a branch keep
    changing, hence the statement "branch moves".
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do not worry about the blob and tree objects, which are created as a part of
    the `add` operation when not committed; these are destroyed as part of the garbage
    collection process after a few months.
  prefs: []
  type: TYPE_NORMAL
- en: Now if you do a `git status` you will see that the changes you staged are not
    in the staged changes state any longer.
  prefs: []
  type: TYPE_NORMAL
- en: Git status
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the `status` command is executed, Git checks for the file's path and size.
    If there are no differences, it leaves it as it is, but if any differences are
    found, it goes ahead and computes the hash with which it checks for a relation
    to other hashes, as we saw earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'The file path comparison as such happens in the following stages:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Stage number | Comparison | Related status message |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | File path present in index versus recent commit (HEAD commit) | Changes
    to be committed |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | File path present in index versus working tree | Changes not staged for
    commit |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | Paths in the working tree that are not tracked by Git (and are not ignored
    by `gitignore` or the exclude file) | Changes not staged for commit |'
  prefs: []
  type: TYPE_TB
- en: The first status denotes changes that have already been added (staged) but not
    committed. So executing `git commit` would complete the versioning process.
  prefs: []
  type: TYPE_NORMAL
- en: The second and third statuses denote that the changes are not yet added (staged)
    for a commit. So to complete the versioning process, we need to add them first
    using `git add` and then `git commit`.
  prefs: []
  type: TYPE_NORMAL
- en: Git clone
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `clone` command is executed, the internal process order would be as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the destination directory if it does not exist and execute `git init`
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up remote tracking branches in the destination repository for each branch
    present in the source repository (`git remote`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetch the objects, refs (inside the `.git` directory).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally do a checkout.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git remote
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `remote` command is executed, Git lists down all the remotes added
    to the repository by reading it from the remote section of the local config file
    located at `.git/config`. An example of the content inside the config file is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The name `capsource` was the alias we gave preceding the URL while adding a
    new remote to the repository. Under this section two reference parameters are
    captured:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Reference parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `url` | This is the URL of the remote repository that you want to track,
    share, and get content from, within your repository. |'
  prefs: []
  type: TYPE_TB
- en: '| `Fetch` | This is to convey to Git the refs (branches and tags) from the
    remote that are to be tracked.By default, it tracks all refs from the remote repository
    specified by `refs/heads/*`. These are placed under your local repository''s directory
    `capsource` located at `refs/remotes/capsource/*`. |'
  prefs: []
  type: TYPE_TB
- en: Git branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `branch` command is executed, it performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Collects all branch names from `.git/refs/heads/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finds the active/current working branch with the help of the entry in the HEAD
    located at `.git/HEAD`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Displays all the branches in ascending order with an asterisk (*) mark next
    to the active branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that the branches listed this way are only local branches of your repository.
    When you want all branches listed inclusive of remote tracking branches, which
    are stored inside `.git/refs/remotes/`, you will use `git branch –a`.
  prefs: []
  type: TYPE_NORMAL
- en: Git tag
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the `tag` command is executed, Git performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Gets the SHA-1 ID of the referred commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validates the given tag name with the existing tag names.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If it's a new name, it validates the name with the naming conventions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the name abides by the rules, a tag object gets created with the given name
    mapped to the acquired SHA-1 ID, which is found inside `.git/refs/tags/`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following figure shows the association of the tag object along with other
    objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Git tag](img/7522_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Git fetch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `fetch` is executed, Git performs the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Checks for the URL or remote name, which points to a valid Git repository specified
    in the command `git fetch remote_name` (or) `url`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If none is specified, it reads the config file to see if there is any default
    remote.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If found, it fetches the named refs (heads and tags) from the remote repository
    along with their associated objects.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The retrieved ref names are stored in `.git/FETCH_HEAD` to aid a possible merge
    operation in the future.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git merge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While executing the `merge` command, Git will perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify both the merge candidates from the `heads` directory based on specified
    parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the common ancestor of both heads and load all their objects in memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform a diff (difference) between the common ancestor and head one.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply the diff with head two.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are changes in common areas across heads, indicate the conflict with
    markers and inform the user about it (expecting the user to solve the conflict,
    add the changes, and make a commit).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If there are no conflicts, merge those contents, and make a merge commit mentioning
    metadata stating this.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git pull
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On executing the `pull` command, Git internally performs the following operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Git fetch` with the given parameters.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calls `git merge` to merge the retrieved branch head into the current branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Git push
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'On executing the `push` command, Git will perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify current branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Look up the existence of a default remote in the config file (if none is found,
    it prompts you to provide the remote name or URL as a parameter while executing
    `git push`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get to know the remote's URL and the heads (branches) tracked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check whether the remote has changed since the last time you fetched changes
    from it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Get the list of references from the remote repositories (using `git ls-remote`).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Check the existence of the entries from the list with the local history. If
    the reference from the remote is a part of the local repository's history, it's
    evident that there are no other changes since the last time you fetched/pulled
    from the remote. So Git will allow you to directly push your changes to the remote.
    If it's not a part of your local repository's history, Git understands that the
    remote repository has undergone some changes since the last time you fetched/pulled
    from it. So it will ask you to first do a `git fetch` or `git pull` before pushing.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Git checkout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When `checkout` is executed without any parameters, Git performs the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Fetches the named paths in the working tree.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fetches the related objects from the index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates the contents of the working tree with the ones from the index.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: However the behavior changes according to the parameters used.
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `-b` | This is used to spawn a new branch from the checked out position mentioned
    with the commit ID.`git checkout –b <your_branch_name>` is a short form of `git
    checkout branch` followed `by git checkout <branch_name>`.This command creates
    a new reference inside `.git/refs/heads/` with that particular commit ID. |'
  prefs: []
  type: TYPE_TB
- en: '| `--track` | This parameter is used to set up the upstream configuration usually
    while creating a new branch with the `–b` parameter.When executed, a separate
    section is added to the `.config` file inside the `.git` directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This happens when a command like `git checkout --track -b master origin/master`
    is executed. |
  prefs: []
  type: TYPE_NORMAL
- en: Relation across relations – Git packfiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw how Git sees the relation across files through its content and intelligently
    chooses between whether to create a new blob for the content or have an existing
    blob referenced to it. We also understood that even a small change in content
    will cause Git to store a separate blob because the SHA-1 ID will change.
  prefs: []
  type: TYPE_NORMAL
- en: Think about a situation where you have two text files, 5 MB each, with the same
    content but in different locations. Git will accordingly create a single blob
    as the same content will result in the same SHA-1 ID, thus saving space.
  prefs: []
  type: TYPE_NORMAL
- en: Now, append a line to the content of one of the files. Git will now create a
    new blob (5+ MB in size) for the second file, which has changed. Observing this
    behavior of having two nearly identical blobs of 5 MB, a few questions might arise.
  prefs: []
  type: TYPE_NORMAL
- en: Why does Git create a new blob for the entire content?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why not still have the same old blob shared between both files, and additionally
    create a new blob for the difference brought into the second file alone, thus
    reducing storage and being more efficient?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Well, these are good questions; Git has an answer that addresses those with
    something called **packfiles**. The objects created as mentioned in the scenario
    we just discussed are called loose objects, and automatically but occasionally
    Git packs up several of these loose objects into a single binary called a packfile.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring packfiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Git not only supports the transferring of refs and their associated plain blob,
    tree, commit, and tag objects but also packfiles on operations such as clone,
    fetch, push, and pull. Talking on a higher level, Git has two sets of protocols
    for transferring data between remotes.
  prefs: []
  type: TYPE_NORMAL
- en: One for pushing data from the client to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another for fetching data from the server to the client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '| Implemented side | Process invoked | Description |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Server side | Upload-pack | Invoked by `git fetch-pack`, it learns what objects
    the other side is missing, and sends them after packing. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Client side | Fetch-pack | This is responsible for receiving missing packages
    from another repository.This command is usually not called directly by the end
    user, instead `git fetch`, which is a higher level wrapper of this command, is
    executed. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Server side | Receive-pack | Invoked by `git send-pack`, this receives what
    is pushed into the repository. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: '| Client side | Send-pack | This is responsible for pushing objects over Git
    protocol to another repository.This command is usually not called directly by
    the end user, instead `git push`, which is a higher level wrapper of this command,
    is executed. |'
  prefs:
  - PREF_IND
  type: TYPE_TB
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned about the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The structure of a Git repository and the role each one of them plays in the
    versioning process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The different objects and how Git smartly manages the content using those objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additionally, we have also learned in detail about the internals of commands
    such as `init`, `add`, `commit`, `status`, `clone`, `fetch`, `merge`, `remote`,
    `pull`, `push`, `tag`, `branch`, and `checkout`, which we have used in earlier
    chapters to master the versioning concept.
  prefs: []
  type: TYPE_NORMAL
- en: Not only that, we also viewed at a high level about how Git not only understands
    relations between files based on their complete content but also partial content
    in the form of packfiles.
  prefs: []
  type: TYPE_NORMAL
