- en: '*Chapter 5*: Services and Ingress – Communicating with the Outside World'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter contains a comprehensive discussion of the methods that Kubernetes
    provides to allow applications to communicate with each other, and with resources
    outside the cluster. You'll learn about the Kubernetes Service resource and all
    its possible types – ClusterIP, NodePort, LoadBalancer, and ExternalName – as
    well as how to implement them. Finally, you'll learn how to use Kubernetes Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Services and cluster DNS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing ClusterIP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using NodePort
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a LoadBalancer Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an ExternalName Service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Ingress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to run the commands detailed in this chapter, you will need a computer
    that supports the `kubectl` command-line tool along with a working Kubernetes
    cluster. Review [*Chapter 1*](B14790_01_Final_PG_ePub.xhtml#_idTextAnchor016),
    *Communicating with Kubernetes*, to see several methods for getting up and running
    with Kubernetes quickly, and for instructions on how to install the `kubectl`
    tool.
  prefs: []
  type: TYPE_NORMAL
- en: The code used in this chapter can be found in the book's GitHub repository at
    [https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter5](https://github.com/PacktPublishing/Cloud-Native-with-Kubernetes/tree/master/Chapter5).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Services and cluster DNS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last few chapters, we've talked about how to run applications effectively
    on Kubernetes using resources including Pods, Deployments, and StatefulSets. However,
    many applications, such as web servers, need to be able to accept network requests
    from outside their containers. These requests could come either from other applications
    or from devices accessing the public internet.
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides several types of resources to handle various scenarios when
    it comes to allowing resources outside and inside the cluster to access applications
    running on Pods, Deployments, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'These fall into two major resource types, Services and Ingress:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Services** have several subtypes – ClusterIP, NodePort, and LoadBalancer
    – and are generally used to provide simple access to a single application from
    inside or outside the cluster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ingress** is a more advanced resource that creates a controller that takes
    care of pathname- and hostname-based routing to various resources running inside
    the cluster. Ingress works by using rules to forward traffic to Services. You
    need to use Services to use Ingress.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we get started with our first type of Service resource, let's review
    how Kubernetes handles DNS inside the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Cluster DNS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start by discussing which resources in Kubernetes get their own DNS names
    by default. DNS names in Kubernetes are restricted to Pods and Services. Pod DNS
    names contain several parts structured as subdomains.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical **Fully Qualified Domain Name** (**FQDN**) for a Pod running in Kubernetes
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break it down, starting from the rightmost side:'
  prefs: []
  type: TYPE_NORMAL
- en: '`my-cluster-domain.example` corresponds to the configured DNS name for the
    Cluster API itself. Depending on the tool used to set up the cluster, and the
    environment that it runs in, this can be an external domain name or an internal
    DNS name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`svc` is a section that will occur even in a Pod DNS name – so we can just
    assume it will be there. However, as you will see shortly, you won''t generally
    be accessing Pods or Services through their FQDNs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my-namespace` is pretty self-explanatory. This section of the DNS name will
    be whatever namespace your Pod is operating in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`my-subdomain` corresponds to the `subdomain` field in the Pod spec. This field
    is completely optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, `my-hostname` will be set to whatever the name of the Pod is in the
    Pod metadata.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Together, this DNS name allows other resources in the cluster to access a particular
    Pod. This generally isn't very helpful by itself, especially if you're using Deployments
    and StatefulSets that generally have multiple Pods. This is where Services come
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the A record DNS name for a Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it's very similar to the Pod DNS name, with the difference that
    we only have one value to the left of our namespace – which is the Service name
    (again, as with Pods, this is generated based on the metadata name).
  prefs: []
  type: TYPE_NORMAL
- en: One result of how these DNS names are handled is that within a namespace, you
    can access a Service or Pod via just its Service (or Pod) name, and the subdomain.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, take our previous Service DNS name. From within the `my-namespace`
    namespace, the Service can be accessed simply by the DNS name `my-svc`. From outside
    the `my-namespace` namespace, you can access the Service via `my-svc.my-namespace`.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've learned how in-cluster DNS works, we can discuss how that translates
    to the Service proxy.
  prefs: []
  type: TYPE_NORMAL
- en: Service proxy types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Services, explained as simply as possible, provide an abstraction to forward
    requests to one or more Pods that are running an application.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a Service, we define a selector that tells the Service which Pods
    to forward requests to. Through functionality in the `kube-proxy` component, when
    requests hit a Service, they will be forwarded to the various Pods that match
    the Service's selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three possible proxy modes that you can use in Kubernetes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Userspace proxy mode**: The oldest proxy mode, available since Kubernetes
    version 1.0\. This proxy mode will forward requests to the matched Pods in a round-robin
    fashion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Iptables proxy mode**: Available since 1.1, and the default since 1.2\. This
    offers a lower overhead than userspace mode and can use round robin or random
    selection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IPVS proxy mode**: The newest option, available since 1.8\. This proxy mode
    allows other load balancing options (not just Round Robin):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: a. Round Robin
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: b. Least Connection (the least number of open connections)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: c. Source Hashing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: d. Destination Hashing
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: e. Shortest Expected Delay
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: f. Never Queue
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Relevant to this list is a discussion of what round-robin load balancing is,
    for those not familiar.
  prefs: []
  type: TYPE_NORMAL
- en: 'Round-robin load balancing involves looping through the potential list of Service
    endpoints from beginning to end, per network request. The following diagram shows
    a simplified view of this process it pertains to Kubernetes Pods behind a Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – A Service load-balancing to Pods](img/B14790_05_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – A Service load-balancing to Pods
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the Service alternates which Pod it sends requests to. The first
    request goes to Pod A, the second goes to Pod B, the third goes to Pod C, and
    then it loops around. Now that we know how Services actually handle requests,
    let's review the major types of Services, starting with ClusterIP.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing ClusterIP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'ClusterIP is a simple type of Service exposed on an internal IP inside the
    cluster. This type of Service is not reachable from outside of the cluster. Let''s
    take a look at the YAML file for our Service:'
  prefs: []
  type: TYPE_NORMAL
- en: clusterip-service.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As with other Kubernetes resources, we have our metadata block with our `name`
    value. As you can recall from our discussion on DNS, this `name` value is how
    you can access your Service from elsewhere in the cluster. For this reason, ClusterIP
    is a great option for Services that only need to be accessed by other Pods within
    a cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have our `Spec`, which consists of three major pieces:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have our `type`, which corresponds to the type of our Service. Since
    the default type is `ClusterIP`, you don't actually need to specify a type if
    you want a ClusterIP Service.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we have our `selector`. Our `selector` consists of key-value pairs that
    must match labels in the metadata of the Pods in question. In this case, our Service
    will look for Pods with `app=web-application` and `environment=staging` to forward
    traffic to.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we have our `ports` block, where we can map ports on our Service to
    `targetPort` numbers on our Pods. In this case, port `80` (the HTTP port) on our
    Service will map to port `8080` on our application Pod. More than one port can
    be opened on our Service, but the `name` field is required when opening multiple
    ports.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, let's review the `protocol` options in depth, since these are important
    to our discussion of Service ports.
  prefs: []
  type: TYPE_NORMAL
- en: Protocol
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the case of our previous ClusterIP Service, we chose `TCP` as our protocol.
    Kubernetes currently (as of version 1.19) supports several protocols:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TCP**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UDP**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HTTP**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**PROXY**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SCTP**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is an area where new features are likely coming, especially where HTTP
    (L7) services are concerned. Currently, there is not full support of all of these
    protocols across environments or cloud providers.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information, you can check the main Kubernetes documentation ([https://kubernetes.io/docs/concepts/services-networking/service/](https://kubernetes.io/docs/concepts/services-networking/service/))
    for the current state of Service protocols.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we've discussed the specifics of Service YAMLs with Cluster IP, we
    can move on to the next type of Service – NodePort.
  prefs: []
  type: TYPE_NORMAL
- en: Using NodePort
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: NodePort is an external-facing Service type, which means that it can actually
    be accessed from outside the Cluster. When creating a NodePort Service, a ClusterIP
    Service of the same name will automatically be created and routed to by the NodePort,
    so you will still be able to access the Service from inside the cluster. This
    makes NodePort a good option for external access to applications when a LoadBalancer
    Service is not feasible or possible.
  prefs: []
  type: TYPE_NORMAL
- en: NodePort sounds like what it is – this type of Service opens a port on every
    Node in the cluster on which the Service can be accessed. This port will be in
    a range that is by default between `30000`-`32767` and will be linked automatically
    on Service creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s what our NodePort Service YAML looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: nodeport-service.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can tell, the only difference from the ClusterIP Service is the Service
    type – however, it is important to note that our intended port `80` in the `ports`
    section will only be used when accessing the automatically created ClusterIP version
    of the Service. From outside the cluster, we'll need to see what the generated
    port link is to access the Service on our Node IP.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we can create our Service with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'And then run this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the preceding command will be the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: From this output, we look to the `NodePort` line to see that our assigned port
    for this Service is `31598`. Thus, this Service can be accessed on any node at
    `[NODE_IP]:[ASSIGNED_PORT]`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we can manually assign a NodePort IP to the Service. The YAML
    for a manually assigned NodePort is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: manual-nodeport-service.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have chosen a `nodePort` in the range `30000`-`32767`, in
    this case, `31233`. To see exactly how this NodePort Service works across Nodes,
    take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2 – NodePort Service](img/B14790_05_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – NodePort Service
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, though the Service is accessible at every Node in the cluster
    (Node A, Node B, and Node C), network requests are still load-balanced across
    the Pods in all Nodes (Pod A, Pod B, and Pod C), not just the Node that is accessed.
    This is an effective way to ensure that the application can be accessed from any
    Node. When using cloud services, however, you already have a range of tools to
    spread requests between servers. The next type of Service, LoadBalancer, lets
    us use those tools in the context of Kubernetes.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a LoadBalancer Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: LoadBalancer is a special Service type in Kubernetes that provisions a load
    balancer based on where your cluster is running. For instance, in AWS, Kubernetes
    will provision an Elastic Load Balancer.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of LoadBalancer services and configurations, check the documentation
    for Kubernetes Services at [https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer](https://kubernetes.io/docs/concepts/services-networking/service/#loadbalancer).
  prefs: []
  type: TYPE_NORMAL
- en: 'Unlike with `ClusterIP` or NodePort, we can amend the functionality of a LoadBalancer
    Service in cloud-specific ways. Generally, this is done using an annotations block
    in the Service YAML file – which, as we''ve discussed before, is just a set of
    keys and values. To see how this is done for AWS, let''s review the spec for a
    LoadBalancer Service:'
  prefs: []
  type: TYPE_NORMAL
- en: loadbalancer-service.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Though we can create a LoadBalancer without any annotations, the supported AWS-specific
    annotations give us the ability (as seen in the preceding YAML code) to specify
    which TLS certificate (via its ARN in Amazon Certificate Manager) we want to be
    attached to our load balancer. AWS annotations also allow configuring logs for
    load balancers, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are a few key annotations supported by the AWS Cloud Provider as of the
    writing of this book:'
  prefs: []
  type: TYPE_NORMAL
- en: '`service.beta.kubernetes.io/aws-load-balancer-ssl-cert`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service.beta.kubernetes.io/aws-load-balancer-proxy-protocol`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`service.beta.kubernetes.io/aws-load-balancer-ssl-ports`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A full list of annotations and explanations for all providers can be found on
    the **Cloud Providers** page in the official Kubernetes documentation, at [https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/](https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, with LoadBalancer Services, we''ve covered the Service types you will
    likely use the most. However, for special cases where the Service itself runs
    outside of Kubernetes, we can use another Service type: ExternalName.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ExternalName Service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Services of type ExternalName can be used to proxify applications that are not
    actually running on your cluster, while still keeping the Service as a layer of
    abstraction that can be updated at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set the scene: you have a legacy production application running on Azure
    that you want to access from within your cluster. You can access this legacy application
    at `myoldapp.mydomain.com`. However, your team is currently working on containerizing
    this application and running it on Kubernetes, and that new version is currently
    working in your `dev` namespace environment on your cluster.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of asking your other applications to talk to different places depending
    on the environment, you can always point to a Service called `my-svc` in both
    your production (`prod`) and development (`dev`) namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `dev`, this Service could be a `ClusterIP` Service that leads to your newly
    containerized application on Pods. The following YAML shows how the in-development,
    containerized Service should work:'
  prefs: []
  type: TYPE_NORMAL
- en: clusterip-for-external-service.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `prod` namespace, this Service would instead be an `ExternalName` Service:'
  prefs: []
  type: TYPE_NORMAL
- en: externalname-service.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since our `ExternalName` Service is not actually forwarding requests to Pods,
    we don't need a selector. Instead, we specify an `ExternalName`, which is the
    DNS name we want the Service to direct to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how an `ExternalName` Service could be used in
    this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – ExternalName Service configuration](img/B14790_05_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – ExternalName Service configuration
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding diagram, our **EC2 Running Legacy Application** is an AWS VM,
    external to the cluster. Our **Service B** of type **ExternalName** will route
    requests out to the VM. That way, our **Pod C** (or any other Pod in the cluster)
    can access our external legacy application simply through the ExternalName services'
    Kubernetes DNS name.
  prefs: []
  type: TYPE_NORMAL
- en: With `ExternalName`, we've finished our review of all the Kubernetes Service
    types. Let's move on to a more complex method of exposing applications – the Kubernetes
    Ingress resource.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Ingress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned at the beginning of the chapter, Ingress provides a granular mechanism
    for routing requests into a cluster. Ingress does not replace Services but augments
    them with capabilities such as path-based routing. Why is this necessary? There
    are plenty of reasons, including cost. An Ingress with 10 paths to `ClusterIP`
    Services is a lot cheaper than creating a new LoadBalancer Service for each path
    – plus it keeps things simple and easy to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ingresses do not work like other Services in Kubernetes. Just creating the
    Ingress itself will do nothing. You need two additional components:'
  prefs: []
  type: TYPE_NORMAL
- en: 'An Ingress controller: you can choose from many implementations, built on tools
    such as Nginx or HAProxy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ClusterIP or NodePort Services for the intended routes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First, let's discuss how to configure the Ingress controller.
  prefs: []
  type: TYPE_NORMAL
- en: Ingress controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, clusters will not come configured with any pre-existing Ingress controllers.
    You'll need to select and deploy one to your cluster. `ingress-nginx` is likely
    the most popular choice, but there are several others – see [https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/](https://kubernetes.io/docs/concepts/services-networking/ingress-controllers/)
    for a full list.
  prefs: []
  type: TYPE_NORMAL
- en: Let's learn how to deploy an Ingress controller - for the purposes of this book,
    we'll stick with the Nginx Ingress controller created by the Kubernetes community,
    `ingress-nginx`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Installation may differ from controller to controller, but for `ingress-nginx`
    there are two main parts. First, to deploy the main controller itself, run the
    following command, which may change depending on the target environment and newest
    Nginx Ingress version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Secondly, we may need to configure our Ingress depending on which environment
    we're running in. For a cluster running on AWS, we can configure the Ingress entry
    point to use an Elastic Load Balancer that we create in AWS.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To see all environment-specific setup instructions, see the `ingress-nginx`
    docs at [https://kubernetes.github.io/ingress-nginx/deploy/](https://kubernetes.github.io/ingress-nginx/deploy/).
  prefs: []
  type: TYPE_NORMAL
- en: The Nginx ingress controller is a set of Pods that will auto-update the Nginx
    configuration whenever a new Ingress resource (a custom Kubernetes resource) is
    created. In addition to the Ingress controller, we will need a way to route requests
    to the Ingress controller – known as the entry point.
  prefs: []
  type: TYPE_NORMAL
- en: Ingress entry point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The default `nginx-ingress` install will also create a singular Service that
    serves requests to the Nginx layer, at which point the Ingress rules take over.
    Depending on how you configure your Ingress, this can be a LoadBalancer or NodePort
    Service. In a cloud environment, you will likely use a cloud LoadBalancer Service
    as the entry point to the cluster Ingress.
  prefs: []
  type: TYPE_NORMAL
- en: Ingress rules and YAML
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we have our Ingress controller up and running, we can start configuring
    our Ingress rules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with a simple example. We have two Services, `service-a` and `service-b`,
    that we want to expose on different paths via our Ingress. Once your Ingress controller
    and any associated Elastic Load Balancers are created (assuming we''re running
    on AWS), let''s first create our Services by working through the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at how to create Service A in YAML. Let''s call the file
    `service-a.yaml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can create our Service A by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s create our Service B, for which the YAML code looks very similar:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create our Service B by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can create our Ingress with rules for each path. Here is the YAML
    code for our Ingress that will split requests as necessary based on path-based
    routing rules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: ingress.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In our preceding YAML, the ingress has a singular `host` value, which would
    correspond to the host request header for traffic coming through the Ingress.
    Then, we have two paths, `/a` and `/b`, which lead to our two previously created
    `ClusterIP` Services. To put this configuration in a graphical format, let''s
    take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Kubernetes Ingress example](img/B14790_05_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Kubernetes Ingress example
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, our simple path-based rules result in network requests getting
    routed directly to the proper Pods. This is because `nginx-ingress` uses the Service
    selector to get a list of Pod IPs, but does not directly use the Service to communicate
    with the Pods. Rather, the Nginx (in this case) config is automatically updated
    as new Pod IPs come online.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `host` value isn''t actually required. If you leave it out, any traffic
    that comes through the Ingress, regardless of the host header (unless it matches
    a different rule that specifies a host) will be routed according to the rule.
    The following YAML shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: ingress-no-host.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This previous Ingress definition will flow traffic to the path-based routing
    rules even if there is no host header value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, it is possible to split traffic into multiple separate branching
    paths based on the host header, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: ingress-branching.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, you can also secure your Ingress with TLS in many cases, though this
    functionality differs on a per Ingress controller basis. For Nginx, this can be
    done by using a Kubernetes Secret. We''ll get to this functionality in the next
    chapter but for now, check out the configuration on the Ingress side:'
  prefs: []
  type: TYPE_NORMAL
- en: ingress-secure.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This configuration will look for a Kubernetes Secret named `my-tls-secret` in
    the default namespace to attach to the Ingress for TLS.
  prefs: []
  type: TYPE_NORMAL
- en: That ends our discussion of Ingress. A lot of Ingress functionality can be specific
    to which Ingress controller you decide to use, so check out the documentation
    for your chosen implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the various methods that Kubernetes provides in
    order to expose applications running on the cluster to the outside world. The
    major methods are Services and Ingress. Within Services, you can use ClusterIP
    Services for in-cluster routing and NodePort for access to a Service directly
    via ports on Nodes. LoadBalancer Services let you use existing cloud load-balancing
    systems, and ExternalName Services let you route requests out of the cluster to
    external resources.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, Ingress provides a powerful tool to route requests in the cluster by
    path. To implement Ingress you need to install a third-party or open source Ingress
    controller on your cluster.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we''ll talk about how to inject configuration information
    into your applications running on Kubernetes using two resource types: ConfigMap
    and Secret.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What type of Service would you use for applications that are only accessed internally
    in a cluster?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you tell which port a NodePort Service is active on?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why can Ingress be more cost-effective than purely Services?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Other than supporting legacy applications, how might ExternalName Services be
    useful on a cloud platform?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Information on cloud providers, from the Kubernetes documentation: [https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/](https://kubernetes.io/docs/tasks/administer-cluster/running-cloud-controller/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
