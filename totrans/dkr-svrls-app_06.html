<html><head></head><body>
        

                            
                    <h1 class="header-title">OpenWhisk on Docker</h1>
                
            
            
                
<p class="mce-root">This chapter will discuss another player in the serverless space, OpenWhisk. The chapter will start with an overview of the OpenWhisk platform, its design rationale, and features. After that, the chapter will go through the steps of deploying a local instance of OpenWhisk for function development, how to use its command-line interface, its components and architecture, and how to prepare functions to deploy on the platform.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is OpenWhisk?</h1>
                
            
            
                
<p>Donated to the Apache foundation, OpenWhisk is a robust FaaS platform originally developed by IBM and Adobe. Built atop Docker container technologies, OpenWhisk can be deployed in the cloud or on on-premises hardware. It is a platform that frees developers from worrying about managing the life cycle of their code or operations of the container runtimes that execute the code. OpenWhisk is designed to be scalable and to support massive numbers of function invocations. Currently, OpenWhisk is the engine behind IBM Cloud Functions.</p>
<p>The OpenWhisk scaling mechanism is not built on top of Docker Swarm or Kubernetes schedulers. It plugs directly into each Docker instance to start and scale function containers. With this design, OpenWhisk fits better with the plain Docker infrastructure than Kubernetes.</p>
<p>For developers, OpenWhisk provides a number of compelling features via its high-level programming model surrounding functions. Its event triggering mechanism is shown in Figure 6.1:</p>
<div><img src="img/f10236a1-723f-41aa-8756-1fe01f159c0e.png" style="width:49.00em;height:22.08em;"/></div>
<p>Figure 6.1: OpenWhisk's flow of event triggering</p>
<p>Similar to other platforms, OpenWhisk's smallest deployment unit is a function. In OpenWhisk, a function is referred to as an action. An action can be executed in response to an event. An event, in the form of a trigger, will be processed through a rule, where it selects an appropriate action to execute. After the action is executed, its result will be stored in the result storage before being emitted back to the source of the event.</p>
<p>OpenWhisk natively supports many language runtimes out of the box. However, this chapter focuses only on its Docker runtime, which allows developers to pack any kind of workload into a container and let OpenWhisk do the rest. An action in OpenWhisk can be invoked synchronously, asynchronously, or even on a schedule. Besides an action, OpenWhisk provides a declarative programming construct, such as a sequence to allow multiple actions to be chained and executed as a flow.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Installing OpenWhisk</h1>
                
            
            
                
<p>At the time of writing, the quickest way to install OpenWhisk on a local machine is to use Docker and Docker Compose.</p>
<p>To install Docker Compose, we can follow instructions from <a href="https://github.com/docker/compose/releases">https://github.com/docker/compose/releases</a>:</p>
<pre><strong>$ sudo curl -L https://github.com/docker/compose/releases/download/1.17.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose</strong><br/><strong>$ sudo chmod +x /usr/local/bin/docker-compose</strong></pre>
<p>To check the version of Docker Compose, use the following command:</p>
<pre><strong>$ docker-compose --version</strong><br/><strong>docker-compose version 1.17.1, build 6d101fb</strong></pre>
<p>We use Docker Compose 1.17.1 in this chapter.</p>
<p>Also check if the Git is installed already. If so, now we are ready to install a local OpenWhisk instance.</p>
<p>First, clone the OpenWhisk Dev tools repository from GitHub (<a href="https://github.com/apache/incubator-openwhisk-devtools">https://github.com/apache/incubator-openwhisk-devtools</a>) using the following command:</p>
<pre><strong>$ git clone --depth=1 https://github.com/apache/incubator-openwhisk-devtools</strong></pre>
<p>The <kbd>--depth=1</kbd> tells <kbd>git</kbd> to shallow clone the repository, which means that only the latest revision of the Git history will be there to save time and space.</p>
<p>Next, move into the directory <kbd>incubator-openwhisk-devtools/docker-compose</kbd>. This directory contains <kbd>docker-compose.yml</kbd> and the required environment variables to start a single node OpenWhisk instance. Look for a <kbd>Makefile</kbd> there; it contains the <kbd>quick-start</kbd> target to provision an instance, set up the initial data, and invoke an example function:</p>
<pre><strong>$ make quick-start</strong></pre>
<p>The command will be doing the following.</p>
<p>First, it will download the latest source of OpenWhisk from the <kbd>master</kbd> branch of its GitHub repository, along with the <kbd>wsk</kbd> CLI binary. Second, it will start an OpenWhisk local cluster and initialize the data with the Ansible playbooks that came with the OpenWhisk source tree. Then it will register the <kbd>hello-world</kbd> function and finally invoke it:</p>
<pre><strong>Response body size is 9 bytes</strong><br/><strong>Response body received:</strong><br/><strong>["guest"]</strong><br/><strong>ok: whisk auth set. Run 'wsk property get --auth' to see the new value.</strong><br/><strong>ok: whisk API host set to 192.168.1.40:443</strong><br/><strong>ok: whisk namespace set to guest</strong><br/><strong>waiting for the Whisk invoker to come up ... </strong><br/><strong>creating the hello.js function ...</strong><br/><strong>invoking the hello-world function ... </strong><br/><strong>adding the function to whisk ...</strong><br/><strong>ok: created action hello</strong><br/><strong>invoking the function ...</strong><br/><strong>invocation result: { "payload": "Hello, World!" }</strong><br/><strong>{ "payload": "Hello, World!" }</strong><br/><strong>deleting the function ...</strong><br/><strong>ok: deleted action hello</strong><br/><strong>To invoke the function again use: make hello-world</strong><br/><strong>To stop openwhisk use: make destroy</strong></pre>
<p>Sometimes, when the process is up and running, the instance becomes flaky. Simply press <em>Ctrl</em> + <em>C</em> and issue the command <kbd>make run</kbd> instead of <kbd>make quick-start</kbd> to try to start the instance again. If you'd like to start over, simply run the <kbd>make destroy</kbd> command to destroy the instance. After destroying it, you can start over with <kbd>make quick-start</kbd>.</p>
<p>If the output ends like this, OpenWhisk is now ready to serve at <kbd>localhost:443</kbd>:</p>
<pre><strong>Response body received:</strong><br/><strong>["guest"]</strong><br/><strong>ok: whisk auth set. Run 'wsk property get --auth' to see the new value.</strong><br/><strong>ok: whisk API host set to localhost:443</strong><br/><strong>ok: whisk namespace set to guest</strong></pre>
<p>We can then use the <kbd>docker ps</kbd> command to double check that all OpenWhisk containers are running:</p>
<pre><strong>$ docker ps --format "table {{.ID}}\t{{.Image}}"</strong><br/><strong>CONTAINER ID    IMAGE</strong><br/><strong>5e44dca4c542    openwhisk/nodejs6action:latest</strong><br/><strong>d784018ef3de    adobeapiplatform/apigateway:1.1.0</strong><br/><strong>74b6b1d71510    openwhisk/controller</strong><br/><strong>0c0cb4779412    openwhisk/invoker</strong><br/><strong>b0111898e1a8    nginx:latest</strong><br/><strong>874dac58a7c1    landoop/kafka-topics-ui:0.9.3</strong><br/><strong>611e9b97ad74    confluentinc/cp-kafka-rest:3.3.1</strong><br/><strong>4e1a82df737e    wurstmeister/kafka:0.11.0.1</strong><br/><strong>9c490336abff    redis:2.8</strong><br/><strong>abc4c0845fac    couchdb:1.6</strong><br/><strong>451ab4c7bf45    zookeeper:3.4</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Using the wsk client</h1>
                
            
            
                
<p>The <kbd>wsk</kbd> client will have already been installed by the <kbd>make quick-start</kbd> command. The <kbd>wsk</kbd> binary can be found at <kbd>openmaster/bin/wsk</kbd>. We usually copy the <kbd>wsk</kbd> CLI to <kbd>/usr/local/bin</kbd> and set up bash completion for it:</p>
<pre><strong>$ sudo cp openwhisk-master/bin/wsk /usr/local/bin</strong><br/><br/><strong>$ wsk sdk install bashauto</strong><br/><strong>The bash auto-completion script (wsk_cli_bash_completion.sh) is installed in the current directory.</strong><br/><strong>To enable command line completion of wsk commands, source the auto completion script into your bash environment</strong><br/><br/><strong>$ source wsk_cli_bash_completion.sh</strong><br/><strong>$ wsk</strong><br/><br/><strong>        ____      ___                   _    _ _     _     _</strong><br/><strong>       /\   \    / _ \ _ __   ___ _ __ | |  | | |__ (_)___| | __</strong><br/><strong>  /\  /__\   \  | | | | '_ \ / _ \ '_ \| |  | | '_ \| / __| |/ /</strong><br/><strong> /  \____ \  /  | |_| | |_) |  __/ | | | |/\| | | | | \__ \   &lt;</strong><br/><strong> \   \  /  \/    \___/| .__/ \___|_| |_|__/\__|_| |_|_|___/_|\_\</strong><br/><strong>  \___\/ tm           |_|</strong><br/><br/><strong>Usage:</strong><br/><strong>  wsk [command]</strong><br/><br/><strong>...</strong></pre>
<p>The first sub-command introduced here is <kbd>wsk property get</kbd>. It is to display OpenWhisk information, including the current namespace, the authentication key, and the build number. For example, we use <kbd>-i</kbd> or <kbd>--insecure</kbd> for insecurely connecting to the OpenWhisk instance as the generated certificate is self-signed:</p>
<pre><strong>$ wsk -i property get</strong><br/><strong>client cert </strong><br/><strong>Client key </strong><br/><strong>whisk auth              23bc46b1-71f6-4ed5-8c54-816aa4f8c502:123zO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP</strong><br/><strong>whisk API host          localhost:443</strong><br/><strong>whisk API version       v1</strong><br/><strong>whisk namespace         guest</strong><br/><strong>whisk CLI version       2017-12-05T00:51:32+00:00</strong><br/><strong>whisk API build         "09/01/2016"</strong><br/><strong>whisk API build number  "latest"</strong></pre>
<p>What does the information tell us? We are currently at the guest <kbd>namespace</kbd> using API version 1 and the long string, starting with <kbd>23bc</kbd>, is our API key for authentication. Any OpenWhisk client, including the <kbd>wsk</kbd> itself, needs this key to connect to the OpenWhisk instance. Our current API gateway is at <kbd>localhost:443</kbd>, which will forward all requests to the underlying controllers. The overview of each OpenWhisk component and the architecture will be discussed in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Components and architecture</h1>
                
            
            
                
<p class="mce-root">In this section, we discuss the architecture and components of OpenWhisk. OpenWhisk is designed to be a rock-solid FaaS platform as it is powering IBM Cloud Function, one of the FaaS production systems already launched by IBM. The key of this rock-solid architecture is Kafka. OpenWhisk cleverly uses Kafka as its backbone to guarantee that every single function request accepted by Kafka will be delivered to the invoker layer. Let's start by looking its overall architecture.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Architecture</h1>
                
            
            
                
<p>The following diagram in <em>Figure 6.2</em> shows the overall architecture of OpenWhisk:</p>
<div><img src="img/c783eee1-e45d-4c01-9f39-ac503a26052d.png" style="border: 1em solid black;color: #333333;text-align: center;width:40.25em;height:31.25em;"/></div>
<p>Figure 6.2: The overview architecture of OpenWhisk.</p>
<p>The edge component is the API gateway built on top of NGINX and OpenResty. The API gateway optionally uses Redis for caching. The API gateway sits in front of one or more controllers. The controller stores all configuration in a CouchDB cluster. Behind the controller, there is a Kafka cluster coordinated by a ZooKeeper quorum. The Kafka cluster is very important; every invocation is guaranteed to be executed. Kafka acts as a resilient buffer between controllers and invokers. Each invoker is responsible for invoking real implementations of functions, in this case Docker containers. Therefore, an invoker requires a special privilege to connect to the host's Docker socket. An invoker is optionally able to use <kbd>docker-runc</kbd> to improve the performance of the invocation process. Every single component of OpenWhisk is able to run inside a container, such as when we deployed it with Docker Compose.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Components</h1>
                
            
            
                
<p>Now we will proceed to the details of each component.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">API gateway</h1>
                
            
            
                
<p>The API gateway component of OpenWhisk is built atop NGINX and OpenResty technologies. The main reason NGINX is chosen is because it provides high performance as the edge component of the platform. NGINX sits in front of every other component in the system. The API gateway is capable of caching the request with OpenResty talking to a Redis cluster on its side. However, Redis is an optional component. It can easily be disabled by removing it from the Docker Compose configuration. The API gateway is also responsible for severing the secured HTTPS protocol from users.</p>
<p>The current version of the API gateway is <kbd>adobeapiplatform/apigateway:1.1.0</kbd>. It is the version of the API gateway under joint development by Adobe and IBM.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Controller</h1>
                
            
            
                
<p>A controller is one of the most important components of OpenWhisk. As the name implies, it mainly controls the invocation process of the cluster. Controllers can work without having the API gateway in front of them. A controller serves the HTTP protocol directly, in an insecure form, as the HTTPS part is the function of the API gateway. Basically, a controller source is a part of the OpenWhisk project. The configuration used in this chapter is the latest Docker image published by OpenWhisk.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Database</h1>
                
            
            
                
<p>The storage component of OpenWhisk is CouchDB. CouchDB is highly available, document-based data storage. The controller talks to CouchDB to store every entity related to the function invocation. The most important entity stored in CouchDB is the activation data. The activation data contains information of each invocation process. The progress of actions and their results are stored in the form of <em>activation documents</em>.</p>
<p>The official CouchDB version 1.6, <kbd>couchdb:1.6</kbd>, is used in the current configuration.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Kafka</h1>
                
            
            
                
<p>Kafka plays a very important role in the system. By nature, Kafka is a message broker that stores every received message and replays them reliably. With Kafka as the backbone, requests for action invocation will be reliably delivered to the invokers.</p>
<p>Kafka is formed as a cluster using the ZooKeeper quorum. Kafka is running on port <kbd>9092</kbd> within the default network. We use the <kbd>wurstmeister/kafka:0.11.0.1</kbd> image for the configuration in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Invoker</h1>
                
            
            
                
<p>The invoker is the component that is responsible for receiving invocation requests from Kafka topics, message queues that consumers could subscribe to receive messages. After receiving the messages, the invoker executes the functions using a backend runtime. OpenWhisk supports both native and Docker runtimes. The Docker runtime is internally called <strong>blackbox</strong>.</p>
<p>OpenWhisk also has an option to use Docker's <kbd>runc</kbd> directly to improve the function performance. With this architecture, the invoker requires access to <kbd>/var/run/docker.sock</kbd> of the local Docker host. This limitation prevents OpenWhisk from scaling efficiently in Swarm mode. We will discuss the new architecture for OpenWhisk over Swarm in a later chapter, when we discuss the deployment of OpenWhisk in a production environment.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Action runtime</h1>
                
            
            
                
<p>There are several kinds of runtime provided by OpenWhisk. Java, Node.js, and Python are native runtimes, for example. As previously mentioned, the Docker runtime is called blackbox.</p>
<p>The runtime takes the Docker image registered by the process of action creation. Then it starts the Docker container to accept the request. The runtime can keep the container running so subsequent calls can be significantly faster.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Function preparation</h1>
                
            
            
                
<p>In this section, we discuss how to prepare a function using the Docker template called <strong>Docker skeleton</strong>, provided by OpenWhisk.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">OpenWhisk Docker SDK</h1>
                
            
            
                
<p>To install the Docker skeleton, normally we would do the following:</p>
<pre><strong>$ wsk -i sdk install docker</strong></pre>
<p class="mce-root">But if the file does not exist on your local OpenWhisk, you can download it directly from <a href="https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz">https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz</a>.</p>
<p>The following steps are to download SDK, extract the SDK, change its directory from <kbd>dockerSkeleton</kbd> to <kbd>docker_c</kbd>, and change into the <kbd>docker_c</kbd> directory to check its contents:</p>
<pre><strong>$ curl -sSL -O https://github.com/apache/incubator-openwhisk-runtime-docker/releases/download/sdk%400.1.0/blackbox-0.1.0.tar.gz<br/></strong><strong>$ tar xf blackbox-0.1.0.tar.gz</strong><br/><strong>$ mv dockerSkeleton docker_c</strong><br/><strong>$ cd docker_c</strong><br/><strong>$ ls</strong><br/><strong>buildAndPush.sh Dockerfile example.c README.md</strong></pre>
<p>The skeleton contains a Dockerfile, a simple C program, a bash script for building and pushing the finished function to Docker's Hub, and a <kbd>README.md</kbd> file.</p>
<p>We start with the content of the C program to see what it is for. The C program that came with the Docker skeleton SDK contains only the <kbd>main</kbd> function with a couple of <kbd>printf</kbd> statements:</p>
<pre>#include &lt;stdio.h&gt;<br/><br/>int main(int argc, char *argv[]) {<br/>    printf("This is a log message from an arbitrary C program!\n");<br/>    printf("{ \"msg\": \"Hello from C program!\", \"args\": %s }",<br/>      (argc == 1) ? "undefined" : argv[1]);<br/>}</pre>
<p>The last <kbd>printf</kbd> line tells us the whole story of OpenWhisk's action. This action returns JSON data by printing it out to STDOUT. The action accepts arguments, also in the form of JSON, through the main function's <kbd>argv</kbd>. It is the action's responsibility to decode the arguments and encode the output.</p>
<p>Next, we'll take a look at its <kbd>Dockerfile</kbd>.</p>
<p>The file starts by declaring <kbd>openwhisk/dockerskeleton</kbd> as the base image. In the next line, the environment variable <kbd>FLASK_PROXY_PORT</kbd> is defined as <kbd>8080</kbd>. You may guess here that the framework used as the wrapper of every Docker function is <kbd>Flask</kbd>, a Python web framework.</p>
<p>Moving to the next two lines, they add the C program into the building container, install the GCC compiler, and then compile the program. The output binary is named <kbd>exec</kbd>. It must be placed at <kbd>/action/exec</kbd>. This is the mandatory location of the executable needed by OpenWhisk's <kbd>actionproxy</kbd>.</p>
<p>What is <kbd>actionproxy</kbd>? It is the OpenWhisk version of a function wrapping server. The server accepts a web request through its exposed port, <kbd>8080</kbd>. As mentioned earlier, it is written in Python with the Flask framework, so every OpenWhisk function requires Python and Flask dependencies in order to start the <kbd>actionproxy</kbd>. This kind of setup is already there by inheriting from the base image, <kbd>openwhisk/dockerskeleton</kbd>:</p>
<pre># Dockerfile for example whisk docker action<br/>FROM openwhisk/dockerskeleton<br/> <br/>ENV FLASK_PROXY_PORT 8080<br/><br/>### Add source file(s)<br/>ADD example.c /action/example.c<br/><br/>RUN apk add --no-cache --virtual .build-deps \<br/>        bzip2-dev \<br/>        gcc \<br/>        libc-dev \<br/>### Compile source file(s)<br/> &amp;&amp; cd /action; gcc -o exec example.c \<br/> &amp;&amp; apk del .build-deps<br/><br/>CMD ["/bin/bash", "-c", "cd actionProxy &amp;&amp; python -u actionproxy.py"]</pre>
<p>Instead of using the provided script, we will build it ourselves using the <kbd>docker build</kbd> command. Please recall that you need to use your own <kbd>&lt;DOCKER ID&gt;</kbd> as the repository name to allow you to push the built image onto Docker Hub:</p>
<pre>$ docker build -t chanwit/whisk_c .<br/><br/>Sending build context to Docker daemon 6.656kB<br/>Step 1/5 : FROM openwhisk/dockerskeleton<br/>latest: Pulling from openwhisk/dockerskeleton<br/>...<br/> ---&gt; 25d1878c2f31<br/>Step 2/5 : ENV FLASK_PROXY_PORT 8080<br/> ---&gt; Running in 932e3e3d6c0b<br/> ---&gt; 647789067bf0<br/>Removing intermediate container 932e3e3d6c0b<br/>Step 3/5 : ADD example.c /action/example.c<br/> ---&gt; 91eb99956da2<br/>Step 4/5 : RUN apk add --no-cache --virtual .build-deps bzip2-dev gcc <br/>       libc-dev &amp;&amp; cd /action; gcc -o exec example.c &amp;&amp; apk del .build-deps<br/> ---&gt; Running in 943930981ac6<br/>fetch http://dl-cdn.alpinelinux.org/alpine/v3.4/main/x86_64/APKINDEX.tar.gz<br/>fetch http://dl-cdn.alpinelinux.org/alpine/v3.4/community/x86_64/APKINDEX.tar.gz<br/>(1/19) Upgrading musl (1.1.14-r15 -&gt; 1.1.14-r16)<br/>...<br/>(17/17) Purging libgcc (5.3.0-r0)<br/>Executing busybox-1.24.2-r13.trigger<br/>OK: 32 MiB in 35 packages<br/> ---&gt; d1cc0ed0f307<br/>Removing intermediate container 943930981ac6<br/>Step 5/5 : CMD /bin/bash -c cd actionProxy &amp;&amp; python -u actionproxy.py<br/> ---&gt; Running in fc68fc0ba06f<br/> ---&gt; 924277b2a3a0<br/>Removing intermediate container fc68fc0ba06f<br/>Successfully built 924277b2a3a0<br/>Successfully tagged chanwit/whisk_c:latest</pre>
<p>If everything was done correctly, don't forget to use the <kbd>docker push</kbd> command to store this image on the Hub.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Preparing a Go function</h1>
                
            
            
                
<p>Next, we will write a function using the Go programming language to show you how to decode JSON parameters using the Go built-in library. Of course, we will modify OpenWhisk's Docker skeleton by adding Go compilers and use a multi-stage build to optimize the build process.</p>
<p>Let's start over.</p>
<p>We'll untar the Docker skeleton again, and this time we rename the <kbd>dockerSkeleton</kbd> directory <kbd>docker_go</kbd>:</p>
<pre><strong>$ tar xf blackbox-0.1.0.tar.gz</strong><br/><strong>$ mv dockerSkeleton docker_go</strong><br/><strong>$ cd docker_go</strong></pre>
<p>Inside the <kbd>docker_go</kbd> directory, we will write a Go program to decode the JSON <kbd>params</kbd> of the action, rearrange them, encode them back to JSON, and write them to the caller:</p>
<pre>package main<br/><br/>import (<br/>  "encoding/json"<br/>  "fmt"<br/>  "os"<br/>)<br/><br/>func main() {<br/>  rawParams := []byte(os.Args[1])<br/>  params := map[string]string{}<br/><br/>  // decode JSON to a Go map<br/>  err := json.Unmarshal(rawParams, &amp;params)<br/>  if err != nil {<br/>    fmt.Printf(`{"error":%q}`, err.Error())<br/>    os.Exit(0)<br/>  }<br/><br/>  // re-arrange<br/>  keys := []string{}<br/>  values := []string{}<br/>  for k, v := range params {<br/>    keys = append(keys, k)<br/>    values = append(values, v)<br/>  }<br/><br/>  result := map[string]interface{}{<br/>    "message": "Hello from Go",<br/>    "keys": keys,<br/>    "values": values,<br/>  }<br/><br/>  // encode<br/>  rawResult, err := json.Marshal(result)<br/>  if err != nil {<br/>    fmt.Printf(`{"error":%q}`, err.Error())<br/>    os.Exit(0)<br/>  }<br/><br/>  // write JSON back to the caller<br/>  fmt.Print(string(rawResult))<br/>}</pre>
<p>We save this program as <kbd>main.go</kbd> before continuing to the next step, writing our Dockerfile for multi-stage builds to compile the Go program, and pack it as an OpenWhisk action. Here's the new version of <kbd>Dockerfile</kbd>. Its first build stage is to compile the Go program using Go 1.9.2. Please note that we compile it into a statically linked binary so that it can run independently inside the OpenWhisk base image. In the second build stage, we copy the binary <kbd>/go/src/app/main</kbd> from the first stage as <kbd>/action/exec</kbd>, the binary location required for OpenWhisk <kbd>actionproxy</kbd> to execute:</p>
<pre># Compile the Go program<br/>FROM golang:1.9.2-alpine3.6<br/><br/>WORKDIR /go/src/app<br/>COPY main.go .<br/><br/>RUN CGO_ENABLED=0 go build -a -ldflags '-extldflags "-static"' main.go<br/><br/># Build using the base image for whisk docker action<br/>FROM openwhisk/dockerskeleton<br/><br/>ENV FLASK_PROXY_PORT 8080<br/><br/>COPY --from=0 /go/src/app/main /action/exec<br/><br/>CMD ["/bin/bash", "-c", "cd actionProxy &amp;&amp; python -u actionproxy.py"]</pre>
<p>Now the <kbd>Dockerfile</kbd> is ready. Let's build it using the <kbd>docker build</kbd> command:</p>
<pre><strong>$ docker build -t chanwit/whisk_go .</strong><br/><strong>Sending build context to Docker daemon 2.242MB</strong><br/><strong>Step 1/8 : FROM golang:1.9.2-alpine3.6</strong><br/><strong> ---&gt; bbab7aea1231</strong><br/><strong>Step 2/8 : WORKDIR /go/src/app</strong><br/><strong> ---&gt; a219190c401f</strong><br/><strong>Removing intermediate container 2a665bded884</strong><br/><strong>Step 3/8 : COPY main.go .</strong><br/><strong> ---&gt; f0df3a87489d</strong><br/><strong>Step 4/8 : RUN CGO_ENABLED=0 go build -a -ldflags '-extldflags "-static"' main.go</strong><br/><strong> ---&gt; Running in ec72e6f59a57</strong><br/><strong> ---&gt; e0f943bac9a5</strong><br/><strong>Removing intermediate container ec72e6f59a57</strong><br/><strong>Step 5/8 : FROM openwhisk/dockerskeleton</strong><br/><strong> ---&gt; 25d1878c2f31</strong><br/><strong>Step 6/8 : ENV FLASK_PROXY_PORT 8080</strong><br/><strong> ---&gt; Running in 846db07a0f5b</strong><br/><strong> ---&gt; 543e673a9c79</strong><br/><strong>Removing intermediate container 846db07a0f5b</strong><br/><strong>Step 7/8 : COPY --from=0 /go/src/app/main /action/exec</strong><br/><strong> ---&gt; 8ec5987098d8</strong><br/><strong>Step 8/8 : CMD /bin/bash -c cd actionProxy &amp;&amp; python -u actionproxy.py</strong><br/><strong> ---&gt; Running in ea25c9a65bcc</strong><br/><strong> ---&gt; a4193ccd5f48</strong><br/><strong>Removing intermediate container ea25c9a65bcc</strong><br/><strong>Successfully built a4193ccd5f48</strong><br/><strong>Successfully tagged chanwit/whisk_go:latest</strong></pre>
<p>The action image is now ready as <kbd>chanwit/whisk_go</kbd>. Again, please use your Docker Hub's ID, not mine, as the image repository and don't forget to push it to the Hub.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Invoking functions</h1>
                
            
            
                
<p>This section describes the internal flow of how OpenWhisk invokes its actions. We will learn how to create (or register) a Docker container as an OpenWhisk action and how to invoke it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Invocation flows</h1>
                
            
            
                
<p>As OpenWhisk is an event-driven platform, any kind of event fired to it could be intercepted and interpreted. However, in this example, we will show you only the event triggered by sending a direct request to the gateway.</p>
<p>The invocation flow starts with an invocation request in the form of an HTTP-based request and is sent to the API gateway. For example, we can use the wsk CLI to initiate this kind of request. After the API gateway receives the request, it will forward that call to a controller behind it.</p>
<p>One of the most important components of OpenWhisk is the controller. The controller is a component written in Scala using the infamous framework Akka and Spray to implement a set of REST APIs. The controller accepts all kinds of requests; if it accepts a POST request, it will interpret it as an invocation of an OpenWhisk action.</p>
<p>The controller then starts to authenticate and authorize the access of the requested action.</p>
<p>The controller will look up the credential information and verify it against the data stored in an instance of CouchDB.</p>
<p>If the action is not found, the controller simply returns 404 back to the caller, for example. Also, if access is denied after verification of the credentials, the controller will send a chunk of JSON back to the caller saying that they are not allowed to access the action.</p>
<p>If everything is granted, the controller goes to the next step.</p>
<p>The controller then again looks up the information about the action: what it is, what kind it is, and how to invoke it.</p>
<p>In our case, we use Docker as an action primitive. So, the controller will find that our action is a blackbox. Now it's ready to invoke the action.</p>
<p>The controller will not make a request to an invoker directly; instead, it will make a request to a Kafka cluster, the backbone of the messaging system. As previously mentioned, using Kafka could prevent the loss of the invocation, as well as make the system robust by queuing the invocation when the system is busy under heavy load.</p>
<p>So the controller publishes a message to Kafka. The request message contains all information needed to invoke an action. This message is also persisted by Kafka so that it can be replayed when the system crashes.</p>
<p>Once Kafka gets the message, the controller is responded to with an activation ID to later obtain the result of invocation.</p>
<p>On the other side of Kafka, a set of invokers subscribe to the requested messages. Once a message is available in the queue, an invoker will be notified. Then the invoker will do the real job, invoking the real Docker container. After it gets the results, the invoker stores them in the instance of CouchDB under the same activation ID.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Action invoke</h1>
                
            
            
                
<p>OK, now we are ready to try out both newly created C and Go functions built in the previous sections. First, we will create an action using the <kbd>wsk action create</kbd> command starting with the C program:</p>
<pre><strong>$ wsk -i action create --docker chanwit/whisk_c whisk_c</strong><br/><strong>ok: created action whisk_c</strong></pre>
<p>If things go correctly, <kbd>wsk</kbd> will tell us <kbd>ok: created action</kbd>. Next, we will invoke the action using the <kbd>wsk action invoke</kbd> command. The <kbd>invoke</kbd> command accepts one or more <kbd>--param</kbd> to pass parameters to the action. We can also pass <kbd>--result</kbd> to obtain the result synchronously. The result is, of course returned as JSON:</p>
<pre><strong>$ wsk -i action invoke --param key value --result whisk_c</strong><br/><strong>{</strong><br/><strong>    "args": {</strong><br/><strong>        "key": "value"</strong><br/><strong>    },</strong><br/><strong>    "msg": "Hello from C program!"</strong><br/><strong>}</strong></pre>
<p>We will try once more, this time with the Go program. First, create the action:</p>
<pre><strong>$ wsk -i action create --docker chanwit/whisk_go whisk_go</strong><br/><strong>ok: created action whisk_go</strong></pre>
<p>Then, invoke the action using <kbd>wsk action invoke</kbd>:</p>
<pre><strong>$ wsk -i action invoke --param hello world --result whisk_go</strong><br/><strong>{</strong><br/><strong>    "keys": [</strong><br/><strong>        "hello"</strong><br/><strong>    ],</strong><br/><strong>    "message": "Hello from Go",</strong><br/><strong>    "values": [</strong><br/><strong>        "world"</strong><br/><strong>    ]</strong><br/><strong>}</strong></pre>
<p>As we have seen, we pack actions with Docker and it basically simplifies the whole process, starting with action preparation, creation, and invocation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Obtaining activation results</h1>
                
            
            
                
<p>Each time an action is invoked, OpenWhisk creates an activation record for it. To see the activation record, we may invoke an action without the <kbd>--result</kbd> parameter, for example:</p>
<pre><strong>$ wsk -i action invoke --param hello world whisk_go</strong><br/><strong>ok: invoked /guest/whisk_go with id 6ba2c0fd6f4348b8a2c0fd6f4388b864</strong></pre>
<p>The ID <kbd>6ba2c0fd6f4348b8a2c0fd6f4388b864</kbd> is called an activation ID. We can now obtain the activation record using the <kbd>wsk activation get</kbd> command. Putting a field name after the activation ID will filter it to display only that field. The following example shows only the field <kbd>response</kbd> of the activation record <kbd>6ba2c0</kbd>:</p>
<pre><strong>$ wsk -i activation get 6ba2c0fd6f4348b8a2c0fd6f4388b864 response</strong><br/><strong>ok: got activation 6ba2c0fd6f4348b8a2c0fd6f4388b864, displaying field response</strong><br/><strong>{</strong><br/><strong>    "status": "success",</strong><br/><strong>    "statusCode": 0,</strong><br/><strong>    "success": true,</strong><br/><strong>    "result": {</strong><br/><strong>        "keys": [</strong><br/><strong>            "hello"</strong><br/><strong>        ],</strong><br/><strong>        "message": "Hello from Go",</strong><br/><strong>        "values": [</strong><br/><strong>            "world"</strong><br/><strong>        ]</strong><br/><strong>    }</strong><br/><strong>}</strong></pre>
<p>In the activation record, the JSON result is placed under the <kbd>result</kbd> key. You may observe that all the data is correctly serialized to JSON and recorded there.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">User interface</h1>
                
            
            
                
<p>There is no open source portal for OpenWhisk at the time of writing. To make it easier for developers to use OpenWhisk, I'm developing a UI portal for it. SuraWhisk is an open source project hosted on GitHub. Its source can be found at <a href="https://github.com/surawhisk/ui">https://github.com/surawhisk/ui</a>. If you do not want to look at the source code, you can just start the UI from a ready-to-use Docker image.</p>
<p>First, create a volume to store the settings data. Endpoints and their API keys for authentication will be stored there in the volume:</p>
<pre><strong>$ docker volume create surawhisk_vol</strong></pre>
<p>Then the UI can be run using the following command:</p>
<pre><strong>$ docker run -d -p 8080:8080 -v surawhisk_vol:/root/data surawhisk/ui</strong></pre>
<p>After SuraWhisk UI starts, point the browser to <kbd>http://localhost:8080</kbd>. The UI's navigation bar on the left-hand side currently contains three basic items: settings, actions, and namespaces.</p>
<p>The Settings page, as shown in <em>Figure 6.3</em>, is for setting up an OpenWhisk endpoint and its API key. The SuraWhisk container is running on a bridge network; therefore, it can access the OpenWhisk's API gateway via the Docker's gateway bridge IP, <kbd>172.17.0.1</kbd>. That is, the endpoint to our local OpenWhisk's instance will be <kbd>https://172.17.0.1/api/v1</kbd>. The API key for the current guest namespace can be obtained by running the <kbd>wsk</kbd> CLI with the following command. If the bridge IP is not working, you may try the local IP of the local machine, as the OpenWhisk's API gateway is exposed over the machine's IP as well:</p>
<pre><strong>$ wsk property get --auth</strong><br/><strong>whisk auth     23bc46b1-71f6-4ed5-8c54-816aa4f8c502:123zO3xZCLrMN6v2BKK1dXYFpXlPkccOFqm12CdAsMgRU4VrNZ9lyGVCGuMDGIwP</strong></pre>
<p>The result of the command provides a long string saying that it is a <kbd>whisk auth</kbd>. Copy and paste the whole string, <kbd>23b...IwP</kbd>, into the API Key textbox of the Settings page, and click the Save button:</p>
<div><img src="img/75d7fbc7-5239-4f73-a0c5-60fc73b2e420.png" style="width:61.08em;height:46.67em;"/></div>
<p>Figure 6.3: The Settings screen of SuraWhisk for specifying the Endpoint and API Key</p>
<p>Now the SuraWhisk Portal will be able to communicate with the OpenWhisk instance. We will proceed to the step of defining a new function.</p>
<p>A function, an action in OpenWhisk, can be defined on the Actions/Create page, as in <em>Figure 6.4</em>. The Docker image built earlier in this chapter will be used here. In the following example, we create a function named <kbd>hello</kbd> as a Docker container, whose image is <kbd>chanwit/whisk_c</kbd>:</p>
<div><img src="img/be85fc16-34ac-471b-9443-d8773018f01f.png"/></div>
<p>Figure 6.4: The Action Creation screen which allows us to define a new action in OpenWhisk</p>
<p>When everything is ready, click the Create button. The portal will connect to the OpenWhisk instance and request creation of a new action. The Docker image is not pulled during this stage, so the step will be finished quickly. If the <kbd>hello</kbd> action is created successfully, dialog will pop up, as in Figure 6.5.</p>
<div><img src="img/89cee774-b1d3-4241-8f2f-8db3cf5936aa.png"/></div>
<p>Figure 6.5: Dialog showing that an action was successfully created</p>
<p>To invoke the action, go to the menu Actions/Invoke on the left-hand side navigation bar, as in <em>Figure 6.6</em>. All actions in the current namespace will be listed in the Action combo box. Each invocation accepts key/value pairs as the action's parameters. They can be added by clicking the Add button. In the following example, the <kbd>book</kbd> parameter is set to contain the value <kbd>serverless</kbd>. A parameter can be removed at any time by clicking the Remove button of each pair. These parameters will be encoded into JSON before being passed to the action:</p>
<div><img src="img/a143defb-24f0-4456-8f78-0b5555578352.png"/></div>
<p>Figure 6.6: The Invoke Action screen in SuraWhisk showing the result</p>
<p>After selecting the action to be invoked, clicking the invoke button will start the invocation process. In the previous example, the <kbd>hello</kbd> action is in the form of a Docker container.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Exercises</h1>
                
            
            
                
<p>Here are more questions to help you review the contents of this chapter:</p>
<ol>
<li>What are the strengths of OpenWhisk?</li>
<li>Please describe OpenWhisk's architecture.</li>
<li>What is the role of the OpenWhisk controller?</li>
<li>What is the role of Kafka? Why is it important for OpenWhisk?</li>
<li>What is an invoker?</li>
<li>Is there any reason why the controller and invoker are not connected directly?</li>
<li>How could we define and invoke an action on the OpenWhisk platform?</li>
<li>How could we improve the performance of the invoker?</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter introduced OpenWhisk, especially when we utilized Docker as parts of its ecosystem. OpenWhisk is a fully featured, fault-tolerant, and polyglot serverless platform that allows you to virtually run functions written in any language.</p>
<p>This chapter walked through its components and architecture, and discussed how to use the <kbd>wsk</kbd> CLI to prepare, create, and invoke OpenWhisk functions. This chapter also introduced SuraWhisk, a web UI for OpenWhisk to help us manage and invoke OpenWhisk's actions more easily.</p>
<p>We have learned all about three major FaaS platforms. In the next chapter, we will discuss how to prepare and operate a Docker cluster to provision and administrate FaaS platforms on it.</p>


            

            
        
    </body></html>