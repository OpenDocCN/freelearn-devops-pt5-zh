<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Connecting Containers</h1></div></div></div><p>It's time to connect all our three containers to form a single unit of modularized parts. I'll introduce you to two services, <strong>Docker Compose</strong> and <strong>Crane</strong>, which can be used to automate this. We'll<a class="indexterm" id="id219"/> go<a class="indexterm" id="id220"/> through the following topics in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Manually connecting containers together</li><li class="listitem" style="list-style-type: disc">Exploring the contents of a data volume container</li><li class="listitem" style="list-style-type: disc">Connecting containers to a configuration file using Docker Compose</li><li class="listitem" style="list-style-type: disc">Connecting containers to a configuration file using Crane</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Manually connecting containers</h1></div></div></div><p>Let's take a<a class="indexterm" id="id221"/> look at how to connect our service containers to our data volume container. First, we have to run our data volume container, then run our MySQL container, and lastly run our WordPress container, as shown in the following command:</p><div><pre class="programlisting">
<strong>docker run -d --name data-one oskarhane/data tail -f /dev/null</strong>
<strong>docker run --name mysql-one --volumes-from data-one -e MYSQL_ROOT_PASSWORD=mysecretpassword -d mysql</strong>
<strong>docker run --name wordpress-one --volumes-from data-one --link mysql-one:mysql -d -p 80 oskarhane/wordpress</strong>
</pre></div><p>Here, we have fired up and named the data volume container <code class="literal">data-one</code>. The next line fires up the MySQL container, named <code class="literal">mysql-one</code>, and gives it the data volume container. The last line fires up our WordPress container, named <code class="literal">wordpress-one</code>, links <code class="literal">mysql-one</code> as the MySQL link, and gives it the data volume container.</p><p>The following output is displayed:</p><div><img alt="Manually connecting containers" src="img/3946OT_05_01.jpg"/></div><p>Open your <a class="indexterm" id="id222"/>web browser and head over to the container's URL and port in order to verify that all the services are running and the containers are tied together as they should be. You should see the, now familiar, WordPress installation page.</p><p>As you may have figured out by now, you can fire up another WordPress container using the same MySQL link and the same data volume container. What do you think will happen?</p><p>The new WordPress container will be another instance of the same WordPress site, with the same files and the same database.</p><p>When you link containers, Docker will set some environment variables in the target container in order to enable you to get information about the linked source container. In our case, these environment variables will be set when we link the MySQL container, as shown in the following command:</p><div><pre class="programlisting">MYSQL_NAME=/wordpress-one/mysql-one
MYSQL_PORT=tcp://ip:3306
MYSQL_3306_TCP=tcp://ip:3306
MYSQL_3306_TCP_PROTO=tcp
MYSQL_3306_TCP_PORT=3306
MYSQL_3306_TCP_ADDR=ip</pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Exploring the contents of a data volume container</h1></div></div></div><p>Is the data being <a class="indexterm" id="id223"/>written to the data volume container? Or, is the data stored inside the MySQL and WordPress containers when connected? How can you tell?</p><p>One way to determine this is to enter a container via a shell so that you can navigate around its filesystem. Since version 1.3, Docker has the ability to start a new instance of a container's <a class="indexterm" id="id224"/>shell. Running the old <code class="literal">docker attach</code> command just gets you in the current shell instance, which in our case has <code class="literal">tail –f /dev/null</code> running. If we exit this <code class="literal">tail</code> command, the container will exit and shut down. Therefore, we need a new shell instance in a running container so that we can invoke any commands we want inside the container without the risk of the container exiting. The following command can be used to do this:</p><div><pre class="programlisting">
<strong>docker exec -i -t data-one /bin/sh</strong>
</pre></div><p>The <code class="literal">–i</code> and <code class="literal">–t</code> flags mean that we want to keep the session interactive and allocate a pseudo-TTY. <code class="literal">data-one</code> is the name of the container, but you can use the container ID if you like. I would choose <code class="literal">/bin/bash </code>over<code class="literal"> /bin/sh</code>, but the container runs BusyBox and <code class="literal">/bin/bash</code> isn't available there. For the kinds of tasks that we are about to perform, it doesn't matter which shell we use.</p><p>What we want to do is to take a look in the directories we exposed as <code class="literal">VOLUMES</code> in this data volume container. The directories are <code class="literal">/var/www/html</code> and <code class="literal">/var/lib/mysql</code>.</p><p>Let's explore in the following command:</p><div><pre class="programlisting">
<strong>ls -la /var/www/html</strong>
<strong>ls -la /var/lib/mysql</strong>
</pre></div><p>The following output is displayed:</p><div><img alt="Exploring the contents of a data volume container" src="img/3946OT_05_02.jpg"/></div><p>We see files <a class="indexterm" id="id225"/>on both those directories, which indicates that the two other containers are writing to this one. It separates the services with the data. If you want further proof, launch <code class="literal">vi</code> in the shell, edit a file, and reload the site in your browser.</p><p>This worked out really smooth and easy, didn't it? The containers interact with each other and all we have to do is to link them together with just one command.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Connecting containers using Docker Compose</h1></div></div></div><p>Docker Compose <a class="indexterm" id="id226"/>was previously called Fig, but <a class="indexterm" id="id227"/>Docker acquired Fig and<a class="indexterm" id="id228"/> the name was changed. This is how Docker describes Docker Compose:</p><div><blockquote class="blockquote"><p><em>"Compose is a tool for defining and running complex applications with Docker. With Compose, you define a multi-container application in a single file, then spin your application up in a single command which does everything that needs to be done to get it running."</em></p></blockquote></div><p>Docker Compose basically gives us a way to define settings in a configuration file, so we don't have to remember all the names for all the containers when linking them together, the ports to expose, the data volume container to use, and so on.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec28"/>Installing Docker Compose</h2></div></div></div><p>Docker Compose<a class="indexterm" id="id229"/> has regular releases on GitHub, and at the time<a class="indexterm" id="id230"/> of writing this book, the latest release is 1.0.1.</p><p>We will install Docker Compose with the Python package manager, pip. Our EC2 instance does not come with pip installed, so we have to start with the installation, as shown here:</p><div><pre class="programlisting">
<strong>sudo su</strong>
<strong>wget https://bootstrap.pypa.io/get-pip.py &amp;&amp; python ./get-pip.py</strong>
</pre></div><p>The following output is displayed:</p><div><img alt="Installing Docker Compose" src="img/3946OT_05_03.jpg"/></div><p>After pip is<a class="indexterm" id="id231"/> installed, you can go ahead and install Docker <a class="indexterm" id="id232"/>Compose:</p><div><pre class="programlisting">
<strong>sudo pip install -U docker-compose</strong>
</pre></div><p>Now, you'll see Docker Compose installed along with all of its dependencies. Invoke <code class="literal">docker-compose --version</code> to verify that it works as expected.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec29"/>Basic Docker Compose commands</h2></div></div></div><p>The following are the basic Docker Compose commands that you should be familiar with:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">build</code>: This is<a class="indexterm" id="id233"/> used to build or rebuild services</li><li class="listitem" style="list-style-type: disc"><code class="literal">kill</code>: This <a class="indexterm" id="id234"/>forces the service containers to stop</li><li class="listitem" style="list-style-type: disc"><code class="literal">logs</code>: This <a class="indexterm" id="id235"/>views the output from the services</li><li class="listitem" style="list-style-type: disc"><code class="literal">port</code>: This<a class="indexterm" id="id236"/> is used to print the public port for a port binding</li><li class="listitem" style="list-style-type: disc"><code class="literal">ps</code>: This is <a class="indexterm" id="id237"/>used to list containers</li><li class="listitem" style="list-style-type: disc"><code class="literal">pull</code>: This<a class="indexterm" id="id238"/> is used to pull service images</li><li class="listitem" style="list-style-type: disc"><code class="literal">rm</code>: This<a class="indexterm" id="id239"/> is used to remove stopped service containers</li><li class="listitem" style="list-style-type: disc"><code class="literal">run</code>: This is <a class="indexterm" id="id240"/>used to run a one-off command on a service</li><li class="listitem" style="list-style-type: disc"><code class="literal">scale</code>: This<a class="indexterm" id="id241"/> sets the number of containers to be run for a service</li><li class="listitem" style="list-style-type: disc"><code class="literal">start</code>: This<a class="indexterm" id="id242"/> is used to start existing containers for a service</li><li class="listitem" style="list-style-type: disc"><code class="literal">stop</code>: This <a class="indexterm" id="id243"/>stops running containers without removing them</li><li class="listitem" style="list-style-type: disc"><code class="literal">up</code>: This<a class="indexterm" id="id244"/> builds, recreates, starts, and attaches to containers for a service; linked containers will be started, unless they are already running</li></ul></div><p>As you can see, the commands are very similar to the Docker client commands and most of them do the exact same thing by forwarding the commands to the Docker daemon. We will go through some of them a little more in detail.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec03"/>Service</h3></div></div></div><p>When the<a class="indexterm" id="id245"/> word <code class="literal">service</code> is used with Docker Compose, it refers to a named container in a <code class="literal">docker-compose.yml</code> configuration file.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec04"/>Using the run command</h3></div></div></div><p>We are used to <a class="indexterm" id="id246"/>starting containers with the <code class="literal">run</code> command for the Docker client. With docker-compose, the <code class="literal">run</code> command is very different. When you <code class="literal">run</code> a command with docker-compose, it's a one-off command on a service. This means that if we name a container configuration <code class="literal">Ubuntu</code> and invoke <code class="literal">docker-compose run ubuntu /bin/bash echo hello</code>, the container will start and execute <code class="literal">/bin/bash echo hello</code> and then shut down. The difference with this and running the command directly with Docker is that all the linked containers and <code class="literal">VOLUME</code> containers will be started and connected when you use docker-compose.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec05"/>Using the scale command</h3></div></div></div><p>The <code class="literal">scale</code> command <a class="indexterm" id="id247"/>is very interesting. When we invoke <code class="literal">docker-compose scale web=3</code>, we actually start three containers of the service that we named <code class="literal">web</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec30"/>Setting up our PaaS with Docker Compose</h2></div></div></div><p>Every <a class="indexterm" id="id248"/>Docker Compose instance lives in its own <a class="indexterm" id="id249"/>directory and has a configuration file named <code class="literal">docker-compose.yml</code> inside it:</p><div><pre class="programlisting">
<strong>mkdir docker-compose-wp &amp;&amp; cd $_</strong>
<strong>touch docker-compose.yml</strong>
</pre></div><p>This is how the contents of our <code class="literal">docker-compose.yml</code> file will look:</p><div><pre class="programlisting">
<strong>wp:</strong>
<strong>  image: oskarhane/wordpress</strong>
<strong>  links:</strong>
<strong>    - mysql:mysql</strong>
<strong>  ports:</strong>
<strong>    - "80"</strong>
<strong>  volumes_from:</strong>
<strong>    - paasdata</strong>
<strong>mysql:</strong>
<strong>  image: mysql</strong>
<strong>  volumes_from:</strong>
<strong>    - paasdata</strong>
<strong>  environment:</strong>
<strong>    - MYSQL_ROOT_PASSWORD=myrootpass</strong>
<strong>paasdata:</strong>
<strong>  image: oskarhane/data</strong>
<strong>  command: tail -f /dev/null</strong>
</pre></div><p>You can see that we have defined three services here, namely <code class="literal">wp</code>, <code class="literal">mysql</code>, and <code class="literal">paasdata</code>.</p><p>Lets try these services and the following output is displayed:</p><div><img alt="Setting up our PaaS with Docker Compose" src="img/3946OT_05_04.jpg"/></div><p>Invoke <code class="literal">docker-compose up –d</code> to run <code class="literal">docker-compose</code> and the containers in daemon mode.</p><p>That's how <a class="indexterm" id="id250"/>easy it is. Open your web browser and<a class="indexterm" id="id251"/> head to your Docker host and the port stated in the table (in my case, port <strong>49155</strong>); you should see the very familiar WordPress installation page.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Connecting containers using Crane</h1></div></div></div><p>Crane is <a class="indexterm" id="id252"/>much like Docker Compose, but it has more <a class="indexterm" id="id253"/>configuration possibilities. This is how its <a class="indexterm" id="id254"/>creator describes Crane:</p><div><blockquote class="blockquote"><p><em>"Crane is a tool to orchestrate Docker containers. It works by reading in some configuration (JSON or YAML) which describes how to obtain images and how to run containers. This simplifies setting up a development environment a lot as you don't have to bring up every container manually, remembering all the arguments you need to pass. By storing the configuration next to the data and the app(s) in a repository, you can easily share the whole environment."</em></p></blockquote></div><p>This paragraph can be about Docker Compose as well, as you can see.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec31"/>Installing Crane</h2></div></div></div><p>Crane is <a class="indexterm" id="id255"/>easy to install but not easy to keep updated. The same command is<a class="indexterm" id="id256"/> used to install as well as update, so we have to invoke this once in a while in order to have the latest version.</p><p>Invoke the following command on a single line to install Crane:</p><div><pre class="programlisting">
<strong>bash -c "`curl -sL https://raw.githubusercontent.com/michaelsauter/crane/master/download.sh`" &amp;&amp; sudo mv crane /usr/local/bin/crane</strong>
</pre></div><p>Crane is now installed in <code class="literal">/usr/local/bin</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec32"/>Usage</h2></div></div></div><p>I won't go<a class="indexterm" id="id257"/> through all the commands here since they're similar to Docker Compose's commands, but I'll comment on a few here:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">lift</code>: This <a class="indexterm" id="id258"/>command, like Docker Compose's <code class="literal">up</code> command, builds and runs containers from your configuration file</li><li class="listitem" style="list-style-type: disc"><code class="literal">graph</code>: This <a class="indexterm" id="id259"/>prints your containers' relations from the configuration file</li><li class="listitem" style="list-style-type: disc"><code class="literal">logs</code>: This<a class="indexterm" id="id260"/> maps to the Dockers Compose's command, but here you can get the logs for a whole group</li><li class="listitem" style="list-style-type: disc"><code class="literal">status</code>: This<a class="indexterm" id="id261"/> also maps to the Dockers Compose's command but lets you get the logs for a group</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Configuration</h2></div></div></div><p>This is where Crane really leaves Docker Compose behind. You have many more configuration options for Crane apps. The configuration file must be named <code class="literal">crane.json</code> or <code class="literal">crane.yaml</code>. For<a class="indexterm" id="id262"/> every container, this is what you can configure:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">image</code> (string, required): This is the name of the image to build/pull</li><li class="listitem" style="list-style-type: disc"><code class="literal">dockerfile</code> (string, optional): This gives the relative path to the Dockerfile</li><li class="listitem" style="list-style-type: disc"><code class="literal">run</code> (object, optional): These parameters are mapped to Docker's<em> </em><code class="literal">run</code> and <code class="literal">create</code> commands:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">add-host (array): This adds custom host-to-IP mappings</li><li class="listitem" style="list-style-type: disc">cpuset (integer)</li><li class="listitem" style="list-style-type: disc">cpu-shares (integer)</li><li class="listitem" style="list-style-type: disc">detach (boolean) <code class="literal">sudo docker attach &lt;container name&gt;</code> will work as normal</li><li class="listitem" style="list-style-type: disc">device (array): This adds host devices</li><li class="listitem" style="list-style-type: disc">dns (array)</li><li class="listitem" style="list-style-type: disc">entrypoint (string)</li><li class="listitem" style="list-style-type: disc">env (array)</li><li class="listitem" style="list-style-type: disc">expose (array): This denotes the ports to be exposed to linked containers</li><li class="listitem" style="list-style-type: disc">hostname (string)</li><li class="listitem" style="list-style-type: disc">interactive (boolean)</li><li class="listitem" style="list-style-type: disc">link (array): This links containers</li><li class="listitem" style="list-style-type: disc">memory (string)</li><li class="listitem" style="list-style-type: disc">privileged (boolean)</li><li class="listitem" style="list-style-type: disc">publish (array): This maps network ports to the container</li><li class="listitem" style="list-style-type: disc">publish-all (boolean)</li><li class="listitem" style="list-style-type: disc">restart (string) Restart policy</li><li class="listitem" style="list-style-type: disc">rm (boolean)</li><li class="listitem" style="list-style-type: disc">tty (boolean)</li><li class="listitem" style="list-style-type: disc">volume (array): In <a class="indexterm" id="id263"/>contrast to plain Docker, the host path can be relative</li><li class="listitem" style="list-style-type: disc">volumes-from (array): This is used to mount volumes from other containers</li><li class="listitem" style="list-style-type: disc">workdir (string)</li><li class="listitem" style="list-style-type: disc"><code class="literal">cmd</code> (array/string): This command is used to append to <code class="literal">docker run</code> (overwriting CMD)</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">rm (object, optional):</code> These parameters are mapped to Docker's <code class="literal">rm</code> command:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">volumes (boolean)</li></ul></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">start (object, optional)</code>: These parameters are mapped to Docker's <code class="literal">start</code> command:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">attach (boolean)</li><li class="listitem" style="list-style-type: disc">interactive (boolean)</li></ul></div></li></ul></div><p>Set up the same configuration that you did in Docker Compose; it will look something like the following code. As you might understand, you can write this in the JSON format as well, but for the comparison to Docker Compose's version to be as easy as possible, I'll keep it in the <code class="literal">yaml</code> format:</p><div><pre class="programlisting">
<strong>containers:</strong>
<strong>  wp:</strong>
<strong>    image: oskarhane/wordpress</strong>
<strong>    run:</strong>
<strong>      volumes-from: ["mydata"]</strong>
<strong>      link: </strong>
<strong>        - mymysql:mysql</strong>
<strong>      publish: ["80"]</strong>
<strong>      detach: true</strong>
<strong>  mymysql:</strong>
<strong>    image: mysql</strong>
<strong>    run:</strong>
<strong>      volumes-from: ["mydata"]</strong>
<strong>      detach: true</strong>
<strong>      env: ["MYSQL_ROOT_PASSWORD=rootpass"]</strong>
<strong>  mydata:</strong>
<strong>    image: oskarhane/data</strong>
<strong>    run:</strong>
<strong>      detach: true</strong>
<strong>      cmd: "tail -f /dev/null"</strong>
</pre></div><p>Here, we <a class="indexterm" id="id264"/>specify three containers, where the data container is added as a data volume container to the others and the MySQL container is linked to the WordPress container.</p><p>Save this file as <code class="literal">crane.yaml</code> and type <code class="literal">crane lift</code> to run your app.</p><p>The following output is displayed:</p><div><img alt="Configuration" src="img/3946OT_05_05.jpg"/></div><p>To see the containers' current statuses, we can type <code class="literal">crane status</code>. Take a look at the last column in our <code class="literal">wp</code> container. It says it's not running. Type <code class="literal">crane</code> <code class="literal">logs wp</code> and see what it says in following command:</p><div><pre class="programlisting">
<strong>wp * WordPress not found in /var/www/html - copying now...</strong>
<strong>wp * Complete! WordPress has been successfully copied to /var/www/html</strong>
<strong>wp | </strong>
<strong>wp | Warning: mysqli::mysqli(): (HY000/2002): Connection refused in - on line 5</strong>
<strong>wp * MySQL Connection Error: (2002) Connection refused</strong>
</pre></div><p>It seems that <a class="indexterm" id="id265"/>our WordPress container starts faster than our MySQL container, so the WordPress container can't find it when it starts.</p><p>This can happen in Docker Compose as well because there's no check if <code class="literal">--link:ed</code> containers are up, at least not at the time when this is being written.</p><p>This cannot be solved in Docker Compose; we have to rely on pure luck that the MySQL container will get ready before the WordPress container tries to use the linked MySQL container.</p><p>With Crane, you can group containers inside the configuration file in different groups and then <code class="literal">run</code> commands on that group instead of the whole configuration.</p><p>This is very easy; we just add these lines at the end of our <code class="literal">crane.yaml</code> file:</p><div><pre class="programlisting">
<strong>groups:</strong>
<strong>  default: ['mydata', 'mymysql', 'wp']</strong>
<strong>  data_db: ['mydata', 'mymysql']</strong>
<strong>  web: ['wp']</strong>
</pre></div><p>Here, we have separated the WordPress container from the other two containers we have so that we can <code class="literal">run</code> commands on them separately.</p><p>Let's start our <code class="literal">data_db</code> group first by invoking the <code class="literal">crane lift data_db --recreate</code> command. I added the flag <code class="literal">--recreate</code> and to make sure that we're creating new containers and not reusing the old ones. Run <code class="literal">crane status data_db</code> to make sure they're running.</p><p>Now that we know that the MySQL container is running, we can start the WordPress container by invoking the <code class="literal">crane lift web --recreate</code> command.</p><p>The following output is displayed:</p><div><img alt="Configuration" src="img/3946OT_05_06.jpg"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Summary</h1></div></div></div><p>Now, we can connect containers in different ways to keep different services separate on different containers. We learned how to do this manually, which can be quite hard when you have lots of dependencies between containers.</p><p>We had a brief look at two orchestration tools: Docker Compose and Crane. Crane is an independent and more advanced tool for the administrators who want more control over containers. The ability to group containers in Crane makes it more reliable when there can be timing issues in dependencies.</p><p>In the next chapter, we will run two instances of our app using Crane to see what problems and possibilities crop up when we want to make both our blogs publicly accessible on the regular HTTP port (80).</p></div></body></html>