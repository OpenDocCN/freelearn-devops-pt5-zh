- en: Assessments
  prefs: []
  type: TYPE_NORMAL
- en: Chapter 1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'b and c: We can run more than one process per container, but it is not recommended
    because Docker Engine will only manage the main container process. We will need
    to manage additional logic between processes to start and stop everything at once.
    It is not easy and you can leave "zombie" processes in your hosts. Microservices
    are based on minimal functionality for each application component, which fits
    with containers very well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: Control groups, or cgroups, will manage the host resources provided to each
    container, but it is very important to understand that, by default, containers
    will run with unlimited resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and b: Containers will run as root unless the source image has a non-root
    user definition or we specify a non-root user upon container creation. User namespaces
    allow us to use the root inside containers, although a real user outside the container
    can have a non-root ID. This is useful when processes require UID 0 to work.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd. All of the above sentences are true: Windows hosts will run two different
    types of isolation. We can run Linux containers on Windows, but this is not true
    in reverse.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a, b, and c: We can use `systemd` unit files or `/etc/docker/daemon.json` to
    configure the Docker daemon on Linux. On Windows hosts, `daemon.json` is located
    in the `%programdata%\docker\config\` directory. In both cases, Docker daemon
    remote access is not secure by default.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'b: The image ID is the only identification of uniqueness when listing or managing
    images. We can have one ID with many names, including the registry part, and tags.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: All the methods described are valid.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: Using a Dockerfile is a reproducible method as we describe all actions to
    add software, execute commands, add files, and more, in order to build a new image.
    We can automate and use templates to build images with Dockerfiles and this is
    the preferred method.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and c: Only `RUN`, `CMD`, and `ENTRYPOINT` instructions admit shell and exec
    formats.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a: Using the shell format, the container main process, as defined by the `ENTRYPOINT`
    key, cannot be modified with arguments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'a and c: `build` is only available for image objects, and `destroy` does not
    exist for any object.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: This is not true. The Docker daemon will wait a defined amount of time (10
    seconds, by default) before issuing a `SIGKILL` signal to the container''s main
    process.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: `docker kill` will immediately send a `SIGKILL` signal to the container''s
    main process. Not all processes will be killed if they were executed in the background;
    for example, inside the container. It can leave zombie processes if they do not
    have parent-child dependencies. As we learned, containers must be removed by hand
    and `docker kill` will not remove them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: `docker container update` will only change the container restart policy
    and its access to host resources.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'c: We have launched a privileged container; therefore no resource limits will
    be applied, although we have used `-memory` to confine memory usage. The privileged
    mode does not affect the filesystem. It will only modify the main process behavior,
    but in this case, we used a non-root user to create a new file on a directory
    owned by root and, as a result, it could not be created.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'c: Each container will use its own filesystem unless we declare a shared volume
    for them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a, b, and c: There are different types of volumes and it is not only allowed
    on container creation or execution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: Docker volumes can be removed along with their associated container using
    the `--volumes` (or `-v`) option. A Docker volume purge will remove all unused
    volumes; those not associated to any container. But Docker will never remove a
    bind mount volume content (a local directory mounted on a container).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'c: Only custom bridge networks are attachable after container creation. If
    we create or start a container and we want it to be connected to the default bridge
    network, we need to recreate it and attach it to that network on container creation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: Using `--publish-all` or `-P` will associate a random port between `32768`
    and `65535` to internal container port `80`. A NAT rule will automatically be
    created by the Docker daemon to allow this communication. You can disable the
    Docker daemon iptables management, but it is enabled by default.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'a: Docker Compose will run all application components just in one host. We
    will also use `docker-compose` files for deploying Swarm orchestrated applications
    with their components distributed on different hosts, but that requires a cluster
    running. In that case, we will not use the `docker-compose` binary to deploy the
    application; only the definition file will be valid and we will use it with the
    `docker stack` action. In Docker Swarm, we deploy swarm services, not containers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: Docker Compose provides all required actions to build, share, and deploy
    multi-container applications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and c: Docker Compose will review whether project images are present in the
    host. If they are not, the Docker daemon will try to download all not-present
    ones. Once the Docker daemon has all the required images, it will start all project
    containers and our terminal will be attached to containers'' standard and error
    output unless the `--detach` or `-d` argument is used.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a: Docker Compose will allow us to scale the number of containers associated
    with a service. By default, Docker Compose will create a bridge network for our
    deployment, therefore an internal DNS will be associated and will manage all application
    IP addresses and names. In scaled services, we will receive one of the IP addresses
    of the replicas each time we ask for the defined service name. It uses round-robin
    DNS resolution.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: In this case, we could say that answer c is almost right, but it is incomplete.
    Docker Compose will remove all containers. If containers were running, they will
    be stopped before they are deleted. All associated resources created during the
    application execution will also be removed.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'c: Docker Content Trust is based on **The Update Framework** (**TUF**) and
    this framework was created to ensure the release of content between updates using
    different keys. It is possible to validate the trustfulness of a package or any
    other content using TUF.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and d: Docker Content Trust will use Root, Targets, Snapshot, and Timestamp
    keys to ensure content.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'c: We ensure image freshness using Content Trust, but it is true that we cannot
    ensure that the image tagged as "latest" in a given repository is actually the
    latest one created. We can only ensure that the image tagged as "latest" will
    be used. It is always recommended to use tags avoiding the use of "latest".'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: We tried to sign a version of a non-public write repository. We are not
    allowed to modify root repositories at docker.io.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: We can recover the key if we have a backup. If it is not possible, we can
    generate a new one or let Docker generate one for us on first signing. Although
    we will be able to sign images after the new key has been generated, all our previously
    signed images will be untrusted because we changed our signature.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'a: Orchestrators will not know anything about your application logic. On the
    other hand, we have quickly reviewed the interfaces that use orchestration to
    ensure that containers get the appropriate volumes of data on distributed environments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'c: Orchestrators will not manage application data, nor do they know anything
    about your application logic. The orchestrator will take care of the application
    components'' health and will run a new instance if one of the required instances
    dies.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and b: Distributed environments will help us to deploy applications with
    high availability and improved performance. But on the other hand, we will have
    new challenges because we need to be able to distribute application logic and
    components'' interactions on different nodes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and b: Answers a and b are correct, while c is not, because application components
    can be managed one at a time. Therefore, upgrades will only impact one application
    component if the application logic knows how to manage the situation.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'c: All sentences are correct. We learned that we can define container limits
    and the required resources. Orchestrators will review these specifications and
    will deploy them on nodes with enough resources to ensure their correct execution.
    We can guide orchestration to choose labeled nodes, for example, to ensure application
    disk I/O, along with many other features. Each orchestrator will manage different
    rules and workflows to choose the best node for each workload.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'a: Docker Swarm is built into Docker Engine, but we have to enable Swarm mode
    for it to work. We can deploy other orchestrators such as Kubernetes, but it will
    involve extra work to deploy them. Orchestrators allow us to deploy applications
    on clusters, hence Swarm will deploy distributed applications.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: Docker Swarm provides service discovery via DNS, internal load balancing
    for services and their tasks, and overlay networking for services and containers
    distributed on different nodes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: Each cluster has only one leader node. The leader is elected from the available
    managers. When we initialize a cluster, the first node will be the leader until
    a new election is required. All managers will run workloads unless we specifically
    avoid them using service constraints.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: Roles can be changed as we require, such as for maintenance, for example.
    We need to always maintain the defined number of odd managers to avoid cluster
    instability.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and b: By default, Docker Swarm will deploy stacks on its own network, unless
    others are specified. Everything related to the application to be deployed must
    be configured in the Docker Compose stack file. We can add externally created
    components, but they must exist before the stack is deployed and we will set them
    as external in the infrastructure-as-code stack file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'a and b: Kubernetes requires etcd to work. Most of the Kubernetes deployment
    solutions will deploy etcd for you, but it is an external application and therefore
    it is up to you to manage and ensure that the key-value solution provides high
    availability. Kubernetes internal networking will work out of the box, but communications
    between components deployed on different hosts rely on external plugins (the CNI
    standard). Therefore, we will need to choose and deploy ourselves a solution to
    provide this kind of communication.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b and c: We will deploy pods in Kubernetes, hence these are the minimum unit
    of deployment. We can deploy more than one container in a pod. The container density
    is higher in Kubernetes. Scaling pods will replicate all their components at once.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: All sentences are true. All containers in a pod share the same IP address
    and localhost. They also share pod volumes. **Container Network Interface** (**CNI**)
    is not required for connections between pods running on the same host. They all
    are accessible using their virtual IP addresses.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a, b, and c: ReplicaSets allow us to manage replicated environments. Deployments
    create ReplicaSets and allow us to scale application pods both up and down. They
    will also maintain the application health based on the required running pods.
    DaemonSets will ensure one replica on each cluster node.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a: The ClusterIP service type will only provide internal access to a service.
    The assigned IP is not available from the cluster nodes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'c: Docker Machine is maintained by the Docker community.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a: Docker Enterprise provides a supported and enterprise-ready CaaS platform,
    with supported Kubernetes, **Universal Control Plane** (**UCP**), and **Docker
    Trusted Registry** (**DTR**, based on the Docker Registry community). We can deploy
    Docker Swarm in production even with Docker support using Docker Enterprise Engine.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a, b, and d: Docker Enterprise provides Kubernetes out of the box when we deploy
    UCP â€“ we do not need to install Kubernetes manually.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: We will use fixed IP addresses for all components. We will use an external
    load balancer to forward traffic to all manager nodes for UCP and all worker nodes
    with DTR running for the registry. Forwarding traffic to just one node will not
    provide high availability if it fails. The Docker UCP installation will deploy
    Calico by default for Kubernetes, but we will need to review `pod-cidr` and `service-cidr`
    to ensure that the subnets defined by default will be valid in our environment.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'c: To provide high availability for workloads, we will deploy at least two
    Linux nodes. Although it is possible to run DTR on UCP managers, it is not recommended
    because managers need to have enough resources for control plane tasks and image
    scanning can affect cluster stability. We will also need to choose different ports
    for the applications'' frontends because both use port `443`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'b: As we have learned, Docker Enterprise Engine is required to install UCP.
    It will not be installed automatically for us. We can use Web UI, the UCP bundle,
    and the UCP API to manage our workloads and cluster configurations. UCP''s RBAC
    system will manage authorizations, but it is true that it will also authenticate
    users if no external authorization source is configured or it is not available.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b and d: Docker provides a complete UCP backup and restore solution with the
    `docker/ucp` image, but remember that we should take care of Docker Swarm''s filesystem
    because it is not part of UCP''s backup. We should use the appropriate `docker/ucp`
    image release for our environment. In fact, we will use the same installed release
    for any action other than upgrading. UCP removal can be executed from the `docker/ucp`
    image and this will remove UCP components from all nodes in the cluster. We should
    then remove the `docker/ucp` image. The upgrade process can be achieved automatically
    using the `docker/ucp` image, but this may impact your users. We will usually
    upgrade UCP managers automatically and then execute upgrade steps manually on
    worker nodes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and b: We can use `--controller-port` and:`-kube-apiserver-port` to modify
    the UCP controller and Kubernetes'' API server ports. We can also isolate the
    control plane from the data plane by choosing different interfaces in multihomed
    hosts using `--data-path-addr`. **Subject Alias Names** (**SANs**) will add alias
    names to UCP''s certificate. We can add all required aliases for our environment
    using `--san` multiple times.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a, c, and d: UCP deploys a Kubernetes cluster with high availability on top
    of Docker Swarm. As UCP is deployed on Docker Swarm, we will need at least three
    nodes to provide high availability. All managers will run the same control plane
    processes and an external load balancer is required to distribute access between
    them. This requires a transparent proxy configuration to allow managers to manage
    encrypted communications. We will use the `/_ping` endpoint to verify manager
    nodes'' health and it can be used on load balancers as a backend health check.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and c: UCP provides **None**, **View Only**, **Restricted Control**, **Scheduler**,
    and **Full Control**. We can create new roles, but there are no privileged or
    administrator roles by default. Docker Enterprise administrators are not defined
    as roles. There is a checkbox in the user''s properties to enable this feature.
    Only administrators can create grants, users, teams, organizations, and collections.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'b and c: There are two labels that are always required. We will need to ensure
    Interlock forwards the service''s requests using `com.docker.lb.hosts` and `com.docker.lb.port`.
    These will have all the required information, but `com.docker.lb.network` is recommended
    and required if the service''s instances are attached to more than one network.
    We need to specify which network should be used as an ingress.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: The Interlock solution is based on a main process named `interlock`, a process
    for managing external proxy services and configurations, and an `interlock-proxy`
    service that will run inside the Docker Enterprise environment if no external
    load balancer is specified. These three processes run as services within Docker
    Swarm and they are prefixed with `ucp-`. `ucp-interlock-controller` does not exist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: By default, only the `ucp-interlock` service will be located by the node''s
    roles. All other components can run anywhere. We will use location constraints
    to run the `ucp-interlock-proxy` and `ucp-interlock-extension` components on worker
    nodes.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a, b, and c: Interlock allows us to either manage SSL/TLS tunnels on `ucp-interlock-proxy`
    or configure it as a transparent proxy. In this case, our services'' backends
    should manage SSL/TLS certificates. Interlock interacts with the Docker API and
    all changes will be updated automatically on Interlock''s proxy component. Interlock
    is a Layer 7 load balancer; reverse proxy, TCP, and UDP protocols should be published
    using a routing mesh or host mode.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and b: Ingress controllers and Interlock have a common logic, using a few
    published ports. They will manage all ingress traffic using load balancing and
    reverse proxy features. We will not publish applications directly. No application''s
    service has to be exposed directly. The ingress controllers (and Interlock) will
    be exposed and they will route requests to the application''s defined services.
    Interlock has to interact with the application''s services, hence it has to connect
    to their networks. This will happen automatically. Docker Enterprise will connect
    the `interlock-proxy` service to our application''s networks.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Chapter 13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'b: This list only shows one valid feature. DTR provides repository mirroring.
    Neither repository load balancing nor repository signing are valid features. We
    do not sign repositories. We sign repositories'' images/tags.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'b: DTR does not manage images'' data with high availability. Deploying more
    than one replica will provide high availability for DTR''s processes. DTR replication
    requires data sharing between replicas, but we must include third-party solutions
    to provide high availability for our storage.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a and b: The DTR installation runs the `dtr-garant` and `dtr-jobrunner` containers.
    The first will manage user authentication, while jobrunner will execute DTR''s
    maintenance tasks to remove unreferenced layers. `dtr-notary-server` and `dtr-notary-signer`
    will be deployed within DTR to manage Docker Content Trust metadata.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'd: All the question''s sentences describe required steps for deploying DTR
    with high availability.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'a: DTR backups do not include images'' layers. This can constitute a great
    amount of data and is the key to recovering your images. You should prepare third-party
    solutions for this data. On the other hand, repository metadata, RBAC configurations,
    and images'' signatures will be stored within your backup TAR file.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exam answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 1 - b and c
  prefs: []
  type: TYPE_NORMAL
- en: 2 - c
  prefs: []
  type: TYPE_NORMAL
- en: 3 - b
  prefs: []
  type: TYPE_NORMAL
- en: 4 - a, b, and c
  prefs: []
  type: TYPE_NORMAL
- en: 5 - b
  prefs: []
  type: TYPE_NORMAL
- en: 6 - c
  prefs: []
  type: TYPE_NORMAL
- en: 7 - a
  prefs: []
  type: TYPE_NORMAL
- en: 8 - a, c, and d
  prefs: []
  type: TYPE_NORMAL
- en: 9 - c
  prefs: []
  type: TYPE_NORMAL
- en: 10 - a and c
  prefs: []
  type: TYPE_NORMAL
- en: 11 - b
  prefs: []
  type: TYPE_NORMAL
- en: 12 - a
  prefs: []
  type: TYPE_NORMAL
- en: 13 - d
  prefs: []
  type: TYPE_NORMAL
- en: 14 - b
  prefs: []
  type: TYPE_NORMAL
- en: 15 - c
  prefs: []
  type: TYPE_NORMAL
- en: 16 - a, b, and c
  prefs: []
  type: TYPE_NORMAL
- en: 17 - a, b, and c
  prefs: []
  type: TYPE_NORMAL
- en: 18 - a
  prefs: []
  type: TYPE_NORMAL
- en: 19 - b and c
  prefs: []
  type: TYPE_NORMAL
- en: 20 - a and b
  prefs: []
  type: TYPE_NORMAL
- en: 21 - d
  prefs: []
  type: TYPE_NORMAL
- en: 22 - c
  prefs: []
  type: TYPE_NORMAL
- en: 23 - b, c, and d
  prefs: []
  type: TYPE_NORMAL
- en: 24 - c and d
  prefs: []
  type: TYPE_NORMAL
- en: 25 - a, c, and d
  prefs: []
  type: TYPE_NORMAL
- en: 26 - a and c
  prefs: []
  type: TYPE_NORMAL
- en: 27 - c
  prefs: []
  type: TYPE_NORMAL
- en: 28 - c
  prefs: []
  type: TYPE_NORMAL
- en: 29 -c
  prefs: []
  type: TYPE_NORMAL
- en: 30 - b
  prefs: []
  type: TYPE_NORMAL
- en: 31 - d
  prefs: []
  type: TYPE_NORMAL
- en: 32 - a and b
  prefs: []
  type: TYPE_NORMAL
- en: 33 - d
  prefs: []
  type: TYPE_NORMAL
- en: 34 - b and c
  prefs: []
  type: TYPE_NORMAL
- en: 35 - d
  prefs: []
  type: TYPE_NORMAL
- en: 36 - b
  prefs: []
  type: TYPE_NORMAL
- en: 37 - a
  prefs: []
  type: TYPE_NORMAL
- en: 38 - c
  prefs: []
  type: TYPE_NORMAL
- en: 39 - c
  prefs: []
  type: TYPE_NORMAL
- en: 40 - a and b
  prefs: []
  type: TYPE_NORMAL
- en: 41 - a and b
  prefs: []
  type: TYPE_NORMAL
- en: 42 - b and c
  prefs: []
  type: TYPE_NORMAL
- en: 43 - a and c
  prefs: []
  type: TYPE_NORMAL
- en: 44 - c
  prefs: []
  type: TYPE_NORMAL
- en: 45 - a and c
  prefs: []
  type: TYPE_NORMAL
- en: 46 - b
  prefs: []
  type: TYPE_NORMAL
- en: 47 - d
  prefs: []
  type: TYPE_NORMAL
- en: 48 - b, c, and d
  prefs: []
  type: TYPE_NORMAL
- en: 49 - a and b
  prefs: []
  type: TYPE_NORMAL
- en: 50 - a
  prefs: []
  type: TYPE_NORMAL
- en: 51 - a
  prefs: []
  type: TYPE_NORMAL
- en: 52 - a, b, and c
  prefs: []
  type: TYPE_NORMAL
- en: 53 - b
  prefs: []
  type: TYPE_NORMAL
- en: 54 - a
  prefs: []
  type: TYPE_NORMAL
- en: 55 - c
  prefs: []
  type: TYPE_NORMAL
- en: 56 - b
  prefs: []
  type: TYPE_NORMAL
- en: 57 - c and d
  prefs: []
  type: TYPE_NORMAL
- en: 58 - d
  prefs: []
  type: TYPE_NORMAL
- en: 59 - d
  prefs: []
  type: TYPE_NORMAL
- en: 60 - b
  prefs: []
  type: TYPE_NORMAL
- en: 61 - a
  prefs: []
  type: TYPE_NORMAL
- en: 62 - b and c
  prefs: []
  type: TYPE_NORMAL
- en: 63 - b
  prefs: []
  type: TYPE_NORMAL
- en: 64 - b
  prefs: []
  type: TYPE_NORMAL
- en: 65 - a
  prefs: []
  type: TYPE_NORMAL
- en: 66 - a, b, and c
  prefs: []
  type: TYPE_NORMAL
- en: 67 - b
  prefs: []
  type: TYPE_NORMAL
- en: 68 - a and b
  prefs: []
  type: TYPE_NORMAL
- en: 69 - a
  prefs: []
  type: TYPE_NORMAL
- en: 70 - b and d
  prefs: []
  type: TYPE_NORMAL
