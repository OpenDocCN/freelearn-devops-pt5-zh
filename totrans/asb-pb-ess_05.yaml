- en: Chapter 4. Bringing In Your Code – Custom Commands and Scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible comes with a wide variety of built-in modules that allow us to manage
    various system components, for example, users, packages, network, files, and services.
    Ansible's battery-included approach also provides the ability to integrate the
    components with cloud platforms, databases, and applications such as **Jira**,
    **Apache**, **IRC**, and **Nagios**, and so on. However, every now and then, we
    would find ourselves in a position where we may not find a module that exactly
    does the job for us. For example, installing a package from source involves downloading
    it, extracting a source tarball, followed by the make command, and finally, "make
    install". There is no single module that does this. There will also be times when
    we would like to bring in our existing scripts that we have spent nights creating
    and just have them invoked or scheduled with Ansible, for example, nightly backup
    scripts. Ansible's command modules would come to our rescue in such situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to introduce you to:'
  prefs: []
  type: TYPE_NORMAL
- en: How to run custom commands and scripts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ansible command modules: raw, command, shell, and script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to control the idempotence of a command module
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Registered variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create a WordPress application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The command modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible has four modules that fall in to this category and provide us the options
    to choose from while running system commands or scripts. The four modules are:'
  prefs: []
  type: TYPE_NORMAL
- en: Raw
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Command
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will start learning about these one at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Using the raw module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most Ansible modules require Python to be present on the target node. However,
    as the name suggests, a raw module provides a way to communicate with hosts over
    SSH to execute raw commands without getting Python involved. The use of this module
    will bypass the module subsystem of Ansible completely. This can come in really
    handy in certain special situations or cases. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: For legacy systems running a Python version older than 2.6, Ansible requires
    the `Python-simplejson` package to be installed before you run playbooks. A raw
    module can be used to connect to the target host and install the prerequisite
    package before executing any Ansible code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the case of network devices, such as routers, switches, and other embedded
    systems, Python may not be present at all. These devices can still be managed
    with Ansible simply using a raw module.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from these exceptions, for all other cases, it is recommended that you
    use either command or shell modules, as they offer ways to control when, from
    where, and how the commands are run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following given examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command connects to all the hosts in the inventory provided with
    `customhosts` using SSH, runs a raw command uptime, and returns the results. This
    would work even if the target host does not have Python installed. This is equivalent
    to writing a `for` loop to an ad hoc shell command on a group of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same command can be converted to a task as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using the command module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This is the most recommended module for executing commands on target nodes.
    This module takes the free-form command sequence and allows you to run any command
    that could be launched from a command-line interface. In addition to the command,
    we could optionally specify:'
  prefs: []
  type: TYPE_NORMAL
- en: Which directory to run the command from
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which shell to use for execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When not to run the commands
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, a command module is called to run `ls -ltr` on the target hosts with an
    argument to change the directory to `/etc` before running the command.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to writing it as a task, the command module can directly be invoked
    as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Using the shell module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This module is very similar to the command module we just learnt about. It
    takes a free-form command and optional parameters and executes them on the target
    node. However, there are subtle differences between shell modules and command
    modules, which are listed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Shell runs the command through the '/`bin/sh`' shell on the target host, which
    also means that any command that gets executed with this module has access to
    all the shell variables on that system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unlike the command module, shell also allows the usage of operators, such as
    redirects ( `<, <<, >> , >` ), pipes ( | ) , &&, and ||
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shell is less secure than a command module, as it can be affected by a shell
    environment on the remote host
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Similar to using the command module, the preceding task runs the command sequence
    with the shell module. However, in this case, it accepts operators such as `|`
    and `>>`, does filtering with `grep`, and redirects the results to a file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of specifying this task as part of the playbook, it can be run as an
    ad hoc command with Ansible as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, you need to explicitly specify the `--sudo` option, as well as module
    options as arguments, such as `chdir=/etc` and the actual command sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Using the script module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The command modules that we learnt about so far only allow the execution of
    some system commands on the remote host. There will be situations where we would
    have an existing script that needs to be copied to the remote hosts and then executed
    there. Using the shell or command modules, this could be achieved in the following
    two steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a copy module to transfer the script file to a remote host.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, use a command or shell module to execute the script transferred previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ansible has a tailor-made module that solves this in a more efficient way. Using
    a script module instead of command or shell, we can copy and execute a script
    in one step.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'As shown in the preceding code snippet, a script can be sourced either from:'
  prefs: []
  type: TYPE_NORMAL
- en: An inside file directory of the role when invoking this module from a task inside
    a role as shown in the first example
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An absolute system path on the control host (this is the host that runs Ansible
    commands)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Just like all the other modules, a script can also be invoked as an ad hoc
    command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `script` module is invoked only on hosts that are part of the `www`
    group in the inventory. This command will copy a script at `/usr/local/backup.sh`
    from the control host and run it on the target nodes; in this case, all hosts
    in the `www` group.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying a WordPress application – a hands-on approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first iteration, we already configured an Nginx web server and a MySQL
    database to host a simple web page. We will now configure a WordPress application
    on the web server to host news and blogs.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Scenario:**'
  prefs: []
  type: TYPE_NORMAL
- en: Following our success of launching a simple web page in iteration 1, the project
    management department has asked us to set up a WordPress application to serve
    news articles and blogs in iteration 2.
  prefs: []
  type: TYPE_NORMAL
- en: WordPress is a popular open source web publishing framework based on the LAMP
    platform, which is Linux, Apache, MySQL, and PHP. WordPress is a simple, yet flexible,
    open source application that powers a lot of blogs and dynamic websites. Running
    WordPress requires a web server, PHP, and MySQL database. We already have an Nginx
    web server and MySQL database configured. We will begin by installing and configuring
    WordPress by creating a role for it and then later on, we will configure PHP.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the role, we will use the Ansible-Galaxy tool that we learnt about
    in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This will create the scaffolding required for the WordPress role. By now, we
    know that the core logic goes in to tasks and is supported by files, templates,
    handlers, and so on. We will begin by writing tasks to install and configure WordPress.
    First, we will create the main tasks file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We are following best practices and further modularizing tasks here. Instead
    of putting everything in the `main.yml` file, we will create a `install.yml` file
    and a `configure.yml` file and include them from the main file.
  prefs: []
  type: TYPE_NORMAL
- en: Installing WordPress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The installation process of WordPress will be handled from the `install.yml`
    file in the tasks directory. The process of installing WordPress typically involves:'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the WordPress installation package from [https://wordpress.org](https://wordpress.org).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extracting the installation package.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Moving the extracted directory inside the document's `root` directory of the
    web server.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will start writing code for each of the preceding steps mentioned, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw some new features in the preceding steps. Let''s analyze this code:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using a new style to write tasks. In addition to using key-value pairs
    for tasks, we could separate parameters and write them one parameter per line
    in the key-value format.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To download the WordPress installer, we used the command module with the `wget`
    command. The command takes the executable sequence with additional arguments,
    which are `chdir`, and `creates`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Creates` is a special option here. With this, we specified the path to the
    file where WordPress installer is being downloaded. We will look at how this is
    useful.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also registered the result of this module in a variable with the name `wp_download`,
    which we will use in subsequent tasks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is recommended that you use the `get_url` module, which is built in to Ansible
    to download files using the HTTP/FTP protocol. Since we want to demonstrate the
    usage of command modules, we chose to use that instead of using the `get_url`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at the new concepts that we introduced previously.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the idempotence of command modules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible comes with a wide range of modules built in it. As we learnt in [Chapter
    1](ch01.html "Chapter 1. Blueprinting Your Infrastructure"), *Blueprinting Your
    Infrastructure*, most of these modules are idempotent, and the logic to determine
    the configuration drift is built in to the module code.
  prefs: []
  type: TYPE_NORMAL
- en: However, command modules allow us to run shell commands that are not idempotent
    by nature. Since command modules have no way to determine the outcome of the task,
    it is expected that these modules are not idempotent by default. Ansible provides
    us with a few options to make these modules run conditionally and make them idempotent.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two parameters that determine whether a command is run
    or not:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Creates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Removes`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Both accept filename as the value of the parameter. In the case of `creates`,
    the command will not run if the file exists. The `removes` command does the opposite.
  prefs: []
  type: TYPE_NORMAL
- en: The "creates" and "removes" options are applicable for all command modules except
    for raw.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some guidelines on how to use `creates` and `removes` flags:'
  prefs: []
  type: TYPE_NORMAL
- en: If the command sequence or script that you are executing creates a file, provide
    that filename as a parameter value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the command sequence does not create a flag, make sure you incorporate the
    logic of creating a flag file in your command sequence or script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The registered variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We looked at variables earlier. However, we have never registered one before.
    In the tasks that we wrote to download WordPress, we use the following option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This option stores the result of the task in a variable by the name `wp_download`.
    This registered result can then be accessed later. The following are some of the
    important components of a registered variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '`changed`: This shows the status of whether the state was changed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cmd`: Through this, the command sequence is launched'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rc`: This refers to the return code'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdout`: This is the output of the command'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stdout_lines`: This is the output line by line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stderr`: These state the errors, if any'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These can then be accessed as `wp_download.rc`, `wp_download.stdout` and could
    be used inside a template, in an action line, or more commonly, with the `when`
    statements. In this case, we are going to use the return code of `wp_download`
    to decide whether to extract the package or not. This makes sense because there
    is no point in extracting a file that does not even exist.
  prefs: []
  type: TYPE_NORMAL
- en: Extracting WordPress with a shell module
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s now write a task to extract the WordPress installer and move it to the
    desired location. Before this, we also need to make sure that the document `root`
    directory has been created before running this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now analyze what we just wrote:'
  prefs: []
  type: TYPE_NORMAL
- en: We use the `file` module to create the document root directory for a web server.
    Parameters such as path, user, and group all come from variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To extract WordPress, we use the `shell` module instead of a command. This is
    because we are combining the two commands with the `&&` operator here, which the
    command module does not support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We use the `when` statement to decide whether to run extract commands or not.
    To check the condition, we use the return code of the download command that we
    stored in the registered variable `wp_download` earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring WordPress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After downloading and extracting WordPress, the next step is to configure it.
    The main configuration for WordPress is inside `wp-config.php` under the `wordpress`
    directory that we extracted. As a good practice, we will use a template to manage
    this configuration file. The following is the code to configure WordPress:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s analyze this code:'
  prefs: []
  type: TYPE_NORMAL
- en: The first task sets permissions for all WordPress files recursively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second task runs a command locally and registers the results in the `wp_salt`
    variable. This is to provide WordPress with secret keys for additional security.
    This variable will be used inside a template this time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The final task is to generate a Jinja2 template and copy it over to the target
    host as the `wp-config.php` file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s also look at the Jinja2 template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are filling in the values of the configuration parameters from variables.
    What is also interesting is that we are embedding the output of the salt download
    using the `stdout` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The resulting file that is created from this template after filling in the
    variables and the `stdut` from a registered variable will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Configuring WordPress](img/B03800_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We will now add this new role to the `www.yml` playbook, so that it gets executed
    on all our web servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will run the Ansible playbook only for web servers as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will download, extract, and configure WordPress on all web server hosts.
    We still have not installed PHP and configured Nginx to serve WordPress pages,
    so our changes won't be reflected as yet.
  prefs: []
  type: TYPE_NORMAL
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we need command modules when Ansible has a battery-included approach?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When and why do we use the raw module?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do we use the `creates` parameter with a shell when the command being executed
    does not create a file?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are `command` and `shell` modules different? When would you use a shell?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If `var3` is a registered variable, how would you print its output in a template?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learnt about how to run custom commands and scripts using
    Ansible's command modules, that is, raw, command, shell, and script. You also
    learnt how to control the idempotence of command modules using the `creates` and
    `removes` flags. We started using registered variables to store the result of
    a task that can then be used later to conditionally run other tasks or embed output
    in a template. Finally, we created a role to install and configure a WordPress
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to start learning about how to control execution
    flow using conditionals, how to apply roles selectively, and also how to use conditional
    control structures in templates.
  prefs: []
  type: TYPE_NORMAL
