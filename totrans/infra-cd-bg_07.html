<html><head></head><body>
<div><div><div><h1 id="_idParaDest-107" class="chapter-number"><a id="_idTextAnchor431"/>7</h1>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor432"/>Leveraging CI/CD in the Cloud</h1>
			<p>We have discovered that <strong class="bold">Infrastructure as Code</strong> (<strong class="bold">IaC</strong>) has become an essential practice for modern development, enabling developers to manage infrastructure through code rather than manually configuring it.</p>
			<p>However, deploying our infrastructure from a local machine, which we have been doing until now, is no longer sufficient for large-scale systems.</p>
			<p>This is where <strong class="bold">Continuous Integration/Continuous Deployment</strong> (<strong class="bold">CI/CD</strong>) comes into play; it automates the deployment process and provides consistent and reliable infrastructure deployment.</p>
			<p>This chapter will explore leveraging CI/CD in the cloud to deploy our IaC. We will focus on the popular CI/CD tool, <strong class="bold">GitHub Actions</strong>, which can run workflows triggered by different events, such as pull requests or code commits. We will explore how to use GitHub Actions to run Terraform and Ansible code in both public clouds we covered in <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Microsoft Azure</em>, and <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon </em><em class="italic">Web Services</em>.</p>
			<p>We will also cover essential security practices such as managing secrets in GitHub Actions and monitoring and maintaining the deployment once it runs. By the end of this chapter, you will understand how to leverage CI/CD in the cloud for your IaC projects using GitHub Actions.</p>
			<p>We will cover the following topics in this chapter:</p>
			<ul>
				<li><a id="_idTextAnchor433"/>Introducing GitHub Actions</li>
				<li><a id="_idTextAnchor434"/>Running Terraform using GitHub Actions</li>
				<li>Running Ansible using GitHub Actions</li>
				<li><a id="_idTextAnchor435"/><a id="_idTextAnchor436"/>Security best practices</li>
			</ul>
			<p>Before we roll our sleeves up and dive into the code, we should discuss the CI/CD tool we will use to deploy our infrastructure.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor437"/>Technical requirements</h1>
			<p><a id="_idTextAnchor438"/>The source code for this chapter is available here: <a id="_idTextAnchor439"/><a href="https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07">https://github.com/PacktPublishing/Infrastructure-as-Code-for-Beginners/tree/main/Chapter07</a></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor440"/>Introducing GitHub Actions</h1>
			<p>So, what is GitHub Actions? GitHub Actions is an automation platform that allows developers to create workflows to automate software development tasks, which in our case, means managing and<a id="_idIndexMarker397"/> deploying our IaC workloads.</p>
			<p>The beta of GitHub Actions was first launched in mid-2019. The initial release of GitHub Actions allowed a select number of developers to create and share actions that could be used to automate repetitive tasks in their development workflow. It was launched as a competitor to other popular automation platforms such as Jenkins, Travis CI, and CircleCI.<a id="_idTextAnchor441"/></p>
			<p>GitHub Actions is based on several concepts, and the ones which will be covered in detail in this chapter are the following:</p>
			<ul>
				<li><strong class="bold">Workflows</strong>: These are a series <a id="_idIndexMarker398"/>of tasks that are automated using GitHub Actions. Workflows are defined in YAML files that are stored in the repository. Workflows can be triggered by various events, such as pushing code to the repository, creating a pull request, or scheduling a job.</li>
				<li><strong class="bold">Jobs</strong>: These are the individual <a id="_idIndexMarker399"/>units of work performed within a workflow. A workflow can have multiple jobs, each running on a different platform or environment. Jobs can be run in parallel or sequentially, depending on the workflow requirements.</li>
				<li><strong class="bold">Steps</strong>: These are the individual tasks that <a id="_idIndexMarker400"/>make up a job. Each step can be a shell command, a script, or an action. Actions are pre-built units of work that can be used to automate everyday development tasks, such as building and testing code, deploying applications, and sending notifications.</li>
				<li><strong class="bold">Events</strong>: The trigger workflows and GitHub Actions support many event types, including pushes<a id="_idIndexMarker401"/> to the repository, pull requests, scheduled events, and manual triggers.</li>
			</ul>
			<p>GitHub Actions is a powerful automation platform that allows developers to automate many tasks in their development workflow. With its flexible and customizable workflows, support for various events, and pre-built actions, GitHub Actions has become an essential tool for many teams.</p>
			<p>With its continued development and new features, GitHub Actions is set to establish itself as the leading CI/CD automation platform.</p>
			<p>Rather than talking any more about GitHub Actions, let’s roll up our sleeves and look at how to run Terraform using<a id="_idTextAnchor442"/> it.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor443"/>Running Terraform using GitHub Actions</h1>
			<p>In the last four chapters, we<a id="_idIndexMarker402"/> have talked about Terraform a lot – however, we are yet to address the elephant in the room – state files.</p>
			<p>As we have been running <a id="_idIndexMarker403"/>Terraform locally, we haven’t really needed to talk<a id="_idTextAnchor444"/> about state files in too much detail yet, so let’s look at them now before we discuss how we can run Terraform using GitHub Actions.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor445"/>Terraform state files</h2>
			<p>Every time we run Terraform, a file called <code>terraform.tfstate</code> is either created, updated, or read. It is a JSON formatted file containing information about the resources created or modified by Terraform. It includes <a id="_idIndexMarker404"/>details such as the IDs, IP addresses, and other metadata associated with each resource we manage with Terraform.</p>
			<p>Terraform uses this file to keep track of the current state of the infrastructure to determine what changes must be made when you modify your infrastructure code.</p>
			<p>The state file is absolutely critical to the correct operation of Terraform. It ensures that Terraform can accurately determine what changes need to be made to the infrastructure when you run the <code>terraform </code><code>apply</code> command.</p>
			<p>Without a state file, Terraform would be unable to determine what changes to make to your infrastructure, which could result in errors or unexpected behaviors – for example, the termination and redeployment of a resource.</p>
			<p>It is also important to note that a Terraform<a id="_idIndexMarker405"/> state file should be treated as sensitive information; it contains details about your infrastructure resources and also potentially sensitive information, such as passwords if you have used Terraform to generate them.</p>
			<p>This means we must ensure that the state file is securely stored and only accessible to authorized users.</p>
			<p>So why are we only talking about this now?</p>
			<p>Well, services such as GitHub Actions are designed to provide compute resources for a short amount of time to execute a workflow, mak<a id="_idTextAnchor446"/>ing them ephemeral, which means that there is no fixed underlying storage, so once the workflow has been completed, the compute resource is terminated, and everything is lost.</p>
			<p>To support this, Terraform allows you to use backends to store your state files; as you may have already guessed, the default storage option is local storage, which will store the file in the same folder as the Terraform<a id="_idIndexMarker406"/> code you are executing. You can also use external blob storage such as Amazon <code>s3</code>) or Azure storage accounts (<code>azurerm</code>).</p>
			<p>The following example shows how you would use an Azure storage account called <code>satfbeiac1234</code> in a resource group called <code>rg-terraform-state-uks</code>:</p>
			<pre class="source-code">
terraform {
  backend "azurerm" {
    resource_group<a id="_idTextAnchor447"/>_name  = "rg-terraform-state-uks"
    storage_accoun<a id="_idTextAnchor448"/>t_name = "satfbeiac1234"
    container_name<a id="_idTextAnchor449"/>       = "tfstate"
    key                  = "prod.terraform.tfstate"
  }
}</pre>
			<p>The <code>container_name</code> parameter, in the c<a id="_idTextAnchor450"/>ase of an Azure storage account, is the blob container, which, if you were thinking of the Azure storage account as a filesystem, then this would be the folder name, and <code>key</code> is the name of the file.</p>
			<p>The configuration for Amazon<a id="_idIndexMarker407"/> S3 is not too dissimilar, as you can see from the following example:</p>
			<pre class="source-code">
terraform {
  backend "s3" {
    bucket = "tfbeiac1234"
    key    = "tfstate/prod.terraform.tfstate"
    region = "us-east-1"
  }
}</pre>
			<p>Here we are letting Terraform know the bucket name, the path to our file, and the region in which the Amazon S3 bucket is hosted.</p>
			<p>One thing that needs to be added to the preceding code is how the Azure storage account or Amazon S3 bucket is created in the first place and how Terraform authenticates against the cloud provider to be able to read and write to the backend.</p>
			<p>Rather than discuss here, let’s dive into an example GitHub action and find out.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor451"/>GitHub Actions</h2>
			<p>I am going to concentrate on<a id="_idIndexMarker408"/> Microsoft Azure in this chapter. So, as we are not using our locally installed<a id="_idIndexMarker409"/><a id="_idTextAnchor452"/> copy of the Azure <strong class="bold">command-line interface</strong> (<strong class="bold">CLI</strong>), we need to generate some credentials to use and grant access to our Azure subscription.</p>
			<p class="callout-heading">Info</p>
			<p class="callout">Please n<a id="_idTextAnchor453"/>ote<a id="_idIndexMarker410"/> that the <strong class="bold">Universally Unique Identifiers</strong> (<strong class="bold">UUIDs</strong>) in the following list are just examples; please ensure you replace them with your own where prompted.</p>
			<p>To do this, we are going to create a service principal using the following command. When you run it, make sure you replace the subscription ID with your own subscription ID, which you can find in the Azure portal under <strong class="bold">Subscriptions</strong>:</p>
			<pre class="source-code">
$ az ad sp create-for-rbac --scopes /subscriptions/3a52ef17-7e42-4f89-9a43-9a23c517cf1a --role Contributor</pre>
			<p>This will give something similar to the following output, which starts with an important message:</p>
			<pre class="source-code">
Creating 'Contributor' role assignment under scope '/subscriptions/3a52ef17-7e42-4f89-9a43-9a23c517cf1a
The output includes credentials that you must protect. Be sure that you do not include these credentials in your code or check the credentials into your source control. For more information, see https://aka.ms/azadsp-cli</pre>
			<p>As per the preceding <a id="_idIndexMarker411"/>message, ensure that you make a note of the output in a safe place, as it will be the only time you will be able to get the password that is g<a id="_idTextAnchor454"/>enerated:</p>
			<pre class="source-code">
{
  "appId": "019f16d2-552b-43ff-8eb8-6c87b13d47f9",
  "displayName": "azure-cli-2023-03-18-14-28-04",
  "password": "6t3Rq~vT.cL9y7zN_apCvGANvAg7_v6wiBb1eboQ",
  "tenant": "8a7e32c4-5732-4e57-8d8c-dfca4b1e4d4a"
}</pre>
			<p>Now that we have the details and have granted the newly created <code>Contributor</code> service principal access to our Azure subscription, we can move on to GitHub.</p>
			<p>We first need to enter some secrets and variables in the GitHub repository to configure the GitHub action.</p>
			<p>I have started with an empty GitHub repository called <code>Terraform-github-actions-example</code>; if you are following along, I recommend creating a test repo and copying the code from the repository accompanying this title across to your repo.</p>
			<p>As mentioned, the first thing we need to do is add the secrets and variables. To do this, go to your repo and click on <strong class="bold">Settings</strong>. Once the <strong class="bold">Settings</strong> page is open, you should see <strong class="bold">Secrets and variables</strong> in the left-hand side menu; when you click on it, it will expand a submenu with <strong class="bold">Actions</strong>, <strong class="bold">Codespaces</strong>, and <strong class="bold">Dependabot</strong> listed.</p>
			<p>As you might have guessed, you<a id="_idIndexMarker412"/> need to click on <strong class="bold">Actions</strong>. This should present you with something that looks like the following:</p>
			<div><div><img src="img/Figure_7.01_B19537.jpg" alt="Figure 7.1 – The Actions option on the Secrets and variables settings page" width="1650" height="1257"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The Actions option on the Secrets and variables settings page</p>
			<p>If you click on the <strong class="bold">New repository secret</strong> button and enter the secrets detailed in the following table, make sure that you enter the name exactly like it is written in the table, as the GitHub action workflow code will reference the name when it is executed:</p>
			<table id="table001-2" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold"><a id="_idTextAnchor455"/></strong><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Secret Content</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code><a id="_idTextAnchor456"/></code><code>ARM_CLIENT_ID</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the <code>appId</code> value from the output of the command that added the service principal. <a id="_idTextAnchor457"/>From the example output, this would be <code>019f16d2-552b-43ff-8eb8-6c87b13d47f9</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ARM_CLIENT_SECRET</code></p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor458"/>This is the <em class="italic">password</em> from the output of when we ran the command that added the service principal. From the example output, this would be <code>6t3Rq~vT.cL9y7zN_apCvGANvAg7_v6wiBb1eboQ</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ARM _SUBSCRIPTION_ID</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the <em class="italic">subscription ID</em> you used as the scope to add the service principal. From the example output, this would be <code>3a52ef17-7e42-4f89-9a43-9a23c517cf1a</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>ARM_TENANT_ID</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the <em class="italic">tenant</em> from the <a id="_idTextAnchor459"/>output of when we ran <a id="_idTextAnchor460"/>the command that added the service principal. From the example output, this would be <code>8a7e32c4-5732-4e57-8d8c-dfca4b1e4d4a</code>.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>Once you have entered the<a id="_idIndexMarker413"/> four secrets detailed in the preceding table, you will use the credentials to authenticate against your Azure account and make changes. We can now enter the variables; these detail the storage account and don’t need to be stored as secrets:</p>
			<table id="table002-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><strong class="bold">Name</strong></p>
						</td>
						<td class="No-Table-Style">
							<p><strong class="bold">Value Content</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>BACKEND_AZURE_RESOURCE_GROUP_NAME</code></p>
						</td>
						<td class="No-Table-Style">
							<p>This is the name of the resource group that will be created to host the storage account we will use for the <a id="_idTextAnchor461"/>Terraform state file, for example; <a id="_idTextAnchor462"/><code>rg-terraform-state-uks</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code><a id="_idTextAnchor463"/></code><code>BACKEND_AZURE_LOCATION</code></p>
						</td>
						<td class="No-Table-Style">
							<p><a id="_idTextAnchor464"/>The region the resources are going to be launched in. For example, <a id="_idTextAnchor465"/><code>uksouth</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>BACKEND_AZURE_STORAGE_ACCOUNT</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The name of the storage account you create must be unique across all of Azure; otherwise, you will get an error<a id="_idTextAnchor466"/>. For example, <a id="_idTextAnchor467"/><code>satfstate180323</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>BACKEND_AZURE_CONTAINER_NAME</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The name of the container where the file will be stored, for example, <a id="_idTextAnchor468"/><code>tfstate</code>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><code>BACKEND_AZURE_STATE_FILE_NAME</code></p>
						</td>
						<td class="No-Table-Style">
							<p>The name of Terraform state file itself, for example,<a id="_idTextAnchor469"/> <code>ghact.<a id="_idTextAnchor470"/>tfstate</code>.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p>So now that we have<a id="_idIndexMarker414"/> everything that we need secret- and variable-wise in the GitHub repository, we can look at the workflow itself.</p>
			<p>GitHub action<a id="_idIndexMarker415"/> workflows ar<a id="_idTextAnchor471"/>e <strong class="bold">YAML Ain’t Markup Language</strong> or <strong class="bold">Yet Another Markup Language</strong> (<strong class="bold">YAML</strong>) files (depending on the explanation <a id="_idIndexMarker416"/>you read).</p>
			<p class="callout-heading">Information</p>
			<p class="callout">YAML is a human-readable data serialization format that us<a id="_idTextAnchor472"/>es indentation to convey structure, popular for configuration files, data exchange, and applications requiring simple data representation<a id="_idTextAnchor473"/>.</p>
			<p>First, we have some basic configuration; here, we use <code>name</code> to name the workflow and define <code>on</code> to specify on what action the workflow should trigger:</p>
			<pre class="source-code">
name: "Terraform Plan/Apply"
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main</pre>
			<p>As you can see, the workflow will be triggered as defined in the <code>on</code> section of the YAML file, on a <code>push</code> or <code>pull_request</code> to the <code>main</code> branch. Now that we have defined when the workflow will be triggered, we can now define the three jobs that go to make up the workflow, starting with the<a id="_idIndexMarker417"/> job that checks the presence of the storage account we are going to use for the backend Terraform state file – and it if it is not there, create one.</p>
			<p class="callout-heading">Please note</p>
			<p class="callout">Indentation is really important when it comes to the structure of the YAML file; however, while working through the structure across the following pages, I will be removing some of <a id="_idTextAnchor474"/>the indentations to make it more readable – please refer to the code in the GitHub repository that accompanies this title for the correct format and indentation.</p>
			<p>First, we define the jobs and some basic configurations:</p>
			<pre class="source-code">
jobs:
  check_storage_account:
    name: "Check for Azure storage account"
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash</pre>
			<p>Here we are giving the job an internal reference, <code>check_storage_account</code>, and telling it to run on the latest version of Ubuntu and use <code>bash</code> as the default shell.</p>
			<p>The <code>check_storage_account</code> job is made up of two steps, step one being as follows:</p>
			<pre class="source-code">
steps:
    - name: Login to Azure using a service principal
      us<a id="_idTextAnchor475"/>es: Azure/login@v1
      with:
        creds: '{"clientId":"${{ secrets.ARM_CLIENT_ID }}","clientSecret":"${{ secrets.ARM_CLIENT_SECRET }}","subscriptionId":"${{ secrets.ARM_SUBSCRIPTION_ID }}","tenantId":"${{ secrets.ARM_TENANT_ID }}"}'</pre>
			<p>Here we are using the <code>Azure/login@v1</code> task to log in to our Azure account using the secrets we defined in GitHub. Th<a id="_idTextAnchor476"/>ese are referred to by using <code>${{ secrets.ARM_CLIENT_ID }}</code>. The next step uses the variables we added to GitHub and <a id="_idTextAnchor477"/>the <code>Azure/CLI@v1</code> task to <a id="_idIndexMarker418"/>check for the presence of the storage account.</p>
			<p>If it is not there, it will be created, and the resources already exist, then the task will progress to the next step:</p>
			<pre class="source-code">
- name: Create Azure storage account
  uses: Azure/CLI@v1
  with:
    inlineScript: |
      az group create --name ${{ vars.BACKEND_AZURE_RESOURCE_GROUP_NAME }} --location ${{ vars.BACKEND_AZURE_LOCATION }}
      az storage account create --name ${{ vars.BACKEND_AZURE_STORAGE_ACCOUNT }} --resource-group ${{ vars.BACKEND_AZURE_RESOURCE_GROUP_NAME }} --location ${{ vars.BACKEND_AZURE_LOCATION }} --sku Standard_LRS
      az storage container create --name ${{ vars.BACKEND_AZURE_CONTAINER_NAME }} --account-name ${{ vars.BACKEND_AZURE_STORAGE_ACCOUN<a id="_idTextAnchor478"/>T }}</pre>
			<p>As this step is running on the same Ubuntu instance as the first step, which logged into Azure, we don’t need to authenticate again – instead, we can just run the Azure CLI commands we need:</p>
			<ol>
				<li>Create or check for the presence of the resource group to host<a id="_idTextAnchor479"/> our storage account using <code>az </code><code>group cre<a id="_idTextAnchor480"/>ate</code>.</li>
				<li>Create or check for the presence of the storage account using <code>az storage </code><code>account create</code>.</li>
				<li>Create or check for the presence of the container in the storage account using <code>az storage </code><code>container create</code>.</li>
			</ol>
			<p>Now that we know we have the<a id="_idIndexMarker419"/> storage account in place for the Terraform backend state file storage, we can proceed with the next job, which runs the <code>terraform_plan</code> command and stores the output with the workflow run.</p>
			<p>As per the last job, we need to set up some basic configurations, such as the job name and reference, what operating system to use, and also some additional <a id="_idTextAnchor481"/>bits:</p>
			<pre class="source-code">
terraform_plan:
  name: "Terraform Plan"
  needs: check_storage_account
  runs-on: ubuntu-latest
  env:
    ARM_CLIENT_ID: "${{ secrets.ARM_CLIENT_ID }}"
    ARM_CLIENT_SECRET: "${{ secrets.ARM_CLIENT_SECRET }}"
    ARM_SUBSCRIPTION_ID: "${{ secrets.ARM_SUBSCRIPTION_ID }}"
    ARM_TENANT_ID: "${{ secrets.ARM_TENANT_ID }}"
  defaults:
    run:
      shell: bash</pre>
			<p>As you can see, we are setting some environment variables containing the credentials needed to log in to Azure; why are we doing that again when we already authenticated during the last job?</p>
			<p>The reason is that once the last task in the last job finished, the co<a id="_idTextAnchor482"/>mpute resource running the job was terminated, and when this job started, a new resource was spun up, meaning that everything from the last job was lost.</p>
			<p>Now that we have defined the<a id="_idIndexMarker420"/> basics for the <code>terraform_plan</code> job, we can work through the <a id="_idTextAnchor483"/>steps:</p>
			<pre class="source-code">
steps:
  - name: Checkout the code
    id: checkout
    uses: actions/checkout@v3</pre>
			<p>This simple step checks out the repository from which we are running the action; the repository contains the Terraform we will e<a id="_idTextAnchor484"/>xecute during the workflow.</p>
			<p>Now we have the code we need to install Terraform. To do this, we use the <code>hashicorp/setup-terraform@v2</code> task:</p>
			<pre class="source-code">
- name: Setup Terraform
  id: setup
  uses: hashicorp/setup-terraform@v2
  with:
    terraform_wrapper: false</pre>
			<p>So far, so good; as per when we were running Terraform on our local machine, we now need to r<a id="_idTextAnchor485"/>un the <code>terraform </code><code>init</code> command:</p>
			<pre class="source-code">
- name: Terraform Init
  id: init
  run: terraform init -backend-config="resource_group_name=${{ vars.BACKEND_AZURE_RESOURCE_GROUP_NAME }}" -backend-config="storage_account_name=${{ vars.BACKEND_AZURE_STORAGE_ACCOUNT }}" -backend-config="container_name=${{ vars.BACKEND_AZURE_CONTAINER_NAME }}" -backend-config="key=${{ vars.BACKEND_AZURE_STATE_FILE_NAME }}"</pre>
			<p>As you can see, we have <a id="_idIndexMarker421"/>appended quite a bit to the end of the <code>terraform init</code> command – this sets up our backend using the variables we defined in GitHub for the duration of the job, meaning Terraform will use the remote backend and not the local one.</p>
			<p>Next up, we need to run the <code>terraform plan</code> command to figure out what needs to happen during the workflow execution:</p>
			<pre class="source-code">
- name: Terraform Plan
  id: tf-plan
  run: |
    export exitcode=0
    terraform plan -detailed-exitcode -no-color -out tfplan || export exitcode=$?
    echo "exitcode=$exitcode" &gt;&gt; $GITHUB_OUTPUT</pre>
			<p>You will have noticed that we are wrapping a little logic around the command to figure out the exit code. We need to do this because we need to know whether we should stop the execution of the workflow if there is an error, which is what the final piece of the code in the step does:</p>
			<pre class="source-code">
    if [ $exitcode -eq 1 ]; then
      echo Terraform Plan Failed!
      exit 1
    else
      exit 0
    fi</pre>
			<p>So now we know whether there are any obvious errors or everything is OK, and we have a copy of the Terraform plan file; what’s next?</p>
			<p>As we have already mentioned, when we run the next job, we will be starting from scratch, and as we need a copy of the Terraform plan file, we should copy it from the compute resource:</p>
			<pre class="source-code">
- name: Publish Terraform Plan
<a id="_idTextAnchor486"/>  uses: actions<a id="_idTextAnchor487"/>/upload-artifact@v3
  with:
  <a id="_idTextAnchor488"/>  name: tfplan
    path: tfplan</pre>
			<p>We are using the <code>actions/upload-artifact@v3</code> task to copy the file called <code>tfplan</code> to the workflow execution as an artifact; in subsequent tasks and jobs, we can download the file and use it without<a id="_idIndexMarker422"/> committing to the code repo itself.</p>
			<p>The next task, at first glance, may seem a little redundant:<a id="_idTextAnchor489"/></p>
			<pre class="source-code">
- name: Create String Output
  id: tf-plan-string
  run: |
    TERRAFORM_PLAN=$(terraform show -no-color tfplan)
    delimiter="$(openssl rand -hex 8)"
    echo "summary&lt;&lt;${delimiter}" &gt;&gt; $GITHUB_OUTPUT
    echo "## Terraform Plan Output" &gt;&gt; $GITHUB_OUTPUT
    echo "&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;" &gt;&gt; $GITHUB_OUTPUT
    echo "" &gt;&gt; $GITHUB_OUTPUT
    echo '```terraform' &gt;&gt; $GITHUB_OUTPUT
    echo "$TERRAFORM_PLAN" &gt;&gt; $GITHUB_OUTPUT
    echo '```' &gt;&gt; $GITHUB_OUTPUT
    echo "&lt;/details&gt;" &gt;&gt; $GITHUB_OUTPUT
    echo "${delimiter}" &gt;&gt; $GITHUB_OUTPUT</pre>
			<p>The task appears to be doing something with the Terraform plan file, but what?</p>
			<p>One of the advantages of using a system such as GitHub actions is that you can publish artifacts and also publish other outputs – in this case, we are taking the list of changes logged within the plan file and formatting it for use as a workflow summary.</p>
			<p>The next and final task within this job is <a id="_idIndexMarker423"/>to take the summary we have just generated and publish it back to GitHub:</p>
			<pre class="source-code">
- name: Publish Terraform Plan to Task Summary
  env:
    SUMMARY: ${{ steps.tf-plan-string.outputs.summary }}
  run: |
    echo "$SUMMARY" &gt;&gt; $GITHUB_STEP_SUMMARY</pre>
			<p>Now, all we have left is to run the <code>terraform apply</code> command – this is the last job of our workflow, and it shares many of the steps with the previous job.</p>
			<p>However, there are some changes to the configuration that we should highlight:</p>
			<pre class="source-code">
terraform-apply:
  name: "Terraform Apply"
  if: github.ref == 'refs/heads/main'
  runs-on: ubuntu-latest
  env:
    ARM_CLIENT_ID: "${{ secrets.ARM_CLIENT_ID }}"
    ARM_CLIENT_SECRET: "${{ secrets.ARM_CLIENT_SECRET }}"
    ARM_SUBSCRIPTION_ID: "${{ secrets.ARM_SUBSCRIPTION_ID }}"
    ARM_TENANT_ID: "${{ secrets.ARM_TENANT_ID }}"
  needs: [terraform_plan]</pre>
			<p>As you can see, we have added the <code>if</code> and <code>needs</code> statements. The <code>if</code> statement verifies that we are 100% working with the correct branch, and the <code>needs</code> statement ensures that the <code>terraform_plan</code> job has been successfully executed, meaning that we will have the Terraform p<a id="_idTextAnchor490"/>lan file.</p>
			<p>The first three steps<a id="_idIndexMarker424"/> are ones that we have already covered, them being the following:</p>
			<ol>
				<li>Check out the code</li>
				<li>Set up Terraform</li>
				<li><code>terraform init</code></li>
			</ol>
			<p>Next, we need to download the Terraform plan file:</p>
			<pre class="source-code">
- name: Download Terraform Plan
  uses: actions/download-artifact@v3
  with:
    name: tfplan</pre>
			<p>With the plan file downloaded, we can now perform the final task of the workflow, which is to run the <code>terraform apply</code> command and deploy the changes, if any, detailed within the plan file.</p>
			<p>Given the number of tasks it has taken for us to get to this point, the final task is quite simple:</p>
			<pre class="source-code">
- name: Terraform Apply
  run: terraform apply -auto-approve tfplan</pre>
			<p>As you can see, we run <code>terraform apply</code> with the <code>-auto-approve</code> flag; if we don’t, then Terraform will quite happily sit there for an hour waiting for someone to type <code>Yes</code>, which will never happen as this is not an interactive terminal.</p>
			<p>We are then telling it to load in the file called <code>tfplan</code>, which means that we do not need to run the <code>terraform plan</code> command for a second time as we already know what will change/be applied during the execution.</p>
			<p>So, what changes to our Terraform code are needed for this to work?</p>
			<p>Just the one we need to tweak our code to use the <code>azurerm</code> backend; this makes the top of our <code>main.tf</code> file look like the following:</p>
			<pre class="source-code">
terraform {
  required_version = "&gt;=1.0"
  required_providers {
    azurerm = {
      source  = "hashicorp/azurerm"
      version = "~&gt;3.0"
    }
  }
  backend "azurerm" {}
}</pre>
			<p>The rest of the code remains<a id="_idIndexMarker425"/> as is. We then need to take a workflow YAML file and place it in a fo<a id="_idTextAnchor491"/>lder called <code>.github/workflows</code> at the top level of our repository. I have named the file <a id="_idTextAnchor492"/><code>action.yml</code>.</p>
			<p class="callout-heading">Please note</p>
			<p class="callout">In the repo accompanying this title, the folder name purposely has the “<code>.</code>” removed, so the GitHub action is not registered. When you copy to your repo, please ensure you rename the <code>github</code> folder to <code>.github</code>; otherwise, the action won’t be registered, and the workflow will not run.</p>
			<p>So let’s run it the first time you check in the <code>action.yml</code> file. It will create the action and run – this can be confirmed by the dot next to the commit ID, which in the following example screen is referenced as <a id="_idTextAnchor493"/><strong class="bold">b4900e8</strong>:</p>
			<div><div><img src="img/Figure_7.02_B19537.jpg" alt="Figure 7.2 – Checking in and running the workflow" width="1650" height="778"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – Checking in and running the workflow</p>
			<p>If everything has run as<a id="_idIndexMarker426"/> expected, clicking the <strong class="bold">Actions</strong> tab at the top of the repo page should show you something like the fo<a id="_idTextAnchor494"/>llowing:</p>
			<div><div><img src="img/Figure_7.03_B19537.jpg" alt="Figure 7.3 – Viewing the workflow runs" width="1650" height="428"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3 – Viewing the workflow runs</p>
			<p>Clicking on the workflow run will take you to the execution <strong class="bold">Summary</strong> page; for me, this looked like the fol<a id="_idTextAnchor495"/>lowing:</p>
			<div><div><img src="img/Figure_7.04_B19537.jpg" alt="Figure 7.4 – Reviewing the workflow execution" width="1650" height="1265"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.4 – Reviewing the workflow execution</p>
			<p>As you can see, we<a id="_idIndexMarker427"/> have the three jobs listed and the artifacts and the custom summary we published from the <code>terraform </code><code>plan</code> c<a id="_idTextAnchor496"/>ommand:</p>
			<div><div><img src="img/Figure_7.05_B19537.jpg" alt="Figure 7.5 – Viewing the output of Terraform Plan" width="1650" height="743"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5 – Viewing the output of Terraform Plan</p>
			<p>Also, if you click on any of the job names, it will show the output of each of the t<a id="_idTextAnchor497"/>asks:</p>
			<div><div><img src="img/Figure_7.06_B19537.jpg" alt="Figure 7.6 – Viewing the output of Terraform Plan" width="1650" height="798"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6 – Viewing the output of Terraform Plan</p>
			<p>I recommend clicking<a id="_idIndexMarker428"/> around and reviewing precisely what the GitHub action workflow executed, as it gives pretty detailed information.</p>
			<p>Finally, if you check the Azure portal, you should see the resource group, storage account, and container where there should be a single file called <code>ghact.tf<a id="_idTextAnchor498"/>state</code>:</p>
			<div><div><img src="img/Figure_7.07_B19537.jpg" alt="Figure 7.7 – Checking the Terraform state file in the Azure portal" width="1650" height="487"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7 – Checking the Terraform state file in the Azure portal</p>
			<p>That concludes using GitHub actions to run Terraform; before we finish the chapter, let’s look at a workflow that runs Ansible.</p>
			<h1 id="_idParaDest-114"><a id="_idTextAnchor499"/>Running Ansible using GitHub Actions</h1>
			<p>Ansible doesn’t have a<a id="_idIndexMarker429"/> concept of state files, so this will simplify our <a id="_idIndexMarker430"/>GitHub action workflow. As we are using Microsoft Azure again, you must set up the <code>ARM_CLIENT_ID</code>, <code>ARM_CLIENT_SECRET</code>, <code>ARM_SUBSCRIPTION_ID</code>, and <code>ARM_TENANT_ID</code> secrets in your GitHub repository as we did in the last section before progressing.</p>
			<p>Once they are there, we can move on to the workflow itself; as with the Terraform workflow, we start by setting some basic configurations:</p>
			<pre class="source-code">
name: "Ansible Playbook Run"
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main</pre>
			<p>Then we define the job; that’s right, there is only one job for this workflow:</p>
			<pre class="source-code">
jobs:
  run_ansible_playbook:
    name: "Run Ansible Playbook"
    runs-on: ubuntu-latest
    defaults:
      run:
        shell: bash</pre>
			<p>So far, not much is different, so let’s move on to the steps. First, we check out the code:</p>
			<pre class="source-code">
steps:
  - name: Checkout the code
    id: checkout
    uses: actions/checkout@v3</pre>
			<p>Here we hit our first difference; as <a id="_idIndexMarker431"/>Ansible is written in Python, we need to make sure<a id="_idIndexMarker432"/> that Python is installed and reasonably up to date. For this, we <a id="_idTextAnchor500"/><a id="_idTextAnchor501"/>will use the <code>actions/setup-python@v4</code> task:</p>
			<pre class="source-code">
- name: Ensure that Python 3.10 is installed
  uses: actions/setup-python@v4
  with:
    python-version: "3.10"</pre>
			<p>The next step is to log in to Azure, this is an exact copy of the <em class="italic">Log in to Azure using a service principal</em> step from the Terraform workflow in the previous section of this chapter, so I will not repeat the code here.</p>
			<p>Next, we need to install Ansible itself – we are doing this using the <code>pip</code> command; the step looks like the following:</p>
			<pre class="source-code">
- name: Install Ansible
  run: pip install ansible</pre>
			<p>Once Ansible is installed, we can then run the <code>ansible-galaxy</code> command to install the Azure Collection – this step is not too different from when installed it locally:</p>
			<pre class="source-code">
- name: Install Azure Collection
  run: ansible-galaxy collection install azure.azcollection</pre>
			<p>As you may have guessed, once the Azure Collection is installed, we need to install the Python modules needed for the collection to function:</p>
			<pre class="source-code">
- name: Install Azure Requirements
  run: pip install -r ~/.ansible/collections/ansible_collections/azure/azcollection/requirements-azure.txt</pre>
			<p>Once everything we need to run the playbook is installed, we can run the task; this step looks like the <em class="italic">Create String Output</em> step in the <a id="_idIndexMarker433"/>Terraform workflow, as we want to <a id="_idIndexMarker434"/>capture the output of the <code>ansible-playbook</code> command and store it within the workflow summary:</p>
			<pre class="source-code">
- name: Run the playbook (with ansible-playbook)
  id: ansible-playbook-run
  run: |
    ANSIBLE_OUTPUT=$(ansible-playbook site.yml)
    delimiter="$(openssl rand -hex 8)"
    echo "summary&lt;&lt;${delimiter}" &gt;&gt; $GITHUB_OUTPUT
    echo "## Ansible Playbook Output" &gt;&gt; $GITHUB_OUTPUT
    echo "&lt;details&gt;&lt;summary&gt;Click to expand&lt;/summary&gt;" &gt;&gt; $GITHUB_OUTPUT
    echo "" &gt;&gt; $GITHUB_OUTPUT
    echo '```' &gt;&gt; $GITHUB_OUTPUT
    echo "$ANSIBLE_OUTPUT" &gt;&gt; $GITHUB_OUTPUT
    echo '```' &gt;&gt; $GITHUB_OUTPUT
    echo "&lt;/details&gt;" &gt;&gt; $GITHUB_OUTPUT
    echo "${delimiter}" &gt;&gt; $GITHUB_OUTPUT</pre>
			<p>The final step in the workflow is to publish the summary:</p>
			<pre class="source-code">
- name: Publish Ansible Playbook run to Task Summary
  env:
    SUMMARY: ${{ steps.ansible-playbook-run.outputs.summary }}
  run: |
    echo "$SUMMARY" &gt;&gt; $GITHUB_STEP_SUMMARY</pre>
			<p>That is it; as you can see, the workflow has fewer jobs and steps as we don’t have to take into consideration either<a id="_idIndexMarker435"/> the backend storage or publishing plan file as an<a id="_idIndexMarker436"/> artifact as we did for the Terraform workflow.</p>
			<p>Running the workflow should give you something like the following output:</p>
			<div><div><img src="img/Figure_7.08_B19537.jpg" alt="Figure 7.8 – Running the Ansible Playbook using GitHub Actions" width="1650" height="1277"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8 – Running the Ansible Playbook using GitHub Actions</p>
			<p>Again, the folder name of the repo accompanying this title purposely has the <code>.</code>  character removed from the start of the folder name, so the GitHub action is not registered. If you are following along in your repo, per the Terraform GitHub Action workflow, you must rename this folder to <code>.github</code> when committing to your repo to register the action.</p>
			<p>Now that we have run our workflows using Terraform and Ansible, let’s quickly discuss some best practices.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor502"/>Security best practices</h1>
			<p>When we worked <a id="_idIndexMarker437"/>through the Terraform and Ansible workflows, we discussed adding repository secrets to our GitHub repository. All sensitive information should be stored within secrets outside of using an external source for your secrets, such as Azure Key Vault, AWS Secrets Manager, or HashiCorp Vault.</p>
			<p>The advantage of this is that the secrets will remain hidden, but the code will also be able to consume them. Great, you may think to yourself.</p>
			<p>But anyone who has been granted write access to the repo will also be able to consume them (though not view the contents), so please be careful when granting access to your IaC CI/CD pipelines as they will have a high level of access to your cloud resource via your workflows, so please ensure that you only grant access to trusted member<a id="_idTextAnchor503"/>s of your teams.</p>
			<h1 id="_idParaDest-116"><a id="_idTextAnchor504"/>Pop quiz</h1>
			<p>Before we finish the chapter, let’s have a quick pop quiz:</p>
			<ol>
				<li>When writing YAML, what is it essential to keep an eye on?</li>
				<li>When it comes to credentials, what should you never do?</li>
				<li>What is the folder name in which the GitHub action should be stored?</li>
			</ol>
			<h1 id="_idParaDest-117"><a id="_idTextAnchor505"/>Summary</h1>
			<p>While we spent a lot of the initial part of the chapter discussing how Terraform works, once we got onto working through the GitHub Actions workflows, I am sure that you started to see the ben<a id="_idTextAnchor506"/>efits of running our IaC from a centrally accessible location rather than your local machine.</p>
			<p>Once we discussed Terraform’s requirements, we configured repository secrets and variables in GitHub. Then we worked through the various jobs and steps to make up the workflow that manages the storage account, where we stored the Terraform state and executed the Terraform deployment.</p>
			<p>We then took everything we learned and covered in Terraform and applied it to Ansible before finally discussing a vital security point – be careful what access you give to your IaC GitHub actions!</p>
			<p>There are some points we needed more time to cover, such as monitoring; for example, it is relatively straightforward to hook your GitHub Actions into messaging services such as Microsoft Teams or Slack to get real-time feedback on workflow runs – there are links to the GitHub Actions Marketplace tasks for Microsoft Teams and Slack in the further reading section if you want to have a go at hooking your workflows into your preferred messaging service.</p>
			<p>This is not only a great way of extending your IaC deployments to other team members, but it also works as a system that tracks changes as the workflow runs, which contains a summary of each execution that will be stored for a while.</p>
			<p>In the next and penultimate chapter, we will look at common troubleshooting tips and tricks.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor507"/>Further reading</h1>
			<p>You can find more details on the tasks we have used in the steps in this chapter at the following URLs:</p>
			<ul>
				<li><a href="https://github.com/marketplace/">https://github.com/marketplace/</a></li>
				<li>https://github.com/marketplace/actions/azure-login</li>
				<li><a href="https://github.com/marketplace/actions/azure-cli-action">https://github.com/marketplace/actions/azure-cli-action</a></li>
				<li><a href="https://github.com/marketplace/actions/checkout">https://github.com/marketplace/actions/checkout</a></li>
				<li><a href="https://github.com/marketplace/actions/upload-a-build-artifact">https://github.com/marketplace/actions/upload-a-build-artifact</a></li>
				<li><a href="https://github.com/marketplace/actions/download-a-build-artifact">https://github.com/marketplace/actions/download-a-build-artifact</a></li>
				<li><a href="https://github.com/marketplace/actions/setup-python">https://github.com/marketplace/actions/setup-python</a></li>
				<li><a href="https://github.com/marketplace/actions/microsoft-teams-deploy-card">https://github.com/marketplace/actions/microsoft-teams-deploy-card</a></li>
				<li><a href="https://github.com/marketplace/actions/slack-notify">https://github.com/marketplace/actions/slack-notify</a></li>
			</ul>
			<h1 id="_idParaDest-119"><a id="_idTextAnchor508"/>Answers</h1>
			<p>Here are the answers to the pop quiz:</p>
			<ol>
				<li>When writing YAML, what is it essential to keep an eye on? Indentation! The structure of your YAML file is critical – if you get it wrong, even by a single character, you will get errors.</li>
				<li>When it comes to credentials, what should you never do? Embed them into your code! You need to use an external secret management system.</li>
				<li>What is the folder name in which the GitHub action should be stored? Your YAML files should be stored in the <code>.</code><code>github/workflows</code> folder.</li>
			</ol>
		</div>
	</div>
</div>
</body></html>