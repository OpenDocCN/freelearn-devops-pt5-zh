<html><head></head><body>
<div class="book" title="Chapter&#xA0;2.&#xA0;DevOps Framework" id="DB7S1-9e1d43bf5c22491b83b15944fc98f0e3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. DevOps Framework</h1></div></div></div><p class="calibre8">In this lesson, we will learn about different DevOps processes, frameworks, and best practices. We will present DevOps process maturity frameworks and progression models with checklist templates for each phase of DevOps. We will also become familiar with agile terminology and methodology and the benefits accrued by an organization by adopting it. In this lesson, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">DevOps process</li><li class="listitem">DevOps progression frameworks</li><li class="listitem">DevOps maturity models</li><li class="listitem">DevOps best practices</li><li class="listitem">Agile and DevOps</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;DevOps Framework" id="DB7S1-9e1d43bf5c22491b83b15944fc98f0e3">
<div class="book" title="DevOps Process"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec11" class="calibre1"/>DevOps Process</h1></div></div></div><p class="calibre8">The DevOps standard processes prescribed across the industry and adopted by organizations are listed here; we will discuss them in detail:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Source code management</li><li class="listitem">Source code review</li><li class="listitem">Configuration management</li><li class="listitem">Build management</li><li class="listitem">Repository management</li><li class="listitem">Release management</li><li class="listitem">Test automation</li><li class="listitem">Continuous integration</li><li class="listitem">Continuous delivery</li><li class="listitem">Continuous deployment</li><li class="listitem">Infrastructure as Code</li><li class="listitem">Application performance monitoring</li><li class="listitem">Routine automation/continuous improvement</li><li class="listitem">DevOps frameworks--under DevOps frameworks, we will study the life cycle models, maturity states, progression and best practices frameworks, and also Agile methodology:<div class="book"><ul class="itemizedlist1"><li class="listitem">DevOps project life cycle</li><li class="listitem">Maturity states</li><li class="listitem">Progression frameworks</li><li class="listitem">DevOps practices frameworks</li><li class="listitem">Agile methodology</li></ul></div></li></ul></div></div></div>

<div class="book" title="DevOps Best Practices"><div class="book" id="E9OE2-9e1d43bf5c22491b83b15944fc98f0e3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec12" class="calibre1"/>DevOps Best Practices</h1></div></div></div><p class="calibre8">The adoption of DevOps best practices will help to align people and progress towards organizational goals. DevOps offers multiple process frameworks at every stage of software development. Full-scale implementation of DevOps in an organization requires a cultural shift integrating departments, people, and the process of software life cycles. It enables organizations to move higher on the maturity road map in terms of compliance and process adherence:</p><div class="mediaobject"><img src="../images/00004.jpeg" alt="DevOps Best Practices" class="calibre10"/></div><p class="calibre11"> </p></div>

<div class="book" title="DevOps Best Practices">
<div class="book" title="DevOps Process"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec06" class="calibre1"/>DevOps Process</h2></div></div></div><p class="calibre8">Now we will look at DevOps standard processes prescribed across the industry and adopted by organizations, discussed in detail.</p><div class="book" title="Source Code Management"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec01" class="calibre1"/>Source Code Management</h3></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Source code management</strong></span> (<span class="strong"><strong class="calibre2">SCM</strong></span>) systems have been in use for decades, offering many functions and benefits. However, integrating them with DevOps processes offers robust integration and automation. A source code management system enables multiple developers to develop code concurrently across multiple development centers spread across diverse geographies. SCM helps in the management of code base and version control at the file level, so developers don't overwrite each other's code, and they have ability to work in parallel on files in their respective branches.</p><p class="calibre8">Developers merge their code changes to the main or sub branch which can be tracked, audited, enquired for bug fixes, and rolled back if needed. Branching is an important functionality of SCM, multiple branches of the software are maintained for different major and minor releases, tracking the features and bug fixes across various release versions. SCM enables managing process adherence across environments of development, test and production, facilitating entire software life cycle management from development to support.</p><p class="calibre8">The DevOps process framework emphasizes the adoption of SCM for accruing the following benefits for the organization:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Coordination of services between members of a software development team</li><li class="listitem">Define a single source of truth for any version, minor or major</li><li class="listitem">Review changes before implementing</li><li class="listitem">Track co-authoring, collaboration, and individual contributions</li><li class="listitem">Audit code changes and rollback facility</li><li class="listitem">Incremental backup and recovery</li></ul></div><p class="calibre8">SCM tools prevalent in the market are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">IBM ClearCase</li><li class="listitem">Perforce</li><li class="listitem">PVCS</li><li class="listitem">Team Foundation Server</li><li class="listitem">Visual Studio Team Services</li><li class="listitem">Visual SourceSafe</li></ul></div><p class="calibre8">Open source SCM tools are as follows--their popularity is also attributed to DevOps' widespread adoption:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Subversion</strong></span> (<span class="strong"><strong class="calibre2">SVN</strong></span>)</li><li class="listitem"><span class="strong"><strong class="calibre2">Concurrent Version System</strong></span> (<span class="strong"><strong class="calibre2">CVS</strong></span>)</li><li class="listitem">Git</li><li class="listitem">SCCS</li><li class="listitem">Revision control systems</li><li class="listitem">Bitbucket</li></ul></div></div><div class="book" title="Code Review"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec02" class="calibre1"/>Code Review</h3></div></div></div><p class="calibre8">Code reviews are an important process to improve the quality of software instances before they are integrated into the main stream. They help identify and remove common vulnerabilities such as memory leaks, formatting errors and buffer overflows. Code review or inspection can be both formal and informal. In a formal code review, the process is through multiple methods such as formal meetings, and interactions to review the code line by line. Informal code reviews can be over the shoulder, emails, pair programming where a few authors codevelop, or tool assisted code reviews--these are also called <span class="strong"><strong class="calibre2">code walkthroughs</strong></span>.</p><p class="calibre8">A code review process framework benefits the organization as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Collaboration between software development team members</li><li class="listitem">Identification and elimination of code defects before integration</li><li class="listitem">Improvement of code quality</li><li class="listitem">Quick turnaround of development cycle</li></ul></div><p class="calibre8">Proprietary tools for code review automation:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Crucible</li><li class="listitem">Collaborator</li><li class="listitem">Codacy</li><li class="listitem">Upsource</li><li class="listitem">Understand</li></ul></div><p class="calibre8">Open source tools for code review automation:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Review board</li><li class="listitem">Phabricator</li><li class="listitem">Gerrit</li><li class="listitem">GitLab</li></ul></div></div><div class="book" title="Configuration Management"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec03" class="calibre1"/>Configuration Management</h3></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Configuration Management</strong></span> (<span class="strong"><strong class="calibre2">CM</strong></span>) is the broad subject of governing configuration items at enterprise level, as per <span class="strong"><strong class="calibre2">Infrastructure Library</strong></span> (<span class="strong"><strong class="calibre2">ITIL</strong></span>); even the <span class="strong"><strong class="calibre2">configuration management database </strong></span>(<span class="strong"><strong class="calibre2">CMDB</strong></span>) is part of the CM strategy. Configuration management includes identification, verification, and maintenance of configuration items of both software and hardware, such as patches and versions. In simple terms, it's about managing the configuration of a system and ensuring its fitness for its intended purpose. A configuration management tool will validate the appropriateness of the configurations on the system as per the requirements and its interoperability between systems. A common example is to ensure the code developed on a development system is effectively functional on a QA (test) system and production systems. Any loss of configuration parameters between the systems will be catastrophic for the application's performance.</p><p class="calibre8">As per DevOps, the benefits of incorporating configuration management processes and tools for an organization can be summarized as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Facilitates organizations with impact analysis due to the configuration change</li><li class="listitem">Allows automated provisioning on different systems such as dev, QA, and prod</li><li class="listitem">Facilitates audit, account, and verification of the systems</li><li class="listitem">Reduces redundant work by ensuring consistency</li><li class="listitem">Effectively manages simultaneous updates</li><li class="listitem">Avoids configuration related problems of a single version of the truth</li><li class="listitem">Simplifies coordination between team members of development and operations</li><li class="listitem">It is helpful in tracking defects and resolving them in time</li><li class="listitem">Helps in predictive and preventive maintenance</li></ul></div><p class="calibre8">A few popular configuration management tools for infrastructure are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">BMC Software's Atrium</li><li class="listitem">Hewlett Packard Enterprise's Universal Configuration Management Database</li></ul></div><p class="calibre8">A few popular software configuration management tools are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Chef</li><li class="listitem">Puppet</li><li class="listitem">Ansible</li><li class="listitem">Salt</li><li class="listitem">Juju</li></ul></div></div><div class="book" title="Build Management"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec04" class="calibre1"/>Build Management</h3></div></div></div><p class="calibre8">Build management is the process of preparing a build environment to assemble all the components of a software application as a finished, workable product, fit for its intended purpose. The source code, the compilers, dependencies with hardware and software components, and so on, are compiled to function as a cohesive unit. Builds are manual, on demand and automatic. On-demand automated builds reinitiate with a script to launch the build and are used in few cases. Scheduled automated builds are the case with continuous integration servers running nightly builds. Triggered automated builds in a continuous integration server are launched just after being committed to a Git repository.</p><p class="calibre8">As per DevOps, the benefits of build management processes and tools for an organization can be summarized as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The vital function of ensuring software is usable</li><li class="listitem">Ensures reusability and reliability of the software in client environments</li><li class="listitem">Increases the efficiency and quality of software</li><li class="listitem">It's also a regulatory requirement</li></ul></div><p class="calibre8">A few build tools that are in use are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Ant</li><li class="listitem">Buildr</li><li class="listitem">Maven</li><li class="listitem">Gradle</li><li class="listitem">Grunt</li><li class="listitem">MSbuild</li><li class="listitem">Visual Build</li><li class="listitem">Make (CMake/QMake)</li></ul></div></div><div class="book" title="Artifacts Repository Management"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec05" class="calibre1"/>Artifacts Repository Management</h3></div></div></div><p class="calibre8">A build Artifacts repository manager is a dedicated server for hosting multiple repositories of binary components (executables) of successful builds. By centralizing the management of diverse binary types, it reduces the complexity of access along with their dependencies.</p><p class="calibre8">The benefits are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Manage artifact life cycles</li><li class="listitem">Ensure builds are repeatable and reproducible</li><li class="listitem">Organized access to build artifacts</li><li class="listitem">Convenient to share builds across teams and vendors</li><li class="listitem">Retention policies based on artifacts for audit compliance</li><li class="listitem">High availability of artifacts with access controls</li></ul></div><p class="calibre8">A few repository tools that are in use are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Sonatype Nexus</li><li class="listitem">JFrog Artifactory</li><li class="listitem">Apache Archiva</li><li class="listitem">NuGet</li><li class="listitem">Docker hub</li><li class="listitem">Pulp</li><li class="listitem">Npm</li></ul></div></div><div class="book" title="Release Management"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec06" class="calibre1"/>Release Management</h3></div></div></div><p class="calibre8">Release management is the process of a software life cycle to facilitate a release's movement from development, testing, and deployment to support/maintenance. It interfaces with several other DevOps process areas in the SDLC.</p><p class="calibre8">Release management has been an integral part of the development process for decades. However, its inclusion into the DevOps framework makes a complete cycle for automation.</p><p class="calibre8">Release management is an iterative cycle initiating by a request for the addition of new features or changes to existing functionality. Once the change is approved, the new version is designed, built, tested, reviewed, and after acceptance, deployed to production. During the support phase, there could be a possibility of enhancement or performance leading to the initiation of a new development cycle.</p><p class="calibre8">The benefits of adopting release management are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Product life cycle holistic management, tracking and integrating every phase</li><li class="listitem">Orchestrate all the phase activities--development, version control, build, QA, systems provisioning, production deployment, and support</li><li class="listitem">Track the status of recent deployments in each of the environments</li><li class="listitem">Audit history of all activities of work items that are associated with each release</li><li class="listitem">The automation of release management relies on automating all of its stages</li><li class="listitem">Teams can author release definitions and automate deployment in repeatable, reliable ways while simultaneously tracking in-flight releases all the way to production</li><li class="listitem">Fine grain access control for authorized access and approval for change</li></ul></div><p class="calibre8">A few release management tools are:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Electric Cloud</li><li class="listitem">Octopus Deploy</li><li class="listitem">Continuum</li><li class="listitem">Automic</li><li class="listitem">Quikbuild</li><li class="listitem">UrbanCode Release</li><li class="listitem">CA Service Virtualization (LISA)</li><li class="listitem">BMC Release Process Management</li><li class="listitem">Plutora Release</li><li class="listitem">CA Release Automation</li><li class="listitem">Serena Release</li><li class="listitem">MS Visual Studio</li><li class="listitem">StackStorm</li><li class="listitem">Rally</li></ul></div></div><div class="book" title="Test Automation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec07" class="calibre1"/>Test Automation</h3></div></div></div><p class="calibre8">Testing manually for every possible scenario is tedious, labor intensive, time consuming and expensive. Test automation, or automatic testing, is for running test cases without manual intervention. Though not all test cases qualify to be automatically run, the majority can be scheduled. Automation is achieved by running the test cases with an automation tool or through the scheduling of automation scripts. Recent test data is used as input and the results are captured for analysis. The goal of test automation is to supplement manual testing by reducing the number of test cases to be run manually--not to replace manual testing all together.</p><p class="calibre8">Automation testing is for test cases that are repetitive, monotonous, tedious, and time consuming, that have defined input and boundary conditions. It's not suitable for frequently changing, ad hoc or first time execution test cases. Software automation testing can be based on a few types of frameworks data; keyword, modular, and hybrid.</p><p class="calibre8">Testing big data systems encompasses multiple technologies, integrations, frameworks and testing modules such as functional, security, usability, performance, integration testing, and so on.</p><p class="calibre8">The benefits of adopting test automation are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Improve software quality and responsiveness</li><li class="listitem">Quick turnaround by substituting manual effort with automation</li><li class="listitem">Improve the effectiveness of the overall testing life cycle</li><li class="listitem">Incremental and integration testing for continuous integration and delivery</li></ul></div><p class="calibre8">A few test automation tools are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Visual Studio Test Professional</li><li class="listitem">QTP (UFT)</li><li class="listitem">SoapUI</li><li class="listitem">TestDrive</li><li class="listitem">FitNesse</li><li class="listitem">Telerik Test Studio</li><li class="listitem">Selenium</li><li class="listitem">TestComplete</li><li class="listitem">Watir</li><li class="listitem">Robotium</li></ul></div></div><div class="book" title="Continuous Integration"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec08" class="calibre1"/>Continuous Integration</h3></div></div></div><p class="calibre8">Continuous integration is a DevOps best practice wherein developers continuously integrate their code in small logical units to a common shared repository with regularity (for example, once a day). The advantage of such a process is the transparency of the code's quality and fitness for its intended purpose. Otherwise, bulk code integration after the lapse of a fixed time period could expose many defects or integration challenges which could be expensive to resolve.</p><p class="calibre8">To achieve continuous integration, there are few prerequisites to be implemented, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Using a version repository for source code</li><li class="listitem">Regular code check in schedule</li><li class="listitem">Automate testing for the code changes</li><li class="listitem">Automate the build</li><li class="listitem">Deploy build in preproduction</li></ul></div><p class="calibre8">The benefits of continuous integration are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Availability of latest code as we commit early and often</li><li class="listitem">Build cycles are faster as build issues are exposed early with check-ins</li><li class="listitem">Transparency in the build process means better ownership and lesser defects</li><li class="listitem">Automating the deployment process leads to quicker turnaround</li></ul></div><p class="calibre8">Some continuous integration tools that are available are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Jenkins</li><li class="listitem">TeamCity</li><li class="listitem">Travis</li><li class="listitem">Go CD</li><li class="listitem">Buddy</li><li class="listitem">Bitbucket</li><li class="listitem">Chef</li><li class="listitem">Microsoft Teamcenter</li><li class="listitem">CruiseControl</li><li class="listitem">Bamboo</li><li class="listitem">GitLab CI</li><li class="listitem">CircleCI</li><li class="listitem">Codeship</li></ul></div><p class="calibre8">The following figure represents the roles of continuous integration, delivery, and deployment:</p><div class="mediaobject"><img src="../images/00005.jpeg" alt="Continuous Integration" class="calibre10"/></div><p class="calibre11"> </p></div><div class="book" title="Continuous Delivery"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec09" class="calibre1"/>Continuous Delivery</h3></div></div></div><p class="calibre8">Continuous delivery is the next step of continuous integration in the software development cycle; it enables rapid and reliable development of software and delivery of product with the least amount of manual effort or overhead. In continuous integration, as we have seen, code is developed incorporating reviews, followed by automated building and testing. In continuous delivery, the product is moved to the preproduction (staging) environment in small frequent units to thoroughly test for user acceptance. The focus is on understanding the performance of the features and functionality related issues of the software. This enables issues related to business logic to be found early in the development cycle, ensuring that these issues are addressed before moving ahead to other phases such as deployment to the production environment or the addition of new features. Continuous delivery provides greater reliability and predictability on the usability of the intended features of the product for the developers. With continuous delivery, your software is always ready to release and the final deployment into production is a manual step as per timings based on a business decision.</p><p class="calibre8">The benefits of the continuous delivery process are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Developed code is continuously delivered</li><li class="listitem">Code is constantly and regularly reviewed</li><li class="listitem">High-quality software is deployed rapidly, reliably, and repeatedly</li><li class="listitem">Maximum automation and minimal manual overhead</li></ul></div><p class="calibre8">The tools that perform continuous integration do the job of continuous delivery as well.</p></div><div class="book" title="Continuous Deployment"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec10" class="calibre1"/>Continuous Deployment</h3></div></div></div><p class="calibre8">Continuous deployment is the fully matured and complete process cycle of code change, passing through every phase of the software life cycle to be deployed to production environments.</p><p class="calibre8">Continuous deployment requires the entire process to be automated--also termed as automated application release--through all stages, such as the packaging of the application, ensuring the dependencies are integrated, deployment testing, and the production of adequate documentation for compliance.</p><p class="calibre8">The benefits of continuous deployment and automated application release are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Frequent product releases deliver software as fast as possible</li><li class="listitem">Automated and accelerated product releases with the code change</li><li class="listitem">Code changes qualify for production both from a technical and quality view point</li><li class="listitem">The most current version of the product is ready in shippable format</li><li class="listitem">Deployment modeling reduces errors, resulting in better product quality</li><li class="listitem">Consolidated access to all tools, process and resource data leads to quicker troubleshooting and time to market</li><li class="listitem">Effective collaboration between dev, QA, and operation teams leads to higher output and better customer satisfaction</li><li class="listitem">Facilitates lower audit efforts owing to a centralized view of all phase activities</li></ul></div></div><div class="book" title="Infrastructure as Code"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec11" class="calibre1"/>Infrastructure as Code</h3></div></div></div><p class="calibre8">
<span class="strong"><strong class="calibre2">Infrastructure as Code</strong></span> (<span class="strong"><strong class="calibre2">IaC</strong></span>) is a means to perform infrastructure services through the defining of configuration files. In DevOps' scope, IaC is the automation of routine tasks through code, typically as configuration definition files, such as shell scripts, Ansible playbooks, Chef recipes, or Puppet manifests. It's usually a server and client setup with push or pull-based mechanisms, or agentless through <span class="strong"><strong class="calibre2">secured shell</strong></span> (<span class="strong"><strong class="calibre2">SSH</strong></span>). Many regular tasks on systems such as create, start, stop, delete, terminate, and restarting virtual or bare-metal machines are performed through software. In traditional on-premise systems, many of the system administrative tasks were manual and person dependent. However, with the explosion of big data with cloud computing, all the regular system activities and tasks are managed like any software code. They are maintained in code repositories, and the latest build updates are tested for deployment.</p><p class="calibre8">The advantages of IaC are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The use of definition files and code to update system configuration is quick</li><li class="listitem">The version of all the code and changes is less error prone and has reproducible results</li><li class="listitem">Thorough testing of the deployment with IaC and test systems</li><li class="listitem">Smaller regular changes are easy to manage, bigger infrastructure updates are likely to contain errors that are difficult to detect</li><li class="listitem">Audit tracking and compliance are easy with definition files</li><li class="listitem">Multiple servers update simultaneously</li><li class="listitem">System availability is high, with less down time</li><li class="listitem">Some tools for IaC are as follows:</li><li class="listitem">Ansible tower</li><li class="listitem">CFEngine</li><li class="listitem">Chef</li><li class="listitem">Puppet</li><li class="listitem">SaltStack</li></ul></div></div><div class="book" title="Routine Automation"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec12" class="calibre1"/>Routine Automation</h3></div></div></div><p class="calibre8">Every organization aims to automate routine, repetitive tasks; in fact the survival of most companies and software products is based on the degree to which they automate. ERP systems, data visualization, domain applications, data analytics, and so on; almost all segments are potential areas for automation. A few sections to automate are infrastructure (deployment, patching scalability), applications (development, integration, builds, delivery, and deployment), load balancers, feedback, and defects/errors management.</p></div><div class="book" title="Key Application Performance Monitoring/Indicators"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec13" class="calibre1"/>Key Application Performance Monitoring/Indicators</h3></div></div></div><p class="calibre8">Performance metrics are part of every tool, product and service. Accordingly, organizations are ever vigilant of the performance metrics monitoring of their applications, products and services. To achieve high-quality output for any product, achieving a high degree of standard in process and metrics is prerequisite. There are many parameters to gauge performance metrics, such as, for example, applications or hardware systems availability or uptime versus downtime and responsiveness, tickets categorization, acknowledgement, resolution time lines, and so on.</p><p class="calibre8">DevOps is all about measuring the metrics and feedback, with continuous improvement processes.</p><p class="calibre8">Several tools are available for application monitoring for various needs; we will cover the most appropriate and applicable tools in the context of the DevOps framework in further sections of this lesson.</p></div></div></div>

<div class="book" title="DevOps Frameworks"><div class="book" id="F8902-9e1d43bf5c22491b83b15944fc98f0e3"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec13" class="calibre1"/>DevOps Frameworks</h1></div></div></div><p class="calibre8">Under DevOps frameworks we will study the life cycle models, maturity states, progression and best practices frameworks, as well as agile methodology.</p><p class="calibre8">Accomplishing DevOps maturity is a gradual progression to being well structured and planned, as stated in the following stages:</p></div>

<div class="book" title="DevOps Frameworks">
<div class="book" title="DevOps Maturity Life Cycle"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec07" class="calibre1"/>DevOps Maturity Life Cycle</h2></div></div></div><p class="calibre8">DevOps project phases are on lines of the software development life cycle as described here. We will dwell on each phase in detail:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre2">Discovery and requirements phase</strong></span>: The DevOps discovery phase is a highly interactive project phase for gathering inputs and feedback on the current state of process, frameworks and tools from key stakeholders. Templates and checklists are used to capture the inputs. The timeline for the phase depends on the availability of key stakeholders, the existence of requisite documents, and the complexity of the processes to explore. Discovery phase deliverables are as follows:<div class="book"><ul class="itemizedlist1"><li class="listitem">Templates detailing the current state of process, tools, frameworks</li><li class="listitem">Signoff from key stakeholders on the details collated</li><li class="listitem">Existing best practices and DevOps methods</li><li class="listitem">Existing challenges, constraints as applicable</li><li class="listitem">Reusable tools, process, artifacts</li></ul></div></li><li class="listitem"><span class="strong"><strong class="calibre2">Design print phase</strong></span>: The design phase is also the architecture phase; it's about producing a blueprint of the target state to accomplish. It's an iterative process of weighing alternatives for tools, and processes arriving at agreement by key stakeholders. The timeline and cost will be base lined and revisited and revised regularly based on new learnings from the project as we move forward towards the target state. The timeline for this phase depends on how acceptable the processes, tools, and budgets are to the key stakeholders. Design phase deliverables are as follows:<div class="book"><ul class="itemizedlist1"><li class="listitem">Target state is agreed upon</li><li class="listitem">Baseline of DevOps process to be adopted</li><li class="listitem">Baseline of most viable tools to be implemented</li><li class="listitem">Baseline agreed timelines and cost</li></ul></div></li><li class="listitem"><span class="strong"><strong class="calibre2">Development phase</strong></span>: Artifacts base lined from the blueprint phase will be inputs for the development phase; the agreed upon process changes, tools to be implemented, frameworks to be adopted, and so on. A detailed project plan covering deliverables, schedules, dependencies, constraints, resource leveling, and so on will be quite handy. Agile scrum methodology will be the framework to implement the DevOps, which will be discussed in detail. The timeline for the development phase will be as per the project plan base lined initially, and revised regularly with the progress of milestones that have been accomplished. Development phase deliverables are as follows:<div class="book"><ul class="itemizedlist1"><li class="listitem">Initial project plan base lined and signoff</li><li class="listitem">Incorporating regular feedback till project completion</li><li class="listitem">Allocation of resources for each stage</li><li class="listitem">Including new skills, methods, process, and tools</li><li class="listitem">Work arounds for project risks, constraints, and so on</li><li class="listitem">Deliverables as agreed in the project plan</li></ul></div></li><li class="listitem"><span class="strong"><strong class="calibre2">Deployment phase</strong></span>: The DevOps deployment phase is in accordance with the best practices outlined in the DevOps process framework detailed above. It depends on whether the deployment is a process, an application tool, or for infrastructure. The timeline will be evaluated as per experience gained in the development phase. Deployment phase deliverables are as follows:<div class="book"><ul class="itemizedlist1"><li class="listitem">Deployment guide--cutover plan to production</li><li class="listitem">Deployment checklist</li><li class="listitem">Signoff from key stakeholders</li><li class="listitem">Rollback plan</li><li class="listitem">Capacity planning</li></ul></div></li><li class="listitem"><span class="strong"><strong class="calibre2">Monitoring phase</strong></span>: Monitors the key performance factors for each phase's performance of development, build, integration and deployment over time duration. It's followed by tracking the defects, bug fixes, user tickets and plans for continuous improvement. Monitoring phase timelines are as per organization need and performance benchmarks. Monitoring phase deliverables are as follows:<div class="book"><ul class="itemizedlist1"><li class="listitem">Operations manual</li><li class="listitem">Feedback forms and checklists</li><li class="listitem">User guide, support manual</li><li class="listitem">Process flow manual</li><li class="listitem">Performance benchmark</li></ul></div></li></ul></div></div></div>

<div class="book" title="DevOps Frameworks">
<div class="book" title="DevOps Maturity Map"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec08" class="calibre1"/>DevOps Maturity Map</h2></div></div></div><p class="calibre8">DevOps adoption is a value-added journey for an organization. It's not something achieved overnight quickly, but matured step by step over a period of time with manifested results. Like any Capability Maturity Model (CMMI) or Process Maturity Models, the critical success factors are to be defined for the program's performance objectives. The initial maturity state of key evaluation parameters is agreed upon by key stakeholders. Then the target maturity level of the parameter variables to be accomplished will be defined in the project charter, along with detailed procedure, milestones, budgets and constraints as approved by stakeholders.</p><div class="mediaobject"><img src="../images/00006.jpeg" alt="DevOps Maturity Map" class="calibre10"/><div class="caption"><p class="calibre13">DevOps process maturity framework.</p></div></div><p class="calibre11"> </p></div></div>

<div class="book" title="DevOps Frameworks">
<div class="book" title="DevOps Progression Framework/Readiness Model"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec09" class="calibre1"/>DevOps Progression Framework/Readiness Model</h2></div></div></div><p class="calibre8">As discussed in the previous model, DevOps adoption is a journey for an organization to higher maturity states. In the following table, different practice areas and maturity levels of DevOps at a broad scale are listed. DevOps maturity levels may vary across teams as per their standards, similarly even a common department or division of the same organization may have significantly more varied and advanced practices than others for the same process flow. Enhancing to achieve the best possible DevOps process workflow throughout the entire enterprise should be the end goal for all teams and departments.</p><div class="mediaobject"><img src="../images/00007.jpeg" alt="DevOps Progression Framework/Readiness Model" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="DevOps Frameworks">
<div class="book" title="DevOps Maturity Checklists"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec10" class="calibre1"/>DevOps Maturity Checklists</h2></div></div></div><p class="calibre8">The process maturity framework, as seen in the preceding sections, is assessed with checklists and discussions. For each of the key focus areas, the detailed findings will indicate the maturity levels.</p><p class="calibre8">The findings provide a general estimate of the maturity level and the impact it is causing:</p><div class="mediaobject"><img src="../images/00008.jpeg" alt="DevOps Maturity Checklists" class="calibre10"/></div><p class="calibre11"> </p><div class="mediaobject"><img src="../images/00009.jpeg" alt="DevOps Maturity Checklists" class="calibre10"/></div><p class="calibre11"> </p><div class="mediaobject"><img src="../images/00010.jpeg" alt="DevOps Maturity Checklists" class="calibre10"/></div><p class="calibre11"> </p><div class="mediaobject"><img src="../images/00011.jpeg" alt="DevOps Maturity Checklists" class="calibre10"/></div><p class="calibre11"> </p><div class="mediaobject"><img src="../images/00012.jpeg" alt="DevOps Maturity Checklists" class="calibre10"/></div><p class="calibre11"> </p><div class="mediaobject"><img src="../images/00013.jpeg" alt="DevOps Maturity Checklists" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="DevOps Frameworks">
<div class="book" title="Agile Framework for DevOps Process Projects"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec11" class="calibre1"/>Agile Framework for DevOps Process Projects</h2></div></div></div><p class="calibre8">DevOps projects are typically Agile-framework based, for the effective and quick turnaround of the development and implementation process cycle.</p><p class="calibre8">Agile software development-based projects have become widely accepted and adopted across the industry. The traditional waterfall model is outdated and unable to keep up with the advantages offered by agile methodology.</p><p class="calibre8">Agile methodology owes its success to its core objectives such as:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Individuals and interactions are valued over process and tools</li><li class="listitem">Working software is valued over comprehensive documentation</li><li class="listitem">Customer collaboration is valued over contract negotiation</li><li class="listitem">Change adoption agility is valued over project plan adherence</li></ul></div><div class="book" title="Agile Ways of Development"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch02lvl3sec14" class="calibre1"/>Agile Ways of Development</h3></div></div></div><p class="calibre8">Scrum is the agile development methodology, focused on features development, from a team comprising of roles such as the following:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The scrum master is responsible for team setup, conducting sprint meetings, and removing development obstacles</li><li class="listitem">The product owner creates and prioritizes product backlog, and is responsible for the delivery of the functionality at each sprint iteration cycle</li><li class="listitem">The scrum team manages and organizes the work to complete in the sprint cycle</li><li class="listitem">The product backlog is the list of features and requirements of functionality to be developed</li></ul></div><p class="calibre8">The Agile method of development is an incremental and iterative approach for developing user stories, software features or functionality. Customers can see the product features early and make necessary changes, if needed. The development cycle is broken into sprint cycles of two to four weeks, to accomplish units of work. The idea is that smaller cycles can be developed and managed quickly with a team of developers and testers together. The structure and documentation are not important but a working feature of the code is considered valuable. The development process is iteratively accomplished in successive sprint cycles. Bugs identified are fixed at the earliest sprint with successful testing. Regression testing is performed when new functions or logic are developed. User acceptance tests are performed after the sprint cycle to flag the product for release:</p><div class="mediaobject"><img src="../images/00014.jpeg" alt="Agile Ways of Development" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre8">The benefits of adopting the best practices of agile software development are as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Working software makes the customer satisfied, as he can view the features</li><li class="listitem">Customers can add change requests at any phase of development</li><li class="listitem">Quick and continuous delivery of software in weeks</li><li class="listitem">Projects are built around motivated individuals, who should be trusted</li><li class="listitem">Sprint teams are highly skilled and efficient in delivery</li><li class="listitem">Since developers and testers codevelop, bugs are solved within sprint</li><li class="listitem">The communication mode is effective so quality of product delivered is higher</li><li class="listitem">Continuous attention to technical excellence leads to good design</li><li class="listitem">Self-organizing teams focus on optimal architectures, requirements, and designs</li><li class="listitem">The team is lean and effective, so productivity is maximized</li></ul></div></div></div></div>
<div class="book" title="Summary" id="G6PI1-9e1d43bf5c22491b83b15944fc98f0e3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this lesson, we understood the application of DevOps processes, frameworks, best practices, and DevOps process maturity frameworks and progression models with checklist templates. We also looked into agile terminology and methodology.</p><p class="calibre8">In this next lesson, we will learn about implementing DevOps core process.</p></div>
<div class="book" title="Assessments" id="H5A41-9e1d43bf5c22491b83b15944fc98f0e3"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Assessments</h1></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Which among the following DevOps processes offers robust integration and automation?<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Source code management</li><li class="listitem" value="2">Code review</li><li class="listitem" value="3">Configuration management</li><li class="listitem" value="4">Build management</li></ol><div class="calibre12"/></div></li><li class="listitem" value="2">Which of the following are proprietary tools for code review automation?<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Git</li><li class="listitem" value="2">SCCS</li><li class="listitem" value="3">Crucible</li><li class="listitem" value="4">SVN</li></ol><div class="calibre12"/></div></li><li class="listitem" value="3">Which among the following are benefits of artifacts repository management?<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Ensures reusability and reliability of the software in client environments</li><li class="listitem" value="2">Ensure builds are repeatable and reproducible</li><li class="listitem" value="3">Track the status of recent deployments in each of the environments</li><li class="listitem" value="4">Audit history of all activities of work items that are associated with each release</li></ol><div class="calibre12"/></div></li><li class="listitem" value="4">Which of the following is a deliverable of the discovery phase in DevOps maturity life cycle?<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Baseline of most viable tools to be implemented</li><li class="listitem" value="2">Baseline agreed timelines and cost</li><li class="listitem" value="3">Reusable tools, process, and artifacts</li><li class="listitem" value="4">Baseline of DevOps process to be adopted</li></ol><div class="calibre12"/></div></li><li class="listitem" value="5">The _________ is responsible for team setup, conducting sprint meetings, and removing development obstacles.<div class="book"><ol class="orderedlist1"><li class="listitem" value="1">Scrum master</li><li class="listitem" value="2">Product owner</li><li class="listitem" value="3">Customer</li><li class="listitem" value="4">Scrum team</li></ol><div class="calibre12"/></div></li></ol><div class="calibre12"/></div></div></body></html>