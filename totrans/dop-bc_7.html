<html><head></head><body>
        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Orchestration - End-to-End Automation</h1>
            

            <article>
                
<div class="packtquote1">"The key to following the continuous delivery path is to continually question your own assumptions about what's possible."<br class="title-page-name"/>
<span>                                                                                                                   - Jeff Sussna</span></div>
<p class="calibre2">In this chapter, we will discuss different ways to automate application life cycle management, using orchestration available via open source and commercial alternatives.</p>
<p class="calibre2">We will be using Jenkins plugins and Visual Studio Team Services tasks to orchestrate and automate all the activities that are performed during application life cycle management.</p>
<p class="calibre2">We will cover the following topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">End-to-end automation orchestration of application life cycle management using Jenkins</li>
<li class="calibre11">End-to-end automation using Jenkins, Chef, and AWS EC2</li>
<li class="calibre11">End-to-end automation using Jenkins and AWS Elastic Beanstalk</li>
<li class="calibre11">End-to-end automation using Jenkins and Microsoft Azure app services</li>
<li class="calibre11">End-to-end automation orchestration of application life cycle management using VSTS</li>
</ul>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">End-to-end automation of application life cycle management using Jenkins</h1>
            

            <article>
                
<p class="calibre2">In <a href="part0047.html#1CQAE0-651ea628c0544d18a4415dfef8fe6271" target="_blank" class="calibre4"><span>Chapter 2</span></a>, <em class="calibre12">Continous Integration</em>, we created a build job that performs the following tasks:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Static code analysis of the PetClinic web application:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border72" src="../images/00194.jpeg"/></div>
<ol start="2" class="calibre17">
<li class="calibre11" value="2">Successful execution of static code analysis will show a URL pointing to the SonaQube dashboard for a specific project in Jenkins dashboard.</li>
</ol>
<ol start="3" class="calibre17">
<li class="calibre11" value="3">Verification of the Jenkins dashboard with all the analysis details:</li>
</ol>
<ol start="3" class="calibre17"/>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00206.jpeg"/></div>
<ol start="4" class="calibre17">
<li value="4" class="calibre11">Compilation of source files and unit test execution:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border73" src="../images/00295.jpeg"/></div>
<ol start="5" class="calibre17">
<li class="calibre11" value="5">Unit test results will be available in the Jenkins project dashboard itself.</li>
</ol>
<ol start="6" class="calibre17">
<li class="calibre11" value="6">Creation of package files:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00298.jpeg"/></div>
<p class="calibre2">Once our package file is ready we can deploy it in the AWSEC2 instance, Microsoft Azure Virtual Machine, AWS Elastic Beanstalk, Microsoft Azure App Services, containers, or any physical machine that is accessible from the system that Jenkins is installed on.</p>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">End-to-end automation using Jenkins, Chef, and AWS EC2</h1>
            

            <article>
                
<p class="calibre2">In this section, we will orchestrate different tasks using the <span>Build Pipeline</span> plugin available in Jenkins.</p>
<p class="calibre2">In <a href="part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271" target="_blank" class="calibre4"><span>Chapter 4</span></a>, <em class="calibre12">Cloud Computing and Configuration Management</em>, we installed a Chef workstation, configured the hosted Chef account, and installed knife plugins for AWS and Microsoft Azure.</p>
<p class="calibre2">We created an instance in AWS EC2 using the following command:</p>
<pre class="calibre26">
<strong class="calibre1">[root@devops1 Desktop]# knife ec2 server create -I ami-1ecae776 -f t2.micro -N DevOpsVMonAWS --aws-access-key-id '&lt; Your Access Key ID &gt;' --aws-secret-access-key '&lt; Your Secret Access Key &gt;' -S book --identity-file book.pem --ssh-user ec2-user -r role[v-tomcat]</strong>  
</pre>
<p class="calibre2">We created a virtual machine in Microsoft Azure using the following command:</p>
<pre class="calibre26">
<strong class="calibre1">[root@devops1 Desktop]# knife azure server create --azure-dns-name 'distechnodemo' --azure-vm-name 'dtserver02' --azure-vm-size 'Small' -N DevOpsVMonAzure2 --azure-storage-account 'classicstorage9883' --bootstrap-protocol 'cloud-api' --azure-source-image '5112500ae3b842c8b9c604889f8753c3__OpenLogic-CentOS-67-20160310' --azure-service-location 'Central US' --ssh-user 'dtechno' --ssh-password 'cloud@321' -r role[v-tomcat] --ssh-port 22</strong>  
</pre>
<p class="calibre2">We verified the AWS EC2 instance and Microsoft Azure Virtual Machine registration in the hosted Chef.</p>
<p class="calibre2">We executed both the commands from the command prompt. In Jenkins, we can execute commands for Windows, Linux, or Mac. We can execute the same commands from a Jenkins build job by creating a freestyle job.</p>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Configuring SSH authentication using a key</h1>
            

            <article>
                
<p class="calibre2">A Chef workstation installed on a virtual machine is accessible from a system where we have installed Jenkins. We can create a virtual machine using a virtual box or a VMware workstation on a laptop; and can also then install CentOS 6 or 7 and configure the Chef workstation the way we did in <a href="part0067.html#1VSLM0-651ea628c0544d18a4415dfef8fe6271" target="_blank" class="calibre4"><span>Chapter 4</span></a>, <em class="calibre12">Cloud Computing and Configuration Management</em>.</p>
<p class="calibre2">Before starting with the configuration of end-to-end automation and orchestration using a build pipeline plugin and upstream/downstream jobs, we will configure SSH authentication using a key.</p>
<p class="calibre2">The main objective behind configuring SSH authentication is to allow the Jenkins virtual machine to connect to the Chef workstation virtual machine. By doing this we can execute commands from the Jenkins machine on the Chef workstation. This way we can create an instance in AWS or the Azure cloud using the Chef workstation, and install a runtime environment on it to deploy the PetClinic application:</p>
<div class="CDPAlignCenter"><img class="alignnone27" src="../images/00002.jpeg"/></div>
<p class="calibre2">If we try to access the Chef workstation from Jenkins, it won't work, as we still need to configure a password-free configuration, because in the Jenkins job execution we can't wait in the middle of a flow to give a password. Let's configure password-free access on Jenkins to access the Chef workstation:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Open a terminal in a virtual machine where Jenkins is installed. Use <kbd class="calibre15">ssh-keygen</kbd> to create a new key:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border74" src="../images/00016.jpeg"/></div>
<ol start="2" class="calibre17">
<li value="2" class="calibre11">Verify the key on the local filesystem.</li>
<li value="3" class="calibre11">Copy the key to the remote host where the Chef workstation is configured using <kbd class="calibre15">ssh-copy-id</kbd>:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border75" src="../images/00075.jpeg"/></div>
<ol start="4" class="calibre17">
<li value="4" class="calibre11">Now try to access the Chef workstation VM using the Jenkins build job by executing commands from <kbd class="calibre15">execute</kbd> shell commands.</li>
<li value="5" class="calibre11">If it fails, then try to access the Chef workstation from the Jenkins VM using the Terminal. If you get the <span>Agent admitted failure to sign using key</span> message, then execute the <kbd class="calibre15">ssh-add</kbd> command to fix the issue.</li>
<li value="6" class="calibre11">Once the connection is successful in the Terminal, execute the <kbd class="calibre15">ifconfig</kbd> command to find the IP address so that we find out on which virtual machine that command is executed:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border76" src="../images/00312.jpeg"/></div>
<ol start="7" class="calibre17">
<li value="7" class="calibre11">At this stage, our SSH connection is successful using a key that we created and configured instead of a password.</li>
<li value="8" class="calibre11">Now we have access to the Chef workstation from Jenkins' VM so we can execute knife commands from Jenkins on the Chef workstation. Our next goal is to try to create an instance in AWS using the Jenkins build job and the Chef workstation.</li>
<li value="9" class="calibre11">In a Jenkins build job, add a <span>Build</span> step, select <span>Execute shell</span>, and add the command shown here. We have already discussed <kbd class="calibre15">knife ec2</kbd> commands:</li>
</ol>
<pre class="calibre26">
<strong class="calibre1">        ssh -t -t root@192.168.1.36 "ifconfig; rvm use <br class="title-page-name"/>        2.1.0; knife ec2 server create -I ami-1ecae776 -f <br class="title-page-name"/>        t2.micro -N DevOpsVMonAWS1 --aws-access-key-id <br class="title-page-name"/>        '&lt;YOUR ACCESS KEY ID&gt;' --aws-secret-access-key <br class="title-page-name"/>        '&lt;YOUR SECRET ACCESS KEY&gt;' -S book --identity-file <br class="title-page-name"/>        book.pem --ssh-user ec2-user -r role[v-tomcat]"</strong>  
</pre>
<div class="CDPAlignCenter"><img class="image-border77" src="../images/00042.jpeg"/></div>
<ol start="10" class="calibre17">
<li value="10" class="calibre11">Replace the Access Key ID and Secret Access Key with your own. Click on <span>Save</span>. Click on the <span>Build now</span> link to execute the build job.</li>
</ol>
<ol start="11" class="calibre17">
<li value="11" class="calibre11">Go to <span>Console Output</span> to check the progress:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00182.jpeg"/></div>
<ol start="12" class="calibre17">
<li value="12" class="calibre11">Inspect the logs; AWS instance creation has started.</li>
<li value="13" class="calibre11">Verify it in the AWS management console:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00200.jpeg"/></div>
<ol start="14" class="calibre17">
<li value="14" class="calibre11">Before execution can go further, check whether the AWS security group has an entry for SSH access:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00211.jpeg"/></div>
<ol start="15" class="calibre17">
<li value="15" class="calibre11">Once SSH access is available, it will start the Chef client installations.</li>
<li value="16" class="calibre11">In our case, it will start downloading the Chef client and installing it on the AWS instance that we have created using the Chef workstation:</li>
<li value="17" class="calibre11">Verify the Chef installation process on the console. Once the Chef client is installed on the AWS instance, it will start its first Chef client execution.</li>
<li value="18" class="calibre11">Observe the run list and synchronizing cookbooks. It will converge and start installing packages.</li>
<li value="19" class="calibre11">Verify the package installations.</li>
<li value="20" class="calibre11">It will also display <kbd class="calibre15">conf.xml</kbd>, where port-related details can be verified based on the configuration.</li>
</ol>
<ol start="21" class="calibre17">
<li value="21" class="calibre11">Once the package installation is finished, it will start service management.</li>
<li value="22" class="calibre11">Now, the Chef client execution has finished, and it will display related information for the AWS instance we created:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border78" src="../images/00187.jpeg"/></div>
<ol start="23" class="calibre17">
<li value="23" class="calibre11">Check the AWS management console for the successful status.</li>
<li value="24" class="calibre11">Verify the hosted Chef for the registered nodes:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00015.jpeg"/></div>
<p class="calibre2">At this stage, we have an AWS instance ready that has Tomcat and Java installed so we can deploy our application easily. Now, we have all the resources ready to configure the build pipeline:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Go to <span>PetClinic-Code</span> job and select <span>Build other projects</span> from add <span>Post-build Actions</span>.</li>
</ol>
<ol start="2" class="calibre17">
<li value="2" class="calibre11">Enter <span>PetClinic</span> in <span>Projects to build</span>:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00021.jpeg"/></div>
<ol start="3" class="calibre17">
<li class="calibre11" value="3">Here <span>PetClinic-Code</span> becomes an upstream project for PetClinic and PetClinic becomes a downstream project for <span>PetClinic-Code</span>. The <span>Build Pipeline</span> plugin needs relations established, using upstream and downstream projects for visualization.</li>
<li class="calibre11" value="4">Go to the <span>PetClinic-Code</span> job and select <span>Build other projects</span> from <span>Add Post-build Actions</span>.</li>
</ol>
<ol start="5" class="calibre17">
<li class="calibre11" value="5">Enter <span>PetClinic-CloudProvisioning</span> in <span>Projects to build</span>:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00032.jpeg"/></div>
<ol start="6" class="calibre17">
<li class="calibre11" value="6">If this build job has executed successfully, then it means the deployed virtual machine is ready with an installed runtime environment.</li>
<li class="calibre11" value="7">Go to the <span>PetClinic-CloudProvisioning</span> job and select <span>Build other projects</span> from <span>Add Post-build Actions</span>.</li>
</ol>
<ol start="8" class="calibre17">
<li class="calibre11" value="8">Enter <span>PetClinic-Deploy</span> in <span>Projects to build</span>:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00089.jpeg"/></div>
<ol start="9" class="calibre17">
<li value="9" class="calibre11">Once the artifact copy operation has verified, configure the build job so we can deploy it as a manual operation. We will create a job with the <span>String Parameter</span> of a newly created instance's domain name or IP address:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border79" src="../images/00057.jpeg"/></div>
<ol start="10" class="calibre17">
<li value="10" class="calibre11">Configure the build job to execute deployment of a WAR file in an AWS instance by executing the following commands:</li>
</ol>
<pre class="calibre26">
<strong class="calibre1">        ssh -i /home/mitesh/book.pem -o <br class="title-page-name"/>        StrictHostKeyChecking=no -t -t ec2-user@$AWSDNS <br class="title-page-name"/>        "sudousermod -a -G tomcat ec2-user; sudochmod -R <br class="title-page-name"/>        g+w /var/lib/tomcat6/webapps; sudo service tomcat6 <br class="title-page-name"/>        stop;"</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        scp -i /home/mitesh/book.pem <br class="title-page-name"/>        /home/mitesh/target/*.war ec2-<br class="title-page-name"/>        user@$AWSDNS:/var/lib/tomcat6/webapps</strong><br class="title-page-name"/><br class="title-page-name"/><strong class="calibre1">        ssh -i /home/mitesh/book.pem -o <br class="title-page-name"/>        StrictHostKeyChecking=no -t -t ec2-user@$AWSDNS <br class="title-page-name"/>        "sudo service tomcat6 start"</strong>
</pre>
<ol start="11" class="calibre17">
<li value="11" class="calibre11">Execute this command from the <span>Execute shell</span> commands section in the Jenkins build job:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00173.jpeg"/></div>
<ol start="12" class="calibre17">
<li class="calibre11" value="12">Once this build job ha executed successfully, it means that the application deployment is successful, so we can perform a functional test.</li>
<li class="calibre11" value="13">Configure promotion on the <span>PetClinic-FuncTest</span> build using the <span>Promotion</span> plugin:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00188.jpeg"/></div>
<ol start="14" class="calibre17">
<li value="14" class="calibre11">After execution of <span>PetClinic-FuncTest</span>, our pipeline ends:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00094.jpeg"/></div>
<ol start="15" class="calibre17">
<li value="15" class="calibre11">Save PetClinic-FuncTest and verify the upstream projects.</li>
<li value="16" class="calibre11">Install a <span>Build Pipeline</span> plugin from <span>Manage Jenkins</span> | <span>Manage Plugins</span>.</li>
<li value="17" class="calibre11">On the <span>Jenkins</span> Dashboard, click on the <span>+</span> sign.</li>
<li value="18" class="calibre11">Provide a <span>View name</span>:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00215.jpeg"/></div>
<ol start="19" class="calibre17">
<li class="calibre11" value="19"><span>Select Initial Job</span> in the Upstream / downstream config:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00116.jpeg"/></div>
<ol start="20" class="calibre17">
<li value="20" class="calibre11">Click on <span>Run</span> to execute. Make sure that Tomcat and Sonar, which are configured in Jenkins, are running.</li>
<li value="21" class="calibre11">We have configured <span>PetClinic-Deploy</span> as a downstream project in <span>Build other projects</span> (manual step). We have defined the parameters too:</li>
</ol>
<div class="packtfigure"><img class="image-border6" src="../images/00306.jpeg"/></div>
<div class="packtfigure">Fig: Build pipeline for end-to-end automation of application life cycle management</div>
<ol start="22" class="calibre17">
<li value="22" class="calibre11">Verify the parameter symbol:</li>
</ol>
<div class="packtfigure"><img class="image-border6" src="../images/00008.jpeg"/></div>
<div class="packtfigure">Fig: Build pipeline with parameterized job</div>
<ol start="23" class="calibre17">
<li value="23" class="calibre11">Once the <span>PetClinic-CloudProvisioning</span> project has completed successfully, note the domain name and provide it as a default parameter in the <span>PetClinic-Deploy</span> project.</li>
<li value="24" class="calibre11">Click on <span>Trigger</span>:</li>
</ol>
<div class="packtfigure"><img class="image-border6" src="../images/00041.jpeg"/></div>
<div class="packtfigure">Fig: Build pipeline with manual trigger</div>
<ol start="25" class="calibre17">
<li value="25" class="calibre11">Verify the end-to-end build pipeline execution.</li>
</ol>
<p class="calibre2">So, with the use of the <span>Build Pipeline</span> plugin we can orchestrate the automation of different activities.</p>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">End-to-end automation using Jenkins and AWS Elastic Beanstalk</h1>
            

            <article>
                
<p class="calibre2">To deploy the PetClinic Spring application in Amazon Elastic Beanstalk (PaaS), we need the following flow:</p>
<div class="CDPAlignCenter"><img class="image-border80" src="../images/00166.jpeg"/></div>
<p class="calibre2">We have <span>PetClinic-Code</span>, <span>PetClinic</span>, and <span>PetClinic-Deploy-ElasticBeanstalk</span> build jobs that we have created in this chapter.</p>
<p class="calibre2">Configure <span>PetClinic</span> as a downstream job for <span>PetClinic-Code</span>; and configure <span>PetClinic-Deploy-ElasticBeanstalk</span> as a downstream job for the <span>PetClinic</span> build job.</p>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">End-to end aautomation using Jenkins and Microsoft Azure app services</h1>
            

            <article>
                
<p class="calibre2">To deploy thePetClinic Spring application in Microsoft Azure web apps (PaaS), we need the following flow:</p>
<div class="CDPAlignCenter"><img class="image-border81" src="../images/00164.jpeg"/></div>
<p class="calibre2">We have <span>PetClinic-Code</span>, <span>PetClinic</span>, and <span>PetClinic-Deploy-Azure</span> build jobs that we have created throughout this chapter. Configure PetClinic as a downstream job for <span>PetClinic-Code</span>; and configure <span>PetClinic-Deploy-Azur</span>e as a downstream job for the <span>PetClinic</span> build job.</p>
<p class="calibre2">In Microsoft Azure's case, there is an alternative as well: we can use the Visual Studio Team server and TFS online for continuous integration, continuous delivery, and continuous deployment.</p>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">End-to-end automation orchestration of application life cycle management using VSTS</h1>
            

            <article>
                
<p class="calibre2">In <a href="part0077.html#29DRA0-651ea628c0544d18a4415dfef8fe6271" target="_blank" class="calibre4"><span>Chapter 5</span></a>, <em class="calibre12">Continuous Delivery</em>, we saw how to deploy our web application using VSTS:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Go to <span>Releases</span> and check the latest release definition.</li>
<li value="2" class="calibre11">Look at the <span>Build &amp; Release</span> column to verify the build number.</li>
<li value="3" class="calibre11">Double click on <span>Release-22</span> to get more details on the release definition execution in VSTS:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00170.jpeg"/></div>
<p class="calibre2">Now let's verify the details we have on the release definition execution in VSTS:</p>
<ol class="calibre17">
<li value="1" class="calibre11">In <span>Details</span>, verify the build number that triggered the execution of the release definition. It also provides details on the user who requested continuous deployment.</li>
</ol>
<ol start="2" class="calibre17">
<li value="2" class="calibre11">The <span>Environments</span> section provides details on which the environment release definition has done deployment. It also shows the <span>Deployment status</span>: when the release definition was triggered, when it was completed, and whether or not there was any test execution. In our case, there are no test cases in the release definition:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00192.jpeg"/></div>
<ol start="3" class="calibre17">
<li value="3" class="calibre11">To get more details on the release definition execution, click on <span>Logs</span>. It will have a series of steps that have been executed during the release definition execution.</li>
<li value="4" class="calibre11">If the approval mechanism is set, then it will ask for approval first; once approval is given, it will run on an agent. It will initialize the agent first; then, once the agent is available for the release definition execution, it will download the artifact or WAR file from the source folder.</li>
<li value="5" class="calibre11">We already know that we can't deploy the WAR file directly, so, based on our configuration, it will convert the WAR file into a ZIP file. Once we have a ZIP file of our package, then our Deploy Azure App Service task will deploy the application package into Azure Web Apps.</li>
<li value="6" class="calibre11">Click on each individual step to get a detailed log on the step execution.</li>
<li value="7" class="calibre11">Let's see what the <span>WAR Converter **/*.war</span> step does.</li>
<li value="8" class="calibre11">Similarly, the Deploy Azure App Service step execution will give details on how the deployment process is executed:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00175.jpeg"/></div>
<ol start="9" class="calibre17">
<li value="9" class="calibre11">As there is no <span>Post-deployment</span> approval configured, it is auto-approved and hence the build execution was successful:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00120.jpeg"/></div>
<p class="calibre2">We already know the Azure web application URL, or we can get it from the Azure portal. Visit it and check whether the application has deployed correctly or not.</p>
<p class="calibre2">So, up to this point, we have configured end-to-end automation for application life cycle management using continuous integration and continuous deployment.</p>
<p class="calibre2">We use deployment slots for different environments. So, we should create multiple environments here in the release definition and perform a deployment.</p>
<p class="calibre2">So, the next question should be how to create an environment so we can use it for package deployment in a specific deployment slot in Azure Web Apps?</p>
<p class="calibre2">In the release definition, click on <span>+Add environment</span> and select <span>Create new environment.</span> We can select <span>Clone selected environment</span> if we want to use the same tasks of the existing environment in the new environment:</p>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00078.jpeg"/></div>
<p class="calibre2">In the new environment, let's keep pre-deployment approval automatic:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Select <span>Trigger</span> to <span>Deploy automatically whenever a deployment to the environment Production is successful</span>. We can rearrange or rename it once all the environments are configured.</li>
<li value="2" class="calibre11">Select the <span>Hosted</span> agent for the release definition execution.</li>
<li value="3" class="calibre11">Click on <span>Create</span>.</li>
<li value="4" class="calibre11">Change the name of an environment by double-clicking on the <span>Name of the environment</span>.</li>
<li value="5" class="calibre11">Based on the environment, the rest of the deployment details can be configured:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00020.jpeg"/></div>
<ol start="6" class="calibre17">
<li value="6" class="calibre11">Change the existing environment name to <span>Dev</span> and click on (<span>...</span>). It will open a menu and select the <span>Clone selected environment</span> option.</li>
<li value="7" class="calibre11">In the case of a new environment, what if we want to keep approvals before the deployment process takes place?</li>
<li value="8" class="calibre11">In the <span>Pre-deployment approval</span>, select <span>Specific users</span>. All the users available in the VSTS account are eligible for approval rights. We can provide any name from that list.</li>
<li value="9" class="calibre11">Select <span>Trigger</span> to <span>Deploy automatically whenever a deployment to the environment Dev is successful</span>. We can rearrange or rename it once all environments are configured.</li>
<li value="10" class="calibre11">Select the <span>Hosted</span> agent for the release definition execution.</li>
</ol>
<ol start="11" class="calibre17">
<li value="11" class="calibre11">Click on <span>Create</span>. Change the name of an environment as <kbd class="calibre15">QA</kbd> by double-clicking on the <span>Name of the environment</span>. Based on the environment, the rest of the deployment details can be configured:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00023.jpeg"/></div>
<ol start="12" class="calibre17">
<li value="12" class="calibre11">Configure the UAT environment in a similar fashion.</li>
<li value="13" class="calibre11">To assign approvals manually to any environment, select <span>Environments</span>, click on (<span>...</span>), and select <span>Assign approvers...</span>.</li>
<li value="14" class="calibre11">In <span>Pre-deployment approval</span>, we can specify users who can approve the execution of the release definition for the deployment.</li>
<li value="15" class="calibre11">Click on <span>OK</span>.</li>
<li value="16" class="calibre11">We need to only configure where to deploy the WAR file in different environments that we have created recently:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00183.jpeg"/></div>
<p class="calibre2">Let's start with the <span>Dev</span> environment:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Click on the <span>Dev</span> environment.</li>
<li value="2" class="calibre11">Go to <span>Deploy Azure App Service</span> task available in the release definition.</li>
<li value="3" class="calibre11"><span>AzureRM Subscription</span> and <span>App Service Name</span> are already configured, as we did that exercise earlier</li>
<li value="4" class="calibre11">To deploy the WAR file into a specific slot, that is <span>dev</span> in this case, let's click on the <span>Deploy to Slot</span> checkbox.</li>
<li value="5" class="calibre11">It will ask for the <span>Resource Group</span>: select the resource group from which the Azure web application is available.</li>
<li value="6" class="calibre11">In the <span>Slot</span> list, all slots created for the Azure Web Apps will be listed. Select the <span>dev</span> slot.</li>
</ol>
<ol start="7" class="calibre17">
<li value="7" class="calibre11">Keep the rest of the details as they are and save the release definition:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00026.jpeg"/></div>
<p class="calibre2">Now, let's configure the <span>QA</span> environment:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Click on the <span>QA</span> environment.</li>
<li value="2" class="calibre11">Go to the <span>Deploy Azure App Service</span> task available in the release definition.</li>
<li value="3" class="calibre11"><span>AzureRM Subscription</span> and <span>App Service Name</span> are already configured as we did that exercise earlier too.</li>
<li value="4" class="calibre11">To deploy the WAR file into a specific slot, that is <span>qa</span> in this case, let's click on the <span>Deploy to Slot</span> checkbox.</li>
<li value="5" class="calibre11">It will ask for the <span>Resource Group</span>: select the resource group from which the Azure web application is available.</li>
<li value="6" class="calibre11">In the <span>Slot</span> list, all slots created for the Azure Web Apps will be listed. Select the <span>qa</span> slot.</li>
</ol>
<ol start="7" class="calibre17">
<li value="7" class="calibre11">Keep the rest of the details as they are and save the release definition:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00288.jpeg"/></div>
<p class="calibre2">To configure the <span>UAT</span> environment, follow these steps:</p>
<ol class="calibre17">
<li value="1" class="calibre11">Click on the <span>UAT</span> environment.</li>
<li value="2" class="calibre11">Go to the <span>Deploy Azure App Service</span> task available in the release definition.</li>
<li value="3" class="calibre11"><span>Azure RM Subscription</span> and <span>App Service Name</span> are already configured, as we did that exercise earlier.</li>
<li value="4" class="calibre11">To deploy the WAR file into a specific slot, that is <kbd class="calibre15">dev</kbd> in this case, let's click on the <span>Deploy to Slot</span> checkbox.</li>
<li value="5" class="calibre11">It will ask for the <span>Resource Group</span>: select the resource group in which the Azure Web App is available.</li>
<li value="6" class="calibre11">In the <span>Slot</span> list, all slots created for the Azure Web Apps will be listed. Select the <span>uat</span>/<span>stage</span> slot.</li>
</ol>
<ol start="7" class="calibre17">
<li value="7" class="calibre11">Keep the rest of the details as they are and save the release definition:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00030.jpeg"/></div>
<ol start="8" class="calibre17">
<li value="8" class="calibre11">To deploy an application in the production slot or main Azure Web Apps, we need not select any slot. We just need to provide the Azure web application name and it will deploy into the main web application in Azure:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00303.jpeg"/></div>
<ol start="9" class="calibre17">
<li value="9" class="calibre11">Save the release definition:</li>
<li value="10" class="calibre11">Click on the <span>Release</span> link:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00301.jpeg"/></div>
<p class="calibre2">We have set the approval process in the release definition execution so, until and unless the approver approves it, the execution of the release definition won't take place.</p>
<p class="calibre2">Look at the warning available in the summary section of the release definition execution. It says a pre-deployment approval is pending for the <kbd class="calibre15">dev</kbd> environment.</p>
<p class="calibre2">As I have configured my own ID as the approver, the links are available to approve or reject the build:</p>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00304.jpeg"/></div>
<ol class="calibre17">
<li value="1" class="calibre11">Let's click on the <span>Approve</span> or <span>Reject</span> link.</li>
<li class="calibre11" value="2">It will open a small dialog box. We need to provide a comment in it and click on <span>Approve</span> or <span>Reject</span>. We can assign multiple approvers in this mechanism as well, and we can also set whether we want to have approval from either approver, or all approvers.</li>
</ol>
<ol start="3" class="calibre17">
<li value="3" class="calibre11">In this case, we will click on <span>Approve</span>:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00308.jpeg"/></div>
<ol start="4" class="calibre17">
<li value="4" class="calibre11">In <span>Logs</span>, now we can see that <span>Pre-deployment approval</span> has been given and the rest of the processes are about to be executed for application deployment in the <span>Dev</span> slot:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00039.jpeg"/></div>
<ol start="5" class="calibre17">
<li value="5" class="calibre11">The artifact from the build definition will be downloaded so it can be converted to a ZIP file, and then we can deploy it into the <span>Dev</span> slot:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00001.jpeg"/></div>
<ol start="6" class="calibre17">
<li value="6" class="calibre11">Once deployment to the <span>Dev</span> environment is successful, the execution process will wait for the approval before it starts deployment into the <span>QA</span> slot.</li>
<li value="7" class="calibre11">We need to provide approval to get the step execution going for the application deployment:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border82" src="../images/00044.jpeg"/></div>
<ol start="8" class="calibre17">
<li value="8" class="calibre11">In the releases, we can see that there are four different environments, as in our release definition we created those environments.</li>
<li value="9" class="calibre11">We can see the current status of the release definition execution:</li>
</ol>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00048.jpeg"/></div>
<ol start="10" class="calibre17">
<li value="10" class="calibre11">Give approvals for the <span>QA</span> slot deployment and it will deploy a WAR file into the <span>QA</span> slot as well.</li>
</ol>
<p class="calibre2">We need to remember that the process is going to be the same and nothing is going to change, except some parameters, during the application deployment in the different Azure web application deployment slots.</p>
<p class="calibre2">We need to remember that every slot is a live web application, so if we want to see where the application is deployed and what else is going on behind the scene, then we can go to the <kbd class="calibre15">Kudu</kbd> editor for each slot and verify that the operations have taken place for the deployment in each slot of the Azure web application.</p>
<p class="calibre2">Similarly, deploy into the <span>UAT</span> or <span>Stage</span> slot and <span>Production</span> slot too:</p>
<div class="CDPAlignCenter"><img class="image-border6" src="../images/00050.jpeg"/></div>
<p class="calibre2">Now, as an exercise on your own, commit some changes in the code of the application and observe how the build definition is executed; how it triggers the release definition after successful execution of the build job; and how an application is deployed on different slots. Once that is done, visit a specific URL of the deployment slot of an Azure web application and check whether the application deployment in different environments has been successful or not.</p>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    

        <section>

            <header>
                </header><h1 class="header-title" id="calibre_pb_0">Summary</h1>
            

            <article>
                
<p class="calibre2">In this chapter, we have seen how to automate different tasks that are part of application life cycle management.</p>
<p class="calibre2">We have deployed an application using Jenkins on AWS and Microsoft Azure Cloud service providers. We used the Chef configuration management tool for installing runtime environment.</p>
<p class="calibre2">We also deployed an application on AWS Elastic Beanstalk using Jenkins, and used Visual Studio Team Services for end-to-end automation for deploying the application in Azure App Services, which is a PaaS offering from Microsoft.</p>
<p class="calibre2">In the next chapter, we will learn more about configuring security and monitoring related details. We will look further at role-based access to resources available in Jenkins, VSTS and Microsoft Azure.</p>


            </article>

            <footer class="calibre5">
                
            </footer>

        </section>
    </body></html>