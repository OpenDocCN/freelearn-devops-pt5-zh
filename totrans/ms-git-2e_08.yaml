- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Collaborative Development with Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B21194_02.xhtml#_idTextAnchor028)*, Developing with Git*, and
    [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049)*, Managing Your Worktrees*,
    taught you how to make new contributions to a project, but limited this information
    to affecting only your own clone of the project’s repository on your computer.
    [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028) described how to commit new revisions,
    while [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049) showed you how
    Git can help you prepare it.'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter and [*Chapter 7*](B21194_07.xhtml#_idTextAnchor172)*,* *Publishing
    Your* *Changes*, present a bird’s-eye view of the various ways to collaborate
    with others, showing centralized and distributed workflows. These two chapters
    will focus on the repository-level interactions in collaborative development,
    while the patterns of branches used will be covered in [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196),
    *Advanced* *Branching Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes different collaborative workflows, explaining the advantages
    and disadvantages of each one. You will also learn about the chain of trust concept
    and how to use **signed tags**, **signed merges**, and **signed commits**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Centralized and distributed workflows, and bare repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing remotes and one-off single-shot collaboration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How versions are addressed—the chain of trust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tagging; lightweight tags versus signed tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Signed tags, signed merges, and signed commits
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaborative workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are various levels of engagement while using a version control system.
    One might, for example, only be interested in using Git to examine how the project
    came to be. [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project
    History*, and [*Chapter 5*](B21194_05.xhtml#_idTextAnchor113), *Searching Through
    the Repository*, covered this use of Git. Of course, examining a project’s history
    is an important part of development, too.
  prefs: []
  type: TYPE_NORMAL
- en: 'One might use version control for one’s private development, using it for a
    single developer project, on a single machine. [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028),
    *Developing with Git*, and [*Chapter 3*](B21194_03_split_000.xhtml#_idTextAnchor049),
    *Managing Your* *Worktrees*, show how to do this with Git. Of course, people usually
    don’t work in isolation, but in a team: one’s own development is usually part
    of a collaboration.'
  prefs: []
  type: TYPE_NORMAL
- en: But one of the main goals of version control systems is to help multiple developers
    work together on a project, collaboratively. Version control makes it possible
    for them to work simultaneously on a given piece of software in an effective way,
    ensuring that their changes do not conflict with each other, and thus helping
    with merging those changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'One might work on a project together with a few other developers, or with many.
    One might be a contributor, or a project maintainer. Maybe the project is so large
    that it needs subsystem maintainers. One might work in tight software teams, or
    one might want to make it easy for external contributors to provide proposed changes
    (for example, to fix bugs, or fix an error in the documentation). Various workflows
    might be best suited for those different situations:'
  prefs: []
  type: TYPE_NORMAL
- en: Centralized workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Peer-to-peer workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maintainer workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hierarchical workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bare repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: One with a working directory, and a staging area (**non-bare**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **bare repository**, without the working directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The former type is meant for private solo development, and creating new history,
    while the latter is intended for collaboration and synchronizing development results.
  prefs: []
  type: TYPE_NORMAL
- en: By convention, `.git` extension—for example, `project.git`—while `project` (with
    the administrative area and the local repository in `project/.git`).
  prefs: []
  type: TYPE_NORMAL
- en: You can usually omit this extension when cloning the repository, pushing to
    it, or fetching from it; using either `https://github.com/git/git.git` as the
    repository URL or [https://github.com/git/git](https://github.com/git/git) will
    work the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the bare repository, you need to add the `--bare` option to the `git
    init` or `git clone` commands, as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Interacting with other repositories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After creating a set of revisions and extending the project’s history, you
    usually need to share it with other developers. You need to synchronize with other
    repository instances: publish your changes, and get changes from others.'
  prefs: []
  type: TYPE_NORMAL
- en: From the perspective of the local repository instance – your own clone of the
    repository – you need to **push** your changes to the repository meant for publishing
    changes and **fetch** changes from other repositories. Often the only repository
    you need to interact with is simply the repository you cloned from. [*Chapter
    7*](B21194_07.xhtml#_idTextAnchor172), *Publishing Your Changes,* will describe
    this process (and its alternatives) in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: After fetching changes, you sometimes need to incorporate them into your work
    by **merging** two lines of development (or **rebasing**)—which you can do in
    one operation with **pull**. Merging and rebasing operations will be described
    in more detail in [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229), *Merging* *Changes
    Together*.
  prefs: []
  type: TYPE_NORMAL
- en: Git assumes that you don’t want your local repository to be visible to the public,
    because these repositories are intended for private work (which helps to keep
    work not yet ready for the public from being visible).
  prefs: []
  type: TYPE_NORMAL
- en: 'This means that there is an additional step required to make your finished
    work available: you need to `git` `push` command.'
  prefs: []
  type: TYPE_NORMAL
- en: The diagram in *Figure 6**.1*, which is an extension of the one in *Figure 2**.2*
    in [*Chapter 2*](B21194_02.xhtml#_idTextAnchor028), *Developing with Git*, demonstrates
    the steps one can take when creating and publishing commits. The arrows in this
    diagram show the Git commands used to copy contents from one place to another,
    including to and from the remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Creating commits, publishing commits, and fetching changes published
    by other developers into your local repository](img/B21194_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Creating commits, publishing commits, and fetching changes published
    by other developers into your local repository
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us understand the centralized workflow.
  prefs: []
  type: TYPE_NORMAL
- en: The centralized workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With distributed version control systems, you can use different collaboration
    models, some more distributed, some less distributed. In a **centralized workflow**,
    there is one central hub: a shared repository, usually bare, that everyone uses
    to synchronize their work.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – Centralized workflow – the shared repository is bare](img/B21194_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – Centralized workflow – the shared repository is bare
  prefs: []
  type: TYPE_NORMAL
- en: In this workflow, each developer has their own **non-bare clone** of the central
    shared repository, which they use to develop new revisions of software. When changes
    are ready, they push those changes to the central repository, and fetch (or pull)
    changes from other developers from it. One might have to merge changes before
    being able to push. In this workflow integration of changes is distributed. This
    workflow is shown in *Figure 6**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Let us now look into the advantages and disadvantages of a *centralized workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of a centralized workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the key advantages of centralized workflows include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: This workflow has a simple setup; it is a familiar paradigm for people coming
    from centralized version control systems and used to working with centralized
    management. It provides centralized access control and easy backups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It makes it easy to set up **continuous** **integration** (**CI**).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process of merging changes is shared among developers, with no person solely
    responsible for integrating changes.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It might be a good setup for a private project with a small team, or where all
    developers are trusted and capable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of a centralized workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some of the disadvantages of centralized workflows are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shared repository is a single point of failure: if there are problems with
    the central repository, then there is no way to synchronize changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each developer pushing changes (making them available for other developers)
    might require updating one’s own repository first, and merging changes from others.
    Shared integration means that each developer needs to know how to do it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You also need to trust developers with access to the shared repository in this
    setup, or to provide access controls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peer-to-peer or forking workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The opposite of a centralized workflow is a **peer-to-peer** or **forking workflow**.
    Instead of using a single central shared public repository, each developer has
    a public repository (which is bare), in addition to a private working repository
    (with a working directory), like in the *Figure 6**.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – Peer-to-peer workflow – here, lines pointing up represent push
    operation, while lines pointing down represent fetch/pull operation](img/B21194_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – Peer-to-peer workflow – here, lines pointing up represent push
    operation, while lines pointing down represent fetch/pull operation
  prefs: []
  type: TYPE_NORMAL
- en: When the changes are ready, developers push to their own public repositories.
    To incorporate changes from other developers, one needs to fetch them from the
    public repositories of each of the other developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages and disadvantages of this rarely used peer-to-peer workflow,
    also called forking workflow, are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the peer-to-peer workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One advantage of the forking workflow is that contributions can be integrated
    without the need for a central repository; it is a fully distributed workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another advantage is that you are not forced to integrate if you want to publish
    your changes; you can merge at your leisure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good workflow for organic teams without requiring much setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of the peer-to-peer workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The disadvantages are a lack of the canonical version, no centralized management,
    and the fact that in the basic form of this workflow you need to interact with
    many repositories. Though the **git remote update** or **git fetch --multiple**
    commands can help here by doing multiple fetches with a single command.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up this workflow requires developers’ public repositories to be reachable
    from other developers’ workstations, which might not be as easy as using one’s
    own machine as a server for one’s public repositories
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, as can be seen in *Figure 6**.3*, collaboration gets more complicated
    with the growing number of developers; this workflow does not scale well
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The maintainer or integration manager workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the problems with peer-to-peer workflows is that there is no canonical
    version of a project, something that non-developers can use. Another is that each
    developer has to do their own integration (which was also the case for the centralized
    workflow). If we promote one of the public repositories in *Figure 6**.3* to be
    the canonical (official) repository and make one of the developers responsible
    for integration, we arrive at the **integration manager workflow** (or **maintainer
    workflow**). The following diagram shows this workflow, with bare repositories
    at the top and non-bare at the bottom.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – Integration-manager (maintainer) workflow – lines pointing up
    are push operations, while lines pointing down are fetch operations](img/B21194_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – Integration-manager (maintainer) workflow – lines pointing up are
    push operations, while lines pointing down are fetch operations
  prefs: []
  type: TYPE_NORMAL
- en: In this workflow, when changes are ready, the developer pushes those changes
    to their own public repository and tells the maintainer (for example, via a **pull
    request**) that they are ready. The **maintainer** pulls changes from the developer’s
    repository into their own working repository and integrates the changes. Then
    the maintainer pushes the merged changes to the **“blessed” repository**, for
    all to see, making them available to be fetched.
  prefs: []
  type: TYPE_NORMAL
- en: 'The advantages and disadvantages are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the integration manager workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantages are having an official version of a project, and that developers
    can continue to work without doing or waiting for integration, as maintainers
    can pull their changes at any time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is a good workflow for a large organic team, as in open source projects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fact that the blessed repository is decided by social consensus makes it
    easy to switch to other maintainers, either temporarily (for example, when one
    maintainer takes some time off) or permanently (such as when forking a project),
    without the need to hand out access rights.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This setup makes it easy for a smaller group of developers to collaborate by
    simply denoting one of the repositories in the group as the one to fetch from.
    The dotted line in *Figure 6**.4* shows this possibility of fetching from a non-official
    repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of the integration manager workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The primary disadvantage is that the ability of the maintainer to integrate
    changes can be a bottleneck (as opposed to the centralized workflow, with distributed
    integration).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can happen especially for large teams and large projects. Thus, for very
    large organic teams, such as in Linux kernel development, it is better to use
    the hierarchical workflow, described in the next section.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There needs to be dedicated person that does the merging and is responsible
    for the state of the “*blessed*” repository.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Another disadvantage is that it is more difficult to set up continuous integration
    than in the centralized repository workflow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hierarchical or dictator-and-lieutenants workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **hierarchical workflow** is a variant of the blessed repository workflow,
    generally used in huge projects with hundreds of collaborators. In this workflow,
    the project maintainer (sometimes called the **benevolent dictator**) is accompanied
    by additional integration managers, usually in charge of certain parts of the
    repository (subsystems). They are called **lieutenants**. The benevolent dictator’s
    public repository serves as the *blessed* reference repository from which all
    the collaborators need to pull. Lieutenants pull from developers and the maintainer
    pulls from the lieutenants, as shown in *Figure 6**.5*. (Note that in the following
    diagram, repositories shown with dashed patterns are actually pairs of private
    and public repositories of a developer or a lieutenant).
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – Dictator and lieutenants workflow (hierarchical workflow)](img/B21194_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – Dictator and lieutenants workflow (hierarchical workflow)
  prefs: []
  type: TYPE_NORMAL
- en: In a **dictator** **and** **lieutenants** workflow, there is a hierarchy (a
    network) of repositories. Before starting work, either development or merging,
    one would usually pull updates from the canonical **(blessed) repository** for
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: '**Developers** prepare changes in their own private repository, then send changes
    to an appropriate subsystem maintainer (lieutenant).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changes can be sent as patches in email, or by pushing them to the **developer’s**
    public repository and sending a pull request to an appropriate integration manager
    (appropriate subsystem maintainer).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Lieutenants** are responsible for merging changes in their respective areas
    of responsibility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The master maintainer (**dictator**) pulls from the lieutenants (and occasionally
    directly from developers). The **dictator** is also responsible for pushing merged
    changes to the reference (canonical) repository, and usually also for release
    management (for example, creating tags for releases).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An overview of the advantages and disadvantages of this workflow follows.
  prefs: []
  type: TYPE_NORMAL
- en: Advantages of the hierarchical workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The advantage of this workflow is that it allows the project leader (the dictator)
    to delegate much of the integration work.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This can be useful in very big projects (concerning the number of developers
    and/or changes), or in highly hierarchical environments. Such a workflow is used,
    for example, to develop the Linux kernel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disadvantages of the hierarchical workflow
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Its complicated setup is a disadvantage of this workflow. It is usually overkill
    for an ordinary project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Almost all other disadvantages of the integration manager workflow are present
    in this workflow, which is its more complex variant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which workflow to choose, and how to set up repositories, depend on how the
    project is developed. You need to decide which drawbacks are acceptable and which
    advantages matter most.
  prefs: []
  type: TYPE_NORMAL
- en: Managing remote repositories
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When collaborating on any project managed with Git, you will interact often
    with a constant set of other repositories. For example, using the integration-manager
    workflow will involve (at least) the canonical blessed repository of a project.
    In many cases, you will interact with more than one remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: Git allows us to save the information about a remote repository (or just `git`
    `remote` command.
  prefs: []
  type: TYPE_NORMAL
- en: Legacy mechanisms for storing remote repository information
  prefs: []
  type: TYPE_NORMAL
- en: There are also two legacy mechanisms to store the information about remote repositories.
  prefs: []
  type: TYPE_NORMAL
- en: This first is a named file in **.git/remotes**—the name of this file will be
    the nickname of the remote. This file can contain information about the URL or
    URLs, and fetch and push refspecs.
  prefs: []
  type: TYPE_NORMAL
- en: The second is a named file in **.git/branches**—the name of this file will also
    be the nickname of the remote. The contents of this file are just a URL for the
    repository, optionally followed by **#** and the branch name.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of those mechanisms is likely to be found in modern repositories. See
    the *Remotes* section in the **git-fetch(1)** manpage for more details.
  prefs: []
  type: TYPE_NORMAL
- en: The “origin” remote
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When cloning a repository, Git will create one remote for you—the **origin remote**,
    which stores information about where you cloned from—that is the origin of your
    copy of the repository (hence the name). You can use this remote to fetch updates.
  prefs: []
  type: TYPE_NORMAL
- en: This is the default remote; for example, `git fetch` without the remote name
    will use the origin remote. You can change this using the `remote.default` configuration
    variable on a per-repository basis, or you can set up a default remote differently
    for a given branch with `branch.<branchname>.remote`.
  prefs: []
  type: TYPE_NORMAL
- en: Listing and examining remotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see which remote repositories you have configured, you can run the `git
    remote` command. It lists the short names of each remote you’ve got. In a cloned
    repository you will have at least one remote named `origin`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To see the URL together with remotes, you can use the `-v` or `--``verbose`
    options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: From the output of this command, you can easily guess that the fetch and push
    URLs can be different (in a so-called **triangular workflow**).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to inspect remotes to see more information about a particular remote,
    you can use the `git remote show <``remote>` subcommand:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Git will consult the remote configuration, the branch configuration, and the
    remote repository itself (for an up-to-date status). If you want to skip contacting
    the remote repository and use cached information instead, add the `-n` option
    to `git remote show`. If there is no internet connection,and you did not use `'-n'`
    option, Git will tell you that it was unable to contact the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the information about remotes is stored in the repository configuration
    file, you can simply examine `.git/config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The difference between local and remote branches (and `+refs/heads/*:refs/remotes/origin/*`
    . You can see it in the second line in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new remote
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add a new remote Git repository and to store its information under a short
    name, run `git remote add <``shortname> <URL>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Adding remote doesn’t fetch from it automatically—you need to use the `-f` option
    for that (or run `git fetch <``shortname>` afterwards).
  prefs: []
  type: TYPE_NORMAL
- en: This command has a few options that affect how Git creates a new remote. You
    can select which branches in the remote repository you are interested in with
    the `-t <branch>` option. You can change which branch is the default one in the
    remote repository (and which you can refer to by the remote name) using the `-m
    <branch>` option; otherwise, it would be the current branch in the remote repository.
    You can fetch all tags or no tags with `--tags` or `--no-tags`, respectively;
    otherwise, only tags on fetched branches would be imported. Or you can configure
    the remote repository for mirroring rather than for collaboration with `--mirror=push`
    or `--mirror=fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'will result in the following configuration of the remote:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Updating information about remotes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The information about the remote repository is stored in three places:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the remote configuration: **remote.<remote** **name>**,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In remote-tracking branches and in the remote-HEAD (**refs/remotes/<remote name>/HEAD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And optionally, in the per-branch configuration: **branch.<branch name>**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The remote-HEAD is a symbolic reference (`symref`) that defines the `<remote
    name>` refers to when used as a branch name, such as in the command `'git log
    <``remote name>'`.
  prefs: []
  type: TYPE_NORMAL
- en: You could manipulate this information directly—either by editing the appropriate
    files or using manipulation commands such as `git config` and `git symbolic-ref`—but
    Git provides various `git remote` subcommands for this.
  prefs: []
  type: TYPE_NORMAL
- en: Renaming remotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Renaming the remote—that is, changing its nickname—is quite a complicated operation.
    Running `git remote rename <old> <new>` will not only change the section name
    in `remote.<old>`, but also the remote-tracking branches and accompanying `refspec`,
    their reflogs (if there are any—see the `core.logAllRefUpdates` configuration
    variable), and the respective branch configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the remote URLs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can add or replace the URL for a remote with `git remote set-url`, but it
    is also quite easy to simply directly edit the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also use the `insteadOf` (and `pushInsteadOf`) configuration variables.
    This can be useful if you want to temporarily use another server, for example,
    if the canonical repository is temporarily down. Say that you want to fetch Git
    from the repository on GitHub, because [https://www.kernel.org](https://www.kernel.org)
    that you cloned Git from is down. You can do this by adding the following text
    to the config file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Another use case for this feature is handling repository migration. You can
    use `insteadOf` rewriting in the per-user configuration file, that is, in `~/.gitconfig`
    (or `~/.config/git/config`), without having to change the URL in each and every
    repository’s `.git/config` file. In the case of more than one match, the longest
    match is used.
  prefs: []
  type: TYPE_NORMAL
- en: Tip – multiple URLs for a remote
  prefs: []
  type: TYPE_NORMAL
- en: You can set multiple URLs for a remote. Git will try all these URLs sequentially
    when fetching and use the first one that works. When pushing, Git will publish
    to all URLs (all servers) simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the list of branches tracked by remote
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A similar situation to changing the URL occurs when changing the list of branches
    tracked by a remote (that is, the contents of `fetch` lines). You can use `git
    remote set-branches` (with a sufficiently modern Git client) or edit the config
    file directly.
  prefs: []
  type: TYPE_NORMAL
- en: Note – stale remote-tracking branches
  prefs: []
  type: TYPE_NORMAL
- en: Freeing a branch in a remote repository from being tracked does not remove the
    remote-tracking branch—the latter is simply no longer updated on fetch. This is
    explained in more detail in the *Deleting remote-tracking branches and remotes*
    section later in this chapter, which describes how to prune remote-tracking branches
    that correspond to branches deleted in remote the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the default branch of the remote
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Having a `origin`) instead of a specific remote-tracking branch (for example,
    `origin/master`). This information is stored in the symbolic ref `<remote name>/HEAD`
    (for example, `origin/HEAD`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can set this with `git remote set-head` command. The `--auto` option does
    that based on what the current branch in the remote repository is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can delete the default branch on the remote with the `--``delete` option.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting remote-tracking branches and remotes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a public branch is deleted in the remote repository, Git nevertheless keeps
    the corresponding remote-tracking branch. It does that because you might want
    to do, or might have already done, your own work on top of it. You can, however,
    delete the remote-tracking branch with `git branch -r -d`, or you can ask Git
    to prune all stale remote-tracking branches under the remote with `git remote
    prune`. You can configure Git to do this automatically on every fetch, as if `git
    fetch` were run with the `--prune` option, by setting the `fetch.prune` and/or
    `remote.<name>.prune` configuration variables (the latter on a per-remote basis).
  prefs: []
  type: TYPE_NORMAL
- en: You can check which remote-tracking branches are stale with the `--dry-run`
    option to `git remote prune`, or with the `git remote` `show` command.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting remote is as simple as running `git remote delete` (or its alias, `git
    remote rm`). It also removes remote-tracking branches for the deleted remote.
  prefs: []
  type: TYPE_NORMAL
- en: Support for triangular workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In many collaborative workflows, such as the maintainer (or integration manager)
    workflow, you fetch from one URL (from the blessed repository), but push to another
    URL (to your own public repository).
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 6**.4*, the developer interacts with three repositories:
    they fetch from the **blessed** repository (top left) into their own private repository
    (darker, at the bottom), then push their work into their own public repository
    (lighter, at the top).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a `origin` remote (or `remote.default`). One option for configuring
    which repository you push to is to add this repository as a separate remote, and
    perhaps also set it up as the default with `remote.pushDefault`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also set it as `pushRemote` in the per-branch configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Another option is to use a single remote (perhaps even `origin`) but set it
    up with a separate `pushurl`. This solution, however, has the slight disadvantage
    that you don’t have separate remote-tracking branches for the push repository
    (and thus there is no support `@{push}` notation in addition to having `@{upstream}`
    as a shortcut for specifying the appropriate remote-tracking branches):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Having separate remote-tracking branches for the push repository allows you
    to track which branches were pushed to the push remote, and which have local unpublished
    changes.
  prefs: []
  type: TYPE_NORMAL
- en: Chain of trust
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important part of collaborative efforts during the development of a project
    is ensuring the quality of its code. This includes protection against the accidental
    corruption of the repository, and also from **malicious intent**—a task that the
    version control system can help with. Git needs to ensure trust in the repository
    contents: both your own and other developers’ (especially trust in the canonical
    repository of the project).'
  prefs: []
  type: TYPE_NORMAL
- en: Content-addressed storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B21194_04.xhtml#_idTextAnchor083), *Exploring Project History*,
    in the *SHA-1 and the shortened SHA-1 identifier* section, we learned that Git
    currently uses SHA-1 hashes as a native identifier of commit objects (which represent
    revisions of the project and form the project’s history). This mechanism makes
    it possible to generate commit identifiers in a distributed way, taking a cryptographic
    hash of the commit object. This hash is then used to link to the previous commit
    (to the parent commit or commits).
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, all other data stored in the repository (including the file contents
    in the revision represented by the blob objects, and the file hierarchy represented
    by the tree objects) also use the same mechanism. All types of object are addressed
    by their contents, or to be more accurate, the hash function of the object. You
    can say that the base of a Git repository is the *content-addressed* *object database*.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, Git provides a built-in **trust chain** through secure SHA-1 hashes, via
    a kind of a hash tree, also known as a Merkle tree. In one dimension, the SHA-1
    hash of a commit depends on its contents, which includes the SHA-1 hash of the
    parent commit or commits, which depends on the contents of the parent commit,
    and so forth down to the initial root commit. In the other dimension, the content
    of a commit object includes the SHA-1 hash of the tree representing the top directory
    of a project, which in turn depends on its contents, and these contents include
    the SHA-1 hash of the subdirectory trees and blobs of file contents, and so forth
    down to the individual files.
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 6.6 – Hash tree of a short history of a project, with a tag, two commits,\
    \ and their contents. The SHA-1 hashes, shown in shortened form, \uFEFFdepending\
    \ on their contents](img/B21194_06_06.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – Hash tree of a short history of a project, with a tag, two commits,
    and their contents. The SHA-1 hashes, shown in shortened form, depending on their
    contents
  prefs: []
  type: TYPE_NORMAL
- en: All of this allows SHA-1 hashes to be used to verify whether objects obtained
    from a (potentially untrusted) source have been corrupted or modified since they
    were created.
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight, annotated, and signed tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The trust chain allows us to verify the contents but does not verify the identity
    of the person who created the content (the author and committer name are fully
    configurable and under user control). This is the task for GPG/PGP signatures:
    signed tags, signed commits, and signed merges.'
  prefs: []
  type: TYPE_NORMAL
- en: Since Git version 2.34, you can also use SSH keys for signing by setting the
    `gpg.format` configuration variable to the value `ssh`, for example with `git
    config gpg.format ssh` (you may also need to use your public key as the configuration
    value for the `user.signingKey` configuration variable).
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Git uses two types of tags: lightweight tags and annotated tags (there are
    also signed tags, which are a special case of annotated tags).'
  prefs: []
  type: TYPE_NORMAL
- en: A `refs/tags/` namespace rather than in `refs/heads/`.
  prefs: []
  type: TYPE_NORMAL
- en: Annotated tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`refs/tags/` namespace) points to a tag object, which in turn points to a commit.
    Tag objects contain a creation date, the tagger identity (name and e-mail), and
    a tagging message. You create an annotated tag with `git tag -a` (or `--annotate`).
    If you don’t specify a message for an annotated tag on the command line (for example,
    with `-m "<message>"`), Git will launch your editor so you can enter it.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can view the tag data along with the tagged commit with the `git show`
    command as follows (commit skipped):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Signed tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Signed tags are annotated tags with a clear text PGP signature (or, with modern
    Git, an SSH signature) of the tag data attached. You can create them with `git
    tag -s` (which uses your committer identity to select the signing key, or `user.signingKey`
    if set), or with `git tag -u <key-id>`; both versions assume that you have a `gpg
    --gen-key`).
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight tags versus annotated and signed tags
  prefs: []
  type: TYPE_NORMAL
- en: Annotated or signed tags are meant for marking a release, while lightweight
    tags are meant for private or temporary revision labels. For this reason, some
    Git commands (such as **git describe**) will ignore lightweight tags by default.
  prefs: []
  type: TYPE_NORMAL
- en: Of course in collaborative workflows, it is important that the signed tag is
    *made public*, and that there is a way to *verify it*; both of those operations
    will be described in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing tags
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Git does not push tags by default: you need to do it explicitly. One solution
    is to individually `git push <remote> tag <tag-name>` (here, `tag <tag>` is equivalent
    to the longer `refs/tags/<tag>:refs/tags/<tag>`); however, if you don’t have the
    naming conflict between a branch and a tag (i.e., you don’t have branch and tag
    with the same name), then you can skip the word `tag` here in this operation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another solution is to push tags en masse: either all the tags—both lightweight
    and annotated—with the use of the `--tags` option, or just all annotated tags
    that point to pushed commits with `--follow-tags`. This explicitness allows you
    to re-tag (using `git tag -f`) with impunity if it turns out that you tagged the
    wrong commit, or there is a need for a last-minute fix—but only if the tag was
    not made public. Git does not (and should not) change tags behind the user’s back;
    thus, if you pushed the wrong tag, you need to ask others to delete this old tag
    to change it.'
  prefs: []
  type: TYPE_NORMAL
- en: When fetching changes, Git automatically **follows tags**, downloading annotated
    tags that point to fetched commits. This means that downstream developers will
    automatically get signed tags, and will be able to verify releases.
  prefs: []
  type: TYPE_NORMAL
- en: Tag verification
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To verify a signed tag, you use `git tag --verify <tag-name>` (or `-v` for short).
    You need the signer’s `gpg --import` or `gpg --keyserver <key-server> --recv-key
    <key-id>`), and of course the tagger’s key needs to be vetted in your chain of
    trust. For `gpg.ssh.allowedSignersFile` configuration variable.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Signed commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Signed tags are a good solution for users and developers to verify that the
    tagged release was created by the maintainer. But how do we make sure that a commit
    purporting to be by somebody named Jane Doe, with the `jane@company.com` e-mail,
    is *actually* a commit from her? How can we make it so anybody can check this?
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible solution is to sign individual commits. You can do this with `git
    commit` `--gpg-sign[=<keyid>]` (or `-S` for short). The key identifier is optional—without
    this, Git would use your identity as the author. Note that `-S` (capital *S*)
    is different from `-s` (small *s*); the latter adds a *Signed-off-by* line at
    the end of the commit message for the *Digital Certificate* *of Ownership*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'To make commits available for verification, just push them. Anyone can then
    verify them with the `--show-signature` option to `git log` (or `git show`), or
    with one of the `%Gx` placeholders in `git` `log --format=<format>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: You can also use the `git verify-commit` command for this.
  prefs: []
  type: TYPE_NORMAL
- en: Merging signed tags (merge tags)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *signed commit* mechanism, described in the previous section, may be useful
    in some workflows, but it is inconvenient in an environment where you push commits
    out early, and only after a while do you decide whether they are worth including
    in the upstream. In such cases, you would want to sign only those parts that are
    ready to be published.
  prefs: []
  type: TYPE_NORMAL
- en: This situation can happen if you follow the recommendations in [*Chapter 10*](B21194_10_split_000.xhtml#_idTextAnchor247),
    *Keeping History Clean*; you know only after the fact (long after the commit was
    created) that the given iteration of the commit series passes code review. Commits
    need to be signed at commit creation time, but you can create a signed tag after
    the fact, after the series of commits gets accepted.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can deal with this issue by rewriting the whole commit series after its
    shape is finalized (after passing the review), signing each rewritten commit,
    or just by amending and signing only the top commit. Both of those solutions would
    require a forced push to replace the old history where commits were not signed.
    You can always sign every commit, or you can create an empty commit (with `--allow-empty`),
    sign it, and push it on top of the series. But there is a better solution: requesting
    the pull of a signed tag.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this workflow, you work on your changes and, when they are ready, you create
    and push a signed tag (tagging the last commit in the series). You don’t have
    to push your working branch—pushing the tag is enough. If the workflow involves
    sending a pull request to the integrator, you create it using a signed tag instead
    of the end commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The signed tag message is shown between the dashed lines in the pull request,
    which means that you may want to explain your work in the tag message when creating
    the signed tag. The maintainer, after receiving such a pull request, can copy
    the repository line from it, fetching and integrating the named tag. When recording
    the merge result of pulling the named tag, Git will open an editor and ask for
    a commit message. The integrator will see a template starting with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This commit template includes the commented-out output of the verification of
    the signed tag object being merged (so it won’t be in the final merge commit message).
    The tag message helps describe the merge better.
  prefs: []
  type: TYPE_NORMAL
- en: The signed tag being pulled is *not* stored in the integrator’s repository,
    not as a tag object. Its content is stored, hidden, in a merge commit. This is
    done to avoid polluting the tag namespace with a large number of such working
    tags. The developer can safely delete the tag (`git push public-repo --delete
    1252-for-maintainer`) after it gets integrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recording the signature inside the merge commit allows for after-the-fact verification
    with the `--``show-signature` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Through this chapter, we learned how to use Git for collaborative development
    and how to work together in a team on a project. We got to know different collaborative
    workflows, that is, different ways of setting up repositories for collaboration.
    Which one to use depends on circumstances: how large the team is, how diverse,
    and so on. This chapter focuses on repository-to-repository interaction; the interplay
    between branches and remote-tracking branches in those repositories is left for
    [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced* *Branching
    Techniques*.'
  prefs: []
  type: TYPE_NORMAL
- en: We learned how Git can help manage information about remote repositories involved
    in the chosen workflow. We were shown how to store, view, and update this information.
    This chapter explains how one can manage triangular workflows, in which you fetch
    from one repository (canonical), and push to the other (public).
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned about the chain of trust: how to verify that a release comes from
    the maintainer, how to sign your work so that the maintainer can verify that it
    comes from you, and how the Git architecture helps with this.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter, namely [*Chapter 7*](B21194_07.xhtml#_idTextAnchor172), *Publishing
    Your* *Changes*, will talk about how to get your contribution to other remote
    repositories. The two further following chapters will expand on the topic of collaboration:
    [*Chapter 8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced Branching
    Techniques*, will explore relations between local branches and branches in a remote
    repository and how to set up branches for collaboration, while [*Chapter 9*](B21194_09.xhtml#_idTextAnchor229),
    *Merging Changes Together*, will talk about the opposite issue—how to join the
    results of parallel work.'
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What operation do you need to publish your changes to your public remote repository,
    and what operation do you need to get changes from a remote?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between **git fetch** and **git pull**?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you remove stale remote-tracking branches (that is, remote-tracking
    branches where the corresponding branch on the remote was deleted)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to the questions given above:'
  prefs: []
  type: TYPE_NORMAL
- en: Use **git push** to publish your changes, and use **git fetch** or **git pull**
    (or **git remote update**) to get changes from the remote repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **fetch** operation only downloads changes and updates the remote-tracking
    branches, while the **pull** operation also tries to update the current branch
    with **merge** or **rebase** (if it is configured as tracking some branch in the
    remote repository).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can use **git branch -d -r** to delete individual remote-tracking branches,
    or **git remote prune** to delete all stale remote-tracking branches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scott Chacon and Ben Straub: *Pro Git, 2nd Edition* (2014) [https://git-scm.com/book/en/v2](https://git-scm.com/book/en/v2)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 5.1 Distributed Git -* *Distributed Workflows*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 2.5 Git Basics - Working* *with Remotes*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapter 7.4 Git Tools - Signing* *Your Work*'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ryan Brown: *gpg-sign releases* (2014) [https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html](https://gitready.com/advanced/2014/11/02/gpg-sign-releases.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Danilo Bargen: *Signing Git Commits with SSH Keys* (2021) https://blog.dbrgn.ch/2021/11/16/git-ssh-signatures/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Carl Tashian: *SSH Tips & Trick* – *Add a second factor to your SSH login*
    (2020) [https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh](https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Junio C Hamano: *Git Blame: Fun (?) with GnuPG* (2014) [https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html](https://git-blame.blogspot.com/2014/09/fun-with-gnupg.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
