<html><head></head><body>
<div><div><div><h1 id="_idParaDest-49" class="chapter-number"><a id="_idTextAnchor130"/>3</h1>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor131"/>Planning the Deployment</h1>
			<p><a id="_idTextAnchor132"/>In this chapter, we will dive into the important stage of planning the deployment of our <strong class="bold">Infrastructure as Code</strong> workload. Before we can deploy our infrastructure, it is crucial to have <a id="_idIndexMarker099"/>an understanding of what we are deploying and how we want to approach the deployment process. This will ensure that our deployment is efficient, streamlined, and free of errors.</p>
			<p>We will start by introducing the workload that we will be deploying in the following two chapters. This will give us a clear understanding of what we are trying to achieve and what resources we need to deploy.</p>
			<p>Next, we will discuss how to approach the deployment of our infrastructure. This will include a step-by-step guide on how to plan and execute the deployment process in a smooth and effective manner. We will also discuss best practices and tips for ensuring a successful deployment.</p>
			<p>Finally, we will examine the high-level architecture of our infrastructure. This will give us an overview of how the various components of our infrastructure will fit together and interact with each other.</p>
			<p>With this understanding of our workload and deployment approach, we can move forward confidently to <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a><em class="italic">, Deploying to Microsoft Azure</em>, and <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a><em class="italic">, Deploying to Amazon Web Services</em>, where we go into the low-level design and deployment code.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor133"/>Planning the deployment of our workload</h1>
			<p>When coming up with sample workloads for projects, it is sometimes difficult to find something <a id="_idIndexMarker100"/>that isn’t too complex, but also not so simple that the example is simply a case of following steps 1 through 10 and you are done. To ensure that the project we are going to be covering is both exciting and has the sort of considerations you will need to make in your projects, but also is something that most of you will have had some experience with at one point or another, I have chosen to use <strong class="bold">WordPress</strong>.</p>
			<p>WordPress is an <a id="_idIndexMarker101"/>open source <strong class="bold">content management system </strong>(<strong class="bold">CMS</strong>), hosted using PHP and MySQL, that <a id="_idIndexMarker102"/>enables you to build websites and blogs. It was developed in 2003 and has grown to be one of the most popular CMS platforms in the world, running millions of websites. WordPress is renowned for its simplicity and flexibility, which makes it a great choice for users of all skill levels. I can hear what you are thinking: <em class="italic">But WordPress has its famous five-minute installation, which is just a case of following a few simple steps! </em>However, in our case, we are going to look at deploying WordPress across multiple hosts as well as using services native to each of the public clouds we are going to be targeting for the database, storage, and networking layers.</p>
			<p>One of the key features of WordPress is its use of themes, which allow users to easily change the look <a id="_idIndexMarker103"/>and feel of their website without having to modify the underlying code. This makes it simple for users to produce professional-looking websites <a id="_idIndexMarker104"/>without having any knowledge of web design or programming. In addition to WordPress having a large and active community of users and developers, there are always new features and updates being released. This, in combination with its open source nature, makes it an excellent choice for anybody looking to develop a website or blog.</p>
			<p>Before we progress any further, a word of warning.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">While we will be deploying WordPress across multiple instances, this approach is being taken to give an example of the considerations you need to make tackling your own Infrastructure as Code projects; please do not use it as a guide for deploying and managing your own highly available WordPress installations.</p>
			<p>So, now that we have an idea of what we are going to be deploying, let us look at answering some of the questions that you may have to give an idea of how we are going to be approaching the deployment.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor134"/>How to approach the deployment of our infrastructure</h1>
			<p>First, as we have already mentioned, WordPress runs on top of PHP and MySQL; to be more explicit, it has the following requirements:</p>
			<ul>
				<li>A piece of web server software such as Apache or NGINX</li>
				<li>PHP version 7.4 or greater</li>
				<li>MySQL version 5.7 or greater, or MariaDB version 10.3 or greater</li>
			</ul>
			<p class="callout-heading">Information</p>
			<p class="callout">Please note that, at the time of writing, PHP 8 only has beta support in WordPress version 6.1; because of this, we will be installing PHP 7 in our example deployment.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor135"/>Deployment considerations</h2>
			<p>So, we know from our requirements that we are going to need a web server and PHP installed on <a id="_idIndexMarker105"/>something, while all the cloud services we are going to be looking at in the next two chapters offer some sort of application hosting as a service. For our project, we are going to use <strong class="bold">virtual machine instances</strong> running Ubuntu.</p>
			<p>Rather than launching a single host, which would be a single point of failure, let’s look at launching a minimum of two virtual machine instances to run WordPress on. This approach introduces some complexity as WordPress really likes to run as a fixed point, so what considerations <a id="_idIndexMarker106"/>do we need to make when running WordPress across more than a single virtual machine instance?</p>
			<ul>
				<li>Shared storage across our hosts – all the WordPress code and files should be stored on a filesystem that is available across all the virtual machine instances we are running. As we are running Ubuntu Linux, this should be NFS rather than Samba or <a id="_idIndexMarker107"/>a Windows File share – this should be a <strong class="bold">Platform-as-a-Service</strong> offering from the cloud provider.</li>
				<li>When installing WordPress using our Infrastructure as Code scripts, we should look at only doing this from a single virtual machine instance and only once – let’s refer to this as our <strong class="bold">admin host</strong>. All other hosts, or web hosts, should have all the packages <a id="_idIndexMarker108"/>needed to run WordPress installed and configured, and then mount the NFS share once WordPress has been successfully bootstrapped.</li>
				<li>As well as needing a way of distributing traffic across our multiple virtual machine instances, we are also going to have to think about how we will be serving traffic for the WordPress administration section of our website.</li>
			</ul>
			<p>What about the <strong class="bold">database</strong>? As both the cloud services we are going to be targeting offer MySQL as a service, we will be utilizing these with our deployments. <em class="italic">Great</em>, you may be <a id="_idIndexMarker109"/>thinking to yourself – yes, it is one less resource we need to manage on our virtual machine instances – but there are also some considerations we need to make here as well, quite big ones:</p>
			<ul>
				<li>We will need to know the endpoint of the database host and the credentials we need to access it before we do the initial bootstrap of WordPress.</li>
				<li>We would want to lock down our database endpoint to only our virtual machine instances, as these will be the only things that will need access to it.</li>
				<li>We should also set up database backups!</li>
			</ul>
			<p>Like the database-as-a-service and <a id="_idIndexMarker110"/>as already mentioned, we should be using an as-a-service for our <strong class="bold">shared storage</strong> running NFS; there are some considerations to make there too:</p>
			<ul>
				<li>We need to know the NFS endpoints so they can be mounted before we bootstrap WordPress, as we are going to need WordPress to be correctly installed before we launch the additional virtual machine instances</li>
				<li>Again, like the database, the NFS service needs to be locked down to only allow trusted virtual machine instances to be able to connect to it – we don’t want just anyone to be able to connect randomly and be able to browse/download the contents of our filesystem</li>
			</ul>
			<p>There are other aspects we also need to think about in our deployment:</p>
			<ul>
				<li><strong class="bold">Private networking</strong>: As we want to lock things down, we will need some sort of internal <a id="_idIndexMarker111"/>network to launch our resources into</li>
				<li><strong class="bold">Load balancing</strong>: We <a id="_idIndexMarker112"/>need a Layer 7 load-balancing service to distribute traffic across our backend services</li>
				<li><strong class="bold">Bootstrapping</strong>: We will <a id="_idIndexMarker113"/>need to bootstrap both the software stack and WordPress itself on the virtual machine instances</li>
			</ul>
			<p>Now that we are <a id="_idIndexMarker114"/>aware of the key considerations, let’s look at the specific tasks that we will need to perform for deployment.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor136"/>Performing deployment tasks</h2>
			<p>Based on the information in the previous section, we have a rough idea of what needs to happen <a id="_idIndexMarker115"/>and in which order. This all starts with launching the resources in our preferred cloud provider. To deploy our workload using Infrastructure as Code, we will need to perform the following tasks:</p>
			<ol>
				<li>Launch and configure resources required for our <a id="_idTextAnchor137"/>private network.</li>
				<li>Launch and configure the database as a service.</li>
				<li>Launch and configure the NFS filesystem as a service.</li>
				<li>Launch and configure the load balancer service.</li>
			</ol>
			<p>Now that we have the core resources in our cloud provider, we can perform the following tasks:</p>
			<ol>
				<li>Gather information on the services and resources we have launched so far in our<a id="_idTextAnchor138"/> cloud provider.</li>
				<li>Dynamically generate the script needed to bootstrap the admin virtual machine instance.</li>
				<li>Dynamically generate the script needed to bootstrap the web virtual machine instance(s).</li>
			</ol>
			<p>Once we have the scripts, we can continue to laun<a id="_idTextAnchor139"/>ch our workload.</p>
			<ol>
				<li value="4">Launch <a id="_idIndexMarker116"/>the admin virtual machine instance, attaching the script we generated; this should then do the following, once it is executed when the instance first boots:<ol><li>Run an operating system update</li><li>Download, install, and configure Apache, PHP, and the MySQL clients and NFS clients</li><li>Configure the remote NFS share by creating the mount points, setting it to mount on boot, and also ensuring that the NFS share is mounted before progressing any further</li><li>Download WordPress, bootstrap the database, and configure the site</li><li>Start the webserver and make sure that all the services we have installed and configured are configured to start after a reboot</li></ol></li>
			</ol>
			<p>Now that the admin virtual machine instance has been launched, we hopefully have a working copy of WordPress stored on our NFS share, meaning we can progress with the remaining web virtual machine instances:</p>
			<ol>
				<li>Launch the web virtual machine instances, attaching the script we generated; this should then do the following, once it is executed when the instance boots:<ol><li>Run an operating system update</li><li>Download, install, and configure Apache, PHP, and the MySQL clients and NFS clients</li><li>Configure the remote NFS share by creating the mount points, setting it to mount on boot, and ensuring that the NFS share is mounted before progressing any further</li><li>Start the webserver and ensure all the services we have installed and configured will start after a reboot</li></ol></li>
			</ol>
			<p>We should now have – if everything has gone as planned – a working WordPress installation across a small number of virtual machine instances, which leaves us with one last task.</p>
			<ol>
				<li value="2">Register all the virtual machine instances with the load balancer so they can start receiving traffic.</li>
			</ol>
			<p>There are <a id="_idIndexMarker117"/>a few other cloud provider-specific tasks, which we will get into in the next few chapters as we get lower into the design and start to write our Infrastructure as Code; that sums up the tasks we will need to complete in the rough order they need to be executed.</p>
			<p>Back in <a href="B19537_02.xhtml#_idTextAnchor085"><em class="italic">Chapter 2</em></a><em class="italic">, Ansible and Terraform beyond the Documentation</em>, one of the points we mentioned was that Terraform isn’t really designed to be used to deploy and configure the software – it’s not that straightforward for it to SSH into a virtual machine host to install and configure the software stack, so how are we going to do that?</p>
			<p>Let’s answer that now, by using a tool called <strong class="bold">cloud-init</strong>.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor140"/>Introducing cloud-init</h2>
			<p>In <em class="italic">steps 6</em> and <em class="italic">7</em> of <a id="_idIndexMarker118"/>the tasks we listed in the previous section, we talk about generating a scri<a id="_idTextAnchor141"/>pt – this will be a <code>cloud-init</code> script. This is a cloud and Linux operating system-agnostic tool used for bootstrapping instances as they boot.</p>
			<p>It is supported on both Microsoft Azure and Amazon Web Services, and we will be using our Infrastructure as Code tools to populate a base template with the information gathered on the resources that have been launched, such as SQL and NFS endpoints, and then attach the output to the virtual machine instances when they are launched.</p>
			<p>What follows is an example <code>cloud-init</code> script, which, when deployed with a virtual machine instance, will do the following tasks:</p>
			<ol>
				<li>Update all of the packages which are already installed on the virtual machine to ensure we are fully patched.</li>
				<li>Install NGINX.</li>
				<li>Create a default NGINX site.</li>
				<li>Create an example <code>index.html</code> file and place it in the root of the default NGINX site we configured in <em class="italic">step 2</em>.</li>
				<li>Restart the NGINX service to pick up the new configuration.</li>
			</ol>
			<p>To action these <a id="_idIndexMarker119"/>steps, the script looks like the following:</p>
			<pre class="source-code">
#cloud-config
package_upgrade: true
packages:
  - nginx
write_files:
  - owner: www-data:www-data
    path: /etc/nginx/sites-available/default
    content: |
      server {
          listen         80 default_server;
          root           /var/www/site;
          index          index.html;
          try_files $uri /index.html;
      }
  - owner: www-data:www-data
    path: /var/www/site/index.html
    content: |
      &lt;!DOCTYPE html&gt;
      &lt;html&gt;
          &lt;head&gt;
              &lt;title&gt;Example&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
              &lt;p&gt;This is an example of a simple HTML page.&lt;/p&gt;
          &lt;/body&gt;
      &lt;/html&gt;
runcmd:
  - service nginx restart</pre>
			<p>As you can see, it is relatively straightforward to read and follow along with what is happening; the one we will be using to deploy WordPress is a little more complicated as it is going to do a lot more than the example we have just given – but more on that in <a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying to Microsoft Azure</em>, and <a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a>, <em class="italic">Deploying to Amazon </em><em class="italic">Web Services</em>.</p>
			<p class="callout-heading">Information</p>
			<p class="callout">Please note that while the example above used NGINX as the webserver, we will use Apache for the web server in our Wordpress deployment.</p>
			<p>This means that we <a id="_idIndexMarker120"/>will still be able to use the programmatic parts of Terraform to configure our virtual machine instances without having to SSH into them. For Ansible, in <a href="B19537_06.xhtml#_idTextAnchor350"><em class="italic">Chapter 6</em></a>, <em class="italic">Building upon the Foundations</em>, we will be taking a slightly different approach where we will use SSH to log in to our virtual machine to be able to make changes to the software stack and its configuration.</p>
			<p>Now that we know the steps we are going to be taking to deploy our workload, let’s visualize what it is going to look like.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor142"/>Exploring the high-level architecture</h1>
			<p>Now that we know what <a id="_idIndexMarker121"/>we are going to be deploying, we should have a good idea of what the high-level architecture is going to look like. The following diagram shows a cloud-agnostic overview of how the resources we are going to be deploying across the next two chapters are goin<a id="_idTextAnchor143"/><a id="_idTextAnchor144"/><a id="_idTextAnchor145"/><a id="_idTextAnchor146"/>g to hang together:</p>
			<div><div><img src="img/Figure_3.01_B19537.jpg" alt="Figure 3.1 – An overview of our high-level cloud architecture" width="964" height="901"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – An overview of our high-level cloud architecture</p>
			<p>From a software <a id="_idIndexMarker122"/>stack perspective, each of the virtual machine instances will look like the following:</p>
			<div><div><img src="img/Figure_3.02_B19537.jpg" alt="Figure 3.2 – An overview of our high-level software architecture" width="964" height="469"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – An overview of our high-level software architecture</p>
			<p>While this is not the most verbose high-level design, we now have a good idea of what it is we need to code to deploy our Word<a id="_idTextAnchor147"/>Press-based workload.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor148"/>Summary</h1>
			<p>In this chapter, we have spoken about the example project we are going to look at deploying into Microsoft Azure and Amazon Web Services in the next two chapters using both Terraform and Ansible. While we have kept the discussion at a high level and aimed to be as cloud-agnostic as possible, we know the tasks we need to follow and roughly how we will get around the limitation of Terraform not really being a tool you can use to manage your application deployment.</p>
			<p>Now that we know what our cloud and software architecture is going to look like, as well as having an idea of the order in which we need to deploy the resources, we can make a start on getting into the low-level design and the actual deployments. In our next chapter, we will look at deploying the workload discussed to Microsoft Azure.</p>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor149"/>Further reading</h1>
			<p>You can find more details on the software we have mentioned in this chapter at the following URLs:</p>
			<ul>
				<li>WordPress: <a href="https://wordpress.org/">https://wordpress.org/</a></li>
				<li>PHP: <a href="https://www.php.net/">https://www.php.net/</a></li>
				<li>MySQL: <a href="https://www.mysql.com/">https://www.mysql.com/</a></li>
				<li>NGINX: <a href="https://nginx.org/">https://nginx.org/</a></li>
				<li><code>cloud-init</code>: <a href="https://cloud-init.io/">https://cloud-init.io/</a></li>
			</ul>
		</div>
	</div>
</div>


<div><div><div><h1 id="_idParaDest-59"><a id="_idTextAnchor150"/>Part 2: Getting Hands-On with the Deployment</h1>
			<p>Now that we have an understanding of the tools we are going to be using and also have an idea of the tasks we need to execute to deploy our example workload, it is time to roll up our sleeves and make a start on the code and deploy it.</p>
			<p>In this part, we will be deploying the workload using Terraform and Ansible in Microsoft Azure and Amazon Web Services and discussing how we could build upon the scripts.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B19537_04.xhtml#_idTextAnchor151"><em class="italic">Chapter 4</em></a><em class="italic">, Deploying to Microsoft Azure</em></li>
				<li><a href="B19537_05.xhtml#_idTextAnchor268"><em class="italic">Chapter 5</em></a><em class="italic">, Deploying to Amazon Web Services</em></li>
				<li><a href="B19537_06.xhtml#_idTextAnchor350"><em class="italic">Chapter 6</em></a><em class="italic">, Building upon the Foundations</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</div>
</div>
</body></html>