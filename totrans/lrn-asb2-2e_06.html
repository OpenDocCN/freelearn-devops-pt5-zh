<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Getting Notifications from Ansible</h1></div></div></div><p>One of the big advantages of Ansible compared to a bash script is its capability of running multiple times on the same system, ensuring that everything is in order. This is a very nice feature that not only assures you that nothing has changed the configurations on your server, but also those new configurations will be applied in a short time.</p><p>Due to these reasons, many people run their <code class="literal">master.yaml</code> once a day. When you do this (and probably you should!), you want some kind of feedback sent to you by Ansible itself. There are also many other cases where you may want Ansible to send messages to you or your team. For instance, if you use Ansible to deploy your application, you may want to send an IRC message (or other kinds of group chat messages) to your development team channel, so that they are all informed of the status of your system.</p><p>Other times, you want Ansible to notify Nagios that it's going to break something so that Nagios does not worry and does not start to shoot e-mails and messages to your sysadmins.</p><p>In this chapter we'll explore the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mail notifications</li><li class="listitem" style="list-style-type: disc">Ansible XMPP/Jabber</li><li class="listitem" style="list-style-type: disc">Slack and Rocket Chat</li><li class="listitem" style="list-style-type: disc">Sending a message to an IRC channel (community information and contributing)</li><li class="listitem" style="list-style-type: disc">Amazon Simple Notification Service</li><li class="listitem" style="list-style-type: disc">Nagios</li></ul></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec47"/>E-mails</h1></div></div></div><p>The easiest and most common way of alerting people is to send e-mails. Ansible allows you to send e-mails from your playbook using a <code class="literal">mail</code> module. You can use this module in between any of your tasks and notify your user whenever required. Also, in some cases, you cannot automate each and every thing because either you lack the authority or it requires some manual checking and confirmation. If this is the case, you can notify the responsible user that Ansible has done its job and it's time for him/her to perform his/her duty. Let's see how you can use the <code class="literal">mail</code> module to notify your users with a very simple playbook called <code class="literal">uptime_and_email.yaml</code>:</p><pre class="programlisting">    - hosts: localhost &#13;
      tasks: &#13;
      - name: Read the machine uptime &#13;
        command: uptime -p &#13;
        register: uptime &#13;
      - name: Send the uptime via e-mail &#13;
        mail: &#13;
          host: mail.fale.io &#13;
          username: ansible@fale.io &#13;
          password: PASSWORD &#13;
          to: me@fale.io &#13;
          subject: Ansible-report &#13;
          body: 'Local system uptime is {{ uptime.stdout }}.' &#13;
</pre><p>In the preceding playbook, we will first read the current machine uptime and then send it via e-mail to someone. This example is very easy and will allow us to keep the examples short, but obviously you can generate the e-mails in a similar way in very long and complex playbooks. If we focus on the <code class="literal">mail</code> task a little bit, we can see that we are using it with the following data:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">An e-mail server to be used to send the e-mail (also with login information, which is required for this server)</li><li class="listitem" style="list-style-type: disc">The receiver e-mail address</li><li class="listitem" style="list-style-type: disc">The e-mail subject</li><li class="listitem" style="list-style-type: disc">The e-mail body</li></ul></div><p>Other interesting parameters that the <code class="literal">mail</code> module supports are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">attach</code> parameter: This is used to add attachments to the e-mail that will be generated. This is very useful when, for instance, you want to send a log via an e-mail.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">port</code> parameter: This is used to specify which port is used by the e-mail server.</li></ul></div><p>An interesting thing about this module is that the only mandatory field is <code class="literal">subject</code>, and not the body, as many people would expect.</p><p>We can now proceed to execute the script to validate its functionality with the following:</p><pre class="programlisting">
<strong>ansible-playbook -i localhost, uptime_and_email.yaml</strong>
</pre><p>We will have a result similar to the following:</p><pre class="programlisting">
<strong>PLAY [localhost] *************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Read the machine uptime] ***********************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Send the uptime via e-mail] ********************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>localhost         : ok=3    changed=2    unreachable=0    failed=0</strong>
</pre><p>Also, as expected, Ansible has sent me an e-mail with the following content:</p><pre class="programlisting">    Local system uptime is up 38 min. &#13;
</pre><p>This module can be used in many different ways. An example of a real world case that I've seen is a playbook that was created to automate a piece of a very long procedure done by multiple people. The procedure, historically, changed owners using the e-mails and every person involved in the procedure was supposed to do their part after an e-mail was received from the owner of the previous piece. They then sent an e-mail at the end of their piece to the next owner. When we started to automate that procedure, we did it for one specific piece and no one noticed that that part was automated. This is not the best way to handle procedures, but it's widely used in organizations and often you cannot change it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec48"/>XMPP</h1></div></div></div><p>E-mails are slow, unreliable, and often people do not react to them immediately. There are cases where you want to send a real-time message to one of your users. Many organizations rely on XMPP/Jabber for their internal chat system and the great thing is that Ansible is able to directly send messages to XMPP/Jabber users and conference rooms.</p><p>Let's tweak the previous example to send uptime information to a user in the file <code class="literal">uptime_and_xmpp_user.yaml</code>:</p><pre class="programlisting">    - hosts: localhost &#13;
      tasks: &#13;
      - name: Read the machine uptime &#13;
        command: 'uptime -p' &#13;
        register: uptime &#13;
      - name: Send the uptime to user &#13;
        jabber: &#13;
          user: ansible@fale.io &#13;
          password: PASSWORD &#13;
          to: me@fale.io &#13;
          msg: 'Local system uptime is {{ uptime.stdout }}.' &#13;
</pre><div><div><h3 class="title"><a id="note30"/>Note</h3><p>If you want to use the Ansible <code class="literal">jabber</code> task, you will need to have the library <code class="literal">xmpppy</code> installed on the system that will perform the task.</p></div></div><p>As you can see, the <code class="literal">jabber</code> module is very similar to the <code class="literal">mail</code> module and requires similar parameters. In the XMPP case, we don't need to specify the server host and port, since that information is automatically gathered by XMPP from the DNS. In cases where we would need to use a different server host or port, we can use respectively, the <code class="literal">host</code> and <code class="literal">port</code> parameters.</p><p>We can now proceed to execute the script to validate its functionality with the following:</p><pre class="programlisting">
<strong>ansible-playbook -i localhost, uptime_and_xmpp_user.yaml</strong>
</pre><p>We will have a result similar to the following:</p><pre class="programlisting">
<strong>PLAY [localhost] *************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Read the machine uptime] ***********************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Send the uptime to user] ***********************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>localhost         : ok=3    changed=2    unreachable=0    failed=0</strong>
</pre><p>In cases where we want to send a message to a conference room instead of a single user, it is enough to just change the to parameter, adding the appropriate one, that is:</p><pre class="programlisting">    to=sysop@conference.fale.io (mailto:sysop@conference.fale.io)/ansiblebot &#13;
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec49"/>Slack</h1></div></div></div><p>In the last few years, many new chat and collaboration platforms have appeared. One of the most used ones is Slack. Slack is a cloud-based team collaboration tool, and this allows even easier integration with Ansible.</p><p>Let's put the following lines in the file <code class="literal">uptime_and_slack.yaml</code>:</p><pre class="programlisting">    - hosts: localhost &#13;
      tasks: &#13;
      - name: Read the machine uptime &#13;
        command: 'uptime -p' &#13;
        register: uptime &#13;
      - name: Send the uptime to slack channel &#13;
        slack: &#13;
          token: TOKEN &#13;
          channel: '#ansible' &#13;
          msg: 'Local system uptime is {{ uptime.stdout }}.' &#13;
</pre><p>As we discussed, this module has an even simpler syntax than the XMPP one, in fact it only needs to know the token (which you can generate on the Slack website), the channel to send the message to, and the message itself.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>Since version 1.8 of Ansible, the new version of the Slack token is required, for instance: <code class="literal">G522SJP14/D563DW213/7Qws484asdWD4w12Md3avf4FeD</code>.</p></div></div><p>Run the playbook with the following:</p><pre class="programlisting">
<strong>ansible-playbook -i localhost, uptime_and_slack.yaml</strong>
</pre><p>This results in the following output:</p><pre class="programlisting">
<strong>PLAY [localhost] *************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Read the machine uptime] ***********************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Send the uptime to slack channel] **************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>localhost         : ok=3    changed=2    unreachable=0    failed=0</strong>
</pre><p>Since Slack's goal is to make communications more efficient, it allows us to tweak multiple aspects of the message. The most interesting points from my point of view are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">color</code>: This allows you to specify a color bar to be put in the beginning of the message to identify the following states:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Good</strong>: Green bar</li><li class="listitem" style="list-style-type: disc"><strong>Normal</strong>: No bar</li><li class="listitem" style="list-style-type: disc"><strong>Warning</strong>: Yellow bar</li><li class="listitem" style="list-style-type: disc"><strong>Danger</strong>: Red bar</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc"><code class="literal">icon_url</code>: This allows you to change the user image for that message</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec50"/>Rocket Chat</h1></div></div></div><p>Many companies like the functionality of Slack, but have problems to tradeoff the privacy that an on-premises service gives you for the Slack functionality. Rocket Chat is open source software that implements most of the features of Slack, as well as the majority of its interface. Being open source, every company can install it on-premises and manage it in a way that is compliant with their IT rules.</p><p>As Rocket Chat's goal is to be a drop-in replacement for Slack, from our point of view, very few changes need to be done, in fact, we can create the file <code class="literal">uptime_and_rocket.yaml</code> with the following content:</p><pre class="programlisting">    - hosts: localhost &#13;
      tasks: &#13;
      - name: Read the machine uptime &#13;
        command: 'uptime -p' &#13;
        register: uptime &#13;
      - name: Send the uptime to rocketchat channel &#13;
        rocketchat: &#13;
          token: TOKEN &#13;
          domain: chat.example.com &#13;
          channel: '#ansible' &#13;
          msg: 'Local system uptime is {{ uptime.stdout }}.' &#13;
</pre><p>As you can see, the only lines that changed are the 6th and 7th, where the word <code class="literal">slack</code> has been replaced by <code class="literal">rocketchat</code>. Also, we need to add the domain field specifying where our installation of Rocket Chat is located.</p><p>Run the code with the following:</p><pre class="programlisting">
<strong>ansible-playbook -i localhost, uptime_and_rocketchat.yaml</strong>
</pre><p>This results in the following output:</p><pre class="programlisting">
<strong>PLAY [localhost] *************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Read the machine uptime] ***********************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Send the uptime to rocketchat channel] *********************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>localhost         : ok=3    changed=2    unreachable=0    failed=0</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec51"/>Internet Relay Chat (IRC)</h1></div></div></div><p>IRC is probably the most well-known and widely-used chat protocol of the 1990s and it's still used today, mainly due to its use in open source communities and its simplicity. From an Ansible perspective, IRC is a pretty straightforward module and we can use it as in the following example (to be put in the <code class="literal">uptime_and_irc.yaml</code> file):</p><pre class="programlisting">    - hosts: localhost &#13;
      tasks: &#13;
      - name: Read the machine uptime &#13;
        command: 'uptime -p' &#13;
        register: uptime &#13;
      - name: Send the uptime to IRC channel &#13;
        irc: &#13;
          port: 6669 &#13;
          server: irc.example.net &#13;
          channel: #desired_channel &#13;
          msg: 'Local system uptime is {{ uptime.stdout }}.' &#13;
          color: green &#13;
</pre><div><div><h3 class="title"><a id="note32"/>Note</h3><p>You need the <code class="literal">socket</code> Python library installed to use the Ansible IRC module.</p></div></div><p>In the IRC module, the following fields are required:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">channel</code>: This is to specify in which channel your message will be delivered</li><li class="listitem" style="list-style-type: disc"><code class="literal">msg</code>: This is the message you want to send</li></ul></div><p>Other configurations you will usually specify are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">server</code>: Select <code class="literal">server</code> to connect to, if not <code class="literal">localhost</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">port</code>: Select <code class="literal">port</code> to connect to, if not <code class="literal">6667</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">color</code>: This to specify the message <code class="literal">color</code>, if not <code class="literal">black</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">nick</code>: This to specify the <code class="literal">nick</code> sending the message, if not <code class="literal">ansible</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">use_ssl</code>: Use SSL and TLS security</li><li class="listitem" style="list-style-type: disc"><code class="literal">style</code>: If you want to send your message with bold, italic, underline, or reverse style</li></ul></div><p>Run the code with the following:</p><pre class="programlisting">
<strong>ansible-playbook uptime_and_irc.yaml</strong>
</pre><p>This results in the following output:</p><pre class="programlisting">
<strong>PLAY [localhost] *************************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Read the machine uptime] ***********************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>TASK [Send the uptime to IRC channel] ****************************</strong>
<strong>changed: [localhost]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>localhost         : ok=3    changed=2    unreachable=0    failed=0</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec52"/>Amazon Simple Notification Service</h1></div></div></div><p>Sometimes, you want your playbooks to be agnostic in the way you receive the alert. This has several advantages, mainly in terms of flexibility. In fact, in this model, Ansible will deliver the messages to a notification service and the notification service will then take care of delivering them. <strong>Amazon Simple Notification Service</strong> (<strong>SNS</strong>) is not the only notification service available, but it's probably the most used. SNS has the following components:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Messages</strong>: Messages generated by publishers identified by a UUID</li><li class="listitem" style="list-style-type: disc"><strong>Publishers</strong>: Programs generating messages</li><li class="listitem" style="list-style-type: disc"><strong>Topics</strong>: Named groups of messages, which can be thought of in a similar way to chat channels or rooms</li><li class="listitem" style="list-style-type: disc"><strong>Subscribers</strong>: Clients that will receive all messages published in the topics they have subscribed to</li></ul></div><p>So in our case, we will have, specifically:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Messages</strong>: Ansible notifications</li><li class="listitem" style="list-style-type: disc"><strong>Publishers</strong>: Ansible itself</li><li class="listitem" style="list-style-type: disc"><strong>Topics</strong>: Probably different topics to group messages based on the system and/or the kind of notification (for example, storage, networking, computing)</li><li class="listitem" style="list-style-type: disc"><strong>Subscribers</strong>: The people in your team that has to be notified</li></ul></div><p>As we said, one of the big advantages of SNS is that you can decouple between the way Ansible sends messages (SNS API) and the way your users will receive the messages. In fact, you will be able to choose different delivery systems per user and per topic rules, and eventually you can change them dynamically to ensure that the messages are sent in the best way possible for any situation. The five ways SNS can send messages, at the moment, are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Amazon <strong>lambda</strong> functions (serverless functions written in Python, Java, and JavaScript)</li><li class="listitem" style="list-style-type: disc">Amazon <strong>Simple Queue Service</strong> (<strong>SQS</strong>) (a message queueing system)</li><li class="listitem" style="list-style-type: disc">E-mail</li><li class="listitem" style="list-style-type: disc">HTTP(S) call</li><li class="listitem" style="list-style-type: disc">SMS</li></ul></div><p>Let's see how we can send SNS messages with Ansible. To do so, we can create a file called <code class="literal">uptime_and_sns.yaml</code> with the following content:</p><pre class="programlisting">    - hosts: localhost &#13;
      tasks: &#13;
      - name: Read the machine uptime &#13;
        command: 'uptime -p' &#13;
        register: uptime &#13;
      - name: Send the uptime to SNS &#13;
        sns: &#13;
          msg: 'Local system uptime is {{ uptime.stdout }}.' &#13;
          subject: "System uptime" &#13;
          topic: "uptime" &#13;
</pre><p>In this example, we are using the <code class="literal">msg</code> key to set the message that will be sent, the <code class="literal">topic</code> to choose the most appropriate topic, and <code class="literal">subject</code> that will be used as the subject for e-mail deliveries. There are many other options you can set. Mainly, they are useful for sending different messages using different delivery methods. For instance, it would make sense to send a short message via SMS (in the end, the first S in SMS means <strong>short</strong>) and longer and more detailed messages via e-mails. To do so, the SNS module provides us with the following delivery-specific options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">E-mail</li><li class="listitem" style="list-style-type: disc">HTTP</li><li class="listitem" style="list-style-type: disc">HTTPS</li><li class="listitem" style="list-style-type: disc">SMS</li><li class="listitem" style="list-style-type: disc">SQS</li></ul></div><p>This module allows us also to set three AWS-specific parameters that I've not specified because I have a configuration file for AWS credentials and options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">aws_access_key</code>: AWS access key, if not specified the environmental variable, <code class="literal">aws_access_key</code> will be considered or the content of <code class="literal">~/.aws/credentials</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">aws_secret_key</code>: AWS secret key, if not specified the environmental variable, <code class="literal">aws_secret_key</code> will be considered or the content of <code class="literal">~/.aws/credentials</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">region</code>: AWS region to use, if not specified the environmental variable, <code class="literal">ec2_region</code> will be considered or the content of <code class="literal">~/.aws/config</code></li></ul></div><p>Run the code with the following command:</p><pre class="programlisting">
<strong>ansible-playbook uptime_and_sns.yaml</strong>
</pre><p>This will result in the following output:</p><pre class="programlisting">
<strong>    PLAY [localhost] ************************************************* &#13;
 &#13;
    TASK [setup] ***************************************************** &#13;
    ok: [localhost] &#13;
&#13;
 &#13;
    TASK [Read the machine uptime] *********************************** &#13;
    changed: [localhost] &#13;
&#13;
 &#13;
    TASK [Send the uptime to SNS] ************************************ &#13;
    changed: [localhost] &#13;
&#13;
 &#13;
    PLAY RECAP ******************************************************* &#13;
    localhost         : ok=3    changed=2    unreachable=0    failed=0</strong>
</pre></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec53"/>Nagios</h1></div></div></div><p>Nagios is one of the most used tools for controlling the status of services and servers. Nagios is capable of regularly auditing the state of servers and services, and notifying users in case of problems. If you have Nagios in your environment, you need to be very careful when you administer your machines, because in cases where Nagios finds servers or services in an unhealthy state, it will start sending e-mails, SMS messages, and calls to your whole team. When you run Ansible scripts against nodes that are controlled by Nagios you have to be even more careful, because you risk e-mails, SMS messages, and calls being triggered during the night or other inappropriate times. To avoid this, Ansible is able to notify Nagios beforehand, so that Nagios does not send notifications in that time window even if some services are down (for instance, because they are rebooted) or other checks fail.</p><p>In this example, we are going to stop a service, wait for 5 minutes, then start it again since this would actually create a Nagios failure in the majority of configurations. In fact, usually, Nagios is configured to accept up to two consecutive failures of a test (with usually one execution every minute) putting the service in a warning state before raising a critical state. We are going to create the file, <code class="literal">long_restart_service.yaml</code> which will trigger the Nagios critical state:</p><pre class="programlisting">    - hosts: ws01.fale.io &#13;
      tasks: &#13;
      - name: Stop the HTTPd service &#13;
        service: &#13;
          name: httpd &#13;
          state: stopped &#13;
      - name: Wait for 5 minutes &#13;
        pause: &#13;
          minutes: 5 &#13;
      - name: Start the HTTPd service &#13;
        service: &#13;
          name: httpd &#13;
          state: stopped &#13;
</pre><p>Run the code with the following:</p><pre class="programlisting">
<strong>ansible-playbook long_restart_service.yaml</strong>
</pre><p>This should trigger a Nagios alert and result in the following output:</p><pre class="programlisting">
<strong>    PLAY [ws01.fale.io] ********************************************** &#13;
 &#13;
    TASK [setup] ***************************************************** &#13;
    ok: [ws01.fale.io] &#13;
&#13;
 &#13;
    TASK [Stop the HTTpd service] ************************************ &#13;
    changed: [ws01.fale.io] &#13;
&#13;
 &#13;
    TASK [Wait for 5 minutes] **************************************** &#13;
    changed: [ws01.fale.io] &#13;
&#13;
 &#13;
    TASK [Start the HTTpd service] *********************************** &#13;
    changed: [ws01.fale.io] &#13;
&#13;
 &#13;
    PLAY RECAP ******************************************************* &#13;
    ws01.fale.io      : ok=4    changed=3    unreachable=0    failed=0</strong>
</pre><div><div><h3 class="title"><a id="note33"/>Note</h3><p>If no Nagios alert has been triggered, either your Nagios installation probably does not track that service, or 5 minutes is not enough to make it raise a critical state.</p></div></div><p>We can now create a very similar playbook that will ensure that Nagios will not send any alerts. We are going to create a file called <code class="literal">long_restart_service_no_alert.yaml</code> with the following content:</p><pre class="programlisting">    - hosts: ws01.fale.io &#13;
      tasks: &#13;
      - name: Silence Nagios &#13;
    nagios: &#13;
      action: disable_alerts &#13;
      service: httpd &#13;
      host: '{{ inventory_hostname }}' &#13;
    delegate_to: nagios.fale.io &#13;
  - name: Stop the HTTPd service &#13;
    service: &#13;
      name: httpd &#13;
      state: stopped &#13;
  - name: Wait for 5 minutes &#13;
    pause: &#13;
      minutes: 5 &#13;
  - name: Start the HTTPd service &#13;
    service: &#13;
      name: httpd &#13;
      state: stopped &#13;
  - name: Desilence Nagios &#13;
    nagios: &#13;
      action: enable_alerts &#13;
      service: httpd &#13;
      host: '{{ inventory_hostname }}' &#13;
    delegate_to: nagios.fale.io &#13;
</pre><p>As you can see, we have added two tasks. The first to inform Nagios not to send alerts for the HTTPd service on the given host, and the second to inform Nagios to start sending alerts for the service again. Even if you do not specify the service and therefore all alerts on that host are silenced, my advice is to disable only the alert you are going to break so that Nagios is still able to work normally on the majority of your infrastructure.</p><div><div><h3 class="title"><a id="note34"/>Note</h3><p>If the playbook run fails before reaching the re-enablement of the alerts, your alerts will stay <em>disabled</em>.</p></div></div><p>This module's goal is to toggle the Nagios alerts as well as schedule downtime, and from Ansible 2.2 this module can also unscheduled downtimes.</p><p>Run the code with the following command:</p><pre class="programlisting">
<strong>ansible-playbook long_restart_service_no_alert.yaml</strong>
</pre><p>This should trigger a Nagios alert and result in the following output:</p><pre class="programlisting">
<strong>PLAY [ws01.fale.io] **********************************************</strong>
<strong>TASK [setup] *****************************************************</strong>
<strong>ok: [ws01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Silence Nagios] ********************************************</strong>
<strong>changed: [nagios.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Stop the HTTpd service] ************************************</strong>
<strong>changed: [ws01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Wait for 5 minutes] ****************************************</strong>
<strong>changed: [ws01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Start the HTTpd service] ***********************************</strong>
<strong>changed: [ws01.fale.io]&#13;
&#13;
</strong>
<strong>TASK [Desilence Nagios] ******************************************</strong>
<strong>changed: [nagios.fale.io]&#13;
&#13;
</strong>
<strong>PLAY RECAP *******************************************************</strong>
<strong>ws01.fale.io      : ok=4    changed=3    unreachable=0    failed=0</strong>
<strong>nagios.fale.io    : ok=2    changed=2    unreachable=0    failed=0</strong>
</pre><div><div><h3 class="title"><a id="note35"/>Note</h3><p>To use the Nagios module, you need to delegate the action to your Nagios server.</p></div></div><p>Sometimes, what you want to achieve with a Nagios integration is exactly the opposite, in fact, you are not interested to silentiate it, but you want Nagios to handle your test results. A common case is if you want to leverage your Nagios configuration to notify your administrators of the output of a task. To do so, we can use the Nagios <code class="literal">nsca</code> utility, integrating it into our playbooks. Ansible does not yet have a specific module for managing it, but you can always run it using the command module, leveraging the <code class="literal">send_nsca</code> CLI program.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>Summary</h1></div></div></div><p>In this chapter, we have seen how we can teach Ansible how to send notifications to other systems and/or people.</p><p>In the next chapter, we will learn how to create a module so that you can extend Ansible to perform any kind of task.</p></div></body></html>