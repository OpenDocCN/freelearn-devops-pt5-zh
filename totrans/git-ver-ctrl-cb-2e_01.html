<html><head></head><body>
        

                            
                    <h1 class="header-title">Navigating Git</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Git's objects</li>
<li>The three stages</li>
<li>Viewing the DAG</li>
<li>Extracting fixed issues</li>
<li>Getting a list of the changed files</li>
<li>Viewing the history with gitk</li>
<li>Finding commits in the history</li>
<li>Searching through the history code</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>In this chapter, we will take a look at Git's data model. We will learn how Git references its objects and how the history is recorded. We will learn how to navigate the history, from finding certain text snippets in commit messages, to the introducing a particular string in the code.</p>
<p>The data model of Git is different from other common <strong>version control systems</strong> (<strong>VCSs</strong>) in the way Git handles its data. Traditionally, a VCS will store its data as an initial file, followed by a list of patches for each new version of the file:</p>
<div><img class="alignnone size-full wp-image-381 image-border" src="img/36c11aeb-a197-4e01-bcfc-d9ad3d453752.png" style="width:39.67em;height:14.58em;"/></div>
<p>Git is different: Instead of the regular file and patches list, Git records a snapshot of all the files tracked by Git and their paths relative to the repository root—that is, the files tracked by Git in the filesystem tree. Each commit in Git records the full tree state. If a file does not change between commits, Git will not store the file again. Instead, Git stores a link to the file. This is shown in the diagram below where you see how the files will be after every commit/version.</p>
<div><div><img class="alignnone size-full wp-image-382 image-border" src="img/54662a83-7cbd-40b5-973b-dbf46a31cdd9.png" style="width:39.33em;height:14.25em;"/></div>
</div>
<p>This is what makes Git different from most other VCSs, and, in the following chapters, we will explore some of the benefits of this powerful model.</p>
<p>The way Git references files and directories is directly built into the data model. In short, the Git data model can be summarized as shown in the following diagram:</p>
<div><img class="alignnone size-full wp-image-383 image-border" src="img/7a16ae26-fd8c-48f1-87b0-09b55e763323.png" style="width:24.50em;height:13.83em;"/></div>
<p>The <kbd>commit</kbd> object points to the root tree. The root tree points to subtrees and files.</p>
<p>Branches and tags point to a <kbd>commit</kbd> object and the <kbd>HEAD</kbd> object points to the <strong>branch</strong> that is currently checked out. So, for every commit, the full tree state and snapshot are identified by the root tree.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Git's objects</h1>
                
            
            
                
<p>Now, since you know that Git stores every commit as a full tree state or snapshot, let's take a closer look at the object's Git store in the repository.</p>
<p>Git's object storage is a key-value storage, the key being the ID of the object and the value being the object itself. The key is an SHA-1 hash of the object, with some additional information, such as size. There are four types of objects in Git, as well as branches (which are not objects, but which are important) and the special <kbd>HEAD</kbd> pointer that refers to the branch/commit currently being checked out. The four object types are as follows:</p>
<ul>
<li>Files, or blobs as they are also called in the Git context</li>
<li>Directories, or trees in the Git context</li>
<li>Commits</li>
<li>Tags</li>
</ul>
<p>We will start by looking at the most recent <kbd>commit</kbd> object in the repository we just cloned, keeping in mind that the special <kbd>HEAD</kbd> pointer points to the branch that is currently being checked out.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To view the objects in the Git database, we first need a repository to be examined. For this recipe, we will clone an example repository in the following location:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition.git</strong>
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition</strong></pre>
<p>Now you are ready to look at the objects in the database. We will start by looking first at the <kbd>commit</kbd> object, followed by the trees, the files, and finally, the branches and tags.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>Let's take a closer look at the object's Git stores in the repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The commit object</h1>
                
            
            
                
<p>The Git's special <kbd>HEAD</kbd> object always points to the current snapshot/commit, so we can use that as the target for our request of the commit that we want to have a look at:</p>
<pre><strong>$ git cat-file -p HEAD</strong>
<strong>tree 34fa038544bcd9aed660c08320214bafff94150b</strong><br/><strong>parent 5c662c018efced42ca5e9cce709787c40a849f34</strong><br/><strong>author John Doe &lt;john.doe@example.com&gt; 1386933960 +0100</strong><br/><strong>committer John Doe &lt;john.doe@example.com&gt; 1386941455 +0100</strong><strong>
</strong></pre>
<p>This is the subject line of the commit message. It should be followed by a blank line and then the body, which is this text. Here, you can use multiple paragraphs to explain your commit. It's like an email with a subject and a body to try to attract people's attention to the subject.</p>
<p>The <kbd>cat-file</kbd> command with the <kbd>-p</kbd> option prints the object given on the command line; in this case, <kbd>HEAD</kbd>, points to <kbd>master</kbd>, which, in turn, points to the most recent commit on the branch.</p>
<p>We can now see the <kbd>commit</kbd> object, consisting of the root tree (<kbd>tree</kbd>), the parent <kbd>commit</kbd> object's ID (<kbd>parent</kbd>), the author and timestamp information (<kbd>author</kbd>), the committer and timestamp information (<kbd>committer</kbd>), and the commit message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The tree object</h1>
                
            
            
                
<p>To see the <kbd>tree</kbd> object, we can run the same command on the tree, but with the tree ID (<kbd>34fa038544bcd9aed660c08320214bafff94150b</kbd>) as the target:</p>
<pre><strong>$ git cat-file -p 34fa038544bcd9aed660c08320214bafff94150b </strong>
<strong>100644 blob f21dc2804e888fee6014d7e5b1ceee533b222c15    README.md</strong>
<strong>040000 tree abc267d04fb803760b75be7e665d3d69eeed32f8    a_sub_directory</strong>
<strong>100644 blob b50f80ac4d0a36780f9c0636f43472962154a11a    another-file.txt</strong>
<strong>100644 blob 92f046f17079aa82c924a9acf28d623fcb6ca727    cat-me.txt</strong>
<strong>100644 blob bb2fe940924c65b4a1cefcbdbe88c74d39eb23cd    hello_world.c</strong></pre>
<p>We can also specify that we want the <kbd>tree</kbd> object from the commit pointed to by <kbd>HEAD</kbd> by specifying <kbd>git cat-file -p HEAD^{tree}</kbd>, which would give the same results as the previous command. The special notation <kbd>HEAD^{tree}</kbd> means that from the reference given, <kbd>HEAD</kbd> recursively dereferences the object at the reference until a <kbd>tree</kbd> object is found.</p>
<p>The first <kbd>tree</kbd> object is the root <kbd>tree</kbd> object found from the commit pointed to by the <kbd>master</kbd> branch, which is pointed to by <kbd>HEAD</kbd>. A generic form of the notation is <kbd>&lt;rev&gt;^&lt;type&gt;</kbd>, and will return the first object of <kbd>&lt;type&gt;</kbd>, searching recursively from <kbd>&lt;rev&gt;</kbd>.</p>
<p>From the <kbd>tree</kbd> object, we can see what it contains: the file type/permissions, type (<kbd>tree</kbd>/<kbd>blob</kbd>), ID, and pathname:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Type/</strong></p>
<p><strong>Permissions</strong></p>
</td>
<td>
<p><strong>Type</strong></p>
</td>
<td>
<p><strong>ID/SHA-1</strong></p>
</td>
<td>
<p><strong>Pathname</strong></p>
</td>
</tr>
<tr>
<td>
<p>100644</p>
</td>
<td>
<p><kbd>blob</kbd></p>
</td>
<td>
<p><kbd>f21dc2804e888fee6014</kbd><br/>
<kbd>d7e5b1ceee533b222c15</kbd></p>
</td>
<td>
<p><kbd>README.md</kbd></p>
</td>
</tr>
<tr>
<td>
<p>040000</p>
</td>
<td>
<p><kbd>tree</kbd></p>
</td>
<td>
<p><kbd>abc267d04fb803760b75</kbd><br/>
<kbd>be7e665d3d69eeed32f8</kbd></p>
</td>
<td>
<p><kbd>a_sub_directory</kbd></p>
</td>
</tr>
<tr>
<td>
<p>100644</p>
</td>
<td>
<p><kbd>blob</kbd></p>
</td>
<td>
<p><kbd>b50f80ac4d0a36780f9c</kbd><br/>
<kbd>0636f43472962154a11a</kbd></p>
</td>
<td>
<p><kbd>another-file.txt</kbd></p>
</td>
</tr>
<tr>
<td>
<p>100644</p>
</td>
<td>
<p><kbd>blob</kbd></p>
</td>
<td>
<p><kbd>92f046f17079aa82c924</kbd><br/>
<kbd>a9acf28d623fcb6ca727</kbd></p>
</td>
<td>
<p><kbd>cat-me.txt</kbd></p>
</td>
</tr>
<tr>
<td>
<p>100644</p>
</td>
<td>
<p><kbd>blob</kbd></p>
</td>
<td>
<p><kbd>bb2fe940924c65b4a1ce</kbd><br/>
<kbd>fcbdbe88c74d39eb23cd</kbd></p>
</td>
<td>
<p><kbd>hello-world.c</kbd></p>
</td>
</tr>
</tbody>
</table>
<div><h1 class="header-title">The blob object</h1>
                
            
            
                
<p>Now, we can investigate the <kbd>blob</kbd> (file) object. We can do this using the same command, giving the <kbd>blob</kbd> ID as the target for the <kbd>cat-me.txt</kbd> file:</p>
<pre><strong>$ git cat-file -p 92f046f17079aa82c924a9acf28d623fcb6ca727</strong></pre>
<p>The content of the file is <kbd>cat-me.txt</kbd>.</p>
<pre><strong>Not really that exciting, huh?</strong></pre>
<p>This is simply the content of the file, which we can also get by running a normal <kbd>cat cat-me.txt</kbd> command. So, the objects are tied together, blobs to trees, trees to other trees, and the root tree to the <kbd>commit</kbd> object, all connected by the SHA-1 identifier of the object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The branch object</h1>
                
            
            
                
<p>The <kbd>branch</kbd> object is not really like any other Git objects; you can't print it using the <kbd>cat-file</kbd> command as we can with the others (if you specify the <kbd>-p</kbd> pretty print, you'll just get the <kbd>commit</kbd> object it points to), as shown in the following code:</p>
<pre><strong>$ git cat-file master</strong>
<strong>usage: git cat-file (-t|-s|-e|-p|&lt;type&gt;|--textconv) &lt;object&gt;</strong>
<strong>or: git cat-file (--batch|--batch-check) &lt; &lt;list_of_objects&gt;</strong>
    
<strong>&lt;type&gt; can be one of: blob, tree, commit, tag.</strong>
<strong>...</strong>
<strong>$ git cat-file -p master</strong>
<strong>tree 34fa038544bcd9aed660c08320214bafff94150b</strong>
<strong>parent a90d1906337a6d75f1dc32da647931f932500d83</strong>
<strong>...</strong></pre>
<p>Instead, we can take a look at the branch inside the <kbd>.git</kbd> folder where the whole Git repository is stored. If we open the text file <kbd>.git/refs/heads/master</kbd>, we can actually see the commit ID that the <kbd>master</kbd> branch points to. We can do this using <kbd>cat</kbd>, as follows:</p>
<pre><strong>$ cat .git/refs/heads/master</strong>
<strong>13dcada077e446d3a05ea9cdbc8ecc261a94e42d</strong><strong> </strong></pre>
<p>We can verify that this is the latest commit by running <kbd>git log -1</kbd>:</p>
<pre><strong>$ git log -1</strong>
<strong>commit 34acc370b4d6ae53f051255680feaefaf7f7850d (HEAD -&gt; master, origin/master, origin/HEAD)</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Fri Dec 13 12:26:00 2013 +0100</strong>
    
<strong>This is the subject line of the commit message</strong>
<strong>...</strong></pre>
<p>We can also see that <kbd>HEAD</kbd> is pointing to the active branch by using <kbd>cat</kbd> with the <kbd>.git/HEAD</kbd> file:</p>
<pre><strong>$ cat .git/HEAD</strong>
<strong>ref: refs/heads/master</strong></pre>
<p>The <kbd>branch</kbd> object is simply a pointer to a commit, identified by its SHA-1 hash.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The tag object</h1>
                
            
            
                
<p>The last object to be analyzed is the <kbd>tag</kbd> object. There are three different kinds of tag: a lightweight (just a <kbd>label</kbd>) tag, an annotated tag, and a signed tag. In the example repository, there are two annotated tags:</p>
<pre><strong>$ git tag</strong>
<strong>v0.1</strong>
<strong>v1.0</strong></pre>
<p>Let's take a closer look at the <kbd>v1.0</kbd> tag:</p>
<pre><strong>$ git cat-file -p v1.0</strong>
<strong>object f55f7383b57ad7c11cf56a7c55a8d738af4741ce</strong><br/><strong>type commit</strong><br/><strong>tag v1.0</strong><br/><strong>tagger John Doe &lt;john.doe@example.com&gt; 1526017989 +0200</strong><br/><br/><strong>We got the hello world C program merged, let's call that a release 1.0</strong>  </pre>
<p>As you can see, the tag consists of an object—which, in this case, is the latest commit on the master branch—the object's type (commits, blobs, and trees can be tagged), the tag name, the tagger and timestamp, and finally the tag message.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Git command <kbd>git cat-file -p</kbd> will print the object given as an input. Normally, it is not used in everyday Git commands, but it is quite useful to investigate how it ties the objects together.</p>
<p>We can also verify the output of <kbd>git cat-file</kbd> by rehashing it with the Git command <kbd>git hash-object</kbd>; for example, if we want to verify the <kbd>commit</kbd> object at <kbd>HEAD</kbd> (<kbd>34acc370b4d6ae53f051255680feaefaf7f7850d</kbd>), we can run the following command:</p>
<pre><strong>$ git cat-file -p HEAD | git hash-object -t commit --stdin<br/></strong><strong>13dcada077e446d3a05ea9cdbc8ecc261a94e42d<br/></strong></pre>
<p>If you see the same commit hash as <kbd>HEAD</kbd> pointing towards you, you can verify whether it is correct using <kbd>git log -1</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are many ways to see the objects in the Git database. The <kbd>git ls-tree</kbd> command can easily show the content of trees and subtrees, and <kbd>git show</kbd> can show the Git objects, but in a different way.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The three stages</h1>
                
            
            
                
<p>We have seen the different objects in Git, but how do we create them? In this example, we'll see how to create a <kbd>blob</kbd>, <kbd>tree</kbd>, and <kbd>commit</kbd> object in the repository. We'll also learn about the three stages of creating a commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We'll use the same <kbd>Git-Version-Control-Cookbook-Second-Edition</kbd> repository that we saw in the last recipe:</p>
<pre><strong>$ git clone https://github.com/PacktPublishing/Git-Version-Control-Cookbook-Second-Edition.git</strong>
<strong>$ cd </strong><strong>Git-Version-Control-Cookbook-Second-Edition</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>First, we'll make a small change to the file and check <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo "Another line" &gt;&gt; another-file.txt</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
<strong>Changes not staged for commit:</strong>
<strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
<strong>modified:   another-file.txt</strong>
    
<strong>no changes added to commit (use "git add" and/or "git commit -a")</strong></pre>
<p style="padding-left: 60px">This, of course, just tells us that we have modified <kbd>another-file.txt</kbd> and we need to use <kbd>git add</kbd> to stage it.</p>
<ol start="2">
<li>Let's add the <kbd>another-file.txt</kbd> file and run <kbd>git status</kbd> again:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git add another-file.txt</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
<strong>Changes to be committed:</strong>
<strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
<strong>modified:   another-file.txt</strong></pre>
<p style="padding-left: 60px">The file is now ready to be committed, just as you have probably seen before. But what happens during the <kbd>add</kbd> command? The <kbd>add</kbd> command, generally speaking, moves files from the working directory to the staging area; however, this is not all that actually happens, though you don't see it. When a file is moved to the staging area, the SHA-1 hash of the file is created and the <kbd>blob</kbd> object is written to Git's database. This happens every time a file is added, but if nothing changes for a file, it means that it is already stored in the database. At first, this might seem that the database will grow quickly, but this is not the case. Garbage collection kicks in at times, compressing, and cleaning up the database and keeping only the objects that are required.</p>
<ol start="3">
<li>We can edit the file again and run <kbd>git status</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ echo 'Whoops almost forgot this' &gt;&gt; another-file.txt</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
   
<strong>Changes to be committed:</strong>
<strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
<strong>modified:   another-file.txt</strong>
    
<strong>Changes not staged for commit:</strong>
<strong>(use "git add &lt;file&gt;..." to update what will be committed)</strong>
<strong>(use "git checkout -- &lt;file&gt;..." to discard changes in working directory)</strong>
    
<strong>modified:   another-file.txt</strong></pre>
<p class="mce-root" style="padding-left: 60px">Now, the file shows up in both the <kbd>Changes to be committed</kbd> and <kbd>Changes not staged for commit</kbd> sections. This looks a bit weird at first, but there is, of course, a reason for this. When we added the file the first time, the content of it was hashed and stored in Git's database. The changes arising from the second change to the file have not yet been hashed and written to the database; it only exists in the working directory. Therefore, the file shows up in both the <kbd>Changes to be committed</kbd> and <kbd>Changes not staged for commit</kbd> sections; the first change is ready to be committed, the second is not. Let's also add the second change:</p>
<pre style="padding-left: 60px"><strong>$ git add another-file.txt</strong>
<strong>$ git status</strong>
<strong>On branch master</strong>
<strong>Your branch is up-to-date with 'origin/master'.</strong>
    
<strong>Changes to be committed:</strong>
<strong>(use "git reset HEAD &lt;file&gt;..." to unstage)</strong>
    
<strong>modified:   another-file.txt</strong>  </pre>
<ol start="4">
<li>Now, all the changes we have made to the file are ready to be committed, and we can record a commit:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git commit -m 'Another change to another file'</strong>
<strong>[master 99fac83] Another change to another file</strong>
<strong>1 file changed, 2 insertions(+)</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As we learned previously, the <kbd>add</kbd> command creates the <kbd>blob</kbd>, <kbd>tree</kbd>, and <kbd>commit</kbd> objects; however, they are also created when we run the <kbd>commit</kbd> command. We can view these objects using the <kbd>cat-file</kbd> command, as we saw in the previous recipe:</p>
<pre><strong>$ git cat-file -p HEAD</strong>
<strong>tree 162201200b5223d48ea8267940c8090b23cbfb60</strong>
<strong>parent 13dcada077e446d3a05ea9cdbc8ecc261a94e42d</strong>
<strong>author John Doe &lt;john.doe@example.com&gt; 1524163792 +0200</strong>
<strong>committer John Doe &lt;john.doe@example.com&gt; 1524163792 +0200</strong></pre>
<p>Making changes to another file.</p>
<p>The <kbd>root-tree</kbd> object from the commit is as follows:</p>
<pre style="padding-left: 30px"><strong>$ git cat-file -p HEAD^{tree}</strong>
<strong>100644 blob f21dc2804e888fee6014d7e5b1ceee533b222c15  README.md</strong>
<strong>040000 tree abc267d04fb803760b75be7e665d3d69eeed32f8  a_sub_directory</strong>
<strong>100644 blob 35d31106c5d6fdb38c6b1a6fb43a90b183011a4b  another-file.txt</strong>
<strong>100644 blob 92f046f17079aa82c924a9acf28d623fcb6ca727  cat-me.txt</strong>
<strong>100644 blob bb2fe940924c65b4a1cefcbdbe88c74d39eb23cd  hello_world.c</strong></pre>
<p>From the previous recipe, we know that the SHA-1 of the root tree was <kbd>34fa038544bcd9aed660c08320214bafff94150b</kbd> and the SHA-1 of the <kbd>another-file.txt</kbd> file was <kbd>b50f80ac4d0a36780f9c0636f43472962154a11a</kbd>, and, as expected, they changed in our latest commit when we updated the <kbd>another-file.txt</kbd> file. We added the same file, <kbd>another-file.txt</kbd>, twice before we created the commit, recording the changes to the history of the repository. We also learned that the <kbd>add</kbd> command creates a blob object when called. So, in the Git database, there must have been an object similar to the content of <kbd>another-file.txt</kbd> the first time we added the file to the staging area. We can use the <kbd>git fsck</kbd> command to check for dangling objects—that is, objects that are not referred to by other objects or references:</p>
<pre><strong>$ git fsck --dangling</strong>
<strong>Checking object directories: 100% (256/256), done.</strong>
<strong>dangling blob ad46f2da274ed6c79a16577571a604d3281cd6d9</strong>  </pre>
<p>Let's check the content of the blob using the following command:</p>
<pre><strong>$ git cat-file -p ad46f2da274ed6c79a16577571a604d3281cd6d9</strong>
<strong>This is just another file</strong>
<strong>Another line</strong></pre>
<p>The blob was, as expected, similar to the content of <kbd>another-file.txt</kbd> when we added it to the staging area the first time.</p>
<p>The following diagram describes the tree stages and the commands used to move between the stages:</p>
<div><img class="alignnone size-full wp-image-449 image-border" src="img/8b8aecf9-b35d-4116-9a8d-ec4e9ed6f19c.png" style="width:43.42em;height:24.75em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>For more examples and information on the <kbd>cat-file</kbd> and <kbd>fsck</kbd> commands, please consult the Git documentation at <a href="https://git-scm.com/docs/git-cat-file">https://git-scm.com/docs/git-cat-file</a> and <a href="https://git-scm.com/docs/git-fsck">https://git-scm.com/docs/git-fsck</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Viewing the DAG</h1>
                
            
            
                
<p>The history in Git is formed from the <kbd>commit</kbd> objects; as development advances, branches are created and merged, and the history will create a directed acyclic graph, the DAG, because of the way that Git ties a commit to its parent commit. The DAG makes it easy to see the development of a project based on the commits.</p>
<p>Please note that the arrows in the following diagram are dependency arrows, meaning that each commit points to its parent commit(s), which is why the arrows point in the opposite direction to the normal flow of time:</p>
<div><div><img class="alignnone size-full wp-image-385 image-border" src="img/77587a7b-661f-427c-9ce6-0a398888ed32.png" style="width:42.33em;height:16.00em;"/></div>
</div>
<p>A graph of the example repository with abbreviated commit IDs</p>
<p>You can view the history (the DAG) in Git by using its <kbd>git log</kbd> command. There are also a number of visual Git tools that can graphically display the history. This section will show some features of <kbd>git log</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>We will use the example repository from the last section and ensure that the master branch is pointing to <kbd>34acc37</kbd>:</p>
<pre><strong>$ git checkout master &amp;&amp; git reset --hard 34acc37</strong></pre>
<p>In the previous command, we only use the first seven characters (<kbd>34acc37</kbd>) of the commit ID; this is fine as long as the abbreviated ID that is used is unique in the repository.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<ol>
<li>The simplest way to see the history is to use the <kbd>git log</kbd> command; this will display the history in reverse chronological order. The output is paged through <kbd>less</kbd> and can be further limited, for example, by providing only the number of commits in the history to be displayed:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log -3</strong></pre>
<ol start="2">
<li>This will display the following result:</li>
</ol>
<pre style="padding-left: 60px"><strong>commit 34acc370b4d6ae53f051255680feaefaf7f7850d</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Fri Dec 13 12:26:00 2013 +0100</strong>
    
<strong>This is the subject line of the commit message.</strong>
    
    
<strong>It should be followed by a blank line then the body, which is this text. Here </strong>
<strong>you can have multiple paragraphs etc. and explain your commit. It's like an </strong>
<strong>email with subject and body, so try to get people's attention in the subject</strong>
    
<strong>commit a90d1906337a6d75f1dc32da647931f932500d83</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Fri Dec 13 12:17:42 2013 +0100</strong>
    
<strong>Instructions for compiling hello_world.c</strong>
    
<strong>commit 485884efd6ac68cc7b58c643036acd3cd208d5c8</strong>
<strong>Merge: 44f1e05 0806a8b</strong>
<strong>Author: John Doe &lt;john.doe@example.com&gt;</strong>
<strong>Date:   Fri Dec 13 12:14:49 2013 +0100</strong>
    
<strong>Merge branch 'feature/1'</strong>
    
<strong>Adds a hello world C program.</strong>
  </pre>
<p>Turn on colors in the Git output by running <kbd>git config --global color.ui auto</kbd>.</p>
<ol start="3">
<li>By default, <kbd>git log</kbd> prints the commit, author's name and email ID, timestamp, and the commit message. However, the information isn't very graphical, especially if you want to see branches and merges. To display this information and limit some of the other data, you can use the following options with <kbd>git log</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --decorate --graph --oneline --all</strong></pre>
<ol start="4">
<li>The previous command will show one commit per line (<kbd>--oneline</kbd>), identified by its abbreviated commit ID, and the commit message subject. A graph will be drawn between the commits depicting their dependency (<kbd>--graph</kbd>). The <kbd>--decorate</kbd> option shows the branch names after the abbreviated commit ID, and the <kbd>--all</kbd> option shows all the branches, instead of just the current one(s):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --decorate --graph --oneline --all</strong>
<strong>* 34acc37 (HEAD, tag: v1.0, origin/master, origin/HEAD, master) This is the sub...</strong>
<strong>* a90d190 Instructions for compiling hello_world.c</strong>
<strong>*   485884e Merge branch 'feature/1'</strong>
<strong>...</strong></pre>
<p style="padding-left: 60px">This output, however, gives neither the timestamp nor the author information, because of the way the <kbd>--oneline</kbd> option formats the output.</p>
<ol start="5">
<li>Fortunately, the <kbd>log</kbd> command gives us the ability to create our own output format. So, we can make a history view similar to the previous one. The colors are made with the <kbd>%C&lt;color-name&gt;text-be-colored%Creset</kbd> syntax, along with the author and timestamp information and some colors to display it nicely:</li>
</ol>
<pre style="padding-left: 60px"> <strong>$ git log --all --graph \<br/>   --pretty=format:</strong><strong>'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ci) %C(bold blue)&lt;%an&gt;%Creset'</strong></pre>
<div><img class="alignnone size-full wp-image-386 image-border" src="img/0b832625-9acc-45ce-a2e9-41d088a5dad4.png" style="width:51.92em;height:15.75em;"/></div>
<ol start="6">
<li>This is a bit cumbersome to write, but luckily, it can be made as an alias so you only have to write it once:</li>
</ol>
<pre style="padding-left: 60px"><strong>git config --global alias.graph "log --all --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%ci) %C(bold blue)&lt;%an&gt;%Creset'"</strong></pre>
<p>Now, all you need to do is call <kbd>git graph</kbd> to show the history, as you have seen previously.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Git traverses the DAG by following the parent IDs (hashes) from the given commit(s). The options passed to <kbd>git log</kbd> can format the output in different ways; this can serve several purposes—for example, to give a nice graphical view of the history, branches, and tags, as seen previously, or to extract specific information from the history of a repository to use, for example, in a script.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Extracting fixed issues</h1>
                
            
            
                
<p>A common use case of creating a release is to create a release note, containing, among other things, the bugs fixed in the release. A good practice is to write in the commit message whether a bug is fixed by the commit. A better practice is to have a standard way of doing this—for example, a line with the string <kbd>"Fixes-bug: "</kbd>, followed by the bug identifier in the last part of the commit message. This makes it easy to compile a list of bugs fixed for a release note. The JGit project is a good example of this; their bug identifier in the commit messages is a simple <kbd>"Bug: "</kbd> string followed by the bug ID.</p>
<p>This recipe will show you how to limit the output of <kbd>git log</kbd> to only list the commits since the last release (tag), which contains a bug fix.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Clone the JGit repository using the following command lines:</p>
<pre><strong>$ git clone https://git.eclipse.org/r/jgit/jgit</strong>
<strong>$ cd jgit</strong> </pre>
<p>If you want the exact same output as in this example, reset your <kbd>master</kbd> branch to <kbd>b14a93971837610156e815ae2eee3baaa5b7a44b</kbd>:</p>
<pre><strong>$ git checkout master &amp;&amp; git reset --hard b14a939</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>You are now ready to look through the commit log for commit messages that describe the bugs fixed.</p>
<ol>
<li>First, let's limit the log to only look through the history since the last tag (release). To find the last tag, we can use <kbd>git describe</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git describe </strong>
<strong>v3.1.0.201310021548-r-96-gb14a939</strong></pre>
<p style="padding-left: 60px">The preceding output tells us three things:</p>
<ul>
<li style="list-style-type: none">
<ul>
<li>The last tag was <kbd>v3.1.0.201310021548-r</kbd></li>
<li>The number of commits since the tag was <kbd>96</kbd></li>
<li>The current commit in abbreviated form is <kbd>b14a939</kbd></li>
</ul>
</li>
</ul>
<p style="padding-left: 60px">Now, the log can be parsed from <kbd>HEAD</kbd> to <kbd>v3.1.0.201310021548-r</kbd>. But just running <kbd>git log 3.1.0.201310021548-r..HEAD</kbd> will give us all 96 commits, and we just want the commits with the commit messages that contain <kbd>"Bug: xxxxxx"</kbd> for our release note. The <kbd>xxxxxx</kbd> is an identifier for the bug, and will be a number. We can use the <kbd>--grep</kbd> option with <kbd>git log</kbd> for this purpose, making the code phrase <kbd>git log --grep "Bug: "</kbd>. This will give us all the commits containing <kbd>"Bug: "</kbd> in the commit message; all we need to do now is just to format it to something that we can use for our release note.</p>
<ol start="2">
<li>Now, let's say we want the release note format to look like the following template:</li>
</ol>
<pre style="padding-left: 60px"><strong>Commit-id: Commit subject 
Fixes-bug: xxx</strong> </pre>
<ol start="3">
<li>Our command line so far is as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --grep "Bug: " v3.1.0.201310021548-r..HEAD</strong></pre>
<p style="padding-left: 60px">This gives us all the bug fix commits, but we can format this to a format that is easily parsed with the <kbd>--pretty</kbd> option.</p>
<ol start="4">
<li>First, we will print the abbreviated commit ID (<kbd>%h</kbd>), followed by a separator of our choice (<kbd>|</kbd>), and then the commit subject (<kbd>%s</kbd>, the first line of the commit message), followed by a new line (<kbd>%n</kbd>), and the body (<kbd>%b</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>--pretty="%h|%s%n%b"</strong> </pre>
<p style="padding-left: 60px">The output, of course, needs to be parsed, but that's easy with regular Linux tools, such as <kbd>grep</kbd> and <kbd>sed</kbd>.</p>
<ol start="5">
<li>First, we just want the lines that contain <kbd>"|"</kbd> or <kbd>"Bug: "</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>grep -E "\||Bug: "</strong></pre>
<ol start="6">
<li>Then, we replace these with <kbd>sed</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>sed -e 's/|/: /' -e 's/Bug:/Fixes-bug:/'</strong></pre>
<ol start="7">
<li>The entire command put together is as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ git log --grep "Bug: " v3.1.0.201310021548-r..HEAD --pretty="%h|%s%n%b" </strong><strong>| grep -E "\||Bug: " | sed -e 's/|/: /' -e 's/Bug:/Fixes-bug:/'</strong></pre>
<ol start="8">
<li>The previous set of commands gives the following output:</li>
</ol>
<pre style="padding-left: 60px"><strong>f86a488: Implement rebase.autostash </strong>
<strong>Fixes-bug: 422951 </strong>
<strong>7026658: CLI status should support --porcelain </strong>
<strong>Fixes-bug: 419968 </strong>
<strong>e0502eb: More helpful InvalidPathException messages (include reason) </strong>
<strong>Fixes-bug: 413915 </strong>
<strong>f4dae20: Fix IgnoreRule#isMatch returning wrong result due to missing reset </strong>
<strong>Fixes-bug: 423039       </strong>
<strong>7dc8a4f: Fix exception on conflicts with recursive merge </strong>
<strong>Fixes-bug: 419641 </strong>
<strong>99608f0: Fix broken symbolic links on Cygwin. </strong>
<strong>Fixes-bug: 419494 </strong>
<strong>...</strong>  </pre>
<p>Now, we can extract the bug information from the bug tracker and put the preceding code in the release note as well, if necessary.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>First, we limit the <kbd>git log</kbd> command to only show the range of commits we are interested in, and then we further limit the output by filtering the <kbd>"Bug: "</kbd> string in the commit message. We pretty print the string so we can easily format it to a style we need for the release note, and finally, find <kbd>"Bug: "</kbd> and replace it by <kbd>"Fixes-bug: "</kbd> using <kbd>grep</kbd> and <kbd>sed</kbd> to completely match the style of the release note.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>If we just wanted to extract the bug IDs from the commit messages and didn't care about the commit IDs, we could have just used <kbd>grep</kbd> after the <kbd>git log</kbd> command, still limiting the log to the last tag:</p>
<pre><strong>$ git log  v3.1.0.201310021548-r..HEAD | grep "Bug: "</strong></pre>
<p>If we just want the commit IDs and their subjects, but not the actual bug IDs, we can use the <kbd>--oneline</kbd> feature of <kbd>git log</kbd> combined with the <kbd>--grep</kbd> option:</p>
<pre><strong>$ git log --grep "Bug: " --oneline  v3.1.0.201310021548-r..HEAD</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting a list of the changed files</h1>
                
            
            
                
<p>As we saw in the previous recipe, where a list of fixed issues was extracted from the history, a list of all the files that have been changed since the last release can also easily be extracted. The files can be further filtered to find those that have been added, deleted, modified, and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>The same repository and <kbd>HEAD</kbd> position (<kbd>HEAD</kbd> pointing to <kbd>b14a939</kbd>) that we saw in the previous recipe will be used. The release is also the same, which is <kbd>v3.1.0.201310021548-r</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>The following command lists all the files that have changed since the last release (<kbd>v3.1.0.201310021548-r</kbd>):</p>
<pre><strong>$ git diff --name-only v3.1.0.201310021548-r..HEAD</strong>
<strong>org.eclipse.jgit.packaging/org.eclipse.jgit.target/jgit-4.3.target</strong>
<strong>org.eclipse.jgit.packaging/org.eclipse.jgit.target/jgit-4.4.target </strong>
<strong>org.eclipse.jgit.pgm.test/tst/org/eclipse/jgit/pgm/DescribeTest.java </strong>
<strong>org.eclipse.jgit.pgm.test/tst/org/eclipse/jgit/pgm/FetchTest.java </strong>
<strong>org.eclipse.jgit.pgm/src/org/eclipse/jgit/pgm/Describe.java </strong>
<strong>...</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>git diff</kbd> command operates on the same revision range as <kbd>git log</kbd> did in the previous recipe. By specifying <kbd>--name-only</kbd>, Git will only give the paths of the files that were changed by the commits in the range specified as output.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The output of the command can be further filtered: If we only want to show which files have been deleted in the repository since the last commit, we can use the <kbd>--diff-filter</kbd> switch with <kbd>git diff</kbd>:</p>
<pre><strong>$ git diff --name-only --diff-filter=D  v3.1.0.201310021548-r..HEAD </strong>
<strong>org.eclipse.jgit.junit/src/org/eclipse/jgit/junit/SampleDataRepositoryTestCase.java </strong>
<strong>org.eclipse.jgit.packaging/org.eclipse.jgit.target/org.eclipse.jgit.target.target </strong>
<strong>org.eclipse.jgit.test/tst/org/eclipse/jgit/internal/storage/file/GCTest.java</strong>  </pre>
<p>There are also switches for the files that have been added (<kbd>A</kbd>), copied (<kbd>C</kbd>), deleted (<kbd>D</kbd>), modified (<kbd>M</kbd>), renamed (<kbd>R</kbd>), and so on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>For more information, visit the Help page by running the <kbd>git help diff</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Viewing the history with gitk</h1>
                
            
            
                
<p>We saw earlier how we can view the history (the DAG) and visualize it by using <kbd>git log</kbd>. However, as the history grows, the terminal representation of the history can be a bit cumbersome to navigate. Fortunately, there are a lot of graphical tools in Git, one of them being gitk, which works on multiple platforms (Linux, Mac, and Windows).</p>
<p>This recipe will show you how to get started with gitk.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Make sure you have <kbd>gitk</kbd> installed:</p>
<pre><strong>$ which gitk</strong>
<strong>/usr/local/bin/gitk</strong></pre>
<p>If nothing shows up, then gitk is not installed on your system, or at least is not available on your <kbd>$PATH</kbd>.</p>
<p>Change the directory to the <kbd>Git-Version-Control-Cookbook-Second-Edition</kbd> repository from the objects and DAG examples. Make sure the master branch is checked out and pointing to <kbd>13dcad</kbd>:</p>
<pre><strong>$ git checkout master &amp;&amp; git reset --hard 13dcad</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>In the repository, run <kbd>gitk --all &amp;</kbd> to bring up the <kbd>gitk</kbd> interface. You can also specify the commit range or branches you want, just as you did with <kbd>git log</kbd> (or provide <kbd>--all</kbd> to see everything):</p>
<pre><strong>$ gitk --all &amp;</strong></pre>
<div><p>Gitk shows the commit history of the repository:</p>
<div><img class="alignnone size-full wp-image-387 image-border" src="img/5d2104f1-f937-48b6-bc10-4635374f2e28.png" style="width:43.58em;height:27.25em;"/></div>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Gitk parses the information for every commit and the objects attached to it to provide an easy graphical information screen that shows a graph of the history, author, and timestamp for each commit. In the bottom half is the result of selecting a commit. The commit message and the patches for each file that has changed . Moreover, a list of files that have been changed is displayed to the right.</p>
<p>Though very lightweight and fast, gitk is a very powerful tool. There are many different context menus that appear after the user clicks on a commit, a branch, or a tag in the history view. You can create and delete branches, revert and cherry-pick commits, <kbd>diff</kbd> selected commits, and much more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>From the interface, you can perform a find and search operation. Find looks through the history and Search looks through the information displayed in the lower half of gitk for the commit that is currently highlighted.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Finding commits in the history</h1>
                
            
            
                
<p>You already saw in the previous recipe how we can filter the output of <kbd>git log</kbd> to only list commits with the <kbd>"Bug: "</kbd>string in the commit message. In this example, we will use the same technique to find specific commits in the entire history.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we will use the JGit repository, trying to find commits related to the <kbd>"Performance"</kbd> keyword. In this recipe, we will look through the entire history, so we don't need the master branch to point to a specific commit.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>As we tried earlier, we can use the <kbd>--grep</kbd> option to find specific strings in commit messages. In this recipe, we look at the entire history and search every commit that has <kbd>"Performance"</kbd> in its commit message:</p>
<pre><strong>$ git log --grep "Performance" --oneline --all </strong>
<strong>e3f19a529 Performance improvement on writing a large index</strong><br/><strong>83ad74b6b SHA-1: collision detection support</strong><br/><strong>48e245fc6 RefTreeDatabase: Ref database using refs/txn/committed</strong><br/><strong>087b5051f Skip redundant 'OR-reuse' step in tip commit bitmap setup</strong><br/><strong>9613b04d8 Merge "Performance fixes in DateRevQueue"</strong><br/><strong>84afea917 Performance fixes in DateRevQueue</strong><br/><strong>7cad0adc7 DHT: Remove per-process ChunkCache</strong><br/><strong>d9b224aeb Delete DiffPerformanceTest</strong><br/><strong>e7a3e590e Reuse DiffPerformanceTest support code to validate algorithms</strong><br/><strong>fb1c7b136 Wait for JIT optimization before measuring diff performance </strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this example, we specifically ask Git to consider all of the commits in the history by supplying the <kbd>--all</kbd> switch. Git runs through the DAG and checks whether the <kbd>"Performance"</kbd> string is included in the commit message. For an easy overview of the results, the <kbd>--oneline</kbd> switch is also used to limit the output to just the subject of the commit message. Hopefully then, the commit(s) we needed to find can be identified from this, much shorter, list of commits.</p>
<p>Note that the search is case sensitive—had we searched for <kbd>"performance"</kbd> (all in lower case), the list of commits would have been very different:</p>
<pre><strong>$ git log --grep "performance" --oneline --all</strong>
<strong>d7deda98d Skip ignored directories in FileTreeIterator</strong><br/><strong>5a87d5040 Teach UploadPack "include-tag" in "fetch"</strong><br/><strong>7d9246f16 RawParseUtils#lineMap: Simplify by using null sentinel internally</strong><br/><strong>4bfc6c2ae Significantly speed up FileTreeIterator on Windows</strong><br/><strong>4644d15bc GC: Replace Files methods with File alternatives</strong><br/><strong>d3021788d Use bitmaps for non-commit reachability checks</strong><br/><strong>6b1e3c58b Run auto GC in the background</strong><br/><strong>db7761025 Pack refs/tags/ with refs/heads/</strong><br/><strong>30eb6423a Add GC_REST PackSource to better order DFS packs
... more output</strong> </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We also could have used the Find feature in gitk to find the same commits. Open gitk with the <kbd>--all</kbd> switch, type <kbd>Performance</kbd> in the Find field, and hit <em>Enter</em>. This will highlight the commits in the history view, and you can navigate to the previous/next result by pressing <em>Shift</em> + up arrow, <em>Shift</em> + down arrow, or the buttons next to the Find field. You will still, however, be able to see the entire history in the view with the matching commits highlighted:</p>
<div><img class="alignnone size-full wp-image-388 image-border" src="img/115db940-aff0-479a-9ae2-9e679dba2a97.png" style="width:44.00em;height:27.50em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Searching through the history code</h1>
                
            
            
                
<p>Sometimes, it is not enough to list the commit messages. You may want to know which commits touched a specific method or variable. This is also possible using <kbd>git log</kbd>. You can perform a search for a string, for example, or a variable or method, and <kbd>git log</kbd> will give you the commits, adding or deleting the string from the history. In this way, you can easily get the full commit context for the piece of code.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Again, we will use the JGit repository with the master branch pointing to <kbd>b14a939</kbd>:</p>
<pre><strong>$ git checkout master &amp;&amp; git reset --hard b14a939</strong>  </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We would like to find all the commits that have had changes made to the lines that contain the <kbd>"isOutdated" </kbd>method. Again, we will just display the commits on one line each; we can then check them individually later:</p>
<pre><strong>$ git log -G"isOutdated" --oneline </strong>
<strong>f32b861 JGit 3.0: move internal classes into an internal subpackage </strong>
<strong>c9e4a78 Add isOutdated method to DirCache </strong>
<strong>797ebba Add support for getting the system wide configuration </strong>
<strong>ad5238d Move FileRepository to storage.file.FileRepository </strong>
<strong>4c14b76 Make lib.Repository abstract and lib.FileRepository its implementation </strong>
<strong>c9c57d3 Rename Repository 'config' as 'repoConfig' </strong>
<strong>5c780b3 Fix unit tests using MockSystemReader with user configuation </strong>
<strong>cc905e7 Make Repository.getConfig aware of changed config</strong>  </pre>
<p>We can see that eight commits have patches that involve the string <kbd>"isOutdated"</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Git looks over the history (the DAG) looking at each commit for the <kbd>"isOutdated"</kbd> string in the patch between the parent commit and the current commit. This method is quite convenient to use in finding out when a given string was introduced or deleted, and to get the full context and commit at that point in time.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>The <kbd>-G</kbd> option used with <kbd>git log</kbd> will look for differences in the patches that contain added or deleted lines that match the given string. However, these lines could also have been added or removed because of some other refactoring/renaming of a variable or method. There is another option that can be used with <kbd>git log</kbd>, namely <kbd>-S</kbd>, which will look through the difference in the patch text in a similar way to the <kbd>-G</kbd> option, but will only match commits where there is a change in the number of occurrences of the specified string—that is, a line added or removed, but not added and removed.</p>
<p>Let's see the output of the <kbd>-S</kbd> option:</p>
<pre><strong>$ git log -S"isOutdated" --oneline </strong>
<strong>f32b861 JGit 3.0: move internal classes into an internal subpackage</strong>
<strong>c9e4a78 Add isOutdated method to DirCache</strong>
<strong>797ebba Add support for getting the system wide configuration</strong>
<strong>ad5238d Move FileRepository to storage.file.FileRepository</strong>
<strong>4c14b76 Make lib.Repository abstract and lib.FileRepository its implementation</strong>
<strong>5c780b3 Fix unit tests using MockSystemReader with user configuation</strong>
<strong>cc905e7 Make Repository.getConfig aware of changed config</strong>  </pre>
<p>The search matches seven commits, whereas the search with the <kbd>-G</kbd> option matches eight commits. The difference is that the commit with the ID <kbd>c9c57d3</kbd> is only found with the <kbd>-G</kbd> option in the first list. A closer look at this commit shows that the <kbd>isOutdated</kbd> string is only touched because of the renaming of another object, and this is why it is filtered away from the list of matching commits in the last list when using the <kbd>-S</kbd> option. We can see the content of the commit with the <kbd>git show</kbd> command, and use <kbd>grep -C4</kbd> to limit the output to just the four lines before and after the search string:</p>
<pre><strong>$ git show c9c57d3 | grep -C4 "isOutdated"</strong>
    <strong>@@ -417,14 +417,14 @@ public FileBasedConfig getConfig() {</strong>
    <strong>           throw new RuntimeException(e);</strong>
    <strong>         }</strong>
    <strong>       }</strong>
    <strong>-    if (config.isOutdated()) {</strong>
    <strong>+    if (repoConfig.isOutdated()) {</strong>
    <strong>         try {</strong>
    <strong>-              loadConfig();</strong>
    <strong>+              loadRepoConfig();</strong>
    <strong>         } catch (IOException e) {</strong></pre>


            

            
        
    </body></html>