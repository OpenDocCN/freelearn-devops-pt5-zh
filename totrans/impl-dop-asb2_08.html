<html><head></head><body>
        

                            
                    <h1 class="header-title">Ansible Modules and Libraries</h1>
                
            
            
                
<p>Ansible provides integration and compatibility for hundreds of open and closed source software solutions. This integration opens the door for Ansible to communicate at a programmatic API level with a multitude of build, test, project management, cloud, and delivery software solutions. The module implementation, as a result, provides Ansible with a huge edge against competing automation and configuration management solutions on the market.</p>
<p>At this point in the book, we should be fairly well educated about some of the more common playbook implementations and structured approaches to leverage Ansible. To expand our knowledge further, this chapter will focus on the wide array of modules provided by the Ansible core implementation. Modules in Ansible provide the ability for playbooks to connect to and control third-party technologies (some open source, some closed source). In this chapter, we will discuss the most popular ones and dive into creating playbook tasks that help manage a suite of tools and services available to developers, testers, and operators.</p>
<p>To further our learning, in this chapter, we will take a look at the integration that Ansible provides with other software solutions. As we take a journey through this chapter, and will learn about some of the more popular integration points available within the Ansible realm. We will discover how Ansible's modular architecture works and learn how it provides hooks for integration with other technologies.</p>
<p>The topics we will specifically cover in this chapter include the following:</p>
<ul>
<li>Introducing Ansible modules</li>
<li>Integrating Ansible with other technologies</li>
<li>Understanding the integration options available within the Ansible documentation for various technologies</li>
<li>Step-by-step examples of integrating Ansible with other technologies</li>
</ul>
<p>Let's get started!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Introducing Ansible Modules</h1>
                
            
            
                
<p>Ansible modules represent the preferred way of connecting Ansible (and automating) with other software solutions. At the time of writing of this book, Ansible has the ability to integrate with a multitude of external software and hardware solutions. Some of the more obvious integrations we have already discovered include the following:</p>
<ul>
<li>Linux (OS and packages)</li>
<li>Filesystem management</li>
<li>Package management</li>
</ul>
<p>These basic modules that we have discussed so far are obvious for introductory playbook creation and management, but did you know that Ansible integrates with JIRA, Slack, Git, Artifactory, Jenkins, and <em>much much</em> more. Ansible module's exhaustive integration has been broken down within the Ansible documentation into the following categories:</p>
<ul>
<li>Cloud modules</li>
<li>Clustering modules</li>
<li>Commands modules</li>
<li>Crypto modules</li>
<li>Database modules</li>
<li>Files modules</li>
<li>Identity modules</li>
<li>Inventory modules</li>
<li>Messaging modules</li>
<li>Monitoring modules</li>
<li>Net tools modules</li>
<li>Network modules</li>
<li>Notification modules</li>
<li>Packaging modules</li>
<li>Remote management modules</li>
<li>Source control modules</li>
<li>Storage modules</li>
<li>System modules</li>
<li>Utilities modules</li>
<li>Web infrastructure modules</li>
<li>Windows modules</li>
</ul>
<p>As you can see from the preceding list, Ansible provides a vast expanse of integrations with other technologies. Each integration point with another technology is leveraged via an Ansible playbook task. The complete documentation of each integration module can be found at <a href="http://docs.ansible.com/ansible/modules_by_category.html">http://docs.ansible.com/ansible/modules_by_category.html</a>.<a href="http://docs.ansible.com/ansible/modules_by_category.html"/></p>
<p>Ansible divides the module implementation into a few distinct categories: the Core, Community, Curated module set, and Custom modules, and plugins. Each is implemented in a very similar way but is organized by Ansible slightly differently. The diagram provided next shows where the Ansible module implementation sits within the Ansible architecture:</p>
<div><img height="261" width="351" class="image-border" src="img/a33f873b-f433-42bb-ab17-729ab03f683d.jpg"/></div>
<p>In the previous chapters of this book, we have been using Ansible modules for basic system-level configurations, package management, file operations, and more. These implementations have taught us how to make use of the core Ansible module set.</p>
<p>The Ansible implementation has three different module types. These module types are Core, Curated, Community, and Custom. Each of these modules have their own specific function and role within the Ansible solution. Let's take a minute to look at what the Ansible documentation has to say about these different module types:</p>
<ul>
<li><strong>Core</strong>: These are modules that the core ansible team maintains and will always ship with ansible itself. They will also receive slightly higher priority for all requests. Non-core modules are still fully usable.</li>
<li class="mce-root"><strong>Curated</strong>: Some examples of Curated modules are submitted by other companies or maintained by the community. Maintainers of these types of modules must watch for any issues reported or pull requests raised against the module.</li>
</ul>
<p>Core Committers will review all modules becoming Curated. Core Committers will review proposed changes to existing Curated modules once the community maintainers of the module have approved the changes. Core committers will also ensure that any issues that arise due to Ansible engine changes will be remediated. Also, it is strongly recommended (but not presently required) for these types of modules to have unit tests.<br/>
These modules are currently shipped with Ansible, but might be shipped separately in the future.</p>
<ul>
<li class="mce-root"><strong>Community</strong>: These modules are not supported by Core Committers or by companies/partners associated to the module. They are maintained by the community.</li>
</ul>
<p class="mce-root">They are still fully usable, but the response rate to issues is purely up to the community. Best effort support will be provided but is not covered under any support contracts.</p>
<p class="mce-root">These modules are currently shipped with Ansible, but will most likely be shipped separately in the future.</p>
<p>In the Ansible world, Ansible modules are also referred to as <strong>task-plugins</strong> or <strong>library-plugins</strong>, thus describing the way Ansible handles module implementations. Each module (Core or otherwise) is manifested via the pluggable architecture that is Ansible.</p>
<p>Within the context of an Ansible, modules offer a similar functionality to programming libraries. These libraries can be invoked via a playbook task <em>or</em> a direct single command-line operation. Let's take a quick look at each of these two implementation options.</p>
<p>Let's call an Ansible module from the command line:</p>
<pre>
<strong>ansible webservers -m service -a "name=httpd state=started"</strong><br/><strong>ansible webservers -m ping</strong><br/><strong>ansible webservers -m command -a "/sbin/reboot -t now"</strong>
</pre>
<p>Let's call an Ansible module from a playbook task:</p>
<pre>
<strong>- name: reboot the servers</strong><br/><strong>  action: command /sbin/reboot -t now</strong>
</pre>
<p>From the preceding examples, we can see two distinct implementations of Ansible modules. Now that we can see how Ansible modules are executed (for system calls), let's take a look at how Ansible modules can provide connectivity solutions for other technologies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrating Ansible with Other Technologies</h1>
                
            
            
                
<p>Ansible integrates quite nicely with other technologies. The implementation of the module system provides us with a set of unique hooks that we can leverage to connect Ansible (on an API level) with popular software solutions. In this section of implementing Ansible with DevOps, we will take a closer look at how to actually use Ansible to connect with some of the more popular technology solutions available to DevOps-minded individuals.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible with JIRA</h1>
                
            
            
                
<p>Ansible provides us with a handy set of built-in tasks that can be used to <em>create</em> tickets. For those of you unfamiliar with JIRA, it is a widely used ticketing system created and maintained by Atlassian (<a href="http://www.atlassian.com">http://www.atlassian.com</a>). In this section, we will take a look at how to create and manipulate JIRA tickets using Ansible. The general implementation uses the JIRA module provided by Ansible. The following is an example of how to create a ticket using an Ansible task:</p>
<pre>
# Create a new JIRA ticket and add a comment to it:<br/>- name: Create an issue<br/>  jira:<br/>  uri: "http://pathtojira"<br/>  username: '{{ user }}'<br/>  password: '{{ pass }}'<br/>  project: ANSIBLE<br/>  operation: create<br/>  summary: Hello Ansible Jira Integration<br/>  description: Created using Ansible JIRA module<br/>  issuetype: Task<br/>  register: issue
</pre>
<p>Note that the preceding implementation uses Jinja to supply the module with a JIRA username and password. This might be best implemented using Ansible vault (which we just discovered in the previous chapter).</p>
<p>Beyond simple ticket creation, Ansible can also be used to modify existing tickets. Let's take a look at an example of that next:</p>
<pre>
# Transition an issue in JIRA by changing its status to done<br/>- name: Mark the issue as resolved<br/> jira:<br/> uri: "http://pathtojira"<br/> username: '{{ user }}'<br/> password: '{{ pass }}'<br/> issue: '{{ issue.meta.key }}'<br/> operation: transition<br/> status: Resolved
</pre>
<p>For a complete documentation set of how to manipulate Jira tickets using Ansible, visit <a href="http://docs.ansible.com/ansible/jira_module.html#synopsis">http://docs.ansible.com/ansible/jira_module.html#synopsis</a>.<a href="http://docs.ansible.com/ansible/jira_module.html#synopsis">﻿</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible and Git</h1>
                
            
            
                
<p>Ansible provides a complete module to manipulate Git repositories. For those unfamiliar with Git, Git is a modern distributed source control solution currently in use by a significant number of software organizations. Unlike traditional server/client-oriented source control solutions, Git provides a nifty distributed solution, which does not require a central server. Ansible's integration with Git is fairly robust. It provides a complete set of integration tasks. The complete documentation for the Ansible Git module can be found at <a href="http://docs.ansible.com/ansible/git_module.html">http://docs.ansible.com/ansible/git_module.html</a>.</p>
<p>Let's take a look at some example playbook tasks and see how we can integrate Ansible and Git.</p>
<p>One prerequisite for Ansible's Git integration is that the target machine should have Git v1.7 or a higher command-line client installed and working.</p>
<p>Here's an example Git checkout task:</p>
<pre>
# An Ansible task example which checks out source code<br/>- git:<br/> repo: 'https://mygitserver.com/the/path/to/repo.git'<br/> dest: /opt/sourcecode<br/> version: release-0.23
</pre>
<p>Here's an example where we'll be creating ZIP file from the GitHub repository:</p>
<pre>
# Example of how to create a ZIP from a GitHub repository<br/>- git:<br/>  repo: https://github.com/foo/implementingdevops-examples.git<br/>  dest: /src/implementingdevops-examples<br/>  archive: /tmp/examples.zip
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible and Jenkins</h1>
                
            
            
                
<p>Jenkins CI (Open sourced by CloudBees) is a modern day Continuous Integration and Continuous Delivery solution. It is widely leveraged by organizations of all sizes and supports simple automation as well as complex build and delivery pipeline implementations. It has a massive</p>
<p>Ansible integrates with Jenkins in a few different ways. For the purpose of this chapter, the one we will talk about is the module-specific integration point. That is, we will be automating the control of Jenkins itself using Ansible. In this section, you will learn about some interesting ways in which you can use Ansible to control and manage the Jenkins instance via Ansible. The complete documentation for the Ansible Jenkins module can be found at <a href="http://docs.ansible.com/ansible/jenkins_job_module.html">http://docs.ansible.com/ansible/jenkins_job_module.html</a>.</p>
<p>Ansible communicates with Jenkins over the Jenkins REST API. So it is important that the Jenkins instance have the REST API available and can be reached from the target server that will be connecting to the REST API. In addition to the REST API availability, the Ansible Jenkins module requires the following Python packages to be installed:</p>
<ul>
<li>Python-Jenkins 0.4.12 or higher</li>
<li>lxml 3.3.3 or higher</li>
</ul>
<p>These packages are required because they provide direct API connectivity to Jenkins from Python. This is something Ansible has no direct connection to and as such they are required to use this specific module.</p>
<p>Now that we have the prerequisites taken care of, let's look at some examples of Ansible tasks:</p>
<pre>
<strong># Jenkins REST API to create a jenkins job </strong><br/>- jenkins_job:<br/> config: "{{ lookup('file', 'templates/test.xml') }}"<br/> name: test<br/> password: admin<br/> url: http://localhost:8080<br/> user: admin
</pre>
<p>In addition to creating jobs based on templates, we can also delete jobs. The following example shows how to do that:</p>
<pre>
<strong># Delete a jenkins job using the Ansible Jenkins module</strong><br/>- jenkins_job:<br/>    name: foo<br/>    password: my_admin<br/>    state: absent<br/>    url: http://pathtojenkinsurl:8080<br/>    user: admin
</pre>
<p>For a complete Jenkins REST API documentation, check out the following URL:</p>
<p><a href="https://www.cloudbees.com/blog/taming-jenkins-json-api-depth-and-tree">https://www.cloudbees.com/blog/taming-jenkins-json-api-depth-and-tree</a></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible and Docker</h1>
                
            
            
                
<p>Docker has become a powerhouse in the virtualization space within the last few years. Docker has a unique kernel, filesystem, and memory management solution, which makes Docker an ideal choice in virtualization for many organizations. Docker operates under the concept of container-based visualizations, which are lightweight virtualized operating systems. In this section, we will look at how Ansible integrates with Docker. We will discover how to control Docker containers using Ansible 2. The complete Ansible Docker module reference can be found at <a href="http://docs.ansible.com/ansible/docker_module.html">http://docs.ansible.com/ansible/docker_module.html</a>.</p>
<p>In order to make use of the Docker Ansible module, the following Python packages must be installed on the target system (the system running the playbook):</p>
<ul>
<li>Python 2.6 or higher</li>
<li>Docker-py 0.3.0 or higher</li>
<li>Docker server 0.10.0 or higher</li>
</ul>
<p>Ansible provides a number of docker-oriented modules, which provides interconnectivity with Ansible and Docker. The complete list and descriptions of each is provided as follows (<a href="https://docs.ansible.com/ansible/guide_docker.html">https://docs.ansible.com/ansible/guide_docker.html</a>):</p>
<ul>
<li><kbd>docker_service</kbd>: Use your existing Docker compose files to orchestrate containers on a single Docker daemon or on Swarm. Supports compose versions 1 and 2</li>
<li><kbd>docker_container</kbd>: Manages the container life cycle by providing the ability to create, update, stop, start, and destroy a container</li>
<li><kbd>docker_image</kbd>: Provides full control over images, including <kbd>build</kbd>, <kbd>pull</kbd>, <kbd>push</kbd>, <kbd>tag</kbd>, and <kbd>remove</kbd></li>
<li><kbd>docker_image_facts</kbd>: Inspects one or more images in the Docker host's image cache, providing the information as facts to make decision or assertions in a playbook</li>
<li><kbd>docker_login</kbd>: Authenticates with Docker Hub or any Docker registry and updates the Docker Engine config file, which in turn provides password-free pushing and pulling of images to and from the registry</li>
<li><kbd>docker (dynamic inventory)</kbd>: Dynamically builds an inventory of all the available containers from a set of one or more Docker hosts</li>
</ul>
<p>It's important to note that the <kbd>docker_container</kbd> task name has been deprecated in Ansible 2.2. Instead, Ansible recommends that you use <kbd>docker_container</kbd> and <kbd>docker_image</kbd> instead.</p>
<p>Let's look at some simple playbook task examples that will integrate Ansible with Docker.</p>
<p>This is how we can use Ansible to build a Docker container:</p>
<pre>
<strong># How to build a docker image using Ansible</strong><br/>- name: Build a docker image<br/>  docker_image: &gt;<br/>  name=docker-image-created-by-ansible<br/>  tag=ansibleexample1<br/>  path=/tmp/site<br/>  state=present
</pre>
<p>This is how you can use the command line to build a Docker container:</p>
<pre>
- name: How to build an image with the command line<br/>  command: docker build -t build-container-using-ansible-command:ex2 /tmp/site
</pre>
<p>This is a complete example:</p>
<pre>
---<br/>- name: Build a docker container using the command line<br/>  hosts: all<br/><br/>tasks:<br/> - name: build a docker container <br/>   command: docker build -t build-a-docker-container:ex2b ./site<br/><br/>- name: run a site within a docker container<br/>  docker:<br/>   name: mysite<br/>   image: "build-a-docker-container:ex2b"<br/>   state: reloaded<br/>   publish_all_ports: yes<br/>   use_tls: encrypt
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we looked at the Ansible module architecture. We talked about how Ansible organizes modules by category (Core and user). Once you learned how Ansible manages modules, we talked about how Ansible modules can be called via two distinct methods (the command line and via playbook tasks). Then, we moved on and looked at a few examples of popular integration modules with Ansible.</p>
<p>In the next chapter, we will move on to look at how to integrate Ansible with popular CICD solutions, such as Jenkins, Git, and more. We will explore how to start making pipelines using Ansible and discover some tricks that will help us encourage the reuse of Ansible playbooks within an organization. Let's get moving, shall we?</p>


            

            
        
    </body></html>