<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Troubleshooting and Monitoring</h1></div></div></div><p>In this chapter, we are going to look at commands which will come in useful when troubleshooting your containers, all the commands we will look at are part of the core Docker Engine, we will also look at a way by which you can debug your Dockerfiles.</p><p>Once we have finished with the Troubleshooting commands, we will look at how we can monitor our containers using cAdvisor with a Prometheus backend fronted by a Grafana dashboard – don't worry, it is not as complicated as it sounds.</p><div><div><h3 class="title"><a id="note23"/>Note</h3><p>As we are going to be exposing services, some using default credentials I would recommend that you use your local Docker installation for this chapter.</p></div></div><div><div><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Troubleshooting containers</h1></div></div></div><p>Computer<a id="id241" class="indexterm"/> programs (software) sometimes fail to behave as expected. This is due to faulty code or due to the environmental changes between the development, testing, and deployment systems. Docker container technology eliminates the environmental issues between development, testing, and deployment as much as possible by containerizing all the application dependencies. Nonetheless, there could still be anomalies due to faulty code or variations in the kernel behavior, which needs debugging. Debugging<a id="id242" class="indexterm"/> is one of the most complex processes in the software engineering world and it becomes much more complex in the container paradigm because of the isolation techniques. In this section, we are going to learn a few tips and tricks to debug a containerized application using the tools native to Docker, as well as the tools provided by external sources.</p><p>Initially, many people in the Docker community individually developed their own debugging tools, but later Docker started supporting native tools, such as <code class="literal">exec</code>, <code class="literal">top</code>, <code class="literal">logs</code>, <code class="literal">events</code>, and <a id="id243" class="indexterm"/>many more. In this section, we will dive deep into the following Docker tools:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">exec</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">ps</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">top</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">stats</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">events</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">logs</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">attach</code></li></ul></div><p>We shall also consider debugging a Dockerfile.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec24"/>The exec command</h2></div></div></div><p>The <code class="literal">docker container exec</code> command <a id="id244" class="indexterm"/>provided the much-needed help to users, who are deploying <a id="id245" class="indexterm"/>their own web servers or other applications running in the background.</p><p>Now, it is not necessary to log in to run the SSH daemon in the container.</p><p>First, launch a container:</p><div><pre class="programlisting">
<strong>docker container run -d --name trainingapp training/webapp:latest </strong>
<strong> </strong>
</pre></div><div><img src="img/B06455_06_01.jpg" alt="The exec command"/></div><p>Second, run the <code class="literal">docker container ps </code>command to get the container ID. Now you have the container ID you can run the <code class="literal">docker container exec</code> command to log in to the container using either the container ID or as we have named it <code class="literal">trainingapp</code> you can use that:</p><div><pre class="programlisting">
<strong>docker container exec -it 32005e837724 bash</strong>
</pre></div><div><div><h3 class="title"><a id="note24"/>Note</h3><p>Please note, not every container will have bash installed, some such Alpine Linux don't have bash out of the box but instead uses sh, which bash was based on.</p></div></div><p>It is important<a id="id246" class="indexterm"/> to note that the <code class="literal">docker container exec </code>command <a id="id247" class="indexterm"/>can only access the running containers, so if the container stops functioning then you need to restart the stopped container to proceed. The <code class="literal">docker container exec </code>command spawns a new process in the target containers namespace using the Docker API and CLI.</p><p>A containers name space is what separates the containers from each other, for example you can have several containers all running the same process, but because the processes have been launched within each of the containers namespace they are isolated from one another. A good example of this is are MySQL processes, on a traditional server trying to run more than one MySQL server process will mean that you need to start the process on different ports, use different lock, PID and log files as well as different init scripts.</p><p>As Docker is isolating each MySQL server process all you need to worry about is that if you are exposing the MySQL port on the host machine is that you don't assign it on the same port as another container.</p><p>So, if you run the <code class="literal">ps -aef</code> command inside the target container, it looks like this:</p><div><img src="img/B06455_06_04.jpg" alt="The exec command"/></div><p>Here, <code class="literal">python app.y</code> is the application that is already running in the target container, and the <code class="literal">docker container exec </code>command has added the <code class="literal">bash </code>process inside the container. If you run <code class="literal">kill -9 59</code> (replacing the <code class="literal">59</code> with the PID of your own <code class="literal">bash</code> process), you will be automatically logged out of the container.</p><p>It is recommended that you use the <code class="literal">docker container exec</code> command only for monitoring and diagnostic purposes, and I personally believe in the concept of one process per container, which is one of the best practices widely accentuated.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec25"/>The ps command</h2></div></div></div><p>The <code class="literal">ps</code> command, which<a id="id248" class="indexterm"/> is<a id="id249" class="indexterm"/> available inside the container, is used to see the status of the process. This is like the standard <code class="literal">ps</code> command in the Linux environment and is not a <code class="literal">dockercontainerps</code> command that we run on the Docker host machine.</p><p>This command runs inside the Docker container:</p><div><img src="img/B06455_06_06.jpg" alt="The ps command"/></div><p>Use <code class="literal">ps --help &lt;simple|list|output|threads|misc|all&gt; </code>or <code class="literal">ps --help &lt;s|l|o|t|m|a&gt;</code> for<a id="id250" class="indexterm"/> additional <a id="id251" class="indexterm"/>help text.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec26"/>The top command</h2></div></div></div><p>You can run the<a id="id252" class="indexterm"/> top command from<a id="id253" class="indexterm"/> the Docker host machine using the following command:</p><div><pre class="programlisting">
<strong>docker container top CONTAINER [ps OPTIONS]</strong>
</pre></div><p>This gives a list of the running processes of a container without logging into the container, as follows:</p><div><img src="img/B06455_06_07.jpg" alt="The top command"/></div><p>The within the container the top command provides information about the CPU, memory, and swap usage just like any normal Linux host:</p><div><img src="img/B06455_06_08.jpg" alt="The top command"/></div><p>In case you get the<a id="id254" class="indexterm"/> error as <code class="literal">error - TERM environment variable not set</code> while running the <code class="literal">top</code> command inside the container, perform the <a id="id255" class="indexterm"/>following steps to resolve it.</p><p>Run <code class="literal">echo$TERM</code> and if you get the result <code class="literal">dumb</code>, then, run the following command:</p><div><pre class="programlisting">
<strong>export TERM=dumb </strong>
</pre></div><p>This will resolve your error and you can run the <code class="literal">top</code> command.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec27"/>The stats command</h2></div></div></div><p>The <code class="literal">docker container stats</code> command <a id="id256" class="indexterm"/>provides you with the <a id="id257" class="indexterm"/>capability to view the memory, CPU, and the network usage of a container from a Docker host machine, as illustrated here. Running the following command:</p><div><pre class="programlisting">
<strong>docker container stats 32005e837724</strong>
</pre></div><p>Gives you the following:</p><div><img src="img/B06455_06_09.jpg" alt="The stats command"/></div><p>You can run the <code class="literal">stats</code> command to also view the usage for multiple containers:</p><div><pre class="programlisting">
<strong>docker container stats 32005e837724 5e33f02f5fd2 7c9cf27ff46a</strong>
</pre></div><div><img src="img/B06455_06_10.jpg" alt="The stats command"/></div><p>Since Docker 1.5, you have been able to access to container statistics <em>read only</em> parameters. This will streamline the CPU, memory, network IO, and block IO of your containers.</p><p>This helps you<a id="id258" class="indexterm"/> choose the resource limits and in profiling. The Docker stats utility provides you with these resource usage details only for running containers.</p><p>You can get detailed <a id="id259" class="indexterm"/>information using the endpoint APIs at the following URL <a class="ulink" href="https://docs.docker.com/engine/api/v1.26/">https://docs.docker.com/engine/api/v1.26/</a>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec28"/>The Docker events command</h2></div></div></div><p>Docker containers will<a id="id260" class="indexterm"/> report the following real-time events: <code class="literal">create</code>, <code class="literal">destroy</code>, <code class="literal">die</code>, <code class="literal">export</code>, <code class="literal">kill</code>, <code class="literal">omm</code>, <code class="literal">pause</code>, <code class="literal">restart</code>, <code class="literal">start</code>, <code class="literal">stop</code>, and <code class="literal">unpause</code>. Let's <code class="literal">pause</code> and <code class="literal">unpause</code> our container:</p><div><img src="img/B06455_06_11.jpg" alt="The Docker events command"/></div><p>If you specify an image <a id="id261" class="indexterm"/>it will also report the <code class="literal">untag</code> and <code class="literal">delete</code> events.</p><p>Using multiple filters will be handled as an <code class="literal">AND</code> operation, for example:</p><div><pre class="programlisting">
<strong>docker events --filter container=32005e837724 --filter event=pause --filter event=unpause --since 12h </strong>
</pre></div><p>Preceding will display all <code class="literal">pause</code> and <code class="literal">unpause </code>events for the container <code class="literal">a245253db38b</code> for the last 12 hours:</p><div><img src="img/B06455_06_12.jpg" alt="The Docker events command"/></div><p>Currently, the supported filters are <code class="literal">container</code>, <code class="literal">event</code>, and <code class="literal">image</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec29"/>The logs command</h2></div></div></div><p>This command fetches the <a id="id262" class="indexterm"/>log of a container without logging into the container. It <a id="id263" class="indexterm"/>batch-retrieves logs present at the time of execution. These logs are the output of STDOUT and STDERR. The general usage is shown in:</p><div><pre class="programlisting">
<strong>docker container logs [OPTIONS] CONTAINERID</strong>
</pre></div><p>The <code class="literal">--follow </code>option will continue to provide the output till the Docker logs command is terminated printing any new log entries to the screen in real time,<code class="literal">-t </code>will provide the timestamp, and <code class="literal">--tail=&lt;number of lines&gt; </code>will show the number of lines of the log messages of your container:</p><div><pre class="programlisting">
<strong>docker container logs 32005e837724</strong>
</pre></div><div><img src="img/B06455_06_13.jpg" alt="The logs command"/></div><div><pre class="programlisting">
<strong>docker container logs -t 32005e837724</strong>
</pre></div><div><img src="img/B06455_06_14.jpg" alt="The logs command"/></div><p>We also used the <code class="literal">docker container logs</code> command in previous chapters to view the logs of our database containers.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec30"/>The attach command</h2></div></div></div><p>This command attaches the <a id="id264" class="indexterm"/>running container and it is very helpful when you<a id="id265" class="indexterm"/> want to see what is written in <code class="literal">stdout</code> in real time, let's launch new test container which outputs something to <code class="literal">stdout</code>:</p><div><pre class="programlisting">
<strong>docker container run -d --name=newtest alpine /bin/sh -c "while true; do sleep 2; df -h; done"</strong>
</pre></div><p>Now we can attach to the container using the following command to see the output;</p><div><pre class="programlisting">
<strong>docker container attach newtest</strong>
</pre></div><p>By default, this command attaches <code class="literal">stdin</code> and proxies signals to the remote process. Options are available to control both behaviors. To detach from the process, use the default <em>Ctrl</em> + <em>Q</em> sequence.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Debugging a Dockerfile</h1></div></div></div><p>Every instruction we <a id="id266" class="indexterm"/>set in the Dockerfile is going to be built as a separate, temporary image for the other instruction to build itself on top of the previous instruction.</p><p>There is a Dockerfile in the repo at <code class="literal">/bootcamp/ch</code>
<code class="literal">apter06/debu</code>
<code class="literal">g</code>:</p><div><pre class="programlisting">FROM alpine
RUN ls -lha /home
RUN ls -lha /vars
CMD echo Hello world</pre></div><p>Building the image using the following command:</p><div><pre class="programlisting">
<strong>docker image build</strong>
</pre></div><p>Gives you the following output:</p><div><img src="img/B06455_06_17.jpg" alt="Debugging a Dockerfile"/></div><p>So, there is an error in our Docker file. You may notice there is a line in the output which says <code class="literal">---&gt;5f828f86eaa4</code>this is actually an image file which was built following the successful execution of the <code class="literal">RUN ls -lha /</code>
<code class="literal">home</code> line.</p><div><img src="img/B06455_06_18.jpg" alt="Debugging a Dockerfile"/></div><p>This means that we can <a id="id267" class="indexterm"/>launch a container using this image:</p><div><pre class="programlisting">
<strong>docker container run -it --name=debug 5f828f86eaa4 /bin/sh</strong>
</pre></div><div><div><h3 class="title"><a id="note25"/>Note</h3><p>Notice that as we are using Alpine Linux as our base we are using <code class="literal">/bin/sh</code> rather than <code class="literal">/bin/bash</code>
</p></div></div><p>We can then debug our application, which in this case is simple:</p><div><img src="img/B06455_06_19.jpg" alt="Debugging a Dockerfile"/></div><p>Debugging is a process of analyzing what's going on and it's different for every situation, but usually the way we start debugging is by trying to manually make the instruction that fail work manually and understand the error. When I get the instruction to work, I usually exit the container, update my Dockerfile and repeat the process until I have something working.</p><p>Notice that when the line which is causing the error is corrected (by supplying the correct line <code class="literal">RUN ls -lha /var</code>) and we try the build again that Docker doesn't create a new image for the one step which was successful:</p><div><img src="img/B06455_06_20.jpg" alt="Debugging a Dockerfile"/></div><p>Once it has built the<a id="id268" class="indexterm"/> temporary image is removed and we are left with our final image:</p><div><img src="img/B06455_06_21.jpg" alt="Debugging a Dockerfile"/></div><p>That was quite a simple example, but it should give you an idea of how to debug a more complex Dockerfile.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Monitoring containers</h1></div></div></div><p>In the last section, we looked at how<a id="id269" class="indexterm"/> you can use the API built into Docker to gain an insight to what resources your containers are running by running the <code class="literal">docker container stats</code> and <code class="literal">docker container top</code> commands. Now, we are to see how we can take it to the next level by using <strong>cAdvisor</strong> from Google.</p><p>Google describes <a id="id270" class="indexterm"/>cAdvisor as follows:</p><div><blockquote class="blockquote"><p>cAdvisor (Container Advisor) provides container users an understanding of the resource usage and performance characteristics of their running containers. It is a running daemon that collects, aggregates, processes, and exports information about running containers. Specifically, for each container, it keeps resource isolation parameters, historical resource usage, histograms of complete historical resource usage, and network statistics. This data is exported by a container and is machine-wide.</p></blockquote></div><p>The project started <a id="id271" class="indexterm"/>off life as an internal tool at Google for gaining an insight into containers that had been launched using their own container stack.</p><div><div><h3 class="title"><a id="note26"/>Note</h3><p>Google's own container stack was called "Let Me Contain That For You" or lmctfy for short. The work on lmctfy has been installed as a Google port functionality over to libcontainer that is part of the Open Container Initiative. Further details on lmctfy<a id="id272" class="indexterm"/> can be found at <a class="ulink" href="https://github.com/google/lmctfy/">https://github.com/google/lmctfy/</a></p></div></div><p>cAdvisor is written in <a id="id273" class="indexterm"/>Go (<a class="ulink" href="https://golang.org">https://golang.org</a>); you can either compile your own binary or you can use the pre-compiled binary that are supplied via a container, which is available from Google's own Docker Hub account. You can find this at <a class="ulink" href="http://hub.docker.com/u/google/">http://hub.docker.com/u/google/</a>.</p><p>Once installed, cAdvisor will sit in the background and capture metrics that are like that of the <code class="literal">dockercontainer </code>
<code class="literal">stats</code> command. We will go through these stats and understand what they mean later in this chapter.</p><p>cAdvisor takes these metrics along with those for the host machine and exposes them via a simple and easy-to-use built-in web interface.</p><p>There are several ways to install cAdvisor; the easiest way to get started is to download and run the container image that contains a copy of a precompiled cAdvisor binary:</p><div><pre class="programlisting">
<strong>docker network create monitoring</strong>
<strong>docker container run -d \</strong>
<strong>  --volume=/:/rootfs:ro \</strong>
<strong>  --volume=/var/run:/var/run:rw \</strong>
<strong>  --volume=/sys:/sys:ro \</strong>
<strong>  --volume=/var/lib/docker/:/var/lib/docker:ro \</strong>
<strong>  --publish=8080:8080 \</strong>
<strong>  --name=cadvisor \</strong>
<strong>  google/cadvisor:latest</strong>
</pre></div><p>You should now have a cAdvisor container up and running on your host machine.</p><p>Before we start looking at stats, let's look at cAdvisor in more detail by discussing why we have passed all the options to the container.</p><p>The cAdvisor binary is designed to run on the host machine alongside the Docker binary, so by launching cAdvisor in a container, we are isolating the binary in its own environment. To give cAdvisor access to the resources it requires on the host machine, we have to mount several partitions and also give the container privileged access to let the cAdvisor binary think it is being executed on the host machine.</p><p>So now, we have cAdvisor running; what do we need to do to configure the service in order to start collecting metrics?</p><p>The short answer is, nothing at all. When you started the cAdvisor process, it instantly started polling your host machine to find out what containers are running and gathered information on both the running containers and your host machine.</p><p>cAdvisor should be running<a id="id274" class="indexterm"/> on the 8080 port; if you open <code class="literal">http://localhost:8080/</code>, you should be greeted with the cAdvisor logo and an overview of your host machine:</p><div><img src="img/B06455_06_23.jpg" alt="Monitoring containers"/></div><p>This initial page streams live stats about the host machine, though each section is repeated when you start to drill down and view the containers. To start with, let's look at each section using the host information.</p><p>The overview section gives you a bird's-eye view of your system; it uses gauges so you can quickly get an idea of which resources are reaching their limits. In the following screenshot, there is very little in the way of CPU utilization and the file system usage is relatively low; however, we are using 66% of the available RAM:</p><div><img src="img/B06455_06_24.jpg" alt="Monitoring containers"/></div><p>Next up is the graph <a id="id275" class="indexterm"/>which shows the CPU utilization over the last minute:</p><div><img src="img/B06455_06_25.jpg" alt="Monitoring containers"/></div><p>Here is what <a id="id276" class="indexterm"/>each term means:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Total Usage</strong>: This shows an aggregate usage across all cores</li><li class="listitem" style="list-style-type: disc"><strong>Usage per Core</strong>: This graph breaks down the usage per core</li><li class="listitem" style="list-style-type: disc"><strong>Usage Breakdown</strong>: This shows aggregate usage across all cores, but breaks it down to what is being used by the kernel and what is being used by the user-owned processes</li></ul></div><p>The Memory section<a id="id277" class="indexterm"/> is split into two parts. The graph tells you the total amount of memory used by all the processes for the host or container; this is the total of the hot and cold memory. The Hot memory is the current working set; pages that have been touched by the kernel recently. The Cold memory is the page that hasn't been touched for a while and could be reclaimed if needed.</p><p>The Usage Breakdown gives a visual representation of the total memory in the host machine, or allowance in the container, alongside the total and hot usage.</p><p>The network section shows the incoming and outgoing traffic over the last minute. You can change the interface using the drop-down box on the top-left.</p><p>There is also a graph that shows any networking errors. Typically, this graph should be flat. If it isn't, then you will be seeing performance issues with your host machine or container.</p><p>The final section, filesystem, gives a breakdown of the filesystem usage. In the following screenshot, <code class="literal">/dev/vda1</code> is the boot partition, overlay is the main filesystem running your running containers.</p><p>Now we can look at our containers. At the top of the page, there is a link of your running containers, it says <strong>Docker Containers</strong>; you can either click on the link or go directly to <code class="literal">http://localhost:8080/docker/</code>.</p><p>Once the page loads, you should see a list of all your running containers, and also a detailed overview of your Docker process, and finally a list of the images you have downloaded.</p><p>Subcontainers shows a list of your containers; each entry is a clickable link that will take you to a page that will give you the following details:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Isolation</strong>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>CPU</strong>: This shows you the CPU allowances of the container; if you have not set any resource limits, you will see the host's CPU information</li><li class="listitem" style="list-style-type: disc"><strong>Memory</strong>: This shows you the memory allowances of the container; if you have not set any resource limits, your container will show an unlimited allowance</li></ul></div></li><li class="listitem" style="list-style-type: disc"><strong>Usage</strong>:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Overview</strong>: This shows gauges so you can quickly see how close to any resource limits you are</li><li class="listitem" style="list-style-type: disc"><strong>Processes</strong>: This shows the processes for just your selected container</li><li class="listitem" style="list-style-type: disc"><strong>CPU</strong>: This shows the CPU utilization graphs isolated to just your container</li><li class="listitem" style="list-style-type: disc">Memory: This shows the memory utilization of your container</li></ul></div></li></ul></div><p>The <a id="id278" class="indexterm"/>Driver status section gives the basic stats on your main Docker process, along with the information on the host machine's kernel, host name, and also the underlying operating system.</p><p>It also gives information on the total number of containers and images. You may notice that the total number of images is a much larger figure than you expected to see; this is because it is counting each file system as an individual image.</p><p>Finally, you get a list of the Docker images which are available on the host machine. It lists the Repository, Tag, Size, and when the image was created, along with the images' unique ID. This lets you know where the image originated from (Repository), which version of the image you have downloaded (Tag) and how big the image is (Size).</p><p>This is all great, what's the catch?</p><p>So, you are maybe thinking to yourself that all this information available in your browser is really useful; being able to see real-time performance metrics in an easily readable format is a real plus.</p><p>The biggest drawback of using the web interface for cAdvisor, as you may have noticed, is that it only shows you one minute's worth of metrics; you can quite literally see the information disappearing in real time.</p><p>As a pane of glass gives a real-time view into your containers, cAdvisor is a brilliant tool; if you want to review any metrics that are older than one minute, you are out of luck.</p><p>That is, unless you configure somewhere to store all your data; this is where Prometheus comes in.So what's <a id="id279" class="indexterm"/>Prometheus? Its developers describe it as follows:</p><div><blockquote class="blockquote"><p>Prometheus is an open-source system's monitoring and alerting toolkit built at SoundCloud. Since its inception in 2012, it has become the standard for instrumenting new services at SoundCloud and is seeing growing external usage and contributions.</p></blockquote></div><p>OK, but what does that have to do with cAdvisor? Well, Prometheus has quite a powerful database backend that stores the data it imports as a time series of events.</p><p>One of the things cAdvisor does, by default, is expose all the metrics it is capturing on a single page at <code class="literal">/metrics</code>; you can see this at <code class="literal">http://localhost:8080/metricson</code> our cAdvisor installation. The metrics are updated each time the page is loaded, you should see something like:</p><div><img src="img/B06455_06_29.jpg" alt="Monitoring containers"/></div><p>As you can see <a id="id280" class="indexterm"/>in the preceding screenshot, this is just a single long page of raw text. The way Prometheus works is that you configure it to scrape the <code class="literal">/metrics</code> URL at a user-defined interval, let's say every five seconds; the text is in a format that Prometheus understands and it is ingested into the Prometheus's time series database.</p><p>What this means is that, using Prometheus's powerful built-in query language, you can start to drill down into your data. Let's look at getting Prometheus up and running.</p><p>First of all, there is a work configuration file in the repo at <code class="literal">/bootcamp/chapter06/prometheus/</code>you will need to make sure you are in this folder as we are going to mounting the configuration file from within there:</p><div><pre class="programlisting">
<strong>docker container run -d \</strong>
<strong>  --volume=$PWD/prometheus.yml:/etc/prometheus/prometheus.yml \</strong>
<strong>  --publish=9090:9090 \</strong>
<strong>  --network=monitoring \</strong>
<strong>  --name=prometheus \</strong>
<strong>  prom/prometheus:latest</strong>
</pre></div><div><img src="img/B06455_06_30.jpg" alt="Monitoring containers"/></div><p>The configuration file we have launched Prometheus with looks like the following:</p><div><pre class="programlisting">global:
scrape_interval: 15s # By default, scrape targets every 15 seconds.
external_labels:
    monitor: 'Docker Bootcamp'
scrape_configs:
  - job_name: 'cadvisor'
scrape_interval: 5s
static_configs:
      - targets: ['cadvisor:8080']</pre></div><p>As we have launched <a id="id281" class="indexterm"/>our Prometheus container within the monitoring network our installation will be able scrape the metrics from <code class="literal">http://cadvisor:8080/</code>, also note that we haven't added <code class="literal">/metrics</code> to the URL as this added automatically by Prometheus.</p><p>Opening <code class="literal">http://localhost:9090/targets</code> in your browser should show you something like the following:</p><div><img src="img/B06455_06_31.jpg" alt="Monitoring containers"/></div><p>Also, the status menu has links to the following information pages:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Runtime information&amp;Build information</strong>: This displays how long Prometheus has been up and polling data, if you have configured an end point and details of the version of Prometheus that you have been running</li><li class="listitem" style="list-style-type: disc"><strong>Command-Line Flags</strong>: This shows all the runtime variables and their values</li><li class="listitem" style="list-style-type: disc"><strong>Configuration</strong>: This is a copy of the configuration file we injected into the container when it was launched</li><li class="listitem" style="list-style-type: disc"><strong>Rules</strong>: This is a copy of any rules we injected; these will be used for alerting</li></ul></div><p>As we only have a few containers up and running at the moment, let's launch one that runs Redis so we can start to look at the query language built into Prometheus.</p><p>We will use the official Redis image for this and as we are only going to use this as an example we won't need to pass it any user variables:</p><div><pre class="programlisting">
<strong>docker container run -d --name my-redis-server redis</strong>
</pre></div><p>We now have a <a id="id282" class="indexterm"/>container called my-redis-server running. cAdvisor should already be exposing metrics about the container to Prometheus; let's go ahead and see.</p><p>In the Prometheus web interface, go to the <strong>Graph</strong> link in the menu at the top of the page. Here, you will be presented with a text box into which you can enter your query. To start with, let's look at the CPU usage of the Redis container.</p><p>In the box, enter the following:</p><div><pre class="programlisting">container_cpu_usage_seconds_total{job="cadvisor",name="my-redis-server"}</pre></div><p>Then, after clicking on Execute, you should have two results returned, listed in the Console tab of the page. If you remember, cAdvisor records the CPU usage of each of the CPU cores that the container has access to, which is why we have two values returned, one for <code class="literal">cpu00</code> and one for <code class="literal">cpu01</code>. Clicking on the <strong>Graph</strong> link will show you results over a period of time:</p><div><img src="img/B06455_06_32.jpg" alt="Monitoring containers"/></div><p>As you can see in<a id="id283" class="indexterm"/> the preceding screenshot, we now have access to the usage graphs for the last 5 minutes, which is about how long ago I launched the Redis instance before generating the graph.</p><p>Graphing, as you may have noticed, isn't Prometheus's strong point. Luckily Grafana has been able to use Prometheus as a data source for a while, let's now launch a Grafana container:</p><div><pre class="programlisting">
<strong>docker container run -d \</strong>
<strong>  --publish=3000:3000 \</strong>
<strong>  --network=monitoring \</strong>
<strong>  --name=grafana \</strong>
<strong>grafan</strong>
<strong>a/grafana:latest</strong>
</pre></div><div><img src="img/B06455_06_33.jpg" alt="Monitoring containers"/></div><p>Once the container<a id="id284" class="indexterm"/> has launched, go to <code class="literal">http://localhost:3000/</code> in your browser and you will be prompted to login, the default username and password is <code class="literal">admin</code> / <code class="literal">admin</code>.</p><p>Now you are logged in you should see something like the following page:</p><div><img src="img/B06455_06_34.jpg" alt="Monitoring containers"/></div><p>As you may have guessed, we need to click <strong>Add data source</strong>and the add then enter the following information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Name</strong>: prometheus</li><li class="listitem" style="list-style-type: disc"><strong>Type</strong>: &lt;Select Prometheus from the drop down list&gt;</li><li class="listitem" style="list-style-type: disc"><strong>Url</strong>: <code class="literal">http://prometheus:9090</code></li><li class="listitem" style="list-style-type: disc"><strong>Access</strong>: &lt;Select proxy from the drop down list&gt;</li></ul></div><p>Leave everything else as is and then click on<strong> Add</strong>, after a second or two your data source should have successfully been added and the connection test passed.</p><p>Now that we have our data source added we can add a dashboard. There are plenty of dashboards available, we are going to use the one published by Brian Christner which can be found at <a class="ulink" href="https://grafana.net/dashboards/179/">https://grafana.net/dashboards/179/</a>.</p><p>To import the dashboard,click on the <strong>Grafana logo</strong> in the top left, in the menu which opens go to <strong>Dashboards</strong> and then select <strong>Import</strong>. In the pop-up dialog which opens enter the URL for the dashboard, which is <a class="ulink" href="https://grafana.net/dashboards/179/">https://grafana.net/dashboards/179/</a>, into the <strong>Grafana.net Dashboard</strong> box and then click on the <strong>Load</strong> button.</p><p>That will load the dashboard configuration, on the next page you given two options, the <strong>Name</strong> is already filled in so just select <strong>prometheus </strong>from the dropdown <strong>Prometheus</strong> list and click the <strong>Import</strong> button.</p><p>Once imported you <a id="id285" class="indexterm"/>should be greeted by a dashboard which looks similar (I have tweaked it for the screenshot) to the following:</p><div><img src="img/B06455_06_35.jpg" alt="Monitoring containers"/></div><p>You may notice from the screen above that we now have over an hour's worth of data from cAdvisor stored in Prometheus.</p><p>It's worth pointing that the current experimental build of Docker has a built-in Prometheus endpoint much in the same way that cAdvisor has. Once this hits the stable release I expect to<a id="id286" class="indexterm"/> see this be a great out of the box solution for monitoring your Docker hosts.</p><p>However, this<a id="id287" class="indexterm"/> is just one way you monitor your containers as there <a id="id288" class="indexterm"/>are numerous other<a id="id289" class="indexterm"/> tools both of which are<a id="id290" class="indexterm"/> self-hosted or<a id="id291" class="indexterm"/> run as a software as a service<a id="id292" class="indexterm"/> in the cloud such as:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Sysdig - <a class="ulink" href="http://www.sysdig.org/">http://www.sysdig.org/</a></li><li class="listitem" style="list-style-type: disc">Sysdig Cloud - <a class="ulink" href="https://sysdig.com/">https://sysdig.com/</a></li><li class="listitem" style="list-style-type: disc">Datadog - <a class="ulink" href="http://docs.datadoghq.com/integrations/docker/">http://docs.datadoghq.com/integrations/docker/</a></li><li class="listitem" style="list-style-type: disc">New Relic - <a class="ulink" href="https://newrelic.com/partner/docker">https://newrelic.com/partner/docker</a></li><li class="listitem" style="list-style-type: disc">Coscale - <a class="ulink" href="http://www.coscale.com/docker-monitoring">http://www.coscale.com/docker-monitoring</a></li><li class="listitem" style="list-style-type: disc">Elastic Metric Beat - <a class="ulink" href="https://www.elastic.co/products/beats/metricbeat">https://www.elastic.co/products/beats/metricbeat</a></li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Summary</h1></div></div></div><p>Hopefully now you should have an idea of where to start when it comes to looking into problems with containers, be it building them, checking logs, attaching to a container to further into issues or gathering performance metrics.</p><p>In the next chapter, which is also our last, we will look at some of the different scenarios and use cases for both Docker and techniques we have covered in this and previous five chapters.</p></div></body></html>