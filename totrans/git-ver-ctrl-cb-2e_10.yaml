- en: Patching and Offline Sharing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'n this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating patches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating patches from branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying patches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending patches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating Git bundles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a Git bundle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating archives from a tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the distributed nature of Git and the many existing hosting options available
    for it, it's very easy to share history between machines when they are connected
    through a network. In cases where the machines that need to share history are
    not connected or can't use the supported transport mechanisms, Git provides other
    methods to share history.
  prefs: []
  type: TYPE_NORMAL
- en: Git provides an easy way to format patches from existing history, sending them
    in an email and applying them to another repository. Git also has a bundle concept,
    where a bundle that contains only part of the history of a repository can be used
    as a remote for another repository. Finally, Git provides a simple and easy way
    to create an archive for a snapshot of the folder/subfolder structure of a given
    reference.
  prefs: []
  type: TYPE_NORMAL
- en: With the different methods provided by Git, it is easy to share history between
    repositories, especially where the normal push/pull methods are not available.
  prefs: []
  type: TYPE_NORMAL
- en: Creating patches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll learn how to make patches out of commits. Patches can
    be sent via email for quick sharing or can be copied to sneakernet devices (USB
    sticks, memory cards, external hard disk drives, and so on) if they need to be
    applied to an offline computer or suchlike. Patches can be useful methods to review
    code, as the reviewer can apply a patch to their repository, investigate the difference,
    and check the program. If the reviewer decides that the patch is good, they can
    publish (`push`) it to a public repository, given that the reviewer is the maintainer
    of the repository. If the reviewer rejects the patch, they can simply reset their
    branch to the original state and inform the author of the patch that more work
    is needed before it can be accepted.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this example, we''ll clone and use a new repository. The repository is just
    an example repository for Git commands and only contains some example commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see the history of the repository, as shown by `gitk`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three branches in the repository: `master`, `develop`, and `doc`.
    All of them differ from the others by one or more commits. On the `master` branch,
    we can now create a patch file for the latest commit on the `master` branch and
    store it in the `latest-commit` folder, as shown in the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look at the file created by the `patch` command, we will see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The previous snippet is the contents of the produced patch file. It contains
    a header much like an email with the `From`, `Date`, and `Subject` fields, a body
    with the commit message, and, after the three dashes (`---`), the actual patch,
    followed finally by two dashes (`--`),  and the Git version used to generate the
    patch. The patch generated by `git format-patch` is in the **UNIX** mailbox format,
    but with a magic fixed timestamp to identify that it comes from `git format-patch`
    rather than a real mailbox. You can see the timestamp in the first line after
    the `sha-1` ID Mon Sep 17 00:00:00 2001.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When generating the patch, Git will `diff` the commit at `HEAD` with its parent
    commit and use this `diff` as the patch. The `-1` option tells Git to only generate
    patches for the last commit, and `-o latest-commit` tells Git to store the patch
    in the `latest-commit` folder. The folder will be created if it does not already
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want to create patches for several commits, say the last three commits,
    you just pass on `-3` to `git format-patch` instead of `-1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Format the latest three commits as patches in the `latest-commits` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Creating patches from branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Instead of counting the number of commits you need to make patches for, you
    can create patches by specifying the target branch when running the `format-patch`
    command.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same repository as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Make sure we have the `develop` branch checked out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We'll pretend that we have been working on the `develop` branch and have made
    some commits. Now, we need to format patches for all those commits so that we
    can send them to the repository maintainer or carry them to another machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the commits on `develop`, not on `master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, instead of running `git format-patch -3` to get patches made for these
    three commits, we''ll tell Git to create patches for all of the commits that are
    not on the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Git makes a list of commits from `develop` that are not on the `master` branch,
    much like we did before creating the patches, and makes patches for these. We
    can check the contents of the `not-on-master`folder, which we specified as the
    output folder (`-o`) and verify that it contains the patches as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git format-patch` command has many options besides the `-<n>` option to
    specify the number of commits in order to create patches for the `-o <dir>` for
    the target directory. Some useful options are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-s`, `--signoff`: Adds a `Signed-off-by` line to the commit message in the
    patch file with the name of the committer. This is often required when mailing
    patches to the repository maintainers. This line is required for patches to be
    accepted when they are sent to the Linux kernel mailing list and the Git mailing
    list.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-n`, `--numbered`: Numbers the patch in the subject line as `[PATCH n/m]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--suffix=.<sfx>`: Sets the suffix of the patch; it can be empty and does not
    have to start with a dot.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-q`, `--quiet`: Suppresses the printing of patch filenames when generating
    patches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--stdout`: Prints all commits to the standard output instead of creating files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying patches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now we know how to create patches from commits, it's time to learn how to apply
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the repository from the previous examples, along with the generated
    patches, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we'll check out the `develop` branch and apply the patch generated from
    the `master` branch (`0001-Calculate-pi-with-more-digits.patch`) in the first
    example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the Git `am` command to apply the patches; `am` is short for `apply
    from mailbox`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We can resolve the conflict in line 47 (an empty line to be removed) and continue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also apply the `master` branch to the series of patches that was generated
    from the `develop` branch, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `git am` command takes the mailbox file specified in the input and applies
    the patch in the file to the files needed. Then, a commit is recorded using the
    commit message and author information from the patch. The committer identity of
    the commit will be the identity of the person performing the `git am` command.
    We can see the author and committer information with `git log`, but we need to
    pass the `--pretty=fuller` option to also view the committer information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `git am` command applies the patches in the files specified and records
    the commits in the repository. However, if you only want to apply the patch to
    the working tree or the staging area and not record a commit, you can use the
    `git apply` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to apply the patch from the `master` branch to the `develop` branch
    once again; we just need to reset the `develop` branch first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the state of the repository with the `status` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We successfully applied the patch to the working tree. We can also apply it
    to the staging area and the working tree using the `--index` option, or only to
    the staging area using the `--cached` option.
  prefs: []
  type: TYPE_NORMAL
- en: Sending patches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous example, you saw how to create and apply patches. You can,
    of course, attach these patch files directly to an email, but Git provides a way
    to send patches directly as emails with the `git send-email` command. The command
    requires some setting up, but how you do that is heavily dependent on your general
    mail and SMTP configuration. A general guide can be found in the Git help pages
    or by visiting: [http://git-scm.com/docs/git-send-email](http://git-scm.com/docs/git-send-email)[.](http://git-scm.com/docs/git-send-email)'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll set up the same repository as in the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll send the same patch as the one we created in the first example.
    We''ll send it to ourselves using the email address we specified in our Git configuration.
    Let''s create the patch again with `git format-patch` and send it with `git send-email`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the email address from the Git configuration to a variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Send the patch using the email address in both the `--to` and `--from` fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Checking your email will reveal a new email in your inbox.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in the previous examples, `git format-patch` creates the patch files
    in the Unix mbox format, so only a little extra effort is required to allow Git
    to send the patch as an email. When sending emails with `git send-email`, make
    sure your **Mail User Agent** (**MUA**) does not break the lines in the patch
    files, replace tabs with spaces, and so on. You can test this easily by sending
    a patch to yourself and checking whether it can be applied cleanly to your repository.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `send-email` command can, of course, be used to send more than one patch
    at a time. If a directory is specified instead of a single patch file, all the
    patches in that directory will be sent. We don''t even have to generate the patch
    files before sending them; we can just specify the same range of revisions we
    want to send as we would have specified for the `format-patch` command. Then,
    Git will create the patches on the fly and send them. When we send a series of
    patches this way, it is good practice to create a cover letter with a bit of explanation
    about the patch series that follows. A cover letter can be created by passing
    `--cover-letter` to the `send-email` command. We''ll try sending patches for the
    commits on `develop`, since it is branched from `master` (the same patches as
    in the second example), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check our email inbox and see the four emails we sent: the cover letter
    and the three patches.'
  prefs: []
  type: TYPE_NORMAL
- en: Before sending the patches, the cover letter is filled out and, by default,
    has `[PATCH 0/3] `(if sending three patches) in the subject line. A cover letter
    with only the default template subject and body won't be sent as default. In the
    scripts that come with this chapter, the `git send-email` command invokes the
    `--force` and `--confirm=never` options. This was done for script automation to
    force Git to send the mails even though the cover letter has not been changed
    from the default. You can try to remove these options, put in the `--annotate`
    option, and run the scripts again. You should then be able to edit the cover letter
    and emails that contain the patches before sending them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Git bundles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another method for sharing repository history between repositories is to use
    the `git bundle` command. A Git bundle is a series of commits that can work as
    a remote repository, but without having the full history of a repository included
    in the bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use a fresh clone of the `offline-sharing` repository, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we''ll create a root bundle, as shown in the following command, so that
    the history in the bundle forms a complete history and the initial commit is also
    included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can verify the bundle content with `git bundle verify`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'To make it easy to remember which commit we included as the latest commit in
    the bundle, we create a `tag` that points to this commit; the commit is also pointed
    to by the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We have created the root bundle that contains the initial commits of the repository
    history. We can now create a second bundle that contains the history from the
    tag we just created to the tip of the `develop` branch. Note that, in the following
    command, we use the same name for the bundle file, `myrepo.bundle`, and this will
    overwrite the old bundle file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: It might seem strange to overwrite the bundle file just after creating it, but
    there is some sense in giving bundle files the same name. As you will also see
    in the next recipe, when using a bundle file, you add it to your repository as
    a remote, the URL being the file path of the bundle. The first time you do this
    is with the root bundle file and the URL. The file path of the bundle file will
    be stored as the URL of the remote repository. So, the next time you need to update
    the repository, you just overwrite the bundle file and perform `fetch` from the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we verify the bundle, we can see which commit needs to exist in the target
    repository before the bundle can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We can check the history and see that the `ead7de4` commit is where `develop`
    is branched off, so it makes sense that this commit is the basis for the bundle
    we have just created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f99b9719-e249-4d17-99bd-cce29e881308.png)'
  prefs: []
  type: TYPE_IMG
- en: How it works...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `bundle` command creates a binary file with the history of the specified
    commit range included. When creating the bundle as a range of commits that do
    not include the initial commit in the repository (for example, `bundleForOtherRepo..develop`),
    it's important to make sure that the range matches the history in the repository
    in which the bundle is going to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Git bundle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last example, we saw how we could create bundles from the existing history,
    which contains a specified range of history. Now, we'll learn how to use these
    bundles either to create a new repository or to add a history to an existing one.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same repository and methods as in the last example to create
    bundles, but we''ll recreate them in this example to be able to use them one at
    a time. First, we''ll prepare the repository and the first bundle, as shown in
    the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s create a new repository from the bundle file we just created. We
    can do that with the `git clone` command and by specifying the URL to the remote
    repository as the path to the bundle. We''ll see how to do that in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The new repository is created in the `offline-other` folder. Let''s check the
    history of that repository by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The repository contains, as expected, all the history of the `master` branch
    in the original repository. We can now create a second bundle, the same as in
    the previous example, that contains history from the tag we created (`bundleForOtherRepo`)
    to the tip of the `develop` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As we also saw in the previous example, the bundle requires the `ead7de45a504ee19cece26daf45d0184296f3fec`
    commit to already exist in the repository we''ll use with the bundle. Let''s check
    the repository we created from the first bundle for this commit by using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The commit exists. Now we can use the new bundle file as it has the same filename
    and path as the first bundle we created. We can just use `git fetch` in the `offline-other`
    repository as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now `checkout develop`, and verify that the history for the `develop`
    and `master` branches matches the one in the original repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f262370a-2f5c-4afc-b0dd-0bc0e4b8497a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The bundle is useful for updating the history of repositories on machines where
    the normal transport mechanisms can't be used due to missing network connections
    between the machines, firewall rules, and so on. There are, of course, other methods
    than the Git bundle for transporting history to remote machines. A bare repository
    on a USB stick could also be used, or even plain patches can be applied to a repository.
    The advantage of the Git bundle is that you don't have to write the entire history
    to a bare repository each time you need to update a remote, but only the part
    of history that is missing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating archives from a tree
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, it's useful to have a snapshot of the directory structure, as specified
    by a particular commit, but without the corresponding history. This can, of course,
    be done by checking the particular commit followed by deleting/omitting the `.git`
    folder when creating an archive. But with Git, there is a better way to do this,
    which is built in so it is possible to create an archive from a particular commit
    or reference. When using Git to create the archive, you also make sure that the
    archive only contains the files tracked by Git and not any untracked files or
    folders you might have in your working directory.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll use the same `offline-sharing` repository as was used in the previous
    examples in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How to do it...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We''ll start by creating an archive of the directory structure on the latest
    commit on the `master` branch. The `offline-sharing` repository is checked out
    on the `develop` branch by default, so we''ll use the reference `origin/master`
    to specify the ref for the archive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The `--prefix` option prepends the specified prefix to each file in the archive,
    effectively adding an `offline` directory as a root directory for the files in
    the repository, and the `-o` option tells Git to create the archive in the `offline.zip`
    file, which of course, is compressed in the ZIP format. We can investigate the
    ZIP archive to check whether the files contain the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'If we look in the Git repository in the `origin/master` commit, we can see
    that the files are the same; the `-l` option tells Git to specify each file''s
    size, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `archive` command can also be used to create an archive for a subdirectory
    of the repository. We can use this on the `doc` branch of the repository to ZIP
    the content of the `Documentation` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we can list the contents of the ZIP file and the `Documentation` tree
    at `origin/doc`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'There are other format options besides the ZIP format for the archive, for
    example, `tar`, `tar.gz`, and so on. The format can be specified with the `--format=<format>`
    option or as a suffix to the output filename with the `-o` option. The following
    two commands will produce the same output file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The Git archive command behaves a bit differently if a commit/tag ID or a tree
    ID is passed as an identifier. If a commit or tag ID is given, the ID will be
    stored in a global extended pax header for the TAR format, and as a file comment
    for the ZIP format. If only the tree ID is given, no extra information will be
    stored. You can actually see this in the previous examples, where the first ID
    was given a branch as a reference. As the branch points to a commit, the ID of
    this commit was written as a comment on the file and we can actually see it in
    the output of the archive listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In the second example, we also passed a branch as a reference, but furthermore,
    we specified the `Documentation` folder as the subfolder we wanted to create an
    archive from. This corresponds to passing the ID of the tree to the archive command;
    hence, no extra information will be stored in the archive.
  prefs: []
  type: TYPE_NORMAL
