- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Project History
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the important parts of mastering a **version control system** (**VCS**)
    is exploring project history and making use of the fact that with the VCS, we
    have an archive of every version that has ever existed. For example, you might
    want to examine what other developers did or remind yourself what you are about
    to publish.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to select and view a revision or a range
    of revisions, as well as how to refer to them. The following chapter will continue
    this topic and explain how to find revisions using different criteria, as well
    as how to search through selected revisions; it will also describe how to search
    through project content.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will also introduce the concept of **Directed Acyclic Graph** (**DAG**)
    of revisions and explain how this concept relates to the idea of the project history,
    as well as the ideas of branches, tags, and the current branch in Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the list of topics we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: DAG of revisions as a way of representing history
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Different ways of revision selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting starting branches and tags
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using data from reflog to select revisions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Double-dot (A..B) and triple-dot notation (A…B) for revision range selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced revision range selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The purpose of this chapter is to teach you how to select relevant parts of
    project history. The next chapter will explain how to investigate this further
    by searching through what you’ve selected.
  prefs: []
  type: TYPE_NORMAL
- en: DAGs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes VCSs different from backup applications is *the ability to represent
    more than linear history*. This is necessary both to support the simultaneous
    parallel development by different developers (each developer in their own clone
    of the repository) and to allow independent parallel lines of development – branches.
    For example, with a VCS, you might want to keep the ongoing development and the
    work on bug fixes for the stable version isolated. You can do this by using individual
    branches for those separate lines of development. So, the VCS needs to be able
    to model such a non-linear way of development and needs to have some structure
    to represent it.
  prefs: []
  type: TYPE_NORMAL
- en: The structure that Git uses (on the abstract level) to represent the possibly
    non-linear history of a project is called a **Directed Acyclic** **Graph (DAG)**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram (*Figure 4**.1*) shows an example of a DAG, drawn in
    two different ways. The same graph is represented on both sides of the figure:
    using the free-form layout on the left and the left-to-right layout on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Generic example of a DAG, with the same graph drawn with different
    layouts](img/B21194_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Generic example of a DAG, with the same graph drawn with different
    layouts
  prefs: []
  type: TYPE_NORMAL
- en: A **directed graph** is a data structure from computer science and mathematics
    that’s composed of *nodes* (vertices) connected with *directed edges* (arrows).
    A directed graph is *acyclic* if it doesn’t contain any cycles, which means that
    there is no way to start at some node and follow a sequence of directed edges
    to end up at the starting node again.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding this topic, in my opinion, helps with mastering the art of exploring,
    searching, and shaping the project history. You might want to read it more times
    to internalize this knowledge. It is not, however, required to be able to use
    Git successfully, so this section can be skipped on the first pass.
  prefs: []
  type: TYPE_NORMAL
- en: In a specific realization of a graph, each node represents some object (or a
    piece of data), and each edge from one node to another represents some kind of
    relationship between the objects it connects (or between data represented by nodes).
  prefs: []
  type: TYPE_NORMAL
- en: 'The DAG of revisions in **distributed version control systems** (**DVCSs**)
    uses the following representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nodes**: In DVCSs, each node represents one **revision** (one version) of
    a project (of the entire tree). Those objects are called **commits**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Directed edges**: In DVCSs, each edge represents the *this revision is based
    on that revision* relationship between two revisions. The arrow goes from a later
    **child** revision to an earlier **parent** revision it was based on – that is,
    the revision it was created from. This is *the reverse* of the way most people
    like to think of *the arrow of time* – that is, the arrow pointing from an earlier
    commit to a later one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because directed edges represent the *is based on* causal relationship between
    revisions, the arrows in the DAG of revisions cannot form a cycle. Usually, the
    DAG of revisions is laid out left-to-right (root nodes on the left, leaves on
    the right) or bottom-to-top (most recent revisions on the top). The figures in
    this book and ASCII-art examples in the Git documentation use the left-to-right
    convention, while the Git command line uses bottom-to-top, which is the most recent
    first convention.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two special types of nodes in any DAG (see *Figure 4**.1*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Root nodes** (or **roots**): These are nodes (revisions) that have no parents
    (have no outgoing edges). There is at least one root node in the DAG of revisions,
    which represents the initial (starting) version of a project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaf nodes** (or **leaves**): These are nodes that have no children (no incoming
    edges); there is at least one such node. They represent the most recent versions
    of the project, not having any work based on them. Usually, each leaf in the DAG
    of revisions has a branch head pointing to it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There can be more than one root node in Git’s DAG of revisions. Additional root
    nodes can be created when you’re joining two formerly originally independent projects
    together; each joined project brings its own root node. As this is a very rare
    occasion, with modern Git, you need to pass the **--allow-unrelated-histories**
    option to the **git merge** or **git pull** command to do so, to help avoid mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Another source of root nodes is **orphan branches** – that is, disconnected
    branches with no history in common. They are, for example, used by GitHub to manage
    a project’s web pages together in one repository with the code (in the **gh-pages**
    branch), and by the Git project itself to store pre-generated documentation (the
    **man** and **html** branches) and related projects (the **todo** branch). To
    create such a branch, you need to use the **--orphan** option in **git checkout**
    or **git switch**.
  prefs: []
  type: TYPE_NORMAL
- en: The fact that the DAG can have more than one leaf node means that there is no
    inherent notion of the latest version, as it was in the linear history paradigm.
  prefs: []
  type: TYPE_NORMAL
- en: Whole-tree commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In DVCSs, each node of the DAG of revisions (DVCS’s model of history) represents
    a version of the project as a whole single entity: a **snapshot** of the whole
    directory tree contents of a project.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that by default, each developer will get the history of all the files
    in their clone of the repository. Where needed, they can choose to get only a
    part of the history (shallow clone and/or cloning only selected branches), they
    can checkout only selected files (sparse checkout), or they can use the partial
    clone feature (with, for example, different versions of files contents loaded
    on demand). Those special cases, and more, will be described in [*Chapter 12*](B21194_12.xhtml#_idTextAnchor302),
    *Managing* *Large Repositories*.
  prefs: []
  type: TYPE_NORMAL
- en: Branches and tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A `maintenance`, to help in managing bug fixes to the released stable version
    of a project, while isolating this activity from the rest of the development.
  prefs: []
  type: TYPE_NORMAL
- en: A `v1.3-rc3` tag, among others, to be able to go back to this specific version,
    check the validity of bug reports from your testers, and find the sources of reported
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both branches and tags, sometimes called **references** (**refs**) when used
    together, have the same meaning and almost the same representation within the
    DAG of revisions. They are external references (pointers) to the graph of revisions,
    as shown in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Example DAG of revisions in a VCS with two branches, a single
    tag, one fork point, and a single merge commit](img/B21194_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Example DAG of revisions in a VCS with two branches, a single tag,
    one fork point, and a single merge commit
  prefs: []
  type: TYPE_NORMAL
- en: A `v1.3-rc3` in *Figure 4**.2*. It always points to the same object; it doesn’t
    change. The idea behind having tags is to be able to refer to the given revision
    with a symbolic name and to have this symbolic name mean the same for every developer.
    Checking out or viewing the given tag should provide the same results for everyone.
  prefs: []
  type: TYPE_NORMAL
- en: A `maint` and `master`.)
  prefs: []
  type: TYPE_NORMAL
- en: The branch in the DAG is, as a line of development, the subgraph of the DAG
    composed of those revisions that can be **reached** from the tip of the branch
    (from the branch head) – in other words, of those revisions that you can walk
    to by following the parent edges starting from the branch head.
  prefs: []
  type: TYPE_NORMAL
- en: Git needs to know which branch tip to advance when creating a new commit. It
    needs to know which branch is the current one and is `HEAD` points directly to
    a node in the DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Full names of references (branches and tags)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Originally, Git stored branches and tags in files inside the `.git` administrative
    area, in the `.git/refs/heads/` and `.git/refs/tags/` directories, respectively.
    Modern Git can store information about tags and branches inside the `.git/packed-refs`
    file to avoid handling a very large number of small files. Nevertheless, active
    references use the original *loose* format – one file per reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `HEAD` pointer (denoting the current branch) is stored in `.git/HEAD`.
    It is usually a symbolic reference – for example, **ref: refs/heads/master**.'
  prefs: []
  type: TYPE_NORMAL
- en: The `master` branch is stored in `.git/refs/heads/master` and has `refs/heads/master`
    as its full name (in other words, branches reside in the `refs/heads/` namespace).
    The tip of the branch is referred to as the **head** of a branch, hence the name
    of this namespace. In *loose* format, the file contents are an SHA-1 identifier
    of the most current revision on the branch (the **branch tip**), in plain text
    as hexadecimal digits. It is sometimes required to use the full name if there
    is ambiguity among refs.
  prefs: []
  type: TYPE_NORMAL
- en: The remote-tracking branch, `origin/master`, which remembers the last seen position
    of the `master` branch in the remote repository, `origin`, is stored in `.git/refs/remotes/origin/master`
    and has `refs/remotes/origin/master` as its full name. The concept of **remotes**
    will be explained in [*Chapter 6*](B21194_06.xhtml#_idTextAnchor140), *Collaborative
    Development with Git*, while **remote-tracking branches** will be covered in [*Chapter
    8*](B21194_08_split_000.xhtml#_idTextAnchor196), *Advanced* *Branching Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: The `v1.3-rc3` tag has `refs/tags/v1.3-rc3` as its full name (tags reside in
    the `refs/tags/` namespace). To be more precise, in the case of **annotated**
    and **signed tags**, this file stores a reference to the **tag object**, which,
    in turn, points to the node in the DAG, and not directly to a commit. This is
    the only type of ref that can point to any type of object; branches and remote-tracking
    branches always point to a commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'These full names (fully qualified names) can be seen when using commands intended
    for scripts (so-called `git show-ref`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Branch points
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you create a new branch starting at a given version, the lines of development
    usually diverge. The act of creating a divergent branch is denoted in the DAG
    by a commit that has more than one child – that is, a node pointed to by more
    than one arrow.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Git does not track information about creating (forking) a branch and does not
    mark branch points in any way that they’re preserved across clones and pushes.
    There is information about this event in the **reflog** (**branch: Created from
    HEAD**), but this is local to the repository where branching occurred and is temporary.
    However, if you know that the **B** branch started from the **A** branch, you
    can find the branching point with **git merge-base A B**. In modern Git, you can
    use the **--fork-point** option to make this command use the information from
    the reflog, when available.'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.2*, the `34ac2` commit is a branching point, or a `master` and
    `maint` branches.
  prefs: []
  type: TYPE_NORMAL
- en: Merge commits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Typically, when you’ve used branches to enable independent parallel development,
    you will want to join them later. For example, you would want bug fixes that have
    been applied to the stable (maintenance) branch so that they’re included in the
    main line of development as well (if they’re applicable and weren’t fixed accidentally
    during the main line development).
  prefs: []
  type: TYPE_NORMAL
- en: You would also want to merge changes created in parallel by different developers
    working simultaneously on the same project, each using their own clone of the
    repository, and creating their own lines of commits.
  prefs: []
  type: TYPE_NORMAL
- en: Such a **merge operation** will create a new revision, joining two lines of
    development. The result of this operation will be based on more than one commit.
    The node in the DAG representing said revision will have more than one parent
    and more than one outgoing edge. Such an object is called a **merge commit**.
  prefs: []
  type: TYPE_NORMAL
- en: You can see a merge commit, `3fb00`, in *Figure 4**.2*.
  prefs: []
  type: TYPE_NORMAL
- en: Single revision selection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During development, often, you’ll want to select a single revision in the history
    of the project so that you can examine it or compare it with the current version.
    The ability to select a revision is also the basis for selecting a revision range
    – for example, selecting a subsection of history to examine.
  prefs: []
  type: TYPE_NORMAL
- en: Many Git commands take revision parameters as arguments, which are typically
    denoted by `<rev>` in the Git reference documentation. Git allows you to specify
    a commit or a range of commits in several ways. This will be described in this
    and the next section.
  prefs: []
  type: TYPE_NORMAL
- en: HEAD – the implicit revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most, but not all, Git commands that require the revision parameter default
    to using `HEAD`. For example, `git log` and `git log HEAD` will show the same
    information. You can also use `@` alone as a shortcut for `HEAD`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `HEAD` denotes the **current branch**, or in other words, the commit that
    was checked out into the working directory and forms a base of current work (a
    current revision).
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few other references that are similar to `HEAD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FETCH_HEAD**: This records the information about the remote branches that
    were fetched from a remote repository with your last **git fetch** or **git pull**
    invocation. It is very useful for one-off fetching, with a repository to fetch
    from given by a URL (**git fetch <URL>**), unlike when we’re fetching from a named
    repository such as **origin**, where we can use a remote tracking branch instead,
    such as **origin/master**. Moreover, with named repositories, we can use the reflog
    for the remote-tracking branch – for example, **origin/master@{1}** – to get the
    position before the fetch. Note that **FETCH_HEAD** is overwritten by each fetch
    from any repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ORIG_HEAD**: This records the previous position of the current branch. This
    reference is created by commands that move the current branch in a drastic way
    (creating a new commit doesn’t set **ORIG_HEAD**) to record the position of **HEAD**
    before the operation. This is very useful if you want to undo or abort such an
    operation. However, nowadays, the same can be done using reflogs, which store
    additional information that can be examined in their use; see the *Reflogging
    shortnames* section for more details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can also stumble upon the short-lived temporary references that are used
    during specific operations:'
  prefs: []
  type: TYPE_NORMAL
- en: During a merge, before creating a merge commit, **MERGE_HEAD** records the commit(s)
    that you’re merging into your branch. It vanishes after creating a merge commit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: During a cherry-pick, before creating a commit that copies picked changes into
    another branch, **CHERRY_PICK_HEAD** records the commit that you’ve selected for
    cherry-picking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Branch and tag references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most straightforward and commonly used way to specify a revision is to
    use symbolic names: branches, naming the line of development, pointing to the
    tip of said line; and tags, naming the specific revision. This way of specifying
    revisions can be used to view the history of a line of development, examine the
    most current revision (current work) on a given branch, or compare a branch or
    a tag with the current work.'
  prefs: []
  type: TYPE_NORMAL
- en: You can use any of the *refs* (external references to the DAG of revisions)
    to select a commit. You can use a branch name, a tag name, and a remote-tracking
    branch name in any Git command that requires a revision as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Usually, it is enough to give the *short* name of a branch or tag, such as `git
    log master`, to view the history of a `master` branch, or `git log v1.3-rc3` to
    see how version `v1.3-rc1` came about. It can, however, happen that there are
    different types of refs with the same name, such as both the branch and tag being
    named `dev` (though it is recommended to avoid such situations. Alternatively,
    you could have created (usually by accident) the local `origin/master` branch
    when there was a remote-tracking branch with a short named `origin/master`, tracking
    where the `master` branch was in the remote repository named `origin`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In such a situation, when the ref name is ambiguous, it is disambiguated by
    taking the first match in the following rules (this is a shortened and simplified
    version – for the full list, see the **gitrevisions(7)** manpage):'
  prefs: []
  type: TYPE_NORMAL
- en: The top-level symbolic name – for example, **HEAD**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, the name of the tag (the **refs/tags/** namespace).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, the name of the local branch (the **refs/heads/** namespace).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, the name of the remote-tracking branch (the **refs/remotes/** namespace).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, the name of the remote if a default branch exists for it; the revision
    is said to be the default branch (for example, **refs/remotes/origin/HEAD** for
    **origin** as a parameter).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The --branches, --tags, and similar options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to see the whole graph of revisions, you need a way to specify all
    the refs – that is, branches, remote-tracking branches, and tags. That’s what
    the `--all` option to the `git log` command is for. With this option, Git pretends
    as if all the refs in the `refs/` namespace, along with `HEAD`, were listed as
    starting points for revision traversal (for viewing the history of a project).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to limit yourself to branches, remote-tracking branches, or tags,
    you can use the `--branches`, `--remotes`, or `--tags` option, respectively. All
    of those options take an optional `<pattern>` parameter, which limits respective
    refs to ones matching the given shell glob. If the pattern lacks glob wildcards
    (that is, `*`, `?`, or `[`), then `/*` at the end of the pattern is implied. For
    example, to pretend as if all topic branches (with hierarchical names that begin
    with author initials) and all remote-tracking branches for the `origin` remote
    were listed on the command line, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `--all` option with the `<pattern>` parameter is named `--glob=<pattern>`.
  prefs: []
  type: TYPE_NORMAL
- en: Glob patterns
  prefs: []
  type: TYPE_NORMAL
- en: In computer science, **glob patterns** are used to match strings using a specific
    set of wildcard characters. This is the syntax that’s used by UNIX shells and
    is described on the **glob(7)** manpage. It is simpler but less expressive than
    **regular expressions**.
  prefs: []
  type: TYPE_NORMAL
- en: The most common glob wildcards are *****, **?**, and **[…]**. The ***** wildcard
    character matches any number of characters including none, **?** matches a single
    character, and **[abc]** matches one character from the one listed inside brackets.
    You can simplify the list of characters using the character range – for example,
    **[a-z]**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Pattern matching can be enhanced with the help of the `--exclude=<pattern>`
    option, which affects `--all`, `--branches`, `--tags`, `--remotes`, and `--glob`,
    excluding refs that the next such option would otherwise consider. This option
    can be given multiple times, accumulating exclusion patterns. For example, to
    include all topic branches but exclude your own topic branches (which have names
    starting with `jn/`), you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: SHA-1 and the shortened SHA-1 identifier
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Git, each revision is given a unique identifier (object name), which is
    a `git` `log` output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: It isn’t necessary to give the full 40 characters of the SHA-1 identifier. Git
    is smart enough to figure out what you meant if you provide it with the first
    few characters of the SHA-1 revision identifier, so long as the partial SHA-1
    is at least 4 characters long. To be able to use a shortened SHA-1 to select revision,
    it must be long enough to be unambiguous – that is, there must be one and only
    one commit object where the SHA-1 identifier begins with given characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, both `dae86e1950b1277e545cee180551750029cfe735` and `dae86e` name
    the same commit object, assuming, of course, that that there is no other object
    in your repository whose object name starts with `dae86e`. If there is any ambiguity,
    Git will tell us about all the choices, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In many places, Git shows unambiguously shortened SHA-1 identifiers in its command
    output. For example, in the preceding example of the `git log` output, we can
    see the shortened SHA-1 identifiers in the `Merge:` line.
  prefs: []
  type: TYPE_NORMAL
- en: You can also request that Git use the shortened SHA-1 in place of the full SHA-1
    revision identifiers with the `--abbrev-commit` option. By default, Git will use
    at least 7 characters for the shortened SHA-1; you can change this with the optional
    parameter – for example, `--abbrev-commit=12`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that Git will use as many characters as is required for the shortened SHA-1
    to be unique at the time the command was issued. The parameter to `--abbrev-commit`
    (and the similar `--abbrev` option) is the minimal length of the abbreviation.
  prefs: []
  type: TYPE_NORMAL
- en: A short note about shortened SHA-1
  prefs: []
  type: TYPE_NORMAL
- en: Generally, 8 to 10 characters is more than enough for the shortened SHA-1 (for
    the SHA-1 prefix)to be unique within a project. One of the largest Git projects,
    the Linux kernel, is beginning to need 12 characters out of the possible 40 to
    stay unique. While a hash collision, which means having two revisions (two objects)
    that have the same full SHA-1 identifier, is extremely unlikely (with *1/2^80
    ≈ 1/1.2×10^24* probability), the formerly unique shortened SHA-1 identifier may
    stop being unique due to repository growth.
  prefs: []
  type: TYPE_NORMAL
- en: The SHA-1 and the shortened SHA-1 are often copied from the command output and
    pasted as revision parameters in another command. They can also be used to communicate
    between developers in case of doubt or ambiguity as SHA-1 identifiers are the
    same in any clone of the repository. *Figure 4**.2* uses a five-character shortened
    SHA-1 to identify revisions in the DAG.
  prefs: []
  type: TYPE_NORMAL
- en: Ancestry references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The other main way to specify a revision is via its `HEAD`, a branch head, or
    a tag), and then follow through parent relationships to the commit in question.
    There is a special suffix syntax to specify such ancestry paths.
  prefs: []
  type: TYPE_NORMAL
- en: If you place `^` at the end of a revision name, Git resolves it to mean a (first)
    parent of that revision. For example, `HEAD^` means the parent of `HEAD` – that
    is, the previous commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a shortcut syntax. For merge commits, which have more than one parent,
    you might want to follow any of the parents. To select a parent, put its number
    after the `^` character: using the `^<n>` suffix means the *n-th* parent of a
    revision. We can see that `^` is a short version of `^1`.'
  prefs: []
  type: TYPE_NORMAL
- en: As a special case, `^0` means the commit itself; it is only important when a
    command behaves differently when you’re using the branch name as a parameter and
    when you’re using other revision specifiers. It can be also used to get the commit
    that an annotated (or a signed) tag points to; compare `git show v0.9` and `git
    show v0.9^0`. Note that you can do the latter operation with `<tag>^{commit}`;
    in most cases, it is what `<tag>^{}` would do (follow this until you find an object
    that isn’t a tag).
  prefs: []
  type: TYPE_NORMAL
- en: This suffix syntax is composable. You can use `HEAD^^` to mean the grandparent
    of `HEAD` and the parent of `HEAD^`. There is another shortcut syntax for specifying
    a chain of first parents. Instead of writing *n* times the `^` suffix – that is,
    `^^…^` or `^1^1…^1` – you can simply use `~<n>`. As a special case, `~` is equivalent
    to `~1`, so `HEAD~` and `HEAD^` are equivalent. In a similar vein, `HEAD~2` means
    the first parent of the first parent or the grandparent and is equivalent to `HEAD^^`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also combine everything. For example, you can get the second parent
    of a great-grandparent of `HEAD` (assuming it was a merge commit) by using `HEAD~3^2`,
    and so on. You can use `git name-rev` or `git describe --contains` to find out
    how a revision is related to local refs, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, with `git name-rev --stdin` used as a filter for `git log`,
    after each SHA-1 identifier, you get its ancestry reference in parentheses – for
    example, **(master~1)**.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse ancestry references – git-describe output
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ancestry reference describes how a historic version relates to the current
    branches and tags. It depends on the position of the starting revision. For example,
    `HEAD^` would usually mean a completely different commit next month.
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes, we want to describe how the current version relates to the prior
    named version. For example, we might want to have a human-readable name of the
    current version to store in the generated binary application. We want this name
    to refer to the same revision for everybody. This is the task of `git describe`.
  prefs: []
  type: TYPE_NORMAL
- en: Here, `git describe` finds the most recent tag that can be reached from a given
    revision (by default, from `HEAD`) and uses it to describe that version. If the
    found tag points to the given commit, then (by default) only the tag is shown.
    Otherwise, `git describe` suffixes the tag name with the number of additional
    commits on top of the tagged object and uses the abbreviated SHA-1 identifier
    of the given revision. For example, `v1.0.4-14-g2414721` means that the given
    commit was based on the named (tagged) version `v1.0.4`, which was 14 commits
    ago, and that it has `2414721` as a shortened SHA-1\. Without the SHA-1 abbreviation,
    the notation would be ambiguous; in the presence of non-linear history, there
    can be many revisions that are 14 commits away from the given tag.
  prefs: []
  type: TYPE_NORMAL
- en: Git understands this output format as a revision specifier.
  prefs: []
  type: TYPE_NORMAL
- en: Reflogging shortnames
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To help you recover from some types of mistakes, and to be able to undo changes
    (to go back to the state before the change), Git keeps a `HEAD` and branch references
    have been for the last few months, and how they got there, as described in [*Chapter
    2*](B21194_02.xhtml#_idTextAnchor028), *Developing with Git*. The default is to
    keep reflog entries up to 90 days; 30 days for revisions that can only be reached
    through reflog (for example, amended commits). This can be configured on a ref-by-ref
    basis; see [*Chapter 13*](B21194_13_split_000.xhtml#_idTextAnchor320), *Customizing*
    *and* *Extending Git*.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can examine and manipulate your reflog with the `git reflog` command and
    its subcommands. You can also display history with `git log -g` (or `git` `log
    --walk-reflog`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Every time `HEAD` and your branch head are updated for any reason, Git stores
    that information for you in this local temporary log of ref history. The data
    from the reflog can be used to specify references (and therefore to specify revisions):'
  prefs: []
  type: TYPE_NORMAL
- en: To specify the *n*th prior value of **HEAD** in your local repository, you can
    use **HEAD@{n}** notation that you can see in the **git reflog** output. It’s
    the same with the *n*th prior value of the given branch – for example, **master@{n}**.
    The special syntax, **@{n}**, means the *n*th prior value of the current branch,
    which can be different from **HEAD@{n}**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use this syntax to see where a branch was some specific amount
    of time ago. For instance, to denote where your **master** branch was yesterday
    in your local repository, you can use **master@{yesterday}**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use the **@{-n}** syntax to refer to the *n*th branch that was checked
    out (used) before the current one. In some places, you can simply use **– (dash)**
    in place of **@{-1}**. For example**, git checkout –** or **git switch –** will
    switch to the previous branch.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Upstreaming remote-tracking branches
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The local repository that you use to work doesn’t usually live in isolation.
    It interacts with other repositories, usually at least with the `origin` repository
    it was cloned from (unless it was started from scratch with `git init`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The name of the default remote can be set using **clone.defaultRemoteName**.
  prefs: []
  type: TYPE_NORMAL
- en: For these remote repositories with which you interact often, Git will track
    where their branches were at the time of the last contact.
  prefs: []
  type: TYPE_NORMAL
- en: To follow the movement of branches in the remote repository, Git uses `some-branch`,
    then the `git checkout <some-branch>` command will create a local branch based
    on this remote-tracking branch for you.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when working on a line of development that is to be ultimately
    published to the `next` branch in the `origin` repository, which is tracked by
    the `origin/next` remote-tracking branch, you would create a local `next` branch.
    We say that `origin/next` is upstream of the `next` branch, and we can refer to
    it as `next@{upstream}`.
  prefs: []
  type: TYPE_NORMAL
- en: The `@{upstream}` suffix (short form `<refname>@{u}`), which can only be applied
    to a local branch name, selects the branch that the ref is set to build on top
    of. A missing ref defaults to the current branch – that is, `@{u}` is the upstream
    for the current branch.
  prefs: []
  type: TYPE_NORMAL
- en: There is also `[<branch>]@{push}`, which is useful for triangular workflows,
    where the repository you push your changes to is different from the repository
    you get updates from.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting revisions via a commit message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can specify the revision by matching its commit message with a regular
    expression. The `:/<pattern>` notation (for example, `:/^Bugfix`) specifies the
    youngest matching commit that can be reached from any ref, while `<rev>^{/<pattern>}`
    (for example, `next^{/fix bug}`) specifies the youngest matching commit that can
    be reached from `<rev>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This revision specifier gives similar results to the `--grep=<pattern>` option
    to `git log`, but it’s composable. This means that it can be combined with other
    components, such as ancestry references. On the other hand, it only returns the
    first (youngest) matching revision, while the `--grep` option returns all matching
    revisions.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting the revision range
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that you can specify individual revisions in multiple ways, let’s learn
    how to specify ranges of revisions, a subset of the DAG we want to examine. **Revision
    ranges** are particularly useful for viewing selected parts of the history of
    a project.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can use range specifications to answer questions such as, “What
    work is on this branch that I haven’t yet merged into my main branch?”, “What
    works on my main branch I haven’t yet published?”, or simply “What was done on
    this branch since its creation?”
  prefs: []
  type: TYPE_NORMAL
- en: Single revision as a revision range
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: History traversing commands such as `git log` operate on a set of commits, walking
    down a chain of revisions from child to parent. These kinds of commands, given
    a single revision as an argument (as described in the *Single revision selection*
    section of this chapter), will show the set of commits that can be reached from
    that revision, following the commit ancestry chain, all the way down to root commits.
    Thanks to Git using pager by default, Git will stop after one full page – that
    is, one full screen of commits.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `git log master` would show all commits that can be found from
    the tip of a `master` branch (all revisions that are or were based on the current
    work on the said branch), which means that it would show the whole `master` branch
    – that is, the whole line of development.
  prefs: []
  type: TYPE_NORMAL
- en: Double-dot notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The most common range specification is the double-dot syntax, `A..B`. For a
    linear history, it means all revisions between `A` and `B`, or to be more exact
    all the commits that are in `B` but not in `A`, as shown in *Figure 4**.3*. For
    example, the `HEAD~4..HEAD` range means four commits: `HEAD`, `HEAD^`, `HEAD^^`,
    and `HEAD^^^`. In other words, it means `HEAD~0`, `HEAD~1`, `HEAD~2`, and `HEAD~3`,
    assuming that there is no merge commit between the current branch and its fourth
    ancestor:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Double-dot notation A..B for linear history. The selected revision
    range is marked with a thin halo (with an outline)](img/B21194_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Double-dot notation A..B for linear history. The selected revision
    range is marked with a thin halo (with an outline)
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you want to include a starting commit (in the general case, boundary commits),
    which Git considers uninteresting by default, you can use the **--boundary** option
    with **git log**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The situation is more complicated for a history that is not a straight line.
    One such case is when `A` is not the ancestor of `B` (there is no path in the
    DAG of revisions leading from `B` to `A`), but both have a common ancestor, as
    shown in *Figure 4**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Double-dot notation A..B for non-linear history, where revision
    A is not an ancestor of revision B, showing the case with a divergent history
    (with a fork point)](img/B21194_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Double-dot notation A..B for non-linear history, where revision
    A is not an ancestor of revision B, showing the case with a divergent history
    (with a fork point)
  prefs: []
  type: TYPE_NORMAL
- en: 'Another situation with non-linear history is when the path from `B` to `A`
    is not a simple line – that is, when there are merge commits between `A` and `B`,
    as shown in *Figure 4**.5*. In the view of nonlinear history, the double-dot notation,
    `A..B`, or *between A and B*, is defined as those commits that can be reached
    from `A` while being not reachable from `B`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – Double-dot notation A..B for a non-linear history, with merge
    commit between A and B. To exclude commits marked with *, use the --strict-ancestor
    option](img/B21194_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – Double-dot notation A..B for a non-linear history, with merge commit
    between A and B. To exclude commits marked with *, use the --strict-ancestor option
  prefs: []
  type: TYPE_NORMAL
- en: For Git, `A..B` means a range of all commits that can be reached from one revision
    (`B`) but can’t be reached from another revision (`A`) while following the ancestry
    chain. In the case of divergent `A` and `B`, as shown in *Figure 4**.4*, this
    is simply all commits in `B` from the branch point of `A`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, say your `master` and `experiment` branches diverge. You want to
    see what’s in your `experiment` branch that hasn’t been merged into your `master`
    branch yet. You can ask Git to show you a log of just those commits with `master..experiment`.
  prefs: []
  type: TYPE_NORMAL
- en: If, on the other hand, you want to see the opposite – all the commits in `master`
    that aren’t in `experiment` – you can reverse the branch names. The `experiment..master`
    notation shows you everything in `master` that can’t be reached from `experiment`.
  prefs: []
  type: TYPE_NORMAL
- en: Another example is that `origin/master..HEAD` shows what you’re about to push
    to a remote repository (commits in your current branch that are not yet present
    in the `master` branch in `origin`), while `HEAD..origin/master` can show what
    you have fetched but not yet merged in.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also leave off one side of the syntax to have Git assume **HEAD**:
    **origin/master..** is **origin/master..HEAD** and **..origin/master** is **HEAD..origin/master**;
    Git substitutes **HEAD** if one side is missing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git uses double-dot notation in many places, such as in the output of `git
    fetch` and `git push` for ordinary fast-forward cases. Here, you can just copy
    and paste a fragment of output as parameters to `git log`. In this case, the beginning
    of the range is the ancestor of the end of the range – that is, the range is linear:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating the range by including and excluding revisions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The double-dot `A..B` syntax is very useful and quite intuitive, but it is a
    shorthand notation. Usually, it’s enough, but sometimes, you might want more than
    it provides. Perhaps you want to specify more than two branches to indicate your
    revision, such as seeing what commits are present in any of several branches that
    aren’t in the branch you’re currently on. Perhaps you want to see only those changes
    on the `master` branch that aren’t in any of the other long-lived branches.
  prefs: []
  type: TYPE_NORMAL
- en: Git allows you to exclude the commits that can be reached from a given revision
    by *prefixing* said revision with `^`. For example, to view all revisions that
    are on `maint` or `master`, but are not in `next`, you can use `git log maint
    master ^next`. This means that the `A..B` notation is just a shorthand for `B
    ^A`.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of having to use the `^` character as a prefix for each of the revisions
    we want to exclude, Git allows us to use the `--not` option, which *negates* all
    the following revisions. For example, `B ^A ^C` might be written as `B --not A
    C`. This is useful, for example, when we’re generating excluded revisions programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Thus, these three commands are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The revision range for a single revision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is another useful shortcut, `A^!`, that is a range composed of a single
    commit. For non-merge commits, it is simply `A^..A`.
  prefs: []
  type: TYPE_NORMAL
- en: For merge commits, `A^!` excludes all the parents. With the help of yet another
    special notation, namely `A^@`, denoting all the parents of `A` (that is, `A^1`,
    `A^2`,… `A^n`), we can say that `A^!` is a shortcut for `A --``not A^@`.
  prefs: []
  type: TYPE_NORMAL
- en: Triple-dot notation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last major syntax for specifying revision ranges is the triple-dot syntax,
    `A...B`. It selects all the commits that can be reached by either of two references,
    but not by both of them; see *Figure 4**.6*. In mathematics, this notation is
    called the **symmetric difference of A** **and B**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – A triple-dot notation, A...B, for a non-linear history, where
    the selected range is shown with a thin outline, and O is the boundary commit
    – the merge base of A and B](img/B21194_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – A triple-dot notation, A...B, for a non-linear history, where the
    selected range is shown with a thin outline, and O is the boundary commit – the
    merge base of A and B
  prefs: []
  type: TYPE_NORMAL
- en: It is a shortcut notation for `A B --not $(git merge-base --all A B)`, where
    `$(…)` denotes shell `git merge-base` command to find out all the best common
    ancestors (all merge bases), and then paste its output on the command line so
    that it can be negated.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common switch to the `git log` command to use with the triple dot notation
    is `--left-right`. This option makes Git show which side of the range each commit
    is in by prefixing commits from the left-hand side (`A` in `A...B`) with `<`,
    and those from the right (`B` in `A...B`) with `>`, as shown in *Figure 4**.6*
    and the following example. This helps make the data more useful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: If the **--left-right** option is combined with **--boundary**, these normally
    uninteresting boundary commits are prefixed with **-**.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of using the triple-dot **A...B** revision range, these boundary
    commits are **git merge-base --all** **A B**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Git uses triple-dot notation in `git fetch` and `git push` output when there
    is a **forced update**, in cases where the old version (left-hand side) and the
    updated version (right-hand side) diverged, and the new version was forced to
    overwrite the old version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Using the revision range notation in diff
  prefs: []
  type: TYPE_NORMAL
- en: To make it easier to copy and paste between the **log** and **diff** commands,
    Git allows us to use the *revision range* double-dot notation, **A..B**, and triple-dot,
    **A...B**, as a *set of revisions (endpoints)* in the **git** **diff** command.
  prefs: []
  type: TYPE_NORMAL
- en: For Git, using **git diff A..B** is the same as **git diff A B**, which means
    the difference between revision **A** and revision **B**. If the revision on either
    side of the double dot is omitted, it will have the same effect as using **HEAD**
    instead. For example, **git diff A..** is equivalent to **git diff** **A HEAD**.
  prefs: []
  type: TYPE_NORMAL
- en: The **git diff A...B** notation is intended to show incoming changes on branch
    **B**. Incoming changes mean revisions up to **B**, starting at a common ancestor
    – that is, a merge base of both **A** and **B**. Thus, writing **git diff A...B**
    is equivalent to **git diff $(git merge-base A B) B**; note that **git merge-base**
    is without **--all** here. The result of this convention makes it so that a copy
    and paste of the **git fetch** output (whether with double-dot or triple-dot)
    as an argument to **git diff** will always show fetched changes. Note, however,
    that it doesn’t include changes that were made on **A** since divergence at all!
  prefs: []
  type: TYPE_NORMAL
- en: With modern Git, you can use the less cryptic **git diff --merge-base A B**
    instead of using triple-dot notation – that is, **git** **diff A...B**.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, this feature makes it possible to use **git diff A^!** to view
    how revision **A** differs from its parent (it’s the shortcut for **git diff**
    **A^ A**).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered the various ways you can explore project history: to find
    relevant revisions, select revisions to display, and for further analysis.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We started by describing the conceptual model of project history: the DAG of
    revisions. Understanding this concept is very important because many selection
    tools refer directly or indirectly to the DAG.'
  prefs: []
  type: TYPE_NORMAL
- en: Then, you learned how to select a single revision and range of revisions, as
    well as how the concept of revision range works for a non-linear history. We can
    use this knowledge to see what changes were made on a branch since its divergence
    from the base branch, and vice versa; we can also examine what happened to both
    branches since their divergence.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting revisions is an important first step in searching through project
    history. This will be described in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: How would you list all revisions that are present upstream for the current branch
    but are not present in the current branch (are not integrated)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How would you list all revisions that you would send using **git push**, allowing
    for a triangular workflow (remote to push to is different from remote to pull
    from)?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you find all divergent changes in two branches, **A** and **B**, starting
    from a fork point, and show which changeset is present on which branch?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you list all commits that were made on any remote-tracking branch whose
    name starts with **fix-**, from any remote repository?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the simplest way of switching to the previous branch, and how does it
    work?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are the answers to this chapter’s questions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Combine the double-dot notation with the notation for the upstream branch:
    **git** **log ..@****{upstream}**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **git log @{push}..HEAD**, combining double-dot notation with the “where
    to push to” notation. Note that for simple workflows, **@{push}** is the same
    as **@{upstream}**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the triple-dot notation and the appropriate **git log** option: **git log
    --left-right** **A...B**.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use the **--remotes[=<pattern>]** option with the appropriate glob pattern:
    **git** **log --remotes=*/fix-***.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use **git checkout –** or **git switch -**. In those commands, **-** means **@{-1}**,
    which uses the reflog to find the previous value of the current branch.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: 'gitrevisions(7) – specifying revisions and ranges for Git: [https://git-scm.com/docs/gitrevisions](https://git-scm.com/docs/gitrevisions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Scott Chacon, Ben Straub: *Pro Git*, 2nd Edition (2014), Apress *Chapter 2**.3:
    Git Basics - Viewing the Commit* *History*: [https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History](https://git-scm.com/book/en/v2/Git-Basics-Viewing-the-Commit-History)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*glob(7)* – globbing pathnames (shell wildcard patterns): [https://man7.org/linux/man-pages/man7/glob.7.html](https://man7.org/linux/man-pages/man7/glob.7.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Jan Goyvaerts: *Regular Expressions Tutorial: Learn How to Use and Get The
    Most out of Regular* *Expressions*: [https://www.regular-expressions.info/tutorial.html](https://www.regular-expressions.info/tutorial.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
