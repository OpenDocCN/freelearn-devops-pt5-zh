- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playbooks and Roles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have worked mostly with ad hoc Ansible commands for
    simplicity and to help you to understand the fundamentals. However, the lifeblood
    of Ansible is most certainly the playbook, which is a logical organization of
    tasks (think ad hoc commands) in a structure that creates a useful outcome. This
    might be to deploy a web server on a newly built virtual machine, or it might
    be to apply a security policy. It might even involve handling the whole build
    process for a virtual machine! The possibilities are endless. Ansible playbooks,
    as we have already covered, are designed to be simple to write and easy to read
    – they are intended to be self-documenting and, as such, will form a valuable
    part of your IT processes.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore playbooks in greater depth, from the basics
    of their creation to more advanced concepts such as running tasks in loops and
    blocks, performing conditional logic, and – perhaps one of the most important
    concepts for playbook organization and code reuse – Ansible roles. We will cover
    roles in more detail later, but just know that this is something you will want
    to use as much as possible when creating manageable playbook code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Specifically, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the playbook framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding roles – the playbook organizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using conditions in your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeating tasks with loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Grouping tasks using blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring play execution via strategies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `ansible-pull`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    detailed in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started
    with Ansible*, and are using the most recent version available – the examples
    in this chapter were tested with Ansible 8.0 and `ansible-core` 2.15\. This chapter
    also assumes that you have at least one additional host to test against, and this
    should be Linux-based. Although we will give specific examples of hostnames in
    this chapter, you are free to substitute them with your own hostnames and/or IP
    addresses, and details of how to do this will be provided in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code bundle for this chapter is available here: [https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204](https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%204).'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the playbook framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A playbook allows you to manage multiple configurations and complex deployments
    on many machines simply and easily. This is one of the key benefits of using Ansible
    for the delivery of complex applications. With playbooks, you can organize your
    tasks in a logical structure, as tasks are (generally) executed in the order they
    are written, allowing you to have a good deal of control over your automation
    processes. With that said, it is possible to perform tasks asynchronously, so
    where tasks are not executed in sequence, we will highlight this. Our goal is
    that once you complete this chapter, you will understand the best practices to
    write your own Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although YAML format is easy to read and write, it is very pedantic when it
    comes to spacing. For example, you cannot use tabs to set indentation even though
    on the screen a tab and four spaces might look identical – in YAML, they are not.
    We recommend that you adopt an editor with YAML support to aid you in writing
    your playbooks if you are doing this for the first time – perhaps Vim, Visual
    Studio Code, or Eclipse – as these will help you to ensure that your indentation
    is correct. To test the playbooks we develop in this chapter, we will create a
    variant of the inventory created in [*Chapter 3*](B20846_03.xhtml#_idTextAnchor158),
    *Defining Your Inventory* (unless stated otherwise):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s dive right in and get started writing a playbook. In [*Chapter 2*](B20846_02.xhtml#_idTextAnchor099),
    *Understanding the Fundamentals of Ansible*, we covered some of the basic aspects
    of the YAML syntax and structure required to create a playbook, so we won’t repeat
    these in detail here. Rather, we will build on them to show you what playbook
    development is all about:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a simple playbook (called `myplaybook.yml`) to run on the hosts in the
    `frontends` host group defined in our inventory file. We can set the user that
    will access the hosts using the `remote_user` directive in the playbook, as demonstrated
    in the following (you can also use the `--user` switch on the command line, but
    as this chapter is about playbook development, we’ll ignore that for now):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add another task below the first, which will run the `ansible.builtin.shell`
    module (that will, in turn, run the `ls` command on the remote hosts). We’ll also
    add the `ignore_errors` directive to this task to ensure that our playbook doesn’t
    fail if the `ls` command fails (for example, if the directory we’re trying to
    list doesn’t exist). Be careful with the indentation and ensure that it matches
    that of the first part of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s see how our newly created playbook behaves when we run it with the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output from this playbook run should look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Demonstrating the execution of a playbook where errors are willfully
    ignored](img/B20846_04_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Demonstrating the execution of a playbook where errors are willfully
    ignored
  prefs: []
  type: TYPE_NORMAL
- en: From the output of the playbook run, you can see that our two tasks were executed
    in the order in which they were specified. We can see that the `ls` command failed
    because we tried to list a directory that did not exist, but the playbook did
    not register any `failed` tasks because we set `ignore_errors` to `true` for this
    task (and only this task).
  prefs: []
  type: TYPE_NORMAL
- en: Most Ansible modules (with the exception of those that run user-defined commands
    such as `ansible.builtin.shell`, `ansible.builtin.command`, and `ansible.builtin.raw`)
    are coded to be idempotent – that is to say, if you run the same task twice, the
    results will be the same, and the task will not make the same change twice; if
    it detects that the action it is being requested to perform has been completed,
    then it does not perform it a second time. This, of course, is not possible for
    the aforementioned modules, as they could be used to perform just about any conceivable
    task – hence, how could the module know it was being performed twice?
  prefs: []
  type: TYPE_NORMAL
- en: 'Every module returns a set of results, and among these results is the task
    status. You can see these summarized at the bottom of the preceding playbook run
    output, and their meaning is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ok`: The task ran successfully and no changes were made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`changed`: The task ran successfully and changes were made'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`failed`: The task failed to run (but the host was reachable)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unreachable`: The host was unreachable to run the task on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`skipped`: This task was skipped'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignored`: This task was ignored (for example, in the case of `ignore_errors`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rescued`: We will see an example of this later when we look at blocks and
    rescue tasks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These statuses can be very useful – for example, if we have a task to deploy
    a new Apache configuration file from a template, we know we must restart the Apache
    service for the changes to be picked up. However, we only want to do this if the
    file was actually changed – if no changes were made, we don’t want to needlessly
    restart Apache, as it would interrupt people who might be using the service. Hence,
    we can use the `notify` action, which tells Ansible to call a `handler` when (and
    only when) the result from a task is `changed`. In brief, a handler is a special
    type of task that is run as a result of a `notify`. However, unlike Ansible playbook
    tasks, which are performed in sequence, handlers are all grouped together and
    run at the very end of the play. Also, they can be notified more than once but
    will only be run once regardless, again preventing needless service restarts.
    Consider the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To keep the output concise, I’ve turned off fact-gathering for this playbook
    (we won’t use facts in any of the tasks). I’m also running this on just one host
    again for conciseness, but you are welcome to expand the demo code as you wish.
    If we run this task for the first time, we will see the following results:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Note how the handler was run at the end, as the configuration file was updated.
    However, if we run this playbook a second time without making any changes to the
    template or configuration file, we will see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the handler was not called, as the result from the configuration
    task was `ok`. All handlers should have a globally unique name so that the `notify`
    action can call the correct handler. You can also call multiple handlers by setting
    a common name to use the `listen` directive – this way, you can call either the
    handler `name` or the `listen` string, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We only have one task in the playbook, but when we run it, both handlers are
    called. Also, remember that we said earlier that `ansible.builtin.command` was
    among a set of modules that were a special case because they can’t detect whether
    a change has occurred – as a result, they always return the `changed` value, and
    so, in this demo playbook, the handlers will always be notified, even when we
    run it a second time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: These are some of the fundamentals that you need to know to start writing your
    own playbooks. With these under your belt, let’s run through a comparison of ad
    hoc commands and playbooks in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing playbooks and ad hoc tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ad hoc commands allow you to quickly create and execute one-off commands, without
    keeping any record of what was done (other than perhaps your shell history). These
    serve an important purpose and can be very valuable in getting small changes made
    quickly and for learning Ansible and its modules.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks, by contrast, are logically organized sets of tasks (each could conceivably
    be an ad hoc command), put together in a sequence that performs one bigger action.
    The addition of conditional logic, error handling, and so on means that, very
    often, the benefits of playbooks outweigh the usefulness of ad hoc commands. In
    addition, provided you keep them organized, you will have copies of all previous
    playbooks that you run, so you will be able to refer back (if you ever need to)
    to see what you ran and when.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s develop a practical example – suppose you want to install Apache 2.4 on
    Ubuntu Server. There are a number of steps involved even if the default configuration
    is sufficient (which is unlikely, but for now, we’ll keep the example simple).
    If you were to perform the basic installation by hand, you would need to install
    the package, open up the firewall, and ensure the service is running (and runs
    at boot time).
  prefs: []
  type: TYPE_NORMAL
- en: 'To perform these commands in the shell, you might do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, for each of these commands, there is an equivalent ad hoc Ansible command
    that you can run. We won’t go through all of them here in the interests of space;
    however, let’s say you want to restart the Apache service – if so, you could run
    an ad hoc command similar to the following (again, we will perform it only on
    one host for conciseness):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'When run successfully, you will see pages of shell output containing all of
    the variable data returned from running the `ansible.builtin.service` module.
    A snippet of the output from running this ad hoc command is shown here for you
    to check yours against – the key thing being that the command resulted in the
    `changed` status, meaning that it ran successfully and that the service was indeed
    restarted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You, of course, could create and execute a series of ad hoc commands to replicate
    the multiple shell commands given previously and run them all individually. With
    a bit of cleverness, you should reduce this from four commands (for example, the
    Ansible `ansible.builtin.service` module can both enable a service at boot time
    and restart it in one ad hoc command). However, you would still ultimately end
    up with at least two or three ad hoc commands, and if you want to run these again
    later on another server, you will need to refer to your notes to figure out how
    you did it.
  prefs: []
  type: TYPE_NORMAL
- en: 'A playbook is, hence, a far more valuable way to approach this – not only will
    it perform all of the steps in one go but it will also give you a record of how
    it was done for you to refer to later on. There are multiple ways to do this,
    but consider the following as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when you run this, you should see that all of our installation requirements
    have been completed by one fairly simple and easy-to-read playbook. There is a
    new concept here, loops, which we haven’t covered yet, but don’t worry – we will
    cover this later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this is far better to capture what was actually done and document
    it in a format that someone else can easily pick up. Even though we will cover
    loops later on in the book, it’s fairly easy to see from the preceding example
    how they might work. With this established, let’s proceed to the next section
    to look in more detail at a couple of terms we have used several times to ensure
    you are clear on their meanings – **plays** and **tasks**.
  prefs: []
  type: TYPE_NORMAL
- en: Defining plays and tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, when we have worked with playbooks, we have created one single play
    per playbook (which logically is the minimum you can do). However, you can have
    more than one play in a playbook, and a “*play*” in Ansible terms is simply a
    set of tasks (and roles, handlers, and other Ansible facets) associated with a
    host (or group of hosts). A task is the smallest possible element of a play, and
    it is responsible for running a single module with a set of arguments to achieve
    a specific goal. Of course, in theory, this sounds quite complex, but when backed
    up by a practical example, it becomes quite simple to understand.
  prefs: []
  type: TYPE_NORMAL
- en: If we refer to our example inventory, this describes a simple two-tier architecture
    (we’ve left out the database tier for now). Now, suppose we want to write a single
    playbook to configure both the frontend servers and the application servers. We
    could use two separate playbooks to configure the frontend and application servers,
    but this risks fragmenting your code and making it difficult to organize. However,
    frontend servers and application servers are going to be (by their very nature)
    fundamentally different and so are unlikely to be configured with the same set
    of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this problem is to create a single playbook with two plays in
    it. The start of each play can be identified by the line at the lowest indentation
    (that is, zero spaces in front of it).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started with building up our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the first play to the playbook and define some simple tasks to set up the
    Apache server on the frontend, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately below this, in the same file, add the second play to configure
    the application tier servers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, you have two plays – one to install web servers in the `frontends` group
    and one to install application servers in the `apps` group, all combined into
    one simple playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we run this playbook, we’ll see the two plays performed sequentially,
    in the order they appear in the playbook. Note the presence of the `PLAY` keyword,
    which denotes the start of each play. Use the following command to run the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output from your playbook run should look something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 –  Demonstrating the execution of a playbook containing two plays](img/B20846_04_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Demonstrating the execution of a playbook containing two plays
  prefs: []
  type: TYPE_NORMAL
- en: There we have it – one playbook, yet two distinct plays operating on different
    sets of hosts from the provided inventory. This is very powerful, especially when
    combined with roles (which will be covered later in this book). Of course, you
    can have just one play in your playbook – you don’t have to have multiple ones,
    but it is important to be able to develop multi-play playbooks, as you will almost
    certainly find them useful as your environment gets more complex.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks are the lifeblood of Ansible automation – they extend it beyond single
    tasks/commands (which in themselves are incredibly powerful) to a whole series
    of tasks organized logically. As you extend your library of playbooks, however,
    how do you keep your work organized? How do you efficiently reuse the same blocks
    of code? In the preceding example, we installed Apache, and this might be a requirement
    on a number of your servers. However, should you attempt to manage them all from
    one playbook? Or should you perhaps keep copying and pasting the same block of
    code over and over again? There is a better way, and in Ansible terms, we need
    to start looking at roles, which we shall do in the very next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding roles – the playbook organizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Roles are designed to enable you to efficiently and effectively reuse Ansible
    code. They always follow a known structure and often will include sensible default
    values for variables, error handling, handlers, and so on. Taking our Apache installation
    example from the previous chapter, we know that this is something that we might
    want to do over and over again, perhaps with a different configuration file each
    time, and perhaps with a few other tweaks on a per-server (or per-inventory group)
    basis. In Ansible, the most efficient way to support the reuse of this code in
    this way would be to create it as a role.
  prefs: []
  type: TYPE_NORMAL
- en: The process of creating roles is in fact very simple – Ansible will (by default)
    look within the same directory that you are running your playbook from for a `roles/`
    directory, and in here, you will create one subdirectory for each role. The role
    name is derived from the subdirectory name. There is no need to create complex
    metadata or anything else – it really is that simple. Within each subdirectory
    goes a fixed directory structure that tells Ansible what the tasks, default variables,
    handlers, and so on are for each role.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `roles/` directory is not the only place Ansible will look for roles – this
    is the first directory it will look in, but it will then look in `/etc/ansible/roles`
    for any additional roles. This can be further customized through the Ansible configuration
    file, as discussed in [*Chapter 2*](B20846_02.xhtml#_idTextAnchor099), *Understanding
    the Fundamentals* *of Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore this in a little more detail. Consider the following directory
    structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The preceding directory structure shows two roles defined in our hypothetical
    playbook directory, called `installapache` and `installtomcat`. Within each of
    these directories, you will see a series of subdirectories. These subdirectories
    do not need to exist (there’ll be more on what they mean in a minute, but, for
    example, if your role has no handlers, then `handlers/` does not need to be created).
    However, where you do require such a directory, you should populate it with a
    YAML file named `main.yml`. Each of these `main.yml` files will be expected to
    have certain contents, depending on the directory that contained them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The subdirectories that can exist inside of a role are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`tasks`: This is the most common directory to find in a role, and it contains
    all of the Ansible tasks that the role should perform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`handlers`: All handlers used in the role should go into this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`defaults`: All default variables for the role go in here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars`: These are other role variables – these override those declared in the
    `defaults/` directory, as they are higher up the precedence order.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`files`: Files needed by the role should go in here – for example, any configuration
    files that need to be deployed to the target hosts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templates`: Distinct from the `files/` directory, this directory should contain
    all templates used by the role.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`meta`: Any metadata needed for the role goes in here. For example, roles are
    normally executed in the order they are called from the parent playbook; however,
    sometimes, a role will have dependency roles that need to be run first, and if
    this is the case, they can be declared within this directory.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For the examples we will develop in this part of this chapter, we will need
    an inventory, so let’s reuse the inventory we used in the previous section (included
    here for convenience):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let’s get started with some practical exercises to help you to learn how to
    create and work with roles. We’ll start by creating a role called `installapache`,
    which will handle the Apache installation process we looked at in the previous
    section. However, here, we will expand it to cover the installation of Apache
    on both Fedora and Ubuntu. This is a good practice, especially if you are looking
    to submit your roles back to the community, as the more general-purpose they are
    (and the wider the range of systems they will work on), the more useful they will
    be to people.
  prefs: []
  type: TYPE_NORMAL
- en: 'Step through the following process to create your first role:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directory structure for the `installapache` role from within your
    chosen playbook directory – this is as simple as this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- name: import a tasks based on OS platform'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'import_tasks: fedora.yml'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'when: ansible_distribution == ''Fedora'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '- import_tasks: ubuntu.yml'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'when: ansible_distribution == ''Ubuntu'''
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `fedora.yml` in `roles/installapache/tasks` to install the latest version
    of the Apache web server via the `dnf` package manager. This should contain the
    following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file called `ubuntu.yml` in `roles/installapache/tasks` to install
    the latest version of the Apache web server via the `apt` package manager on Ubuntu.
    Note how the content differs between Fedora and Ubuntu hosts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: For now, we’re keeping our code for a role really simple – however, you can
    see that the preceding tasks’ files are just like an Ansible playbook, except
    that they lack the play definition. As they do not come under a play, they are
    also at a lower indentation level than in a playbook, but apart from this difference,
    the code should look very familiar to you. In fact, this is part of the beauty
    of roles – as long as you pay attention to getting the indentation level right,
    you can more or less use the same code in a playbook or a role.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, roles can’t be run directly – we have to create a playbook to call them,
    so let’s write a simple playbook to call our newly created role. This has a play
    definition just like we saw before, but rather than having a `tasks:` section
    within the play, we have a `roles:` section where the roles are declared instead.
    Convention dictates that this file is called `site.yml`, but you are free to call
    it whatever you like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'For clarity, your final directory structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'With this completed, you can now run your `site.yml` playbook using `ansible-playbook`
    in the normal way – you should see output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: That’s it – you have created, at the simplest possible level, your first role.
    Of course (as we discussed earlier), there is much more to a role than just the
    simple tasks that we have added here, and we will see expanded examples as we
    work through this chapter. However, the preceding example is intended to show
    you how quick and easy it is to get started with roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we look at some of the other aspects relating to roles, let’s take a
    look at some other ways to call your role. Ansible allows you to statically import
    or dynamically include roles when you write a playbook. The syntax between importing
    or including a role is subtly different, and notably, both go in the `tasks` section
    of your playbook rather than in the `roles` section. The following is a hypothetical
    example that shows both options in a really simple playbook. The `roles/` directory
    structure, including both the `common` and `approle` roles, is created in a similar
    manner to the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These features were not available in versions of Ansible earlier than 2.3, and
    their usage changed slightly in version 2.4 for consistency with the way that
    some other Ansible features work. We will not worry about the details of this
    here, as the core is now on release 2.15, so unless you absolutely have to run
    a much earlier version of Ansible, it is sufficient to assume that these two statements
    work, as we shall outline in the following.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, the `ansible.builtin.import_role` statement performs a static
    import of the role you specify at the time when all playbook code is parsed. Hence,
    roles brought into your playbook using the `ansible.builtin.import_role` statement
    are treated just like any other code in a play or role when Ansible begins parsing.
    Using `ansible.builtin.import_role` is basically the same as declaring your roles
    after the `roles:` statement in `site.yml`, just as we did in the preceding example.
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible.builtin.include_role` is subtly but fundamentally different in that
    the role you specify is not evaluated when the playbook is parsed initially –
    rather, it is processed dynamically during the playbook run, at the point at which
    `ansible.builtin.include_role` is encountered.'
  prefs: []
  type: TYPE_NORMAL
- en: Probably the most fundamental reason to choose between the `include` or `import`
    statements given in the preceding is looping – if you need to run a role within
    a loop, you cannot do so with `import_role`, so you must use `include_role`. There
    are, however, both benefits and limitations to both, and you will need to choose
    the most appropriate one for your scenario – the official Ansible documentation
    ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static](https://docs.ansible.com/ansible/latest/user_guide/playbooks_reuse.xhtml#dynamic-vs-static))
    will help you to make the right decision.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen in this section, roles are incredibly simple to get started
    with and yet offer an incredibly powerful way in which to organize and reuse your
    Ansible code. In the next section, we will expand upon our simple task-based example
    by looking at adding role-specific variables and dependencies to your code.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up role-based variables and dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables are at the heart of making Ansible playbooks and roles reusable, as
    they allow the same code to be repurposed with slightly different values or configuration
    data. The Ansible role directory structure allows for role-specific variables
    to be declared in two locations. Although, at first, the difference between these
    two locations may not seem obvious, it is of fundamental importance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Role-based variables can go in one of two locations:'
  prefs: []
  type: TYPE_NORMAL
- en: '`defaults/main.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars/main.yml`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between these two locations is their position in Ansible’s variable
    order of precedence ([https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable)).
    Variables that go in the `defaults/` directory are one of the lowest in terms
    of precedence so are easily overridden. This location is where you would put variables
    that you want to override easily, but where you don’t want to leave a variable
    undefined. For example, if you install Apache Tomcat, you might build a role to
    install a specific version. However, you don’t want the role to exit with an error
    if someone forgets to set the version – rather, you would prefer to set a sensible
    default, such as `9.0`, that can then be overridden with inventory variables or
    on the command line (using the `-e` or `--extra-vars` switches). In this way,
    you know the role will work even without someone explicitly setting this variable,
    but it can easily be changed to a newer Tomcat version if desired.
  prefs: []
  type: TYPE_NORMAL
- en: Variables that go in the `vars/` directory, however, come much higher up on
    Ansible’s variable precedence ordering. These will not be overridden by inventory
    variables, and so it should be used for variable data that it is more important
    to keep static. Of course, this is not to say they can’t be overridden – the `-e`
    or `--extra-vars` switches are the highest order of precedence in Ansible so will
    override anything else that you define.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, you will probably make use of the `defaults/` based variables
    alone, but there will doubtless be times when having the option of variables higher
    up the precedence ordering becomes valuable to your automation, and so it is vital
    to know that this option is available to you.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the role-based variables described previously, there is also
    the option to add metadata to a role using the `meta/` directory. As before, to
    make use of this, simply add a file called `main.yml` into this directory. To
    explain how you might make use of the `meta/` directory, let’s build and run a
    practical example that will show how it can be used. Before we get started though,
    it is important to note that, by default, the Ansible parser will only allow you
    to run a role once.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is somewhat similar to the way in which we discussed handlers earlier,
    which can be called multiple times but ultimately are only run once at the end
    of the play. Roles are the same in that they can be referred to multiple times
    but will only actually get run once. There are two exceptions to this – the first
    is if the role is called more than once but with different variables or parameters,
    and the other is if the role being called has `allow_duplicates` set to `true`
    in its `meta/` directory. We shall see examples of both as we build our example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top level of our practical example, we will have a copy of the same
    inventory we have used throughout this chapter. We will also create a simple playbook
    called `site.yml`, which contains the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we are simply calling one role called `platform` from this playbook
    – nothing else is called from the playbook itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and create the `platform` role – unlike our previous role, this
    will not contain any tasks or even any variable data; instead, it will just contain
    a `meta` directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this directory, create a file called `main.yml` with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This code will tell Ansible that the platform role is dependent on the `linuxtype`
    role. Note that we specify the dependency twice, but each time we specify it,
    we pass it a variable called `type` with a different value – in this way, the
    Ansible parser allows us to call the role twice because a different variable value
    has been passed to it each time it is referred to as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now go ahead and create the `linuxtype` role – again, this will contain
    no tasks but more dependency declarations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Again, create a `main.yml` file in the `meta` directory but this time containing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we create more dependencies – this time, when the `linuxtype` role
    is called, it, in turn, declares dependencies on roles called `version` and `network`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create the `version` role first – this will have both `meta` and `tasks`
    directories in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `meta` directory, we’ll create a `main.yml` file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This declaration is important in this example – as discussed earlier, normally,
    Ansible will only allow a role to be executed once, even if it is called multiple
    times. Setting `allow_duplicates` to `true` tells Ansible to allow the execution
    of the role more than once. This is required because, in the `platform` role,
    we call (via a dependency) the `linuxtype` role twice, which means, in turn, we
    will call the `version` role twice.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also create a simple `main.yml` file in the `tasks/` directory, which
    prints the value of the `type` variable that gets passed to the role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now repeat the process with the `network` role – to keep our example
    code simple, we’ll define it with the same contents as the `version` role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `meta` directory, we’ll again create a `main.yml` file with the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, we’ll create a simple `main.yml` file in the `tasks` directory, which
    prints the value of the `type` variable that gets passed to the role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'At the end of this process, your directory structure should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s see what happens when we run this playbook. The flow should be as follows
    – our initial playbook statically imports the `platform` role. The `platform`
    role then states that it depends upon the `linuxtype` role, and the dependency
    is declared twice with a different value in a variable called `type` each time.
    The `linuxtype` role then states that it depends upon both the `network` and `version`
    roles, which are allowed to run more than once and print the value of `type`.
    Hence, we see the `network` and `version` roles called twice, printing `fedora`
    on the first call and `ubuntu` the second time (as this is how we originally specified
    the dependencies in the `platform` role). You can execute the playbook using the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should look something like this from this playbook execution:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – An example of running a playbook using roles with dependencies](img/B20846_04_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – An example of running a playbook using roles with dependencies
  prefs: []
  type: TYPE_NORMAL
- en: This is distinctly different from earlier versions of Ansible (for example,
    Ansible 2.7), where if you had run the same code, you would have seen only the
    `type` printed on the screen as `ubuntu`. This demonstrates an important point
    about looking at the code porting guidelines between releases of Ansible/`ansible-core`
    and understanding how the behavior may have changed. While, in most cases (excepting
    the fundamental change around collections), your automation code will work without
    changes from one version of Ansible to the next, this is not guaranteed, and a
    subtle change such as this could have catastrophic consequences in a production
    environment. Ansible code should be treated just as code, including testing new
    releases of Ansible when they are deployed.
  prefs: []
  type: TYPE_NORMAL
- en: This is quite an advanced example of Ansible role dependencies, but it has been
    provided to you to demonstrate the importance of knowing a little about variable
    precedence (that is, where the variable is scoped) and how the parser works. If
    you write simple, sequentially parsed tasks, then you may never need to know this,
    but I recommend that you make extensive use of the `debug` statement and test
    your playbook design to make sure that you don’t fall foul of this during your
    playbook development.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have looked in great detail at a number of role aspects, let’s take
    a look in the following section at a centralized store for publicly available
    Ansible roles – **Ansible Galaxy**.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible Galaxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No section on Ansible roles would be complete without a mention of Ansible Galaxy.
    Ansible Galaxy is a community-driven collection of Ansible roles and collections,
    hosted by Red Hat at [https://galaxy.ansible.com/](https://galaxy.ansible.com/).
    It contains a great many community-contributed Ansible roles and collections,
    and if you can conceive of an automation task, there is a good chance someone
    has already written code to do exactly what you want. It is well worth exploring
    and can get your automation project off the ground quickly, as you can start to
    work with a set of ready-made roles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the website, the `ansible-galaxy` client is included in Ansible,
    and this provides a quick and convenient way for you to download and deploy roles
    into your playbook structure. Let’s say that you want to update the `arillso.motd`),
    we can download it into our roles directory using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: That’s all you need to do – once the download is complete, you can import or
    include the role in your playbook, just as you would for the manually created
    roles we have discussed in this chapter. Note that if you don’t specify `-p roles/`,
    `ansible-galaxy` will install the roles into `~/.ansible/roles`, the central roles
    directory for your user account. This might be what you want, of course, but if
    you want the role downloaded directly into your playbook directory structure,
    you would add this parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another neat trick is to use `ansible-galaxy` to create an empty role directory
    structure for you to create your own roles in – this saves all of the manual directory
    and file creation we undertook in this chapter, as shown in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: That should give you enough information to get started on your journey into
    Ansible roles. I cannot stress highly enough how important it is to develop your
    code as roles – it might not seem important initially, but as your automation
    use cases expand, and your requirement to reuse code grows, you will be glad that
    you did. In the next section, let’s expand our look at Ansible playbooks with
    a discussion of the ways in which conditional logic can be used in your Ansible
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Using conditions in your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In most of our examples so far, we have created simple sets of tasks that always
    run. However, as you generate tasks (whether in roles or playbooks) that you want
    to apply to a wider array of hosts, sooner or later, you will want to perform
    some kind of conditional action. This might be to only perform a task in response
    to the results of a previous task, or it might be to only perform a task in response
    to a specific fact gathered from a managed node. In this section, we will provide
    some practical examples of conditional logic to apply to your Ansible tasks to
    demonstrate how to use this feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, we’ll need an inventory to get started, and we’ll reuse the inventory
    we have used throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Suppose that you want to perform an Ansible task only on certain operating systems.
    We have already discussed Ansible facts, and these provide the perfect platform
    to start exploring conditional logic in your playbooks. Consider this – an urgent
    patch has been released for all of your Fedora systems, and you want to apply
    it immediately. You could, of course, go through and create a special inventory
    (or host group) for Fedora hosts, but this is additional work that you don’t necessarily
    need to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, let’s define the task that will perform our update, adding a `when`
    clause containing a Jinja2 expression to it, so that the update is only performed
    on Fedora-based hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this task, if your test system(s) are Fedora-based (and one
    of mine is), you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output shows that only one of our systems was Fedora-based, and
    it returned an `ok` status, meaning the patch had already been applied. Now, we
    can make our logic more precise – perhaps it is only our legacy systems that run
    on Fedora 35 that need the patch applied. In this case, we can expand the logic
    in our playbook to check both the distribution and major versions, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we run our modified playbook, depending on the systems you have in
    your inventory, you might see output similar to the following. In this case, all
    systems were skipped because they did not match my logical expression (and, hence,
    I am safe in the knowledge that I have no legacy systems in this inventory to
    worry about):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Of course, this conditional logic is not limited to Ansible facts and can be
    incredibly valuable when using the `ansible.builtin.shell` or `ansible.builtin.command`
    modules. When you run *any* Ansible module, the module returns data detailing
    the results of its run. You can capture this in an Ansible variable using the
    `register` keyword and then process it further later on in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following playbook code. It contains two tasks, the first of which
    is to obtain the listing of the current directory and capture the output of the
    `ansible.builtin.shell` module in a variable called `shellresult`. We then print
    a simple `ansible.builtin.debug` message, but only on the condition that the `hosts`
    string is in the output of the `ansible.builtin.shell` module run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this in the current directory, which if you work from the
    GitHub repository that accompanies this book will contain a file named `hosts`,
    then you should see output similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Yet, if the file doesn’t exist, you’ll see that the `ansible.builtin.debug`
    message gets skipped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also create complex conditions for IT operational tasks in production;
    however, remember that in Ansible, variables are not cast to any particular type
    by default, so even though the contents of a variable (or fact) might look like
    a number, Ansible will treat it as a string by default. If you need to perform
    an integer comparison instead, you must first cast the variable to an integer
    type. For example, here is a fragment of a playbook that will run a task only
    on Fedora 35 and newer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: There are many different types of conditionals you can apply to your Ansible
    tasks, and this section just scratches the surface; however, it should give you
    a sound basis on which to expand your knowledge of applying conditions to your
    tasks in Ansible. Not only can you apply conditional logic to Ansible tasks but
    you can also run them in loops over a set of data, which we shall explore in the
    following section.
  prefs: []
  type: TYPE_NORMAL
- en: Repeating tasks with loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Oftentimes, we will want to perform a single task but use it to iterate over
    a set of data. Perhaps you are creating new 15 new user groups on a server for
    various teams to utilize. It would be incredibly inefficient to have to write
    15 individual tasks within an Ansible play to achieve this – and Ansible is all
    about efficiency and saving the user time. To enable this level of efficiency,
    Ansible supports looping over datasets to ensure that you can perform large-scale
    operations using tightly defined code. In this section, we will explore how to
    make practical use of loops in your Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, we must start with an inventory to work against, and we will use our
    by-now familiar inventory, which we have consistently used throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Let’s start with a really simple playbook to show you how to loop over a set
    of data in a single task. Although this is quite a contrived example, it is intended
    to be simple to show you the fundamentals of how loops work in Ansible. We will
    define a single task that runs the `ansible.builtin.command` module on a single
    host from the inventory and uses the `ansible.builtin.command` module to `echo`
    the numbers 1 through 6 in turn on the remote system (with some imagination, this
    could easily be extended to adding user accounts or creating a sequence of files).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'The `loop:` statement defines the start of the loop, and the items in the loop
    are defined as a YAML list. Also, note the higher indentation level, which tells
    the parser they are part of the loop. When working with the loop data, we use
    a special variable called `item`, which contains the current value from the loop
    iteration to be echoed. When we run this playbook, we should see output similar
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'You can combine the conditional logic we discussed in the preceding section
    with loops, to make the loop operate on just a subset of its data. For example,
    consider the following iteration of the playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run this, we can see that the task is skipped until we reach the
    integer value of `4` and higher in the loop contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: You can, of course, combine this with the conditional logic based on Ansible
    facts and other variables in the manner we discussed previously. Just as we captured
    the results of a module’s execution using the `register` keyword before, we can
    do so with loops. The only difference is that the results will now be stored in
    a dictionary, with one dictionary entry for each iteration of the loop rather
    than just one set of results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, let’s see what happens if we further enhance the playbook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when we run the playbook, you will see pages of output containing the
    dictionary with the contents of `loopresult`. The following output is truncated
    in the interests of space but demonstrates the kind of results you should expect
    from running this playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `results` section of the output is a dictionary, and we
    can clearly see that the first two items in the list were `skipped` because the
    result of our `when` clause (conditional) was `false`.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, we can see so far that loops are easy to define and work with – but you
    may be asking, *can you create nested loops?* The answer to that question is *yes*,
    but there is a catch – the special variable named `item` would clash, as both
    the inner and outer loops would use the same variable name. This would mean the
    results from your nested loop run would be, at best, unexpected.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, there is a `loop` parameter called `loop_control`, which allows
    you to change the name of the special variable containing the data from the current
    `loop` iteration from `item` to something of your choosing. Let’s create a nested
    loop to see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, we’ll create a playbook in the usual manner, with a single task
    to run in a loop. To generate our nested loop, we’ll use the `include_tasks` directive
    to dynamically include a single task from another YAML file, which will also contain
    a loop. As we intend to use this playbook in a nested loop, we’ll use the `loop_var`
    directive to change the name of the special loop contents variable from `item`
    to `second_item`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we’ll create a second file called `loopsubtask.yml`, which contains the
    inner loop and is included in the preceding playbook. As we already changed the
    loop item variable name in the outer loop, we don’t need to change it again here.
    Note that the structure of this file is very much like a tasks file in a role
    – it is not a complete playbook but, rather, simply a list of tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Now you should be able to run the playbook, and you will see Ansible iterate
    over the outer loop first and then process the inner loop over the data defined
    by the outer loop. Test this playbook by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'As the loop variable names do not clash, everything works exactly as we would
    expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Demonstrating nested loops in an Ansible playbook](img/B20846_04_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Demonstrating nested loops in an Ansible playbook
  prefs: []
  type: TYPE_NORMAL
- en: Loops are simple to work with and yet very powerful, as they allow you to easily
    use one task to iterate over a large dataset. In the next section, we’ll look
    at another construct of the Ansible language to control playbook flow – blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Grouping tasks using blocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blocks in Ansible allow you to logically group a set of tasks together, primarily
    for one of two purposes. One might be to apply conditional logic to an entire
    set of tasks; in this example, you could apply an identical `when` clause to each
    of the tasks, but this is cumbersome and inefficient – it’s far better to place
    all of the tasks in a block and apply the conditional logic to the block itself.
    In this way, the logic only needs to be declared once. Blocks are also valuable
    when it comes to error handling and especially when it comes to recovering from
    an error condition. We shall explore both of these through simple practical examples
    in this chapter to get you up to speed with blocks in Ansible.
  prefs: []
  type: TYPE_NORMAL
- en: 'As ever, let’s ensure we have an inventory to work from:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s dive straight in and look at an example of how you would use blocks
    to apply conditional logic to a set of tasks. At a high level, suppose we want
    to perform the following actions on all of our Fedora Linux hosts:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the package for the Apache web server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install a templated configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Start the appropriate service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We could achieve this with three individual tasks, all with a `when` clause
    associated with them, but blocks provide us with a better way. The following example
    playbook shows the three tasks discussed contained in a block (note the additional
    level of indentation required to denote their inclusion in the block):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your playbook with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'You should find that the Apache-related tasks are only run on any Fedora hosts
    you might have in your inventory; you should see that either all three tasks are
    run or are skipped – depending on the makeup and contents of your inventory, it
    might look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – A playbook demonstrating the use of blocks in conditional task
    execution](img/B20846_04_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – A playbook demonstrating the use of blocks in conditional task
    execution
  prefs: []
  type: TYPE_NORMAL
- en: This is very simple-to-construct but very powerful in terms of the effect it
    has on your ability to control the flow over large sets of tasks.
  prefs: []
  type: TYPE_NORMAL
- en: This time, let’s build a different example to demonstrate how blocks can help
    Ansible to handle error conditions gracefully. So far, you should have seen that
    if your playbooks encounter any errors, they are likely to stop executing at the
    point of failure. This is, in some situations, far from ideal, and you might want
    to perform some kind of recovery action in this event rather than simply halting
    the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new playbook, this time with the following contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that in the preceding play, we now have additional sections to `block`
    – as well as the tasks in `block` itself, we have two new parts labeled `rescue`
    and `always`. The flow of execution is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: All tasks in the `block` section are executed normally, in the sequence in which
    they are listed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If a task in the `block` results in an error, no further tasks in the `block`
    are run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tasks in the `rescue` section start to run in the order they are listed
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Tasks in the `rescue` section do not run if no errors result from the `block`
    tasks
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If an error results from a task being run in the `rescue` section, no further
    `rescue` tasks are executed, and execution moves on to the `always` section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tasks in the `always` section are always run, regardless of any errors in either
    the `block` or `rescue` sections. They even run when no errors are encountered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Test your playbook code by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'With this flow of execution in mind, you should see output similar to the following
    when you execute this playbook, noting that we have deliberately created two error
    conditions to demonstrate the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – Demonstrating the use of blocks in error handling in playbooks](img/B20846_04_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – Demonstrating the use of blocks in error handling in playbooks
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible has two special variables, which contain information you might find
    useful in the `rescue` block to perform your recovery actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ansible_failed_task`: This is a dictionary containing details of the task
    from `block` that failed, causing us to enter the `rescue` section. You can explore
    this by displaying its contents using `ansible.builtin.debug`, so, for example,
    the name of the failing task can be obtained from `ansible_failed_task.name`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_failed_result`: This is the result of the failed task and behaves
    the same as if you had added the `register` keyword to the failing task. This
    saves you from having to add `register` to every single task in the block if it
    fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As your playbooks get more complex and error handling gets more and more important
    (or, indeed, conditional logic becomes more vital), blocks will become an important
    part of your arsenal to write robust playbooks. Let’s proceed in the next section
    to explore execution strategies to gain further control of your playbook runs.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring play execution via strategies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As your playbooks become increasingly complex, it becomes more and more important
    that you have robust ways to debug any issues that might arise. For example, is
    there a way you can check the contents of a given variable (or variables) during
    execution without the need to insert `ansible.builtin.debug` statements throughout
    your playbook? Similarly, we have so far seen that Ansible will ensure that a
    particular task runs to completion on all inventory hosts that it applies to before
    moving on to the next task – is there a way to vary this?
  prefs: []
  type: TYPE_NORMAL
- en: When you get started with Ansible, the execution strategy that you see by default
    (and we have seen this so far in every playbook we have executed, even though
    we have not mentioned it by name) is known as `linear`. This does exactly what
    it describes – each task is executed in turn on all applicable hosts before the
    next task is started. However, there is another less commonly used strategy called
    `free`, which allows all tasks to be completed as fast as they can on each host,
    without waiting for other hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most useful strategy when you start to work with Ansible, however, is going
    to be the `debug` strategy, and this enables Ansible to drop you straight into
    its integrated debug environment if an error should occur in the playbook. Let’s
    demonstrate this by creating a playbook that has a deliberate error in it. Note
    the `strategy: debug` and `debugger: on_failed` statements in the play definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if you execute this playbook, you should see that it starts to run, but
    then it drops you into the integrated debugger when it encounters the deliberate
    error it contains. The start of the output should be similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the playbook starts executing but fails on the first task with an
    error, as the variable is undefined. However, rather than exiting back to the
    shell, it enters an interactive debugger. We’ve given a simple example of using
    the debugger in the preceding output, and if you’d like to learn how to use it
    more comprehensively, the Ansible documentation has full details of the available
    commands and how to use them: [https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml](https://docs.ansible.com/ansible/latest/user_guide/playbooks_debugger.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To take you through a very simple, practical debugging example, enter the `p
    task` command at the prompt – this will cause the Ansible debugger to print the
    name of the failing task, which is very useful if you are in the midst of a large
    playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we know where the play failed, so let’s dig a little deeper by issuing
    the `p task.args` command, which will show us the arguments that were passed to
    the module in the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can see that our module was passed the argument called `data`, with
    the argument value being a variable (denoted by the pairs of curly braces) called
    `mobile`. Hence, it might be logical to have a look at the variables available
    to the task to see whether this variable exists and, if so, whether the value
    is sensible (use the `p task_vars` command to do this):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: The preceding output is truncated, and you will find a great many variables
    associated with the task – this is because any gathered facts, and internal Ansible
    variables, are all available to the task. However, if you scroll through the list,
    you will be able to confirm that there is no variable called `mobile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Hence, this should be enough information to fix your playbook. Enter `q` to
    quit the debugger:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The Ansible debugger is an incredibly powerful tool, and you should learn to
    make effective use of it, especially as your playbook complexity grows. This concludes
    our practical look at the various aspects of playbook design – in the next section,
    we’ll take a look at the ways in which you can integrate Git source code management
    into your playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Using ansible-pull
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Of course, the ideal way to work with Ansible code is to store it in a version
    control repository. This is a valuable step that ensures all changes are tracked,
    and that everyone responsible for automation is working from the same code. However,
    it also presents an inefficiency – end users must remember to check out (or pull)
    the latest version of the code and then execute it, and while this isn’t difficult,
    manual tasks are both the enemy of efficiency and make it easy for errors to occur.
    Luckily, once again, Ansible supports us by providing tooling to ensure the most
    efficient approach can be achieved, and a special command called `ansible-pull`
    can be used to both retrieve the latest code from a Git repository and execute
    it, all using one command. This supports not only greater efficiency for end users
    (and reduces the chance of human error) but also enables automation jobs to be
    run unattended (for example, using a scheduler such as `cron`).
  prefs: []
  type: TYPE_NORMAL
- en: An important thing to note, however, is that, while the `ansible` and `ansible-playbook`
    commands can both operate over an entire inventory and run the playbooks against
    one or more remote hosts, the `ansible-pull` command is only intended to run the
    playbooks it obtains from your source control system on `localhost`. Hence, if
    you want to use `ansible-pull` throughout your infrastructure, you must install
    it onto every host that needs it.
  prefs: []
  type: TYPE_NORMAL
- en: Nonetheless, let’s see how this might work. We’ll simply run the command by
    hand to explore its application, but in reality, you would almost certainly install
    it in your `crontab` so that it runs on a regular basis, picking up any changes
    you make to your playbook in the version control system.
  prefs: []
  type: TYPE_NORMAL
- en: As stated, `ansible-pull` is only intended to run the playbook on the local
    system, so an inventory file is somewhat redundant – instead, we’ll use a little-used
    inventory specification whereby you can simply specify the inventory hosts directory
    as a comma-separated list on the command line. If you only have one host, you
    simply specify its name followed by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use a simple playbook from GitHub that sets the message of the day based
    on variable content. To do this, we will run the following command (which we’ll
    break down in a minute):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'This command breaks down as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`-d /tmp/ansible-set-motd`: This sets the working directory that will contain
    the checkout of the code from GitHub. Ensure this is writeable by the user account
    running the `ansible-pull` command.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-i ${HOSTNAME},`: This runs only on the current host, specified by its hostname
    from the appropriate shell variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-U` [https://github.com/jamesfreeman959/ansible-set-motd.git](https://github.com/jamesfreeman959/ansible-set-motd.git):
    We use this URL to obtain the playbooks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`site.yml`: This is the name of the playbook to run from the Git repository
    specified earlier.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-e "ag_motd_content=''MOTD generated by ansible-pull''"`: This sets the appropriate
    Ansible variable to generate the MOTD content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`>> /tmp/ansible-pull.log 2>&1`: This redirects the output of the command to
    a log file if we need to analyze it later – this is especially useful if running
    the command in a cron job where the output would never be printed to the user’s
    terminal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can test this with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see some output similar to the following (note that log redirection
    has been removed to make it easier to see the output):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – Demonstrating the use of ansible-pull](img/B20846_04_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – Demonstrating the use of ansible-pull
  prefs: []
  type: TYPE_NORMAL
- en: This command can be a very powerful part of your overall Ansible solution, especially
    as it means you don’t have to worry too much about running all of your playbooks
    centrally, or ensuring that they are all up to date every time you run them. The
    ability to schedule this in `cron` is especially powerful in a large infrastructure
    where, ideally, automation means things should take care of themselves.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our practical look at playbooks and how to author your own code
    – with a little research into Ansible modules, you should now have enough to write
    your own robust playbooks with ease.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playbooks are the lifeblood of Ansible automation, providing a robust framework
    within which to define logical collections of tasks and handle error conditions
    cleanly and robustly. The addition of roles into this mix is valuable in terms
    of not only organizing your code but also in terms of supporting code reuse as
    your automation requirements grow. Ansible playbooks provide a truly complete
    automation solution for your technology needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about the playbook framework and how to start building
    your own playbooks. You then learned how to organize your code into roles and
    design your code to effectively and efficiently support reuse. We then explored
    some of the more advanced playbook writing topics, such as working with conditional
    logic, blocks, and loops. Finally, we looked at playbook execution strategies,
    especially with a view to being able to debug our playbooks effectively, and we
    wrapped up with a look at how we can run Ansible playbooks on a local machine
    directly from GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to consume and create our very own modules,
    providing you with the skills you need to expand the capabilities of Ansible to
    suit your own bespoke environments and contribute to the community.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How do you restart the Apache web server in the `frontends` host group via an
    ad hoc command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible frontends -i hosts -a "``name=httpd state=restarted"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible frontends -i hosts -b ansible.builtin.service -a "``name=httpd state=restarted"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible frontends -i hosts -b -m ansible.builtin.service -a "``name=httpd
    state=restarted"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible frontends -i hosts -b -m ansible.builtin.server -a "``name=httpd state=restarted"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`ansible frontends -i hosts -m restart -``a "name=httpd"`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Blocks allow you to logically make a group of tasks or perform error handling:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Default strategies are implemented via the relevant modules in the playbook:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`ansible-galaxy` and its documentation can be found here: [https://galaxy.ansible.com/docs/](https://galaxy.ansible.com/docs/).'
  prefs: []
  type: TYPE_NORMAL
- en: Part 2:Expanding the Capabilities of Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will cover the important concepts of Ansible plugins and
    modules. We will cover both their effective use and how to expand Ansible’s capabilities
    by writing your own plugins, modules, and collections. We’ll even look at the
    requirements for submitting your modules and plugins back to the official Ansible
    project. We’ll also look at coding best practices, as well as some advanced Ansible
    techniques that allow you to safely automate your infrastructure even when you
    are working with a clustered environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating and Consuming* *Modules*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B20846_06.xhtml#_idTextAnchor318), *Creating and Consuming* *Collections*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B20846_07.xhtml#_idTextAnchor343), *Creating and Consuming* *Plugins*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B20846_08.xhtml#_idTextAnchor347), *Coding Best Practices*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B20846_09.xhtml#_idTextAnchor378), *Advanced Ansible Topics*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
