<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Building a Single Container Application</h1></div></div></div><p>In this chapter, we are going to write our first module to deploy our first containerized application. The application that we are going to deploy is Consul from HashiCorp (<a class="ulink" href="https://www.consul.io/">https://www.consul.io/</a>). We <a id="id78" class="indexterm"/>will talk about Consul a little later in the chapter. The first thing we will look at is how to construct a Puppet module with the correct file structure, unit tests, and gems. Once we have our module skeleton, we will look at the two ways to deploy Consul with Puppet in a container. The first will be to use resource declarations in a manifest and the second will be to use Docker Compose as a template <code class="literal">.erb</code> file. These are the topics that we will cover in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Building a Puppet module skeleton</li><li class="listitem" style="list-style-type: disc">Coding using resource declarations</li><li class="listitem" style="list-style-type: disc">Coding using <code class="literal">.erb</code> files</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec16"/>Building a Puppet module skeleton</h1></div></div></div><p>One of <a id="id79" class="indexterm"/>the most important things in development is having a solid foundation. Writing a Puppet module is no different. This topic is extremely important for the rest of the book, as we will be reusing the code over and over again to build all our modules from now on. We will first look at how to build a module with the Puppet module generator. Once we have our module skeleton, we will look at its construct. We will look at the plumbing Puppet uses with Ruby, and lastly, at basic unit tests.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec20"/>The Puppet module generator</h2></div></div></div><p>One of the <a id="id80" class="indexterm"/>best things about working with Puppet is the number of tools out there, both from the community and from puppetlabs itself. The Puppet module generator is a tool that is developed by puppetlabs and follows the best practices to create a module skeleton. The best thing about this tool is that it is bundled <a id="id81" class="indexterm"/>with every Puppet agent install. So, we don't need to install any extra software. Let's log in to our Vagrant box that we built in the last chapter. Let's change directory to the root of our Vagrant repo and then use the <code class="literal">vagrant up &amp;&amp; vagrant ssh</code> command. Now that we are logged in to the box, let's sudo to root (<code class="literal">sudo -i</code>) and change the directory to <code class="literal">/vagrant</code>. The reason for this is that this folder will be mapped to our local box. Then, we can use our favorite text editor later in the chapter. Once we're in <code class="literal">/vagrant</code>, we can run the command to build our Puppet module skeleton. The <code class="literal">puppet module generate &lt;AUTHOR&gt;-consul</code> command for me will look like this: <code class="literal">puppet module generate scottyc-consul</code>.</p><p>The script will then ask a few questions such as the version, author name, description, where the source lives, and so on. These are very important questions that are to be considered when you want to publish a module to the Puppet Forge (<a class="ulink" href="https://forge.puppetlabs.com/">https://forge.puppetlabs.com/</a>), but for now, let's just answer the questions as per the following example:</p><div><img src="img/B05201_03_01.jpg" alt="The Puppet module generator"/></div><p>Now that we have our Puppet module skeleton, we should look at what the structure looks <a id="id82" class="indexterm"/>like:</p><div><img src="img/B05201_03_02.jpg" alt="The Puppet module generator"/></div><p>Now, we are going to add a few files to help us with unit tests. The first file is <code class="literal">.fixtures.yml</code>. This file is used by <code class="literal">spec-puppet</code> to pull down any module dependencies into the <code class="literal">spec/fixtures</code> directory when we run our unit tests. For this module, the <code class="literal">.fixtures.yml</code> file should look like the one shown in the following screenshot:</p><div><img src="img/B05201_03_03.jpg" alt="The Puppet module generator"/></div><p>The next file that we are going to add is a <code class="literal">.rspec</code> file. This is the file that <code class="literal">rspec-puppet</code> uses when it requires <code class="literal">spec_helper</code>, and it sets the pattern for our unit test folder structure. The file contents should look as shown in this screenshot:</p><div><img src="img/B05201_03_04.jpg" alt="The Puppet module generator"/></div><p>Now that <a id="id83" class="indexterm"/>we have our folder structure, let's install the gems that we need to run our unit tests. My personal preference is to install the gems on the vagrant box; if you want to use your local machine, that's fine as well. So, let's log in to our vagrant box (cd into the root of our Vagrant repo, use the <code class="literal">vagrant ssh</code> command, and then change the directory to root using <code class="literal">sudo -i</code>). First, we will install Ruby with <code class="literal">yum install -y ruby</code>. Once that is complete, let's cd into <code class="literal">/vagrant/&lt;your modules folder&gt;</code> and then run <code class="literal">gem install bundler &amp;&amp; bundle install</code>. You should get the following output:</p><div><img src="img/B05201_03_05.jpg" alt="The Puppet module generator"/></div><p>As you can see from the preceding screenshot, we got some warnings. This is because we ran <code class="literal">gem install</code> as the root. We would not do that on a production system, but as this is our development box, it won't pose an issue. Now that we have all the gems that we need for our unit tests, let's add some basic facts to <code class="literal">/spec/classes/init_spec.rb</code>. The facts we are going to add are <code class="literal">osfamily</code> and <code class="literal">operatingsystemrelease</code>. So, the file will look as shown in this screenshot:</p><div><img src="img/B05201_03_06.jpg" alt="The Puppet module generator"/></div><p>The last file <a id="id84" class="indexterm"/>that we will edit is the <code class="literal">metadata.json</code> file in the root of the repo. This file defines our module dependencies. For this module, we have one dependency, <code class="literal">docker</code>, so we need to add that at the bottom of the <code class="literal">metadata.json</code> file, as shown in the following screenshot:</p><div><img src="img/B05201_03_07.jpg" alt="The Puppet module generator"/></div><p>The last thing we need to do is put everything in its place inside our Vagrant repo. We do that by creating a folder called <code class="literal">modules</code> in the root of our Vagrant repo. Then, we issue the <code class="literal">mv &lt;AUTHOR&gt;-consul/ modules/consul</code> command. Note that we removed the author name because we need the module to replicate what it would look like on a Puppet master. Now that we have our basic module skeleton ready, we can start with some coding.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec17"/>Coding using resource declarations</h1></div></div></div><p>In this <a id="id85" class="indexterm"/>section, we are going to use our module skeleton to build our first Docker application. We are going to write it using standard Puppet manifests.</p><p>But first, why is the first module that we are writing Consul? I chose this application for a few reasons. First, Consul has a lot of awesome features such as service discovery and health <a id="id86" class="indexterm"/>checks, and can be used as a key/value store. The second reason is that we will use all the features I just mentioned later in the book. So, it will come in handy when we look at Docker Swarm.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec21"/>File structures</h2></div></div></div><p>Let's <a id="id87" class="indexterm"/>create two new files, <code class="literal">install.pp</code> and <code class="literal">params.pp</code>, in the <code class="literal">manifests</code> folder. The structure should look as shown in the following screenshot:</p><div><img src="img/B05201_03_08.jpg" alt="File structures"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>Writing our module</h2></div></div></div><p>Let's start <a id="id88" class="indexterm"/>writing our module. We will start with <code class="literal">init.pp</code>; this module is not going to be very complex as we are only going to add a few lines of code and some parameters. As you can see in the preceding screenshot, we created three files in the <code class="literal">manifests</code> directory. When I write a module, I always like to start at <code class="literal">params.pp</code>, as it gives me a good starting structure to work for the code that provides the module logic. So, let's look at <code class="literal">params.pp</code> for this module, which is shown in the following screenshot:</p><div><img src="img/B05201_03_09.jpg" alt="Writing our module"/></div><p>Now, let's look at the parameters that we have set:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">$docker_version</code>: This<a id="id89" class="indexterm"/> is the version of Docker that we will install.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$docker_tcp_bind</code>: This <a id="id90" class="indexterm"/>is the IP address and port that the Docker API will bind to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$docker_image</code>: This is<a id="id91" class="indexterm"/> the Docker image we will be using from Docker Hub. We will be using my Consul image. To read more about the image or get the Dockerfile, go to <a class="ulink" href="https://hub.docker.com/r/scottyc/consul/">https://hub.docker.com/r/scottyc/consul/</a>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$container_hostname</code>: This<a id="id92" class="indexterm"/> is going to set the hostname inside the container.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$consul_advertise</code>: This<a id="id93" class="indexterm"/> is the IP address that Consul is going to advertise. We are going to use a built-in Puppet fact, <code class="literal">$::ipaddress_enp0s8</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">$consul_bootstrap_expect</code>: This<a id="id94" class="indexterm"/> sets the number of nodes in the Consul cluster. We are using just the one. If it was a production cluster, you would use at least three.</li></ul></div><p>Now that we have set up our parameters, let's get started on <code class="literal">install.pp</code>. As the name implies, this <a id="id95" class="indexterm"/>class will contain the logic that installs Docker, pulls the image, and runs the container. So, let's take a look at the code shown in the following screenshot:</p><div><img src="img/B05201_03_10.jpg" alt="Writing our module"/></div><p>To look at the code in more depth, we will break the class into two, the Docker installation and the container configuration. In the Docker installation, the first piece of code is a simple package type for <code class="literal">device-mapper-libs</code>. The reason we make sure that this package and its dependencies are installed is that it will be the storage drive that Docker will use to mount the container's filesystem.</p><p>Now, we move on to the Docker install. We start by declaring the <code class="literal">docker</code> class. For this class, we will set the Docker version, calling the parameters we set in <code class="literal">params.pp</code>, and the version of Docker that we are using is 1.9.1 (which is the latest at the time of writing this book). The next piece of configurations we will declare are the Docker API's TCP bind. Again, we will call our <code class="literal">params.pp</code> class and set the value to <code class="literal">tcp://127.0.0.1:4242</code>. This binds the API to listen to the localhost address on the TCP port <code class="literal">4242</code>.</p><p>The last value we will set to our Docker install is the Unix socket, which Docker will use. We will declare this without calling a parameter. The last piece of code makes sure that <code class="literal">device-mapper-libs</code> is installed before Docker, as it is a prerequisite to the Docker install:</p><div><img src="img/B05201_03_11.jpg" alt="Writing our module"/></div><p>Now that <a id="id96" class="indexterm"/>we have Docker installed, let's look at the code to build our Consul container. The first class that we call is <code class="literal">docker::image</code>. This will pull the image from Docker Hub before we call the <code class="literal">docker::run</code> class. In the <code class="literal">docker::run</code> class, we set <code class="literal">navmar</code> as the same value as the container's hostname. We will get that value from <code class="literal">params.pp</code> and it will be set to <code class="literal">consul</code>.</p><p>The next configuration we will set is the image. Now, this is different from calling <code class="literal">docker::image</code>. When you call <code class="literal">docker::image</code>, it pulls the image from Docker Hub to the local filesystem. When we set the image value in the <code class="literal">docker::run</code> class, it sets the value for the base image where the container will be deployed from. The value is set to <code class="literal">scottyc/consul</code>, and again we will get that value from <code class="literal">params.pp</code>. The <code class="literal">hostname</code> parameter is going to set the hostname inside the container.</p><p>Now we get to the the <code class="literal">resource</code> attribute that passes running configurations' parameters to the container. The <code class="literal">command</code> attribute is an arbitrary attribute that allows you to pass configurations to the container at boot. In this case, we are going to pass the boot configuration for the Consul setting as the server role, the IP address that the Consul application will bind to, and the number of servers that are there in the Consul's cluster. In the first case, all the values in the arguments that we are passing to the <code class="literal">command</code> attribute come from <code class="literal">params.pp</code>:</p><div><img src="img/B05201_03_12.jpg" alt="Writing our module"/></div><p>Now, last <a id="id97" class="indexterm"/>but definitely not least, let's look at what our <code class="literal">init.pp</code> file contains. The first thing that you will note at the top after the main class declaration is the mapping of all our parameters to <code class="literal">params.pp</code>. The reason we do this is to set any sensible configurations or defaults in <code class="literal">params.pp</code> and any sensitive data we can overwrite the defaults with Hiera lookups. We will look at Hiera lookups in the next chapter. The last line of code includes our <code class="literal">consul::install</code> class, which we covered in the preceding section:</p><div><img src="img/B05201_03_13.jpg" alt="Writing our module"/></div><p>Now, let's run our module.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Running our module</h2></div></div></div><p>Now that we<a id="id98" class="indexterm"/> have written our module, I am sure we are all keen to run it; however, before we can do that, there is one more piece of configuration that we need to add to <code class="literal">servers.yml</code> and <code class="literal">default.pp</code>. First, we need to make sure that our module <code class="literal">consul</code> is located in <code class="literal">modules/consul</code>. The next step is to open our <code class="literal">servers.yml</code> file and add the following line at the bottom of the shell commands:</p><div><pre class="programlisting">
<strong>- { shell: cp /home/vagrant/node-01/modules/* -R /tmp/modules }</strong>
</pre></div><p>This will copy our module into the correct module path in the vagrant box. We also need to forward the Consul port so that we can hit the GUI. This is done by adding <code class="literal">- { guest: 8500, host: 8500 }</code> to the forwarded port's attribute. It should look as shown in the<a id="id99" class="indexterm"/> following screenshot:</p><div><img src="img/B05201_03_14.jpg" alt="Running our module"/></div><p>Now, let's open our <code class="literal">manifests</code> directory and edit <code class="literal">default.pp</code>. We just need to add our module to the node definition. You can do this by adding the <code class="literal">include consul</code> configuration, as shown in the following screenshot, and saving both files:</p><div><img src="img/B05201_03_15.jpg" alt="Running our module"/></div><p>Let's head to our terminal, change the directory to the root of our Vagrant repo, and type the <code class="literal">vagrant up</code> command. Now, if this box is already running, issue a <code class="literal">vagrant destroy -f &amp;&amp; vagrant up</code> command. The output should look as shown in this screenshot:</p><div><img src="img/B05201_03_16.jpg" alt="Running our module"/></div><p>Even though <a id="id100" class="indexterm"/>we a have successful run Puppet, it can take a couple of minutes for the container to come up the first time, as it downloads the image from Docker Hub, so just be patient. You can easily check when the container is up by going to your browser and navigating to <code class="literal">127.0.0.1:8500</code>. You should get the consul GUI, as shown in the following screenshot:</p><div><img src="img/B05201_03_17.jpg" alt="Running our module"/></div><p>As you can see, we have one node that is running, named <code class="literal">consul</code>, which is the hostname that we gave to<a id="id101" class="indexterm"/> our container.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec18"/>Coding using .erb files</h1></div></div></div><p>In this<a id="id102" class="indexterm"/> topic, we are going to deploy the same container using <code class="literal">docker-compose</code> with a twist. The twist is with Puppet, where we can turn the <code class="literal">docker-compose.yml</code> file into <code class="literal">docker-compose.yml.erb</code>. This allows us to take advantage of all the tools Puppet gives us to manipulate template files. This is definitely the way I like to deploy containers with Puppet; however, I will let you decide for yourself the method you like best as we continue through the book.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Writing our module with Docker Compose</h2></div></div></div><p>In the <a id="id103" class="indexterm"/>chapter, we are going to look at how to use <code class="literal">docker-compose</code> as an <code class="literal">.erb</code> template file. In this example, we are only deploying a single container, but when an application contains five or six containers with links, this way is much more efficient than using the standard manifest declarations.</p><p>So, we will take our <code class="literal">consul</code> module from the last topic and modify it now to use <code class="literal">docker-compose</code>. If you want to keep that module, just make a copy. First, we are not going to touch <code class="literal">init.pp</code> and <code class="literal">params.pp</code>—they will remain the same. Now, let's look at <code class="literal">install.pp</code>:</p><div><img src="img/B05201_03_18.jpg" alt="Writing our module with Docker Compose"/></div><p>As you can see <a id="id104" class="indexterm"/>in the preceding screenshot, the top half of the class is exactly the same. However, we still install <code class="literal">device-mapper-libs</code> and declare the <code class="literal">docker</code> class in exactly the same way. The next attribute is different though; here, we call the file resource type. The reason is that this is the configuration that is used to place our <code class="literal">docker-compose</code> file on the local filesystem. You can see that we are declaring the contents with a template file located in the <code class="literal">templates</code> directory of the module. We will come back to this in a minute.</p><p>Now, let's look at the last resource type in <code class="literal">install.pp</code>. We are calling the <code class="literal">docker_compose</code> type because this is the resource type that will run the <code class="literal">docker-compose</code> command to bring up our container. Let's look at the attributes that we have configured. The first is <code class="literal">navmar</code>; this will set the name tag in Docker for the container. We are calling this value from <code class="literal">params.pp</code>, and it will be set to <code class="literal">consul</code>. <code class="literal">ensure</code> is a puppet meta parameter container which ensures that the container is always there.</p><p>If we want to delete the container, we would have to set this value to <code class="literal">absent</code>. The next attribute is <code class="literal">source</code>; this sets the folder where the <code class="literal">docker-compose</code> command can find the <code class="literal">docker-compose</code> file. We have set this to <code class="literal">root</code>. You could change the value to any folder on your system. The last attribute is <code class="literal">scale</code>. This tells <code class="literal">docker-compose</code> how many containers we want. The value is set to <code class="literal">1</code> in this instance. If we were deploying an nginx web farm, we might set the value to a figure such as 5. Now, let's get back to that template file. The<a id="id105" class="indexterm"/> first thing we need to do is create a folder called <code class="literal">templates</code> in the root of our <code class="literal">consul</code> module:</p><div><img src="img/B05201_03_19.jpg" alt="Writing our module with Docker Compose"/></div><p>The next step after that is to create our <code class="literal">.erb</code> template file. In <code class="literal">install.pp</code>, we declared the filename as <code class="literal">docker-compose.yml.erb</code>, so in our <code class="literal">templates</code> directory, let's create a file with that name. The contents of the file should look as shown in the following screenshot:</p><div><img src="img/B05201_03_20.jpg" alt="Writing our module with Docker Compose"/></div><p>So, the <a id="id106" class="indexterm"/>first thing that you should note in the preceding screenshot are the variables that are set, such as <code class="literal">&lt;%= @container_hostname %&gt;</code>. This maps back to <code class="literal">init.pp</code> as <code class="literal">$container_hostname</code>. As you can see, attributes such as <code class="literal">image</code>, <code class="literal">hostname</code>, <code class="literal">ports</code>, and <code class="literal">command</code> look very familiar. This is because they are the same attributes that we declared in the preceding section. In this example, we only configured our <code class="literal">docker-compose</code> file for a single container; in the next topic, we will look at a much more complex configuration. Before we get to that, let's make sure that this module runs.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Docker Compose up with Puppet</h2></div></div></div><p>To run <a id="id107" class="indexterm"/>our module, let's make sure that our module is located in the <code class="literal">modules/consul</code> directory in the root of your Vagrant repo. We have the configuration to forward port <code class="literal">8500</code> (<code class="literal">forwarded_ports: -  { guest: 8500, host: 8500 }</code>) and copy our module to our module's path directory using <code class="literal">- { shell: cp /home/vagrant/node-01/modules/* -R /tmp/modules }</code>.</p><p>Once this is in place, let's run <code class="literal">vagrant up</code> in our terminal in the root of our Vagrant repo. Again, if you have a box that is running, issue the <code class="literal">vagrant destroy -f &amp;&amp; vagrant up</code> command. The terminal should give you the following output:</p><div><img src="img/B05201_03_21.jpg" alt="Docker Compose up with Puppet"/></div><p>Again, we <a id="id108" class="indexterm"/>can go to <code class="literal">127.0.0.1:8500</code> and get the Consul GUI:</p><div><img src="img/B05201_03_22.jpg" alt="Docker Compose up with Puppet"/></div><p>Now, let's log in to our vagrant box; we will do that by issuing the <code class="literal">vagrant ssh</code> command in our terminal from the root of our Vagrant repo. Once we have logged in, we can <code class="literal">su</code> to root (<code class="literal">sudo -i</code>). Then, we can issue the <code class="literal">docker ps</code> command to look at all the running containers. The terminal should give you the following output:</p><div><img src="img/B05201_03_23.jpg" alt="Docker Compose up with Puppet"/></div><p>As you can see, the<a id="id109" class="indexterm"/> container is up and running.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec19"/>Summary</h1></div></div></div><p>In this chapter, we deployed our first container with Puppet. In doing so, we actually covered a lot of ground. We now have our script to create Puppet modules, and we know how to map our Puppet module's dependencies with <code class="literal">metadata.json</code> and <code class="literal">.fixtures.yml</code>.</p><p>In our tool belt, we now have two ways to deploy a container with Puppet, which will come in very handy in the chapters to come.</p></div></body></html>