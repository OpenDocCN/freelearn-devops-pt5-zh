<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Build, Test, and Release Faster with Continuous Integration"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Build, Test, and Release Faster with Continuous Integration</h1></div></div></div><p>The emphasis of this chapter will be the value of quick iteration: Quick over quality iteration, as per Boyd's law (you might recall the OODA principle mentioned in <a class="link" href="ch01.html" title="Chapter 1. What is DevOps and Should You Care?">Chapter 1</a>, <span class="emphasis"><em>What Is DevOps and Should You Care?</em></span>).</p><p>By iteration, I am referring to a software development cycle, from the moment a piece of code is written, published (committed to version control), compiled (if needed), tested and finally deployed.</p><p>
<span class="strong"><strong>Continuous Integration </strong></span>(<span class="strong"><strong>CI</strong></span>) defines the routines that should be adopted by developers plus the necessary tools to make this iteration as fast as possible.</p><p>Let us start with the human factor:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Use version control (for example Git)</li><li class="listitem" style="list-style-type: disc">Commit smaller changes, more often</li><li class="listitem" style="list-style-type: disc">Test locally first</li><li class="listitem" style="list-style-type: disc">Do peer code reviews</li><li class="listitem" style="list-style-type: disc">Pause other team activity until an issue is resolved</li></ul></div><p>Then add a bit of automation (a CI server):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Monitor for version control changes (for example Git commits)</li><li class="listitem" style="list-style-type: disc">Pull down changed code</li><li class="listitem" style="list-style-type: disc">Compile and run tests<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">On success, build an artefact</li><li class="listitem" style="list-style-type: disc">On failure, notify the team and pause the pipeline</li></ul></div><p>
</p></li><li class="listitem" style="list-style-type: disc">Repeat</li></ul></div><p>Committing smaller changes helps detect problems earlier and potentially solves them much more easily; and a developer receives feedback on their work more frequently which builds confidence that their code is in a good state.</p><p>Testing locally, where possible, greatly reduces team distraction caused by the CI pipeline tripping over minor issues.</p><p>Code reviews are beneficial at many levels. They eliminate bad coding habits as peers ensure code complies with agreed standards. They increase visibility; peers get a lot more exposure to the work of others. They help catch the errors which a machine would miss.</p><p>The <span class="strong"><strong>Toyota Way</strong></span> teaches us to <span class="emphasis"><em>Stop the Line</em></span> whenever a problem is detected. In terms of CI, this translates into halting the pipeline on errors and concentrating resources on fixing these. At first this might seem like an obvious way to reduce productivity and slow down the whole process, but it's been proven again and again that the initial overhead is ultimately worth it. This way you keep your technical debt to a minimum; improve code as-you-go, preventing issues from accumulating and re-surfacing at a later stage. Now is a good time to restate the <span class="strong"><strong>test locally</strong></span> point made earlier. You would likely not want to interrupt your colleagues with something trivial, which could have been spotted easily before committing.</p><p>As you succeed in building this team discipline (the hard part), it is time to add some automation flavor by setting up a CI pipeline.</p><p>The CI server tirelessly monitors your code repository and reacts to changes by performing a set of tasks over and over again. I believe it is evident how this saves engineers a great amount of time and effort, not to mention the fact that they avoid having to address the monotone nature of such work.</p><p>A pipeline, say in Jenkins, would normally consist of a number of stages: individual stages can represent the checking out of the latest code, running build tasks on it, performing tests then building artefacts, where each stage runs subject to the previous one completing successfully.</p><p>This generally describes how a combination of engineer habits and some tooling can greatly improve a software development cycle. Continuous Integration helps us collaborate better, write better code, ship more often and get feedback quicker.</p><p>Users want new features released fast, developers want to see the result of their work out there - everybody wins.</p><p>We have discussed the theory, now let us bring our focus to the title of this chapter. We are going to use our acquired Terraform and Salt skills to deploy a CI environment on AWS featuring a Jenkins (v2) CI server.</p><p>Jenkins (ref: <a class="ulink" href="https://jenkins.io">https://jenkins.io</a>) is a popular, well established open source project focusing on automation. It comes with a long list of integrations, catering to a variety of platforms and programming languages. Meet Jenkins: <a class="ulink" href="https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins">https://wiki.jenkins-ci.org/display/JENKINS/Meet+Jenkins</a>.</p><p>The deployment of our CI environment can be broken down into three main stages:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Prepare an <span class="strong"><strong>Infrastructure as Code</strong></span> deployment:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Write <span class="strong"><strong>Terraform</strong></span> templates to provision a VPC and an EC2 instance</li><li class="listitem" style="list-style-type: disc">Write <span class="strong"><strong>Salt</strong></span> States to install Jenkins, NGINX and other software onto the EC2 instance</li></ul></div></li><li class="listitem">Deploy IaC:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Deploy the Terraform templates and Salt States</li></ul></div></li><li class="listitem">Setup CI:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configure a Jenkins pipeline for Continuous Integration of a demo application</li></ul></div></li></ol></div><div class="section" title="Prepare IaC"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec10"/>Prepare IaC</h1></div></div></div><p>In accordance with our <span class="emphasis"><em>Infrastructure as Code</em></span> principles, this deployment will also be mostly template driven. We will try to reuse some of the Terraform and Salt code from previous chapters.</p><div class="section" title="Terraform templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec24"/>Terraform templates</h2></div></div></div><p>For this particular setup we can simplify our template as we will only need the VPC, some networking bits, and an EC2 instance.</p><p>Let's browse through the files in our <span class="emphasis"><em>TF</em></span> repository:</p><div class="section" title="Variables"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec15"/>Variables</h3></div></div></div><p>The few variables we need can be grouped into VPC and EC2 related ones:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/variables.tf</a>.</p></div></div><p>
<span class="strong"><strong>VPC</strong></span>
</p><pre class="programlisting">variable "aws-region" { &#13;
  type = "string" &#13;
  description = "AWS region" &#13;
} &#13;
variable "vpc-cidr" { &#13;
  type = "string" &#13;
  description = "VPC CIDR" &#13;
} &#13;
variable "vpc-name" { &#13;
  type = "string" &#13;
  description = "VPC name" &#13;
} &#13;
variable "aws-availability-zones" { &#13;
  type = "string" &#13;
  description = "AWS zones" &#13;
} &#13;
</pre><p>
<span class="strong"><strong>EC2</strong></span>
</p><pre class="programlisting">variable "jenkins-ami-id" { &#13;
  type="string" &#13;
  description = "EC2 AMI identifier" &#13;
} &#13;
variable "jenkins-instance-type" { &#13;
  type = "string" &#13;
  description = "EC2 instance type" &#13;
} &#13;
variable "jenkins-key-name" { &#13;
  type = "string" &#13;
  description = "EC2 ssh key name" &#13;
} &#13;
</pre></div><div class="section" title="Variables (values)"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec16"/>Variables (values)</h3></div></div></div><p>Following the bare variable definitions, we now supply some values:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/terraform.tfvars</a>.</p></div></div><p>
<span class="strong"><strong>VPC</strong></span>
</p><p>We'll keep our deployment in US East:</p><pre class="programlisting">aws-region = "us-east-1" &#13;
vpc-cidr = "10.0.0.0/16" &#13;
vpc-name = "Terraform" &#13;
aws-availability-zones = "us-east-1b,us-east-1c" &#13;
</pre><p>
<span class="strong"><strong>EC2</strong></span>
</p><p>A Nano instance will be sufficient for testing. Ensure the referenced key-pair exists:</p><pre class="programlisting">jenkins-ami-id = "ami-6869aa05" &#13;
jenkins-instance-type = "t2.nano" &#13;
jenkins-key-name = "terraform" &#13;
</pre></div><div class="section" title="Resources"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec17"/>Resources</h3></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/resources.tf</a>.</p></div></div><div class="section" title="Create the VPC"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec0"/>Create the VPC</h4></div></div></div><p>As a matter of standard (good) practice we create all our resources inside a VPC:</p><pre class="programlisting"># Set a Provider &#13;
provider "aws" { &#13;
  region = "${var.aws-region}" &#13;
} &#13;
 &#13;
# Create a VPC &#13;
resource "aws_vpc" "terraform-vpc" { &#13;
  cidr_block = "${var.vpc-cidr}" &#13;
 &#13;
  tags { &#13;
    Name = "${var.vpc-name}" &#13;
  } &#13;
} &#13;
</pre></div><div class="section" title="Add networking components"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec1"/>Add networking components</h4></div></div></div><p>We add a gateway, a route table, and an Internet facing subnet from where our Jenkins instance will be launched:</p><p>
<span class="strong"><strong>IGW</strong></span>
</p><pre class="programlisting"># Create an Internet Gateway &#13;
resource "aws_internet_gateway" "terraform-igw" { &#13;
  vpc_id = "${aws_vpc.terraform-vpc.id}" &#13;
} &#13;
</pre><p>
<span class="strong"><strong>Route table</strong></span>
</p><pre class="programlisting"># Create public route tables &#13;
resource "aws_route_table" "public" { &#13;
  vpc_id = "${aws_vpc.terraform-vpc.id}" &#13;
  route { &#13;
    cidr_block = "0.0.0.0/0" &#13;
    gateway_id = "${aws_internet_gateway.terraform-igw.id}" &#13;
  } &#13;
 &#13;
  tags { &#13;
    Name = "Public" &#13;
  } &#13;
} &#13;
</pre><p>
<span class="strong"><strong>Subnet</strong></span>
</p><pre class="programlisting"># Create and associate public subnets with a route table &#13;
resource "aws_subnet" "public-1" { &#13;
  vpc_id = "${aws_vpc.terraform-vpc.id}" &#13;
  cidr_block = "${cidrsubnet(var.vpc-cidr, 8, 1)}" &#13;
  availability_zone = "${element(split(",",var.aws-availability-zones), count.index)}" &#13;
  map_public_ip_on_launch = true &#13;
 &#13;
  tags { &#13;
    Name = "Public" &#13;
  } &#13;
} &#13;
 &#13;
resource "aws_route_table_association" "public-1" { &#13;
  subnet_id = "${aws_subnet.public-1.id}" &#13;
  route_table_id = "${aws_route_table.public.id}" &#13;
} &#13;
</pre></div><div class="section" title="Add EC2 node and related resources"><div class="titlepage"><div><div><h4 class="title"><a id="ch04lvl4sec2"/>Add EC2 node and related resources</h4></div></div></div><p>The security group for our Jenkins node needs to permit HTTP/S access plus SSH for convenience, so that we can access the command line if needed:</p><p>
<span class="strong"><strong>Security Group</strong></span>
</p><pre class="programlisting">resource "aws_security_group" "jenkins" { &#13;
  name = "jenkins" &#13;
  description = "ec2 instance security group" &#13;
  vpc_id = "${aws_vpc.terraform-vpc.id}" &#13;
 &#13;
  ingress { &#13;
    from_port = "22" &#13;
    to_port = "22" &#13;
    protocol = "tcp" &#13;
    cidr_blocks = ["0.0.0.0/0"] &#13;
  } &#13;
 &#13;
  ingress { &#13;
    from_port = "80" &#13;
    to_port = "80" &#13;
    protocol = "tcp" &#13;
    cidr_blocks = ["0.0.0.0/0"] &#13;
  } &#13;
 &#13;
  ingress { &#13;
    from_port = "443" &#13;
    to_port = "443" &#13;
    protocol = "tcp" &#13;
    cidr_blocks = ["0.0.0.0/0"] &#13;
  } &#13;
 &#13;
  egress { &#13;
    from_port = 0 &#13;
    to_port = 0 &#13;
    protocol = "-1" &#13;
    cidr_blocks = ["0.0.0.0/0"] &#13;
  } &#13;
 &#13;
} &#13;
</pre><p>
<span class="strong"><strong>IAM Role</strong></span>
</p><p>We will use an IAM Role to grant Jenkins access to AWS services:</p><pre class="programlisting">resource "aws_iam_role" "jenkins" { &#13;
    name = "jenkins" &#13;
    path = "/" &#13;
    assume_role_policy = &lt;&lt;EOF &#13;
{ &#13;
  "Version": "2012-10-17", &#13;
  "Statement": [ &#13;
    { &#13;
      "Action": "sts:AssumeRole", &#13;
      "Principal": { &#13;
        "Service": "ec2.amazonaws.com" &#13;
      }, &#13;
      "Effect": "Allow", &#13;
      "Sid": "" &#13;
    } &#13;
  ] &#13;
} &#13;
EOF &#13;
} &#13;
</pre><p>
<span class="strong"><strong>IAM Role Policy</strong></span>
</p><p>This policy will allow Jenkins to read from a codecommit repository and perform all actions (except deleting) on an s3 bucket:</p><pre class="programlisting">resource "aws_iam_role_policy" "jenkins" { &#13;
    name = "jenkins" &#13;
    role = "${aws_iam_role.jenkins.id}" &#13;
    policy = &lt;&lt;EOF &#13;
{ &#13;
    "Version": "2012-10-17", &#13;
    "Statement": [ &#13;
       { &#13;
            "Effect": "Allow", &#13;
            "Action": [ &#13;
                "codecommit:Get*", &#13;
                "codecommit:GitPull", &#13;
                "codecommit:List*" &#13;
            ], &#13;
            "Resource": "*" &#13;
       }, &#13;
       { &#13;
            "Effect": "Allow", &#13;
            "NotAction": [ &#13;
                "s3:DeleteBucket" &#13;
            ], &#13;
            "Resource": "*" &#13;
        } &#13;
    ] &#13;
} &#13;
EOF &#13;
} &#13;
</pre><p>
<span class="strong"><strong>IAM Profile</strong></span>
</p><pre class="programlisting">resource "aws_iam_instance_profile" "jenkins" { &#13;
    name = "jenkins" &#13;
    roles = ["${aws_iam_role.jenkins.name}"] &#13;
} &#13;
</pre><p>
<span class="strong"><strong>EC2 instance</strong></span>
</p><p>Here we define a single instance along with its bootstrap UserData script:</p><pre class="programlisting">resource "aws_instance" "jenkins" { &#13;
    ami = "${var.jenkins-ami-id}" &#13;
    instance_type = "${var.jenkins-instance-type}" &#13;
    key_name = "${var.jenkins-key-name}" &#13;
    vpc_security_group_ids = ["${aws_security_group.jenkins.id}"] &#13;
    iam_instance_profile = "${aws_iam_instance_profile.jenkins.id}" &#13;
    subnet_id = "${aws_subnet.public-1.id}" &#13;
    tags { Name = "jenkins" } &#13;
 &#13;
</pre><p>Here we set the attributes needed to launch an EC2 instance, such as the instance type, the AMI to be used, security group(s), subnet and so on.</p><p>Next, we add the bootstrap shell script to help us install required packages, checkout Git repositories and run Salt:</p><pre class="programlisting">    user_data = &lt;&lt;EOF &#13;
#!/bin/bash &#13;
set -euf -o pipefail &#13;
exec 1&gt; &gt;(logger -s -t $(basename $0)) 2&gt;&amp;1 &#13;
# Install Git and set CodeComit connection settings &#13;
# (required for access via IAM roles) &#13;
yum -y install git &#13;
git config --system credential.helper '!aws codecommit credential-helper $@' &#13;
git config --system credential.UseHttpPath true &#13;
# Clone the Salt repository &#13;
git clone https://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt /srv/salt; chmod 700 /srv/salt &#13;
# Install SaltStack &#13;
yum -y install https://repo.saltstack.com/yum/amazon/salt-amzn-repo-latest-1.ami.noarch.rpm &#13;
yum clean expire-cache; yum -y install salt-minion; chkconfig salt-minion off &#13;
# Put custom minion config in place (for enabling masterless mode) &#13;
cp -r /srv/salt/minion.d /etc/salt/ &#13;
# Trigger a full Salt run &#13;
salt-call state.apply &#13;
EOF &#13;
 &#13;
    lifecycle { create_before_destroy = true } &#13;
} &#13;
</pre><p>
<span class="strong"><strong>Elastic IP</strong></span>
</p><p>Finally, we provision a static IP for Jenkins:</p><pre class="programlisting">resource "aws_eip" "jenkins" { &#13;
  instance = "${aws_instance.jenkins.id}" &#13;
  vpc      = true &#13;
} &#13;
</pre></div></div><div class="section" title="Outputs"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec18"/>Outputs</h3></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/outputs.tf</a>.</p></div></div><p>Some useful outputs to provide us with the address of the Jenkins node:</p><pre class="programlisting">output "VPC ID" { &#13;
  value = "${aws_vpc.terraform-vpc.id}" &#13;
} &#13;
 &#13;
output "JENKINS EIP" { &#13;
  value = "${aws_eip.jenkins.public_ip}" &#13;
} &#13;
</pre><p>And that is our VPC infrastructure defined. Now we can move onto Salt and the application stack.</p></div></div><div class="section" title="SaltStack code"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec25"/>SaltStack code</h2></div></div></div><p>You'll remember our favorite Configuration Management tool from the previous chapter. We will use SaltStack to configure the EC2 Jenkins node for us.</p><div class="section" title="States"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec19"/>States</h3></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/states</a>.</p></div></div><p>
<span class="strong"><strong>top.sls</strong></span>
</p><p>We are working with a single minion, and all our states apply to it:</p><pre class="programlisting">base: &#13;
  '*': &#13;
    - users &#13;
    - yum-s3 &#13;
    - jenkins &#13;
    - nginx &#13;
    - docker &#13;
</pre><p>
<span class="strong"><strong>users</strong></span>
</p><p>We add a Linux user account, configure its SSH keys and <span class="strong"><strong>sudo</strong></span> access:</p><pre class="programlisting">veselin: &#13;
  user.present: &#13;
    - fullname: Veselin Kantsev &#13;
    - uid: {{ salt['pillar.get']('users:veselin:uid') }} &#13;
... &#13;
</pre><p>
<span class="strong"><strong>yum-s3</strong></span>
</p><p>As part of our CI pipeline, we will be storing RPM artefacts in S3. Cob (ref: <a class="ulink" href="https://github.com/henrysher/cob">https://github.com/henrysher/cob</a>) is a Yum package manager plugin which makes it possible to access S3 based RPM repositories using an IAM Role.</p><p>We deploy the plugin, its configuration and a repository definition (disabled for now) as managed files:</p><pre class="programlisting">yum-s3_cob.py: &#13;
  file.managed: &#13;
    - name: /usr/lib/yum-plugins/cob.py &#13;
    - source: salt://yum-s3/files/cob.py &#13;
 &#13;
yum-s3_cob.conf: &#13;
  file.managed: &#13;
    - name: /etc/yum/pluginconf.d/cob.conf &#13;
    - source: salt://yum-s3/files/cob.conf &#13;
 &#13;
yum-s3_s3.repo: &#13;
  file.managed: &#13;
    - name: /etc/yum.repos.d/s3.repo &#13;
    - source: salt://yum-s3/files/s3.repo &#13;
</pre><p>
<span class="strong"><strong>Jenkins</strong></span>
</p><p>Here comes the lead character – Mr Jenkins. We make use of Docker in our CI pipeline, hence the <code class="literal">include</code> following. Docker allows us to run the different pipeline steps in isolation, which makes dependency management much easier and helps keeps the Jenkins node clean.</p><pre class="programlisting">include: &#13;
  - docker &#13;
</pre><p>Also we ensure Java and a few other prerequisites get installed:</p><pre class="programlisting">jenkins_prereq: &#13;
  pkg.installed: &#13;
    - pkgs: &#13;
      - java-1.7.0-openjdk &#13;
      - gcc &#13;
      - make &#13;
      - createrepo &#13;
</pre><p>Then, install Jenkins itself:</p><pre class="programlisting">jenkins: &#13;
  pkg.installed: &#13;
    - sources: &#13;
      - jenkins: http://mirrors.jenkins-ci.org/redhat-stable/jenkins-2.7.1-1.1.noarch.rpm &#13;
    - require: &#13;
      - pkg: jenkins_prereq &#13;
... &#13;
</pre><p>
<span class="strong"><strong>NGINX</strong></span>
</p><p>We will use NGINX as a reverse proxy and an SSL termination point. That is not to say that Jenkins cannot serve on its own, it is just considered better practice to separate the roles:</p><pre class="programlisting">include: &#13;
  - jenkins &#13;
 &#13;
nginx: &#13;
  pkg.installed: [] &#13;
... &#13;
{% for FIL in ['crt','key'] %} &#13;
/etc/nginx/ssl/server.{{ FIL }}: &#13;
... &#13;
{% endfor %} &#13;
</pre><p>
<span class="strong"><strong>Docker</strong></span>
</p><p>It is about time we mentioned Docker, given its (deserved) popularity nowadays. It is very well suited to our CI needs, providing isolated environments for the various tests and builds that may be required:</p><pre class="programlisting">docker: &#13;
  pkg.installed: [] &#13;
 &#13;
  service.running: &#13;
    - enable: True &#13;
    - reload: True &#13;
</pre></div><div class="section" title="Pillars"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec20"/>Pillars</h3></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/pillars</a>.</p></div></div><p>
<span class="strong"><strong>top.sls</strong></span>
</p><p>Our standalone minion gets it all:</p><pre class="programlisting">base: &#13;
  '*': &#13;
    - users &#13;
    - nginx &#13;
</pre><p>
<span class="strong"><strong>users</strong></span>
</p><p>Setting a password hash and a consistent UID for the Linux account:</p><pre class="programlisting">users: &#13;
  veselin: &#13;
    uid: 5001 &#13;
    password: ... &#13;
</pre><p>
<span class="strong"><strong>NGINX</strong></span>
</p><p>We store the SSL data in this Pillar:</p><pre class="programlisting">nginx: &#13;
  crt: | &#13;
    -----BEGIN CERTIFICATE----- &#13;
    ... &#13;
    -----END CERTIFICATE----- &#13;
  key: | &#13;
    -----BEGIN RSA PRIVATE KEY----- &#13;
    ... &#13;
    -----END RSA PRIVATE KEY----- &#13;
</pre></div><div class="section" title="Minion configuration"><div class="titlepage"><div><div><h3 class="title"><a id="ch04lvl3sec21"/>Minion configuration</h3></div></div></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt/minion.d</a>.</p></div></div><p>
<span class="strong"><strong>masterless.conf</strong></span>
</p><p>We are still using Salt in standalone (masterless) mode, so this is our extra <code class="literal">minion</code> configuration:</p><pre class="programlisting">file_client: local &#13;
file_roots: &#13;
  base: &#13;
    - /srv/salt/states &#13;
pillar_roots: &#13;
  base: &#13;
    - /srv/salt/pillars &#13;
</pre><p>Thanks to all of the preceding codes, we should be able to run Terraform and end up with a Jenkins service ready for use.</p><p>Let us give that a try.</p></div></div></div></div>
<div class="section" title="Deploy IaC"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec11"/>Deploy IaC</h1></div></div></div><p>We start by creating a Terraform EC2 key-pair and a Terraform IAM user as in previous chapters (do not forget to write down access/secret API keys). Then we grant permissions to the IAM user to perform actions with the EC2, IAM, S3 and CodeCommit services:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/Terraform/iam_user_policy.json</a>.</p></div></div><pre class="programlisting">{ &#13;
    "Version": "2012-10-17", &#13;
    "Statement": [ &#13;
      { &#13;
          "Effect": "Allow", &#13;
          "NotAction": [ &#13;
              "codecommit:DeleteRepository" &#13;
          ], &#13;
          "Resource": "*" &#13;
      }, &#13;
      { &#13;
          "Effect": "Allow", &#13;
          "NotAction": [ &#13;
              "s3:DeleteBucket" &#13;
          ], &#13;
          "Resource": "*" &#13;
      }, &#13;
      { &#13;
          "Sid": "Stmt1461764665000", &#13;
          "Effect": "Allow", &#13;
          "Action": [ &#13;
              "ec2:AllocateAddress", &#13;
... &#13;
                 &#13;
</pre><p>Then we associate a SSH public key with the user (as per the screenshots in the previous chapter) to allow <code class="literal">codecommit</code> repository access.</p><p>Next, we need to setup our AWS CLI environment with the keys we produced earlier:</p><pre class="programlisting">
<span class="strong"><strong>$ export AWS_ACCESS_KEY_ID='user_access_key'</strong></span>
<span class="strong"><strong>$ export AWS_SECRET_ACCESS_KEY='user_secret_access_key'</strong></span>
<span class="strong"><strong>$ export AWS_DEFAULT_REGION='us-east-1'</strong></span>
</pre><p>Now we should be able to use the CLI tool and create our SaltStack repository:</p><pre class="programlisting">
<span class="strong"><strong>$ aws codecommit create-repository --repository-name salt &#13;
      --repository-description "SaltStack repo"</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>"repositoryMetadata": {</strong></span>
<span class="strong"><strong>"repositoryName": "salt",</strong></span>
<span class="strong"><strong>"cloneUrlSsh": &#13;
    "ssh://git-codecommit.us-east-1.amazonaws.com/v1/repos/salt",</strong></span>
<span class="strong"><strong>...</strong></span>
</pre><p>We clone the repository locally:</p><pre class="programlisting">
<span class="strong"><strong>$ git clone ssh://SSH_KEY_ID@git-codecommit.us-east-&#13;
     1.amazonaws.com/v1/repos/salt</strong></span>
<span class="strong"><strong>Cloning into 'salt'...</strong></span>
<span class="strong"><strong>warning: You appear to have cloned an empty repository.</strong></span>
<span class="strong"><strong>Checking connectivity... done.</strong></span>
</pre><p>(where <code class="literal">SSH_KEY_ID</code> is the one we saw after uploading a public key here)</p><p>Finally, you can copy the ready salt code examples for this chapter, commit and push to the <code class="literal">codecommit</code> repository.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/salt</a>
</p></div></div><p>With the SaltStack repo in sync, we can proceed with Terraform and the bootstrap process. Inside our TF templates folder we run the familiar command sequence:</p><pre class="programlisting">
<span class="strong"><strong>$ terraform validate</strong></span>
<span class="strong"><strong>$ terraform plan</strong></span>
<span class="strong"><strong>Refreshing Terraform state prior to plan...</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Plan: 11 to add, 0 to change, 0 to destroy.</strong></span>
<span class="strong"><strong>$ terraform apply</strong></span>
<span class="strong"><strong>aws_iam_role.jenkins: Creating...</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Apply complete! Resources: 11 added, 0 changed, 0 destroyed.</strong></span>
<span class="strong"><strong>Outputs:</strong></span>
<span class="strong"><strong>  JENKINS EIP = x.x.x.x</strong></span>
<span class="strong"><strong>  VPC ID      = vpc-xxxxxx</strong></span>
</pre><p>At the end we get the IP of our Jenkins node which we would need to resolve into a hostname (for example via the <code class="literal">nslookup</code> cmd). Load that in your browser and you should be greeted by Jenkins.</p></div>
<div class="section" title="Setup CI"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec12"/>Setup CI</h1></div></div></div><p>After a successful Terraform deployment, it is time to move onto service configuration. More specifically, Jenkins and the integration pipeline.</p><div class="section" title="Jenkins initialization"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec26"/>Jenkins initialization</h2></div></div></div><p>With Jenkins running for the first time, we need to complete a short setup routine. First, we need to SSH into the node and retrieve the admin password stored in <code class="literal">/var/lib/jenkins/secrets/initialAdminPassword</code>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_001.jpg" alt="Jenkins initialization"/></div><p>
</p><p>We are mainly interested in the pipeline group of plugins which is included with the suggested ones:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_002.jpg" alt="Jenkins initialization"/></div><p>
</p><p>After the plugins installation has completed, it's time to create our first user:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_003.jpg" alt="Jenkins initialization"/></div><p>
</p><p>With this the initialization process is complete and Jenkins is ready for use:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_004.jpg" alt="Jenkins initialization"/></div><p>
</p></div><div class="section" title="Writing a demo app"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec27"/>Writing a demo app</h2></div></div></div><p>Before configuring the CI pipeline, it will help to have something to do some integration on. A basic Hello World type of PHP code will do, so with a sincere apology to all PHP developers out there, I present you with the source of our demo app:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/tree/master/5585_04_CodeFiles/CodeCommit/demo-app</a>.</p></div></div><pre class="programlisting">src/index.php: &#13;
&lt;?php &#13;
 &#13;
function greet($name) { &#13;
  return "Hello $name!"; &#13;
} &#13;
 &#13;
$full_name = "Bobby D"; &#13;
 greet ($full_name); &#13;
&#13;
Clapping fades... &#13;
And naturally, a unit test for it: &#13;
tests/indexTest.php: &#13;
&#13;
&lt;?php &#13;
require_once "src/index.php"; &#13;
 &#13;
class IndexTest extends PHPUnit_Framework_TestCase &#13;
{ &#13;
  public function testGreet() { &#13;
    global $full_name; &#13;
    $expected = "Hello $full_name!"; &#13;
    $actual = greet($full_name); &#13;
    $this-&gt;assertEquals($expected, $actual); &#13;
    } &#13;
}</pre><p>There is a third file in our <code class="literal">demo-app</code> folder curiously named <code class="literal">Jenkinsfile</code> which we will discuss shortly.</p><p>Now let us get our code into a repository:</p><pre class="programlisting">
<span class="strong"><strong>$ aws codecommit create-repository --repository-name demo-app &#13;
      --repository-description "Demo app"</strong></span>
<span class="strong"><strong>{</strong></span>
<span class="strong"><strong>"repositoryMetadata": {</strong></span>
<span class="strong"><strong>"repositoryName": "demo-app",</strong></span>
<span class="strong"><strong>"cloneUrlSsh": &#13;
    "ssh://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app"</strong></span>
<span class="strong"><strong>...</strong></span>
<span class="strong"><strong>Then we clone it locally (replace SSH_KEY_ID as before):</strong></span>
<span class="strong"><strong>$ git clone ssh://SSH_KEY_ID@git-codecommit.us-east-&#13;
      1.amazonaws.com/v1/repos/demo-app</strong></span>
<span class="strong"><strong>...</strong></span>
</pre><p>Finally, we place our <code class="literal">demo-app</code> code into the empty repository, commit and push all changes to codecommit.</p></div><div class="section" title="Defining the pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Defining the pipeline</h2></div></div></div><p>It is time to decide on what the CI pipeline is meant to do for us. Here is a list of useful steps as a start:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Checkout application source code from Git</li><li class="listitem">Run tests against it by running PHPUnit inside a Docker container (on the Jenkins host)</li><li class="listitem">Build application artefacts by executing FPM within a container on the Jenkins host</li><li class="listitem">Upload artefacts to an external store (for example, a Yum repository)</li></ol></div><p>Translated into Jenkins pipeline code:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/demo-app/Jenkinsfile</a>.</p></div></div><pre class="programlisting">#!groovy &#13;
 &#13;
node { &#13;
 &#13;
  stage "Checkout Git repo" &#13;
    checkout scm &#13;
   &#13;
  stage "Run tests" &#13;
    sh "docker run -v \$(pwd):/app --rm phpunit/phpunit tests/" &#13;
  stage "Build RPM" &#13;
    sh "[ -d ./rpm ] || mkdir ./rpm" &#13;
    sh "docker run -v \$(pwd)/src:/data/demo-app -v \$(pwd)/rpm:/data/rpm --rm tenzer/fpm fpm -s dir -t rpm -n demo-app -v \$(git rev-parse --short HEAD) --description "Demo PHP app" --directories /var/www/demo-app --package /data/rpm/demo-app-\$(git rev-parse --short HEAD).rpm /data/demo-app=/var/www/" &#13;
 &#13;
  stage "Update YUM repo" &#13;
    sh "[ -d ~/repo/rpm/demo-app/ ] || mkdir -p ~/repo/rpm/demo-app/" &#13;
    sh "mv ./rpm/*.rpm ~/repo/rpm/demo-app/" &#13;
    sh "createrepo ~/repo/" &#13;
    sh "aws s3 sync ~/repo s3://MY_BUCKET_NAME/ --region us-east-1 --delete" &#13;
 &#13;
  stage "Check YUM repo" &#13;
    sh "yum clean all" &#13;
    sh "yum info demo-app-\$(git rev-parse --short HEAD)" &#13;
} &#13;
</pre><p>Generally speaking, defining a pipeline consists of a setting out a series of tasks/stages. Let us review each of the preceding stages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We start with a Git checkout of our <code class="literal">demo-app</code> code. The repository address is assumed to be the one of the <code class="literal">Jenkinsfile</code>.</li><li class="listitem" style="list-style-type: disc">At the next stage we take advantage of Docker's isolation and spin up a container with everything needed for PHPUnit (ref: https://phpunit.de) to run a test against our <code class="literal">demo-app</code> source code. Take a look in the <code class="literal">tests/</code> folder under <code class="literal">${GIT_URL}/Examples/Chapter-4/CodeCommit/demo-app/</code> if you would like to add more or modify it further.</li><li class="listitem" style="list-style-type: disc">If the tests pass, we move onto building an RPM artefact using a neat, user-friendly tool called FPM (ref: https://github.com/jordansissel/fpm), again in a Docker container. We use the short <code class="literal">git commit hash</code> as the version identifier for our demo-app.</li><li class="listitem" style="list-style-type: disc">We move our RPM artefact to a designated repository folder, create a YUM repository out of it using <code class="literal">createrepo</code> and sync all that data to an Amazon S3 bucket. The idea is to use this S3 based YUM repository later on for deploying our <code class="literal">demo-app</code>.</li><li class="listitem" style="list-style-type: disc">Finally, as a bonus, we check that the package we just synced can be retrieved via YUM.</li></ul></div><p>Our pipeline is now defined but before we can run it, we need to satisfy one (S3) dependency. We need to create a S3 bucket to store the RPM artefacts that the pipeline would produce. Then we need to update parts of the Jenkins and Saltstack code with the address of that S3 bucket.</p><p>To interact with S3, we shall use the AWS CLI tool within the environment we configured for Terraform earlier:</p><pre class="programlisting">
<span class="strong"><strong>$ aws s3 mb s3://MY_BUCKET_NAME</strong></span>
</pre><p>The bucket name is up to you, but keep in mind that the global S3 namespace is shared, so the more unique the name the better.</p><p>Next, we update our pipeline definition (<code class="literal">Jenkinsfile</code>). Look for the line containing <code class="literal">MY_BUCKET_NAME</code>:</p><pre class="programlisting">
<span class="strong"><strong>sh "aws s3 sync ~/repo s3://MY_BUCKET_NAME/ --region us-east-1 &#13;
        --delete"</strong></span>
</pre><p>We also need to update SaltStack (again replacing <code class="literal">MY_BUCKET_NAME</code>):</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>Please refer to:
<a class="ulink" href="https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo">https://github.com/PacktPublishing/Implementing-DevOps-on-AWS/blob/master/5585_04_CodeFiles/CodeCommit/salt/states/yum-s3/files/s3.repo</a>.</p></div></div><pre class="programlisting">[s3-repo] &#13;
name=S3-repo &#13;
baseurl=https://s3.amazonaws.com/MY_BUCKET_NAME &#13;
enabled=1 &#13;
gpgcheck=0 &#13;
</pre><p>This <code class="literal">repo</code> file will be used in the last stage of our pipeline, as we will see in a moment. At this point you will need to commit and push both changes: the <code class="literal">Jenkinsfile</code> to the <code class="literal">demo-app</code> repository and the <code class="literal">s3.repo</code> file to the SaltStack one. Then you would SSH into the Jenkins node, pull and apply the Salt changes.</p></div><div class="section" title="Setting up the pipeline"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Setting up the pipeline</h2></div></div></div><p>Back to the Jenkins interface. After logging in, we click on the <code class="literal">create new jobs</code> link on the welcome page:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_005.jpg" alt="Setting up the pipeline"/></div><p>
</p><p>We select <span class="strong"><strong>Pipeline</strong></span> as a job type and pick a name for it:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_006.jpg" alt="Setting up the pipeline"/></div><p>
</p><p>The next screen takes us to the job configuration details. At the top we choose to <span class="strong"><strong>Discard old builds</strong></span> in order to keep our Jenkins workspace compact. We are saying, only keep details of the last five executions of this job:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_007.jpg" alt="Setting up the pipeline"/></div><p>
</p><p>Under <span class="strong"><strong>Build Triggers</strong></span> we choose to poll our Git repository for changes every 5 minutes:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_008.jpg" alt="Setting up the pipeline"/></div><p>
</p><p>Underneath, we choose <span class="strong"><strong>Pipeline script from SCM</strong></span>, set SCM to <span class="strong"><strong>Git</strong></span> and add the URL of our <code class="literal">demo-app</code> repository (that is <a class="ulink" href="https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app">https://git-codecommit.us-east-1.amazonaws.com/v1/repos/demo-app</a> ) to be polled:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_009.jpg" alt="Setting up the pipeline"/></div><p>
</p><p>No need for extra credentials as these will be fetched via the EC2 IAM Role. Note the <span class="strong"><strong>Script Path</strong></span> referencing the Jenkins file we mentioned earlier. This is a great new feature which gives us pipeline as code functionality as described here: <a class="ulink" href="https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm">https://jenkins.io/doc/pipeline/#loading-pipeline-scripts-from-scm</a>.</p><p>With that we can keep our application code and the Jenkins pipeline definition conveniently together under revision control.</p><p>After we save the pipeline job, Jenkins will start polling the Git repository and trigger an execution whenever a change is detected (or you can click on <span class="strong"><strong>Build Now</strong></span> to force a run).</p><p>Each successful build will result in an RPM package uploaded to our YUM repository. Go ahead and experiment, breaking the build by changing the <code class="literal">demo-app</code> source code so that the test fails.</p><p>To troubleshoot, look at the <span class="strong"><strong>Build History</strong></span> list, select the job that failed and examine its <span class="strong"><strong>Console Output</strong></span>:</p><p>
</p><div class="mediaobject"><img src="graphics/image_04_010.jpg" alt="Setting up the pipeline"/></div><p>
</p><p>Now that you are familiar with our example pipeline, I encourage you to expand it: Add more stages to it, make some of the tasks execute in parallel, enable chat or email notifications, or link pipelines so they trigger each other.</p><p>You will appreciate the benefits of implementing a CI server as you continue to convert more of your daily, manual routines to Jenkins jobs.</p><p>You can be sure your teammates will love it too.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note44"/>Note</h3><p>Please remember to delete any AWS resources used in the preceding examples (VPC, EC2, S3, IAM, CodeCommit, etcetera) to avoid unnecessary charges.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec13"/>Summary</h1></div></div></div><p>In this chapter we studied examples of how to launch and configure a Continuous Integration environment on AWS.</p><p>We used our previous Terraform and SaltStack knowledge to prepare the AWS infrastructure.</p><p>With the help of Jenkins CI we composed a pipeline that would take application source code, run tests against it, build an RPM package and deposit that into a remote YUM repository for later use.</p><p>Our next topic will be on Continuous Delivery, an extension to Continuous Integration which takes us a step closer to being ready to deploy our application to a production environment with confidence.</p></div></body></html>