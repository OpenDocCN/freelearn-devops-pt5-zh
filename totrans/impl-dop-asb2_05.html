<html><head></head><body>
        

                            
                    <h1 class="header-title">Playbooks – Beyond the Fundamentals</h1>
                
            
            
                
<p>In the previous chapter, we outlined and discussed how to construct Ansible playbook's and inventory host files. This knowledge will help us get up and running with Ansible quickly and is a great foundation to build from. We looked at how to leverage these implementations to target groups of infrastructure and began to see some of the power that Ansible provides. While Ansible was designed with simplicity as its core design construct, that does not mean it is not highly scalable and flexible. In many ways, Ansible's real power and scalability comes from its modular design and simplistic implementation standards combined with an effectively customizable playbook and role design pattern.</p>
<p>While the implementations we have learned thus far have their place and purpose (as basic constructs, and foundational elements), can you imagine how hard a 10,000-line single file Ansible playbook would be to create and manage? Or what if half of that playbook were designed to simply setup web servers? Could there be a better way? Absolutely! A better way of implementing and managing playbook's is to use Ansible roles and the includes. These scenarios are where moving beyond a simple single-file playbook becomes a reality.</p>
<p>In this chapter, we are going to expand our Ansible knowledge and learn how to make use of Ansible roles and includes. We will learn how to expand from a single playbook file into a playbook hierarchy structure where multiple files can be combined and reused to provide an <strong>Object Oriented Programming</strong> (<strong>OOP</strong>) playbook implementation. In addition to learning roles and include, we will also learn how registers and other more advanced playbook structures work. The specific learning objectives of this chapter are as follows:</p>
<ul>
<li>Ansible playbook's and Conditional Logic</li>
<li>Ansible Loops and Iterators</li>
<li>Ansible Includes</li>
<li>Ansible Roles</li>
<li>Ansible Registers</li>
<li>Error Trapping</li>
<li>Ansible Handlers</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">playbook's and Conditional Logic</h1>
                
            
            
                
<p>Ansible provides a nice integrated way of performing conditional operations. That is to say, a task can be executed when a given condition is met. Some examples of this type of requirement might be to only execute a task <em>if</em> the target system is Ubuntu or only execute a task <em>if</em> the target system has a specific processor architecture.</p>
<p>Ansible supports conditionals through the implementation of the when operator. In this section, we will take a look at how Ansible manages conditionals and tour through an example of managing tasks through a condition. Let's start with this code:</p>
<pre class="p1">
<strong># Reboot Debian Flavored Linux Systems using the WHEN operator </strong>tasks:<br/>  - name: "Reboot all Debian flavored Linux systems"<br/>    command: /sbin/reboot -t now<br/>    when: Ansible_os_family == "Debian"
</pre>
<p>In this example, we conditionally specify the <kbd>Debian</kbd> family as the requirement for the task to run. Simple enough, right? In addition to the example using the <kbd>Ansible_os_family</kbd> implementation, we can also specify variable conditions. Variable conditions let us specify that a variable is set or exists as a requirement to executing the Ansible task. Look at another example of a snippet:</p>
<pre class="p1">
<strong># Display Hello World to DevOps readers</strong><br/>vars:<br/>  is_enabled: true<br/>tasks:<br/>    - name: "Tell only DevOps People Hello"<br/>      shell: echo “Hello DevOps Readers“<br/>      when: is_enabled
</pre>
<p>In this example, we can see that if the when operator is set to <kbd>true</kbd>, we tell the user <em>hello</em>. Simple enough logic, right? In addition to this implementation, we can also use the inverse of this logic, that is, to execute a task when the operator is not set. Let's take a look at an example of this in inverse operation in action:</p>
<pre>
tasks:<br/><br/> - shell: echo "The operator has not been set"<br/> when: myvar is undefined
</pre>
<p>While simple logic can be implemented using these solutions, oftentimes we need something a bit more comprehensive. In addition to simple logic conditions Ansible provides, we can also perform more complex implementations. One such implementation is the use of iterators and conditions. Let's take a look at an example of how to implement this:</p>
<pre>
<strong># Iterator with conditional logic to stop the iteration at a specified number</strong><br/><br/>tasks:<br/>  - command: echo {{ item }}<br/>    with_items: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ]<br/>    when: item &gt; 7
</pre>
<p>In this example, we have a simple command of <kbd>echo</kbd>, which takes an iterator array (<kbd>with_items</kbd>), and we terminate the loop if the item count gets larger than <kbd>7</kbd>. The output of this example should be similar to the following screenshot:</p>
<div><img class="image-border" src="img/7974d04b-b200-4c30-8bb3-be0d708a73b4.png"/></div>
<p>Great! Now that we know how to do this, let's take a look at how to use conditionals based on the output of previous commands. Here is an example:</p>
<div><div><pre>
<strong>  when: "'divide by zero' in output"</strong>
</pre></div>
</div>
<p>After the implementation of Ansible 2.0, the kind folks at Ansible provided us with a handy way of adding conditionals to Ansible roles. As a result, we can now use conditional logic directly within our role declarations. This is accomplished via the following syntax:</p>
<pre>
<strong># Conditional Logic directly in the Ansible Roles </strong><br/><br/>- hosts: all<br/>  roles:<br/>     - { role: centos_config, when: Ansible_os_family == 'CentOS' }
</pre>
<p class="mce-root">So we have learned how useful conditionals can be within an Ansible playbook. Now let's move on from conditionals onto iterators and loops. Iterators and loops provide us with a really handy way to reduce the amount of code we write and allow us to perform repetitive operations easily.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterators and Loops</h1>
                
            
            
                
<p>In Ansible (and YAML for that matter), there is usually more than one way to accomplish any given automation. Automation actions can be implemented in simple YAML format or can be potentially grouped together by using the <kbd>with_items</kbd> iterator. In this section, we will take a look at iterators and learn how we can leverage them to reduce the amount of YAML code we need to write and organize our playbook tasks more effectively.</p>
<p>If you are familiar with basic programming concepts, the idea of an iterator is not new or novel. In fact, Ansible supports multiple variations of an iterator: everything from traditional loops to <kbd>Do...Until</kbd>, numerical iterators, and many more. Iterators in the context of Ansible playbook's are almost identical in nature as traditional programming implementations of iterators, with a few specific syntax caveats.</p>
<p>In this section, we are going to look at the multiple loop variations that Ansible supports. We will begin by looking at standard basic loops and move onto more complex implementations as we progress through this section. Let's get moving!</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic loops using with_items</h1>
                
            
            
                
<p>Ansible's YAML integration supports a basic loop syntax for reducing duplication in code. This can be especially handy when installing packages, copying files, or managing sets of items. The Ansible implementation of this is managed via the <kbd>with_items</kbd> iterator. Ansible's <kbd>with_items</kbd> iterator allows us to specify the task to perform once and a list of items to perform the same task repetitively. Let's look at a comparison of an Ansible task that uses <kbd>with_items</kbd> and the same set of tasks that does not use this feature:</p>
<pre>
<strong># playbook.yml without list based iterators</strong><br/>---<br/>- hosts: all<br/>  tasks:<br/>    - name: Install Apache2<br/>      apt: name=apache2 state=installed<br/><br/>    - name: Install VIM<br/>      apt: name=vim state=installed<br/><br/>    - name: Install TMUX<br/>      apt: name=tmux state=installed<br/><br/>    - name: Install MOSH<br/>      apt: name=mosh state=installed<br/><br/><strong># playbook.yml using an Iterator to install packages</strong><br/>---<br/>- hosts: all<br/>  tasks:<br/>    - name: Install list of packages<br/>      apt: name={{item}} state=installed<br/>        with_items:<br/>          - apache2<br/>          - vim<br/>          - tmux<br/>          - mosh
</pre>
<p>Based on this example, we can see that we can alleviate some tedium when writing our playbook's by using a <kbd>with_items</kbd> iterator. The iterator in this case takes a list of items and then repeats the task any number of times with a different item substituted during each iteration.</p>
<div><p>In addition to specifying <kbd>with_items</kbd> directly inline in the task, we can also leverage a list defined within a YAML variables file, or the vars section. This can be accomplished like so:</p>
<p><kbd>with_items: "{{ myvarlist }}"</kbd></p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Nested loops using with_nested</h1>
                
            
            
                
<p>In addition to the simple loops we described previously, Ansible's syntax also supports the idea of nested looping. Nested loops in many ways are similar in nature to a set of arrays that would be iterated over using the <kbd>with_nested</kbd> operator. Nested loops provide us with a succinct way of iterating over multiple lists within a single task. This could be useful in cases where multiple data items are required (such as creating user accounts with different names and details, or maybe seeding a MySQL database). Let's look at an example:</p>
<pre class="p1">
# Demo of Nested Loops Using Ansible. To execute use the following command:<br/><strong># &gt; Ansible-playbook -i 'localhost,' -c local nested_loops.yml</strong><br/><br/>---<br/>- name: Demo of nested loops using with_nested<br/>  hosts: all<br/>  remote_user: root<br/>  vars:<br/>    listA: [1, 2]<br/>    listB: [a, b]<br/>  tasks:<br/>    - name: Say Hello using Nested Loops<br/>      debug: msg=“The values in the array are {{item[0]}} and {{item[1]}}"<br/>      with_nested:<br/>        - listA<br/>        - listB
</pre>
<p class="CDPAlignCenter CDPAlign CDPAlignLeft">Here is the output from the console when we run this playbook on the command line:</p>
<div><img class="image-border" src="img/48116d26-cb97-4884-9039-74ae1a53ba1e.png"/></div>
<p>As we can see from this example, we have the ability within our playbook to use arrays and iterate over them by simply referring to them using the <kbd>with_items</kbd> clause. Neat, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Looping over hashes using with_dict</h1>
                
            
            
                
<p>For those of you who are familiar with programming languages, the idea of a hash is nothing new. For those of you who are not familiar, a hash is simply a set of data points identified by a key. Within a hash can be multiple keys, and each key has an associated value.</p>
<p>Let's take a look at a basic example of a hash to get a better idea of how this unique but popular data structure works:</p>
<div><img height="133" width="171" class="image-border" src="img/7eebd00a-36a9-4960-bf31-20a2fcdace64.png"/></div>
<p class="CDPAlignLeft CDPAlign">From this, table we can see that a key is simply an identifier, and the value that key represents could be any string or data piece stored in the value table that is associated with that specific key. So how does this apply to Ansible? Ansible provides us a <kbd>with_dict</kbd> operator, which we can leverage to iterate over key/value pairs. Let's look at an example:</p>
<pre class="mce-root">
# Example of iterating over a YAML dictionary (iterator_keyvalue.yml)<br/># To execute save this as a YML file and run the following command <br/><strong># &gt; Ansible-playbook -i 'localhost,' -c local iterator_keyvalue.yml</strong><br/>---<br/>- name: Say Hello to our Favorite Looney Tune Characters<br/>  hosts: all<br/>  vars:<br/>    looney_tunes_characters:<br/>      bugs:<br/>        full_name: Bugs A Bunny<br/>      daffy:<br/>        full_name: Daffy E Duck<br/>      wiley:<br/>        full_name: Wiley E Coyote<br/>  tasks:<br/>    - name: Show Our Favorite Looney Tunes<br/>      debug:<br/>      msg: "Hello there: {{ item.key }} your real name is {{ item.value.full_name }}"<br/>      with_dict: "{{ looney_tunes_charachters }}"
</pre>
<p class="mce-root">This example shows a way to store hash data within an Ansible playbook and then iterate over the results. In this specific case, we iterate over the key, which is our looney's short name, and the associated value, which is the looney's full name. When we run this playbook, the output we will see should be something like the following:</p>
<div><img class="image-border" src="img/f2a15eda-3136-4ee0-be56-8178628e540a.png"/></div>
<p class="mce-root">So we can see from this screenshot that Ansible will neatly iterate over the data sets we requested and say <em>hello</em> to our favorite Looney Tunes character.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterating over files using with_file</h1>
                
            
            
                
<p>Ansible's <kbd>with_file</kbd> operator provides us with a handy way to iterate over the contents of a file. This specific iterator operation provides us with a way to iterate over a single file or multiple files in order. To illustrate how this works, let's look at an example:</p>
<ul>
<li><kbd>hello.txt</kbd>:</li>
</ul>
<pre style="padding-left: 90px">
Hello There:
</pre>
<ul>
<li><kbd>favorite_toons.txt</kbd>:</li>
</ul>
<pre style="padding-left: 90px">
Bugs Bunny<br/>Daffy Duck<br/>Mickey Mouse<br/>Donald Duck<br/>Wiley E. Coyote
</pre>
<ul>
<li><kbd>iterator_file_contents.yml</kbd>:</li>
</ul>
<pre class="mce-root">
# Example Playbook which Iterates Over the Contents of Two Files (iterator_file_contents.yml)<br/>---<br/>- name: Say hello to our favorite Looney Toons<br/>  hosts: all<br/>  tasks:<br/>    - name: Say Hello to Our Favorite Looney Toons<br/>      debug:<br/>        msg: "{{ item }}"<br/>        with_file:<br/>          - hello.txt<br/>          - favorite_toons.txt
</pre>
<p>From this example, we should be able to at this point understand basically what it is trying to accomplish. The first thing it will do is display the contents of <kbd>hello.txt</kbd>, and subsequently display the contents of <kbd>favorite_toons.txt</kbd>. As such, the output should be similar to the following screenshot:</p>
<div><img class="image-border" src="img/a0d2d93b-6fcd-4c44-a0ef-866c084a97f8.png"/></div>
<p>From this screenshot, we can see that the playbook which uses nesting outputs the names of our favorite Looney Toons character, prefaced with a greeting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterating over sequential numbers</h1>
                
            
            
                
<p>Counting through a sequential number set is a fundamental programming concept. It involves essentially creating a counter that counts forward or backward sequentially by a given step. That is to say, we can count up or down from a given number using Ansible sequential numerical iterators. We can then pipe the numerical data from Ansible into, say, a shell call or a debug message. Let's take a quick look at a brief example:</p>
<pre>
# Ansible Example provided by Ansible.com<br/># create some test users<br/> - user:<br/>     name: "{{ item }}"<br/>     state: present<br/>     groups: "evens"<br/>   with_sequence: start=0 end=32 format=testuser%02x<br/>
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The do until iterator</h1>
                
            
            
                
<p>The <kbd>Do...Until</kbd> iterator has been around for a long time in many programming languages. It is probably one of the most widely implemented iterators that exist. This specific iteration solution provides the developer with the ability to continuously loop through a sequence of code until a specific condition or flag is met. Let's look at a traditional programming example of a <kbd>Do...Until</kbd> loop versus an Ansible implementation of the same operator:</p>
<ul>
<li>VB.NET example:</li>
</ul>
<pre style="padding-left: 90px" class="p1">
  ' This example is a VB.NET example of a Do Loop<br/>  Do<br/>            Debug.Write(“Counter: " &amp; index.ToString)<br/>            index += 1<br/>  Loop Until index &gt; 5
</pre>
<ul>
<li>Ansible <kbd>Do...Until</kbd> example:</li>
</ul>
<pre style="padding-left: 120px" class="p1">
- action:<br/>    /usr/bin/tail -n 1 /var/log/auth.log <br/>  register: result<br/>  until: result.stdout.find("Cannot create session") != -1<br/>  retries: 100<br/>  delay: 1
</pre>
<p>This Ansible <kbd>Do</kbd> example shows how to tail a log and wait for a specific text to appear. This can be really handy when waiting for a system to spin up or an execution to throw something in a log file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterating over inventory hosts using play_hosts</h1>
                
            
            
                
<p>Inventory hosts are data items too! Each hostname defined within an inventory file can be iterated upon. This implementation of the kind folks at Ansible can be really handy for performing numerous configuration operations, installation items, and much more. In this section, we will look at how to effectively iterate through an inventory file and perform an operation with the hosts defined. The easiest way to iterate through the inventory is to use the <kbd>play_hosts</kbd> variable in conjunction with <kbd>with_items</kbd>. While this may be the easiest method, it is not the only way to achieve this type of iteration. Let's get started by looking at an example of the <kbd>play_hosts</kbd> variable in action:</p>
<ul>
<li><kbd>hosts.yml</kbd>:</li>
</ul>
<pre>
[webserver]<br/>192.168.10.10<br/>192.168.10.11<br/>192.168.10.12<br/><br/>[dbserver]<br/>192.168.30.1<br/>192.168.30.2<br/>192.168.30.3
</pre>
<ul>
<li><kbd>iterating_inventory_ex1.yml</kbd>:</li>
</ul>
<pre>
# Example of a playbook, which iterates over the inventory list.<br/># Specifically this will display <br/># all hosts in the webserver group. This example uses the play_hosts <br/># variable in conjunction <br/># with with_items to provide an elegant mechanism for iterating.<br/><br/>--- <br/>- <br/>  hosts: webserver<br/>  name: "Iteration Example using With_Items and Play_Hosts"<br/>  tasks: <br/>    - <br/>      debug: ~<br/>      msg: "Host Identified: {{ item }}"<br/>      with_items: <br/>        - "{{ play_hosts }}"
</pre>
<p>This example shows the user a list of all hosts that are currently targeted by the execution, in this case, the items in the <kbd>webserver</kbd> group.</p>
<p>In addition to the previously shown example, which uses the <kbd>play_hosts</kbd> variable, we can also implement a similar solution using Ansible group identifiers. Group identifiers are a neat way to access the data (hosts in our case) that Ansible is using as part of this specific run. This implementation is actually in some ways slightly more powerful. The power of this solution comes from the key/value pair definition we can specify in the groups variable. Let's take a look at an example of how we can use group identifiers to effect the same output as the previous example:</p>
<pre class="p1">
<strong># Display inventory using groups['webserver']</strong><br/>- debug:<br/>    msg: "{{ item }}"<br/>  with_items:<br/>    - "{{ groups['webserver'] }}"
</pre>
<p>As we can see from this example, we can not only target the current hosts targeted by the play, but also any specific group defined within the inventory. For example, we can fetch a list of <em>all</em> hosts by simply specifying <kbd>{{ groups['all'] }}</kbd>. Or if we wanted to target only the <kbd>dbserver</kbd> group, we could do something like this:</p>
<pre class="p1">
with_items:<br/>  - "{{ groups['dbserver'] }}"
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Includes</h1>
                
            
            
                
<p>It is completely feasible to create a playbook as a single small or large file. Many new Ansible developers actually begin developing playbook's this way, and generally, this implementation methodology is a perfectly normal way to initially learn Ansible playbook creation. Sooner or later though, learning to reuse portions of a playbook will become something very useful and will help better organize playbook development efforts.</p>
<p>On a fundamentally simplistic level, using an Ansible include statement allows us to reuse positions of our automation in one or multiple locations. Consider this in some ways like a method or function in programming that we can execute over and over, essentially allowing us to write the automation once and then reuse it many times.</p>
<p>This is a far more effective way to reuse automation as it removes the need for repeating the creation of various portions of an automation or configuration management solution. As a result, we can begin to think outside of the scope of <em>step one, step two—</em>type automation and instead start thinking in terms of <em>provision this as a web server, or provision this as a web and database server</em>.</p>
<p>This is a pretty critical concept. We might have a top level playbook that is nothing than a series of includes that are easy to understand and reusable. For example:</p>
<ul>
<li><kbd>- include: add_users.yml</kbd></li>
<li><kbd>- include: install_httpd.yml</kbd></li>
<li><kbd>- include: configure_apache.yml</kbd></li>
<li><kbd>- include: setup_firewall.yml</kbd></li>
</ul>
<p>This is the real power of ansible because the first and last steps there would be executed on every box.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Play-level includes</h1>
                
            
            
                
<p>One of the most effective ways to modularize and organize an Ansible playbook is to use Ansible <kbd>include</kbd>. Ansible play includes provide an easy way to embed <kbd>play</kbd> from other YAML files. This implementation allows us to effectively modularize our playbook's automation. Let's take a look at how to leverage a <kbd>play</kbd> include within an Ansible playbook:</p>
<pre>
<strong># This is an example of a 'play' include, which includes the contents of playlevelplays.yml</strong><br/><br/>- include: playlevelplays.yml<br/>- name: some play<br/>  hosts: all<br/>  tasks:<br/>    - debug: msg=hello<br/><br/><strong># This is an example of the contents of playlevelplays.yml</strong><br/><br/>- name: some additional play<br/>  hosts: all<br/>  tasks:<br/>    - debug: msg=hello I am an included file
</pre>
<p>In this example, we can see that to implement a <kbd>play</kbd> include, we can simply add a <kbd>- include: &lt;filename&gt;</kbd> directive within our playbook, which will embed the contents of an external Ansible playbook (its plays) into the current playbook and execute those contents at the appropriate step. Neat, right? So to sum up, let's define an Ansible <kbd>play</kbd> include succinctly: a play-level include allows us to embed additional Ansible plays from external files within our playbook's using the <kbd>-include</kbd> directive.</p>
<p>In addition to the <em>vanilla</em> implementation of Ansible includes we just looked at, the Ansible <kbd>include</kbd> directive provides us with the ability to pass parameters to our included files upon execution. This can be handy for handing off variables to the other YAML files we include. Let's take a look at how to pass parameters using the <kbd>include</kbd> directive. An example is provided next:</p>
<pre>
tasks:<br/>  - include: myincludedplaybook.yml user=dbuser
</pre>
<p>Based on the previous example, we can then wield the variable within the target included file using the following syntax <kbd>{{user}}</kbd>. So a more complete example might look like the following:</p>
<pre>
tasks:<br/> - include: myincludedplaybook.yml user=dbuser<br/> <br/> - debug:<br/>   msg: "System {{ user }} user is AWESOME!"
</pre>
<p>Now that we have a grasp of play-level includes, let's take a look at task includes.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Task-level includes</h1>
                
            
            
                
<p>In addition to play includes, Ansible supports an additional implementation of the <kbd>include</kbd> directive. The second implementation is called a <strong>task include</strong>. Task includes are different from <kbd>play</kbd> includes, in that the contents of the included file would only be a YAML file containing a static list of tasks to execute. To implement a task include, we must specify the include directive at the task level. Let's take a look at an example of a task include solution:</p>
<pre>
<strong># This is an example of a 'play' include</strong><br/><br/>- include: myplaybook.yml<br/>- name: some play<br/>  hosts: all<br/>  tasks:<br/>    - debug: msg=hello<br/><br/>    # An Example of a task level include<br/>    - include: additionaltasks.yml
</pre>
<p>From this example, we can see the <kbd>include</kbd> statement provided would include the contents of the file <kbd>additionaltasks.yml</kbd>. The important thing to understand here is scope. Play-level includes will need to have a complete play or set of plays within, whereas <kbd>task</kbd> includes should only have a YAML-formatted list of tasks. Let's look at an example of each for a bit of clarity. Consider the following two files, adequately named <kbd>additionaltasks.yml</kbd>.</p>
<p>The content of <kbd>additionaltasks.yml</kbd> is illustrated here:</p>
<pre>
---<br/># additional_tasks.yml example<br/>- name: some task<br/>  command: /bin/ls<br/>- name: some other tasks<br/>  command: /bin/ps -ef
</pre>
<p>So now, we know that Ansible supports two scopes of the <kbd>include</kbd> directive: the first imports a set of plays, and the second imports a set of tasks. These two distinctions are important to understand as they are a powerful feature that can be used to modularize automation and configuration management implementations. By effectively using includes, we can create highly feature-rich automation and configuration management solutions without redundancy in code.</p>
<p>As of Ansible 2, you can develop unlimited levels of includes. This means that one file can include another, and within the second, you can include additional ones. There is no limit to the number of includes supported.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dynamic includes</h1>
                
            
            
                
<p>In conjunction with the two basic include types that we mentioned before, Ansible 2.0 supports dynamic task-level includes. A dynamic include is simply a variable translation support within an <kbd>include</kbd>. As a result of this implementation, we should note that the inclusion is not actually evaluated by Ansible until the moment it is set to be executed. This allows adding variables within an include, which was not possible prior to Ansible 2.0. This implementation can more specifically leverage loops and variable use within the <kbd>include</kbd> statement. This additional functionality provides us with a significant amount of flexibility within our playbook. Let's take a look at a few examples of <strong>dynamic includes</strong>:</p>
<pre>
# A basic dynamic include using a variable<br/>- include: "{{dbserver}}.yml"
</pre>
<p>This example shows us that it is possible to use variable names within our <kbd>include</kbd> statement. This can be useful for dynamically specifying the file to include, or having the <kbd>include</kbd> file be assigned at runtime. Beyond this implementation, we can also use dynamic includes to pass a list of variables between the master playbook and child. An example of this is provided next:</p>
<pre>
# Dynamic include with parameters as a loop<br/>- include: myplaybook.yml param={{item}}<br/>  with_items:<br/>  - apples<br/>  - oranges<br/>  - {{favorite_fruit}}
</pre>
<p>From this example, we can see we are passing <kbd>apples</kbd>, <kbd>oranges</kbd>, and the variable <kbd>{{favorite_fruit}}</kbd> to our included playbook using the <kbd>with_items</kbd> notation (more on this later). This should give you a pretty good idea of how to pass information from one playbook to an include file.</p>
<p>Now that we have a pretty good grasp of how Ansible can be more dynamic, let's take a look at Ansible roles and see how those fit into our implementations and development efforts.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible Roles</h1>
                
            
            
                
<p>Ansible works very well with supporting a single-file 10,000-line long playbook (please don't actually do that). However, when playbook's grow out of control, Ansible provides a very nice way to break automation into multiple files (as illustrated before using includes). Yet, as we start to grow the number of files we need to include, things can become hairy to manage and maintain. So what is an Ansible developer to do? Roles to the rescue! Ansible roles provide us with a really unique way of dividing out our automation into uniquely defined responsibilities.</p>
<p>In addition to providing configuration management modularization, Ansible roles provide us with a best-practice approach to organizing automation within a playbook and developing reusable solutions. The Ansible <em>roles</em> implementation simply represents an automated, well-structured implementation of an Ansible includes solution (which we discussed in the previous section). This means that the include directives are already defined and implemented so long as the predefined directory structure is honored within the roles implementation.</p>
<p>So to sum up, let's consider the following definition for Ansible roles:</p>
<p>A role is a set of Ansible tasks or configuration management automation grouped by a common purpose or responsibility.</p>
<p>To begin understanding how Ansible roles work on a fundamental level, it is probably best to start with a simple flat-file Ansible playbook that installs and configures a LAMP server (Linux, Apache, MySQL, and PHP) and then implement the same solution using Ansible roles and look at the implementation differences. This will give us a good apples-to-apples comparison of how roles implementations differ from standard playbook's and how to organize the responsibilities. For this tutorial, we will be using an Ubuntu-based Ansible control server. Let's get started:</p>
<p>The content of <kbd>AnsibleLAMPwithoutRoles.yml</kbd> is illustrated here:</p>
<pre>
# playbook.yml<br/>---<br/>- hosts: all<br/>  tasks:<br/>    - name: Install Apache<br/>      apt: name=apache2 state=present<br/><br/>    - name: Install PHP module for Apache<br/>      apt: name=libapache2-mod-php5 state=present<br/><br/>    - name: Install PHP<br/>      apt: name=libapache2-mod-php5 state=present<br/><br/>    - name: Install MySQL<br/>      apt: name=libapache2-mod-php5 state=present<br/><br/>    - name: 3. start Apache<br/>      service: name=apache2 state=running enabled=yes<br/><br/>    - name: 4. install Hello World PHP script<br/>      copy: src=index.php dest=/var/www/index.php
</pre>
<p>Based on this playbook, we can see we are instructing Ansible to install and configure a basic LAMP solution via a single playbook. This includes installing Apache2, PHP, MySQL, and so on. With Ansible roles, we can accomplish the same tasks with a bit more elegance and modularity.</p>
<p>As mentioned earlier, Ansible roles are basically include statements that are pre-baked into the Ansible implementation based on a set of predefined directory structures. Let's take a look at this same basic configuration management implementation and how the directory structure that makes up Ansible roles would need to be applied. On your local system, replicate the following directory and file structure (leave the file contents blank for the moment):</p>
<div><img height="196" width="323" class="image-border" src="img/184e108a-bef1-46fe-9162-489d23761a1e.png"/></div>
<p>Once the directory and file structure have been created, the next thing we need to fill in is the top-level <kbd>playbook.yml</kbd> file, which we will use to specify the roles we want and execute them. Here is the content to add to <kbd>playbook.yml</kbd>:</p>
<pre>
<strong># playbook.yml</strong><br/>---<br/>- hosts: all<br/>  roles:<br/>    - webserver<br/>    - dbserver
</pre>
<p>The purpose of this file is to simply act as a pointer to the roles we wish to execute as part of our Ansible run. The <kbd>roles</kbd> defined within in this case are a <kbd>webserver</kbd> role and a <kbd>dbserver</kbd> role. Each role will be defined by naming and folder convention. Let's move on to the roles themselves. In our example, we have two task files that need to be created/modified (the <kbd>webserver</kbd> tasks file and the <kbd>dbserver</kbd> tasks file). These are respectively named <kbd>main.yml</kbd> and reside in the tasks folder. Let's fill in each. The contents for each are provided next.</p>
<p>The content of <kbd>webserver/tasks/main.yml</kbd> and <kbd>dbserver/tasks/main.yml</kbd> is illustrated here:</p>
<pre>
<strong># roles/dbserver/tasks/main.yml</strong><br/><br/>- name: Install Mysql Server Packages<br/>  yum: name={{ item }} state=installed<br/>  with_items:<br/>   - mysql-server<br/>   - MySQL-python<br/>- name: Start Mysql Service<br/>  service: name=mysqld state=started enabled=yes<br/><br/>- name: Create Example Database<br/>  mysql_db: name=foo state=present<br/><br/>- name: Create Example DB User<br/>  mysql_user: name=foo password=bar priv=*.*:ALL host='%' state=present<br/><br/><strong># roles/webserver/tasks/main.yml</strong><br/>---<br/>- name: Install Apache HTTPD Server Packages<br/>  yum: name={{ item }} state=installed<br/>  with_items:<br/>   - httpd<br/><br/>- name: Start Http Service<br/>  service: name=http state=started enabled=yes<br/><br/>
</pre>
<p>When we run this playbook with our roles defined, we can see that Ansible understands how to traverse the main playbook and execute the roles required to ensure that Apache and MySQL are properly installed and running.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible Register Variables</h1>
                
            
            
                
<p>Ansible registers provide us with a nice way of capturing the results of a given task and executing a set of additional automations based on the captured results. In many ways, this is similar to variable declarations, although registers are more global in nature. Ansible registers provide us with a way of storing this captured data for later and then conditionalizing future tasks based on the results of previous ones.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Simple Ansible registers</h1>
                
            
            
                
<p>The most basic Ansible register implementations require us to only <kbd>register</kbd> the output of a given operation. An example of how to define a simple register is provided next:</p>
<pre class="p1">
---<br/>- name: A Simple Ansible Register Example<br/>  hosts: all<br/>  tasks:<br/>      - shell: tail -n 100 /etc/motd<br/>        register: motd_contents
</pre>
<p>In this example, we use the register operator to capture the last 100 lines of the system's MOTD file and store it in a global <kbd>register</kbd> variable, <kbd>motd_contents</kbd>. Ansible registers essentially create a new Ansible fact at runtime, which can be then used later within the play as part of a conditional.</p>
<p>But how exactly do we leverage stored registers later? Good question! Let's explore.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Accessing registers</h1>
                
            
            
                
<p>Accessing Ansible registers later within the same <kbd>play</kbd> as they were created can be accomplished fairly easily: all we need to do is use the the <kbd>when</kbd> conditional. We learned about the basics of how to leverage the <kbd>when</kbd> conditional earlier in this chapter. But in this context it lets us access registers. Let's look at an example of how to use the <kbd>when</kbd> conditional to access our <kbd>register</kbd>:</p>
<pre class="p1">
---<br/>- name: A Simple Ansible Register Example<br/>  hosts: all<br/>  tasks:<br/>      - shell: tail -n 100 /etc/motd<br/>        register: motd_contents<br/><br/>     - shell: echo "Our MOTD file contains the word Bugs Bunny"<br/>        when: motd_contents.stdout.find('bugs bunny') != -1
</pre>
<p>The important line in this playbook is the <kbd>when</kbd> line (obviously). The interesting portion of it is the idea of <kbd>.stdout.find</kbd>, which is attached to the end of our register variable. This extension in many ways looks like a set of OOP methods. That would be an accurate way to identify those specific calls.</p>
<p>In our example, we told Ansible to look at the contents of <kbd>STDOUT</kbd> (standard command-line output) and find a specific text. If Ansible were able to properly find the text, only then would the task have been executed. Nifty, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Additional conditional logic with registers</h1>
                
            
            
                
<p>Ansible registers are not limited only by the find method of <kbd>STDOUT</kbd>. In addition to basic search criteria, we can also apply many other comparisons. In this section, we will identify the more common methods that can be attached to a <kbd>register</kbd> variable and learn what other comparisons we can perform.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Null or empty comparisons</h1>
                
            
            
                
<p>Null or empty string comparisons are common in most programming languages, and Ansible is no different. Applying a null or empty string check to an Ansible register can be accomplished via the following solution:</p>
<pre>
 when: &lt;registername&gt;.stdout == ""
</pre>
<p>In addition to this specific implementation, we can also apply other variables to our conditionals with registers. Let's see how.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Vars and Ansible registers</h1>
                
            
            
                
<p>Ansible registers also support the use of regular predefined variable comparisons within an Ansible register <kbd>when</kbd> clause. This implementation lets us say something like the following:</p>
<pre>
"when varfoo is in register, execute the task" 
</pre>
<p>This plain English comparison could be represented in Ansible YAML form via something like this:</p>
<pre>
with_items: varfoo.stdout.find("{{bar}}") &gt; 0
</pre>
<p>This conditional simply specifies that if the contents of <kbd>varfoo</kbd> exist within the <kbd>stdout</kbd> of register <kbd>varfoo</kbd>, then execute the task.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Iterating over register contents</h1>
                
            
            
                
<p>Finally, the contents of the register can be iterated over to create new things and adapt existing system solutions. This type of implementation might be something like creating a list of directories, touching a set of files, or creating a list of users. Basically, it means we can use the contents of the register as a list. Let's take a look at a quick example provided by <a href="https://www.ansible.com/">https://www.Ansible.com/</a>:</p>
<pre>
--<br/>- name: registered variable usage as a with_items list<br/>  hosts: all<br/><br/>  tasks:<br/><br/>      - name: retrieve the list of home directories<br/>        command: ls /home<br/>        register: home_dirs<br/><br/>      - name: add home dirs to the backup spooler<br/>        file: path=/mnt/bkspool/{{ item }} src=/home/{{ item }} state=link<br/>        with_items: "{{ home_dirs.stdout_lines }}"<br/>        # same as with_items: "{{ home_dirs.stdout.split() }}"
</pre>
<p>Based on this example, we can see that our <kbd>with_items</kbd> clause is now used to create a set of files and folders. However, the <kbd>home_dirs</kbd> variable is set through a register instead of a standard Ansible variable.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible Handlers</h1>
                
            
            
                
<p>Ansible handlers by default are run at the end of the actual execution of a playbook. They are different from registers in that they provide us with a way of creating a set of automation that can be executed once (and only once) at the end of a playbook based on a set of conditions provided during the execution. Logically, this could look something like the following:</p>
<ul>
<li>Run role <kbd>foo</kbd></li>
<li>Run role <kbd>bar</kbd>:
<ul>
<li>If role <kbd>bar</kbd>'s service start failed, trigger a flag</li>
</ul>
</li>
<li>Execute handlers:
<ul>
<li>If a trigger was flagged, do something</li>
</ul>
</li>
</ul>
<p>While this example may seem similar in some ways to conditionals, it is in many ways very different. That is to say, the handler would only get executed the one time regardless of how many times the flag was tripped. In addition, the other variance would be that a handler is more global in nature. That is to say, regardless of which role tripped the flag of the handler, it would still get executed, thus making the solution non-modular.<br/>
<br/>
Confused? Let's take a look at an example of an Ansible handler:<strong><br/></strong></p>
<pre class="p1">
--<br/>- name: Example Handler<br/>  hosts: all<br/>  tasks:<br/>    - command: service httpd restart<br/>      notify: restart service<br/><br/>    - command: service mysqld restart<br/>      notify: restart service<br/><br/>    - command: service cron.d restart<br/>      notify: restart service<br/><br/>    - command: service iptables restart<br/>      notify: restart service<br/><br/>  handlers:<br/>    - name: restart service<br/>      include: tasks/restart_verify.yml
</pre>
<p>From this example, we can see we have two new concepts: the <kbd>notify</kbd> operator and the <kbd>handlers</kbd> operator. Notify in some ways represents a global event system, which throws an event out when triggered. The handlers on the other hand represent listeners to those events.</p>
<p>So essentially, we can use the <kbd>notify</kbd> solution to trigger a set of tasks downstream after the main playbook has completed its execution. Nice, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p class="p1">In this chapter, we discovered a number of new techniques of developing and managing playbook's. We learned how to leverage <kbd>includes</kbd> to modularize our playbook structures and provide us with a level of reusability within our implementations. We learned how to implement conditional logic within our playbook's. We found out how to deal with iterators and loops. We discovered how to implement roles in Ansible and how we can use this structure to organize and better manage complex configuration management and automation tasks. We learned how to best organize our playbook's for reusability. We learned how handlers and registers work and discovered ways we can make our automation solutions more fault tolerant, and we discussed how to effectively enforce basic configuration management implementations.</p>
<p class="p1">This information represents the basic cursory information you will need to become a successful Ansible developer and pave the way for success in configuration management. To assist you on your way, the <a href="https://www.ansible.com/">https://www.Ansible.com/</a> documentation can be of great use. As such, this resource should become your go-to guide for all things Ansible related.</p>
<p class="p1">In the next chapter, we will discover Jinja2. Jinja provides Ansible with a huge amount of flexibility as it allows conditionals, loops, variables, and so much more. By the time we complete the next chapter, we should have a pretty good idea of how we can develop playbook's and leverage Jinja to support our implementations.</p>


            

            
        
    </body></html>