<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-115"><a id="_idTextAnchor347"/>8</h1>
<h1 id="_idParaDest-116"><a id="_idTextAnchor348"/>Coding Best Practices</h1>
<p>Ansible can help you automate almost all your daily IT tasks, from mundane tasks, such as applying patches or deploying configuration files, to deploying entirely new infrastructure as code. The use of, and engagement with, Ansible has been growing year by year as more and more people realize its power and simplicity. You will find many examples of Ansible playbooks, roles, blog articles, and so on across the internet, and combined with resources such as this book, you will become proficient at writing your own Ansible playbooks.</p>
<p>Yet, how can you tell whether an example you found on the internet is actually a good way of doing things? In this chapter, we will take you through a practical guide of the best practices in Ansible, showing you what is currently considered good practice when it comes to directory structure and playbook layout, how to make effective use of inventories (especially on the cloud), and how best to differentiate your environments. By the end of this chapter, you should be able to proceed with confidence in writing everything from small single-task playbooks to large-scale playbooks for complex environments.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The preferred directory layout</li>
<li>Differentiating between different environment types</li>
<li>The proper approach to defining group and host variables</li>
<li>Using top-level playbooks</li>
<li>Leveraging version control tools</li>
<li>Setting OS and distribution variances</li>
<li>Porting between Ansible versions</li>
</ul>
<h1 id="_idParaDest-117"><a id="_idTextAnchor349"/>Technical requirements</h1>
<p>This chapter assumes that you have set up your control host with Ansible, as in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, and that you are using the most recent version available; the examples in this chapter were tested on Ansible 2.15. This chapter also assumes that you have at least one additional host to test against; ideally, this should be Linux-based. Although we will give specific examples of hostnames in this chapter, you are welcome to substitute them with your own hostname and/or IP addresses, and details of how to do this are provided in the appropriate places.</p>
<p>The code bundle used in this chapter is available at <a href="https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%208">https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%208</a>.</p>
<h1 id="_idParaDest-118"><a id="_idTextAnchor350"/>The preferred directory layout</h1>
<p>As we <a id="_idIndexMarker467"/>have explored Ansible throughout this book, we have shown many times that the more your playbook grows in size and scale, the more likely you are to want to divide it up into multiple files and directories. A great example of this is roles, which we covered in <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks and Roles</em>, where we defined roles<a id="_idIndexMarker468"/> to not only enable us to reuse common automation code but also to split up what could potentially be a massive, single playbook into smaller, logically organized, manageable chunks. We also looked, in <a href="B20846_03.xhtml#_idTextAnchor158"><em class="italic">Chapter 3</em></a>, <em class="italic">Defining Your Inventory</em>, at the process of defining your inventory file and how you can also split this up across multiple files and directories. What we have not looked at, however, is how we can put all of this together. All of this is documented in the official Ansible<a id="_idIndexMarker469"/> documentation at <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.xhtml#content-organization">https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.xhtml#content-organization</a>.</p>
<p>However, in this chapter, let’s get started with a practical example of this to show you a great way of setting up your directory structure for a simple role-based playbook that has two different inventories—one for a development environment and one for a production environment (you would want to keep these separate in any real-world use case; although, ideally, you should be able to execute the same plays on both for consistency and for testing purposes).</p>
<p>Let’s get started by building the directory structure:</p>
<ol>
<li>Create<a id="_idIndexMarker470"/> a directory tree for your development inventory with the following commands:<pre class="source-code">
<strong class="bold">$ mkdir -p inventories/development/group_vars</strong>
<code>inventories/development/hosts</code>:<pre class="source-code">
[app]
app01.dev.example.com
app02.dev.example.com</pre></li> <li>To<a id="_idIndexMarker471"/> further our example, we’ll add a group variable to our app group. As discussed in <a href="B20846_03.xhtml#_idTextAnchor158"><em class="italic">Chapter 3</em></a>, <em class="italic">Defining Your Inventory</em>, create a file called <code>app.yml</code> in the <code>group_vars</code> directory we created in the previous step:<pre class="source-code">
---
http_port: 8080</pre></li> <li>Next, create a <code>production</code> directory structure using the same method:<pre class="source-code">
<strong class="bold">$ mkdir -p inventories/production/group_vars</strong>
<code>hosts</code> in the newly created <code>production</code> directory with the following contents:<pre class="source-code">
[app]
app01.prod.example.com
app02.prod.example.com</pre></li> <li>Now, we’ll <a id="_idIndexMarker472"/>define a different value for the <code>http_port</code> group variable for our <code>production</code> inventory. Add the following contents to <code>inventories/production/group_vars/app.yml</code>:<pre class="source-code">
---
http_port: 80</pre></li> </ol>
<p>That completes our inventory definition. Next, we will add any custom modules or plugins that we might find useful for our playbook. Suppose we want to use the <code>remote_filecopy.py</code> module we created in <a href="B20846_05.xhtml#_idTextAnchor279"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating and Consuming</em><em class="italic"> Modules</em>. Just as we discussed in that chapter, we first create the directory for this module:</p>
<pre class="console">
$ mkdir library</pre> <p>Then, we<a id="_idIndexMarker473"/> add the <code>remote_filecopy.py</code> module to this library. We won’t relist the code here to save space, but you can copy it from the section called <em class="italic">Developing custom modules</em> from <a href="B20846_05.xhtml#_idTextAnchor279"><em class="italic">Chapter 5</em></a>, <em class="italic">Creating and Consuming</em><em class="italic"> Modules</em>, or take advantage of the example code that accompanies this book on GitHub.</p>
<p>The same can be done for the plugins; if we also want to use the <code>filter</code> plugin that we created in <a href="B20846_06.xhtml#_idTextAnchor318"><em class="italic">Chapter 6</em></a>, <em class="italic">Creating and Consuming</em><em class="italic"> Plugins</em>, we would create an appropriately named directory:</p>
<pre class="console">
$ mkdir filter_plugins</pre> <p>Then, copy the <code>filter</code> plugin code into this directory.</p>
<p>Finally, we’ll create a role to use in our new playbook structure. Naturally, you will have many roles, but we’ll create one as an example and then you can repeat the process for each role. We’ll call our role <code>installapp</code> and use the <code>ansible-galaxy</code> command (covered in <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks and Roles</em>) to create the directory structure for us:</p>
<pre class="console">
$ mkdir roles
$ ansible-galaxy role init --init-path roles/ installapp
- Role installapp was created successfully</pre> <p>Then, in our <code>roles/installapp/tasks/main.yml</code> file, we’ll add the following contents:</p>
<pre class="source-code">
---
- name: Display http_port variable contents
  debug:
    var: http_port
- name: Create /tmp/foo
  file:
    path: /tmp/foo
    state: file
- name: Use custom module to copy /tmp/foo
  remote_filecopy:
    source: /tmp/foo
  dest: /tmp/bar
- name: Define a fact about automation
  set_fact:
    about_automation: "Puppet is an excellent automation tool"
- name: Tell us about automation with a custom filter applied
  debug:
    msg: "{{ about_automation | improve_automation }}"</pre> <p>In the<a id="_idIndexMarker474"/> preceding code, we’ve reused a number of examples from earlier chapters of this book. You can also define the handlers, variables, default values, and so on to the role, as discussed previously, but for our example, this will suffice.</p>
<p>The final stage in creating our best practice directory structure is to add a top-level playbook to run. By convention, this will be called <code>site.yml</code> and it will have the following simple contents (note that the directory structure we have built takes care of many things, allowing the top-level playbook to be incredibly simple):</p>
<pre class="source-code">
---
- name: Play using best practice directory structure
hosts: all
  roles:
    - installapp</pre> <p>For the <a id="_idIndexMarker475"/>purpose of clarity, your resulting directory structure should look as follows:</p>
<pre class="console">
.
├── filter_plugins
│ ├── custom_filter.py
│ └── custom_filter.pyc
├── inventories
│ ├── development
│ │ ├── group_vars
│ │ │ └── app.yml
│ │ ├── hosts
│ │ └── host_vars
│ └── production
│ ├── group_vars
│ │ └── app.yml
│ ├── hosts
│ └── host_vars
├── library
│ └── remote_filecopy.py
├── roles
│ └── installapp
│ ├── defaults
│ │ └── main.yml
│ ├── files
│ ├── handlers
│ │ └── main.yml
│ ├── meta
│ │ └── main.yml
│ ├── README.md
│ ├── tasks
│ │ └── main.yml
│ ├── templates
│ ├── tests
│ │ ├── inventory
│ │ └── test.yml
│ └── vars
│ └── main.yml
└── site.yml</pre> <p>Now, we can simply <a id="_idIndexMarker476"/>run our playbook in the normal manner. For example, to run it on the <code>development</code> inventory, execute the following:</p>
<pre class="console">
$ ansible-playbook -i inventories/development/hosts site.yml
PLAY [Play using best practice directory structure] ****************************
TASK [Gathering Facts] *********************************************************
ok: [app02.dev.example.com]
ok: [app01.dev.example.com]
TASK [installapp : Display http_port variable contents] ************************
ok: [app01.dev.example.com] =&gt; {
 "http_port": 8080
}
ok: [app02.dev.example.com] =&gt; {
 "http_port": 8080
}
TASK [installapp : Create /tmp/foo] ********************************************
changed: [app02.dev.example.com]
changed: [app01.dev.example.com]
TASK [installapp : Use custom module to copy /tmp/foo] *************************
changed: [app02.dev.example.com]
changed: [app01.dev.example.com]
TASK [installapp : Define a fact about automation] *****************************
ok: [app01.dev.example.com]
ok: [app02.dev.example.com]
TASK [installapp : Tell us about automation with a custom filter applied] ******
ok: [app01.dev.example.com] =&gt; {
 "msg": "Ansible is an excellent automation tool"
}
ok: [app02.dev.example.com] =&gt; {
 "msg": "Ansible is an excellent automation tool"
}
PLAY RECAP *********************************************************************
app01.dev.example.com : ok=6 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
app02.dev.example.com : ok=6 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>Similarly, run <a id="_idIndexMarker477"/>the following for the <code>production</code> inventory:</p>
<pre class="console">
$ ansible-playbook -i inventories/production/hosts site.yml
PLAY [Play using best practice directory structure] ****************************
TASK [Gathering Facts] *********************************************************
ok: [app02.prod.example.com]
ok: [app01.prod.example.com]
TASK [installapp : Display http_port variable contents] ************************
ok: [app01.prod.example.com] =&gt; {
 "http_port": 80
}
ok: [app02.prod.example.com] =&gt; {
 "http_port": 80
}
TASK [installapp : Create /tmp/foo] ********************************************
changed: [app01.prod.example.com]
changed: [app02.prod.example.com]
TASK [installapp : Use custom module to copy /tmp/foo] *************************
changed: [app02.prod.example.com]
changed: [app01.prod.example.com]
TASK [installapp : Define a fact about automation] *****************************
ok: [app01.prod.example.com]
ok: [app02.prod.example.com]
TASK [installapp : Tell us about automation with a custom filter applied] ******
ok: [app01.prod.example.com] =&gt; {
 "msg": "Ansible is an excellent automation tool"
}
ok: [app02.prod.example.com] =&gt; {
 "msg": "Ansible is an excellent automation tool"
}
PLAY RECAP *********************************************************************
app01.prod.example.com : ok=6 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
app02.prod.example.com : ok=6 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>Notice <a id="_idIndexMarker478"/>how the appropriate hosts and associated variables are picked up for each inventory and how tidy and well organized our directory structure is. This is the ideal way for you to lay out your playbooks and will ensure that they can be scaled up to whatever size you need them to be, without them becoming unwieldy and difficult to manage or troubleshoot. In the next section, we wi<a id="_idTextAnchor351"/>ll explore differentiating between different environ<a id="_idTextAnchor352"/>ment types.</p>
<h1 id="_idParaDest-119"><a id="_idTextAnchor353"/>Differentiating between different environment types</h1>
<p>In<a id="_idIndexMarker479"/> almost every business, you will need to split your technology environment by type. For example, you will almost certainly have a development environment, where all the testing and development work is performed, and a production environment, where all of the stable test code is run. The environments should (in a best-case scenario) make use of the same Ansible playbooks—after all, the logic is that if you can successfully deploy and test an application in your development environment, then you should be able to deploy it in the same way in a production environment and have it work just as well. However, there are always differences between the two environments, not just in the hostnames but also sometimes in the parameters, the load balancer names, the port numbers, and so on—the list can seem endless.</p>
<p>In the <em class="italic">The preferred directory layout</em> section of this chapter, we covered a way of differentiating between a development and production environment using two separate inventory directory trees. This is how you should proceed when it comes to differentiating these environments; obviously, we won’t repeat the examples, but it’s important to note that when working with multiple environments, your goals should be as follows:</p>
<ul>
<li>Try and reuse the same playbooks for all of your environments that run the same code. For example, if you deploy a web app in your development environment, you should be confident that your playbooks will deploy the same app in the production environment (and your <strong class="bold">Quality Assurance</strong> (<strong class="bold">QA</strong>) environment, as <a id="_idIndexMarker480"/>well as any others that it might need to be deployed in).</li>
<li>This means that not only are you testing your application deployments and code but you are also testing your Ansible playbooks and roles as part of your overall testing process.</li>
<li>Your inventories for each environment should be kept in separate directory trees (as we saw in the <em class="italic">The preferred directory layout </em>section of this chapter), but all roles, playbooks, plugins, and modules (if used) should be in the same directory structure (this should be the case for both environments).</li>
<li>It is normal for different environments to require different authentication credentials; you should keep these separate not only for security but also to ensure that playbooks are not accidentally run in the wrong environment.</li>
<li>Your playbooks should be in your version control system, just as your code is. This enables you to track changes over time and ensure that everyone is working from the same copy of the automation code.</li>
</ul>
<p>If you pay<a id="_idIndexMarker481"/> attention to these simple pointers, you will find that your automation workflow becomes a real asset to your business and ensures reliability and consistency across all of your deployments. Conversely, failure to follow these pointers puts you at risk of experiencing the dreaded, <em class="italic">it worked in development but it doesn’t work in production</em> deployment failures that so often plague the technology industry. Let’s now build on this discussion in the next section by looking at best practices when handling host and group variables—something that, as we saw in the <em class="italic">The preferred directory layout</em> section, you need to apply, especially when working with multiple<a id="_idTextAnchor354"/> <a id="_idTextAnchor355"/>environments.</p>
<h1 id="_idParaDest-120"><a id="_idTextAnchor356"/>The proper approach to defining group and host variables</h1>
<p>When <a id="_idIndexMarker482"/>working with group and host variables, you can split them up using the directory-based approach we used in the <em class="italic">The preferred directory layout</em> section. However, there are a few additional pointers to managing this that you should be aware of. First and foremost, you should always pay attention to variable precedence. A detailed list of variable precedence order<a id="_idIndexMarker483"/> can be found at <a href="https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable">https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable</a>. However, the key takeaways for working with multiple environments are as follows:</p>
<ul>
<li>Host variables are always of a higher order of precedence than group variables, so you can override any group variable with a host variable. This behavior is useful if you take advantage of it in a controlled manner, but can yield unexpected results if you are not aware of it.</li>
<li>There is a special group variables definition called <code>all</code>, which is applied to all inventory groups. This has a lower order of precedence than specifically defined group variables.</li>
<li>What happens if you define the same variable twice in two groups? If this happens, both groups have the same order of precedence, so which one wins? To demonstrate this (and our earlier examples), we will create a simple practical example for you to follow.</li>
</ul>
<p>To get<a id="_idIndexMarker484"/> started, let’s create a directory structure for our inventories. To keep this example as concise as possible, we will only create a development environment. However, you are free to expand on these concepts by building on the more complete example we covered in the <em class="italic">The preferred directory layout</em> section of this chapter:</p>
<ol>
<li>Create an inventory directory structure with the following commands:<pre class="source-code">
<strong class="bold">$ mkdir -p inventories/development/group_vars</strong>
<code>inventories/development/hosts</code> file; the contents should be as follows:<pre class="source-code">
[app]
app01.dev.example.com
app02.dev.example.com</pre></li> <li>Now, let’s create a special group variable file for all the groups in the inventory; this file will be called <code>inventories/development/group_vars/all.yml</code> and should contain the following content:<pre class="source-code">
---
http_port: 8080</pre></li> <li>Finally, let’s create a simple playbook called <code>site.yml</code> to query and print the value of the variable we just created:<pre class="source-code">
---
- name: Play using best practice directory structure
hosts: all
tasks:
  - name: Display the value of our inventory variable
    debug:
      var: http_port</pre></li> <li>Now, if we <a id="_idIndexMarker485"/>run this playbook, we’ll see that the variable (which we only defined in one place) takes the value we would expect:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i inventories/development/hosts site.yml</strong>
<strong class="bold">PLAY [Play using best practice directory structure] ****************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [app01.dev.example.com]</strong>
<strong class="bold">ok: [app02.dev.example.com]</strong>
<strong class="bold">TASK [Display the value of our inventory variable] *****************************</strong>
<strong class="bold">ok: [app01.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 8080</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [app02.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 8080</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">app01.dev.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<code>all.yml</code> file remaining unchanged. Let’s also create a new file located in <code>inventories/development/group_vars/app.yml</code>, which will contain the following content:<pre class="source-code">
---
http_port: 8081</pre></li> <li>We have <a id="_idIndexMarker486"/>now defined the same variable twice—once in a special group called <code>all</code> and once in the <code>app</code> group (which both servers in our <code>development</code> inventory belong to). So, what happens if we now run our playbook? The output should appear as follows:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i inventories/development/hosts site.yml</strong>
<strong class="bold">PLAY [Play using best practice directory structure] ****************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [app02.dev.example.com]</strong>
<strong class="bold">ok: [app01.dev.example.com]</strong>
<strong class="bold">TASK [Display the value of our inventory variable] *****************************</strong>
<strong class="bold">ok: [app01.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 8081</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [app02.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 8081</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">app01.dev.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<code>centos</code>, and another group that could notionally contain hosts built to a new build standard, called <code>newcentos</code>, of which both application servers will be a member. This means modifying <code>inventories/development/hosts</code> so that it now looks as follows:<pre class="source-code">
[app]
app01.dev.example.com
app02.dev.example.com
[centos:children]
app
[newcentos:children]
app</pre></li> <li>Now, let’s redefine the <code>http_port</code> variable for the <code>centos</code> group by creating a file called <code>inventories/development/group_vars/centos.yml</code>, which contains the following content:<pre class="source-code">
---
http_port: 8082</pre></li> <li>Just to add to the confusion, let’s also define this variable for the <code>newcentos</code> group in <code>inventories/development/group_vars/newcentos.yml</code>, which will contain the following content:<pre class="source-code">
---
http_port: 8083</pre></li> <li>We’ve <a id="_idIndexMarker488"/>now defined the same variable four times at the group level! Let’s rerun our playbook and see which value comes through:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i inventories/development/hosts site.yml</strong>
<strong class="bold">PLAY [Play using best practice directory structure] ****************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [app01.dev.example.com]</strong>
<strong class="bold">ok: [app02.dev.example.com]</strong>
<strong class="bold">TASK [Display the value of our inventory variable] *****************************</strong>
<strong class="bold">ok: [app01.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 8083</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [app02.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 8083</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">app01.dev.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<code>newcentos.yml</code> won—but why? The Ansible documentation states that where identical variables are defined at the group level in the inventory (the one place you can do this), the one from the last-loaded group wins. Just for completeness, we can override all of this by leaving the <code>group_vars</code> directory untouched, but adding a file called <code>inventories/development/host_vars/app01.dev.example.com.yml</code>, which will contain the following content:<pre class="source-code">
---
http_port: 9090</pre></li> <li>Now, if we <a id="_idIndexMarker489"/>run our playbook one final time, we will see that the value we defined at the host level completely overrides any value that we set at the group level for <code>app01.dev.example.com</code>. <code>app02.dev.example.com</code> is unaffected as we did not define a host variable for it, so the next highest level of precedence—the group variable from the <code>newcentos</code> group—won:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i inventories/development/hosts site.yml</strong>
<strong class="bold">PLAY [Play using best practice directory structure] ****************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [app01.dev.example.com]</strong>
<strong class="bold">ok: [app02.dev.example.com]</strong>
<strong class="bold">TASK [Display the value of our inventory variable] *****************************</strong>
<strong class="bold">ok: [app01.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 9090</strong>
<strong class="bold">}</strong>
<strong class="bold">ok: [app02.dev.example.com] =&gt; {</strong>
<strong class="bold"> "http_port": 8083</strong>
<strong class="bold">}</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">app01.dev.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">app02.dev.example.com : ok=2 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>With this <a id="_idIndexMarker490"/>knowledge, you can now make advanced decisions about how to structure your variables within your inventory to make sure you achieve the desired results at both a host and group level. It’s important to know about variable precedence ordering, as these examples have demonstrated, but following the documented order will also allow you to produce powerful, flexible playbook inventories that work well across multiple environments. Now, you may have noticed that, throughout this chapter, we have used a top-level playbook in our directory structure, called <code>site.yml</code>. We will look at this playbook in greater det<a id="_idTextAnchor357"/>a<a id="_idTextAnchor358"/>il in the next section.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor359"/>Using top-level playbooks</h1>
<p>In all of the<a id="_idIndexMarker491"/> examples so far, we have built out using the best<a id="_idIndexMarker492"/> practice directory structure recommended by Ansible and continually referred to a top-level playbook, typically called <code>site.yml</code>. The idea behind this playbook (and, indeed, its common name across all of our directory structures) is so that it can be used across your entire server estate—that is to say, your <strong class="bold">site</strong>.</p>
<p>Of course, this is not to say that you have to use the same set of playbooks across every server in your infrastructure or for every single function; rather, it means only you can make the best decision as to what suits your environment best. However, the whole aim of Ansible automation is that the created solution is simple to run and operate. Imagine handing a playbook directory structure with 100 different playbooks to a new system administrator—how would they know which ones to run and in which circumstances? The task of training someone to use the playbooks would be immense and would simply move complexity from one area to another.</p>
<p>At the other end of the spectrum, you could make use of the <code>when</code> clauses with facts and inventory grouping, such that your playbook knows exactly what to run on each server in every possible circumstance. This, of course, is unlikely to happen, and the truth is that your automation solution will end up somewhere in the middle.</p>
<p>The most important thing is that, on receipt of a new playbook directory structure, a new operator at least knows what the starting point for both running the playbooks and understanding the code is. If the top-level playbook they encounter is always <code>site.yml</code>, then at least everyone knows where to start. Through the clever use of roles and the <code>import_*</code> and <code>include_*</code> statements, you can split your playbook up into logical portions of <a id="_idIndexMarker493"/>reusable code, as <a id="_idIndexMarker494"/>we previously discussed, all from one playbook file.</p>
<p>Now that you have learned about the importance of top-level playbooks, let’s take a look, in the next section, at how to take advantage of version control tools to ensure good practices are adhered to when it comes to centralizing and maint<a id="_idTextAnchor360"/>a<a id="_idTextAnchor361"/>ining your automation code.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor362"/>Leveraging version control tools</h1>
<p>As we discussed earlier <a id="_idIndexMarker495"/>in this chapter, it is vital that you version control and <a id="_idIndexMarker496"/>test not only your code but also your Ansible automation code. This should include inventories (or dynamic inventory collections), any custom modules, plugins, roles, and playbook code. The reason for this is simple—the ultimate goal of Ansible automation is likely to be to deploy an entire environment using a playbook (or set of playbooks). This might even involve deploying infrastructure as code, especially if you are deploying to a cloud environment.</p>
<p>Any changes to your Ansible code could mean big changes to your environment and possibly even determine whether an important production service works or not. As a result, it is vital that you maintain a version history of your Ansible code and that everyone works from the same version. You are free to choose the version control system that suits you best; most corporate environments will already have some kind of version control system in place. However, if you haven’t worked with version control systems before, we recommend that you sign up for a free account somewhere such as GitHub or GitLab, which both offer version control repositories for free, along with more advanced paid-for plans.</p>
<p>A <a id="_idIndexMarker497"/>complete <a id="_idIndexMarker498"/>discussion of version control with Git is beyond the scope of this book, but there are entire books devoted to the subject. However, we will take you through the simplest possible use case. It is assumed, in the following examples, that you are using a free account on GitHub, but if you are using a different provider, simply change the URLs to match those given to you by your version control repository host.</p>
<p>In addition to this, you will need to install the command-line Git tools on your Linux host.</p>
<p>On CentOS, you would install these as follows:</p>
<pre class="console">
$ sudo yum install git</pre> <p>On Ubuntu, the process is similarly straightforward:</p>
<pre class="console">
$ sudo apt-get update
$ sudo apt-get install git</pre> <p>On macOS, you can use the <code>brew</code> package manager to install Git tools as follows:</p>
<pre class="console">
$ brew install git</pre> <p>Once the tools are installed and your account is set up, your next task is to clone a Git repository to your machine. If you want to start working with your own repository, you will need to set this up with your provider—excellent documentation is provided by both GitHub and GitLab and you should follow this to set up your first repository.</p>
<p>Once it is set up and initialized, you can clone a copy to your local machine to make changes to your code. This local copy is called a working copy, and you can work through the process of cloning it and making changes as follows (note that these are purely hypothetical examples to give you an idea of the commands you will need to run; you should adapt <a id="_idIndexMarker499"/>them for your own use case):</p>
<ol>
<li>Clone your <code>git</code> repository to your<a id="_idIndexMarker500"/> local machine to create a working copy using a command such as the following:<pre class="source-code">
<strong class="bold">$ git clone https://github.com/&lt;YOUR_GIT_ACCOUNT&gt;/&lt;GIT_REPO&gt;.git</strong>
<strong class="bold">Cloning into '&lt;GIT_REPO&gt;'...</strong>
<strong class="bold">remote: Enumerating objects: 7, done.</strong>
<strong class="bold">remote: Total 7 (delta 0), reused 0 (delta 0), pack-reused 7</strong>
<strong class="bold">Unpacking objects: 100% (7/7), done.</strong></pre></li> <li>Change to the directory of the code you cloned (the working copy) and make any code changes you need to make:<pre class="source-code">
<strong class="bold">$ cd &lt;GIT_REPO&gt;</strong>
<strong class="bold">$ vim myplaybook.yml</strong></pre></li> <li>Be sure to test your code and, when you are happy with it, add the changed files that are ready for committing a new version using a command such as the following:<pre class="source-code">
<code>commit</code> message (specified in quotes after the <code>-m</code> switch), as follows:<pre class="source-code">
<strong class="bold">$ git commit -m 'Added new spongle-widget deployment to myplaybook.yml'</strong>
<strong class="bold">[master ed14138] Added new spongle-widget deployment to myplaybook.yml</strong>
<strong class="bold">Committer: Daniel Oh &lt;doh@danieloh.redhat.com&gt;</strong>
<strong class="bold">Your name and email address were configured automatically based</strong>
<strong class="bold">on your username and hostname. Please check that they are accurate.</strong>
<strong class="bold">You can suppress this message by setting them explicitly. Run the</strong>
<strong class="bold">following command and follow the instructions in your editor to edit</strong>
<strong class="bold">your configuration file:</strong>
<strong class="bold">git config --global --edit</strong>
<strong class="bold">After doing this, you may fix the identity used for this commit with:</strong>
<strong class="bold">git commit --amend --reset-author</strong>
<strong class="bold">1 file changed, 1 insertion(+), 1 deletion(-)</strong></pre></li> <li>Right <a id="_idIndexMarker503"/>now, all of these changes live solely in the working<a id="_idIndexMarker504"/> copy on your local machine. This is good by itself, but it would be better if the code was available to everyone who needs to view it on the version control system. To push your updated commits back to (for example) GitHub, run the following command:<pre class="source-code">
<strong class="bold">$ git push</strong>
<strong class="bold">Enumerating objects: 5, done.</strong>
<strong class="bold">Counting objects: 100% (5/5), done.</strong>
<strong class="bold">Delta compression using up to 8 threads</strong>
<strong class="bold">Compressing objects: 100% (3/3), done.</strong>
<strong class="bold">Writing objects: 100% (3/3), 297 bytes | 297.00 KiB/s, done.</strong>
<strong class="bold">Total 3 (delta 2), reused 0 (delta 0)</strong>
<strong class="bold">remote: Resolving deltas: 100% (2/2), completed with 2 local objects.</strong>
<strong class="bold">To https://github.com/&lt;YOUR_GIT_ACCOUNT&gt;/&lt;GIT_REPO&gt;.git</strong>
<strong class="bold">0d00263..ed14138 master -&gt; master</strong></pre></li> </ol>
<p>That’s all there is to it!</p>
<ol>
<li value="6">Now, other collaborators can clone your code just as we did in <em class="italic">Step 1</em>. Alternatively, if they already have a working copy of your repository, they can update their working copy using the following command (you can also do this if you want to update your working copy to see changes made by someone else):<pre class="source-code">
<strong class="bold">$ git pull</strong></pre></li> </ol>
<p>There are some incredibly <a id="_idIndexMarker505"/>advanced topics and use cases for <a id="_idIndexMarker506"/>Git that are beyond the scope of this book. However, you will find that roughly 80% of the time, the preceding commands are all the Git command-line knowledge you need. There are also a number of graphical frontends to Git, as well as code editors and <strong class="bold">Integrated Development Environments</strong> (<strong class="bold">IDEs</strong>), that integrate<a id="_idIndexMarker507"/> with Git repositories and can assist you further in taking advantage of them. With that complete, let’s take a look at how to ensure you can use the same playbook (or role) across multiple hosts, even though th<a id="_idTextAnchor363"/>e<a id="_idTextAnchor364"/>y might have different OSs and versions.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor365"/>Setting OS and distribution variances</h1>
<p>As stated<a id="_idIndexMarker508"/> earlier, our goal is to try to use the same automation code as widely as possible. However, as much as we try to standardize our technology environments, variants always creep in. For example, it is impossible to simultaneously perform a major upgrade on all your servers in one go, so when a major new OS version comes out, such as <strong class="bold">Red Hat Enterprise Linux</strong> (<strong class="bold">RHEL</strong>) 8 or <a id="_idIndexMarker509"/>Ubuntu Server 20.04, it is inevitable that some machines will remain on older versions as others are upgraded. Similarly, an environment might be standardized on Ubuntu, but then an application is introduced that has only been certified to run on CentOS. In short, as important as standardization is, variances will always creep in.</p>
<p>When writing Ansible playbooks, especially roles, your goal should be for them to be as widely applicable as possible throughout your environment. A classic example of this is package management—let’s say you are writing a role to install the Apache 2 web server. If you have to support both Ubuntu and CentOS with this role, not only do you have different package managers to deal with (<code>yum</code> and <code>apt</code>) but you also have different package names (<code>httpd</code> and <code>apache2</code>).</p>
<p>In <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks and Roles</em>, we looked at how to apply conditions to tasks using the <code>when</code> clause, along with facts gathered by Ansible, such as <code>ansible_distribution</code>. However, there is another way of running tasks on specific hosts that we haven’t yet looked at. In the same chapter, we also looked at the concept of defining multiple plays in one playbook—there is a special module that can create inventory groups for us based on Ansible facts, and we can leverage this along with multiple plays to create a playbook that runs the appropriate tasks on each host based on its type. This is best explained by a practical example, so let’s get started.</p>
<p>Assume<a id="_idIndexMarker510"/> that we are using the following simple inventory file for this example, which has two hosts in a single group called <code>app</code>:</p>
<pre class="source-code">
[app]
app01.dev.example.com
app02.dev.example.com</pre> <p>Let’s now build a simple playbook that demonstrates how you can group the groups using an Ansible fact so that the OS distribution determines which play in a playbook is run.</p>
<p>Follow these steps to create this playbook and observe its operation:</p>
<ol>
<li>Start by creating a new playbook—we’ll call it <code>osvariants.yml</code>—with the following <code>Play</code> definition. It will also contain a single task, as shown:<pre class="source-code">
---
- name: Play to demonstrate group_by module
  hosts: all
  tasks:
  - name: Create inventory groups based on host facts
    group_by:
      key: os_{{ ansible_facts['distribution'] }}</pre></li> </ol>
<p>The playbook structure will be, by now, incredibly familiar to you. However, the use of the <code>group_by</code> module is new. It dynamically creates new inventory groups based on the key that we specify—in this example, we are creating groups based on a key comprising the <code>os_</code> fixed string, followed by the OS distribution fact obtained from the <code>Gathering Facts</code> stage. The original inventory group structure is preserved and unmodified, but all the hosts are also added to the newly created groups according to their facts.</p>
<p>So, the two servers in our simple inventory remain in the <code>app</code> group, but if they are based on Ubuntu, they will be added to a newly created inventory group called <code>os_Ubuntu</code>. Similarly, if they are based on CentOS, they will be added to a group called <code>os_CentOS</code>.</p>
<ol>
<li value="2">Armed<a id="_idIndexMarker511"/> with this information, we can go ahead and create additional plays based on the newly created groups. Let’s add the following <code>Play</code> definition to the same playbook file to install Apache on CentOS:<pre class="source-code">
- name: Play to install Apache on CentOS
  hosts: os_CentOS
  become: true
  tasks:
    - name: Install Apache on CentOS
      yum:
        name: httpd
        state: present</pre></li> </ol>
<p>This is a perfectly normal <code>Play</code> definition that uses the <code>yum</code> module to install the <code>httpd</code> package (as required on CentOS). The only thing that differentiates it from our earlier work is the <code>hosts</code> definition at the top of the play. This uses the newly created inventory group created by the <code>group_by</code> module in the first play.</p>
<ol>
<li value="3">Similarly, we can add a third <code>Play</code> definition—this time, for installing the <code>apache2</code> package on Ubuntu using the <code>apt</code> module:<pre class="source-code">
- name: Play to install Apache on Ubuntu
  hosts: os_Ubuntu
  become: true
  tasks:
    - name: Install Apache on Ubuntu
    apt:
      name: apache2
      state: present</pre></li> <li>If our <a id="_idIndexMarker512"/>environment is based on CentOS servers and we run this playbook, the results are as follows:<pre class="source-code">
<strong class="bold">$ ansible-playbook -i hosts osvariants.yml</strong>
<strong class="bold">PLAY [Play to demonstrate group_by module] *************************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [app02.dev.example.com]</strong>
<strong class="bold">ok: [app01.dev.example.com]</strong>
<strong class="bold">TASK [Create inventory groups based on host facts] *****************************</strong>
<strong class="bold">ok: [app01.dev.example.com]</strong>
<strong class="bold">ok: [app02.dev.example.com]</strong>
<strong class="bold">PLAY [Play to install Apache on CentOS] ****************************************</strong>
<strong class="bold">TASK [Gathering Facts] *********************************************************</strong>
<strong class="bold">ok: [app01.dev.example.com]</strong>
<strong class="bold">ok: [app02.dev.example.com]</strong>
<strong class="bold">TASK [Install Apache on CentOS] ************************************************</strong>
<strong class="bold">changed: [app02.dev.example.com]</strong>
<strong class="bold">changed: [app01.dev.example.com]</strong>
<strong class="bold">[WARNING]: Could not match supplied host pattern, ignoring: os_Ubuntu</strong>
<strong class="bold">PLAY [Play to install Apache on Ubuntu] ****************************************</strong>
<strong class="bold">skipping: no hosts matched</strong>
<strong class="bold">PLAY RECAP *********************************************************************</strong>
<strong class="bold">app01.dev.example.com : ok=4 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong>
<strong class="bold">app02.dev.example.com : ok=4 changed=2 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</strong></pre></li> </ol>
<p>Notice how the task <a id="_idIndexMarker513"/>to install Apache on CentOS was run. It was run this way because the <code>group_by</code> module created a group called <code>os_CentOS</code> and our second play only runs on hosts in the group called <code>os_CentOS</code>. As there were no servers running on Ubuntu in the inventory, the <code>os_Ubuntu</code> group was never created and so the third play does not run. We receive a warning about the fact that there is no host pattern that matches <code>os_Ubuntu</code>, but the playbook does not fail—it simply skips this play.</p>
<p>We provided this example to show you another way of managing the inevitable variance in OS types that you will come across in your automation coding. At the end of the day, it is up to you to choose the coding style most appropriate to you. You can make use of the <code>group_by</code> module, as detailed here, or write your tasks in blocks and add a <code>when</code> clause to the blocks so that they only run when a certain fact-based condition is met (for example, the OS distribution is CentOS)—or perhaps even a combination of the two. The choice is ultimately yours, and these different examples are provided to empower you with multiple <a id="_idIndexMarker514"/>options that you can choose between to create the best possible solution for your scenario.</p>
<p>Finally, let’s round off this chapter with a look at portin<a id="_idTextAnchor366"/>g<a id="_idTextAnchor367"/> your automation code between Ansible versions.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor368"/>Porting between Ansible versions</h1>
<p>Ansible is a<a id="_idIndexMarker515"/> fast-moving project, and with releases and<a id="_idIndexMarker516"/> new features added, new modules (and module enhancements) are released and the inevitable bugs that come with the software are fixed. There is no doubt that you will end up writing your code against one version of Ansible only to need to run it on a newer version again at some point. By way of example, when we started writing the second edition, the current release of Ansible was 2.15.</p>
<p>Often, you will find that your code from an earlier version <em class="italic">just about works</em> when you upgrade it, but this isn’t always a given. Modules are sometimes deprecated (although usually not without warning) and features do change. You can find more details on the 2.15 release notes here: <a href="https://github.com/ansible/ansible/blob/v2.15.2/changelogs/CHANGELOG-v2.15.rst">https://github.com/ansible/ansible/blob/v2.15.2/changelogs/CHANGELOG-v2.15.rst</a>.</p>
<p>So, the question remains—how can you ensure that your playbooks, roles, modules, and plugins still work when you update your Ansible installation?</p>
<p>The first part of the answer is to establish which version of Ansible you are starting from. For example, let’s say you are preparing for the release of Ansible 2.10. If you query the <a id="_idIndexMarker517"/>version of Ansible you already <a id="_idIndexMarker518"/>have installed and see something like the following, then you know you are starting from Ansible release 2.15.0:</p>
<pre class="console">
$ ansible [core 2.15.0]
  config file = None
  configured module search path = ['/Users/danieloh/Library/Python/3.11/bin/plugins/modules', '/usr/share/ansible/plugins/modules']
  ansible python module location = /Users/danieloh/Library/Python/3.11/lib/python/site-packages/ansible
  ansible collection location =
/Users/danieloh/Library/Python/3.11/bin/collections:/usr/share/ansible/collections
  executable location = /Users/danieloh/Library/Python/3.11/bin/ansible
  python version = 3.11.3 (main, Apr  7 2023, 20:13:31) [Clang 14.0.0 (clang-1400.0.29.202)] (/opt/homebrew/opt/python@3.11/bin/python3.11)
  jinja version = 3.1.2
 libyaml = True</pre> <p>So, your first port of call should be to review the porting guide for the Ansible release; a porting guide is normally written for every major release (such as 2.10, 8, and so on). Note that Ansible 8 includes Ansible Core 2.15.</p>
<p>The guide for Ansible 8 can be found at <a href="https://docs.ansible.com/ansible/latest/porting_guides/porting_guide_8.xhtml">https://docs.ansible.com/ansible/latest/porting_guides/porting_guide_8.xhtml</a>.</p>
<p>If we review this document, we can see that there are a number of changes coming—whether they are significant to you really depends on the code you are running. For example, if we review the <em class="italic">Added Collections</em> section of the guide, we can see that the <code>grafana.grafana</code> (version <code>2.0.0</code>) collection has been added.</p>
<p>As seen in the<a id="_idIndexMarker519"/> preceding link, there are several <a id="_idIndexMarker520"/>known issues in the eight releases of Ansible. To that end, it is also important to note that the porting guides are written from the perspective of an upgrade from the previous major release. If you query your Ansible version and it returns the following, you are porting from Ansible 2.8:</p>
<pre class="console">
$ ansible --version
ansible 2.8.4
 config file = /etc/ansible/ansible.cfg
 configured module search path = [u'/home/james/.ansible/plugins/modules', u'/usr/share/ansible/plugins/modules']
 ansible python module location = /usr/lib/python2.7/site-packages/ansible
 executable location = /usr/bin/ansible
 python version = 2.7.5 (default, Aug 7 2019, 00:51:29) [GCC 4.8.5 20150623 (Red Hat 4.8.5-39)]</pre> <p>If you move straight to Ansible 8 (Core 2.15), then you need to review the porting guides for both 2.9 (which covers the changes required to your code between releases 2.8 and 2.9) and 2.10 (which covers the changes required to upgrade from 2.9 to 2.10). An index of all the porting guides can be found on the official Ansible website at <a href="https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.xhtml">https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.xhtml</a>.</p>
<p>Another great source of information, especially more fine-grained information, on the changes between releases is the changelogs. These are released and updated for every minor release and can currently be found in the official Ansible GitHub repository on the <code>stable</code> branch for the release you wish to query. For example, if you wish to review all the changelogs for Ansible 2.15, you would need to go to <a href="https://github.com/ansible/ansible/blob/stable-2.15/changelogs/CHANGELOG-v2.15.rst">https://github.com/ansible/ansible/blob/stable-2.15/changelogs/CHANGELOG-v2.15.rst</a>.</p>
<p>The trick to<a id="_idIndexMarker521"/> porting code between Ansible<a id="_idIndexMarker522"/> releases (if, indeed, you can call it a trick) is simply to read the excellent documentation released by the Ansible project team. A lot of effort goes into creating this documentation, so you are advised to make good use of it. That concludes our look at the best practices for working wit<a id="_idTextAnchor369"/>h<a id="_idTextAnchor370"/> Ansible. We hope you have found this chapter valuable.</p>
<h1 id="_idParaDest-125"><a id="_idTextAnchor371"/>Summary</h1>
<p>Ansible automation projects often start out small, but as people come to realize the power and simplicity of Ansible, both the code and the inventories tend to grow at an exponential pace (at least in my experience). It is important that in the push for greater automation, the Ansible automation code and the infrastructure itself don’t become another headache. By embedding a few good practices early on and applying them consistently throughout your automation journey with Ansible, you will find that managing your Ansible automation is easy and is a true benefit to your technology infrastructure.</p>
<p>In this chapter, you learned new ways of differentiating environments by OS type, as well as more about variable precedence and how to leverage it when working with host and group variables. You then explored the importance of the top-level playbook, before looking at how to make use of version control tools to manage your automation code. Finally, you explored the new techniques for creating single playbooks that will manage servers of different OS versions and distributions, before finally looking at the important topic of porting your code to new Ansible versions.</p>
<p>In the next chapter, we will look at some of the more advanced ways that you can use Ansible to take care of some <a id="_idTextAnchor372"/>s<a id="_idTextAnchor373"/>pecial cases that may arise on your automation journey.</p>
<h1 id="_idParaDest-126"><a id="_idTextAnchor374"/>Questions</h1>
<ol>
<li>What is a safe and easy way to manage (that is, modify, fix, and create) code changes continuously and share them with others?<ol><li>Playbook revision</li><li>Task history</li><li>Ad hoc creation</li><li>With a Git repository</li><li>Log management</li></ol></li>
<li>True or false? Ansible Galaxy supports sharing roles with other users from a central, community-supported repository:<ol><li>True</li><li>False</li></ol></li>
<li>True or false? Ansible modules are guaranteed to be<a id="_idTextAnchor375"/> <a id="_idTextAnchor376"/>available in all future releases of Ansible:<ol><li>True</li><li>False</li></ol></li>
</ol>
<h1 id="_idParaDest-127"><a id="_idTextAnchor377"/>Further reading</h1>
<p>Manage multiple repositories, versions, or tasks by creating branches and tags to control multiple versions effectively. Refer to the following links for more details:</p>
<ul>
<li>How to use Git tagging: <a href="https://git-scm.com/book/en/v2/Git-Basics-Tagging%0D">https://git-scm.com/book/en/v2/Git-Basics-Tagging</a></li>
<li>How to use Git branches: <a href="https://git-scm.com/docs/git-branch">https://git-scm.com/docs/git-branch</a></li>
</ul>
</div>
</div></body></html>