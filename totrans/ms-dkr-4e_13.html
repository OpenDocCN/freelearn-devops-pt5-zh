<html><head></head><body><div><div><p id="_idParaDest-239" class="chapter-number"><a id="_idTextAnchor626"/><em class="italic">Chapter 13</em></p>
			<h1 id="_idParaDest-240"><a id="_idTextAnchor627"/>Running Kubernetes in Public Clouds</h1>
			<p>In the previous two chapters, we looked at the various ways that we can create, configure, and interact with Kubernetes clusters on our local machines.</p>
			<p>Now it is time to take our Kubernetes journey into the cloud by looking at what is involved in launching, configuring, and using Kubernetes in the following public cloud providers using both the web portals from each provider and also their command-line tools:</p>
			<ul>
				<li><strong class="bold"><a id="_idTextAnchor628"/><a id="_idTextAnchor629"/>Microsoft Azure <a id="_idTextAnchor630"/><a id="_idTextAnchor631"/>Kubernetes Service</strong> (<strong class="bold">AKS</strong>)</li>
				<li><strong class="bold"><a id="_idTextAnchor632"/><a id="_idTextAnchor633"/>Google Kubernetes Engine</strong> (<strong class="bold">GKE</strong>)</li>
				<li><strong class="bold"><a id="_idTextAnchor634"/><a id="_idTextAnchor635"/>Amazon Elastic Kubernetes Service</strong> (<strong class="bold">EKS</strong>)</li>
				<li><strong class="bold"><a id="_idTextAnchor636"/><a id="_idTextAnchor637"/>DigitalOcean <a id="_idTextAnchor638"/><a id="_idTextAnchor639"/>Kubernetes<a id="_idTextAnchor640"/><a id="_idTextAnchor641"/><a id="_idTextAnchor642"/><a id="_idTextAnchor643"/></strong></li>
			</ul>
			<h1 id="_idParaDest-241"><a id="_idTextAnchor644"/>Technical requirements</h1>
			<p>This chapter assumes that you have access to one or all of the cloud providers that we will be covering. As such, please be aware that launching these services, depending on your account, will incur costs. You should also remember to remove any resources once you have finished with them or that you understand the costs if you choose to leave them running for any length of time.</p>
			<p>As with the previous chapters, I will be using my preferred operating system, which is macOS. As such, some of the supporting commands, which will be few and far between, may only apply to macOS.<a id="_idTextAnchor645"/><a id="_idTextAnchor646"/></p>
			<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/336J7dE">https://bit.ly/336J7dE</a></p>
			<h1 id="_idParaDest-242"><a id="_idTextAnchor647"/><a id="_idTextAnchor648"/>Microsoft <a id="_idTextAnchor649"/><a id="_idTextAnchor650"/>Azure Kubernetes Service (<a id="_idTextAnchor651"/><a id="_idTextAnchor652"/>AKS)</h1>
			<p>Microsoft<a id="_idIndexMarker950"/> has long been a supporter of running container workloads in Microsoft Azure. Originally, Microsoft started by offering the<a id="_idTextAnchor653"/><a id="_idTextAnchor654"/> Azure Container Service, which supported three different container orchestrators: Kubernetes,<a id="_idTextAnchor655"/><a id="_idTextAnchor656"/><a id="_idTextAnchor657"/><a id="_idTextAnchor658"/> Mesosphere DC/OS, and Docker Swarm.</p>
			<p>However, in October 2017, Microsoft announced that they would be replacing Azure Container Service with the newly developed Azure Kubernetes Service—this, as you may already have guessed, dropped support for Mesosphere DC/OS and Docker Swarm. </p>
			<p>Since then, the service, which is a CNCF-certified Kubernetes hosting platform, has come on leaps and bounds, with a recent development being the general availability of Windows container support.</p>
			<p>Rather than go into<a id="_idIndexMarker951"/> any more detail on this subject, let's get on and launch an AKS cluster. We will be covering two ways of doing this: using th<a id="_idTextAnchor659"/><a id="_idTextAnchor660"/>e Azure web portal and setting it up from your local machine using the Azure command-line tools. Let's start with the Azure web portal<a id="_idTextAnchor661"/><a id="_idTextAnchor662"/><a id="_idTextAnchor663"/>.</p>
			<h2 id="_idParaDest-243"><a id="_idTextAnchor664"/>Launching a cluster using the web portal</h2>
			<p>To<a id="_idIndexMarker952"/> start with, you need to be logged into the Azure web portal, which can be found at <a href="https://portal.azure.com/">https://portal.azure.com/</a>. Once logged in, enter <code>AKS</code> in the top search bar and click on the <strong class="bold">Kubernetes services</strong> item in the <strong class="bold">Services</strong> section of the search results.</p>
			<p>Once the page has loaded, you will be presented with a screen that looks like the following:</p>
			<div><div><img src="img/image_001.jpg" alt="Figure 13.1: Ready to create the cluster&#13;&#10;" width="746" height="487"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1: Ready to create the cluster</p>
			<p>Most of you will have already guessed what the next step in launching our AKS cluster is going to be. That's right: click on the <strong class="bold">+ Add</strong> button and select <strong class="bold">Add Kubernetes cluster</strong>. There are seven sections that we are going to be working through to launch our cluster, listed as<a id="_idIndexMarker953"/> follows: </p>
			<ul>
				<li><strong class="bold">Basics</strong></li>
				<li><strong class="bold">Node pools</strong></li>
				<li><strong class="bold">Authentication</strong></li>
				<li><strong class="bold">Networki<a id="_idTextAnchor665"/><a id="_idTextAnchor666"/>ng</strong></li>
				<li><strong class="bold">Integrations</strong></li>
				<li><strong class="bold">Tags</strong></li>
				<li><strong class="bold">Review + create</strong></li>
			</ul>
			<p>Let's start with the <strong class="bold">Basics</strong>. Here, you will be asked for several pieces of information, beginning with the <strong class="bold">Project details</strong>. Here, we need to define which <strong class="bold">Subscription</strong> and <strong class="bold">Resource Group</strong> should be used.</p>
			<p>Choose your required subscription and then click on the <strong class="bold">Create new</strong> link under <strong class="bold">Resource Group</strong>. Enter the name of the resource group you would like your cluster to be placed—I have called mi<a id="_idTextAnchor667"/><a id="_idTextAnchor668"/><a id="_idTextAnchor669"/>ne <strong class="bold">mastering-docker-aks-rg</strong>.</p>
			<p>Once those two bits of information have been entered, we can move on to the <code>1.15.10</code> at the time of writing).</p>
			<p>The last piece of basic information is for the <strong class="bold">Primary node pool</strong>. Here, we can define the <strong class="bold">Node size</strong> and the <strong class="bold">Node count</strong>. By default, these are set <a id="_idTextAnchor670"/><a id="_idTextAnchor671"/>to <strong class="bold">Standard DS2 v2</strong> and <strong class="bold">3</strong>—for testing purposes, let's leave these as their default settings. To progress to the next step, click on the <strong class="bold">Next: Node pools &gt;</strong> button.</p>
			<p>On the <strong class="bold">Node pools</strong> screen, we can add more pools—for example, if you wanted to run a Windows host pool alongside the Linux one that we are launching, then you can click on the <strong class="bold">+ Add node pool</strong> button.</p>
			<p>Here, you will be asked the following:</p>
			<ul>
				<li><strong class="bold">Node pool name</strong>: Name the new node pool.</li>
				<li><strong class="bold">OS type</strong>: The underlying operating system that you want the new node pool to use. You have the choice of Linux or Windows.</li>
				<li><strong class="bold">Node size</strong>: The virtual machine size that the nodes in the new node pool should be.</li>
				<li><strong class="bold">Node count</strong>: The number of nodes that you want in the pool.</li>
			</ul>
			<p>As we are launching a <a id="_idIndexMarker954"/>test cluster, we do not need any additional node pools, so let's move on to the next set of options.</p>
			<p><strong class="bold">Virtual nodes</strong> allow you to use <strong class="bold">Azure Container Instances</strong>, which we looked at in <a href="B15659_10_Final_JM_ePub.xhtml#_idTextAnchor277"><em class="italic">Chapter 10</em></a>, <em class="italic">Running Docker in Public Clouds</em>. Leave this setting as <strong class="bold">Disabled</strong>.</p>
			<p>Setting <strong class="bold">VM scale sets</strong> as <strong class="bold">Enabled</strong> will allow us to scale our cluster up and down, so let's click on the <strong class="bold">Ne<a id="_idTextAnchor672"/><a id="_idTextAnchor673"/>xt: Authentication &gt;</strong> button.</p>
			<p>The <strong class="bold">Authentication</strong> settings allow you to configure how the Kubernetes cluster will be able to interact with and even launch other Azure services. For our cluster, leave these at their defaults and click on the <strong class="bold">Next: Networking &gt;</strong> button.</p>
			<p>The <strong class="bold">Networking</strong> page has two different sets of options, the first being the <strong class="bold">Network</strong><strong class="bold"> </strong><strong class="bold">Configuration</strong>. Here, we have the option of choosing an existing <strong class="bold">Virtual network</strong> or creating one—for ease of use, let's stick with the defaults, which are already prefilled in for us, and move on to the <strong class="bold">Network Settings</strong>.</p>
			<p>Here, we can again stick with the defaults, meaning that the only piece of information we need to provide is the <strong class="bold">DNS name prefix</strong>—I used <strong class="bold">mastering-docker-aks</strong>.</p>
			<p>Clicking on <strong class="bold">Next: Integrations &gt;</strong> will take you to the options, where you can connect your AKS cluster to an <strong class="bold">Azure Container Registry</strong>, which we discussed in <a href="B15659_03_Final_JM_ePub.xhtml#_idTextAnchor109"><em class="italic">Chapter 3</em></a><em class="italic">, Storing &amp; Distributing Images</em>. But as we are not using a system-assigned managed identity, this option is not available. The other integration we can configure is <strong class="bold">Azure Monitor</strong>. Leave these settings at their defaults, as we want a <strong class="bold">Log Analytics workspace</strong> set up for us.</p>
			<p>As our cluster is only temporary, you can click on the <strong class="bold">Review + Create</strong> button rather than adding the <strong class="bold">Tags</strong>.</p>
			<p>The first thing that happens is that your configuration is validated. If there are any problems, you will not be allowed to proceed until the problem is fixed. If everything goes as planned, then you should be presented with something that looks like the following screen:</p>
			<div><div><img src="img/image_002.jpg" alt="Figure 13.2: A validated configuration &#13;&#10;" width="672" height="624"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2: A validated configuration </p>
			<p>Once validated, click <a id="_idIndexMarker955"/>on the <strong class="bold">Create</strong> button. Now would be a good time to grab a drink as a cluster could take anywhere from 10 to 20 minutes to deploy. Once deployed, you will see the following screen:</p>
			<div><div><img src="img/image_003.jpg" alt="Figure 13.3: The deployment has completed&#13;&#10;" width="759" height="420"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3: The deployment has completed</p>
			<p>Clicking on <code>kubectl</code> instance.</p>
			<p>As Microsoft provides a shell built into Azure portal with both the Azure command-line tools and kubectl preinstalled; because we launched the cluster through the portal, we will use that. </p>
			<p>Click on the Cloud Shell icon, which is the first of the icons in the top right of the screen after the search bar (it has <strong class="bold">&gt;_</strong> on it). If you have used Cloud Shell before, then you will be logged straight in. If not, then follow the on-screen prompts.</p>
			<p>There are two different flavors of Cloud Shell: <strong class="bold">Bash</strong> and <strong class="bold">PowerShell</strong>. For our purposes, you need to make sure you are using <strong class="bold">Bash</strong>. </p>
			<p>Once you are at <a id="_idIndexMarker956"/>Command Prompt, enter the following command, making sure that you update the resource group and cluster name if you have used different values to the ones I used:</p>
			<pre>$ az aks get-credentials --resource-group mastering-docker-
aks-rg --name mastering-docker-aks</pre>
			<p>Once you have run the command, you can test the connectivity to the cluster by running the followi<a id="_idTextAnchor674"/><a id="_idTextAnchor675"/><a id="_idTextAnchor676"/>ng:</p>
			<pre>$ kubectl get nodes
$ kubectl get namespaces</pre>
			<p>This should return three nodes, each with the version of Kubernetes that we selected when we first went to configure our cluster:</p>
			<div><div><img src="img/image_004.jpg" alt="Figure 13.4: Connecting kubectl to our AKS cluster using Cloud Shell&#13;&#10;" width="914" height="450"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4: Connecting kubectl to our AKS cluster using Cloud Shell</p>
			<p>Now we have our cluster up and running, you can skip the next part of this section where we launch the<a id="_idIndexMarker957"/> cluster using the Azure command-line tools and go straight to launching an applicatio<a id="_idTextAnchor677"/><a id="_idTextAnchor678"/><a id="_idTextAnchor679"/>n. </p>
			<h2 id="_idParaDest-244"><a id="_idTextAnchor680"/>Launching a cluster using the command-line tools</h2>
			<p>An alternative to<a id="_idIndexMarker958"/> launching the cluster through the Azure web portal is to use the Azure command-line tool. If you don't already have it installed, then you can use the following instructions, starting with macOS:</p>
			<pre>$ brew install azure-cli</pre>
			<p>Windows users can open a PowerShell prompt as the Administrator user and run the following:</p>
			<pre>$ Invoke-WebRequest -Uri https://aka.ms/installazurecliwindows
 -OutFile .\AzureCLI.msi; Start-Process msiexec.exe -Wait 
-ArgumentList '/I AzureCLI.msi /quiet'; rm .\AzureCLI.msi</pre>
			<p>Linux users using Debian-based machines can run the following:</p>
			<pre>$ curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash</pre>
			<p>Linux users running Red-Hat-based operating systems can run the following:</p>
			<pre>$ sudo rpm --import https://packages.microsoft.com/keys/microsoft.asc
$ sudo sh -c 'echo -e '[azure-cli]
name=Azure CLI
baseurl=https://packages.microsoft.com/yumrepos/azure-cli
enabled=1
gpgcheck=1
gpgkey=https://packages.microsoft.com/keys/microsoft.asc' &gt; /
etc/yum.repos.d/azure-cli.repo'
$ sudo yum install azure-cli</pre>
			<p>Once you have the Azure CLI package installed, the first command you should run is the following:</p>
			<pre>$ az login</pre>
			<p>This will prompt you to log in to your Azure account. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Please make sure that the account you are logging in to has the subscription that you want to launch your resources in as the default subscription—if it doesn't, go to <a href="https://docs.microsoft.com/en-us/cli/azure/manage-azure-subscriptions-azure-cli">https://docs.microsoft.com/en-us/cli/azure/manage-azure-subscriptions-azure-cli</a> for details on how to change the active subscription.</p>
			<p>Now that we have the<a id="_idIndexMarker959"/> Azure command-line tools installed and configured, we can launch our cluster. For macOS and Linux users, we can set some environment variables for values that we will be using through the cluster creation. </p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Windows users should replace the variables in the commands used to launch the cluster with the corresponding values from the following four variables.</p>
			<p>These are the same values that we used in the last section, where we launched our cluster using the Azure web port<a id="_idTextAnchor681"/><a id="_idTextAnchor682"/>al:</p>
			<pre>$ AKSLOCATION=eas<a id="_idTextAnchor683"/><a id="_idTextAnchor684"/>tus
$ AKSRG=mastering-docker-aks<a id="_idTextAnchor685"/><a id="_idTextAnchor686"/>-rg
$ AKSCLUSTER=mastering-docker-<a id="_idTextAnchor687"/><a id="_idTextAnchor688"/>aks
$ AKSNUMNODES=3</pre>
			<p>The first step in launching the cluster is to create the resource group. To do this, run  the followi<a id="_idTextAnchor689"/><a id="_idTextAnchor690"/>ng:</p>
			<pre>$ az group create --name $AKSRG --location $AKSLOCATION</pre>
			<p>This should return a JSON file where the provisioning state should be <code>Succeeded</code>. Once the resource group has been created, we can launch our cluster by running the following comma<a id="_idTextAnchor691"/><a id="_idTextAnchor692"/>nd:</p>
			<pre>$ az aks create \
    --resource-group $AKSRG \
    --name $AKSCLUSTER \
    --node-count $AKSNUMNODES \
    --enable-addons monitoring \
    --generate-ssh-keys</pre>
			<p>While the cluster is<a id="_idIndexMarker960"/> launching, you will see a screen that looks like the following:</p>
			<div><div><img src="img/image_005.jpg" alt=" Figure 13.5: Launching the cluster using the Azure CLI&#13;&#10;" width="875" height="226"/>
				</div>
			</div>
			<p class="figure-caption"> Figure 13.5: Launching the cluster using the Azure CLI</p>
			<p>Just like when the cluster was launched using the Azure web portal, it will take between 10 and 20 minutes to complete, so don't worry too much if you see the preceding output for a while—it just takes a little time.</p>
			<p>Once completed, the final step is the same as when we launched the cluster using the Azure web portal. We need to configure kubectl to point towards the new launching cluster. To do this, run the following comma<a id="_idTextAnchor693"/><a id="_idTextAnchor694"/><a id="_idTextAnchor695"/><a id="_idTextAnchor696"/>nd:</p>
			<pre>$ az aks get-credentials --resource-group $AKSRG --name 
$AKSCLUSTER</pre>
			<p>Once the configuration has been merged, you can run the following commands to check the connectivity with the cluster:</p>
			<pre>$ kubectl get nodes
$ kubectl get namespaces</pre>
			<p>This should return something similar to the following output:</p>
			<div><div><img src="img/image_006.jpg" alt="Figure 13.6: Checking the cluster connectivity using kubectl&#13;&#10;" width="1094" height="419"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6: Checking the cluster connectivity using kubectl</p>
			<p>We should now <a id="_idIndexMarker961"/>have an AKS cluster in the same state as if it were launched using the Azure web portal, which means that we can now launch an applic<a id="_idTextAnchor697"/><a id="_idTextAnchor698"/>ation.</p>
			<h2 id="_idParaDest-245"><a id="_idTextAnchor699"/>Launching an application</h2>
			<p>As we are no longer<a id="_idIndexMarker962"/> using our local machine to run Kubernetes, we can launch an application that is a little more resource-intensive. For this, we are going to be using the microservices demo created and maintained by Weave.</p>
			<p>To launch the application, you simply need to run the following commands:</p>
			<pre>$ kubectl create namespace sock-shop
$ kubectl -n sock-shop apply -f 'https://github.com/
microservices-demo/microservices-demo/blob/master/deploy/
kubernetes/complete-demo.yaml?raw=true'</pre>
			<p>This will create a nam<a id="_idTextAnchor700"/>espace <a id="_idIndexMarker963"/>called <strong class="bold">sock-shop</strong> and then the resource that is used to make up the application, which is an e-commerce site selling socks.</p>
			<p>After a minute or two, you can run the following command to view the status of the pods:</p>
			<pre>$ kubectl -n sock-shop get pods</pre>
			<p>This should display something like the following output:</p>
			<div><div><img src="img/image_007.jpg" alt="Figure 13.7: Checking the status of the pods&#13;&#10;" width="836" height="474"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7: Checking the status of the pods</p>
			<p>Once all of the pods are running, you can check the status of the services by running the following:</p>
			<pre>$ kubectl -n sock-shop get services</pre>
			<p>Again, you should see <a id="_idIndexMarker964"/>something like the following:</p>
			<div><div><img src="img/image_008.jpg" alt="Figure 13.8: Checking the status of the services&#13;&#10;" width="969" height="474"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8: Checking the status of the services</p>
			<p>Now that the application has been deployed, we need to expose it so that we can access it. To do this, run the following command:</p>
			<pre>$ kubectl -n sock-shop expose deployment front-end 
--type=LoadBalancer --name=front-end-lb</pre>
			<p>Once exposed, you can run the following command to get information on the endpoint:</p>
			<pre>$ kubectl -n sock-shop describe services front-end-lb</pre>
			<p>In the output, you are<a id="_idIndexMarker965"/> after the <code>LoadBalancer Ingress</code> and <code>Port</code>. See the following screenshot for an example output:</p>
			<div><div><img src="img/image_009.jpg" alt="Figure 13.9: Getting information on the exposed service&#13;&#10;" width="1006" height="611"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9: Getting information on the exposed service</p>
			<p>Entering the <code>LoadBalancer Ingress</code> IP and <code>Port</code>—which for me was <a href="http://52.191.99.154:8079/">http://52.191.99.154:8079/</a>—into a browser should open the store:</p>
			<div><div><img src="img/image_010.jpg" alt="Figure 13.10 – The Sock Shop application&#13;&#10;" width="1039" height="597"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10 – The Sock Shop application</p>
			<p>Click around the <a id="_idIndexMarker966"/>application—stick some socks in your basket, refresh pages, and so on. We are now going to take a look at the cluster in the Azure web p<a id="_idTextAnchor701"/><a id="_idTextAnchor702"/>ortal.</p>
			<h2 id="_idParaDest-246"><a id="_idTextAnchor703"/>Cluster information</h2>
			<p>If you log in to <a id="_idIndexMarker967"/>the Azure web portal at <a href="https://portal.azure.com/">https://portal.azure.com/</a> and then search for the name of your cluster in the search bar at the top of the page, you should be greeted with a page that looks like the following:</p>
			<div><div><img src="img/image_011.jpg" alt="Figure 13.11 – Viewing the cluster in the Azure web portal&#13;&#10;" width="767" height="278"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.11 – Viewing the cluster in the Azure web portal</p>
			<p>If you then click on the <strong class="bold">Monitor container</strong> button, you will be taken to a <strong class="bold">Cluster</strong> overview. Once there, click on <strong class="bold">Containers</strong>. Adding a filter for the <strong class="bold">sock-shop</strong> namespace will just select the containers that are running in the pods for our application. Selecting one and then clicking the <strong class="bold">View live data (preview)</strong> button will stream the logs from the container to the page:</p>
			<div><div><img src="img/image_012.jpg" alt="Figure 13.12 – Viewing the logs from the frontend container in the Azure web portal&#13;&#10;" width="838" height="417"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.12 – Viewing the logs from the frontend container in the Azure web p<a id="_idTextAnchor704"/><a id="_idTextAnchor705"/><a id="_idTextAnchor706"/><a id="_idTextAnchor707"/>ortal</p>
			<p>I would recommend <a id="_idIndexMarker968"/>having a click around some of the other tabs and options to get an idea of what else you can do with AKS.</p>
			<p>Once you have finished with your AKS cluster, I recommend removing all of the resources created either through the Azure web portal or Azure CLI by deleting the resource groups. To do this,<a id="_idTextAnchor708"/><a id="_idTextAnchor709"/> enter <code>Resource Groups</code> in the top search box and select the resource group related to your cluster. For example, as I launched my cluster, I have three resource groups, which I have highlighted in the following screenshot:</p>
			<div><div><img src="img/image_013.jpg" alt="Figure 13.13 – Finding the resource groups to delete&#13;&#10;" width="503" height="305"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.13 – Finding the resource groups to delete</p>
			<p>To remove them, click on the resource group name, double-check the resources in there and then if you are happy, they contain just the resources for your test cluster click on the <strong class="bold">Delete resource group</strong> button and follow the on-screen instruc<a id="_idTextAnchor710"/><a id="_idTextAnchor711"/>tions.</p>
			<h2 id="_idParaDest-247"><a id="_idTextAnchor712"/>Microsoft Azure Kubernetes Service summary</h2>
			<p>As I am sure you will <a id="_idIndexMarker969"/>agree, launching the cluster was quite a straightforward process using both the Azure web portal and Azure CLI. Once launched and kubectl configured to interact with the cluster, the commands that were used to launch the application were pretty much the same as the ones that we used in <a href="B15659_12_Final_JM_ePub.xhtml#_idTextAnchor394"><em class="italic">Chapter 12</em></a>, <em class="italic">Discovering other Kubernetes options</em>.</p>
			<p>The cluster that we launched would have a running cost of around $215 per month, with the only cost being for the virtual machine resource. Microsoft does not charge for the resources required for cluster management; if we want to add an uptime SLA to the cluster, we would add a further $73.00 per month.</p>
			<p>Being able to run multiple node pools with a mixture of Linux and Windows containers is a big plus point for the service, as is its integration with Azure Monitor and the Azure Container Registry service. Add to this services such as Azure DevOps and <strong class="bold">Azure Sentin<a id="_idTextAnchor713"/><a id="_idTextAnchor714"/>el for Security information and event management</strong> (<strong class="bold">SIEM</strong>), and you have quite a powerful platform.</p>
			<p>Next up, we are going to move from Microsoft Azure to Google Cloud.</p>
			<h1 id="_idParaDest-248"><a id="_idTextAnchor715"/>Google Kubernetes Engine (GKE)</h1>
			<p>The GKE, <a id="_idIndexMarker970"/>as you may have already guessed, is very tightly integrated with Google's Cloud platform. Rather than going into more detail on how Kubernetes started off life at Google, let's dive straight in and launch a cluster.</p>
			<p>Going ahead, I am assuming that you already have a Google Cloud account and a project with billing enabled.</p>
			<h2 id="_idParaDest-249"><a id="_idTextAnchor716"/>Launching a cluster using the web portal</h2>
			<p>Once<a id="_idIndexMarker971"/> you are logged into <a href="https://console.cloud.google.com/">https://console.cloud.google.com/</a>, enter Kubernetes into the search box at the top of the page and select <strong class="bold">Kubernetes Engine</strong>. If you don't have the service enabled for your project, it will automatically be enabled, and after a few seconds, you will be presented with a page that looks like the following:</p>
			<div><div><img src="img/image_014.jpg" alt="Figure 13.14 – The Kubernetes page in the Google Cloud web portal&#13;&#10;" width="876" height="471"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.14 – The Kubernetes page in the Google Cloud web portal</p>
			<p>Again, as you might have already guessed, the first step to launching the cluster is to click on the <strong class="bold">Create cluster</strong> button. You will then be presented with quite a few options; however, we<a id="_idIndexMarker972"/> are going to use the defaults, other than the <strong class="bold">Name</strong>, which I am going to change to <strong class="bold">mastering-docker-gke</strong>. Once the name has been changed, click on the <strong class="bold">Create</strong> button:</p>
			<div><div><img src="img/image_015.jpg" alt="Figure 13.15 – Entering the cluster details&#13;&#10;" width="907" height="609"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.15 – Entering the cluster details</p>
			<p>Launching the cluster will take around 10 minutes. Once it is created, you should see something like the following:</p>
			<div><div><img src="img/image_016.jpg" alt="Figure 13.16 – The cluster is ready&#13;&#10;" width="684" height="194"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.16 – The cluster is ready</p>
			<p>Like Microsoft Azure, Google Cloud has a shell built into the web interface, and the shell has <code>kubectl</code> and the <code>gcloud</code> command-line tool installed and configured. Open the shell by clicking on the <code>kubectl</code> accesses your cluster:</p>
			<pre>$ gcloud container clusters get-credentials mastering-docker-gke<a id="_idTextAnchor717"/><a id="_idTextAnchor718"/> --zone us-central1-c</pre>
			<p>Update the name and zone if you used anything other than what we set it to. Once configured, you should be able to run both of the following c<a id="_idTextAnchor719"/><a id="_idTextAnchor720"/>omm<a id="_idTextAnchor721"/><a id="_idTextAnchor722"/>ands:</p>
			<pre>$ kubectl get <a id="_idTextAnchor723"/><a id="_idTextAnchor724"/>nodes
$ kubectl get namespaces</pre>
			<p>To test the connectivity, if everything has gone as planned, you should see something like the following:</p>
			<div><div><img src="img/image_017.jpg" alt="Figure 13.17 – Connecting kubectl to our cluster&#13;&#10;" width="868" height="529"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.17 – Connecting kubectl to our cluster</p>
			<p>Launching a basic cluster using<a id="_idIndexMarker974"/> the Google Cloud web portal is a really simple process; however, using the <code>gcloud</code> CLI is just as easy.</p>
			<h2 id="_idParaDest-250"><a id="_idTextAnchor725"/>Launching a cluster using the command-line tools</h2>
			<p>The <code>gcloud</code> command is<a id="_idIndexMarker975"/> provided by the Google Cloud SDK package. To install this on macOS using Homebrew and Cask, run the following command:</p>
			<pre>$ brew cask install google-cloud-sdk</pre>
			<p>If you are running Windows, then you can download the installer from <a href="https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe">https://dl.google.com/dl/cloudsdk/channels/rapid/GoogleCloudSDKInstaller.exe</a>.</p>
			<p>Linux users running a Debian-based operating system need to run the following:</p>
			<pre>$ echo 'deb [signed-by=/usr/share/keyrings/cloud.google.gpg] 
http://packages.cloud.google.com/apt cloud-sdk main' | sudo tee
 -a /etc/apt/sources.list.d/google-cloud-sdk.list
$ curl https://packages.cloud.google.com/apt/doc/apt-key.gpg | 
sudo apt-key --keyring /usr/share/keyrings/cloud.google.gpg add
 -
$ sudo apt-get update &amp;&amp; sudo apt-get install google-cloud-sdk</pre>
			<p>Finally, Linux users running Red-Hat-based operating systems need to run the following:</p>
			<pre>$ sudo tee -a /etc/yum.repos.d/google-cloud-sdk.repo &lt;&lt; EOM
[google-cloud-sdk]
name=Google Cloud SDK
baseurl=https://packages.cloud.google.com/yum/repos/cloud-sdk-el7-x86_64
enabled=1
gpgcheck=1
repo_gpgcheck=1
gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg
       https://packages.cloud.google<a id="_idTextAnchor726"/>.com/yum/doc/rpm-package-
key.gpg
EOM</pre>
			<p>Once the repository file is in place, you can install the package using the following command:</p>
			<pre>$ sudo yum install google-cloud-sdk</pre>
			<p>Should you have any <a id="_idIndexMarker976"/>problems with any of the preceding commands, a link for the quick starts for each of them containing common troubleshooting tips can be found in the further reading section of this chapter.</p>
			<p>Once installed, you need to log in and then let the command-line tool know which project to use. You can do this by running the following commands:</p>
			<pre>$ gcloud auth login
$ gcloud config set project masteringdocker4</pre>
			<p>As you may have guessed, the project I am using is called <strong class="bold">masteringdocker4</strong>; you should update this to reflect your own proj<a id="_idTextAnchor727"/><a id="_idTextAnchor728"/>ect name.</p>
			<p>Now that we have <code>gcloud</code> configured, we can launch our cluster. To do this, run the following:</p>
			<pre>$ gcloud container clusters create mastering-docker-gke --num-nodes=3 --zone=us-central1-c</pre>
			<p>This will create a three-node cluster in the US Central 1c zone. Once launched, your kubectl will automatically be configured to communicate with the cluster, meaning that all you need to do is test connectivity by running the following:</p>
			<pre>$ kubectl get nodes
$ kubectl get namespaces</pre>
			<p>This should show you something similar to the following output:</p>
			<div><div><img src="img/image_018.jpg" alt="Figure 13.18 – Testing the connection to the Google Kubernetes Engine cluster&#13;&#10;" width="1165" height="364"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.18 – Testing the connection to the Google Kubernetes Engine cluster</p>
			<p>Now that we have a<a id="_idIndexMarker977"/> Google Kubernetes Engine cluster up and running, we can now launch our app<a id="_idTextAnchor729"/><a id="_idTextAnchor730"/>lication.</p>
			<h2 id="_idParaDest-251"><a id="_idTextAnchor731"/>Launching an application</h2>
			<p>As we covered<a id="_idIndexMarker978"/> the launching of the application in detail in the <em class="italic">Microsoft Azure Kubernetes Service</em> section of this chapter, we are not going to go into much detail here, other than to say that you need to run the following commands to launch the app:</p>
			<pre>$ kubectl create namespace sock-shop
$ kubectl -n sock-shop apply  -f 'https://github.com/
microservices-demo/microservices-demo/blob/master/deploy/
kubernetes/complete-demo.yaml?raw=true'</pre>
			<p>You can check the status of the pods and services by running the following:</p>
			<pre>$ kubectl -n sock-shop get pods,services</pre>
			<p>Once everything looks as if it's up and running, you can use the following:</p>
			<pre>$ kubectl -n sock-shop expose deployment front-end 
--type=LoadBalancer --name=front-end-lb </pre>
			<p>This will expose the application. Once you have entered this, you can enter the following command:</p>
			<pre>$ kubectl -n sock-shop describe services front-end-lb</pre>
			<p>As we mentioned <a id="_idIndexMarker979"/>before, to get information on the exposed service you need the <code>LoadBalancer Ingress</code> and <code>Port</code>. Stick them both in a browser (for example, I used <code>http://104.154.45.136:8079/</code>) and you should see that the Sock Shop is up a<a id="_idTextAnchor732"/><a id="_idTextAnchor733"/>nd running.</p>
			<h2 id="_idParaDest-252"><a id="_idTextAnchor734"/>Cluster information</h2>
			<p>Going back to <a id="_idIndexMarker980"/>the Google Cloud web portal and clicking on <strong class="bold">Workloads</strong> within your cluster will show you a list of the nonsystem workload. Clicking on the frontend deployment will show you something like the following:</p>
			<div><div><img src="img/image_019.jpg" alt="Figure 13.19 – Viewing the deployment details&#13;&#10;" width="804" height="533"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.19 – Viewing the deployment details</p>
			<p>Clicking on <strong class="bold">Container logs</strong>, which can be found at the bottom of the preceding screen, will take you to a page where you can view the logs being generated by the workload:</p>
			<div><div><img src="img/image_020.jpg" alt="Figure 13.20 – Viewing the logs for the frontend deployment&#13;&#10;" width="936" height="557"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.20 – Viewing the logs for the frontend deployment</p>
			<p>Again, spend a little time having a click around some of the other tabs and options to get an idea of what else you can do with GKE. Once you have finished spending some time getting to know GKE, you should remove all of the resources that were launched. To do this, simply select your cluster from the <strong class="bold">Clusters</strong> page of the <strong class="bold">Kubernetes</strong><strong class="bold"> </strong><strong class="bold">Engine</strong> section of the portal<a id="_idIndexMarker981"/> and then click on <strong class="bold">Delete</strong>. You will be given a warning before the cluster is removed:</p>
			<div><div><img src="img/image_021.jpg" alt="Figure 13.21 – Are you sure you want to delete the cluster?&#13;&#10;" width="661" height="244"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.21 – Are you sure you want to delete the cluster?</p>
			<p>If you are happy to proceed, then click on <strong class="bold">DELETE</strong> and give it about 1<a id="_idTextAnchor735"/><a id="_idTextAnchor736"/>0 minutes.</p>
			<h2 id="_idParaDest-253"><a id="_idTextAnchor737"/>Google Kubernetes Engine summary</h2>
			<p>I am sure that you<a id="_idIndexMarker982"/> agree that the Google Kubernetes Service is another simple service to configure, and as you must now be noticing, once the cluster is up and running, interacting with it is a consistent experience. Again, Google offers deep integration with other Google Cloud services, such as its monitoring, databases, and load-balancing services.</p>
			<p>Running the cluster at the specifications that we set up would cost around $150 per month; however, $73 of that <a id="_idTextAnchor738"/><a id="_idTextAnchor739"/>cost is the GKE cluster management fee, to run the cluster at the same specifications as the Microsoft Azure Kubernetes Service will cost around $220 per month, with the GKE cluster management fee staying the same.</p>
			<p>Both Googles and Microsoft<a id="_idIndexMarker983"/> Kubernetes offerings have been established for quite a while, so let's take a look at the last of the big three cloud providers' Kubernetes offerings and move onto Amazon <a id="_idTextAnchor740"/><a id="_idTextAnchor741"/><a id="_idTextAnchor742"/>Web Services</p>
			<h1 id="_idParaDest-254"><a id="_idTextAnchor743"/>Amazon Elastic Kubernetes Service (EKS)</h1>
			<p>The next Kubernetes service<a id="_idIndexMarker984"/> we are going to take a look at is the Amazon Elastic Container Service for Kubernetes, or Amazon EKS for short. This is the most recently launched service of the three services we have covered so far. In fact, you could say that Amazon was very late to the Kubernetes party.</p>
			<p>Unfortunately, the command-line tools for Amazon are not as user friendly as the ones we used for Microsoft Azure and Google Cloud. Because of this, we are going to be using <a id="_idTextAnchor744"/><a id="_idTextAnchor745"/>a tool called <code>eksctl</code>, which was written by Weave, the same people who created the demo store we have been using. It has been adopted by Amazon as the official command client of EKS, as opposed to the commands built into their own client.</p>
			<p>Because of this, we are going to bypass the web-based portal and concentrate on <code>eksctl,</code> which itself makes use of the AWS command-line tools.</p>
			<h2 id="_idParaDest-255"><a id="_idTextAnchor746"/>Launching a cluster using the command-line tools</h2>
			<p>Befo<a id="_idTextAnchor747"/><a id="_idTextAnchor748"/>re <a id="_idIndexMarker985"/>we install <code>eksctl</code>, we need to install the AWS command-line tools. To do this on macOS using Homebrew, run the following command:</p>
			<pre>$ brew install awscli</pre>
			<p>If you are a Windows user, then you can download the installer from <a href="https://awscli.amazonaws.com/AWSCLIV2.msi">https://awscli.amazonaws.com/AWSCLIV2.msi</a>. </p>
			<p>Finally, Linux users can run the following commands to download and install the command-line tools:</p>
			<pre>$ curl 'https://awscli.amazonaws.com/awscli-exe-linux-x86_64.
zip' -o 'awscliv2.zip'
$ unzip awscliv2.zip
$ sudo ./aws/install</pre>
			<p>Once installed, you<a id="_idIndexMarker986"/> will need to configure your credentials. Unlike the <code>az</code> and <code>gcloud</code> commands, you need to log in to the AWS web portal to do this. Details on the steps you need to take can be found at <a href="https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html">https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-files.html</a>.</p>
			<p>Once you have the AWS command-line tools installed and configured, you can proceed with installing <code>eksctl</code>, again starting with macOS and Homebrew:</p>
			<pre>$ brew tap weaveworks/tap
$ brew install weaveworks/tap/eksctl</pre>
			<p>It is recommended that Windows users use Chocolatey:</p>
			<pre>$ chocolatey install eksctl</pre>
			<p>Finally, Linux users can download the precompiled binary straight from GitHub using the following commands:</p>
			<pre>$ curl --silent --location 'https://github.com/weaveworks/
eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.
gz' | tar xz -C /tmp
$ sudo mv /tmp/eksctl /usr/local/bin</pre>
			<p>Once installed, you will be able to run the following command to create and configure <a id="_idTextAnchor749"/><a id="_idTextAnchor750"/>your cluster:</p>
			<pre>$ eksctl create cluster</pre>
			<p>Once launched, you should see something like the following, which, as you can see, is quite descriptive:</p>
			<div><div><img src="img/image_022.jpg" alt="Figure 13.22  – Launching the EKS cluster using eksctl&#13;&#10;" width="851" height="625"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.22  – Launching the EKS cluster using eksctl</p>
			<p>As part of the<a id="_idIndexMarker987"/> launch, <code>eksctl</code> will have configured your local <code>kubectl</code> context, meaning that you can run t<a id="_idTextAnchor751"/><a id="_idTextAnchor752"/>he following:</p>
			<pre>$ kubectl get nodes
$ kubectl get services</pre>
			<p>Now that we have the cluster up and running, we can launch the demo store, just like we did previously.</p>
			<h2 id="_idParaDest-256"><a id="_idTextAnchor753"/>Launching an application</h2>
			<p>You should be<a id="_idIndexMarker988"/> getting quite good at deploying the Sock Shop application now, so here is a recap of all of the co<a id="_idTextAnchor754"/><a id="_idTextAnchor755"/>mm<a id="_idTextAnchor756"/><a id="_idTextAnchor757"/>ands you need:</p>
			<pre>$ kubectl create names<a id="_idTextAnchor758"/><a id="_idTextAnchor759"/>pace sock-shop
$ kubectl -n sock-shop apply -f 'https://github.com/
microservices-demo/microservices-demo/blob/master/deploy/
kubernetes/complete-demo.<a id="_idTextAnchor760"/><a id="_idTextAnchor761"/>yaml?raw=true'
$ kubectl -n sock-shop get<a id="_idTextAnchor762"/><a id="_idTextAnchor763"/> pods,services
$ kubectl -n sock-shop expose deployment front-end 
--type=LoadBalancer --name<a id="_idTextAnchor764"/><a id="_idTextAnchor765"/>=front-end-lb 
$ kubectl -n sock-shop describe services front-end-lb</pre>
			<p>You may notice that <a id="_idIndexMarker989"/>the <strong class="bold">LoadBalancer Ingres</strong> is actually a fully qualified domain rather than an IP address:</p>
			<div><div><img src="img/image_023.jpg" alt="Figure 13.23 – Viewing details on the exposed service&#13;&#10;" width="1205" height="611"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.23 – Viewing details on the exposed service</p>
			<p>You might need to give it a few minutes for the DNS for the load balancer to update, but you should be able to use the URL and port. For my cl<a id="_idTextAnchor766"/><a id="_idTextAnchor767"/>uster, I went to http://a5fecbaee10a04cfaa19846e116081f8-624222238.eu-west-1.elb.amazonaws.com:8079 to access the Sock Shop.</p>
			<h2 id="_idParaDest-257"><a id="_idTextAnchor768"/>Cluster information</h2>
			<p>If I am honest, this section is<a id="_idIndexMarker990"/> pretty redundant as there isn't much information on the cluster exposed in the AWS web portal by default outside of the basic information on the VMs that make up the node cluster. Sure, you can enable some features in CloudWatch to start monitoring your cluster, but this is not done by default at the moment.</p>
			<p>The following command will immediately delete the cluster for you:</p>
			<pre>$ eksctl get cluster
$ eksctl delete cluster --name=extravagant-outfit-1590399495</pre>
			<p>However, I recommend double-checking for any resources left over in your AWS web portal, just to make sure <a id="_idIndexMarker991"/>you don't get any<a id="_idTextAnchor769"/><a id="_idTextAnchor770"/> une<a id="_idTextAnchor771"/><a id="_idTextAnchor772"/>xpected bills.</p>
			<h2 id="_idParaDest-258"><a id="_idTextAnchor773"/>Amazon Elastic Kubernetes Service summary</h2>
			<p>As already mentioned, the <a id="_idIndexMarker992"/>Amazon Elastic Kubernetes Service was the last of the big three public cloud providers' Kubernetes-as-a-service offerings to launch, and in my personal opinion, it is the weakest of the three offerings.</p>
			<p>While it is a CNCF-certified hosting platform, it simply doesn't feel as integrated or intuitive as the offerings from Microsoft and Google—everything just feels tacked on to the normally good AWS services; the same can also be said of the Amazon Container Service.</p>
			<p>Costwise, the instances are charged at standard EC2 rates, and there is a charge of $0.10 per hour per Kubernetes cluster.</p>
			<p>Before we finish the chapter, let's look at one more Kubernetes offering, this time from DigitalOcean.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor774"/>DigitalOcean Kubernetes</h1>
			<p>As we are nearing the <a id="_idIndexMarker993"/>end of the chapter, we are going to very quickly take a look at the Kubernetes offering from DigitalOcean, as it represents good value for money and is simple to configure. To start with, log in to your DigitalOcean web portal and under the <strong class="bold">Manage </strong>section of the right-hand menu, click on <strong class="bold">Kubernetes</strong>:</p>
			<div><div><img src="img/image_024.jpg" alt="Figure 13.24 – Details of the DigitalOcean Kubernetes offering&#13;&#10;" width="965" height="363"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.24 – Details of the DigitalOcean Kubernetes offering</p>
			<p>Clicking the <strong class="bold">Create a Kubernetes</strong> <strong class="bold">Cluster</strong> button will take you to the <strong class="bold">Create a cluster</strong> page, from there just choose a datacenter region and scroll to the bottom of the page; DigitalOcean has some<a id="_idIndexMarker994"/> great defaults so we can skim past them. Once at the bottom, click on the <strong class="bold">Create Cluster</strong> button and wait. After around five minutes, your cluster will be available:</p>
			<div><div><img src="img/image_025.jpg" alt="Figure 13.25 – Viewing the newly created DigitalOcean Kubernetes cluster&#13;&#10;" width="665" height="324"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.25 – Viewing the newly created DigitalOcean Kubernetes cluster</p>
			<p>Now that the cluster is up and running, you can click on the <code>kubectl</code> configuration for your cluster, or, if you have it installed (see the further reading section for a link), you can use the <code>doctl</code> command to download and configure your local <code>kubectl</code> to talk to your newly created cluster. </p>
			<p>The command to do this is as follows; please make sure that you update the name at the end to match that of your own cluster:</p>
			<pre>$ doctl kubernetes cluster kubeconfig save k8s-1-17-5-do-0-
nyc3-1590403077241</pre>
			<p>Once configured, you know what to do: launch the Sock Shop application using the same commands that we have been using throughout the chapter—well sort of; if you want to steam ahead and try to launch the application you would receive several errors. Go ahead and try it.</p>
			<p>The errors, which look like the following screenshot, are there because of changes to the API in the later version of Kubernetes that DigitalOcean launches by default:</p>
			<div><div><img src="img/image_026.jpg" alt="Figure 13.26 – Errors with the Sock Shop&#13;&#10;" width="1256" height="584"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.26 – Errors with the Sock Shop</p>
			<p>Never fear though—this is <a id="_idIndexMarker995"/>easily resolved. First, let's remove the namespace with the partly deployed application in it:</p>
			<pre>$ kubectl delete namespace sock-shop</pre>
			<p>Once these are removed, we need to clone the Sock Shop repository and recreate the namespace. To do this, run the f<a id="_idTextAnchor775"/><a id="_idTextAnchor776"/>ollowing command:</p>
			<pre>$ git clone https://github.com/microservices-demo/
micro<a id="_idTextAnchor777"/><a id="_idTextAnchor778"/>services-demo.git
$ kubectl create namespace sock-shop</pre>
			<p>Next, we have to change directory to the Kubernetes deployment folder, update the definition files, and then launch the application. For this, we need to r<a id="_idTextAnchor779"/><a id="_idTextAnchor780"/>un the following:</p>
			<pre>$ cd microservices-demo/<a id="_idTextAnchor781"/><a id="_idTextAnchor782"/>deploy/kubernetes
$ kubectl convert -f . | kubectl create -f -</pre>
			<p>From there, you can check the pods and services, expose the frontend, and get information on the exposed service using the following:</p>
			<pre>$ kubectl -n sock-shop get pods,services
$ kubectl -n sock-shop expose deployment front-end 
--type=LoadBalancer --name=front-end-lb 
$ kubectl -n sock-shop describe services front-end-lb</pre>
			<p>It may take a minute or two for the services to be exposed as a DigitalOcean load balancer is launched.</p>
			<p>Before we return to the DigitalOcean web portal, let's enable the advanced cluster metrics. To do this, we need to deploy another application. You can do this by running the following two commands:</p>
			<pre>$ git clone https://github.com/kubernetes/kube-state-metrics.
git
$ kubectl create -f kube-state-metrics/examples/standard/</pre>
			<p>Once installed, it will take a <a id="_idIndexMarker996"/>minute or two for the metrics to appear in the portal. You can find them by selecting your cluster and then clicking on the <strong class="bold">Insights</strong> tab:</p>
			<div><div><img src="img/image_027.jpg" alt="Figure 13.27 – Viewing details on the cluster in the DigitalOcean web portal&#13;&#10;" width="732" height="417"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.27 – Viewing details on the cluster in the DigitalOcean web portal</p>
			<p>I would recommend having a click around the DigitalOcean web portal before you remove the cluster, as I am sure you will agree that the service is quite well integrated and comes at a bargain price. The three-node cluster we launched would cost just $30 per month to run!</p>
			<p>You can terminate the cluster through the web portal. Also, make sure that you also remove the load balancer as this will remain once the cluster has been terminated to avoid unexpected costs at the end of the month.</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor783"/>Summary</h1>
			<p>In this chapter, we looked at launching Kubernetes clusters in various clouds and running the same demo application in all of them. I am sure that by the end of the chapter you were quite bored of launching the same application over and over again; however, that was the point.</p>
			<p>We have looked at four very different and traditionally incompatible cloud providers and deployed the same application using the same tools and commands across all four of them. Admittedly, we had to make some allowances for the different versions of Kubernetes being used, but for the most part, we didn't have to make any provider-specific allowances once we started working with <code>kubectl</code>.  </p>
			<p>This is one of the key reasons why Kubernetes has become so popular: it truly does allow you to define and distribute your applications in a platform-agnostic way—even just a few years ago, being able to deploy an application locally and then across four public cloud providers using the same set of commands and configurations seemed impossible without a lot of complexity, which I am sure you will agree there has been none of in the last few chapters.</p>
			<p>In the next chapter, we are going to go back to Docker and learn how to best secure your containers.</p>
			<h1 id="_idParaDest-261"><a id="_idTextAnchor784"/>Questions</h1>
			<ol>
				<li>Once our cluster launches, what command did we need to run to create the namespace for the Sock Shop store?</li>
				<li>How do you find out the full details of the Load Balancer?</li>
				<li>Name the official Amazon Elastic Kubernetes Service CLI.</li>
			</ol>
			<h1 id="_idParaDest-262"><a id="_idTextAnchor785"/>Further reading</h1>
			<p>The product pages for each of the Kubernetes services can be found at the following links:</p>
			<ul>
				<li><strong class="bold">Azure Kubernetes Service:</strong> <a href="https://azure.microsoft.com/en-gb/services/kubernetes-service/">https://azure.microsoft.com/en-gb/services/kubernetes-service/</a> </li>
				<li><strong class="bold">Google Kubernetes Engine:</strong> <a href="https://cloud.google.com/kubernetes-engine/">https://cloud.google.com/kubernetes-engine/</a> </li>
				<li><strong class="bold">Amazon Elastic Container Service for Kubernetes:</strong> <a href="https://aws.amazon.com/eks/">https://aws.amazon.com/eks/</a></li>
				<li><strong class="bold">DigitalOcean Kubernetes:</strong> <a href="https://www.digitalocean.com/products/kubernetes/">https://www.digitalocean.com/products/kubernetes/</a> </li>
			</ul>
			<p>Quick starts for the various command-line tools used in the chapter can be found at the following links:</p>
			<ul>
				<li><strong class="bold">Azure CLI:</strong> <a href="https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest">https://docs.microsoft.com/en-us/cli/azure/?view=azure-cli-latest</a></li>
				<li><strong class="bold">Google Cloud SDK:</strong> <a href="https://cloud.google.com/sdk/">https://cloud.google.com/sdk/</a></li>
				<li><strong class="bold">AWS Command-Line Interface:</strong> <a href="https://aws.amazon.com/cli/">https://aws.amazon.com/cli/</a> </li>
				<li><strong class="bold">eksctl, the official CLI for Amazon EKS:</strong> <a href="https://eksctl.io/">https://eksctl.io/</a> </li>
				<li><strong class="bold">doctl:</strong> <a href="https://github.com/digitalocean/doctl/">https://github.com/digitalocean/doctl/</a> </li>
			</ul>
			<p>Finally, for more details on the demo store, go to the following link:</p>
			<ul>
				<li><strong class="bold">Sock Shop:</strong> <a href="https://microservices-demo.github.io/">https://microservices-demo.github.io/</a> </li>
			</ul>
		</div>
	</div>



  
<div><div><h1 id="_idParaDest-263"><strong class="bold"><a id="_idTextAnchor786"/>Section 3</strong>: Best Practices</h1>
			<p>In this section, we will take the skills learned from the previous chapters and cover how they can be used in the real world.</p>
			<p>This section comprises the following chapters:</p>
			<p><a href="B15659_14_Final_JM_ePub.xhtml#_idTextAnchor787"><em class="italic">Chapter 14</em></a>, <em class="italic">Securing Your Docker Environment</em></p>
			<p><a href="B15659_15_Final_JM_ePub.xhtml#_idTextAnchor823"><em class="italic">Chapter 15</em></a>, <em class="italic">Docker Workflows</em></p>
			<p><a href="B15659_16_Final_JM_ePub.xhtml#_idTextAnchor922"><em class="italic">Chapter 16</em></a>, <em class="italic">Next Steps with Docker</em></p>
		</div>
	</div>



  </body></html>