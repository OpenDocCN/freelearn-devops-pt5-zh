- en: Chapter 11. Useful Recipes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing a service in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing scheduled tasks in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing listeners in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing e-mail content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirecting to different page in webwork actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding custom behavior for user details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying a servlet in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding shared parameters to Servlet Context
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a ServletContextListener interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using filters to intercept queries in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding and importing components in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding new module types to JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling access logs in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enabling SQL logging in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Overriding JIRA's default components in plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating issues and comments from e-mail
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internationalization in webwork plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sharing common libraries across v2 plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Operations via direct HTML links
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have grouped the recipes under common themes as different chapters
    in this book. We have seen all the important themes but we still are left with
    some useful recipes and a handful of plugin modules that are not covered in the
    previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will look at some of those powerful plugin points and useful
    tricks in JIRA that are not covered in the earlier chapters. Not all of these
    recipes are related, but they are all useful in its own ways.
  prefs: []
  type: TYPE_NORMAL
- en: Writing a service in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A service that runs at regular intervals is a much wanted feature in any web
    application. It is more so if it is the one that can be managed with user-configured
    parameters and without having to reboot, and so on. JIRA offers a mechanism to
    add new services on to it that run at regular intervals after every start-up.
    It lets us do things related to JIRA and things independent of it. It lets us
    integrate with third-party applications. It lets us do wonders!
  prefs: []
  type: TYPE_NORMAL
- en: There are built-in services in JIRA. Export Service, POP Service, Mail Service,
    and so on, to name a few. In this recipe, we are going to see how we can add a
    custom service on to JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK. Note that the `atlassian-plugin.xml`
    file can be removed as it is not used in a service.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As opposed to the other JIRA plug-in modules, services don''t need a plugin
    descriptor. Instead, it uses a configuration XML. It is typically a JAR file with
    the related classes, files and a configuration XML. Following are the steps to
    write a simple service that just prints something onto the server console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the configuration XML. This is the most important part of a service.
    The following is a simple configuration XML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a simple configuration XML that doesn't take any properties. It has
    a root element and a unique ID both of which can be custom names of your pick.
    The root element we have is `someservice` and the ID is `jtricksserviceid`. The
    description, as the name suggests, is just a short description of the service.
    `properties` tag holds the different properties you want to associate with the
    service. These properties will be entered by the user while configuring the service.
    We will see more on that later.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Put the XML file under `src/main/resources/com/jtricks/services`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the service class. The class clan be put under any package structure
    as it will be referenced with the fully qualified name when it is added in JIRA.
    The class should extend `AbstractService`, which implements `JTricksService`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the mandatory methods in the service class. The following are the
    only ones that you need to implement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `run` is the key method that is executed when the service runs at regular
    intervals.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The other key mandatory method is `getObjectConfiguration()`. We get the configurations
    from the XML we have written earlier (in *Step* *1*) in this method. All we need
    to do here is to call the parent class' `getObjectConfiguration` method by passing
    three arguments. The first argument is a unique **ID** (which need not be same
    as the ID in the XML file). This ID is used as a key while saving the configurations
    internally. The second one is the **path** to the configuration XML file we wrote
    earlier, and the third argument is a **Map** using which you can add user parameters
    on to the object configuration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The third argument is mostly null in case of services as these user parameters
    are not used anywhere. It is meaningful in other places of JIRA, such as portlets,
    though not in the case of services.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compile these two files in to a JAR and drop it under `WEB-INF/lib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now the service is ready. We can go to **Administration** | **System** | **Services**
    and add the new service with the appropriate delay. While adding the service,
    we need to use the fully qualified name of the service class. More about registering
    a service can be found at: [http://confluence.atlassian.com/display/JIRA/Services#Services-RegisteringaService](http://confluence.atlassian.com/display/JIRA/Services#Services-RegisteringaService)
    and is outside the scope of the book.'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Adding* *configurable* *parameters* *to* *a* *service*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding configurable parameters to a service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For a simple service as the one we just wrote, there is only one parameter that
    can be configured. It is the delay at which the service runs! What if we need
    to add more parameters? Let's say we want to add the tutorial name in the service
    which can be changed later if needed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the service configuration XML to include the configurable properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we have added a string property with the key: `Tutorial`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Override the `init()` method in the service class to retrieve the new property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we retrieve the property `Tutorial` from the `PropertySet` in the `init`
    method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the property as appropriately in the `run()` method. Here, let us just
    print the tutorial name:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `init` method will be called whenever the service is configured or re-configured
    and the property values we entered on the JIRA Admin GUI are retrieved in this
    method for use in the `run()` method.
  prefs: []
  type: TYPE_NORMAL
- en: We can also optionally override the destroy method to do anything we want before
    the service is removed!
  prefs: []
  type: TYPE_NORMAL
- en: Once the service is deployed and added in the GUI, it prints **Running** **the**
    **JTricks** **service** **Tutorial?** **I** **don't** **like** **tutorials!**
    as the tutorial property is not configured yet.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Go to the **Administration** | **System** | **Services** area, edit the service
    to enter a value under **The** **tutorial** **you** **like** field. Assuming you
    entered **JTricks** **Tutorials**, you will see some output as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing* *a* *service* *in* *JIRA*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing scheduled tasks in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Have you ever thought of running scheduled tasks within JIRA? Why do we need
    scheduled tasks when we have the JIRA Services? We have seen how to write a service
    in the previous recipe. But in spite of all the advantages we discussed so far,
    these services have a disadvantage. It always starts when JIRA is restarted and
    runs at regular intervals after that. So, if you have a service that does some
    heavy memory-intensive operation and if you restart JIRA in the middle of the
    day, you will suddenly find your instance's performance compromised! If it is
    scheduled to run every 24 hours, you will find the same service running in the
    middle of the day from then on until the next restart.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled tasks in JIRA are a good way to make sure all such operations happen
    at quite times, midnight, for example. In this chapter, we will write a simple
    scheduled task and see how easy that can be!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us write a simple scheduled task that prints a line in the console. Following
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Write a Java class that implements the `Quartz` `job` interface. JIRA internally
    uses Quartz for scheduling its tasks and so Quartz comes bundled within JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `execute` method. This is the method that gets executed every
    time the job runs. Whatever we do in this method can be as simple as a one liner
    or as complex as initiating a nuclear explosion! Our scheduled job just prints
    a line to the console and hence the Java class that we write is as simple as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Package the class in a JAR file and deploy it under `WEB-INF/lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `scheduler-config.xml` file under `WEB-INF/classes` folder to let
    JIRA know of our new scheduled task. JIRA stores all the information about scheduled
    tasks in this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define a job under the `<job>` tag as shown:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a trigger that runs the `JTricksJob`. This is where we define the `cron`
    expression to run the job at defined timings:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'The previous trigger schedules the job to run every two minutes. More details
    about writing a `cron` expression can be found at: [http://www.quartz-scheduler.org/docs/tutorial/TutorialLesson06.html](http://www.quartz-scheduler.org/docs/tutorial/TutorialLesson06.html).'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once JIRA is restarted, the new job can be seen at the scheduler details page
    under **Administration** | **System** | **Scheduler** **Details**. We can also
    verify the next fire time for the task on the same page, as shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And when the job runs, you will see the following printed in the console!
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing listeners in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Listeners** are very powerful features in JIRA. JIRA has a mechanism of throwing
    events whenever something happens on an issue, such as when creating an issue,
    updating an issue, progressing on the workflows, or in similar events. Using listeners,
    we can capture these events and do special things based on our requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: There are two different ways using which listeners can be implemented in JIRA.
    The old way of doing it is to extend the `AbstractIssueEventListener` class which
    in turn implements the `IssueEventListener` interface. The `AbstractIssueEventListener`
    class captures the event, identifies its type, and delegates the event to the
    appropriate method where it is handled. To write a new listener, all we need to
    do is to extend the `AbstractIssueEventListener` class and override the methods
    of interest!
  prefs: []
  type: TYPE_NORMAL
- en: The new way of doing it is to use the `atlassian-event` library. Here, we register
    the listener in the plugin descriptor and implement the listener with the help
    of `@EventListener` annotation.
  prefs: []
  type: TYPE_NORMAL
- en: Both ways are supported in JIRA now, though they have their own advantages and
    disadvantages. For example, it is possible to add properties for a listener in
    the old way. Adding properties is not supported in the new way but then the new
    way doesn't need any configuration as it is registered automatically. The new
    way, on the other hand, can be written as a fully fledged v2.0 plugin.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to write listeners in both the ways.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing a listener in the old way, by extending `AbstractIssueEventListener`,
    is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a listener class that extends the `AbstractIssueEventListener` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Define the properties for the listener. This is an optional step, needed only
    if you need to define properties for the listener, which can then be used during
    execution. An example could be to enter the mail server details, if we have a
    listener that sends custom e-mail using a specific mail server when an event is
    fired.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `getAcceptedParams` method to return a String array of properties
    to be defined.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define a property named `prop1`.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the `init` method and retrieve the property value entered by the user.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `init` method is invoked whenever a listener is configured or re-configured.
    Here, we just retrieve the property value and assigns it to a class variable for
    future use.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Override the appropriate listener methods. For example, an issue created event
    can be captured by overriding `issueCreated` method as shown next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we just retrieve the issue that triggered the event—the issue that is
    newly created in this case—and just prints the details along with the listener
    property. We can write even more complex methods in this method. It is also possible
    to retrieve other things from the event like the change log details if there are
    any changes involved, for example, in case of `issueUpdated` event or when entering
    the comment using a transition.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Note that only a handful of events can be listened to like this and there are
    events like `project` `creation`, which do not throw an event at all! In such
    cases, you might want to extend the respective action and throw a custom event
    if needed. All the available events can be found at: [http://docs.atlassian.com/jira/latest/com/atlassian/jira/event/issue/IssueEventListener.html](http://docs.atlassian.com/jira/latest/com/atlassian/jira/event/issue/IssueEventListener.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'An important method that is worth mentioning here is the `customEvent` method,
    which is invoked whenever a custom event is triggered. This happens for all the
    custom events configured by the user as mentioned in the next recipe. We can capture
    them as shown next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, 10033 is the ID of the new event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the class into a JAR file and deploy it under the `jira-home/plugins/installed-plugins`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Restart JIRA
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure the listener by going to **Administration** | **System** | **Listeners**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter name and the fully qualified class name and click on **Add**.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Edit the listener to add properties if there are any!
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A listener created in the new way, that is, using `@EventListener` annotation
    is written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Register the listener in `atlassian-plugin.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here the `class` attribute holds the fully qualified name of the listener class
    that we are going to write.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Import the `EventPublisher` component using `component-import` plugin module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the listener class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inject the `EventPublisher` component into the class and use the `register`
    method to self register as shown next:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Create methods to handle the events using `@EventListener` as shown in the
    following code:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Note that the annotation can be used with any number of public methods in the
    class and all of them will be invoked when an event is fired in JIRA.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Handle the events appropriately.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Here, as we can see, the event ID is checked and then handled as appropriate.
    First, we handled the issue created event and then the custom event.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it under the `jira-home/plugins/installed-plugins`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In both the cases, the listener works exactly the same way once configured.
    Note that the configuration is applicable only for the old way and when done the
    listener can be seen under **Administration** | **System** | **Listeners** as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that there is the property **prop** **1** configured in the listener.
  prefs: []
  type: TYPE_NORMAL
- en: When the event is fired in JIRA, listeners capture them and the appropriate
    methods are invoked. The old one will print the issue key along with the property
    name. The new one works the same way, except that there is no property value.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is possible to add properties to the listener even in the new way but that
    needs a separate configuration screen to capture and maintain the properties.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible that the plugin maybe disabled and re-enabled by the Administrators
    while the service is still running. The constructor is invoked when the listener
    is initially loaded at JIRA startup but we might want to handle the enabling or
    disabling of plugins separately as they are not captured in the constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Handling, enabling, and disabling of plugins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Atlassian plugins are implemented as Spring dynamic modules, and the `atlassian-plugin.xml`
    is transformed into a Spring XML bean configuration before it is actually loaded
    by the product. In case of listeners, Event Listener will become a Spring bean
    and hence we can apply the Spring interfaces—`InitializingBean` and `DisposableBean`—to
    capture the creation and destruction of the bean. In our case, the code is modified
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the registering and un-registering happens in methods `afterPropertiesSet`
    and `destroy` events respectively. These methods are invoked during the creation/destruction
    of the bean and that effectively handles enabling/disabling of the plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'Don''t forget to add the `spring-beans` JAR in the project build path in this
    case to avoid compilation issues! Alternatively, the following dependency can
    be added in the `pom.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Customizing e-mail content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how JIRA throws various events when something happens and
    how we can handle these events to things ourselves. One such handling of these
    events includes sending e-mail notifications to users based on the notification
    schemes that are setup in JIRA. But what if we don't like the default content
    of JIRA notifications? What if we just want a different wording or maybe even
    amend the e-mail content?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can customize the e-mail content that is
    sent as a notification when an event is thrown in JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JIRA has a set of e-mail templates written using velocity that is rendered when
    a notification is sent. For each event, a template is configured within JIRA and
    that template is used when the event is thrown. We can either create new templates
    and edit the events to use these new templates or modify the existing templates
    and leave the events as they are!
  prefs: []
  type: TYPE_NORMAL
- en: 'In both the cases, the steps are pretty much similar and are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the event for which the notification needs to be changed. The event
    could be an existing JIRA event such as `Issue` `Created` and `Issue` `Updated`
    or the custom event that the JIRA administrator has created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the template mapped to the event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For each event, be it system-based or custom, there is a template associated
    to it. We cannot change the templates associated with a system event. For example,
    an `Issue` `Updated` event is associated with `Issue` `Updated` template. We can,
    however, choose any template for the custom events we have added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The e-mail template mapping for the chosen template can be found at `atlassian-jira/WEB-INF/classes/email-template-id-mappings.xml`.
    In this file, we can find many templates associated to each event. For example,
    `Issue` `Updated` event has the following entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we can add new mappings if we are adding new templates as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the `id` we use here is unique in the file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identify the template to be edited if we are customizing an existing template
    or add a new template with the name mentioned in the `email-template-id-mappings.xml`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Email templates are stored under two different locations within JIRA one for
    HTML mails and another for Text mails. The templates for those can be found at
    `WEB-INF/classes/templates/email/html and WEB-INF/classes/templates/email/text
    respectively`. In addition to these, the subject of the e-mail can be found under
    `WEB-INF/classes/templates/email/subject`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that the name of the template is the same in all the three places. In our
    example, the name of the template being edited is `issueupdated.vm` and hence
    if we need to only modify the subject, we just need to modify the `WEB-INF/classes/templates/email/subject/issueupdated.vm`
    file. Similarly, HTML or text content can be edited at `WEB-INF/classes/templates/email/html/issueupdated.vm`
    or `WEB-INF/classes/templates/email/text/issueupdated.vm` respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we are adding the template, `demoevent.vm` in our case, we need to create
    three templates one for each subject, HTML body and text body, all with the same
    name put under the respective folders.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Restart JIRA after editing the templates appropriately.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After, a template is newly added and JIRA is restarted, we can associate it
    with the custom events we have created. When the notification is sent, JIRA will
    use the updated or newly added templates to render the e-mail content.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is possible to add more information about an issue, such as custom fields
    in the notification e-mails by editing the relevant velocity templates.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Customization—adding custom field information
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All the VM templates have got the `$issue` object in the velocity context along
    with other variables that are elaborated at: [http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates](http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates).
    It is fairly easy to use this to retrieve the contents on an issue while generating
    the e-mail content.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `$issue.summary` will retrieve the issue summary and you can see
    it in the e-mail subject rendered using `WEB-INF/classes/templates/email/subject/issueupdated.vm`.
    Similarly, other information on the issue can be easily accessed. For example,
    custom field details can be accessed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Here, `10010` is the unique ID for the custom field.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can see various other examples of formatting at: [http://confluence.atlassian.com/display/JIRADEV/Adding+Custom+Fields+to+Email](http://confluence.atlassian.com/display/JIRADEV/Adding+Custom+Fields+to+Email).'
  prefs: []
  type: TYPE_NORMAL
- en: Redirecting to different page in webwork actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This recipe covers a very simple concept in JIRA web actions. While writing
    plugins, we often come across scenarios where we need to navigate to a new page
    such as a Dashboard or to browse a new project or view another issue after the
    action is executed. `JiraWebActionSupport` provides a simple method for doing
    this, which we will see in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What if we want to navigate to the Dashboard instead of rendering a success
    view when an action is executed? What if we can't directly link it from the JSP
    page or the velocity template because we want to perform something in the action
    class before we redirect?
  prefs: []
  type: TYPE_NORMAL
- en: All you need here is to return `getRedirect(URL)` in the action class's `doExecute`
    method (or the appropriate method)! This method will redirect to the specified
    location when the action method is successfully finished. If there are any errors,
    it will go to the error page as the `getRedirect()` method returns `Action.ERROR`
    in that case.
  prefs: []
  type: TYPE_NORMAL
- en: You can force redirect to the URL even if there are errors by using `forceRedirect(URL)`
    instead of `getRedirect()` method. It doesn't clear the return URL and will always
    go to the redirect URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we need to return to Dashboard when SUCCESS, we can do it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Replacing `getRedirect` with `forceRedirect` will take the user to Dashboard
    irrespective of the result.
  prefs: []
  type: TYPE_NORMAL
- en: Adding custom behavior for user details
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In JIRA, you can see that the user details are formatted with the full name
    and a link to the users'' profile within the application. For example, when the
    issues are displayed in the issue navigator, the assignee and reporter are displayed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding custom behavior for user details](img/1803-11-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: But what if we want to change how the user details are displayed? Say, if we
    want to display the user avatar alongside? Or, if we want to display their usernames
    with an external link, like a link to their Twitter profile?
  prefs: []
  type: TYPE_NORMAL
- en: JIRA provides the User Format plugin module to serve this purpose. Using this
    module, we can define different formats in which the user will be displayed and
    use them within the existing JIRA displays or within out-custom plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using the Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, let us try to create a new user profile that will display the
    username (instead of full name) with a link to their twitter profile to add some
    spice! The following are the steps to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the user-profile module in to the `atlassian-plugin.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with other plugin modules, user profile module also has a unique **key**.
    It then points to the **class** that will be used by the user formatter, `TwitterUserFormat`
    in this case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `type` element holds the unique profile type name that will be used while
    formatting the user. Following are the types existing in JIRA by default as on
    4.4 version: `profileLink`, `fullName`, `profileLinkSearcher`, `profileLinkExternal`,
    `profileLinkActionHeader`, `fullProfile`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `resource` element points to the velocity template to be used for rendering
    the view, `twitterLink.vm` in this case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the formatter class in the previous step. The class should implement
    the `UserFormat` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we inject `UserFormatModuleDescriptor` into the class as it will be used
    in rendering the velocity template, as shown in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the required methods. We will have to implement the two overridden
    **format** methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first method takes a `username` and `id` where the `username` is the name
    of the user, which can also be *null*, and `id` is an extra argument that can
    be used to pass an extra context to the renderer. Ideally, an implementation might
    include this ID in the rendered output such that it can be used for test assertions.
    An example of how the ID is used can be found in displaying the assignee in the
    column view (`/WEB-INF/classes/templates/jira/issue/field/assignee-columnview.vm`)
    where the ID is assignee.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We are not going to use ID in the example, but the method is implemented as
    follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'where the `getInitialParams` just populates the `params` map with the username
    as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can populate the map with as many things as needed if we want to render the
    user details in some other way!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The second method takes `username`, `id`, and a `map` pre-populated with extra
    values to add more to the context! The method is implemented as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The only difference is that the extra context is also populated into `params`
    map.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In both cases, the `moduleDescriptor` renders the velocity template, defined
    by the name `VIEW_TEMPLATE` or "view".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the velocity template that uses the context populated in `params` map
    in the previous step to display the user information:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our example, we just display the username as it is with a link `http://twitter.com/#!/${username}`
    that will point to the twitter account with that username. Note that the `quote`
    variable is assigned a double quotation mark inside a single quotation mark. Single
    quotation here is the velocity syntax and double quotation is the value. It is
    used to construct the URL where encoded name, href value, and so on are placed
    between quotes!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Don't forget to handle the scenario when the user is null. In our case, we just
    display the name as Anonymous when the user is null.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the plugin is deployed, the new user profile, `twitterLink` in this case,
    can be used in various places in JIRA where appropriate. For example, the `assignee-columnview.vm`
    can be modified to include `twitterLink` profile instead of the default `profileLink`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'When you do that, the assignee column in issue navigator will appear as follows
    with a link to the user''s Twitter account:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can also use the new profile in the plugins to render user details just
    by invoking the `formatUser` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Or:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Deploying a servlet in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We all know how useful a servlet is! JIRA provides an easy way to deploy a JAVA
    servlet with the help of the Servlet Plugin module. In this recipe, we will see
    how to write a simple servlet and access it in JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using the Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to deploy a JAVA servlet in JIRA:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Include the servlet plugin module in the `atlassian-plugin.xml`. The Servlet
    plugin module allows the following set of attributes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`class`: It is the servlet Java class and it must be a subclass of `javax.servlet.http.HttpServlet`.
    This attribute is mandatory.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`disabled`: It indicates whether the plugin module should be disabled or enabled
    by default. By default, the module is enabled.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`i18n-name-key`: The localization key for the human-readable name of the plugin
    module.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`key`: It represents the unique key for the plugin module. This attribute is
    mandatory.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`name`: It is the human-readable name of the servlet.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`system`: It indicates whether this plugin module is a system plugin module
    or not. Only available for non-OSGi plugins.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the child elements supported:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`description`: The description of the plugin module.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`init-param`: Initialization parameters for the servlet, specified using `param-name`
    and `param-value` subelements, just as in `web.xml`. This element and its child
    elements may be repeated.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`resource`: Resources for this plugin module. This element may be repeated.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`url-pattern`: The pattern of the URL to match. This element is mandatory and
    may be repeated.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, let us use only the mandatory fields and some example init-`params`
    as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here `JTricksServlet` is the servlet class where as `/myWebsite` is the URL
    pattern. We are also passing a couple of `init` params: `siteName` and `siteAddress`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a `servlet` class. The class must extend `javax.servlet.http.HttpServlet`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the necessary methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can retrieve the `init` params in the `init` method as shown next:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `init()` method is invoked every time the servlet is initialized and this
    happens when the servlet is first accessed. `init()` method is also invoked when
    the servlet is first accessed after the plugin module is disabled and enabled
    back.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see, the `init` params we defined in the servlet plugin module can
    be accessed here from the `ServletConfig`. Here, we also initialize the `JiraAuthenticationContext`
    so that we can use it to retrieve the logged-in user details in the servlet. Similarly,
    we can initialize any JIRA components here.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the `doGet()` and/or `doPost()` methods to do what needs to be implemented.
    For the example, we will just use the `init` params to create a simple HTML page
    and print a line to the console.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: The `authenticationContext` retrieves the current username as mentioned earlier.
    From JIRA 4.3, `getLoggedInUser()` method is used to retrieve the current user
    and `getDisplayName()` gets the user's full name.
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once deployed, the servlet will be accessible at the URL: `http://yourserver/jira/plugins/servlet/${urlPattern}`.
    In our case, the URL is `http://yourserver/jira/plugins/servlet/myWebsite`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the servlet is accessed at `/plugins/servlet/myWebsite`, the output is
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding shared parameters to Servlet Context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we saw how to deploy a servlet and how to make use of
    the init params. What if we have a set of servlets or servlet filters or context
    listeners that make use of the same parameters? Do we really need to initialize
    them in all the plugin modules?
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can use the Servlet Context Parameter plugin
    module to share parameters across servlets, filters, and listeners.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using the Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All we need to do is to define the shared parameters to add a `servlet-context-param`
    module for each shared parameter in the `atlassian-plugin.xml`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a parameter with key `sharedText` can be defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Make sure the module has a unique key. Here, the parameter name is `sharedText`
    and it has a value **This** **is** **a** **shared** **Text**. Once the plugin
    is packaged and deployed, the parameter **sharedText** is available across servlets,
    filters, and listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a servlet, we can access the parameter in the `init` method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the shared text is retrieved, we can use it anywhere like while constructing
    the HTML
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The servlet will be now printing that as well, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Writing a Servlet Context Listener
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to write servlets. How about writing a context listener for
    the same? This will come in handy if you want to integrate with frameworks that
    use context listeners for initialization.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using the Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps to write a simple context listener:'
  prefs: []
  type: TYPE_NORMAL
- en: Include the `servlet-context-listener` module in the `atlassian-plugin.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have a unique module key and a class that is the servlet context listener's
    Java class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Write the servlet context listener''s class. The class must `javax.servlet.ServletContextListener`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the context listener methods as appropriate. For example, we just
    print some statements to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The details of the context that is initialized or destroyed can be found from
    the `ServletContextEvent` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `contextInitialized` method is not invoked at application startup. Instead,
    it is invoked the first time a servlet or filter in the plugin is accessed after
    each time it is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Similarly the `contextDestroyed` method is invoked every time the plugin module
    containing a servlet or filter is disabled.
  prefs: []
  type: TYPE_NORMAL
- en: Using filters to intercept queries in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Servlet filters provide a powerful mechanism to intercept queries and do wise
    things such as profiling, monitoring, content generation, and so on. It works
    exactly like any normal Java servlet filter and JIRA provides the **Servlet**
    **Filter** **Plugin** **Module** to add them using plugins. In this recipe, we
    will learn about how to use filter to intercept certain queries to JIRA and how
    we can utilize them!
  prefs: []
  type: TYPE_NORMAL
- en: As with other servlet plugin modules, a `servlet-filter` `plugin` module also
    has a unique `key` and a `class` associated with it. The `name` attribute holds
    the human-readable name of the filter and `weight` indicates the order in which
    the filter will be placed in the filter chain. The higher the weight, the lower
    the filter's position.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another important attribute `location` that denotes the position of
    the filter in the application''s filter chain. Following are the four possible
    values for the location:'
  prefs: []
  type: TYPE_NORMAL
- en: '`after-encoding`: Very top of the filter chain in the application, but after
    any filters which ensure the integrity of the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before-login`: Before the filter that logs in the user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before-decoration`: Before the filter which does Sitemesh decoration of the
    response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`before-dispatch`: At the end of the filter chain, before any servlet or filter
    which handles the request by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `weight` attribute is used in conjunction with `location`. If two filters
    have the same location, then they are ordered based on the weight attribute.
  prefs: []
  type: TYPE_NORMAL
- en: '`init-param` as usual takes the initialisation parameters for the filter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`url-pattern` defines the pattern of the URL to match. This element can be
    repeated and the filter will be invoked for all the URLs matching any of the patterns
    specified. Unlike a servlet URL, the `url-pattern` here matches `${baseUrl}/${url-pattern}`.
    The pattern can use wild chars `*` or `?`, the former matching zero or many characters,
    including directory slashes and the latter matching zero or one character.'
  prefs: []
  type: TYPE_NORMAL
- en: '`dispatcher` is another element that determines when the filter is invoked.
    You can include multiple dispatcher elements with values `REQUEST`, `INCLUDE`,
    `FORWARD`, or `ERROR`. If not present, the filter will be invoked in all cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create an skeleton plugin using the Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us try to intercept all the issue views, which has the URLs of the format
    `${baseUrl}/browse/*-*` and log them. The following are the step-by-step procedure
    to write a filter and implement the given logic.
  prefs: []
  type: TYPE_NORMAL
- en: Add the **Servlet** **Filter** plugin module into `atlassian-plugin.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here `JTricksServletFilter` is the filter class and we have added the filter
    before dispatch. In our example, `url-pattern` will be `/browse/*-*` as the URL
    to browse an issue is of the form `${baseUrl}/browse/*-*.` We can use different
    URL patterns as required in our context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the `Filter` class. The class should implement `javax.servlet.Filter`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the appropriate Filter methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `init` method is invoked when the filter is initialized, that is,
    the first time it is accessed after the plugin is enabled. In this method, we
    can retrieve the `init-param` instances defined or parameters defined using Servlet
    Context Parameter plugin module. In the previous code snippet, use `getLoggedInUser()`
    to retrieve logged user from JIRA 4.3+ and use `getDisplayName()` to retrieve
    the user's full name in that case.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `destroy` method is invoked whenever a filter is destroyed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `doFilter` is the method which is invoked every time the URL matches the
    `url-pattern`. Here, we are just printing the IP address and user details requesting
    the **View** **Issue** page and logs the time but we can do many things like logging,
    using the data for profiling or monitoring, so on and so forth.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Whenever the URL in JIRA matches the `url-pattern`, the respective filter is
    invoked. This can be of huge help when you want to do specific things when a particular
    operation in JIRA is performed, or if you want to monitor who is doing what and
    when, or something else based on a specific URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: With our code in the example, the details are printed, as shown in the previous
    screenshot, whenever an issue is viewed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and importing components in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIRA has a component system that has so many Service classes and Manager classes
    that are registered in PicoContainer and are available for use by the core classes
    and plugins alike. It makes sense sometimes to add custom components to that component
    system that can then be used with the other modules in the same plugin or shared
    by other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can add a new component in JIRA and how we
    can consume that from within the plugin and from a separate plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Skeleton plugin using Atlassian Plugin SDK. For the example, we will
    use the `RedirectAction` webwork module used in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let us see how we can define a component and use them in the different
    modules within the same plugin. In our example, we will define a sample component
    and use the methods exposed by it in the `RedirectAction`. Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an interface with the required method definitions. The component will
    expose these methods when used elsewhere:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create the implementation class and implement the methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the implementation class, we can inject the JIRA components as usual and
    use them for various things. Here, we inject `JiraAuthenticationContext` to retrieve
    the current user details just to print a personalized message!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Declare the component in the `atlassian-plugin.xml` file using the Component
    Plugin module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the component module has a unique key and a class attribute that points
    to the Implementation class. The element interface points to the component interface
    we created in *Step* *1*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our component is now ready and available to use within the other plugin modules.
    For example, we can use this component in the RedirectAction class we saw earlier,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Here, the component is injected in the constructor as we normally do with a
    JIRA component (remember the `JiraAuthenticationContext` in the component itself!)
    and invoke the exposed method, `doSomething` in this case, where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exposing components to other plugins**'
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we create the components as discussed earlier, they remain private and
    are available only within the plugin even though we can expose these components
    to other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the two things you need to do to expose a component:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare the component as public.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Export the packages required for the plugin so that they are available to the
    other plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following are the steps in detail to do the same:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the interface and implementation class as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare the component in the `atlassian-plugin.xml` using the Component Plugin
    module as a public component. For this, we use the public attribute on the component
    module, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Export the packages using `bundle-instructions` element under `plugin-info`
    in `atlassian-plugin.xml`. This is done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the `Export-Package` element exports `com.jtricks.provider` package
    that holds the interface and implementation class. More about bundle instructions
    can be found at: [http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Creating+your+Plugin+Descriptor#CreatingyourPluginDescriptor-{{bundleinstructions}}element](http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Creating+your+Plugin+Descriptor#CreatingyourPluginDescriptor-{{bundleinstructions}}element).'
  prefs: []
  type: TYPE_NORMAL
- en: With that, the component is now ready and available to other plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Importing public components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to use the public components in other plugins, we will have to first
    import them using the `component-import` plugin module. The module is entered
    in `atlassian-plugin.xml` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: Now, the component is available as if it is created within the plugin itself.
    The `RedirectAction` class will look exactly the same in the new plugin as well
    if we want to use the component there.
  prefs: []
  type: TYPE_NORMAL
- en: Using service properties in components
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It is also possible to define a Map of properties for a public component which
    can then be used while importing the components with other plugins. It uses the
    `service-properties` element to define the properties which has child elements
    named entry and have key & value attributes. For example, a dictionary service
    can have the service properties defined with the language as key, as shown in
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'It is now possible to use the `filter` attribute on the `component-import`
    module to import component only if the service matches the filter. For example,
    the dictionary service that has English as the language can be imported as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a component is installed, it generates the `atlassian-plugins-spring.xml`.
    Spring Framework configuration file, transforming Component Plugin modules into
    Spring bean definitions. The generated file is stored in a temporary plugin JAR
    file and installed into the framework. If the `public` attribute is set to 'true',
    the component will be turned into an OSGi service under the covers, using **Spring**
    **Dynamic** modules to manage its lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Component imports also generate the `atlassian-plugins-spring.xml` Spring Framework
    configuration file and transforms the Import Plugin Module to OSGi service references
    using Spring Dynamic modules. The imported component will have its bean name set
    to the component import key.
  prefs: []
  type: TYPE_NORMAL
- en: In both cases, it is possible to write our your own Spring configuration file,
    stored under the folder META-INF/spring in the plugin JAR.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'More details about Component Plugin module and Component Import plugin module
    can be found in the Atlassian documentation at: [http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Component+Plugin+Module](http://confluence.atlassian.com/display/PLUGINFRAMEWORK/Component+Plugin+Module)
    and [http://confluence.atlassian.com/display/JIRADEV/Component+Import+Plugin+Module](http://confluence.atlassian.com/display/JIRADEV/Component+Import+Plugin+Module)
    respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding new module types to JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have seen a lot of useful plugin module types in JIRA. Custom field
    module type, webwork module type, servlet module type, and so on. But is it possible
    to add a custom module type in JIRA, one that can then be used to create different
    modules?
  prefs: []
  type: TYPE_NORMAL
- en: JIRA provides the Module Type plugin module using which we can add new module
    types dynamically to the plugin framework. In this recipe, we will see how we
    can add such a new plugin module type and use it to create different modules of
    that type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a Skeleton plugin using Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us consider the same example Atlassian have used in their online documentation,
    that is, to create a new dictionary plugin module which can then be used to feed
    a dictionary service used by other plugins or modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps to define a new plugin module type:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the module type definition in the `atlassin-plugin.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the key must be unique and will be used as the root element when defining
    the modules of this type. The class points to the `ModuleDescriptor` class that
    is instantiated when a new plugin module of this type is found.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Other useful attributes of this module type includes `name` that holds a human
    readable name, `i18n-name-key` to hold the localization key for the human-readable
    name, `disabled` to indicate if the plugin module is disabled by default or not
    and `system` to indicate whether this plugin module is a system plugin module
    or not (available only for non-OSGi). You can also have an optional `description`
    as a child element.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create an interface that can be used in the `ModuleDescriptor` class. This
    interface will have all the methods needed for the new module. For example, in
    the dictionary, we need a method to retrieve the definition of a given text and
    hence we can define the interface as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The new modules of this particular type will ultimately implement this interface.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the module descriptor class. The class must extend the `AbstractModuleDescriptor`
    class and should use the interface we created as the generic type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Implement the `getModule` method to create the module.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have used the `ModuleFactory` to create a module of this type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the attributes and elements that will be used in the new module type
    and retrieve them in the `init` method. For a dictionary, we need at least one
    attribute, that is the `language`, to differentiate the various dictionary modules.
    Let us name that attribute as `lang` and retrieve it in the `init` method. The
    class will now look similar to the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `init` method takes as argument, `com.atlassian.plugin.Plugin` and `org.dom4j.Element`,
    the latter holding the module element. We have retrieved the 'lang' attribute
    here and assigned it to a local variable which has a getter method that can be
    used to get the language value in other plugins/modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can have more attributes or child elements as required by the new module
    type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, the new plugin module is now ready. We can now write new modules
    of the type dictionary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Creating modules using the new module type
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The new module types will be as simple as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that the root element is the same as the module types'' key, **dictionary**
    in this case. Each has its own unique `key` and has the `lang` attribute we defined
    earlier. Each has a class which will implement the Dictionary interface appropriately.
    For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Using the new modules created
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once the new modules are defined, `myUSEnglishDictionary` and `myUKEnglishDictionary`
    in our example, we can use these in other plugin modules. For example, if we want
    to use them in a servlet module to find the definition of JIRA in both the dictionaries,
    it can be done using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Get all the enabled modules that use the dictionary module descriptor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, `pluginAccessor` can be retrieved as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It can also be used to retrieve all the enabled modules that uses the given
    module descriptor class as shown in the code.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For each `DictionaryModuleDescriptor`, `getLanguage()` method will retrieve
    the value of the `lang` attribute and `getModule()` will retrieve the respective
    Dictionary implementation class. For example, JIRA definition for `uk-english`
    can be retrieved as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the key that is passed will be `uk-english`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we use a servlet to display all the definitions of the word JIRA in all
    the dictionaries deployed, US and UK in our case, it will appear as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Enabling access logs in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Access logs are a good way to find out who is doing what in your JIRA instance.
    In this recipe, we will see how we can turn on access logging in JIRA.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As of JIRA 4.1, the list of users who are currently accessing JIRA can be found
    from **Administration** | **System** | **User** **Sessions** menu. But if you
    need more detailed information about who is doing what, access logging is the
    way to go.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JIRA 4.x, enabling access logs can be done via the administration screen
    by going to **Administration** | **System** | **Logging** **&** **Profiling**
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-11-14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We can turn **ON** **HTTP** and **SOAP** access logs separately as shown. There
    is an additional option to turn ON HTTP dump log and SOAP dump log as well. For
    HTTP, we can also include images in the HTTP access logs.
  prefs: []
  type: TYPE_NORMAL
- en: All these logs are disabled by default and if enabled via GUI, it will be disabled
    again on next restart.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable them permanently, we can switch them ON in the `log4j.properties`
    file residing under `WEB-INF/classes` folder under the section, **Access** **logs,**
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Enabling Access logs prior to JIRA 4.x
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to JIRA 4.x, Access logs had only a single entry in the `log4j.properties`
    file and we could enable it by changing the log level from WARN to INFO as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: The same option can be enabled from WARN to INFO on the GUI as well but it will
    be retained only till the next restart just like it is in 4.x.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once turned ON, the SOAP access logs will be written to `atlassian-jira-soap-access.log`,
    SOAP dump logs to `atlassian-jira-soap-dump.log`, HTTP access logs to `atlassian-jira-http-access.log`
    and HTTP dump logs to atlassian`-jira-http-dump.log` files, everything residing
    under the `logs` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find detailed information in the access logs, similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to change the individual log file''s name or path in the
    `log4j.properties` by modifying the appropriate properties. For example, the SOAP
    access log file can be written to `/var/log/soap-access.log` by modifying `log4j.appender.soapaccesslog.File`
    property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Enabling SQL logging in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Similar to access logs, another useful piece of logging, especially when debugging
    an issue, is SQL logging. In this recipe, we will see how to turn on SQL logging.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'SQL logging cannot be turned ON from the user interface. Instead, it can be
    turned ON in the `WEB-INF/classes/log4j.properties` file as we have seen with
    access logs. In this case, the logging entry to be modified is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: The latter logs the SQL queries executed for Xsrf vulnerability detection.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once turned **ON**, the SQL logs will be written to `atlassian-jira-sql.log`
    file under logs folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find details of numerous SQLs executed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'As in the case of Access logs, the SQL log file path can be changed by modifying
    `log4j.appender.sqllog.file` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Overriding JIRA's default components in plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JIRA uses **PicoContainer** as a central object factory. Picocontainer is responsible
    for instantiating objects and resolving their constructor dependencies. Within
    JIRA a lot of Manager, Service, and Utility classes are already registered with
    Picocontainer. The registration happens in `ComponentRegistrar` class' `registerComponents()`
    method and these classes can be retrieved via **dependency** **injection** or
    using `ComponentManager` class' getter methods or the `getComponentInstanceOfType()`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: While it is true that most of the plugins can work with these already-registered
    components and the new ones created using Component Plugins module, sometimes
    the need arises to override an existing component registered within JIRA. In this
    recipe, we will see how to do that.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK. The plugin must be v1.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The overriding of existing components in JIRA is also done using the **Component**
    **Plugins** module. But you must note that the plugin must be v1 and should be
    deployed under `WEB-INF/lib` folder for the overriding to work. Following are
    the simple, yet powerful, steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the component that we need to extend and find out the interface associated
    with it. For example, let us try to override the default JIRA `SubTaskManager`.
    The interface in this case will be `com.atlassian.jira.config.SubTaskManager`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a component plugin module in the `atlassian-plugin.xml` with the interface
    in *Step 1*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As usual, the component module has a unique **key** and an optional **name**.
    Here, the class points to the new component's implementation class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the implementation class used in the component plugin module, `com.jtricks.MySubtaskManager`
    in this case.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will need to implement all the methods in the SubTaskManager interface but
    it is entirely up to us how to implement them. It will be a lot easier if we just
    need to manipulate only a few methods in them because in that case we can choose
    to extend the default implementation class in JIRA and override only the methods
    we are interested in!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For simplicity, let us assume we need to only modify the `createSubTaskIssueLink`
    operation in `SubTaskManager` to do some extra bit. For this, we can create the
    `MySubtaskManager` by extending `com.atlassian.jira.config.DefaultSubTaskManager`,
    the default implementation class in JIRA, and override the `createSubTaskIssueLink`
    method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our example, let us just print a line to the logs but we can do harder things
    here!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it under `WEB-INF/lib`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When JIRA is started, all the default components that are registered with **PicoContainer**
    are loaded first. But when the plugins are loaded, if there is a component module
    that uses the same interface and a different implementation class; this class
    will be registered for that interface. In our example, `MySubtaskManager` is registered
    instead of `DefaultSubTaskManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This method fails in case of some Manager classes, possibly because of the order
    in which the classes are loaded. You might want to see the next section in such
    scenarios!
  prefs: []
  type: TYPE_NORMAL
- en: 'After overriding `SubTaskManager` as discussed before, we will see the message
    printed into the server logs every time a subtask is created, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-11-15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While overriding a component, using the **Component** **Plugins** module is
    the recommended way, the same thing can be done in a couple of other ways.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding by modifying JIRA code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For people who have modified the JIRA Source distribution, overriding the component
    can be done in a single line. After creating the new component—implementing the
    interface that we want to override—we can modify the `registerComponents` method
    in `com.atlassian.jira.ContainerRegistrar` class to include the new class instead
    of the default class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, `SubTaskManager` can be overridden by replacing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'With:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Note that components can either by `INTERNAL` meaning that they will be available
    only to JIRA itself or `PROVIDED` in which case they will also be available to
    `plugins2` plugins.
  prefs: []
  type: TYPE_NORMAL
- en: Overriding by extending PicoContainer
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Prior to JIRA 4.3, there was a provision in JIRA to extend the PicoContainer
    and register the custom components in the extended PicoContainer. The following
    is how it was done:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `PicoContainer` class that implements `ContainerProvider` interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `getContainer` method that builds a container from the parent
    and includes the new registrations. For our earlier example, the class will look
    similar to the following block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `MySubtaskManager` will be created exactly the same way.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Register the new container provider in the `jira-application.properties` file,
    residing at `atlassian-jira/WEB-INF/classes` folder, using the key `jira.extension.container.provider`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Deploy the JAR file with the new container class and component class under `WEB-INF/lib`
    folder and restart JIRA.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This works in JIRA 4.3 as well though deprecated. From 4.4, it still works
    but the `jira.extension.container.provider` property must be added in `jpm.xml`
    file instead of `jira-application.properties`. The property will be added as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: Creating issues and comments from e-mail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to automatically create issues or comments in JIRA based on incoming
    e-mail messages. This feature is very useful in scenarios such as helpdesks where
    the users normally send an e-mail to a designated e-mail address and the support
    team works on issues raised such as this one!
  prefs: []
  type: TYPE_NORMAL
- en: Once configured correctly, any new e-mail that comes in will create a corresponding
    issue in JIRA and the replies to the e-mail notifications on that issue will be
    created as comments on that issue. It is also possible to attach documents on
    the issue by attaching them on the e-mail provided attachments that are enabled
    in JIRA. If external user management is not enabled, it is still possible to create
    a user account—if they don't already have an account.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how we can configure JIRA to enable this feature.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are the steps to enable issue creation from e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: Create an e-mail account on the server—typically, one e-mail account for each
    JIRA project. This mailbox should be accessible via POP, IMAP, or on the local
    file system. JIRA will periodically scan this mailbox and create issues or comments
    based on the e-mail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to JIRA's **Administration** | **Global** **Settings** | **Mail** **Servers**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Configure new POP / IMAP mail server** link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter the details for the POP or IMAP mail server created in *Step* *1* and
    click on **Add**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the details on the **Mail** **Servers** page and modify if needed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to JIRA **Administration** | **System** | **Services**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new service with the following details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Name**: Name of the service'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Class**: Pick one from the list of Built-in services. `com.atlassian.jira.service.services.pop.PopService`
    for example.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Delay**: Choose a delay for the service to run and scan the mails.'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Adding the service will take you to the **Edit** **Service** page. Populate
    the details as follows and update:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handler** : Select **Create** **Or** **Comment** **Handler** from the drop
    down box'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Handler** **Parameters**: This is the most important part where we specify
    the parameters that will be used while creating the issue. Following are the list
    of important parameters:'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '`project`: Key of the project where the issue should be created'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`issuetype`: Unique ID of the `issuetype`. For example, if we want the issue
    to be created as a Bug, provide `issuetype` as 1.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`createusers`: if set to true, accounts will be created for new senders.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`reporterusername`: Can be used to create issue with the specified reporter
    when the sender does not match with an existing user.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`notifyusers`: Only used if `createusers` is true. Indicates whether users
    should get a mail notification for the new accounts created.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ccassignee`: If set, the new issue will be assigned to a matching user in
    To field or in Cc field if no one matches in To field.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bulk`: Determines how to handle "bulk" e-mails. Values possible are:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ignore`: Ignore the e-mail and do nothing.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`forward`: Forward the e-mail to the address set in the "Forward Email" text
    field.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`delete`: Delete the e-mail permanently.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`catchemail`: If added, JIRA will process only e-mails sent to this address.
    It is used when there are multiple aliases for the same e-mail inbox.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stripquotes`: If enabled, it strips previous messages from replies.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Forward e-mail: Error notifications and un-handled e-mails (used in conjunction
    with bulk forward handle parameter) will be forwarded to this address.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Uses SSL: Select SSL if used.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Server: Select the e-mail server for this service. It will be the one we added
    in *Step* *2* to *Step* *4*.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Port: It is the port to connect to. Leave blank if default.'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: JIRA is now configured to receive mails to the newly added mailbox.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The service we have setup here scans the mailbox every **n** minutes as configured
    in the delay and picks up the new incoming messages. When a new message is received,
    JIRA scans through the subject to see if there are any mentions of an already
    existing issue. If there is one, the e-mail is added as a comment on the mentioned
    issue with the e-mail body as the comment text. If there is no mention of an issue
    in the subject, JIRA still checks whether the e-mail is a reply to another e-mail
    that already created an issue or not. If so, the e-mail body is again added as
    a comment on that issue. This is done by checking the `in-reply-to` header in
    the e-mail.
  prefs: []
  type: TYPE_NORMAL
- en: If JIRA still couldn't find any matching issues, a new issue is created in the
    project and of type configured in the handle parameters. The e-mail subject will
    become the issue, summary and e-mail body, the description.
  prefs: []
  type: TYPE_NORMAL
- en: Any attachments on an e-mail, new, or replies, will be added as attachments
    on the issue.
  prefs: []
  type: TYPE_NORMAL
- en: More information about the creation of issues and comments from an e-mail can
    be found at [http://confluence.atlassian.com/display/JIRA/Creating+Issues+and+Comments+from+Email](http://confluence.atlassian.com/display/JIRA/Creating+Issues+and+Comments+from+Email).
  prefs: []
  type: TYPE_NORMAL
- en: It is also worth checking the plugin exchange for plugins with extended mail
    handlers that are capable of adding more details on the issue while creation like
    custom field values. Some of them have far better filtering mechanisms as well.
  prefs: []
  type: TYPE_NORMAL
- en: Internationalization in webwork plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen in the earlier chapters how to write webwork plugins to create
    new or extended JIRA actions. In this recipe, we will see how we can personalize
    the messages in these plugins using **internationalization** and **localization**.
  prefs: []
  type: TYPE_NORMAL
- en: 'As Wikipedia puts it:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Internationalization and localization are means of adapting computer software
    to different languages, regional differences and technical requirements of a target
    market. Internationalization is the process of designing a software application
    so that it can be adapted to various languages and regions without engineering
    changes. Localization is the process of adapting internationalized software for
    a specific region or language by adding locale-specific components and translating
    text."'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The terms internationalization and localization are abbreviated to **i18n**
    where **18** stands for the number of letters between the first **i** and last
    **n** in internationalization!
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Internationalization in a webwork plugin is achieved with the help of a resource
    bundle with the same name as the action that it is associated with. Following
    are the steps to enable it in a JIRA webwork plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `properties` file with the same name as that of the action class under
    the same package structure under `src/main/resources` folder in the plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For example, if we consider the `RedirectAction` example in the previous recipes,
    the property file will be `RedirectAction.propertie`s residing under `src/main/resources/com/jtricks`
    folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the key value pair of properties that needs to be used in action as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `good.bye` is the key that will be used and will be same across all language
    `properties` files. The value here "Good Bye" will be used for the default locale
    but will have the equivalent translations in the other language property files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create `properties` files in the same folder for other required languages in
    the following format: `${actionName}_${languageCode}_${countryCode}.properties`.
    For example, if we need to personalize the above action for UK and US and French
    users, following will be the property filenames:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the property `good.bye` in each of the property files with the appropriate
    translation as the values. For example, a property with value `Good` `Bye` in
    the English property file will have value `revoir` in French!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the action class, use `getText(key)` method to retrieve the appropriate message.
    Keep in mind that the action `class` extends the `JiraWebActionSupport` class
    which implements the getText method!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example, the value `Good` `Bye` can be printed to users in different locales
    in their own language as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This magic however is broken in v2 plugins and there is already an issue reported
    with Atlassian at [https://jira.atlassian.com/browse/JRA-23720](https://jira.atlassian.com/browse/JRA-23720).
    The workaround is to override the `getTexts` method as follows in the action class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: Here we get the `ResourceBundle` using the class loader of the action class
    and that fixes the above issue in v2 plugins!
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we wind up, if you need to get the `i18N` texts in the velocity templates,
    following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the property files as before.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the resource entry in the `atlassian-plugin.xml` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the resource points to the property file with the package and name (omitting
    the country or language code).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `$i18n` object to retrieve the property values as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Sharing common libraries across v2 plugins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already explored creating both v1 and v2 plugins throughout this book.
    One major difference between v1 and v2 plugins is that the v1 plugins has got
    access to all the libraries and classes available in the application class path
    whereas v2 plugins can't access them.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the v1 plugins can access some common utility classes by dropping
    the JAR file with those classes in the `WEB-INF/lib` or adding those classes under
    `WB-INF/classes`. But that won't work with v2 plugins as they need the JAR files
    embedded with them under `MET-INF/lib` or the classes embedded in them. How will
    we handle this scenario when there is a utility class that we need to share across
    a few v2 plugins? Should we embed the class in all the plugins? The answer is
    no, and in this recipe, we will see how we can share those utility classes across
    v2 plugins by creating an OSGi bundle.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us assume we have a Number utility class that does summation and multiplication
    of integer numbers. What should we do if we want to make this class available
    in all the v2 plugins? The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the Utility class under the correct package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Export the classes that needs to be shared so that it is visible to other v2
    plugins. This step is very important.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Even though it is a simple utility class, we need the atlassian-plugin.xml for
    this step. We can use the `bundle-instructions` under `plugin-info` element in
    the `atlassian-plugin.xml` for exporting selected packages to other plugins/bundles.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The bundle-instructions element allows child elements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Export** **-** **Package**: To export selected packages from the plugin to
    be shared across other plugins'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Import** **-** **Package**: Tom import only selected packages into a plugin.
    By default it imports all the exported packages from other plugins.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In this case, we need to modify the atlassian-plugin.xml to export our utility
    class and this can be done as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is possible to export only selected versions and choose not to export certain
    packages. More details on this can be found at [http://www.aqute.biz/Bnd/Bnd](http://www.aqute.biz/Bnd/Bnd).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally, we can use the **Import-Package** element to import the above exported
    package. By default, it will anyways be imported and hence this step can be omitted.
    However it will be useful when you want to import only selected packages or make
    the import mandatory etc. Again, the details can be found in the above link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Package the plugin and deploy it as a v2 plugin.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now the utility class is available to all the other v2 plugins. When developing,
    the other plugins should have this class in the classpath which can be achieved
    by adding the above plugin as a dependency in the `pom.xml` with scope as provided.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'When we do that, the above method, add, can be invoked as if the class is within
    the same plugin. For example, the `RedirectAction` class may have the method as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: Operations using direct HTML links
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It probably make sense to wind up this book by giving a little tip on how we
    can do powerful operations in JIRA by a simple click on a link, either from your
    e-mail or a from a web form or from within JIRA itself!
  prefs: []
  type: TYPE_NORMAL
- en: Almost all the actions can be encoded into a single URL provided we have the
    right parameters to invoke those actions. Make no mistake, it has its own disadvantages
    because it will override all the pre-processing, validations, and so on, in place
    in some cases.
  prefs: []
  type: TYPE_NORMAL
- en: 'The URL that performs the action is constructed in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '`${baseUrl}/secure/${action}?${arguments}`'
  prefs: []
  type: TYPE_NORMAL
- en: where `baseUrl` is the JIRA base url, `action` is the webwork action to be executed
    and `arguments` is the URL encoded arguments needed for the action. The arguments
    are constructed as key value pairs separated by `&`. Each key value pair will
    be of the form `key=value` and must comply with HTML link syntax—that is, all
    characters must be escaped. Let us see in detail.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us consider a simple example to start with, i.e. creating issues. Creating
    an issue has four stages.
  prefs: []
  type: TYPE_NORMAL
- en: Going to initial create screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting the project and `issuetype` and clicking on **Next**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entering all the details on the issue
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking on **Submit** with details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can execute each of these in single steps provided we know the details in
    advance. For the example, let us take `http://localhost:8080/` as the base URL
    for the JIRA instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going to initial create issue screen can be done via the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/CreateIssue!default.jspa`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Note that the recent `project` and `issuetype` are pre-selected when you access
    this link because that is the JIRA default behavior. But what if we want to pre-select
    some other project? All we need is to add the parameters `pid` in the URL as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/CreateIssue!default.jspa?pid=10100`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we need to go to the second step directly by selecting the project and issuetype,
    just add the `issuetype` parameter as well into the URL separated by `&`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/CreateIssue!default.jspa?pid=10100&issuetype=1`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If we need to pre-populate create issue dialogue in one click, enter all the
    details in the URL as shown with the action name as `CreateIssueDetails!init.jspa`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/CreateIssueDetails!init.jspa?pid=10100&issuetype=1&priority=1&summary=Emergency+Bug&reporter=jobinkk`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that all the mandatory fields should be populated to avoid validation errors.
    The above example also shows how the URL is encoded to comply with HTML syntax
    by replacing space in the summary with a +. i.e. Emergency Bug is written as Emergency+Bug
    which can also be written as Emergency%20Bug.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And if we want to create the issue in one click with the details above, use
    `CreateIssueDetails` action instead of `CreateIssueDetails!init`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`http://localhost:8080/secure/CreateIssueDetails.jspa?pid=10100&issuetype=1&priority=1&summary=Emergency+Bug&reporter=jobinkk`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hopefully that gives as idea about how the operation can be executed via direct
    links. Make sure the user is logged or Anonymous issue creation is turned on when
    the above link are clicked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: But how do we find out what is the action class involved or what are the parameters
    to be passed?
  prefs: []
  type: TYPE_NORMAL
- en: 'This you can do easily from the browser URL if the request uses GET method.
    Create an issue with project and `issuetype` selected (case 2 above) is an example
    as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-11-16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the request is **POST** as in case 4, we can find out the action name
    from the URL but the parameters needs to be worked out from what is posted when
    the action is executed. There are multiple ways to do it and an easy way out of
    them will be to use the browser capabilities. For example, using **Firebug** with
    Mozilla Firefox will get you the parameters posted when an action is executed
    as shown below:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-11-17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we can see the parameters pid, issuetype, priority, summary and reporter
    getting submitted in the **POST** section. Also, we can see the action name. Once
    you get the list of parameters, we can user them in the URL with appropriate values
    separated by & as we saw in *Step* *4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This technique opens up lot of possibilities. For example, we can easily automate
    the submission of these URLs that we have constructed using command-line tools
    like `wget` or `curl`. Read about these more at: [http://confluence.atlassian.com/display/JIRA/Creating+Issues+via+direct+HTML+links](http://confluence.atlassian.com/display/JIRA/Creating+Issues+via+direct+HTML+links)
    And: [http://confluence.atlassian.com/display/JIRACOM/Automating+JIRA+operations+via+wget](http://confluence.atlassian.com/display/JIRACOM/Automating+JIRA+operations+via+wget).'
  prefs: []
  type: TYPE_NORMAL
