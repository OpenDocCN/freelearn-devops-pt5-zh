- en: Continuous Integration
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续集成
- en: When building software, quality assessment is something that usually is pushed
    toward the end of the life cycle, just before the release. When the team is working
    in a 6-months release cycle, the drawbacks are not as obvious as when the release
    cycle is just a few days old (or even hours!), but from my experience, I can tell
    you that getting early feedback in your software is crucial in order to raise
    the quality to a good level we are comfortable to live with.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件构建过程中，质量评估通常会被推到生命周期的末尾，发布之前。当团队在一个六个月的发布周期内工作时，这些缺点不如在发布周期只有几天（甚至几小时！）时那么明显，但根据我的经验，我可以告诉你，在软件开发早期就获取反馈对于将质量提高到我们可以接受的水平至关重要。
- en: 'There is a misconception in the software that puts the average software project
    in danger: the software has to be perfect*.* This is totally incorrect. Think
    about some of these real-world systems: the engine of your car, a nuclear plant,
    the water purification system in major cities, and so on; human lives depend upon
    all of them and they fail. A fair amount of money is spent on these systems without
    being able to ensure the total safety, so what makes you think that the software
    that your company writes will be perfect?'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 软件中存在一种误解，致使许多软件项目面临危险：软件必须是完美的*.* 这是完全错误的。想想这些真实世界中的系统：你汽车的引擎、核电站、大城市的水净化系统等等；这些系统关乎人命，并且它们也会失败。在这些系统上花费了大量资金，但无法确保完全安全，那你怎么认为你公司编写的软件就能做到完美呢？
- en: 'Instead of investing resources in making your software perfect, the experience
    has taught me (through the hard path) that it is a lot better to invest the resources
    in building the software in a way that makes it easy for the engineers to fix
    the problems as quickly as possible, being able to shorten the release cycles
    with enough level of confidence. In this chapter, we are going to examine the
    key components of the continuous integration:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与其将资源投入到使软件完美，不如我通过艰难的经验得出结论：更好的做法是将资源投入到构建软件的方式，使工程师能够尽可能快速地修复问题，并能够在有足够信心的情况下缩短发布周期。在本章中，我们将探讨持续集成的关键组成部分：
- en: Software development life cycle
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 软件开发生命周期
- en: 'Traditional CI servers:'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传统持续集成服务器：
- en: Bamboo
  id: totrans-6
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bamboo
- en: Jenkins
  id: totrans-7
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: 'Modern CI servers:'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现代持续集成服务器：
- en: Drone
  id: totrans-9
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone
- en: This has the objective of building an effective continuous integration pipeline
    to ensure reliability and enables us to deliver faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 其目标是建立一个有效的持续集成流水线，以确保可靠性，并使我们能够更快地交付产品。
- en: Software development life cycle
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 软件开发生命周期
- en: 'The software development life cycle is the diagram of our day to day activity
    as software engineers wait, this book is about DevOps; what are we doing talking
    about software engineering? Well, in theory, DevOps is the role of the IT activity
    that covers the full life cycle of a software component, from the inception to
    the release and further maintenance. Nowadays, many companies are hiring DevOps
    engineers on the basis of hiring system administrators on steroids that even though
    it works, it completely misses the biggest advantage of the DevOps role: having
    someone on the team with exposure to all the aspects of the software so that problems
    can be solved quickly without involving people from different teams in the majority
    of the cases.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发生命周期是我们作为软件工程师的日常活动图表，等等，这本书是关于DevOps的；那我们为什么要谈论软件工程呢？理论上讲，DevOps是IT活动的一部分，涵盖了软件组件的完整生命周期，从初期到发布再到后续的维护。如今，许多公司正在招聘DevOps工程师，基于招聘强化版的系统管理员，尽管这种做法有效，但它完全忽视了DevOps角色的最大优势：让团队中有人接触软件的所有方面，这样问题就可以快速解决，而无需涉及来自不同团队的人。
- en: 'Before proceeding further, let''s take a look at how the software development
    life cycle works:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在进一步讨论之前，让我们看看软件开发生命周期是如何运作的：
- en: '![](img/8fe57653-6bb9-4c79-91a2-97fe7be8e5f0.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fe57653-6bb9-4c79-91a2-97fe7be8e5f0.png)'
- en: 'This is the most classical and studied software development life cycle in IT
    literacy, something that everyone has gone through in college and everyone has
    as a mental model of even if we have not seen it before. Nowadays, with the agile
    methodologies, people tend to think that the model is obsolete. I think it is
    still a very valid model, but what it has changed is the scale and the involvement
    of the different stakeholders through the previous diagram. Let''s take a brief
    look at the objectives of every step in a top-to-bottom approach:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这是IT素养中最经典且最研究透彻的软件开发生命周期，几乎每个人在大学里都经历过这一过程，并且即使我们之前没见过，它也作为一种心理模型存在于每个人的脑海中。如今，随着敏捷方法的出现，人们倾向于认为这个模型已经过时。但我认为它仍然是一个非常有效的模型，唯一变化的是规模以及不同利益相关者在之前图示中的参与度。让我们从上到下简要地了解每个步骤的目标：
- en: '**Requirement analysis**: This is where we are going to encounter the majority
    of the problems. We need to find a common language between people outside of IT
    (accountants, marketers, farmers, and so on) and people in IT, which often leads
    to different problems around terminology and even business flows being captured
    incorrectly.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**需求分析**：这是我们将遇到大部分问题的地方。我们需要在IT外部人员（如会计、市场营销人员、农民等）与IT人员之间找到共同的语言，这通常会导致术语不同，甚至商业流程被错误捕捉的问题。'
- en: '**Design**: In this phase, we are going to design our flows in a language that
    the IT crowd can understand straight away, so they will be able to code efficiently.
    Often, this phase overlaps with the requirement analysis (if the stakeholder is
    into IT) and that is desirable as diagrams are the perfect middle language that
    we are looking for.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设计**：在这一阶段，我们将使用IT人员可以立即理解的语言设计流程，这样他们就能够高效地编码。通常，这一阶段会与需求分析重叠（如果利益相关者本身就懂IT），这也是理想的情况，因为图表是我们正在寻找的完美中介语言。'
- en: '**Development**: As the name suggests, this is where the software is built.
    This is what developers do well: build technical artifacts that work and work
    well--according to a potentially flawed specification. This is where we need to
    be clever: no matter what we do, our software is going to be imperfect, and we
    need to plan accordingly. When we are working in agile environments, deliver early
    and deliver often is the mantra followed to minimize the impact of a wrong specification
    so that the stakeholders can test the product before the problem is too big to
    be tackled. I also believe that involving the stakeholders early enough is a good
    strategy, but it is not a silver bullet, so no matter what we do, our software
    has to be modular so we can plug and play modules in order to accommodate new
    requirements. In order to ensure the functionality of our modules on their own,
    we write unit tests that can be run quickly in order to ensure that the code is
    doing what it is supposed to do.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：顾名思义，这就是软件被构建的地方。这是开发人员擅长的事情：构建符合（可能有缺陷的）规范并且能够正常工作的技术制品。这里我们需要聪明：不管我们做什么，我们的软件都不可能完美无缺，我们需要相应地进行规划。当我们在敏捷环境中工作时，“尽早交付，频繁交付”是减少错误规范影响的座右铭，这样利益相关者就能在问题变得过大之前对产品进行测试。我还认为，尽早让利益相关者参与进来是一个不错的策略，但这不是万灵药，所以无论我们做什么，我们的软件必须是模块化的，以便我们可以插拔模块以适应新的需求。为了确保我们模块的功能正常，我们编写可以快速运行的单元测试，以确保代码按照预期的方式执行。'
- en: '**Testing**: This is where continuous integration lives. Our continuous integration
    server will run the testing for us when appropriated and inform us about the potential
    problems in our application as quickly as possible. Depending on the complexity
    of our software, our testing can be very extensive in this phase, but in general,
    the continuous integration server focuses on running integration and acceptance
    (that said, the integration server usually runs all the tests as the unit tests
    should be inexpensive to run).'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试**：这是持续集成存在的地方。我们的持续集成服务器将在适当时运行测试，并尽快通知我们应用程序可能存在的问题。根据软件的复杂性，在这一阶段我们的测试可能非常广泛，但一般来说，持续集成服务器专注于运行集成测试和验收测试（也就是说，集成服务器通常会运行所有测试，因为单元测试应该是低成本的）。'
- en: '**Release**: In this phase, we deliver the software to what we call production;
    people start using the software, and no matter how much effort we put in the previous
    phases, there will be bugs and that is the reason why we planned our software
    to be able to fix the problems quickly. In the release phase, we can create something
    that we will see later on in this book, called **Continuous Delivery** (**CD**)
    pipelines, which enables the developers to execute the build-test-deploy cycle
    very quickly (even a few times a day).'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**：在这个阶段，我们将软件交付到所谓的生产环境中；人们开始使用软件，无论我们在前期阶段投入多少精力，都难免会出现Bug，这也是我们设计软件时希望能快速修复问题的原因。在发布阶段，我们可以创建一些稍后将在本书中看到的东西，称为**持续交付**（**CD**）流水线，它使开发人员能够非常快速地执行构建-测试-部署周期（甚至每天几次）。'
- en: '**Maintenance**: There are two types of maintenance: evolutive and corrective.
    Evolutive maintenance is where we evolve our software by adding new functionalities
    or improving business flows to suit the business needs. Corrective maintenance
    is the one where we fix bugs and misconceptions. We want to minimize the latter
    but we cannot totally avoid it.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护**：维护有两种类型：演化性和修正性。演化性维护是通过添加新功能或改进业务流程来推动软件的发展，以适应业务需求。修正性维护是修复错误和误解的过程。我们希望将后者最小化，但不能完全避免。'
- en: Testing types
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试类型
- en: 'In the previous section, we talked about different types of tests:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了不同类型的测试：
- en: '**Unit tests**: What we call white box tests are what mock the dependencies
    and test the business flow of a particular piece of code.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试**：我们所说的白盒测试是模拟依赖项并测试特定代码片段的业务流程。'
- en: '**Integration tests**: These are designed to test the integration between different
    components of an application and they do not test the business logic extensively.
    Sometimes, when the software is not very complex, the integration tests are used
    as unit tests (especially in dynamic languages), but this is not the most common
    use case.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**集成测试**：这些测试旨在验证应用程序不同组件之间的集成，而不是广泛地测试业务逻辑。有时，当软件不太复杂时，集成测试被用作单元测试（尤其是在动态语言中），但这并不是最常见的使用场景。'
- en: '**Acceptance tests**: Designed to test business assumptions, these are usually
    built on the principle of what we know as user stories describing situations with
    the style of being given an assumption.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试**：这些测试旨在验证业务假设，通常基于我们所称的用户故事原理，描述具有“给定假设”风格的情境。'
- en: 'Every test has a different objective, and they work well together, but keep
    the following diagram in your mind:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试有不同的目标，它们协同工作，但请记住以下图示：
- en: '![](img/c42d749d-a598-4031-b89b-2a6065f485bd.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c42d749d-a598-4031-b89b-2a6065f485bd.png)'
- en: 'This is what I call the pyramid of testing, and there are years of experience
    (not only mine) behind it: your software should have a whole bunch of unit testing,
    fewer integration tests, and some acceptance tests. This ensures that the majority
    of your business logic is covered by the unit tests and the integration and acceptance
    tests are used for more specific functions. Also, the integration and acceptance
    tests are usually more expensive, so minimizing their its usage is usually something
    that''s recommended (but not at the cost of dropping the test coverage).'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我所说的测试金字塔，背后有多年的经验（不仅仅是我的）：你的软件应该有大量的单元测试，较少的集成测试，以及一些验收测试。这可以确保大部分业务逻辑被单元测试覆盖，集成测试和验收测试用于更特定的功能。此外，集成测试和验收测试通常更昂贵，因此通常建议最小化它们的使用（但前提是不降低测试覆盖率）。
- en: When working with a CI server, usually, the developer runs the **unit tests**
    on his computer as they are quick and should spot a big amount of the potential
    problems, leaving the integration and acceptance tests to the CI server, which
    will run while the developer is working on other tasks.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当与CI服务器协作时，通常开发人员会在自己的计算机上运行**单元测试**，因为它们快速且能够发现大量潜在问题，将集成测试和验收测试留给CI服务器，在开发人员进行其他任务时运行这些测试。
- en: Traditional CI servers
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传统CI服务器
- en: 'In this section, we are going to walk through the most traditional CI servers:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍最传统的CI服务器：
- en: Bamboo
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bamboo
- en: Jenkins
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins
- en: They have been around for quite a while and even though they are heavily used
    in the enterprise world, they are losing some grasp against the new and more modern
    CI servers such as Drone or Travis (although Travis has been around for a while,
    it has been reinvented to work on the cloud).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 它们已经存在一段时间了，尽管它们在企业界得到了广泛使用，但在与新的、更现代的CI服务器（如Drone或Travis）相比，它们的优势正在逐渐减弱（尽管Travis已经存在一段时间，但它已被重新设计以支持云端工作）。
- en: Bamboo
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Bamboo
- en: '**Bamboo** is a proprietary CI server that is developed by Atlassian. Atlassian
    is a software company that specializes in tools for developers. Products such
    as JIRA and Bitbucket are created by Atlassian and they are well known in the
    IT world. Bamboo is their proposal for CI activities, and it is quite popular
    as it integrates fairly well with their other products.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**Bamboo**是由Atlassian开发的专有CI服务器。Atlassian是一家专注于为开发者提供工具的软件公司。像JIRA和Bitbucket这样的产品由Atlassian开发，并在IT界广为人知。Bamboo是他们为CI活动提供的解决方案，并且因与其他产品的良好集成而非常受欢迎。'
- en: 'Let''s install it. In order to do that, please visit Bamboo''s home page at
    [https://confluence.atlassian.com/bamboo/](https://confluence.atlassian.com/bamboo/)
    and follow the instructions in the quick start guide. As you can see, the installation
    is quite simple, and after generating the evaluation license and some steps (express
    installation), you should have bamboo running on your local computer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们安装它。为此，请访问Bamboo的主页：[https://confluence.atlassian.com/bamboo/](https://confluence.atlassian.com/bamboo/)并按照快速入门指南中的说明操作。如你所见，安装过程非常简单，生成评估许可证并经过一些步骤（快速安装）后，你应该能在本地计算机上运行Bamboo：
- en: '![](img/197335a7-5918-457e-a803-6643d215004b.png)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![](img/197335a7-5918-457e-a803-6643d215004b.png)'
- en: If you click on the button labeled Create your first build plan, you can see
    how easy it is to set up jobs in Bamboo. In this case, we can use one of the open
    source projects that I created in the past called **Visigoth**, a load balancer
    with circuit breaking capabilities used for interconnecting microservices. The
    GitHub repository is located at [https://github.com/dgonzalez/visigoth](https://github.com/dgonzalez/visigoth).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击标有“创建你的第一个构建计划”的按钮，你会发现设置Bamboo中的作业非常简单。在这个例子中，我们可以使用我之前创建的一个开源项目——**Visigoth**，它是一个带有断路器功能的负载均衡器，用于微服务之间的互联。GitHub仓库位于[https://github.com/dgonzalez/visigoth](https://github.com/dgonzalez/visigoth)。
- en: Fork it into your GitHub repository if you want to modify it. Visigoth is a
    single component that does not interact with others, so only unit tests were created
    for it. Enter the clone URL of the repository into the appropriate field, in this
    case, Git repository, and submit the form.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想修改它，可以将其分叉到你的GitHub仓库中。Visigoth是一个单一组件，彼此之间不互相作用，因此只为其创建了单元测试。在相应的字段中输入仓库的克隆URL，在此情况下为Git仓库，然后提交表单。
- en: If you have the **Time-based One-Time Password** (**TOTP**) protection in your
    GitHub account, you might need to choose Git repository with no authentication
    instead of GitHub repository in the source part of the form to create a test plan.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的GitHub账户启用了**基于时间的一次性密码**（**TOTP**）保护，你可能需要在表单的源部分选择“无认证的Git仓库”，而不是选择“GitHub仓库”来创建测试计划。
- en: 'Once you finish creating the plan, it will ask you to add tasks to your test
    plan, which, at the moment, is only checking out the source code from Git. In
    this case, Visigoth is a Node.js application, and as such, the tests are run by
    executing the `npm test` command. In order to run the command, we need to add
    two tasks of the `type` command. The first task will be used to install the dependencies
    of the application and the second one to run the tests. Let''s add the first one:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你完成了创建计划的步骤，它将要求你为测试计划添加任务，目前，这些任务仅包括从Git检出源代码。在这种情况下，Visigoth是一个Node.js应用程序，因此，测试是通过执行`npm
    test`命令来运行的。为了执行此命令，我们需要添加两个`type`命令任务。第一个任务将用于安装应用程序的依赖项，第二个任务将用于运行测试。让我们先添加第一个任务：
- en: '![](img/a2b24fe9-fdae-4e5c-9d5b-7174af91496c.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a2b24fe9-fdae-4e5c-9d5b-7174af91496c.png)'
- en: As you can see, I have added one executable by clicking on Add new executable
    by specifying the path where `NPM` is, which can be found by executing `which
    npm` in the terminal of the machine where you installed Bamboo.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我通过点击“添加新可执行文件”并指定`NPM`所在路径来添加了一个可执行文件。你可以通过在安装Bamboo的机器的终端执行`which npm`来找到该路径。
- en: You will need to install Node.js on the same machine where you installed Bamboo
    in order to run the tests. The current LTS version will work fine with it, but
    Visigoth was tested with Node 6.x.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在安装了Bamboo的同一台机器上安装Node.js才能运行测试。当前的LTS版本与之兼容良好，但Visigoth是在Node 6.x上进行测试的。
- en: 'Now we are going to add the second command, which will execute `npm test` in
    order to run the tests. This command will only be executed if the two previous
    steps (checking out the code [Checkout Default Repository) and installing the
    dependencies (NPM install)] are successful:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加第二个命令，它将执行`npm test`来运行测试。该命令只会在前两个步骤（检出代码[Checkout Default Repository]和安装依赖[NPM
    install]）成功后执行：
- en: '![](img/e812b9b3-9b8b-48c5-b17b-799b0c748e1c.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e812b9b3-9b8b-48c5-b17b-799b0c748e1c.png)'
- en: 'Once you save the task, we have completed all the actions that we need to execute
    in order to run the tests in Visigoth. Now, the only thing left is to run the
    job:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦保存了任务，我们就完成了执行Visigoth测试所需的所有操作。现在，剩下的唯一任务就是运行该作业：
- en: '![](img/b3701c63-b5f2-45cf-a1a4-e6b9fc90aab9.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b3701c63-b5f2-45cf-a1a4-e6b9fc90aab9.png)'
- en: If everything is correct, you should get a green badge and a message of success.
    As you can see, my build failed in previous runs as I was adjusting the CI server
    to run Visigoth.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该会看到一个绿色的徽章和成功的消息。正如你看到的，我的构建在之前的运行中失败了，因为我正在调整CI服务器以运行Visigoth。
- en: You can check the logs of the job to see how many tests were successful and
    other useful information. If you explore this even further, you can see how Bamboo
    also offers different types of tasks, such as mocha test runners, which allows
    Bamboo to understand the result of the tests. At the moment, with the current
    configuration, if any of the tests fails, Bamboo won't be able to understand which
    one failed. I'd suggest you to play around with different configurations and even
    different applications to get yourself familiar with it. As you can see by yourself,
    the interface is very friendly, and usually, it is quite simple to achieve your
    desired setup by creating new tasks.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以查看作业的日志，看看有多少测试成功通过以及其他有用的信息。如果你进一步探索，你还会看到Bamboo提供了不同类型的任务，比如mocha测试运行器，这使得Bamboo能够理解测试结果。目前，在当前配置下，如果任何测试失败，Bamboo将无法识别失败的是哪个测试。我建议你尝试不同的配置，甚至不同的应用程序，以便熟悉它。正如你自己所看到的，界面非常友好，通常通过创建新任务，达到你期望的配置也相当简单。
- en: By default, Bamboo creates something called **trigger**. A trigger is an action
    that leads to a test plan being executed. In this case, if we change the GitHub
    repository from where the job was created, the test plan will be triggered to
    verify the changes, ensuring the continuous integration of new code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Bamboo会创建一个名为**触发器**的东西。触发器是一种导致测试计划执行的操作。在这种情况下，如果我们更改了作业创建时使用的GitHub仓库，测试计划将被触发以验证更改，确保新代码的持续集成。
- en: Another interesting type of trigger is the time-based one. This type of trigger
    allows us to run the build overnight, so if our tests take several minutes or
    even hours to run, we can do it when no one is using the server. This type of
    trigger has saved me from bugs derived from the daylight time savings hour adjustment,
    causing some tests to fail due to code fragments not handling the change across
    different time zones well.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种有趣的触发器类型是基于时间的触发器。这种类型的触发器允许我们在夜间运行构建，因此如果我们的测试需要几分钟甚至几个小时才能完成，我们可以在没人使用服务器时执行它。此类触发器帮助我避免了由于夏令时调整导致的一些错误，这些错误会导致某些测试失败，因为代码片段无法很好地处理跨时区的时间变化。
- en: 'In general, Bamboo can deal with every situation, and it has adapted to the
    modern times: we can even build Docker images and push them to remote registries
    once the tests have passed in order to be deployed later on. Bamboo is also able
    to take actions in the post-build phase, for example, alerting us if the build
    failed overnight with an email or other communication channels.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，Bamboo能够应对各种情况，并且已经适应了现代的需求：我们甚至可以在测试通过后构建Docker镜像，并将其推送到远程注册表，以便后续部署。Bamboo还能够在构建后的阶段采取行动，例如，如果构建在夜间失败，它会通过电子邮件或其他通信渠道通知我们。
- en: Jenkins
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Jenkins
- en: I have worked with Jenkins for quite a while now, and I have to say that I feel
    really comfortable working with it as I know it is free, open source, and also
    highly customizable. It has a powerful and well-documented API that enables users
    to automate pretty much anything related to continuous integration. In [Chapter
    8](127a7b5f-4bd7-4290-bea0-3e8db867e4af.xhtml), *Release Management – Continuous
    Delivery*, we are going to set up a continuous delivery pipeline with Jenkins
    in order to be able to release new versions of an application in a transparent
    manner once the test results are satisfactory, enabling our team to focus on development
    and automating all the deployment-related activities.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经使用 Jenkins 一段时间了，我必须说，使用它让我感到非常舒适，因为我知道它是免费的、开源的，并且高度可定制。它有一个强大且文档完善的 API，使用户能够自动化几乎与持续集成相关的所有事务。在[第8章](127a7b5f-4bd7-4290-bea0-3e8db867e4af.xhtml)，*发布管理
    – 持续交付*，我们将设置一个持续交付管道，使用 Jenkins 以便在测试结果满意时能够透明地发布应用程序的新版本，使我们的团队能够专注于开发，并自动化所有与部署相关的活动。
- en: Jenkins is also modular, which enables developers to write plugins to extend
    functionalities, for example, sending messages to a Slack channel if the build
    fails or running Node.js scripts as a part of a job.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 也是模块化的，这使得开发人员可以编写插件来扩展功能，例如，在构建失败时向 Slack 渠道发送消息，或将 Node.js 脚本作为作业的一部分执行。
- en: On the scalability side, Jenkins, like Bamboo, can be scaled to hundreds of
    nodes through a master/slave configuration so that we can add more power to our
    CI server in order to execute some tasks in parallel.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在可扩展性方面，Jenkins 像 Bamboo 一样，可以通过主从配置扩展到数百个节点，从而为我们的 CI 服务器增加更多的计算能力，以便并行执行一些任务。
- en: On its own, Jenkins will be enough to provide contents for a couple of books,
    but we are going to visit what we need to set up automated jobs for testing our
    applications. It is also possible to write plugins for Jenkins, so virtually,
    there is no limit to what it can do.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 就其本身而言，Jenkins 足以提供几本书的内容，但我们将探讨设置自动化作业以测试应用程序所需的内容。也可以为 Jenkins 编写插件，因此，实际上它的功能没有限制。
- en: 'Let''s focus on the operational side of Jenkins for now. In order to run Jenkins,
    we have two options:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们先关注 Jenkins 的操作方面。为了运行 Jenkins，我们有两个选择：
- en: Running it as a Docker container
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 Docker 容器的方式运行
- en: Installing it as a program in your CI server
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其作为程序安装在您的 CI 服务器上
- en: 'For now, we are going to install Jenkins, using its Docker image as it is the
    simplest way of running it and it fits our purpose. Let''s start. The first thing
    is running a simple instance of Jenkins from the command line:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用 Jenkins 的 Docker 镜像进行安装，因为这是运行它的最简单方式，并且适合我们的目的。让我们开始吧。首先要做的是通过命令行运行一个简单的
    Jenkins 实例：
- en: '[PRE0]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This will run Jenkins, but be aware that all the information about configuration
    and builds executed will be stored within the container, so if you lose the container,
    all the data is lost as well. If you want to use a volume to store the data, the
    command that you need to execute is as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这将运行 Jenkins，但要注意，所有关于配置和执行的构建信息都将存储在容器中，因此如果丢失容器，所有数据也会丢失。如果您想使用一个卷来存储数据，需要执行的命令如下：
- en: '[PRE1]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will create a volume that you can reuse later on when upgrading to new
    versions of Jenkins or even restarting the same container. After running the command,
    the logs will show something similar to what is shown in the following figure:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个可以在升级到新版本的 Jenkins 或甚至重新启动相同容器时重用的卷。运行该命令后，日志将显示类似于以下图示的内容：
- en: '![](img/ff8c85aa-209a-4a0d-8848-ba6cf875f196.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff8c85aa-209a-4a0d-8848-ba6cf875f196.png)'
- en: 'This is the initial password for Jenkins and it is necessary in order to set
    up the instance. After a few seconds, the logs of the container will stop, which
    means your Jenkins server is ready to be used. Just open the browser and go to
    `http://localhost:8080/`, and you will see something similar to this:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 Jenkins 的初始密码，设置实例时需要用到它。几秒钟后，容器的日志将停止，这意味着您的 Jenkins 服务器已准备好使用。只需打开浏览器，访问`http://localhost:8080/`，您将看到类似于以下内容的界面：
- en: '![](img/233698b1-6878-42d5-b60d-72b9f6fc8f33.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/233698b1-6878-42d5-b60d-72b9f6fc8f33.png)'
- en: 'This is where you can enter Administrator password, which we saved earlier,
    and click on the Continue button. The next screen will ask you whether it should
    install the suggested plugins or whether you want to select which plugins to install.
    Choose the suggested plugins. After a few minutes, it will let you create a user
    and that''s it. Jenkins is up and running in a container:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是您可以输入先前保存的管理员密码，并单击“继续”按钮的位置。接下来的屏幕将询问您是否应安装建议的插件，或者您是否想选择要安装的插件。请选择建议的插件。几分钟后，它将允许您创建用户，就这样。Jenkins
    正在一个容器中运行：
- en: '![](img/b5c79c48-f1d6-42ea-a9a9-cf9fa59c6064.png)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5c79c48-f1d6-42ea-a9a9-cf9fa59c6064.png)'
- en: 'Now we are going to create a new job. We are going to use the same repository
    as we used with Bamboo so we can compare the two integration servers. Let''s click
    on Create a new project. You should be presented with the following form:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将创建一个新的作业。我们将使用与 Bamboo 相同的代码库，以便我们可以比较这两个集成服务器。让我们点击“创建新项目”。您将看到以下表单：
- en: '![](img/c1d6a180-4ed8-4cc3-b31e-c63a1c30d993.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c1d6a180-4ed8-4cc3-b31e-c63a1c30d993.png)'
- en: 'Just enter a name for the project and choose the first option: Freestyle project.
    Jenkins has different types of projects. Freestyle project is a type of project
    where we can define the steps, as we did in Bamboo. Another interesting option
    is the type Pipeline where we can, through a **DSL** (known as **Domain Specific
    Language**), define a set of steps and stages, creating a pipeline that can be
    saved as code.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 只需为项目输入名称，并选择第一个选项：自由样式项目。Jenkins 有不同类型的项目。自由样式项目是一种我们可以定义步骤的项目类型，就像我们在 Bamboo
    中所做的那样。另一个有趣的选项是流水线类型，我们可以通过一个称为 **DSL**（即 **领域特定语言**）的语言定义一组步骤和阶段，创建可以保存为代码的流水线。
- en: The following screen is where we configure the project. We are going to use
    Git with the repository hosted at [https://github.com/dgonzalez/visigoth.git](https://github.com/dgonzalez/visigoth.git).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的屏幕是我们配置项目的地方。我们将使用 Git，其存储库托管在 [https://github.com/dgonzalez/visigoth.git](https://github.com/dgonzalez/visigoth.git)
    上。
- en: 'You can use your fork if you previously forked it while working with Bamboo.
    Your configuration should be similar to the what is shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前在 Bamboo 中创建了分支，则可以使用您的分支。您的配置应与以下屏幕截图所示类似：
- en: '![](img/ead57bdb-c870-47d6-9eff-669d2f8a56b6.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ead57bdb-c870-47d6-9eff-669d2f8a56b6.png)'
- en: 'Now we need to install the dependencies of Visigoth with the `npm install --development`
    command and execute the tests with the `npm test` command, but we are running
    Jenkins from a container and this container does not have Node.js installed. We
    are going to use our Docker knowledge to install it. Inspecting the Dockerfile
    of the Jenkins image in the Docker Hub, we can verify that it is based on Debian
    Jessie (it is based on OpenJDK but that is based on Debian Jessie) so we can install
    the required software in it. The first thing that needs to be done in order to
    install software is gain root access to the container. As you learned in [Chapter
    2](6b4e8014-1c44-495b-b22b-e84fb1b944b8.xhtml), *Cloud Data Centres - The New
    Reality*, we can execute commands on the running container. Let''s run the following
    command:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要使用 `npm install --development` 命令安装 Visigoth 的依赖项，并使用 `npm test` 命令执行测试，但我们是从容器中运行
    Jenkins，而这个容器并未安装 Node.js。我们将利用我们的 Docker 知识来安装它。检查 Docker Hub 中 Jenkins 镜像的 Dockerfile，我们可以验证它基于
    Debian Jessie（它基于 OpenJDK，但是它基于 Debian Jessie），因此我们可以在其中安装所需的软件。要安装软件的第一步是获得容器的
    root 访问权限。正如您在 [第二章](6b4e8014-1c44-495b-b22b-e84fb1b944b8.xhtml) 中所学到的，“云数据中心
    - 新的现实”，我们可以在正在运行的容器上执行命令。让我们执行以下命令：
- en: '[PRE2]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This command executes `/bin/bash` in the container with the ID `eaaef41f221b`
    (it will change in your system as it is unique per container) but with the user
    that matches the user ID `0`, in this case, root. We need to do this because the
    Jenkins image defines and uses a new user called `jenkins` with a known UID and
    GID so if the `-u 0` flag is not passed, the `/bin/bash` command will be executed
    by the user `jenkins`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 ID 为 `eaaef41f221b` 的容器中以 UID 和 GID 为 `0` 的用户（在您的系统中将会有所不同，因为每个容器的 ID 都是唯一的）执行
    `/bin/bash`。我们需要这样做是因为 Jenkins 镜像定义并使用一个名为 `jenkins` 的新用户，其具有已知的 UID 和 GID，因此如果未传递
    `-u 0` 标志，则 `/bin/bash` 命令将由用户 `jenkins` 执行。
- en: 'Once we are root in the container, proceed to install Node.js:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们在容器中获得了 root 权限，继续安装 Node.js：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'And once the execution of the previous command is finished, run the following
    one:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦上一个命令的执行完成，运行以下命令：
- en: '[PRE4]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: And that's it. From now on, our Jenkins container has an installation of Node.js
    available to run Node.js scripts. That said, we should avoid installing software
    in production containers. Our containers should be **immutable artifacts** that
    do not change through their life cycle, so what we should do is commit the changes
    in this image and tag it as a new version in order to release it into our production
    container. As we don't have a production container, we are making the changes
    as we go.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。从现在开始，我们的 Jenkins 容器有了 Node.js 的安装，可以运行 Node.js 脚本。也就是说，我们应该避免在生产容器中安装软件。我们的容器应该是**不可变的工件**，在生命周期内不做更改，因此我们应该将这个镜像的更改提交并标记为新版本，以便将其发布到生产容器中。由于我们没有生产容器，所以我们边做边修改。
- en: 'Our containers in production should be immutable artifacts: if we need to change
    their status, we create a new version of the image and redeploy it instead of
    modifying the running container.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生产环境中的容器应该是不可变的工件：如果我们需要更改它们的状态，我们会创建新版本的镜像并重新部署，而不是修改正在运行的容器。
- en: 'Once Node.js is installed, we can just exit the root shell within the container
    and go back to Jenkins to complete our tasks. As we did with Bamboo, here are
    our tasks in order to run our tests:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Node.js，我们可以退出容器中的 root shell，然后回到 Jenkins 完成我们的任务。就像我们在 Bamboo 中做的一样，以下是我们运行测试所需要的步骤：
- en: '![](img/fbb53be3-ffce-4470-aa06-eefbe8515c96.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbb53be3-ffce-4470-aa06-eefbe8515c96.png)'
- en: In the very bottom of the job configuration, there is a section called **post-build**
    actions. This section allows you to execute actions once the job is finished.
    These actions include sending e-mails, adding commit messages to the Git repository,
    among others. As we previously mentioned, Jenkins is extensible and new actions
    can be added by installing new plugins.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在作业配置的最底部，有一个叫做 **post-build** 的操作部分。这个部分允许你在作业完成后执行一些操作。这些操作包括发送电子邮件、将提交信息添加到
    Git 仓库等。如我们之前提到的，Jenkins 是可扩展的，通过安装新插件，可以添加新的操作。
- en: Jenkins can also parametrize builds with input from the user.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 还可以通过用户输入对构建进行参数化。
- en: 'Once you have added these two steps to the build, just click on Save and we
    are all set: you now have a fully functional Jenkins job. If we run it, it should
    successfully run the tests on Visigoth.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你添加了这两个步骤到构建中，点击保存，我们就完成了：现在你已经拥有一个完全功能的 Jenkins 作业。如果我们运行它，它应该能够成功运行 Visigoth
    上的测试。
- en: Secrets Management
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 密钥管理
- en: One of the possibilities of the CI server is the ability to talk to third-party
    services that usually rely on some sort of credentials (such as access tokens
    or similar) to authenticate the user. Exposing these secrets would be discouraged
    as they could potentially cause major harm to our company.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: CI 服务器的一个功能是能够与通常依赖某种凭证（如访问令牌或类似物品）来验证用户身份的第三方服务进行通信。暴露这些密钥是不被鼓励的，因为它们可能会对我们的公司造成重大损害。
- en: 'Jenkins handles this in a very simple way: it provides a way to store credentials
    in a safe way that can be injected into the build as environment variables so
    that we can work with them.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 以非常简单的方式处理此问题：它提供了一种安全存储凭证的方法，可以将这些凭证作为环境变量注入到构建中，以便我们可以使用它们。
- en: Let's look at some examples. First, we need to create the secrets in Jenkins.
    In order to do that, we have to go to Manage Jenkins from the home page.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们来看一些示例。首先，我们需要在 Jenkins 中创建密钥。为此，我们需要从首页进入管理 Jenkins 页面。
- en: 'Once we are there, you should see a screen very similar to this one:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们到达那里，你应该看到一个非常相似的界面：
- en: '![](img/7846e9f9-5e2c-4e1f-9633-cdeb51ad4e4f.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7846e9f9-5e2c-4e1f-9633-cdeb51ad4e4f.png)'
- en: We are using the Global credentials store as we just want to showcase how it
    works, but Jenkins allows you to box credentials so you can restrict access across
    different usages. In Jenkins, credentials, aside from being injected into the
    build context, can be connected to plugins and extensions so that they can authenticate
    against third-party systems.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的是全局凭证存储，因为我们只是想展示其工作原理，但 Jenkins 允许你将凭证封装起来，以便你可以在不同的使用场景下限制访问权限。在 Jenkins
    中，凭证除了可以注入到构建上下文外，还可以连接到插件和扩展，以便它们可以对第三方系统进行身份验证。
- en: 'Now, we click on Add Credentials on the left-hand side:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击左侧的“添加凭证”按钮：
- en: '![](img/f717e503-2da1-4b60-a474-4d1716bbc3da.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f717e503-2da1-4b60-a474-4d1716bbc3da.png)'
- en: 'There are some fields that we need to fill before proceeding, but they are
    very basic:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，有些字段需要我们填写，但它们非常基础：
- en: 'Kind: This is the type of secret that we want to create. If you open the drop-down,
    there are several types, from files to certificates, walking through usernames
    and passwords.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型：这是我们想要创建的秘密类型。如果打开下拉菜单，会有几种类型，从文件到证书，涵盖用户名和密码等。
- en: 'Scope: This is the scope of our secret. The documentation is not 100% clear
    (at least not in the first read) but it allows us to hide the secret from certain
    stances. There are two options: Global and System. With Global, the credentials
    can be exposed to any object within Jenkins and its child, whereas with System,
    the credentials can be exposed only to Jenkins and its nodes.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围：这是我们秘密的作用范围。文档不是100%清晰（至少第一次阅读时不清晰），但它允许我们在某些情况下隐藏秘密。这里有两个选项：全局（Global）和系统（System）。选择全局时，凭据可以暴露给Jenkins及其子对象中的任何对象，而选择系统时，凭据只能暴露给Jenkins及其节点。
- en: The rest of the fields are dependant on the type of secret. For now on, we are
    going to create a `Username with password` secret. Just select it in the dropdown
    and fill in the rest of the details. Once it is created, it should show in the
    list of credentials.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 其余字段取决于秘密的类型。接下来，我们将创建一个`用户名与密码`类型的秘密。只需在下拉菜单中选择它并填写其余细节。创建完成后，它应该会出现在凭据列表中。
- en: 'The next step is to create a job that is bound to those credentials so we can
    use them. Just create a new freestyle project, as we saw in the beginning of this
    section, but we are going to stop on the screen where we can configure the job,
    precisely in the Build Environment section:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个绑定到这些凭据的任务，以便我们可以使用它们。只需像本节开始时看到的那样创建一个新的自由风格项目，但我们将在配置任务的屏幕上停下来，特别是在构建环境部分：
- en: '![](img/62534e70-5f74-40f4-b828-ba2da9d6a033.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![](img/62534e70-5f74-40f4-b828-ba2da9d6a033.png)'
- en: 'Now select Username and password (conjoined). Conjoined username and password
    means that we get the full secret (the username and the password) in a single
    variable, whereas with separated, we get the secret split in two variables: one
    for the username and another one for the password.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在选择用户名和密码（联合）。联合用户名和密码意味着我们在一个变量中获得完整的秘密（用户名和密码），而分开则会将秘密分成两个变量：一个用于用户名，另一个用于密码。
- en: 'Once we select it, the form to create the binding is fairly simple:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们选择了它，创建绑定的表单就非常简单：
- en: '![](img/7288f18b-c9c2-4911-8824-ffabdae70d27.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7288f18b-c9c2-4911-8824-ffabdae70d27.png)'
- en: 'We get to choose the Variable where we want to store the secret and we also
    get to choose which secret. There is a radio button that lets you choose between
    Parameter expression or Specific credentials as we can parametrize the job to
    get input from the user on the triggering screen. In order to showcase how well
    thought Jenkins is, we are going to add a Build step that uses the secret by just
    echoing it into the logs:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择存储秘密的变量，并且还可以选择具体的秘密。有一个单选按钮可以让你选择“参数表达式”或“特定凭据”，因为我们可以将任务参数化，让用户在触发屏幕中输入内容。为了展示Jenkins设计的周全，我们将添加一个构建步骤，通过将秘密回显到日志中来使用它：
- en: '![](img/dffe14d5-f5ec-4f76-9748-8818b39f9fa2.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/dffe14d5-f5ec-4f76-9748-8818b39f9fa2.png)'
- en: 'Click on the Save button to save the job and run it. Once the job execution
    finishes, go to the result and click on Console Output. If you were expecting
    to see the secret in here, Jenkins has a surprise for you:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 点击保存按钮以保存任务并运行它。一旦任务执行完成，转到结果并点击控制台输出。如果你原本期待在这里看到秘密，Jenkins将给你一个惊喜：
- en: '![](img/3674ed99-ede8-4ebf-a0c4-32dcafd46a35.png)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3674ed99-ede8-4ebf-a0c4-32dcafd46a35.png)'
- en: The secret has been masked in order to prevent exposure to unauthorized users.
    This is not bullet proof, as someone could easily dump the secret from a test
    within an application checked out by Jenkins, but it adds some level of security
    in there, leaving the rest to the code reviews and processes.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止未授权用户暴露秘密，该秘密已被掩码处理。虽然这种方法并非万无一失，因为有人可能会轻易地从通过Jenkins检查出的应用程序中的测试中提取该秘密，但它确实为安全性提供了一定的保障，剩下的则依赖于代码审查和流程。
- en: Modern CI servers
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现代CI服务器
- en: One thing that is clear in IT is that the market moves very fast, and every
    few years, a new trend breaks what was considered the perfect solution for a problem.
    CI software is not an exception to this. In the last few years (taking into account
    that this book was written in 2017), Infrastructure as Code has drawn a lot of
    attention to the DevOps world, but in CI, its equivalent is Pipelines as Code.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在 IT 领域，有一件事是明确的，那就是市场发展非常迅速，每隔几年，就会有一个新的趋势打破曾经被认为是完美解决方案的问题。CI 软件也不例外。在过去的几年中（考虑到本书是
    2017 年写的），基础设施即代码（Infrastructure as Code）吸引了大量的关注，而在 CI 中，其对应的概念是流水线即代码（Pipelines
    as Code）。
- en: Jenkins and Bamboo have added support for declarative pipelines recently, but
    they are not built around them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins 和 Bamboo 最近已经添加了对声明式流水线的支持，但它们并不是围绕这个概念构建的。
- en: Drone CI
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Drone CI
- en: Drone is probably the newest CI server in the market. I decided to introduce
    it in this chapter as it was a big revelation to me when I found out about it
    working in nearForm Ltd. By that time, I was well used to Jenkins and it suited
    every single use case that I could come across in my professional life, from CI
    to continuous delivery and sometimes even as a bastion host using a feature called
    callback URL, where a job could be triggered by sending an HTTP request to a specific
    URL.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: Drone 可能是市场上最新的 CI 服务器。我决定在本章介绍它，因为当我在 nearForm Ltd. 了解到它时，它对我来说是一个巨大的启示。那时，我已经习惯了
    Jenkins，它适用于我在职业生涯中遇到的每一个用例，从 CI 到持续交付，有时甚至作为堡垒主机，使用一种叫做回调 URL 的功能，在这个功能下，工作可以通过向特定
    URL 发送 HTTP 请求来触发。
- en: Drone is built around the concept of containers. Everything in Drone is a container,
    from the server to where the test runs, but the most interesting part is that
    even the plugins are containers. This makes it easy to write new plugins for executing
    custom actions, as the only requirement is that the containers return `0` as the
    exit code if it was successful and a nonzero exit code if it was not successful.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Drone 是基于容器概念构建的。Drone 中的所有内容都是容器，从服务器到测试运行的地方，最有趣的部分是，甚至插件也是容器。这使得编写新的插件以执行自定义操作变得非常容易，唯一的要求是，如果容器成功完成，必须返回
    `0` 作为退出代码，如果不成功，则返回非零退出代码。
- en: For Jenkins or Bamboo, writing a plugin requires a few hours of testing and
    reading documentation. For Drone, we just need to know how to build a Docker image
    and what task we want to accomplish.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Jenkins 或 Bamboo，编写插件需要几个小时的测试和阅读文档。而对于 Drone，我们只需要知道如何构建 Docker 镜像以及我们想要完成的任务。
- en: Be aware that Drone is still in the version 0.5 and moves very quickly, so by
    the time you read this book, Drone might have changed significantly, but I wanted
    to include it as I think it is a very promising software.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，Drone 仍然处于 0.5 版本，并且发展非常快速，因此在你阅读本书时，Drone 可能已经发生了显著变化，但我还是决定包括它，因为我认为它是一个非常有前途的软件。
- en: Installing Drone
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Drone
- en: In order to install Drone, we are going to use `docker-compose`, and it is going
    to be configured to work with GitHub.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了安装 Drone，我们将使用 `docker-compose`，并将其配置为与 GitHub 一起使用。
- en: 'Drone, like Docker, follows a client-server architecture, so we can find two
    differentiated components, the server and the CLI. The first part we are going
    to proceed with is with the server. Take a look at the following `docker-compose`
    file:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Drone 和 Docker 一样，遵循客户端-服务器架构，因此我们可以找到两个不同的组件：服务器和 CLI。我们将首先继续进行服务器部分的配置。请查看以下
    `docker-compose` 文件：
- en: '[PRE5]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are two containers running in the preceding Docker Compose file: a server
    and an agent. Up until version 0.4, Drone master could execute builds, but after
    that, an agent is needed to run builds. There are some secrets that we need to
    configure before proceeding that are being passed into compose via environment
    variables (with the `${VAR_NAME}` notation):'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的 Docker Compose 文件中，运行了两个容器：一个是服务器，另一个是代理。在 0.4 版本之前，Drone 的主节点可以执行构建，但在此之后，需要一个代理来运行构建。在继续之前，我们需要配置一些秘密信息，这些信息通过环境变量传递给
    Compose（使用`${VAR_NAME}`符号）：
- en: '`DRONE_GITHUB_CLIENT`: As we specified earlier, we are going to use GitHub
    as the origin of our source code to be tested. This is provided on GitHub when
    registering a new OAuth application needed for Drone. You can create OAuth applications
    in the settings section of GitHub. Be careful; one of the parameters that you
    need in order to create a GitHub OAuth application is the callback URL. In this
    case, we are going to use `http://localhost/authorize` as we are working on our
    local machine.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRONE_GITHUB_CLIENT`：如前所述，我们将使用GitHub作为源代码的来源，以便进行测试。在GitHub上注册一个新的OAuth应用时，这个值会提供给你。你可以在GitHub的设置部分创建OAuth应用。小心，创建GitHub
    OAuth应用时需要的参数之一是回调URL。在这种情况下，我们将使用`http://localhost/authorize`，因为我们在本地计算机上工作。'
- en: '`DRONE_GITHUB_SECRET`: In the same way as `DRONE_GITHUB_CLIENT`, this is provided
    when a new OAuth application is created on GitHub.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRONE_GITHUB_SECRET`：与`DRONE_GITHUB_CLIENT`相同，这是在GitHub上创建新OAuth应用时提供的。'
- en: '`DRONE_SECRET`: This is an arbitrary string shared with the agent and the master.
    Just create a simple string, but when running a drone in production, make sure
    that the string is long enough so it cannot be guessed.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRONE_SECRET`：这是一个与代理和主服务器共享的任意字符串。你只需创建一个简单的字符串，但在生产环境中运行Drone时，确保字符串足够长，以免被猜到。'
- en: 'In order to get Drone working with the GitHub integration, we need to receive
    callbacks from GitHub. Once we have all the values, we just need to run the following
    command:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Drone与GitHub集成工作，我们需要从GitHub接收回调。一旦我们获取到所有的值，我们只需要运行以下命令：
- en: '[PRE6]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In one line, we are setting the three variables that we need, apart from running
    `docker-compose up`. If everything went as expected, when you browse `http://localhost`,
    you should see a window similar to the following one:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在一行命令中，我们设置了所需的三个变量，并运行了`docker-compose up`。如果一切顺利，当你访问`http://localhost`时，应该能看到类似下面的窗口：
- en: '![](img/5c92457f-2d38-483b-ba70-5429f8537e1e.png)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/5c92457f-2d38-483b-ba70-5429f8537e1e.png)'
- en: If you click on login, Drone should redirect you to GitHub for authorization
    and then GitHub will redirect you to the callback URL specified when creating
    the OAuth application, which is your local Drone installation, `http://localhost/authorize`.
    Sometimes, it might require some tweaking, but in general, it is very easy to
    make it work. As you can see, Drone leverages the authentication to GitHub so
    a GitHub account is required to log in.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果点击登录，Drone应该会将你重定向到GitHub进行授权，然后GitHub会将你重定向到创建OAuth应用时指定的回调URL，即你的本地Drone安装地址`http://localhost/authorize`。有时可能需要一些调整，但一般来说，非常容易让它工作。如你所见，Drone利用GitHub的身份验证，因此需要一个GitHub账号来登录。
- en: 'Now we are going to proceed with the CLI. It is as easy as visiting [http://readme.drone.io/0.5/install/cli/](http://readme.drone.io/0.5/install/cli/)
    and choosing the right version for your platform, in my case, macOS. Just place
    the binary in the path and you are ready to go. In order to configure the location
    of the Drone server, you need to specify two environment variables:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将继续进行CLI配置。只需访问[http://readme.drone.io/0.5/install/cli/](http://readme.drone.io/0.5/install/cli/)并选择适合你平台的版本，在我的案例中是macOS。只需将二进制文件放在路径中，你就可以开始使用了。为了配置Drone服务器的位置，你需要指定两个环境变量：
- en: '`DRONE_SERVER`: This is the URL to your Drone server, in this case, `http://localhost`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRONE_SERVER`：这是你的Drone服务器的URL，在这种情况下是`http://localhost`'
- en: '`DRONE_TOKEN`: Once you are logged into Drone, navigate to Account and click
    on Show token. This is the value that you need'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DRONE_TOKEN`：登录Drone后，进入帐户页面并点击显示令牌。这就是你需要的值'
- en: 'Once you have set up the two variables, execute the following command:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 设置好这两个变量后，执行以下命令：
- en: '[PRE7]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This should show your GitHub username and the e-mail that you used to register.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会显示你的GitHub用户名和你用来注册的电子邮件。
- en: Running builds
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行构建
- en: 'Drone has a different philosophy when it comes to running builds: it reacts
    to changes in the code on the remote repository by triggering the pipeline. Let''s
    create a super simple repository with a very simple Node.js application. I have
    created it on my GitHub account in order to make everything easier: [https://github.com/dgonzalez/node-example-drone/](https://github.com/dgonzalez/node-example-drone/).
    Just fork it into your own account, and you are good to go.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: Drone在运行构建时有不同的理念：它通过触发管道来响应远程仓库中代码的变化。我们来创建一个超级简单的仓库，里面有一个非常简单的Node.js应用。我已经在我的GitHub账户上创建了这个仓库，为了让一切更加简单：[https://github.com/dgonzalez/node-example-drone/](https://github.com/dgonzalez/node-example-drone/)。只需将其fork到你自己的账户，就可以开始了。
- en: 'The first thing that we need to do is activate the project in your local Drone
    installation. Just go to Account, and in the list of repositories, activate `node-example-drone`.
    Now it should show in the home screen in a manner similar to the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是激活你本地Drone安装中的项目。只需进入账户，在仓库列表中激活`node-example-drone`。现在，它应该像下面的截图一样出现在主屏幕上：
- en: '![](img/4d391aa6-47d1-41fb-98be-6e72b96cf318.png)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4d391aa6-47d1-41fb-98be-6e72b96cf318.png)'
- en: 'Now we are facing a small problem: Drone was created to trigger builds using
    a webhook delivered from GitHub into our Drone server. As we are working in a
    private network, we need to somehow expose our server to the Internet. In this
    case, we are going to use a service called **Ngrok** ([http://www.ngrock.com](http://www.ngrock.com))
    in order to expose Drone to the internet, which is not necessary when working
    in a production environment as it should be accessible over the internet (or at
    least through a proxy). Just follow the instructions, and once you run it in the
    Terminal, it should look very similar to what is shown in the following screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们面临一个小问题：Drone是为了触发通过GitHub发送到我们的Drone服务器的webhook而创建的。由于我们在一个私有网络中工作，我们需要以某种方式将我们的服务器暴露到互联网。在这种情况下，我们将使用一个叫做**Ngrok**的服务（[http://www.ngrock.com](http://www.ngrock.com)），以便将Drone暴露到互联网，而在生产环境中工作时这并不是必要的，因为它应该可以通过互联网访问（或者至少通过代理访问）。只需按照说明操作，一旦在终端运行它，它应该和下面的截图非常相似：
- en: '![](img/2756ecbc-fdca-4bdc-8217-7e93c30b44eb.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2756ecbc-fdca-4bdc-8217-7e93c30b44eb.png)'
- en: This specifies which host is being forwarded to your local address, in my case,
    `http://852cc48a.ngrok.io`. Just open it in your browser and check whether Drone
    is accessible from there.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这指定了哪个主机被转发到你的本地地址，在我的例子中是`http://852cc48a.ngrok.io`。只需在浏览器中打开它，检查是否可以从那里访问Drone。
- en: One thing left to do is edit the webhook that Drone installed in our GitHub
    repository when we activated it. You will find it in the repository settings on
    GitHub. Just edit the webhook to change the URL from `http://localhost` to your
    Ngrok URL, in my case, `http://852cc48a.ngrok.io`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下一件事，就是编辑Drone在我们激活时安装在GitHub仓库中的webhook。你可以在GitHub的仓库设置中找到它。只需编辑webhook，将URL从`http://localhost`更改为你的Ngrok
    URL，在我的例子中是`http://852cc48a.ngrok.io`。
- en: Executing pipelines
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行管道
- en: 'Now the setup is complete, before doing anything else, take a look at the `.drone.yaml`
    file of the forked repository:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在设置完成，在做任何事情之前，先看一下forked仓库中的`.drone.yaml`文件：
- en: '[PRE8]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This is our pipeline, and as you can guess, it gets committed alongside our
    code into our repository. Drone is going to execute the instructions in this pipeline
    when GitHub delivers the webhook into our Drone installation. As Drone works with
    containers, the first thing that Drone is going to do is create an image based
    on the node (as we specified) and run the following operations:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们的管道，正如你所猜测的，它会和我们的代码一起提交到仓库中。当GitHub将webhook传送到我们的Drone安装时，Drone会执行此管道中的指令。由于Drone与容器一起工作，Drone首先会基于我们指定的node创建一个镜像，并执行以下操作：
- en: It installs the dependencies
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会安装依赖
- en: It runs the tests
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它会运行测试
- en: If the exit code of the container that executes these commands is `0`, our build
    is successful and you can test it by pushing some changes to your GitHub repository
    and watching how Drone reacts to them.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果执行这些命令的容器的退出代码是`0`，那么我们的构建就成功了，你可以通过推送一些更改到你的GitHub仓库，并观察Drone如何响应来进行测试。
- en: 'There is also another way to re-trigger builds (not for the first time) via
    the CLI interface. Open the Terminal, and after configuring the environment variables
    previously stated (if you haven''t done it yet), run the following command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一种通过CLI接口重新触发构建的方法（不是第一次）。打开终端，在配置好之前提到的环境变量后（如果你还没有做），执行以下命令：
- en: '[PRE9]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will return a list of all the previously executed builds. Just change
    `dgonzalez` to your username, as you can see in the web interface. In order to
    rerun a previous build, we can run the following command:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个已执行构建的列表。只需将`dgonzalez`更改为你的用户名，正如你在网页界面中看到的那样。为了重新运行之前的构建，我们可以执行以下命令：
- en: '[PRE10]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This command fires off a build in Drone that was already built. This is particularly
    useful when you suspect that the build failed due to external factors.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令触发了一个已构建的Drone构建。这在你怀疑构建因外部因素而失败时特别有用。
- en: Sometimes, the webhook fails (particularly with the setup that we have with
    Ngrok), but GitHub allows you to debug that in the webhooks section of your repository.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，webhook 会失败（尤其是我们与 Ngrok 的设置），但 GitHub 允许你在仓库的 webhook 部分调试这个问题。
- en: This is the simplest case of a pipeline. As mentioned earlier, Drone is based
    on plugins, and those plugins are also Docker images. The list is quite comprehensive
    and can be found at [https://github.com/drone-plugins](https://github.com/drone-plugins).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 这是管道的最简单案例。如前所述，Drone 基于插件，这些插件也是 Docker 镜像。插件列表非常全面，可以在[https://github.com/drone-plugins](https://github.com/drone-plugins)找到。
- en: 'Let''s assume that we want to push our image to the **Google Container Registry**
    in Google Cloud. We are going to use the plugin called `drone-gcr` from [https://github.com/drone-plugins/drone-gcr](https://github.com/drone-plugins/drone-gcr).
    Here is our pipeline:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想将镜像推送到 Google Cloud 中的 **Google Container Registry**。我们将使用来自[https://github.com/drone-plugins/drone-gcr](https://github.com/drone-plugins/drone-gcr)的插件
    `drone-gcr`。这是我们的管道：
- en: '[PRE11]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'What we have here is a two-stage pipeline: it first executes the tests, and
    once they are successful, it deploys the image to Google Cloud Registry. We have
    different phases in the pipeline that we can use:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个两阶段的管道：它首先执行测试，一旦测试成功，就将镜像部署到 Google Cloud Registry。我们在管道中有不同的阶段可以使用：
- en: '**Build**: For building the tests and the related commands'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**构建**: 用于构建测试和相关命令'
- en: '**Publish**: Used to publish the artifact in a remote repository'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布**: 用于将工件发布到远程仓库'
- en: '**Deploy**: Very useful for continuous integration as it allows us to deploy
    our software in a continuous delivery manner'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署**: 对于持续集成非常有用，因为它允许我们以持续交付的方式部署软件'
- en: '**Notify**: Used to send notifications via email, slack, or any other channel'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知**: 用于通过电子邮件、Slack 或其他任何渠道发送通知'
- en: 'For example, if we wanted to send a Slack notification, we would just need
    to add the following lines to our pipeline:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想发送一个 Slack 通知，我们只需要将以下几行添加到管道中：
- en: '[PRE12]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Remember, YAML is sensitive to tabs and spaces so notify needs to be at the
    same level as publish or build.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，YAML 对制表符和空格非常敏感，因此 `notify` 需要与 `publish` 或 `build` 在同一级别。
- en: Other features
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他功能
- en: At the time of writing this, Drone is being actively developed, with new features
    being added and along with some major reworks. It also offers other features,
    such as secret management and support services.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，Drone 正在积极开发中，不断添加新功能，并进行一些重大重构。它还提供了其他功能，如秘密管理和支持服务。
- en: With secret management, we can inject secrets that get encrypted and stored
    in a database and only injected into builds that have been cryptographically signed
    by our drone CLI with a valid token from our Drone server.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 通过秘密管理，我们可以注入加密后的秘密，这些秘密存储在数据库中，只有在我们的 Drone CLI 使用来自 Drone 服务器的有效令牌进行加密签名后，才会注入到构建中。
- en: Drone also offers support services, which are services that run alongside your
    tests. This is very helpful when our integration tests depend on a database or
    when we need to spin third-party software such as Hashicorp Vault or a service
    discovery infrastructure such as Consul or Eureka.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: Drone 还提供支持服务，这些服务在测试期间与测试一起运行。当我们的集成测试依赖数据库，或需要启动像 Hashicorp Vault 这样的第三方软件，或者像
    Consul 或 Eureka 这样的服务发现基础设施时，这非常有用。
- en: It is expected that in future, Drone will have more features, but at the moment,
    it is going through major changes as it is being actively developed (unlike more
    mature servers, such as Jenkins, that have been around for a while).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 预计未来 Drone 将会有更多功能，但目前它正在经历重大变化，因为它正在积极开发（与像 Jenkins 这样的成熟服务器不同，后者已经存在了一段时间）。
- en: Summary
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: 'In this chapter, we walked through three different CI tools:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了三种不同的 CI 工具：
- en: Bamboo, a commercial tool
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Bamboo，一种商业工具
- en: Jenkins, an industry standard open source tool
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Jenkins，一种行业标准的开源工具
- en: Drone, a cutting-edge technology CI server
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Drone，一款尖端技术的 CI 服务器
- en: We discussed the key features of Jenkins that we are going to use going forward
    in this book, but we also showcased how Drone has leveraged the concept of containers
    into a very powerful CI system that, even though not mature yet, I expect to become
    the norm in the coming years.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本书中讨论了将来要使用的 Jenkins 的关键特性，但我们也展示了 Drone 如何将容器的概念融入一个非常强大的 CI 系统，尽管它还不够成熟，但我预计在未来几年将成为行业标准。
- en: The important concepts that we need to be aware of were explained, but to summarize,
    we use our integration server to run our tests for us so we can offload developers
    from doing that but also run the tests overnight in order to ensure that the daily
    build is stable.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要注意的重要概念已经解释过了，但总结来说，我们使用集成服务器来为我们运行测试，这样可以让开发人员不需要做这些工作，同时也能在夜间运行测试，以确保每日构建的稳定性。
- en: In the next chapter, we will visit what the community has called I**nfrastructure
    as Code:** basically, a way of dealing with our infrastructure as if code was,
    managing resources on a very elegant way.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章，我们将探讨社区所称的I**nfrastructure as Code:** 基本上是一种将我们的基础设施视为代码来处理的方式，优雅地管理资源。
