<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Polishing Your Routine – How to Increase Everyday Productivity</h1></div></div></div><p>
<em>We scratched the surface of version control system concepts to understand how Git can make us more efficient in doing our work. Without any delay we also quickly grabbed a copy of it and got it up and running in our systems.</em>
</p><p>
<em>I hear you shouting with excitement, "Let's dive in!".</em>
</p><p>Aye aye, Captain, here we go. In this chapter you will look at five important concepts, which is all you really need most of the time in your workplace:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initiating the process</li><li class="listitem" style="list-style-type: disc">Adding your files to the cabin (repository)</li><li class="listitem" style="list-style-type: disc">Committing the added files</li><li class="listitem" style="list-style-type: disc">Checking out</li><li class="listitem" style="list-style-type: disc">Resetting</li></ul></div><p>That's right, just five concepts are all you need to create a difference. And of course we shall learn how to get back on track with Git's built-in helper functions if you get lost along the way.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec20"/>Suit up – getting ready for your Git</h1></div></div></div><p>Let's say you have a magic wand, and it will do exactly what you order it to do! Yeah, that's right, you have <a id="id122" class="indexterm"/> Git now. You need to command Git to do what it has to do for you.</p><p>Sounds fun, right?</p><p>We already read that to maintain multiple versions of files they have to be kept inside a directory (folder), so we shall create a directory called <code class="literal">Workbench</code> <a id="id123" class="indexterm"/> on your desktop to learn the concepts explained in chapters hands on.</p><p>When it comes to handling computers there are people who would like to get the job done with either of the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">GUI mode (graphical user interface)</li><li class="listitem" style="list-style-type: disc">CLI mode (command-line interface)</li></ul></div><p>A combination of both can also be used. In the interest of serving a diverse audience, we shall try to cover both modes of implementation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec21"/>Initiation</h1></div></div></div><p>Initiation <a id="id124" class="indexterm"/> is nothing but a process of pointing your finger towards that directory so that Git will know it has to monitor its contents for changes from then on.</p><p>As we discussed earlier, we shall cover both ways (GUI and CLI) of performing these operations.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Time for action – initiation in GUI mode</h1></div></div></div><p>To create/initiate a repository, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <strong>Git Gui</strong> <a id="id125" class="indexterm"/> from your desktop or from your <a id="id126" class="indexterm"/> applications menu and select the option <strong>Create New Repository</strong>, as shown in the following screenshot:<div><img src="img/7522_03_01.jpg" alt="Time for action – initiation in GUI mode"/></div></li><li class="listitem">Git will present <a id="id127" class="indexterm"/> you with a new screen, expecting from you the <a id="id128" class="indexterm"/> location of the directory that you want to make a repository. So click the on the <strong>Browse</strong> button, select our <strong>Workbench</strong> directory from the desktop, and click on the <strong>Create</strong> button.<div><img src="img/7522_03_02.jpg" alt="Time for action – initiation in GUI mode"/></div></li><li class="listitem">You should get a screen as follows:<div><img src="img/7522_03_03.jpg" alt="Time for action – initiation in GUI mode"/></div><p>Now don't close this window; we shall continue from this screen for our remaining concepts.</p></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec22"/>
<em>What just happened?</em>
</h2></div></div></div><p>You have successfully <a id="id129" class="indexterm"/> commanded Git to monitor your <code class="literal">Workbench</code> directory <a id="id130" class="indexterm"/> and its contents.</p><p>The previous image showed the master page, which we will be interacting with very often. It consists of four panes; let's call them the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Unstaged Changes</strong> pane (top left)</li><li class="listitem" style="list-style-type: disc"><strong>Staged Changes</strong> pane (bottom left)</li><li class="listitem" style="list-style-type: disc"><strong>Differential Content</strong> pane (top right)</li><li class="listitem" style="list-style-type: disc"><strong>Action</strong> pane (bottom right)</li></ul></div><p>In our example we created a new directory called <code class="literal">Workbench</code> <a id="id131" class="indexterm"/> and initiated it as a repository. You can also follow the same procedures to convert an existing directory that already holds your files into a repository for Git to monitor. When you do that, your files inside the repository will initially appear in the <strong>Unstaged Changes</strong> pane.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Time for action – initiation in CLI mode</h1></div></div></div><p>For those who like to hear the sounds of more keystrokes instead of clicks, there's always <strong>command-line interface</strong> (<strong>CLI</strong>) <a id="id132" class="indexterm"/> mode.</p><p>There has been a <a id="id133" class="indexterm"/> constant increase in the percentage of people <a id="id134" class="indexterm"/> who are quick with keyboard's key strokes, giving more priority to performing operations using keystrokes instead of mouse clicks wherever possible. This is also a main reason why <strong>Gmail</strong>
 <a id="id135" class="indexterm"/> introduced shortcut keys for almost all of its functions.</p><p>To create or initiate the repository using the command-line interface mode you need to do the following:</p><div><ol class="orderedlist arabic"><li class="listitem">Open your <strong>shell</strong> <a id="id136" class="indexterm"/> (command prompt in Windows or Terminal/Console in Mac/Linux).</li><li class="listitem">Go to your <code class="literal">Workbench</code> directory <a id="id137" class="indexterm"/> on your desktop using the <a id="id138" class="indexterm"/> <code class="literal">cd</code><strong> </strong>(change directory) command.</li><li class="listitem">Once you are inside the <code class="literal">Workbench</code> directory type <code class="literal">git init</code> and hit <em>Enter</em> to complete the initiation process.</li><li class="listitem">You should get a status message from Git saying <strong>Initialized empty Git repository in your/path/to/Workbench/directory/goes/here</strong>.<div><img src="img/7522_03_04.jpg" alt="Time for action – initiation in CLI mode"/></div></li></ol></div><p>Ah! The sound of keystrokes, so good to hear.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>
<em>What just happened?</em>
</h2></div></div></div><p>You have successfully commanded GIT to monitor our <code class="literal">Workbench</code> directory and its contents. <code class="literal">Init</code> is <a id="id139" class="indexterm"/> the <a id="id140" class="indexterm"/> operational keyword that <a id="id141" class="indexterm"/> initializes the repository.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Behind the screen</h2></div></div></div><p>This initiation process will create a directory called <code class="literal">.git</code> <a id="id142" class="indexterm"/> inside our <code class="literal">Workbench</code> directory. This directory is usually made <strong>read-only</strong>
 <a id="id143" class="indexterm"/> and <strong>hidden</strong>
 <a id="id144" class="indexterm"/> by Git to safeguard itself from accidental deletion or tampering by users. It's the place where Git will hold all the history about your files and changes made to them.</p><p>So be careful with that directory; deleting it will <em>wipe out</em> the entire history of your files present in that directory.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>Configure Git</h2></div></div></div><p>Gear up your <a id="id145" class="indexterm"/> Git installation <a id="id146" class="indexterm"/> for usage by configuring it properly. There are several reasons why you should configure Git before starting to use it, but discussing all of them now would be premature, so we shall learn about them as and when the necessity occurs. For now, as a bare minimum configuration to get started, we will tell our name and e-mail address to Git so that it can log the changes under our identity.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Time for action – configure Git in GUI mode</h1></div></div></div><p>To convey to Git our <a id="id147" class="indexterm"/> name <a id="id148" class="indexterm"/> and e-mail <a id="id149" class="indexterm"/> address using GUI mode follow these procedures:</p><div><ol class="orderedlist arabic"><li class="listitem">Select <strong>Options</strong> from the <strong>Edit</strong> menu of the screen that you left open after the initiation process.<div><img src="img/7522_03_05.jpg" alt="Time for action – configure Git in GUI mode"/></div><p>The configuration screen is divided into two halves.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Local configuration (left side – particularly our Workbench Repository)</li><li class="listitem" style="list-style-type: disc">Global configuration (right side – applies to all the repositories created using this installation)</li></ul></div></li><li class="listitem">Don't let the big screen with numerous options overwhelm you. Let's focus on the top portion alone for now and type our name and e-mail address in both local and global configurations as shown in the previous image, and hit the <strong>Save</strong> button.</li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>
<em>What just happened?</em>
</h2></div></div></div><p>By giving out our <a id="id150" class="indexterm"/> username <a id="id151" class="indexterm"/> and <a id="id152" class="indexterm"/> e-mail address both locally and globally we have provided ways for Git to identify and group the changes made to files present in any repository.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec02"/>Out of flow</h3></div></div></div><p>Just in case you closed the screen after the initiation process and were wondering how to go about getting to the same screen again, don't worry. There are two ways of getting back.</p><div><ol class="orderedlist arabic"><li class="listitem">Open up <strong>Git Gui</strong> where you will see a newly added option called <strong>Open Recent Repository</strong>, under which you can find our <strong>Workbench</strong> repository.<div><img src="img/7522_03_06.jpg" alt="Out of flow"/></div></li><li class="listitem">Locate <a id="id153" class="indexterm"/> the <code class="literal">Workbench</code><strong> </strong>directory on the <a id="id154" class="indexterm"/> desktop and right-click with your mouse <a id="id155" class="indexterm"/> on the folder. In the menu select <strong>Git GUI here</strong>. People<strong> </strong>who want to switch from CLI mode to GUI mode can use this option as well.</li></ol></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Time for action – configure Git in CLI mode</h1></div></div></div><p>To configure Git using <a id="id156" class="indexterm"/> 
 <a id="id157" class="indexterm"/> CLI you can use the following <a id="id158" class="indexterm"/> commands:</p><div><pre class="programlisting">
<strong>git config --global user.name "your full name"</strong>
<strong>git config --local user.name "your full name"</strong>
<strong>git config --global user.email "your email id"</strong>
<strong>git config --local user.email "your email id"</strong>
<strong>git config -l</strong>
</pre></div><div><img src="img/7522_03_07.jpg" alt="Time for action – configure Git in CLI mode"/></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>
<em>What just happened?</em>
</h2></div></div></div><p>By giving out our username and e-mail address both locally and globally we have provided ways for Git to identify and group the changes made to files present in any repository.</p><p>
<code class="literal">config</code> <a id="id159" class="indexterm"/> is <a id="id160" class="indexterm"/> the operational keyword that needs to be used with <code class="literal">git</code> to set up the configuration of Git. To set a global value we add the <code class="literal">--global</code> parameter with <a id="id161" class="indexterm"/> the command, and to set a local value we add the <code class="literal">--local</code> parameter with the command.</p><p>As the name indicates, global <a id="id162" class="indexterm"/> configuration is nothing but a global value for all repositories created in the system by that system user, whereas local configuration is the exact opposite. As you would have guessed by now, the parameters <code class="literal">user.name</code> and <code class="literal">user.email</code> are used to record the user's name and e-mail address, respectively.</p><p>To get a list of configurations set till date you can use the last command, which had the <code class="literal">–l</code> parameter. It lists all the configuration variables for you.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Adding your files to your directory</h1></div></div></div><p>Now that you <a id="id163" class="indexterm"/> have set a perfect base to operate on, let's move one step ahead by adding your files to the repository that you have created.</p><p>Whoa, wait! What's <a id="id164" class="indexterm"/> that term that we often came across earlier – <a id="id165" class="indexterm"/> <strong>repository</strong>?</p><p>Moving forward, we will address a directory/folder that has been pointed to Git to monitor as a repository.</p><p>Yeah, baby, learn Git lingo and impress your date! The process of adding files is as simple as copying and pasting or creating your files inside our repository and asking Git to watch them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Time for action – adding files to your directory (GUI and CLI mode)</h1></div></div></div><p>Let's create a Word <a id="id166" class="indexterm"/> document called <strong>content.docx </strong>that contains the text "I love <a id="id167" class="indexterm"/> working with Git. It's a simple, fast, and superb version control system<code class="literal">"</code> to learn and put in practice the functionalities mentioned at the beginning of our chapter (people who are not able to create a <code class="literal">.docx</code> file can proceed with any other document format such as <code class="literal">.odt</code>, <code class="literal">.txt</code>, and so on).</p><div><img src="img/7522_03_08.jpg" alt="Time for action – adding files to your directory (GUI and CLI mode)"/></div><p>Git will report to you about the files that have been added to our repository and will stand by for your instructions to proceed. Now we can go ahead and tell Git to monitor these files for changes by performing the steps that we will discuss next.</p><p>If you are using GUI mode, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Click on the <strong>Rescan</strong> button (or press <em>F5</em> on your keyboard) present in the <strong>Action</strong> pane.<div><img src="img/7522_03_09.jpg" alt="Time for action – adding files to your directory (GUI and CLI mode)"/></div></li><li class="listitem">Click on the page-like icon next to the filename to push the file to the <strong>Staged Changes</strong> pane.</li></ol></div><p>If you are using <a id="id168" class="indexterm"/> the CLI mode <a id="id169" class="indexterm"/> ,<strong> </strong>use the following commands:</p><div><pre class="programlisting">
<strong>git status</strong>
<strong>git add content.docx</strong>
</pre></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have successfully added our files to the repository.</p><p>By clicking on the <strong>Rescan</strong> button or typing the <code class="literal">git status</code> command we ordered our slave to list the changes that were made to the repository since its previous state. These changes are called unstaged changes, meaning changes that have happened since our last confirmed state of the repository.</p><p>These changes have to be confirmed by the user by moving them to the staged changes state, which is done by clicking on the file icon next to the filename or using the <code class="literal">git add</code> command.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Ignore 'em</h2></div></div></div><p>We just saw ways to put your files under Git's radar but there are numerous situations where one might want to avoid adding certain files into one's working repository. As a live case, after adding some content in the <code class="literal">content.docx</code> file <a id="id170" class="indexterm"/> and trying to add your files into the repository as seen in the previous step, some might have encountered the situation where Git reports (of course, after refreshing the Git GUI or using the <code class="literal">git status</code> command <a id="id171" class="indexterm"/> in CLI) changes made in two files, <strong>content.docx</strong> and <strong>~$ontent.docx</strong>, as shown in the following screenshot:</p><div><img src="img/7522_03_10.jpg" alt="Ignore 'em"/></div><p>This happens only if the opened <code class="literal">content.docx</code> Word document is not closed before refreshing or hitting the <code class="literal">git status</code> command.</p><div><img src="img/7522_03_11.jpg" alt="Ignore 'em"/></div><p>This is because Microsoft's Word application has a habit of saving your current workspace at regular intervals (which can be configured) in a temporary file for disaster recovery.</p><p>It is only because of this mechanism that Word prompts you with a file recovery dialog from where you can retrieve your latest changes when a proper save is not done before abrupt closure of the document.</p><div><img src="img/7522_03_12.jpg" alt="Ignore 'em"/></div><p>Not only Microsoft Word but all smart applications and editors follow such a procedure to comfort the end users. These files are automatically deleted once the corresponding source file is saved and closed properly. There would be no value added in controlling the versions of these temporary files.</p><p>So while adding files to your repository it is important that you exclude these temporary files before proceeding to the committing concept as the reversal would be a painful process.</p><p>This way of adding files to Git holds good for a few files, but when it comes to handling several files in the repository, clicking on the icon next to each of them or performing a <code class="literal">git add</code> <a id="id172" class="indexterm"/> for each file is going to be a time consuming and tiresome activity.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Bulk operations</h2></div></div></div><p>When you want to move <a id="id173" class="indexterm"/> several files from the <strong>Unstaged Changes</strong> area to the <strong>Staged Changes</strong> area you can use the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>GUI</strong>: Press <em>Ctrl</em> + <em>I</em> and select <strong>yes</strong> if there is a prompt about adding unknown files instead of clicking at each and every icon next to that file.</li><li class="listitem" style="list-style-type: disc"><strong>CLI</strong>: The command <code class="literal">git add .</code><strong> </strong>is the <a id="id174" class="indexterm"/> equivalent of pressing <em>Ctrl</em> + <em>I</em> when using GUI mode. It will stage all your changes at a single shot. The use of <strong>wildcard characters</strong> <a id="id175" class="indexterm"/> like <code class="literal">*.docx</code> is also permitted.<div><pre class="programlisting">
<strong>git add .</strong>
<strong>git add *.docx</strong>
</pre></div></li></ul></div><p>Using these options we can eliminate our tiresome process of adding a single file at a time, but it defeats the objective of excluding the temporary files from being added to the repository. So how do we combine the power of bulk operations along with the control to exclude certain files or file types?</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>.gitignore to the rescue</h3></div></div></div><p>To handle this smartly, Git has a provision. By creating a file called <a id="id176" class="indexterm"/> <code class="literal">.gitignore</code> inside the repository and entering the names of files or pattern of the filenames we can make Git exclude them.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Time for action – usage of .gitignore</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Open your text <a id="id177" class="indexterm"/> editor and type the following:<div><pre class="programlisting">~*.*</pre></div></li><li class="listitem">Save the file as <code class="literal">.gitignore</code> inside our <strong>Workbench</strong> repository, as shown in the following screenshot:<div><img src="img/7522_03_13.jpg" alt="Time for action – usage of .gitignore"/></div><p>Make sure to <a id="id178" class="indexterm"/> select the <strong>All Files</strong> option from the <strong>Save as type</strong> listbox when you save the file.</p></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>
<em>What just happened?</em>
</h2></div></div></div><p>We have successfully commanded Git to ignore the temporary file created by the Word application. Go ahead and refresh your GUI or get the status from your CLI now. The only addition to your <code class="literal">content.docx</code> file in the <strong>Unstaged Changes</strong> area would be the <code class="literal">.gitignore</code> file <a id="id179" class="indexterm"/> and not the temporary file.</p><p>Every time Git wants to check for new files (untracked changes) present in the repository it checks with the <code class="literal">.gitignore</code> file for exclusions. By observing the temporary file's name (<code class="literal">~$ontent.docx</code>) we can guess that any temporary file created by Word is going to start with the special character <strong>~</strong> so we put an entry in <code class="literal">.gitignore</code> to match all files starting with that character. The very entry <code class="literal">~*.*</code> under the <code class="literal">.gitignore</code> file says to exclude any filename starting with the character ~ with any extension.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Though addition of the <code class="literal">.gitignore</code> file itself is a one-time process, the exclusion rules inside the file have to be updated as per the nature and content type of the files added in the repository as required.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Undo addition</h2></div></div></div><p>At any given point of time <a id="id180" class="indexterm"/> before committing, if you want to move a file from the <strong>Staged Changes</strong> to the <strong>Unstaged Changes</strong> area you can do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>GUI</strong>: Click on the tick icon next to that particular filename present in the <strong>Staged Changes</strong> pane</li><li class="listitem" style="list-style-type: disc"><strong>CLI</strong>: Use the following command:<div><pre class="programlisting">
<strong>git reset filename.extension</strong>
</pre></div></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Committing the added files</h1></div></div></div><p>Until now we have <a id="id181" class="indexterm"/> initiated the repository, added our files into the repository, and confirmed those changes by staging them (pushing them to the staged changes stage) but until they are committed the files are not said to be under version control. (This is because only when you commit does Git record the content of the files and save it as a new phase of that file/files, so that next time it can identify whether the files have any change of content by comparing the existing version to the last saved version).</p><p>This is a new addition to your Git lingo: This process is called <a id="id182" class="indexterm"/> <strong>committing</strong>.</p><p>So let's make an initial commit of your files. The first time you add a file to the repository and make a commit, Git registers the new file. Any further commits made to these files inside the same repository will be a commit for the changes based on the previous version of the same file available in the repository.</p><p>Though Git follows your orders it has a healthy habit of associating a comment at the time of every single commit so that it can learn about your behavior and moods with respect to various file types and build an artificially intelligent system based on observed patterns to automate your routines.</p><p>Basically comments that you provide at each commit is just to help yourself or any other person reading the history of your repository understand the purpose of, and/or changes to, the files.</p><p>It's good to make a comment, which can be anything informative. Having learned the theory behind it, let's see it in action. </p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Time for action – committing files in GUI mode</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's type our <a id="id183" class="indexterm"/> reason <a id="id184" class="indexterm"/> for this commit in the space provided under the <strong>Initial Commit Message</strong> label present in the <strong>Action</strong> pane.<div><img src="img/7522_03_14.jpg" alt="Time for action – committing files in GUI mode"/></div></li><li class="listitem">Click on the <a id="id185" class="indexterm"/> <strong>Commit</strong> button. Once the commit is <a id="id186" class="indexterm"/> done Git gives you a status message at the bottom of the pattern <strong>status commit ID: your comment for the commit</strong>.<div><img src="img/7522_03_15.jpg" alt="Time for action – committing files in GUI mode"/></div><p>Commit ID is nothing but a unique identifier for Git to recollect your commit in future. We will see the other usages of our comments on the commit and the Git commit ID in the oncoming functionalities.</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Time for action – committing files in CLI mode</h1></div></div></div><p>Assuming you <a id="id187" class="indexterm"/> already have the command prompt <a id="id188" class="indexterm"/> opened by doing the steps mentioned under initiation process, give Git the following command:</p><div><pre class="programlisting">
<strong>git commit –m "your comments for the commit"</strong>
</pre></div><div><img src="img/7522_03_16.jpg" alt="Time for action – committing files in CLI mode"/></div><p>If you see a status message similar to the one mentioned previously it's a sign of an affirmation.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>
<em>What just happened?</em>
</h2></div></div></div><p>You have <a id="id189" class="indexterm"/> successfully committed your files to the repository. Henceforth any changes made to these files will be relative.</p><p>Let's see what <a id="id190" class="indexterm"/> happens when you change the contents of the file inside the repository.</p><p>I suddenly feel that I need to convey how Git impacts my work instead of just saying "It's a simple, fast, and superb version control system" in our <code class="literal">content.docx</code> file. So I am replacing this with the text "It increases my productivity manyfold when working with files that have frequent content changes."</p><p>Git tracks the change and indicates it to us when asked about a status update.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Time for action – rescan in GUI mode</h1></div></div></div><p>If you already have <a id="id191" class="indexterm"/> 
<strong>Git Gui</strong> open then just hit the <strong>Rescan</strong> <a id="id192" class="indexterm"/> button to get the latest status update from Git. If you don't have the tool opened already, I'm assuming you know how to open it.</p><p>And you see, it shows the files that have changed from their earlier state in the <strong>Unstaged Changes</strong> area.</p><div><img src="img/7522_03_17.jpg" alt="Time for action – rescan in GUI mode"/></div><p>You recently learned <a id="id193" class="indexterm"/> how to stage a file's change and how to commit <a id="id194" class="indexterm"/> it, so I'll leave the rest to you. Just so that you know, my commit message for this commit was "Added more text that explains why I use Git."</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>The <strong>Content</strong> pane shows the change that you have made in the file. Green text indicates addition and red text indicates deletion when compared to the previous version of the file. We shall explore more about this in later chapters.</p></div></div><p>For CLI lovers, we have been using the <code class="literal">status</code> command from the time we added files to check the status of the repository, and it is no different here. Employ the <code class="literal">git status</code> command to get to know about the changes in your repository.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Checking out</h1></div></div></div><p>Well, until now we have been moving forward in versioning our files by giving orders to Git with the concepts we learned. Whatever you have learned up to now is just a one way process!</p><p>To make it clearer – <em>how do you feel about not knowing how to use the undo and redo features of your Word application?</em>
</p><p>So let's learn how to travel back in time with respect to content using Git.</p><p>Checking out is one of the processes that helps you jump to and fro between the changes that you have made in any single file or the entire subset of files that you have in your repository at the time you committed.</p><p>You can go back to a commit that you have made earlier to view the contents of a single file or group of files and return to the latest version of the same file with the latest changes – all in an instant.</p><p>How good is that?</p><p>There are several things you can do other than just viewing the file in an earlier commit, which we will discuss in later chapters under the topic called branching.</p><p>Having learned the theory behind it, let's put it in action.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Time for action – checking out using GUI mode</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Select the <strong>Repository</strong> <a id="id195" class="indexterm"/> menu and then the <strong>Visualize All Branch History</strong> <a id="id196" class="indexterm"/> option in the opened <strong>Git Gui</strong> screen to open <strong>gitk</strong>; you will get a screen like the following:<div><img src="img/7522_03_18.jpg" alt="Time for action – checking out using GUI mode"/></div><p>Gitk <a id="id197" class="indexterm"/> is a powerful graphical repository browser allowing us to perform various kinds of operations such as visualizing the repository, tagging, resetting, and so on.</p><p>Again, don't worry about the overwhelming information on the screen; we shall get there step-by-step.</p><p>For now let's focus on the top-left pane, which shows a pathway in which the colored circles indicate the commits you have made; alongside the circles are your comments.</p><p>And directly beneath it is a field called <strong>SHA1 ID</strong>, which shows you the commit ID for the commit that you have selected above. As we discussed earlier we will use this commit ID to identify a particular commit to travel back in time.</p></li><li class="listitem">Select our <a id="id198" class="indexterm"/> first commit, which says <strong>Initial commit to showcase the commit functionality of Git</strong>, to get its commit <a id="id199" class="indexterm"/> ID displayed in the <strong>SHA1 ID</strong> field and copy the ID (by double-clicking to select the entire line's content and pressing <em>Ctrl</em> + <em>C</em> to copy it).</li><li class="listitem">Switch to <strong>Git Gui</strong> and select <strong>Branch | Checkout</strong> to open the checkout operation window (alternatively you can press <em>Ctrl</em> + <em>O</em>). Paste the SHA1 ID that you have copied into the <strong>Revision Expression</strong> textbox and click on the <strong>Checkout</strong> button, as shown in the following screenshot:<div><img src="img/7522_03_19.jpg" alt="Time for action – checking out using GUI mode"/></div></li><li class="listitem">Click on the <a id="id200" class="indexterm"/> <strong>OK</strong> button on the dialog window <a id="id201" class="indexterm"/> that appears (we will discuss more about the term detached checkout in later chapters under the branching topic).<div><img src="img/7522_03_20.jpg" alt="Time for action – checking out using GUI mode"/></div></li></ol></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>
<em>What just happened?</em>
</h2></div></div></div><p>You have successfully <a id="id202" class="indexterm"/> travelled back in time. If we open our document <a id="id203" class="indexterm"/> now, we can see the content we had initially created in the document.</p><p>At any given point of time you can revert to your latest changes by selecting <strong>Branch</strong> | <strong>Checkout</strong> | <strong>Localbranch</strong>; ensure <strong>master</strong> is selected, and click on the <strong>Checkout</strong> button.</p><div><img src="img/7522_03_21.jpg" alt="What just happened?"/></div><p>As you can see, you have jumped back to your contents with the latest changes.</p><p>Yeah, awesome, isn't it?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Time for action – checking out using CLI mode</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Let's learn two more <a id="id204" class="indexterm"/> commands to add <a id="id205" class="indexterm"/> to your Git lingo.<div><pre class="programlisting">
<strong>Git log</strong>
<strong>Git checkout ___commit_id___</strong>
</pre></div><p>
<code class="literal">Git log</code> <a id="id206" class="indexterm"/> is for showing the history of a repository; it gives us information such as commit ID, author, date, and the commit comment given by us.</p><p>We need the commit ID for use later.</p><div><img src="img/7522_03_22.jpg" alt="Time for action – checking out using CLI mode"/></div><p>Don't worry <a id="id207" class="indexterm"/> about memorizing a sequence <a id="id208" class="indexterm"/> of 40 characters. Our magic wand, Git, does the hard work of filling in the remaining characters for you to identify a commit if you supply it with the first five characters.</p></li><li class="listitem">Let's see it in action.<div><img src="img/7522_03_23.jpg" alt="Time for action – checking out using CLI mode"/></div><p>Now you <a id="id209" class="indexterm"/> have travelled back to a previous <a id="id210" class="indexterm"/> commit, and your files will contain the contents of the previous commit. You can view the contents of the file now.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>When you have checked back to a previous commit you are hanging in the air; any changes to your files now will be lost once you go back to the master. We'll see how to handle this in later chapters with a concept called branching.</p></div></div></li><li class="listitem">To return to the latest changes run <code class="literal">git checkout master</code>; this will bring you to the latest changes.<div><img src="img/7522_03_24.jpg" alt="Time for action – checking out using CLI mode"/></div><p>If you see a message similar to the one in the previous screenshot, you have returned to your latest changes. Again, you can view the contents of the file.</p></li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Resetting</h1></div></div></div><p>Unlike the checkout <a id="id211" class="indexterm"/> function that we learned previously, resetting is a permanent travel back in time with <a id="id212" class="indexterm"/> respect to the content. There are three types of resetting.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Soft</li><li class="listitem" style="list-style-type: disc">Hard</li><li class="listitem" style="list-style-type: disc">Mixed</li></ul></div><p>Our aim of ignoring all the changes made after a particular commit can be achieved only by performing a <a id="id213" class="indexterm"/> 
<strong>hard reset</strong>, so we will learn about the hard type alone in this chapter.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Time for action – reset using GUI mode</h1></div></div></div><div><ol class="orderedlist arabic"><li class="listitem">Select the <a id="id214" class="indexterm"/> <strong>Repository</strong> <a id="id215" class="indexterm"/> menu and then the <strong>Visualize All Branch History</strong> option on the opened <strong>Git Gui</strong> screen to open Gitk.</li><li class="listitem">On the top-left panel you can see how your repository history is shaping up. Right now it's linear with two commits. Now right-click on the first commit, which has the commit message <strong>Initial commit to showcase the commit functionality of Git</strong>, and choose the <strong>Reset master branch to here</strong> option, as shown in the following screenshot:<div><img src="img/7522_03_25.jpg" alt="Time for action – reset using GUI mode"/></div></li><li class="listitem">You will get a confirmation dialog box with three types of reset options as discussed earlier; let's select <strong>Hard</strong> and click on the <strong>OK</strong> button, as shown in the following screenshot:<div><img src="img/7522_03_26.jpg" alt="Time for action – reset using GUI mode"/></div></li><li class="listitem">Gitk should <a id="id216" class="indexterm"/> automatically reload to show you the <a id="id217" class="indexterm"/> altered history of our repository. If it does not reload by itself we can manually do it by selecting the <strong>File</strong> | <strong>Reload</strong> option or pressing <em>Ctrl</em> + <em>F5</em>.</li></ol></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec38"/>Time for action – reset using CLI mode</h1></div></div></div><p>Resetting can be done by using the following commands in the CLI mode:</p><div><pre class="programlisting">
<strong>git log</strong>
<strong>git reset --hard 8b4fe</strong>
</pre></div><div><img src="img/7522_03_27.jpg" alt="Time for action – reset using CLI mode"/></div><p>
<code class="literal">Git log</code> is <a id="id218" class="indexterm"/> used to get to know the commit ID of the <a id="id219" class="indexterm"/> particular commit that you want to reset and the command <code class="literal">git reset --hard your_commitid</code> is to convey to Git that you want to reset all changes that have happened after the commit mentioned by its ID.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>
<em>What just happened?</em>
</h2></div></div></div><p>Congratulations! We have successfully reset our repository to an earlier state permanently. You can verify this by checking the content of your files and logs of your repository.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Git help</h2></div></div></div><p>Git is a continuous <a id="id220" class="indexterm"/> learning platform. No matter how good you are with it already, the chances are you will learn something new every time you use it because there are multiple ways of doing things. Any command you will need to get started with Git CLI to perform basic operations always has the following pattern: <code class="literal">git operation_keyword parameters and/or values</code>.</p><p>When we say that almost <a id="id221" class="indexterm"/> all operations are local/offline in Git, we mean it!</p><p>Git has a built-in help module that can help you whenever you are unsure about the usage of a specific command or even the command itself. You can immediately refer to the built-in documentation by using the following commands:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">git help</code> <a id="id222" class="indexterm"/> to get a list of command-line parameters and most commonly used operation keywords with description</li><li class="listitem" style="list-style-type: disc"><code class="literal">git help operation_keyword</code> <a id="id223" class="indexterm"/> to get a complete reference sheet of that particular operation keyword opened in your default browser</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Have a go hero – try out the help module</h2></div></div></div><p>Try listing out the commonly used Git commands, pick one command, and try opening up the helper page for it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec39"/>Summary</h1></div></div></div><p>We have learned how to do the following in both the GUI and CLI modes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Initiate a repository</li><li class="listitem" style="list-style-type: disc">Configure Git</li><li class="listitem" style="list-style-type: disc">Add files to our repository</li><li class="listitem" style="list-style-type: disc">Ignore unwanted files being added to our repository</li><li class="listitem" style="list-style-type: disc">Commit the new files/changes in existing files</li><li class="listitem" style="list-style-type: disc">Check out to previous commits in case we need to refer old data</li><li class="listitem" style="list-style-type: disc">Reset the repository to permanently travel back to an earlier recorded state</li><li class="listitem" style="list-style-type: disc">Use the built-in help modules</li></ul></div><p>Very soon you will learn how to do the following and much more:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Maintain multiple environments and switch between them as though they are logged into multiple user accounts</li><li class="listitem" style="list-style-type: disc">Continue making changes from a previous commit, thereby maintaining multiple routes (technically called branches) from one source</li></ul></div></div></body></html>