<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Working with Custom Fields</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Writing a simple custom field</li><li class="listitem" style="list-style-type: disc">Custom field searchers</li><li class="listitem" style="list-style-type: disc">Dealing with custom fields on an issue</li><li class="listitem" style="list-style-type: disc">Programming custom field options</li><li class="listitem" style="list-style-type: disc">Overriding validation of custom fields</li><li class="listitem" style="list-style-type: disc">Customizing change log value</li><li class="listitem" style="list-style-type: disc">Migrating from one custom field type to another</li><li class="listitem" style="list-style-type: disc">Making custom fields sortable</li><li class="listitem" style="list-style-type: disc">Displaying custom fields on subtask columns on parent issue</li><li class="listitem" style="list-style-type: disc">User and date fields from 4.1.x</li><li class="listitem" style="list-style-type: disc">Adding custom fields to notification mails</li><li class="listitem" style="list-style-type: disc">Adding help text for a custom field</li><li class="listitem" style="list-style-type: disc">Removing the 'none' option from a select field</li><li class="listitem" style="list-style-type: disc">Making the custom field project importable</li><li class="listitem" style="list-style-type: disc">Changing the size of a text area custom field</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec22"/>Introduction</h1></div></div></div><p>For an issue tracking application, the more details you can provide about an issue, the better. JIRA<a id="id482" class="indexterm"/> helps by giving us some standard issue fields that are most likely to be used while creating an issue. But what if we need to capture additional information such as the name of the reporter's dad or something else that is worth capturing, perhaps the SLA or the estimated costs? For this, we can make use of custom fields.</p><p>With JIRA comes a group of pre-defined custom field types. It includes types like Number Field, User Picker, and so on, which are most likely to be used by JIRA users. But as you become a power user of JIRA, you might come across the need for a customized field type. That is where people start writing custom field plugins to create new field types or custom searchers.</p><p>We will use this chapter to learn more about custom fields.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec23"/>Writing a simple custom field</h1></div></div></div><p>In this recipe, we will see how to write a new custom field type. Once created, we can create a number of custom fields of this type on our JIRA instance that can then be used to capture information on the issues.</p><a id="id483" class="indexterm"/><a id="id484" class="indexterm"/><a id="id485" class="indexterm"/><p>New Custom field types are created with the help of the <code class="literal">customfield-type</code> module<a id="id486" class="indexterm"/>. The following are the key attributes and elements supported.</p><a id="id487" class="indexterm"/><p><strong>Attributes:</strong></p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">key</code></p>
</td><td style="text-align: left" valign="top">
<p>This should be unique within the plugin.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">class</code></p>
</td><td style="text-align: left" valign="top">
<p>Must implement the <code class="literal">com.atlassian.jira.issue.customfields.CustomFieldType</code> interface.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">i18n-name-key</code></p>
</td><td style="text-align: left" valign="top">
<p>The localization key for the human-readable name of the plugin module.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">Name</code></p>
</td><td style="text-align: left" valign="top">
<p>Human-readable name of the web resource.</p>
</td></tr></tbody></table></div><a id="id488" class="indexterm"/><p><strong>Elements:</strong></p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">Description</code></p>
</td><td style="text-align: left" valign="top">
<p>Description of the custom field type.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">resource type="velocity"</code></p>
</td><td style="text-align: left" valign="top">
<p>Velocity templates for the custom field views.</p>
</td></tr></tbody></table></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec59"/>Getting ready</h2></div></div></div><p>Before we start, create a skeleton plugin. Next, create an eclipse project using the skeleton plugin, and we are good to go!</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec60"/>How to do it...</h2></div></div></div><a id="id489" class="indexterm"/><a id="id490" class="indexterm"/><a id="id491" class="indexterm"/><p>In this recipe, let us look at an example custom field type to ease understanding. Let us consider the creation of a <code class="literal">Read Only</code> custom field<a id="id492" class="indexterm"/> that stores the name of the user who edited the issue the last time. It is simple in functionality and enough to explain the basic concepts.</p><p>The following are the major steps to do:</p><div><ol class="orderedlist arabic"><li class="listitem">Modify the <code class="literal">atlassian-plugin.xml</code> file<a id="id493" class="indexterm"/> to include the <code class="literal">customfield-type</code> module. Make sure the appropriate class name and views are added.<p>For our example, the modified <code class="literal">atlassian-plugin.xml</code> will look as follows:</p><div><pre class="programlisting">&lt;customfield-type key="readonly-user" name="Read Only User CF" class="com.jtricks.ReadOnlyUserCF"&gt;       
  &lt;description&gt;Read Only User CF Description&lt;/description&gt;       
  &lt;resource type="velocity" name="view" location="templates/com/jtricks/view-readonly-user.vm" /&gt;       
  &lt;resource type="velocity" name="column-view" location="templates/com/jtricks/view-readonly-user.vm" /&gt;      
  &lt;resource type="velocity" name="xml" location="templates/com/jtricks/view-readonly-user.vm" /&gt;      
  &lt;resource type="velocity" name="edit" location="templates/com/jtricks/edit-readonly-user.vm" /&gt; 
&lt;/customfield-type&gt;</pre></div></li><li class="listitem">Make sure the key is unique inside the plugin.</li><li class="listitem">Implement the class. As mentioned in the introduction, the class must implement the <code class="literal">com.atlassian.jira.issue.customfields.CustomFieldType</code> interface. Now if you do this, make sure you implement all the methods in the interface.<div><div><h3 class="title"><a id="note09"/>Note</h3><p>An easier way is to override some of the existing custom field implementations, if there are any similar to the type you are developing. In such cases, you will need to only override certain methods or maybe just modify the velocity templates!</p><p>The details on existing implementations can be found at the Javadocs for the <code class="literal">CustomFieldType</code> interface. <code class="literal">NumberCFType</code>, <code class="literal">DateCFType</code>, <code class="literal">UserCFType</code>, and so on, are some useful examples.</p></div></div><p>In our example, the class is <code class="literal">com.jtricks.ReadOnlyUserCF</code>. Now, our field type is nothing but a text field in essence and so it makes sense to override the already existing <code class="literal">TextCFType</code>.</p><p>Following is how the class will look:</p><div><pre class="programlisting">public class ReadOnlyUserCF extends TextCFType{
    private final JiraAuthenticationContext authContext;
    public ReadOnlyUserCF(CustomFieldValuePersister 
      customFieldValuePersister,
      StringConverter stringConverter,  GenericConfigManager 
      genericConfigManager,
      JiraAuthenticationContext authContext) {
      super(customFieldValuePersister, stringConverter, 
      genericConfigManager);
      this.authContext = authContext;
    }
    // Overridden methods here
  }</pre></div><a id="id494" class="indexterm"/><a id="id495" class="indexterm"/><a id="id496" class="indexterm"/><p>As you can see, the class extends the <code class="literal">TextCFType</code> class. We perform a 'constructor injection' to call the super class constructor. All you need to do is add the required component as an argument in the public constructor of the class and Spring will inject an instance of that component at runtime. Here, <code class="literal">JiraAuthenticationContext</code><a id="id497" class="indexterm"/> is injected as we use it in our class. As you can see, <code class="literal">authContext</code> is an argument that is injected and is assigned to a class variable with the same name for using it later in the various methods.</p></li><li class="listitem">Implement/Override the methods of interest. As mentioned earlier, implement all the required methods, if you are implementing the interface directly.<p>In our case, we extend the <code class="literal">TextCFType</code>, and so we need to only override the selected methods.</p><p>The only method that we override here is the <code class="literal">getVelocityParameters</code> method<a id="id498" class="indexterm"/> where we populate the velocity params with additional values. In this case, we add the current user's name. We will later use this params in the velocity context to generate the views. The same method is used in creating the different views in different scenarios, that is, create, edit, and so on. The following is the codeippet:</p><div><pre class="programlisting">@Override
public Map getVelocityParameters(Issue issue, CustomField 
    field, FieldLayoutItem fieldLayoutItem){
    Map params = super.getVelocityParameters(issue, field, 
    fieldLayoutItem);
    params.put("currentUser", authContext.getUser().getName());
    return params;
}</pre></div><p>Note: Use the <code class="literal">authContext.getLoggedInUser</code> method<a id="id499" class="indexterm"/> if using JIRA 4.3+.</p></li><li class="listitem">Create the templates defined in the <code class="literal">atlassian-plugin.xml</code> file. The templates could be written in a way you want the fields to appear in different scenarios.<p>If you take a closer look, we have defined four velocity resources but using only two velocity template files, as the <code class="literal">view-readonly-user.vm</code> is shared across 'view', 'column-view', and 'xml' resources. In this example, we only need to show the <code class="literal">readonly</code> field in all the three mentioned cases, and so the template will look as follows:</p><div><pre class="programlisting">#if ($value)  $value  #end</pre></div><p>This code uses velocity syntax, the details of which can be found at <a class="ulink" href="http://velocity.apache.org/engine/devel/developer-guide.html">http://velocity.apache.org/engine/devel/developer-guide.html</a>. Here we display the existing custom field value of the issue.</p></li><li class="listitem">The edit template should be a <code class="literal">readonly</code> <code class="literal">textfield</code> with <code class="literal">id</code> as the custom field's ID, as JIRA uses this to store values back into the database when the issue is edited. The template looks as follows:<div><pre class="programlisting">&lt;input type="text" name="$customField.id" value="$currentUser" id="$customField.id"   class="textfield" readonly="readonly" /&gt;</pre></div><p>Here we use the field <code class="literal">currentUser</code>, as we added into the velocity context in step 4. The value of the text field is <code class="literal">$currentUser</code>. Also note that the ID is <code class="literal">$customfield.id</code> and the <code class="literal">readonly</code> attribute is present to make it read only.</p></li><li class="listitem">Package the plugin and deploy it!</li></ol></div><a id="id500" class="indexterm"/><a id="id501" class="indexterm"/><a id="id502" class="indexterm"/><p>Remember, more complex logic and beautifications can go into the class and velocity templates. As they say, the sky is the limit!</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec61"/>How it works...</h2></div></div></div><p>Once the plugin is installed, it is available under <strong>Administration</strong> | <strong>Issue Fields</strong> | <strong>Custom Fields</strong>.</p><p>Create a new custom field of the type we just created and map it into the appropriate issue types and projects. Also add the fields to the appropriate screens. Once done, the field will be available on the issue at the appropriate places.</p><p>More details on adding a custom field can be found at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Adding+a+Custom+Field">http://confluence.atlassian.com/display/JIRA/Adding+a+Custom+Field</a>.</p><p>In our example, whenever an issue is edited, the name of the user who edited it is stored in the custom field.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec62"/>There's more...</h2></div></div></div><p>You might have noticed that we added only one parameter in the velocity context, that is, <code class="literal">currentUser</code>, but we have used <code class="literal">$value</code> in the view template. Where does this variable <code class="literal">value</code> come from?</p><p>JIRA already populates the custom field velocity contexts with some existing variables in addition to the new ones we add. <code class="literal">value</code> is just one among them and the full list can be found at <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Custom+field+Velocity+context+unwrapped">http://confluence.atlassian.com/display/JIRADEV/Custom+field+Velocity+context+unwrapped</a>.</p><p>You may notice that <code class="literal">authContext</code> is already available in the velocity context and so we could have implemented this example by getting the current user in the velocity template itself instead of injecting the <code class="literal">JiraAuthenticationContext</code> in the constructor of the class and getting the <code class="literal">currentUser</code> variable from it in the class. But we have done that just for the purpose of explaining the example.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec63"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Creating a skeleton plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a>, <em>Plugin Development Process</em></li><li class="listitem" style="list-style-type: disc"><em>Deploying your plugin</em> in <a class="link" href="ch01.html" title="Chapter 1. Plugin Development Process">Chapter 1</a></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Custom field searchers</h1></div></div></div><a id="id503" class="indexterm"/><a id="id504" class="indexterm"/><a id="id505" class="indexterm"/><a id="id506" class="indexterm"/><p>Writing the custom field type is one thing, but making it available to one of JIRA's most powerful functionalities, that is, Search, is another! When you create the custom field, you can associate the searcher to be used along with it.</p><p>In most cases, you wouldn't need a custom searcher. Instead, you can use the built-in custom field searchers in JIRA itself. The list includes, but is not restricted to, Text Field Searcher, Date Searcher, Number Searcher, User Searcher, and so on.</p><p>The first step, of course, is to determine what the kind of Searcher your new field needs. For example, a Select field can easily be searched with Text Searcher or an Exact Text Searcher! A User Picker field can be searched with a User Searcher or a Text Searcher. You might even want to extend one of these Searchers to add some extra functionality, like some special conditions or hacks you want to introduce! Yeah, you know what I mean!</p><p>Here is how JIRA has defined the Text Searcher for its system custom fields:</p><div><pre class="programlisting">&lt;customfield-searcher key="textsearcher" name="Free Text Searcher"
        i18n-name-key="admin.customfield.searcher.textsearcher.name"
        class="com.atlassian.jira.issue.customfields.searchers.TextSearcher"&gt;
        &lt;description key="admin.customfield.searcher.textsearcher.desc"&gt;Search for values using a free text search.&lt;/description&gt;
        &lt;resource type="velocity" name="search" location="templates/plugins/fields/edit-searcher/search-basictext.vm"/&gt;
        &lt;resource type="velocity" name="view" location="templates/plugins/fields/view-searcher/view-searcher-basictext.vm"/&gt;
        &lt;valid-customfield-type package="com.atlassian.jira.plugin.system.customfieldtypes" key="textfield"/&gt;
        &lt;valid-customfield-type package="com.atlassian.jira.plugin.system.customfieldtypes" key="textarea"/&gt;
        &lt;valid-customfield-type package="com.atlassian.jira.plugin.system.customfieldtypes" key="readonlyfield"/&gt;
&lt;/customfield-searcher&gt;</pre></div><a id="id507" class="indexterm"/><a id="id508" class="indexterm"/><a id="id509" class="indexterm"/><p>As you can see, it makes use of the <code class="literal">customfield-searcher</code> module<a id="id510" class="indexterm"/>. The custom fields that should be searchable using this <strong>Free Text Searcher</strong><a id="id511" class="indexterm"/> should be added under the <code class="literal">valid-customfield-type</code> tag.</p><p>The following are the key attributes and elements supported by the <code class="literal">customfield-searcher</code> module.</p><p><strong>Attributes</strong>:<a id="id512" class="indexterm"/></p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">key</code></p>
</td><td style="text-align: left" valign="top">
<p>This should be unique within the plugin</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">class</code></p>
</td><td style="text-align: left" valign="top">
<p>Must implement the <code class="literal">com.atlassian.jira.issue.customfields.CustomFieldSearcher</code> interface</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">i18n-name-key</code></p>
</td><td style="text-align: left" valign="top">
<p>The localization key for the human-readable name of the plugin module</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">name</code></p>
</td><td style="text-align: left" valign="top">
<p>Human-readable name of the web resource</p>
</td></tr></tbody></table></div><a id="id513" class="indexterm"/><p><strong>Elements</strong>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p><code class="literal">description</code></p>
</td><td style="text-align: left" valign="top">
<p>Description of the custom field searcher module</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">resource type="velocity"</code></p>
</td><td style="text-align: left" valign="top">
<p>Velocity templates for the custom field searcher views</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p><code class="literal">valid-customfield-type</code></p>
</td><td style="text-align: left" valign="top">
<a id="id514" class="indexterm"/>
<p>Defines the custom field types this searcher can apply to. It has two attributes: <code class="literal">package</code> – the key of the atlassian plugin where the custom field resides and <code class="literal">key</code> – the module key for the custom field type.</p>
</td></tr></tbody></table></div><p>Let us see in detail how to define a searcher for the custom field we wrote in the previous recipe.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec64"/>Getting ready</h2></div></div></div><p>Make sure you have created the <code class="literal">Read Only User</code> custom field (<code class="literal">com.jtricks.ReadOnlyUserCF</code> ) using the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec65"/>How to do it...</h2></div></div></div><a id="id515" class="indexterm"/><a id="id516" class="indexterm"/><a id="id517" class="indexterm"/><p>As usual, we will do it as a step-by-step procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Add the <code class="literal">customfield-searcher</code> module into the <code class="literal">atlassian-plugin.xml</code> file.<p>In our example, the field is a read-only text field that holds the username, and so it makes sense to use the existing <code class="literal">TextSearcher</code> instead of writing a new Searcher class. The module will look as follows:</p><div><pre class="programlisting">&lt;customfield-searcher key="readonly-user-searcher" name="Read Only User Searcher"  class="com.atlassian.jira.issue.customfields.searchers.TextSearcher"&gt;</pre></div><div><pre class="programlisting">  &lt;description key="admin.customfield.searcher.textsearcher.desc"&gt;Search for Read Only User using a free text search.&lt;/description&gt;
  &lt;resource type="velocity" name="search" location="templates/plugins/fields/edit-searcher/search-basictext.vm"/&gt;
  &lt;resource type="velocity" name="view" location="templates/plugins/fields/view-searcher/view-searcher-basictext.vm"/&gt;
  &lt;valid-customfield-type package="com.jtricks" key="readonly-user"/&gt;  
&lt;/customfield-searcher&gt;</pre></div><p>Here we use <code class="literal">com.atlassian.jira.issue.customfields.searchers.TextSearcher</code> that implements the <code class="literal">com.atlassian.jira.issue.customfields.CustomFieldSearcher</code> interface. If we need to write custom searchers, the appropriate class should appear here.</p><p>We also need to define the velocity templates for <code class="literal">edit</code> and <code class="literal">view</code> scenarios.</p></li><li class="listitem">Implement the custom field searcher class. In this case, we can skip this step, as we are going with the already implemented class <code class="literal">TextSearcher</code>.<p>Even if we are implementing a custom searcher, it might be wise to extend an already existing searcher class and override only the methods of interest to avoid implementing everything from scratch. Having said that, it is entirely up to the developer to give a brand new implementation.</p><p>The only mandatory thing to note is that the searcher class must implement the <code class="literal">com.atlassian.jira.issue.customfields.CustomFieldSearcher</code> interface.</p></li><li class="listitem">Write the velocity templates. For a custom field searcher, there are two views. <code class="literal">Edit</code> and <code class="literal">view</code>, both of which will appear on the issue navigator.<p>The <code class="literal">edit</code> template is used when the filters are created / edited. The <code class="literal">view </code>template is used when the filter is viewed or the search results are viewed by clicking on <strong>View and Hide</strong> ('Search' from JIRA 4.3) on the issue navigator.</p><p>In our example, we have used the in-built JIRA templates, but it is perfectly fine to give a custom implementation of these templates.</p></li><li class="listitem"><a id="id518" class="indexterm"/><a id="id519" class="indexterm"/><a id="id520" class="indexterm"/>Make sure the <code class="literal">valid-customfield-type</code> tags are correctly entered.<p>There is a basic, but very common, error you might make here. The <code class="literal">package</code> attribute here refers to the atlassian-plugin key where the custom field resides and not the Java package where the Searcher class resides! Just to make it clear, the atlassian plugin key is the key in the first line of your <code class="literal">atlassian-plugin.xml</code>, which is <code class="literal">com.jtricks</code> in our case:</p><div><pre class="programlisting">&lt;atlassian-plugin key="com.jtricks" name="J-Tricks Customfields Plugin"  plugins-version="2"&gt;</pre></div><p>This package (plugin key) along with the custom field key (<code class="literal">readonly-user</code> in this case) will point to the right custom field. This would also mean that you can have the same <code class="literal">readonly-user</code> in another plugin with a different plugin key!</p></li><li class="listitem">Package the plugin and deploy it.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec66"/>How it works...</h2></div></div></div><p>Once the custom field type is associated with a searcher using the <code class="literal">customfield-searcher</code> module<a id="id521" class="indexterm"/>, you will see it appear in the searcher drop-down when a custom field of that type is created.</p><p>For any existing custom fields, the searcher can be defined or modified using the edit operation. Once the searcher is changed, a re-indexing must be done for the changes to be effective.</p><a id="id522" class="indexterm"/><a id="id523" class="indexterm"/><a id="id524" class="indexterm"/><p>We can define more than one custom field using the <code class="literal">valid-customfield-type</code> element for a single searcher.</p><p>Similarly, the same custom field type can be defined under more than one searcher. This will be useful when two different custom fields of the same type can potentially use two different searchers. For example, text fields can use <code class="literal">TextSearcher</code><a id="id525" class="indexterm"/> or <code class="literal">ExactTextSearcher</code><a id="id526" class="indexterm"/>.</p><p>Once the searcher is defined against the custom field, you can see it appearing in the issue navigator <strong>when the correct context is selected</strong>. The last part is extremely important because the field will be available to search only when the context chosen is correct. For example, if field X is available only on bugs, it won't appear on the issue navigator when the issue types selected has both bugs and new features. Refresh the search menu after the correct context is selected to see your field. This is applicable only for <strong>simple</strong> searching<a id="id527" class="indexterm"/>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec67"/>There's more...</h2></div></div></div><p>With the introduction of v2 plugins, courtesy of OSGI bundles<a id="id528" class="indexterm"/>, referring to the built-in JIRA searcher classes directly in the <code class="literal">atlassian-plugin.xml</code> file will fail sometimes because it can't resolve all the dependencies (the notorious <strong>Unsatisfied dependency</strong> errors!). This is because some of the classes are not available for dependency injection in the version 2 plugins, as they were in version 1 plugins.</p><p>But there is an easy hack to do it. Just create a dummy custom Searcher class with the constructor that does the dependency injection for you:</p><div><pre class="programlisting">public class MySearcher extends SomeJiraSearcher {
   public MySearcher(PluginComponent ioc) {
      super(ioc, ComponentManager.getInstanceOfType(anotherType));
  } 
}</pre></div><p>If that doesn't work, add the field to the <code class="literal">system-customfield-types.xml</code> file under <code class="literal">WEB-INF/classes</code> along with the JIRA system custom fields, that is, one more <code class="literal">valid-customfield-type</code> entry into the relevant <code class="literal">customfield-searcher</code> element. If you do this, remember to apply this workaround when JIRA is upgraded!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Dealing with custom fields on an issue</h1></div></div></div><p>In this recipe, we will see how to work with custom fields on an issue. It covers reading a custom field value from an issue and then updating the custom field value on the issue, with and without notifications.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec68"/>Getting ready</h2></div></div></div><p>Identify the places where the custom fields needs to be manipulated, be it on a listener, workflow element, or somewhere else in our plugins.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec69"/>How to do it...</h2></div></div></div><a id="id529" class="indexterm"/><a id="id530" class="indexterm"/><p>We will see how to access the value of a custom field and modify the value as we go along.</p><p>The following are the steps to read the custom field value from an <code class="literal">Issue</code> object<a id="id531" class="indexterm"/>.</p><div><ol class="orderedlist arabic"><li class="listitem">Create an instance of the <code class="literal">CustomFieldManager</code> class<a id="id532" class="indexterm"/>. This is the manager class that does most of the operations on custom fields. There are two ways to retrieve a manager class:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inject the manager class in the constructor of your plugin class implementation.</li><li class="listitem" style="list-style-type: disc">Retrieve the <code class="literal">CustomFieldManager</code> directly from the <code class="literal">ComponentManager</code> class. It can be done as follows:<div><pre class="programlisting">CustomFieldManager customFieldManager = ComponentManager.getInstance().getCustomFieldManager();</pre></div></li></ul></div></li><li class="listitem">Retrieve the <code class="literal">customField</code> object using the <code class="literal">customfield</code> name or the ID:<div><pre class="programlisting">CustomField customField = customFieldManager.getCustomFieldObject(new Long(10000)); </pre></div><p>                                                    OR</p><div><pre class="programlisting">CustomField customField = customFieldManager.getCustomFieldObjectByName(demoFieldName);</pre></div></li><li class="listitem">Once the custom field object is available, its value for an issue can be retrieved as follows:<div><pre class="programlisting">Object value = customField.getValue(Issue) </pre></div><p>                                                   OR</p><div><pre class="programlisting">Object value = issue.getCustomFieldValue(customField);</pre></div><p>The latter works fine in all scenarios, whereas the former seems to fail in cases like workflow validators and post functions.</p></li><li class="listitem">Cast the value object to the appropriate class. For example, String for a text field, <code class="literal">List&lt;String&gt;</code> for a multi select field, <code class="literal">Double</code> for a number field, and so on.</li></ol></div><a id="id533" class="indexterm"/><a id="id534" class="indexterm"/><p>If you want to update the custom field values back on to the issue, continue with the following steps.</p><div><ol class="orderedlist arabic"><li class="listitem">Create a modified value object with the old value and the new value:<div><pre class="programlisting">ModifiedValue modifiedValue = new ModifiedValue(value, newValueObject);</pre></div></li><li class="listitem">Obtain the <code class="literal">FieldLayoutItem</code> associated with the custom field for this issue<div><pre class="programlisting">FieldLayoutManager fieldLayoutManager = ComponentManager.getInstance().getFieldLayoutManager();
FieldLayoutItem fieldLayoutItem = fieldLayoutManager.getFieldLayout(issue).getFieldLayoutItem(customField);</pre></div></li><li class="listitem">Update the custom field value for the issue using the <code class="literal">fieldLayoutItem</code>, <code class="literal">modfiedValue</code> and a default change holder:<div><pre class="programlisting">customField.updateValue(fieldLayoutItem, issue, modifiedValue, new DefaultIssueChangeHolder());</pre></div></li></ol></div><p>The advantage of doing this, or the disadvantage depending on your perception, is that the custom field value change will not trigger a notification. If you want to trigger notifications, please follows these steps to update the issue instead of previous steps.</p><div><ol class="orderedlist arabic"><li class="listitem">Modify the custom field value for the issue:<div><pre class="programlisting">issue.setCustomFieldValue(customField, value);</pre></div></li><li class="listitem">Create the action parameters Map using <code class="literal">issueObject</code>, <code class="literal">remoteUser</code> details, and so on:<div><pre class="programlisting">Map actionParams = EasyMap.build("issue", getIssue(), "issueObject", getIssueObject(), "remoteUser", ComponentManager.getInstance().getJiraAuthenticationContext().getUser());</pre></div></li><li class="listitem">Execute the <code class="literal">ISSUE_UPDATE</code> operation<a id="id535" class="indexterm"/>:<div><pre class="programlisting">ActionResult aResult = CoreFactory.getActionDispatcher().execute(ActionNames.ISSUE_UPDATE, actionParams);</pre></div></li></ol></div><p>This will throw an issue update event and all the handlers will be able to pick it up.</p><p>An alternate, and probably simpler, way to update the custom fields is to use the type of the field, as shown next:</p><div><pre class="programlisting">customField.getCustomFieldType().updateValue(customField, issue, newValue);</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec70"/>How it works...</h2></div></div></div><a id="id536" class="indexterm"/><a id="id537" class="indexterm"/><p>The following are the things taking place at the backend when the custom field value is changed using one of the aforementioned methods.</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The Value is updated in the database</li><li class="listitem" style="list-style-type: disc">A change record is created and change history is updated with the latest changes</li><li class="listitem" style="list-style-type: disc">Indexes are updated to hold the new values</li><li class="listitem" style="list-style-type: disc">An <em>Issue Updated </em>event is fired if <code class="literal">ActionDispatcher</code> is used to update the field, which in turn fires notifications and listeners</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec71"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Working with custom fields and SOAP</em> in <a class="link" href="ch09.html" title="Chapter 9. Remote Access to JIRA">Chapter 9</a>, <em>Remote Access to JIRA</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Programming custom field options</h1></div></div></div><a id="id538" class="indexterm"/><a id="id539" class="indexterm"/><p>We have seen how to create a custom field type, search for it, and read/update its value from/on an issue. But one important aspect of multi-valued custom fields and one that we haven't seen yet is custom field options.</p><p>On a multi-valued custom field, the administrator can configure the allowed set of values, also called <code class="literal">options</code>. Once the options are configured, users can only select values within that set of options and there is a validation done to ensure that this is the case.</p><p>So, how do we programmatically read those options or add a new option to the custom field so that it can be later set on an issue? Let us have a look at that in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec72"/>Getting ready</h2></div></div></div><p>Create a multi-valued custom field, say X, in your JIRA instance. Add a few options onto the field X.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec73"/>How to do it...</h2></div></div></div><a id="id540" class="indexterm"/><a id="id541" class="indexterm"/><p>To deal with custom field options, Atlassian has written a manager class named <code class="literal">OptionsManager</code>.</p><p>Following are the steps to get the options configured for a custom field:</p><div><ol class="orderedlist arabic"><li class="listitem">Get an instance of the <code class="literal">OptionsManager</code> class<a id="id542" class="indexterm"/>. Similar to any other manager class, this can be done in two ways.<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inject the manager class in the constructor</li><li class="listitem" style="list-style-type: disc">Directly get an instance from the <code class="literal">ComponentManager</code> class<a id="id543" class="indexterm"/> as shown:<div><pre class="programlisting">optionsManager = ComponentManager.getOSGiComponentInstanceOfType(OptionsManager.class);</pre></div></li></ul></div></li><li class="listitem">Retrieve the field configuration schemes for the custom field.<p>There could be more than one field configuration scheme for a custom field, each with its own set of projects, issue types, and so on, defined in different contexts. We need to identify the field configuration scheme of interest to us:</p><div><pre class="programlisting">List&lt;FieldConfigScheme&gt; schemes = fieldConfigSchemeManager.getConfigSchemesForField(customField);</pre></div></li><li class="listitem">Retrieve the field configuration from the scheme:<div><pre class="programlisting">FieldConfig config = fieldConfigScheme.getOneAndOnlyConfig();</pre></div></li><li class="listitem">Once the field configuration is available, we can use it to retrieve the options on the custom field for that field configuration. The options could be different for different contexts and that is the reason why we retrieve the <code class="literal">config</code> first and use it to get the options:<div><pre class="programlisting">Options options = this.optionsManager.getOptions(config);
List&lt;Option&gt; existingOptions = options.getRootOptions();</pre></div><p><code class="literal">option.getValue()</code><a id="id544" class="indexterm"/> will give the name of the option while iterating on the preceding list.</p><p><code class="literal">option.getChildOptions()</code><a id="id545" class="indexterm"/> will retrieve the child options in the case of a cascading select or any other multilevel select</p></li></ol></div><p>If you need to add new options to the list, it is again <code class="literal">OptionsManager</code> who comes to the rescue. We do it as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Create the new option:<div><pre class="programlisting">Option option = this.optionsManager.createOption(fieldConfig, null, sequence, value);</pre></div><p>The first parameter is <code class="literal">fieldConfig</code> that we saw earlier. The second parameter is the <code class="literal">parent option ID</code>, used in case of a multi-level custom field like cascading select. It will be <code class="literal">null</code> for single-level custom fields. The third parameter is <code class="literal">sequence</code>, which determines the order in which the options will appear. The fourth parameter is the actual <code class="literal">value</code> to be added as an option.</p></li><li class="listitem">Add the new <code class="literal">option</code> to the list of options and update!<div><pre class="programlisting">this.optionsManager.updateOptions(modifiedOptions);</pre></div></li><li class="listitem"><a id="id546" class="indexterm"/><a id="id547" class="indexterm"/>Deleting and updating options are also possible like this, but we shouldn't forget to handle existing issues with those option values.</li><li class="listitem"><code class="literal">OptionsManager</code> exposes a lot of other useful methods to handle custom field options, which can be found in the Javadocs.</li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec74"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing a simple custom field</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Overriding validation of custom fields</h1></div></div></div><p>We have seen how to write a custom field and set its options programmatically. We also discussed how the value set on a multi-valued custom field is validated against its set of pre-configured options. If the value doesn't belong to it, the validation fails and the issue can't be created or updated.</p><a id="id548" class="indexterm"/><a id="id549" class="indexterm"/><p>But what if we have a scenario where we need to suppress this validation? What if we need to add values to an issue which doesn't come from its pre-configured options? Normally, you would add this to the options programmatically, as we've seen before but what if we don't want to do this due to some reason? This is when you can suppress the validation in your custom field.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec75"/>Getting ready</h2></div></div></div><p>Create your custom field, as we have seen in the first recipe of this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec76"/>How to do it...</h2></div></div></div><p>All you need to do here is to suppress the validation happening in the original parent custom field if you are extending an existing custom field type like <code class="literal">MultiSelectCFType</code>. The following is the method you should override:</p><div><pre class="programlisting">@Overridepublic void validateFromParams(CustomFieldParams arg0, ErrorCollection arg1, FieldConfig arg2) {
  // Suppress any validation here
}</pre></div><a id="id550" class="indexterm"/><a id="id551" class="indexterm"/><p>You can add any additional validation in this method as well!</p><p>If you are writing a custom field type from scratch, you will be implementing the <code class="literal">CustomFieldType</code> interface<a id="id552" class="indexterm"/>. You will then need to implement the above method and can do the same thing.</p><p>And if you are interested and have access to the JIRA source code, go and have a look at how the validation is done in some existing custom field types!</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec77"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing a simple custom field</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Customizing the change log value</h1></div></div></div><a id="id553" class="indexterm"/><a id="id554" class="indexterm"/><p>One scenario we might come across when writing certain custom field types is to manipulate the way we display the change log. For a normal Version Picker custom field, the change log is displayed as follows.</p><div><img src="img/1803-03-01.jpg" alt="Customizing the change log value"/></div><p>Here <strong>Test Version</strong> is the field name. The first value you see, <code class="literal">Test2 [10010]</code>, is the old value and the second value, <code class="literal">Test1 [10000]</code>, is the new value.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec78"/>Getting ready</h2></div></div></div><p>Write your custom field type, as described in the first recipe of this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec79"/>How to do it...</h2></div></div></div><p>As you have seen in the preceding screen, the change log value for both old value and new value are displayed in the following format:</p><div><pre class="programlisting">change log string [change log id]</pre></div><p>Both the string value and ID value are stored in the <code class="literal">ChangeItem</code> table. But before storing the value in the database, this value is generated from the individual custom fields. That is where we need to intercept to manipulate the way change log is written.</p><p>There are two methods, one for <code class="literal">change log string</code> and another for <code class="literal">change log id</code>, which need to be modified. Following are the method definitions in the interface:</p><div><pre class="programlisting">public String getChangelogValue(CustomField field, Object value);
public String getChangelogString(CustomField field, Object value);</pre></div><p>All you need to do is implement these methods or override them if you are extending an existing custom field type to put your custom implementation.</p><p>If you don't want the string to appear in the change history, just return <code class="literal">null</code> in the <code class="literal">getChangelogString</code> method<a id="id555" class="indexterm"/>. Note that if <code class="literal">null</code> is returned in the <code class="literal">getChangelogValue</code> method, the change log isn't created!</p><a id="id556" class="indexterm"/><a id="id557" class="indexterm"/><p>Let us consider a simple example where the change history string is truncated when the length of a string is more than 100 characters. In this case, the <code class="literal">getChangelogValue</code> returns an empty string and <code class="literal">getChangelogString</code> returns the truncated string. The overridden methods are as shown next:</p><div><pre class="programlisting">@Override
public String getChangelogValue(CustomField field, Object value) {
  return "";
}

@Override
public String getChangelogString(CustomField field, Object value) {
  String val = (String) value;
  if (val != null &amp;&amp; val.length() &gt; 100){
    val = val.substring(0, 100) + "....";
  }
  return val;
}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec80"/>How it works...</h2></div></div></div><p>Whenever a value is changed for a custom field, it updates the value in the <code class="literal">CustomFieldValue</code> table. In addition, it also stores the changes on the issue by making a change log entry.</p><p>For every set of changes happening on an issue at a single update, a record is created under the <code class="literal">ChangeGroup</code> table. It stores the name of the user who made the change (author), the time when the change was made (created), and the issue ID (issue).</p><p>For every change group, there will be one or more change items stored in the <code class="literal">ChangeItem</code> table. It is in this table that the old and new values for fields are stored. For both old and new value, there are two columns in the table – one for the string representation and another for the ID. The following is the entity definition for the <code class="literal">ChangeItem</code> table:</p><div><pre class="programlisting">&lt;!-- entity to represent a single change to an issue. Always part of a change group --&gt;
    &lt;entity entity-name="ChangeItem" table-name="changeitem" package-name=""&gt;
        &lt;field name="id" type="numeric"/&gt;
        &lt;field name="group" col-name="groupid" type="numeric"/&gt;

        &lt;!-- whether this is a built in field ('jira') or a custom field ('custom') - basically used to avoid naming scope problems --&gt;
        &lt;!-- also used for keeping record of the bug_id of a bug from Bugzilla Import--&gt;
        &lt;!-- and for keeping record of ids in issue move--&gt;
        &lt;field name="fieldtype" type="long-varchar"/&gt;
        &lt;field name="field" type="long-varchar"/&gt;

<strong>        &lt;field name="oldvalue" type="extremely-long"/&gt;</strong>
<strong>        &lt;!-- a string representation of the new value (i.e. "Documentation" instead of "4" for a component which might be deleted) --&gt;</strong>
<strong>        &lt;field name="oldstring" type="extremely-long"/&gt;</strong>

<strong>        &lt;field name="newvalue" type="extremely-long"/&gt;</strong>
<strong>        &lt;!-- a string representation of the new value --&gt;</strong>
<strong>        &lt;field name="newstring" type="extremely-long"/&gt;</strong>
        &lt;prim-key field="id"/&gt;
        &lt;!—relations and indexes --&gt;
    &lt;/entity&gt;</pre></div><a id="id558" class="indexterm"/><a id="id559" class="indexterm"/><p>The fields <code class="literal">oldvalue</code> and <code class="literal">newvalue</code> are populated using the method <code class="literal">getChangelogValue</code>. Similarly, the fields <code class="literal">oldstring</code> and <code class="literal">newstring</code> are populated using <code class="literal">getChangelogString</code>.</p><p>These fields are the ones used while displaying the change history.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Migrating from one custom field type to another</h1></div></div></div><p>Have you been using JIRA for more than a year or are you a power user of JIRA? That is, have you performed huge customizations, created numerous plugins, used lot of use cases, and so on? Then it is very likely that you have come across this scenario. You want to move the values from an old custom field to a new field.</p><a id="id560" class="indexterm"/><a id="id561" class="indexterm"/><p>JIRA doesn't have a standard way of doing this. But you can achieve this to an extent by modifying the JIRA database. Even with SQL, there are some restrictions for doing this.</p><p>The first and foremost thing to check is that both the fields are compatible. You can't move the values from a text field to a number field without extra checks and validations. If there is a value <code class="literal">1234a</code> stored in one of the issues, it can't be stored as a number field as it is not a valid number. The same applies to all the field types.</p><p>Let us see the migration of compatible types and discuss a few other scenarios in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec81"/>How to do it...</h2></div></div></div><p>Let us assume you have two text fields <code class="literal">Field A </code>and <code class="literal">Field B</code>. We need to migrate the values on every issue from <code class="literal">Field A </code>to <code class="literal">Field B</code>. Following are the steps that should be executed:</p><div><ol class="orderedlist arabic"><li class="listitem">Shut down the JIRA instance.</li><li class="listitem">Take a backup of the database. We can revert to this backup if anything goes wrong.</li><li class="listitem">Connect to your database:</li><li class="listitem">Execute the following SQL query:<div><pre class="programlisting">Update customfieldvalue set customfield = (select id from customfield where cfname='Field B')  where customfield = (select id from customfield where cfname='Field A')</pre></div><p>The query assumes that the custom field names are unique. If you have more than one custom field with the same name, use the IDs instead.</p></li><li class="listitem">Commit the changes.</li><li class="listitem">Disconnect from the database.</li><li class="listitem">Start JIRA.</li><li class="listitem">Re-index JIRA by going to <strong>Administration</strong> | <strong>System</strong> | <strong>Indexing</strong>.</li></ol></div><p>That should do it! Verify your changes both on the issue and in the filters.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>All the SQL statements and database references are based on Oracle 10g. Please modify it to suit your database.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec82"/>How it works...</h2></div></div></div><p>All that we did here was change the custom field ID in the <code class="literal">customfieldvalue</code> table. The other steps are standard steps for executing any SQL in JIRA.</p><p>Remember, if you have two custom fields with the same <code class="literal">name</code>, make sure you use the correct <code class="literal">id</code> instead of finding it using the <code class="literal">name</code> in SQL.</p><p>Now, this will work fine if both the fields are of the same type. But what if you want to move the values from one type to another? This may not always be possible because some of the values in the <code class="literal">customfieldvalue</code> table may not be compatible with other custom field types.</p><p>Let us consider migrating a normal text field to a text area custom field. The value in the <a id="id562" class="indexterm"/>
<a id="id563" class="indexterm"/>text area custom field is stored as a <code class="literal">CLOB</code> in the <code class="literal">textvalue</code> column in the database. But the value in a normal text field is stored as VARCHAR 2(255) in the <code class="literal">stringvalue</code> column. So, when you convert, we need to update the custom field ID, read the VARACHAR2(255) value from the <code class="literal">stringvalue</code> column and store it in the <code class="literal">textvalue</code> column as a <code class="literal">CLOB</code>. And set the no longer used <code class="literal">stringvalue</code> to <code class="literal">null</code> in order to free space in the database.</p><p>In this example, if you are trying the reverse order, that is, migrating from text area to text field, you should take into consideration the length of the text, and remove the extra text, as the text field can hold only up to 255 characters.</p><p>You can find the data type for the various custom fields by looking at the <code class="literal">getDatabaseType</code> method. For a <code class="literal">TextField</code>, the method looks as follows:</p><div><pre class="programlisting">protected PersistenceFieldType getDatabaseType()
{
  return PersistenceFieldType.TYPE_LIMITED_TEXT;
}</pre></div><p>Other available field types are <code class="literal">TYPE_UNLIMITED_TEXT</code> (for example, text area), <code class="literal">TYPE_DATE</code> (Date custom field), and <code class="literal">TYPE_DECIMAL</code> (for example, number field).</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec83"/>There's more...</h2></div></div></div><p>Sometimes we just need to change the type of a custom field instead of creating a new one and then migrating the values across. Let us quickly see how to do it.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec38"/>Changing the type of a custom field</h3></div></div></div><a id="id564" class="indexterm"/><p>In this case, the table that needs to be updated is the <code class="literal">CustomField</code> table. All we need to do is to update the <code class="literal">customfieldtypekey</code>. Just set the new custom field type key which will be {<code class="literal">YOUR_ATLASSIAN_PLUGIN_KEY}:{MODULE_KEY}</code>.</p><p>For a text field, the key is <code class="literal">com.atlassian.jira.plugin.system.customfieldtypes:textfield</code>.</p><p>For incompatible types, we need to consider all aforementioned cases and update the <code class="literal">CustomFieldValue</code> table accordingly.</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec84"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Retrieving custom field details from database</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Making custom fields sortable</h1></div></div></div><a id="id565" class="indexterm"/><a id="id566" class="indexterm"/><a id="id567" class="indexterm"/><p>We have seen the creation of new custom fields, writing new searchers for them, and so on. Another important feature with the fields, be it custom fields or the standard JIRA fields, is to use them for sorting. But simply writing a new custom field type won't enable sorting on that field.</p><p>In this recipe, we will see how to enable sorting on custom fields.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec85"/>Getting ready</h2></div></div></div><p>Create the new custom field type that we need to enable searching for.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec86"/>How to do it...</h2></div></div></div><p>This is easy to do. There are only two simple steps that you need to do to make sure the custom field is a sortable field:</p><div><ol class="orderedlist arabic"><li class="listitem">Implement the <code class="literal">SortableCustomField</code> interface<a id="id568" class="indexterm"/>. A new custom field type will look like the following:<div><pre class="programlisting">public class DemoCFType extends AbstractCustomFieldType implements SortableCustomField</pre></div><p>If you are extending an existing custom field type like <code class="literal">TextCFType</code>, it already implements the interface.</p></li><li class="listitem">Implement the <code class="literal">compare</code> method<a id="id569" class="indexterm"/>. Following is an example:<div><pre class="programlisting">public int compare(Object customFieldObjectValue1, Object customFieldObjectValue2, FieldConfig fieldConfig)
{
  return new DemoComparator().compare(customFieldObjectValue1, customFieldObjectValue2);
}</pre></div><p><code class="literal">DemoComparator</code> here is a custom comparator that we can write to implement the sorting logic.</p><p>Just invoke <code class="literal">SortableCustomField.compare()</code> if a custom comparator is not needed.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec87"/>How it works...</h2></div></div></div><a id="id570" class="indexterm"/><a id="id571" class="indexterm"/><a id="id572" class="indexterm"/><p>Once the custom field implements the <code class="literal">SortableCustomField</code> interface, we can click on its header on the issue navigator, and see it getting sorted based on the logic we implemented.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec88"/>There's more...</h2></div></div></div><p><code class="literal">BestNameComparator</code>, <code class="literal">FullNameComparator</code>, <code class="literal">LocaleComparator</code>, <code class="literal">GenericValueComparator</code>, and so on, are some reusable comparators that ships with JIRA. There is no definite list, but you will find quite a lot of them in the JIRA source, if you have access.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec89"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing a simple custom field</em></li><li class="listitem" style="list-style-type: disc"><em>Making the custom field project importable</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Displaying custom fields on subtask columns</h1></div></div></div><a id="id573" class="indexterm"/><a id="id574" class="indexterm"/><a id="id575" class="indexterm"/><p>This is one of the easiest things that you can do! But it adds a lot of value at times. We are talking about adding extra columns for subtasks on the parent issue page.</p><p>We know how to add extra fields, don't we? Let us see how to do it and especially how to add custom fields.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec90"/>How to do it...</h2></div></div></div><p>In short, you need to modify the <code class="literal">jira.table.cols.subtasks</code> property in the <code class="literal">jira-application.properties</code>. Following are the steps to do it. We add a custom field in the example shown here.</p><div><ol class="orderedlist arabic"><li class="listitem">Stop JIRA.</li><li class="listitem">Navigate to the <code class="literal">WEB-INF/classes</code> folder and modify the <code class="literal">jira.table.cols.subtasks</code> property in the <code class="literal">jira-application.properties</code> file:<div><pre class="programlisting">jira.table.cols.subtasks = issuetype, status, assignee, customfield_10140, progress</pre></div></li><li class="listitem">Add the extra fields you want to add along with the existing fields like status, assignee, and so on. For a custom field to be added in the columns, add <code class="literal">customfield_xxxxxx</code> where <code class="literal">xxxxx</code> is the unique numeric ID of the custom field. You can find this unique ID from the database or from the URL when you hover over any of the operations on the custom field (for example, Edit).</li><li class="listitem">Start JIRA.</li></ol></div><p>From JIRA 4.4, this property is available under <strong>Administration</strong> | <strong>General Configuration</strong> | <strong>Advanced</strong>. There is no need to modify the property file and restart JIRA.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec91"/>How it works...</h2></div></div></div><a id="id576" class="indexterm"/><a id="id577" class="indexterm"/><a id="id578" class="indexterm"/><p>JIRA renders the subtask columns on the view issue page by looking at the preceding property. While adding the standard subtask fields are useful, adding custom fields can be extremely helpful sometimes.</p><p>In our example, we have added <code class="literal">customfield_10140</code>, where <code class="literal">10140</code> is the numeric ID for the custom field. It stores the URL associated with the task, as shown:</p><div><img src="img/1803-03-02.jpg" alt="How it works..."/></div><p>Looks useful, doesn't it?</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>User and date fields from 4.1.x</h1></div></div></div><a id="id579" class="indexterm"/><a id="id580" class="indexterm"/><a id="id581" class="indexterm"/><a id="id582" class="indexterm"/><p>If you have upgraded from a pre 4.1 to a post 4.1 version, you must have noticed the new <strong>View Issue </strong>page. People have different opinions on the new UI usability, but one thing that gets everyone's vote is how the date and user fields are arranged in the UI. You will see a section of its own for the user and date fields, as shown in the next screenshot:</p><div><img src="img/1803-03-03.jpg" alt="User and date fields from 4.1.x"/></div><p>So how do our fields appear in that section?</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec92"/>How to do it...</h2></div></div></div><p>When you write your new date fields or user fields, all you need to do to make it appear in the correct sections is to implement the right interface!</p><p>For a user field, the new custom field type class should implement the following interface:</p><div><pre class="programlisting">com.atlassian.jira.issue.fields.UserField</pre></div><p>For a date field, implement:</p><div><pre class="programlisting">com.atlassian.jira.issue.fields.DateField</pre></div><p>If you are extending the existing date fields or user fields, they already implement the interface, and hence they will appear automatically in there!</p><p>What if you do not want your field in the special date/user sections? Simply ignore these interfaces. The fields will appear just like normal custom fields and will then appear in the order specified under field configurations.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec93"/>How it works...</h2></div></div></div><a id="id583" class="indexterm"/><a id="id584" class="indexterm"/><a id="id585" class="indexterm"/><a id="id586" class="indexterm"/><p>This is quite simple. JIRA looks out for classes implementing the <code class="literal">UserField</code>/<code class="literal">DateField</code> interfaces and displays them in the respective sections. On the standard custom field section, it doesn't show these fields.</p><p>Ever wondered where this check is done in the JIRA source code? The view is rendered in the <code class="literal">ViewIssue</code> class, but the actual check is done in the <code class="literal">util</code> class: <code class="literal">com.atlassian.jira.issue.fields.util.FieldPredicates</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec94"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Writing a simple custom field</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Adding custom fields to notification mails</h1></div></div></div><p>One of the main features of JIRA is its capability to send notifications – to selected people on selected events! It is often a requirement from JIRA users to customize these notifications, mainly to add more content in the form of custom fields.</p><p>If you understand velocity templates, adding custom fields to notification mails is a cakewalk, as we would see in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec95"/>Getting ready</h2></div></div></div><a id="id587" class="indexterm"/><a id="id588" class="indexterm"/><a id="id589" class="indexterm"/><p>You should know the custom field ID that you need to add into the template. The <code class="literal">id</code> can be found in the URL that you see when you hover over the 'Edit' operation on the custom field in the administration page.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec96"/>How to do it...</h2></div></div></div><p>Let us have a look at adding a custom field, X, into a notification mail when an issue is updated. The following are the steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Identify the template that needs to be updated. For each event in JIRA, you can find the template associated with it in the <code class="literal">email-template-id-mappings.xml</code> residing under the <code class="literal">WEB-INF/classes</code> folder.<p>In this case, the event is <code class="literal">Issue Updated</code>, and the matching template is <code class="literal">issueupdated.vm</code>.</p><p>Once the template is identified, the files are present under <code class="literal">WEB-INF/classes/templates/email/text/</code> and <code class="literal">WEB-INF/classes/templates/email/html/</code>.</p></li><li class="listitem">Modify the template to include the custom field name and value wherever required.<p>The name of the custom field can be retrieved as follows:</p><div><pre class="programlisting">$customFieldManager.getCustomFieldObject("customfield_10010").getName()</pre></div><p>The actual value can be retrieved as follows:</p><div><pre class="programlisting">$issue.getCustomFieldValue($customFieldManager.getCustomFieldObject("customfield_10010")))</pre></div><p>In both the cases, <code class="literal">10010</code> is the numeric ID of the <code class="literal">customfield</code> that we discussed before.</p></li></ol></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec97"/>How it works...</h2></div></div></div><a id="id590" class="indexterm"/><a id="id591" class="indexterm"/><a id="id592" class="indexterm"/><p>The e-mail notifications are rendered using velocity templates. JIRA already has a lot of objects in the velocity context including <code class="literal">customFieldManager</code> and <code class="literal">issue</code> objects that we have just used. The full list of objects available in the velocity context for e-mail templates can be found in the Atlassian documentation at <a class="ulink" href="http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates">http://confluence.atlassian.com/display/JIRADEV/Velocity+Context+for+Email+Templates</a>.</p><p>In this case, we use the <code class="literal">customFieldManager</code> object to retrieve information about the custom field and then we use the <code class="literal">issue</code> object to retrieve its value from the issue.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Adding help text for a custom field</h1></div></div></div><a id="id593" class="indexterm"/><a id="id594" class="indexterm"/><a id="id595" class="indexterm"/><p>As our JIRA instance grows, demanding more and more information from the users through the custom fields, it becomes a norm to let the users know what we expect from them. Apart from a bunch of tutorials that we can prepare for them, it makes sense to give them some help right there on the screen, next to the field.</p><p>Let us see the various options on how to do it.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec98"/>Getting ready</h2></div></div></div><p>Make sure you have the custom field, for which the help needs to be displayed and configured properly.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec99"/>How to do it...</h2></div></div></div><p>There are various ways to provide help. Let us see the most widely accepted ways:</p><div><ol class="orderedlist arabic"><li class="listitem"><a id="id596" class="indexterm"/><a id="id597" class="indexterm"/><a id="id598" class="indexterm"/>Link to a help page.<p>This is just common sense. Just link to a documentation about the field, hosted somewhere. We can do this easily by adding few hyperlinks in the description of the custom field. We just need to reuse some of the JIRA styles to make sure the help appears consistent across the system.</p><p>The hyperlinks again can be added in two ways. They are as follows:</p><div><ol class="orderedlist loweralpha"><li class="listitem">Open the help document in a new window<p>Here we just link to an external page, which opens in a new window.</p><div><pre class="programlisting">My Demo Field &lt;a class="localHelp" href="http://www.j-tricks.com" title="Get My Help" target="_blank"&gt;&lt;img src="img/help_blue.gif"&lt;/a&gt;</pre></div><p><code class="literal">My Demo Field</code> here is the custom field name. As you can see, we use the image that ships along with JIRA for the consistency we discussed before. One thing we need to note here is the URL of the image – <code class="literal">/jira/images/icons/help_blue.gif</code>. In this case, we assume that <code class="literal">/jira</code> is the context path for this instance. If there is no context path, just use <code class="literal">/images/icons/help_blue.gif</code> or replace <code class="literal">/jira</code> using the context path of your instance!</p><p>Also notice the CSS class <code class="literal">localHelp</code>, which is again used for consistency across help texts. Modify the help URL and title as per your needs.</p></li><li class="listitem">Open the help document as a popup<p>Here we open the help document as a popup instead of opening a new window. The focus is passed to the new window.</p><div><pre class="programlisting">My Demo Field &lt;a class="localHelp" href="http://www.j-tricks.com" onclick="var child = window.open('http://www.google.com', 'myHelp', 'width=600, height=500, resizable, scrollbars=yes'); child.focus(); return false;"&gt;&lt;img src="img/help_blue.gif" title="Get My Help "&gt;&lt;/a&gt;</pre></div><p>Again, the image and CSS files remain the same. Here we can specify the width, height, and so on, of the pop-up window as shown in the preceding code. Everything else remains the same!</p></li></ol></div></li><li class="listitem">Provide inline help.<a id="id599" class="indexterm"/><a id="id600" class="indexterm"/><a id="id601" class="indexterm"/><p>This is suitable if the help isn't big enough to be put in documentation, but at the same time you don't want them to appear along with the description of the field! In this case, we go for a little JavaScript trick where we hide the help text under an HTML <code class="literal">DIV</code> and toggle the visibility as the user clicks on the help image.</p><p>Put the following under the field description after modifying the relevant text. Here, <code class="literal">My Demo Field</code> is the actual field description and <code class="literal">Inline help for my demo field!</code> is the extra help we added:</p><div><pre class="programlisting">My Demo Field&lt;a class="localHelp" href="#"  onclick=" AJS.$('#mdfFieldHelp').toggle();"&gt;&lt;img src="img/help_blue.gif"&lt;/a&gt;
&lt;div id="mdfFieldHelp" style="display:none"&gt;
Inline help for my demo field!
&lt;/div&gt;</pre></div></li></ol></div><p>Short and sweet, right?</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec100"/>How it works...</h2></div></div></div><p>JIRA, thankfully, allows HTML rendering on its description field. We have just used the HTML capabilities to provide some help for the field. It gives us lot of options and the aforementioned ones are just pointers on how to exploit it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Removing the 'none' option from a select field</h1></div></div></div><a id="id602" class="indexterm"/><a id="id603" class="indexterm"/><a id="id604" class="indexterm"/><p>If you are a JIRA plugin developer, you must have come across this feature request before. Some people just don't like the 'none' option in the select fields for various reasons. One reason, obviously, is to force the users to select a valid value.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec101"/>How to do it...</h2></div></div></div><p><code class="literal">Select Field</code> is a system custom field that uses velocity templates to render the view and edit screens. In order to remove the <code class="literal">none</code> option, we need to modify the edit template.</p><p>For any system custom field, you can find the associated classes and their velocity templates from the file <code class="literal">system-customfieldtypes-plugin.xml</code> residing under the <code class="literal">WEB-INF/classes</code> folder.</p><p>In our case, we can find the following snippet related to <code class="literal">select-field</code>:</p><div><pre class="programlisting">&lt;customfield-type key="select" name="Select List"
        i18n-name-key="admin.customfield.type.select.name"
        class="com.atlassian.jira.issue.customfields.impl.SelectCFType"&gt;
        &lt;description key="admin.customfield.type.select.desc"&gt;A single select list with a configurable list of options.&lt;/description&gt;
        &lt;resource type="velocity" name="view" location="templates/plugins/fields/view/view-rawtext.vm"/&gt;
        &lt;resource type="velocity" name="edit" location="templates/plugins/fields/edit/edit-select.vm"/&gt;
        &lt;resource type="velocity" name="xml" location="templates/plugins/fields/xml/xml-basictext.vm"/&gt;
    &lt;/customfield-type&gt;</pre></div><p>As evident from the preceding snippet, the edit template for the select field is <code class="literal">templates/plugins/fields/edit/edit-select.vm</code>. That is the file we need to modify.</p><p>All we need to do now is to navigate to the file and remove the following lines:</p><div><pre class="programlisting">#if (!$fieldLayoutItem || $fieldLayoutItem.required == false)
   &lt;option value="-1"&gt;$i18n.getText("common.words.none")&lt;/option&gt;
   #else
   &lt;option value=""&gt;$i18n.getText("common.words.none")&lt;/option&gt;
   #end</pre></div><p>The remaining code in the template <em>must not</em> be deleted.</p><a id="id605" class="indexterm"/><a id="id606" class="indexterm"/><a id="id607" class="indexterm"/><p>Restart JIRA to make the change effective.</p><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The same approach can be used to remove the <code class="literal">none</code> option from other fields like 'radio buttons', 'multi select', 'cascading select', and so on. The actual code to remove will differ, but the approach is the same.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec102"/>There's more...</h2></div></div></div><p>There's more to it…</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec39"/>Reloading velocity changes without restart (auto reloading)</h3></div></div></div><a id="id608" class="indexterm"/><p>You can configure JIRA to reload the changes to velocity templates without a restart. To do this, you need to make two changes to the <code class="literal">velocity.properties</code> file under <code class="literal">WEB-INF/classes</code>:</p><div><ol class="orderedlist arabic"><li class="listitem">Set the <code class="literal">class.resource.loader.cache</code> property to <code class="literal">false</code>. It is true, by default.</li><li class="listitem">Uncomment the <code class="literal">velocimacro.library.autoreload=true</code> property. This can be done by removing the <code class="literal">#</code> at the beginning of the line.</li></ol></div><p>Restart JIRA and then the changes to the velocity templates will be reloaded without another restart!</p></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec103"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Changing the size of a text area custom field</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Making the custom field project importable</h1></div></div></div><p>As of JIRA 3.13, individual projects can be imported from an existing JIRA backup file. More information on this can be found at <a class="ulink" href="http://confluence.atlassian.com/display/JIRA/Restoring+a+Project+from+Backup">http://confluence.atlassian.com/display/JIRA/Restoring+a+Project+from+Backup</a>.</p><p>While importing projects, JIRA lets you copy all the issue data across, but only if it is asked to do so! Let us see how we can make the custom fields' project importable, or in simple words, inform JIRA that our fields are okay to be imported!</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec104"/>How to do it...</h2></div></div></div><a id="id609" class="indexterm"/><a id="id610" class="indexterm"/><p>All we need to do to tag our custom field project as importable is to implement the following interface: <code class="literal">com.atlassian.jira.imports.project.customfield.ProjectImportableCustomField</code>.</p><p>You will have to then implement the following method:</p><div><pre class="programlisting">ProjectCustomFieldImporter getProjectImporter();</pre></div><p>There are already existing implementations for the <code class="literal">ProjectCustomFieldImporter</code> class like the <code class="literal">SelectCustomFieldImporter</code> class, which we can reuse. It is in this class that we check whether the value getting imported is a valid value or not.</p><p>For example, in the case of a <code class="literal">select</code> field, we need to make sure that the value being imported is a valid option configured in the custom field on the target system. It is entirely up to the users to implement the various rules at this stage.</p><a id="id611" class="indexterm"/><a id="id612" class="indexterm"/><p>See the Javadocs at: <a class="ulink" href="http://docs.atlassian.com/jira/latest/com/atlassian/jira/imports/project/customfield/ProjectCustomFieldImporter.html">http://docs.atlassian.com/jira/latest/com/atlassian/jira/imports/project/customfield/ProjectCustomFieldImporter.html</a> for more details on doing custom <code class="literal">ProjectCustomFieldImporter</code> implementations.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec105"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Making custom fields sortable</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Changing the size of a text area custom field</h1></div></div></div><p>As we have discussed before, JIRA ships with some pre-defined custom field types. One such commonly used type is the Text Area field.</p><p>The Text Area field has a pre-defined width and height which is not customizable. It is often a requirement from the JIRA users to increase the size of the field either globally or for a particular custom field.</p><p>We will have a look at how to achieve this in the recipe.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec106"/>How to do it...</h2></div></div></div><a id="id613" class="indexterm"/><a id="id614" class="indexterm"/><a id="id615" class="indexterm"/><p>Just like any other custom fields, the Text Area field is also rendered using velocity templates. From the <code class="literal">system-customfieldtypes-plugin.xml</code> file, we can find out that the location of the edit template is <code class="literal">templates/plugins/fields/edit/edit-textarea.vm</code>.</p><div><pre class="programlisting">&lt;customfield-type key="textarea" name="Free Text Field (unlimited text)"
    ............................................
    &lt;resource type="velocity" name="edit" location="templates/plugins/
    fields/edit/edit-textarea.vm"/&gt;
    ...................................
&lt;/customfield-type&gt;</pre></div><p>If we need to increase the size, we need to modify the template to increase the <code class="literal">rows</code> or <code class="literal">cols</code> property, as per the requirement.</p><p>If we need to increase the width (number of columns) to 50 and height (number of rows) to 8, the <code class="literal">cols</code> and <code class="literal">rows</code> properties need to be updated to 50 and 8, respectively. The template will then look like the following code:</p><div><pre class="programlisting">#controlHeader ($action $customField.id $customField.name $fieldLayoutItem.required $displayParameters.noHeader)

#if ($!customField.isRenderable() &amp;&amp; $rendererDescriptor)

  ## setup some additional parameters
  $!rendererParams.put("rows", "8")
  $!rendererParams.put("cols", "50")
  $!rendererParams.put("wrap", "virtual")

  ## let the renderer display the edit component
  $rendererDescriptor.getEditVM($!value, $!issue.key, $!fieldLayoutItem.rendererType, $!customField.id, $!customField.name, $rendererParams, false)
#else
  &lt;textarea name="$customField.id"
            id="$customField.id"
            class="textfield"
            rows="8" cols="50" wrap="virtual"
  &gt;$textutils.htmlEncode($!value)&lt;/textarea&gt;
#end

#controlFooter ($action $fieldLayoutItem.fieldDescription $displayParameters.noHeader)</pre></div><a id="id616" class="indexterm"/><a id="id617" class="indexterm"/><a id="id618" class="indexterm"/><p>If this needs to be done only for a selected <code class="literal">customfield</code>, just add a condition at the beginning of the template to handle the custom field separately. The template will then look like the following lines of code:</p><div><pre class="programlisting">#controlHeader ($action $customField.id $customField.name $fieldLayoutItem.required $displayParameters.noHeader)
 
#if ($!customField.id=="customfield_10010")
  ## Modify rows and cols only for this custom field
  $!rendererParams.put("rows", "8")
  $!rendererParams.put("cols", "50")
  $!rendererParams.put("wrap", "virtual")
 
  ## let the renderer display the edit component
  $rendererDescriptor.getEditVM($!value, $!issue.key, $!fieldLayoutItem.rendererType, $!customField.id, $!customField.name, $rendererParams, false)
 
#elseif ($!customField.isRenderable() &amp;&amp; $rendererDescriptor)
 // reminder of the above snippet here
.................................................................
 
#controlFooter ($action $fieldLayoutItem.fieldDescription $displayParameters.noHeader)</pre></div><p>Hopefully, that gives you an idea about increasing the size of the Text Area custom field.</p><a id="id619" class="indexterm"/><a id="id620" class="indexterm"/><a id="id621" class="indexterm"/><p>As usual, JIRA should be restarted to make this change effective, unless <em>velocity autoloading</em> is enabled, as we discussed in the previous recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec107"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><em>Removing the 'none' option from a select field</em></li></ul></div></div></div></body></html>