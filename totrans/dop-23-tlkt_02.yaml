- en: Running Kubernetes Cluster Locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of my goals in this book is to limit the learning expense to a minimum.
    True to that spirit, we'll run local Kubernetes clusters for as long as possible.
    At one point we'll have to switch to a hosted, multi-node Kubernetes cluster.
    I'll do my best to postpone that for as long as possible without limiting your
    learning experience. For now, we'll create a local Kubernetes cluster on your
    laptop.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few ways to set up a local Kubernetes cluster. We could, for
    example, create a few nodes with Vagrant ([https://www.vagrantup.com/](https://www.vagrantup.com/))
    and execute quite a few shell commands that would convert them into a Kubernetes
    cluster. We could go even further and create a VirtualBox image that would have
    all the required software pre-installed and use it to create Vagrant VMs. We could
    also use Ansible to run provisioning of those images as well as to execute all
    the commands required to join VMs into a cluster. There are many other things
    that we could do, but we won't.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, the idea is not to teach you all the intricacies of setting up
    a Kubernetes cluster. Instead, I want to get you up to speed as fast as possible
    and let you experience Kubernetes without sidelining that experience with installation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the subject of this book would be Docker Swarm (as it was in *The DevOps
    2.1 Toolkit: Docker Swarm*), we''d have Docker for Mac or Windows (or run it natively
    on Linux) and execute a single `docker swarm init` command. That''s all that''s
    needed to create a local Docker Swarm cluster. Can we accomplish the same simplicity
    with Kubernetes?'
  prefs: []
  type: TYPE_NORMAL
- en: In October of 2017, Docker announced initial support for Kubernetes in Docker
    for Mac and Windows. At the time of this writing, it is available only for Mac
    in the edge channel.
  prefs: []
  type: TYPE_NORMAL
- en: Minikube creates a single-node cluster inside a VM on your laptop. While that
    is not ideal since we won't be able to demonstrate some of the features Kubernetes
    provides in a multi-node setup, it should be more than enough to explain most
    of the concepts behind Kubernetes. Later on, we'll move into a more production-like
    environment and explore the features that cannot be demonstrated in Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: A note to Windows users
  prefs: []
  type: TYPE_NORMAL
- en: Please run all the examples from *GitBash* (installed through *Git*). That way
    the commands you'll see throughout the book will be same as those that should
    be executed on *MacOS* or any *Linux* distribution. If you're using Hyper-V instead
    of VirtualBox, you may need to run the *GitBash* window as an Administrator.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into Minikube installation, there are a few prerequisites we
    should set up. The first in line is `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing kubectl
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kubernetes' command-line tool, `kubectl`, is used to manage a cluster and applications
    running inside it. We'll use `kubectl` a lot throughout the book, so we won't
    go into details just yet. Instead, we'll discuss its commands through examples
    that will follow shortly. For now, think of it as your interlocutor with a Kubernetes
    cluster.
  prefs: []
  type: TYPE_NORMAL
- en: Let's install `kubectl`.
  prefs: []
  type: TYPE_NORMAL
- en: All the commands from this chapter are available in the `02-minikube.sh` ([https://gist.github.com/vfarcic/77ca05f4d16125b5a5a5dc30a1ade7fc](https://gist.github.com/vfarcic/77ca05f4d16125b5a5a5dc30a1ade7fc))
    Gist.
  prefs: []
  type: TYPE_NORMAL
- en: Feel free to skip the installation steps if you already have `kubectl`. Just
    make sure that it is version 1.8 or above.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are a **MacOS user**, please execute the commands that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If you already have Homebrew ([https://brew.sh/](https://brew.sh/)) package
    manager installed, you can "brew" it with the command that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you''re a **Linux user**, the commands that will install
    `kubectl` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Finally, **Windows users** should download the binary through the command that
    follows.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to copy the binary to any directory. The important thing is to add
    it to your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check `kubectl` version and, at the same time, validate that it is working
    correctly. No matter which OS you''re using, the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The connection to the server `localhost:8080` was refused-did you specify the
    right host or port?
  prefs: []
  type: TYPE_NORMAL
- en: That is a very ugly and unreadable output. Fortunately, `kubectl` can use a
    few different formats for its output. For example, we can tell it to output the
    command in `yaml` format
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: That was a much better (more readable) output.
  prefs: []
  type: TYPE_NORMAL
- en: We can see that the client version is 1.9\. At the bottom is the error message
    stating that `kubectl` could not connect to the server. That is expected since
    we did not yet create a cluster. That's our next step.
  prefs: []
  type: TYPE_NORMAL
- en: At the time of writing this book kubectl version was 1.9.0\. Your version might
    be different when you install.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Minikube supports several virtualization technologies. We'll use VirtualBox
    throughout the book since it is the only virtualization supported in all operating
    systems. If you do not have it already, please head to the Download VirtualBox
    ([https://www.virtualbox.org/wiki/Downloads](https://www.virtualbox.org/wiki/Downloads))
    page and get the version that matches your OS. Please keep in mind that for VirtualBox
    or HyperV to work, virtualization must be enabled in the BIOS. Most laptops should
    have it enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can install Minikube.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re using **MacOS**, please execute the command that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If, on the other hand, you prefer **Linux**, the command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finally, you will not get a command if you are a Windows user. Instead, download
    the latest release from of the `minikube-windows-amd64.exe` ([https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe](https://storage.googleapis.com/minikube/releases/latest/minikube-windows-amd64.exe))
    file, rename it to `minikube.exe`, and add it to your path.
  prefs: []
  type: TYPE_NORMAL
- en: We'll test whether Minikube works by checking its version.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now we're ready to give the cluster a spin.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a local Kubernetes cluster with Minikube
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The folks behind Minikube made creating a cluster as easy as it can get. All
    we need to do is to execute a single command. Minikube will start a virtual machine
    locally and deploy the necessary Kubernetes components into it. The VM will get
    configured with Docker and Kubernetes via a single binary called localkube.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: A note to Windows users
  prefs: []
  type: TYPE_NORMAL
- en: 'You might experience problems with `virtualbox`. If that''s the case, you might
    want to use `hyperv` instead. Open a Powershell Admin Window and execute the `Get-NetAdapter`
    command, noting the name of your network connection. Create a `hyperv` virtual
    switch `New-VMSwitch -name NonDockerSwitch -NetAdapterName Ethernet -AllowManagementOS
    $true` replacing `Ethernet` with your network connection name. Then create the
    Minikube vm: `minikube start --vm-driver=hyperv --hyperv-virtual-switch "NonDockerSwitch"
    --memory=4096`. Other minikube commands such as `minikube start`, `minikube stop`,
    and `minikube delete` all work the same whether you''re using VirutalBox or Hyper-V.'
  prefs: []
  type: TYPE_NORMAL
- en: A few moments later, a new Minikube VM will be created and set up, and a cluster
    will be ready for use.
  prefs: []
  type: TYPE_NORMAL
- en: When we executed the `minikube start` command, it created a new VM based on
    the Minikube image. That image contains a few binaries. It has both `Docker` ([https://www.docker.com/](https://www.docker.com/))
    and `rkt` ([https://coreos.com/rkt/](https://coreos.com/rkt/)) container engines
    as well as `localkube` library. The library includes all the components necessary
    for running Kubernetes. We'll go into details of all those components later. For
    now, the important thing is that localkube provides everything we need to run
    a Kubernetes cluster locally.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7bc69942-e243-4ced-bcaf-5df7d15beec7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-1: Minikube simplified architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Remember that this is a single-node cluster. While that is unfortunate, it is
    still the easiest way (as far as I know) to "play" with Kubernetes locally. It
    should do, for now. Later on, we'll explore ways to create a multi-node cluster
    that will be much closer to a production setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the status of the cluster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Minikube is running, and it initialized a Kubernetes cluster. It even configured
    `kubectl` so that it points to the newly created VM.
  prefs: []
  type: TYPE_NORMAL
- en: You won't see much UI in this book. I believe that a terminal is the best way
    to operate a cluster. More importantly, I am convinced that one should master
    a tool through its commands first. Later on, once we feel comfortable and understand
    how the tool works, we can choose to use a UI on top of it. We'll explore the
    Kubernetes UI in one of the later chapters. For now, I'll let you have a quick
    glimpse of it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Feel free to explore the UI but don't take too long. You'll only get confused
    with concepts that we did not yet study. Once we learn about pods, replica-sets,
    services, and a myriad of other Kubernetes components, the UI will start making
    much more sense.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/312187e1-b120-4562-a13d-8c8d76f4b4a3.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2-2: Kubernetes dashboard'
  prefs: []
  type: TYPE_NORMAL
- en: Another useful Minikube command is `docker-env`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you worked with Docker Machine, you'll notice that the output is the same.
    Both `docker-machine env` and `minikube docker-env` serve the same purpose. They
    output the environment variables required for a local Docker client to communicate
    with a remote Docker server. In this case, that Docker server is the one inside
    a VM created by Minikube. I assume that you already have Docker installed on your
    laptop. If that's not the case, please go to the install Docker ([https://docs.docker.com/install/](https://docs.docker.com/install/))
    page and follow the instructions for your operating system. Once Docker is installed,
    we can connect the client running on your laptop with the server in the Minikube
    VM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We evaluated (created) the environment variables provided through the `minikube
    docker-env` command. As a result, every command we send to our local Docker client
    will be executed on the Minikube VM. We can test that easily by, for example,
    listing all the running containers on that VM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The containers listed in the output are those required by Kubernetes. We can,
    in a way, consider them system containers. We won't discuss each of them. As a
    matter of fact, we won't discuss any of them. At least, not right away. All you
    need to know, at this point, is that they make Kubernetes work.
  prefs: []
  type: TYPE_NORMAL
- en: Since almost everything in that VM is a container, pointing the local Docker
    client to the service inside it should be all you need (besides `kubectl`). Still,
    in some cases, you might want to SSH into the VM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We entered into the Minikube VM, listed containers, and got out. There's no
    reason to do anything else beyond showing that SSH is possible, even though you
    probably won't use it.
  prefs: []
  type: TYPE_NORMAL
- en: What else is there to verify? We can, for example, confirm that `kubectl` is
    also pointing to the Minikube VM.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The output should be a single word, `minikube`, indicating that `kubectl` is
    configured to talk to Kubernetes inside the newly created cluster.
  prefs: []
  type: TYPE_NORMAL
- en: As an additional verification, we can list all the nodes of the cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It should come as no surprise that there is only one node, conveniently called
    `minikube`.
  prefs: []
  type: TYPE_NORMAL
- en: If you are experienced with Docker Machine or Vagrant, you probably noticed
    the similar pattern. Minikube commands are almost exactly the same as those from
    Docker Machine which, on the other hand, are similar to those from Vagrant.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make a sneak peek into the components currently running in our tiny cluster.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Behold, the cluster in all its glory. It's made out of many building blocks
    we are yet to explore. Moreover, those are only the beginning. We'll be adding
    more as our needs and knowledge increase. For now, remember that there are many
    moving pieces. We won't go into details just yet. That would be too much to start
    with.
  prefs: []
  type: TYPE_NORMAL
- en: Going back to minikube, we can do all the common things we would expect from
    a virtual machine. For example, we can stop it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We can start it again.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We can delete it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: One interesting feature is the ability to specify which Kubernetes version we'd
    like to use.
  prefs: []
  type: TYPE_NORMAL
- en: Since Kubernetes is still a young project, we can expect quite a lot of changes
    at a rapid pace. That will often mean that our production cluster might not be
    running the latest version. On the other hand, we should strive to have our local
    environment as close to production as possible (within reason).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can list all the available versions with the command that follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The output, limited to the first few lines, is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know which versions are available, we can create a new cluster based
    on, let's say, Kubernetes v1.7.0.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: We created a new cluster and output versions of the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output of the latter command is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you focus on the `serverVersion` section, you'll notice that the `major`
    version is `1` and the `minor` is `7`.
  prefs: []
  type: TYPE_NORMAL
- en: What now?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are finished with a short introduction to Minikube. Actually, this might
    be called a long introduction as well. We use it to create a single-node Kubernetes
    cluster, launch the UI, do common VM operations like `stop`, `restart`, and `delete`,
    and so on. There's not much more to it. If you are familiar with Vagrant or Docker
    Machine, the principle is the same, and the commands are very similar.
  prefs: []
  type: TYPE_NORMAL
- en: Before we leave, we'll destroy the cluster. The next chapter will start fresh.
    That way, you can execute commands from any chapter at any time.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: That's it. The cluster is no more.
  prefs: []
  type: TYPE_NORMAL
