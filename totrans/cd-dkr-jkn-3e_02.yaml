- en: '*Chapter 1*: Introducing Continuous Delivery'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A common problem that's faced by most developers is how to release the implemented
    code quickly and safely. The delivery process that's traditionally used is a source
    of pitfalls and usually leads to the disappointment of both developers and clients.
    This chapter will present the idea of the **continuous delivery** (**CD**) approach
    and provide the context for the rest of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The automated deployment pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prerequisites to CD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining CD and microservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building the CD process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most accurate definition of CD is stated by *Jez Humble* and reads as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"Continuous delivery is the ability to get changes of all types – including
    new features, configuration changes, bug fixes, and experiments – into production,
    or into the hands of users, safely and quickly, in a sustainable way."'
  prefs: []
  type: TYPE_NORMAL
- en: This definition covers the key points.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s imagine a scenario. You are responsible for
    a product – let''s say, an email client application. Users come to you with a
    new requirement: they want to sort emails by size. You decide that the development
    will take around 1 week. *When can the user expect to use the feature?* Usually,
    after the development is done, you hand over the completed feature to the **Quality
    Assurance** (**QA**) team and then to the operations team, which takes additional
    time, ranging from days to months.'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, even though the development only took 1 week, the user receives it
    in a couple of months! The CD approach addresses this issue by automating manual
    tasks so that the user can receive a new feature as soon as it's implemented.
  prefs: []
  type: TYPE_NORMAL
- en: To help you understand what to automate and how, we'll start by describing the
    delivery process that is currently used for most software systems.
  prefs: []
  type: TYPE_NORMAL
- en: The traditional delivery process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The traditional delivery process, as its name suggests, has been in place for
    many years and is implemented in most IT companies. Let's define how it works
    and comment on its shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the traditional delivery process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Every delivery process begins with the requirements that have been defined
    by a customer and ends with the product being released to production. There are
    differences between these two stages. Traditionally, this process looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Release cycle diagram'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_01.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.1 – Release cycle diagram
  prefs: []
  type: TYPE_NORMAL
- en: 'The release cycle starts with the requirements provided by the **Product Owner**,
    who represents the **Customer** (stakeholders). Then, there are three phases,
    during which the work is passed between different teams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development**: The developers (sometimes together with business analysts)
    work on the product. They often use agile techniques (Scrum or Kanban) to increase
    the development velocity and improve communication with the client. Demo sessions
    are organized to obtain a customer''s quick feedback. All good development techniques
    (such as **test-driven development** (**TDD**) or extreme programming practices)
    are welcome. Once the implementation is complete, the code is passed to the QA
    team.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality Assurance**: This phase is usually called **User Acceptance Testing** (**UAT**)
    and it requires the code to be frozen on the trunk code base so that no new development
    will break the tests. The QA team performs a suite of **integration testing**, **acceptance
    testing**, and **non-functional analysis** (performance, recovery, security, and
    so on). Any bug that is detected goes back to the development team, so the developers
    usually have their hands full. After the UAT phase is completed, the QA team approves
    the features that have been planned for the next release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Operations**: The final phase, and usually the shortest one, involves passing
    the code to the operations team so that they can perform the release and monitor
    the production environment. If anything goes wrong, they contact the developers
    so that they can help with the production system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The length of the release cycle depends on the system and the organization,
    but it usually ranges from 1 week to a few months. The longest I''ve heard about
    was 1 year. The longest I worked on one was quarterly-based, and each part was
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Development**: 1.5 months'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UAT**: 1 month and 3 weeks'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Release (and strict production monitoring)**: 1 week'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The traditional delivery process is widely used in the IT industry, so this
    is probably not the first time you've read about such an approach. Nevertheless,
    it has several drawbacks. Let's look at them explicitly to understand why we need
    to strive for something better.
  prefs: []
  type: TYPE_NORMAL
- en: Shortcomings of the traditional delivery process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most significant shortcomings of the traditional delivery process are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Slow delivery**: The customer receives the product long after the requirements
    were specified. This results in unsatisfactory time to market and delays customer
    feedback.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long feedback cycle**: The feedback cycle is not only related to customers
    but developers. Imagine that you accidentally created a bug, and you learn about
    it during the UAT phase. *How long does it take to fix something you worked on
    2 months ago?* Even dealing with minor bugs can take weeks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lack of automation**: Rare releases do not encourage automation, which leads
    to unpredictable releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Risky hotfixes**: Hotfixes cannot usually wait for the full UAT phase, so
    they tend to be tested differently (the UAT phase is shortened) or not tested
    at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stress**: Unpredictable releases are stressful for the operations team. What''s
    more, the release cycle is usually tightly scheduled, which imposes additional
    stress on developers and testers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Poor communication**: Work that''s passed from one team to another represents
    the waterfall approach, in which people start to care only about their part, rather
    than the complete product. If anything goes wrong, that usually leads to the blame
    game instead of cooperation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Shared responsibility**: No team takes responsibility for the product from
    A to Z:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For developers**: *Done* means that the requirements have been implemented.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For testers**: *Done* means that the code has been tested.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**For operations**: *Done* means that the code has been released.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower job satisfaction**: Each phase is interesting for a different team,
    but other teams need to support the process. For example, the development phase
    is interesting for developers but, during the other two phases, they still need
    to fix bugs and support the release, which is usually not interesting for them
    at all.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These drawbacks represent just the tip of the iceberg of the challenges related
    to the traditional delivery process. You may already feel that there must be a
    better way to develop software and this better way is, obviously, the CD approach.
  prefs: []
  type: TYPE_NORMAL
- en: The benefits of CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*How long would it take your organization to deploy a change that involves
    just a single line of code?* *Do you do this on a repeatable, reliable basis?* These
    are the famous questions from *Mary* and *Tom Poppendieck* (authors of *Implementing
    Lean Software Development*), which have been quoted many times by *Jez Humble* and
    others. The answers to these questions are the only valid measurement of the health
    of your delivery process.'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to deliver continuously, and not spend a fortune on the army of operations
    teams working 24/7, we need automation. That is why, in short, CD is all about
    changing each phase of the traditional delivery process into a sequence of scripts
    called the *automated deployment pipeline*, or the *CD pipeline*. Then, if no
    manual steps are required, we can run the process after every code change and
    deliver the product continuously to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'CD lets us get rid of the tedious release cycle and brings the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Fast delivery**: Time to market is significantly reduced as customers can
    use the product as soon as development is completed. Remember that the software
    delivers no revenue until it is in the hands of its users.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fast feedback cycle**: Imagine that you created a bug in the code, which
    goes into production the same day. *How much time does it take to fix something
    you worked on the same day?* Probably not much. This, together with the quick
    rollback strategy, is the best way to keep production stable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Low-risk releases**: If you release daily, the process becomes repeatable
    and much safer. As the saying goes, *if it hurts, do it more often*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexible release options**: If you need to release immediately, everything
    is already prepared, so there is no additional time/cost associated with the release
    decision.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Needless to say, we could achieve all these benefits simply by eliminating all
    the delivery phases and proceeding with development directly from production.
    However, this would result in a reduction in quality. The whole difficulty of
    introducing CD is the concern that the quality would decrease alongside eliminating
    any manual steps. In this book, we will show you how to approach CD safely and
    explain why, contrary to common beliefs, products that are delivered continuously
    contain fewer bugs and are better adjusted to the customer's needs.
  prefs: []
  type: TYPE_NORMAL
- en: Success stories
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: My favorite story on CD was told by Rolf Russell at one of his talks. It goes
    as follows. In 2005, Yahoo! acquired Flickr, and it was a clash of two cultures
    in the developer's world. Flickr, by that time, was a company with the start-up
    approach in mind. Yahoo!, on the other hand, was a huge corporation with strict
    rules and a safety-first attitude. Their release processes differed a lot. While
    Yahoo used the traditional delivery process, Flickr released many times a day.
    Every change that was implemented by developers went into production the same
    day. They even had a footer at the bottom of their page showing the time of the
    last release and the avatars of the developers who made the changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yahoo! deployed rarely, and each release brought a lot of changes that were
    well-tested and prepared. Flickr worked in very small chunks; each feature was
    divided into small incremental parts, and each part was deployed to production
    quickly. The difference is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Comparison of the release cycles of Yahoo! and Flickr'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.2 – Comparison of the release cycles of Yahoo! and Flickr
  prefs: []
  type: TYPE_NORMAL
- en: You can imagine what happened when the developers from the two companies met.
    Yahoo! treated Flickr's colleagues as irresponsible junior developers, a bunch
    of software cowboys who didn't know what they were doing. So, the first thing
    they wanted to do was add a QA team and the UAT phase to Flickr's delivery process.
    Before they applied the change, however, Flickr's developers had only one wish.
    They asked to evaluate the most reliable products throughout Yahoo! as a whole.
    It came as a surprise when they saw that even with all the software in Yahoo!,
    Flickr had the lowest downtime. The Yahoo! team didn't understand it at first,
    but they let Flickr stay with their current process anyway. After all, they were
    engineers, so the evaluation result was conclusive. Only after some time had passed
    did the Yahoo! developers realize that the CD process could be beneficial for
    all the products in Yahoo! and they started to gradually introduce it everywhere.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important question of the story remains: *how come Flickr was the
    most reliable system?* The reason behind this was what we already mentioned in
    the previous sections. A release is less risky if the following is true:'
  prefs: []
  type: TYPE_NORMAL
- en: The delta of code changes is small
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The process is repeatable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is why, even though the release itself is a difficult activity, it is much
    safer when it's done frequently.
  prefs: []
  type: TYPE_NORMAL
- en: The story of Yahoo! and Flickr is only one example of many successful companies
    where the CD process proved to be the correct choice. Nowadays, it's common for
    even small organizations to release frequently and market leaders such as Amazon,
    Facebook, Google, and Netflix perform thousands of releases per day.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: You can read more about the research on the CD process and individual case studies
    at [https://continuousdelivery.com/evidence-case-studies/](https://continuousdelivery.com/evidence-case-studies/).
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the statistics get better every day. However, even without
    any numbers, just imagine a world in which every line of code you implement goes
    safely into production. Clients can react quickly and adjust their requirements,
    developers are happy as they don't have to solve that many bugs, and managers
    are satisfied because they always know the current state of work. After all, remember
    that the only true measure of progress is the software that is released.
  prefs: []
  type: TYPE_NORMAL
- en: The automated deployment pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already know what the CD process is and why we use it. In this section, we'll
    describe how to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by emphasizing that each phase in the traditional delivery process
    is important. Otherwise, it would never have been created in the first place.
    No one wants to deliver software without testing it! The role of the UAT phase
    is to detect bugs and ensure that what the developers have created is what the
    customer wanted. The same applies to the operations team – the software must be
    configured, deployed to production, and monitored. That''s out of the question.
    So, *how do we automate the process so that we preserve all the phases?* That
    is the role of the automated deployment pipeline, which consists of three stages,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Automated deployment pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.3 – Automated deployment pipeline
  prefs: []
  type: TYPE_NORMAL
- en: The automated deployment pipeline is a sequence of scripts that is executed
    after every code change is committed to the repository. If the process is successful,
    it ends up being deployed to the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each step corresponds to a phase in the traditional delivery process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Continuous integration**: This checks to make sure that the code that''s
    been written by different developers is integrated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated acceptance testing**: This checks if the client''s requirements
    have been met by the developers implementing the features. This testing also replaces
    the manual QA phase.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configuration management**: This replaces the manual operations phase; it
    configures the environment and deploys the software.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's take a deeper look at each phase to understand its responsibility and
    what steps it includes.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **continuous integration** (**CI**) phase provides the first set of feedback
    to developers. It checks out the code from the repository, compiles it, runs unit
    tests, and verifies the code's quality. If any step fails, the pipeline's execution
    is stopped and the first thing the developers should do is fix the CI build. The
    essential aspect of this phase is time; it must be executed promptly. For example,
    if this phase took 1 hour to complete, the developers would commit the code faster,
    which would result in a constantly failing pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The CI pipeline is usually the starting point. Setting it up is simple because
    everything is done within the development team, and no agreement with the QA and
    operations teams is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: Automated acceptance testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The automated acceptance testing phase is a suite of tests written together
    with the client (and QAs) that is supposed to replace the manual UAT stage. It
    acts as a quality gate to decide whether a product is ready to be released. If
    any of the acceptance tests fail, pipeline execution is stopped and no further
    steps are run. It prevents movement to the configuration management phase and,
    hence, the release.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea of automating the acceptance phase is to build quality into the
    product instead of verifying it later. In other words, when a developer completes
    the implementation, the software is delivered together with the acceptance tests,
    which verify that the software is what the client wanted. That is a large shift
    in thinking concerning testing software. There is no longer a single person (or
    team) who approves the release, but everything depends on passing the acceptance
    test suite. That is why creating this phase is usually the most difficult part
    of the CD process. It requires close cooperation with the client and creating
    tests at the beginning (not at the end) of the process.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Introducing automated acceptance tests is especially challenging in the case
    of legacy systems. We will discuss this topic in more detail in [*Chapter 9*](B18223_09_ePub.xhtml#_idTextAnchor242), *Advanced
    Continuous Delivery*.
  prefs: []
  type: TYPE_NORMAL
- en: There is usually a lot of confusion about the types of tests and their place
    in the CD process. It's also often unclear as to how to automate each type, what
    the coverage should be, and what the role of the QA team should be in the development
    process. Let's clarify this using the Agile testing matrix and the testing pyramid.
  prefs: []
  type: TYPE_NORMAL
- en: The Agile testing matrix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Brian Marick, in a series of his blog posts, classified software tests in the form of
    the agile testing matrix. It places tests in two dimensions – business - or technology-facing
    – and supports programmers or a critique of the product. Let''s have a look at
    this classification:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Brian Marick''s testing matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.4 – Brian Marick's testing matrix
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at each type of test:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Acceptance Testing (automated)**: These are tests that represent the functional
    requirements that are seen from the business perspective. They are written in
    the form of stories or examples by clients and developers so that they can agree
    on how the software should work.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Unit Testing (automated)**: These are tests that help developers provide
    high-quality software and minimize the number of bugs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exploratory Testing (manual)**: This is the manual black-box testing phase,
    which tries to break or improve the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Non-Functional Testing (automated)**: These are tests that represent system
    properties related to performance, scalability, security, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This classification answers one of the most important questions about the CD
    process: *what is the role of a QA in the process?*
  prefs: []
  type: TYPE_NORMAL
- en: Manual QAs perform exploratory testing, which means they play with the system,
    try to break it, ask questions, and think about improvements. Automation QAs help
    with non-functional and acceptance testing; for example, they write code to support
    load testing. In general, QAs don't have a special place in the delivery process,
    but rather have a role in the development team.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the automated CD process, there is no longer a place for manual QAs who perform
    repetitive tasks.
  prefs: []
  type: TYPE_NORMAL
- en: You may look at the classification and wonder why you see no integration tests
    there. *Where are they according to Brian Marick, and where can we put them in
    the CD pipeline?*
  prefs: []
  type: TYPE_NORMAL
- en: To explain this well, we need to mention that the meaning of an integration test
    differs based on the context. For (micro) service architectures, they usually mean
    the same as acceptance testing, as services are small and need nothing more than
    unit and acceptance tests. If you build a modular application, then integration
    tests usually mean component tests that bind multiple modules (but not the whole
    application) and test them together. In that case, integration tests place themselves
    somewhere between acceptance and unit tests. They are written in a similar way
    to acceptance tests, but they are usually more technical and require mocking not
    only external services but also internal modules. Integration tests, similar to
    unit tests, represent the code's point of view, while acceptance tests represent
    the user's point of view. In regards to the CD pipeline, integration tests are
    simply implemented as a separate phase in the process.
  prefs: []
  type: TYPE_NORMAL
- en: The testing pyramid
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The previous section explained what each test type represents in the process,
    but mentioned nothing about how many tests we should develop. So, *what should
    the code coverage be in the case of unit testing? What about acceptance testing?*
  prefs: []
  type: TYPE_NORMAL
- en: 'To answer these questions, *Mike Cohn*, in his book *Succeeding with Agile*,
    created a so-called **testing pyramid**. The following diagram should help you
    develop a better understanding of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Mike Cohn''s testing pyramid'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_05.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.5 – Mike Cohn's testing pyramid
  prefs: []
  type: TYPE_NORMAL
- en: When we move up the pyramid, the tests become slower and more expensive to create.
    They often require user interfaces to be touched and a separate test automation
    team to be hired. That is why acceptance tests should not target 100% coverage.
    On the contrary, they should be feature-oriented and only verify selected test
    scenarios. Otherwise, we would spend a fortune on test development and maintenance,
    and our CD pipeline build would take ages to execute.
  prefs: []
  type: TYPE_NORMAL
- en: The case is different at the bottom of the pyramid. Unit tests are cheap and
    fast, so we should strive for 100% code coverage. They are written by developers,
    and providing them should be a standard procedure for any mature team.
  prefs: []
  type: TYPE_NORMAL
- en: I hope that the agile testing matrix and the testing pyramid clarified the role
    and the importance of acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the last phase of the CD process: configuration management.'
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The configuration management phase is responsible for tracking and controlling
    changes in the software and its environment. It involves taking care of preparing
    and installing the necessary tools, scaling the number of service instances and
    their distribution, infrastructure inventory, and all the tasks related to application
    deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management is a solution to the problems that are posed by manually
    deploying and configuring applications in production. This common practice results
    in an issue whereby we no longer know where each service is running and with what
    properties. Configuration management tools (such as Ansible, Chef, and Puppet)
    enable us to store configuration files in the version control system and track
    every change that was made to the production servers.
  prefs: []
  type: TYPE_NORMAL
- en: Additional effort to replace the operations team's manual tasks involves taking
    care of application monitoring. This is usually done by streaming the logs and
    metrics of the running systems to a common dashboard, which is monitored by developers
    (or the DevOps team, as explained in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: One other term related to configuration management that has recently gained
    a lot of traction is **Infrastructure as Code** (**IaC**). If you use the cloud
    instead of bare-metal servers, then tools such as Terraform or AWS CloudFormation
    let you store the description of your infrastructure, not only your software,
    in the version control system. We will discuss both configuration management and
    IaC in[*Chapter 7*](B18223_07_ePub.xhtml#_idTextAnchor185), *Configuration Management
    with Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites to CD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rest of this book is dedicated to technical details on how to implement
    a successful CD pipeline. The success of this process, however, depends not only
    on the tools we present throughout this book. In this section, we will take a
    holistic look at the whole process and define the CD requirements in three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: Your organization's structure and its impact on the development process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your products and their technical details
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your development team and the practices you adopt
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with the organizational prerequisites.
  prefs: []
  type: TYPE_NORMAL
- en: Organizational prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The way your organization works has a high impact on the success of introducing
    the CD process. It''s a bit similar to introducing Scrum. Many organizations would
    like to use the Agile process, but they don''t change their culture. You can''t
    use Scrum in your development team unless the organization''s structure has been
    adjusted for that. For example, you need a product owner, stakeholders, and a
    management team that understands that no requirement changes are possible during
    the sprint. Otherwise, even with good intentions, you won''t make it. The same
    applies to the CD process; it requires you to adjust how the organization is structured.
    Let''s have a look at three aspects: the DevOps culture, a client in the process,
    and business decisions.'
  prefs: []
  type: TYPE_NORMAL
- en: DevOps culture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A long time ago, when software was written by individuals or micro teams, there
    was no clear separation between development, quality assurance, and operations.
    A person developed the code, tested it, and then put it into production. If anything
    went wrong, the same person investigated the issue, fixed it, and redeployed it
    to production. The way the development process is organized changed gradually;
    systems became larger and development teams grew. Then, engineers started to become
    specialized in one area. This made perfect sense as specialization caused a boost
    in productivity. However, the side effect was the communication overhead. This
    is especially visible if developers, QAs, and operations are in separate departments
    in the organization, sit in different buildings, or are outsourced to different
    countries. This organizational structure is not good for the CD process. We need
    something better; we need to adopt the DevOps culture.
  prefs: []
  type: TYPE_NORMAL
- en: 'DevOps culture means, in a sense, going back to the roots. A single person
    or a team is responsible for all three areas, which are shown in the following
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – DevOps culture'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.6 – DevOps culture
  prefs: []
  type: TYPE_NORMAL
- en: The reason it's possible to move to the DevOps model without losing productivity
    is automation. Most of the tasks that are related to QA and operations are moved
    to the automated delivery pipeline, so they can be managed by the development
    team.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: A DevOps team doesn't necessarily need to consist of only developers. A very
    common scenario in many organizations that are transforming is to create teams
    with four developers, one QA, and one person from operations. However, they need
    to work closely together (sit in one area, have stand-ups together, and work on
    the same product).
  prefs: []
  type: TYPE_NORMAL
- en: The culture of small DevOps teams affects the software architecture. Functional
    requirements have to be separated into (micro) services or modules so that each
    team can take care of an independent part.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'The impact of the organization''s structure on the software architecture was
    observed in 1967 and formulated as Conway''s law: "*Any organization that designs
    a system (defined broadly) will produce a design whose structure is a copy of
    the organization''s communication structure*."'
  prefs: []
  type: TYPE_NORMAL
- en: A client in the process
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The role of a client (or a product owner) changes slightly during CD adoption.
    Traditionally, clients are involved in defining requirements, answering questions
    from developers, attending demos, and taking part in the UAT phase to determine
    whether what was built is what they had in mind.
  prefs: []
  type: TYPE_NORMAL
- en: In CD, there is no UAT, and a client is essential in the process of writing
    acceptance tests. For some clients, who have already written their requirements
    in a testable manner, this is not a big shift. For others, it means changing their
    way of thinking to make the requirements more technically oriented.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: In the agile environment, some teams don't even accept user stories (requirements)
    without acceptance tests attached. These techniques, even though they may sound
    too strict, often lead to better development productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Business decisions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most companies, the business has an impact on the release schedule. After
    all, the decision of what features are delivered, and when, is related to different
    departments within the company (for example, marketing) and can be strategic for
    the enterprise. That is why the release schedule has to be re-approached and discussed
    between the business and the development teams.
  prefs: []
  type: TYPE_NORMAL
- en: There are techniques, such as feature toggles or manual pipeline steps, that
    help with releasing features at the specified time. We will describe them later
    in this book. To be precise, the term *continuous delivery* is not the same as *continuous
    deployment*. The latter means that each commit to the repository is automatically
    released to production. Continuous delivery is less strict and means that each
    commit ends up with a release candidate, so it allows the last step (from release
    to production) to be manual.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the remainder of this book, we will use the terms continuous delivery
    and continuous deployment interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: Technical and development prerequisites
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From the technical side, there are a few requirements to keep in mind. We will discuss them
    throughout this book, so let''s only mention them here without going into detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated build, test, package, and deploy operations**: All operations need
    to be able to be automated. If we deal with a system that is non-automatable,
    for example, due to security reasons or its complexity, it is impossible to create
    a fully automated delivery pipeline.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick pipeline execution**: The pipeline must be executed promptly, preferably
    in 5-15 minutes. If our pipeline execution takes hours or days, it will not be
    possible to run it after every commit to the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quick failure recovery**: The possibility of a quick rollback or system recovery
    is necessary. Otherwise, we risk production health due to frequent releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zero-downtime deployment**: The deployment cannot have any downtime since
    we release it many times a day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trunk-based development**: Developers must check into one main branch regularly.
    Otherwise, if everyone develops in their branches, integration is rare, which
    means that releases are rare, which is exactly the opposite of what we want to
    achieve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will learn more about these prerequisites and how to address them throughout
    this book. With this in mind, let's move to the last section of this chapter and
    introduce what system we plan to build in this book and what tools we will use
    for that purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Combining CD and microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We live in the world of microservices. Nowadays, every system is either microservice-based
    or in the process of becoming microservice-based. After the first publication
    of the bestseller book by Sam Newman, *Building Microservices*, the software world
    has shifted into the fine-grained modular systems in which all communication happens
    over the network. Some companies have gone one step further and realized that
    they need to consolidate some of the microservices as they created too many of
    them. Some other companies even take a step back and consolidate microservices
    into a monolith.
  prefs: []
  type: TYPE_NORMAL
- en: While the topic of microservices is broad on its own and outside the scope of
    this book, it is important to understand how the microservice architecture affects
    the CD pipeline. Should we create a separate pipeline for each service? If yes,
    then how do we test the interaction between the services and the system as a whole?
  prefs: []
  type: TYPE_NORMAL
- en: 'Before answering these questions, let''s look at the following diagram, which
    represents a small microservice-based system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.7 – Sample microservice system'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.7 – Sample microservice system
  prefs: []
  type: TYPE_NORMAL
- en: There are three services in our system, each with a database. A user only interacts
    with *Service 1*. As a more concrete example, this system could represent an online
    store, where *Service 1* could represent the checkout service, *Service 2* could
    represent the product catalog service, and *Service 3* could represent customer
    service.
  prefs: []
  type: TYPE_NORMAL
- en: We could either implement one CD pipeline for the entire system or a separate
    CD pipeline for each microservice. Which approach is the right one? Let's consider
    both options. If we create one CD pipeline, this means that the automated acceptance
    testing phase runs against the entire system from the end user's perspective,
    which seems correct. However, one CD pipeline also means that we deploy all the
    services at the same time, which is completely against the microservice principles.
    Remember that in every microservice-based system, services are loosely coupled
    and should always be independently deployable.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to take the second approach and create a separate CD pipeline for
    each service. However, in such a case, the automated acceptance testing phase
    never runs against the entire system. So, how can we be sure that everything works
    correctly from the end user's perspective? To answer this question, we need a
    little more context about the microservice architecture.
  prefs: []
  type: TYPE_NORMAL
- en: In the microservice architecture, each service is a separate unit that's usually
    developed and maintained by a separate team. Services are loosely coupled, and
    they communicate over a well-defined API, which should always be kept backward
    compatible. In that context, each internal microservice does not differ much from
    an external service. That's why we should always be able to deploy a new service
    without testing other services. Note that it does not exclude the possibility
    of having a separate acceptance test for the entire system. All it explains is
    that the acceptance test of the entire system should not be a gatekeeper for deploying
    a single service.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The CD process is suitable for both monolith and microservice-based systems.
    In the former case, we should always create a separate CD pipeline for each microservice.
  prefs: []
  type: TYPE_NORMAL
- en: For the sake of simplicity, all the examples in this book present a system that
    consists of a single service.
  prefs: []
  type: TYPE_NORMAL
- en: Building the CD process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we've introduced the idea, benefits, and prerequisites concerning the
    CD process. In this section, we will describe the tools that will be used throughout
    this book and their place in the system as a whole.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re interested in the idea of the CD process, have a look at the excellent
    book by *Jez Humble* and *David Farley*, called *Continuous Delivery: Reliable
    Software Releases through Build, Test, and Deployment Automation*.'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, the tool is always less important than understanding its role
    in the process. In other words, any tool can be replaced with another one that
    plays the same role. For example, Jenkins can be replaced with Atlassian Bamboo,
    and Chef can be used instead of Ansible. This is why each chapter will begin with
    a general description of why such a tool is necessary and its role in the whole
    process. Then, the tool will be described in comparison to its substitutes. This
    will give you the flexibility to choose the right one for your environment.
  prefs: []
  type: TYPE_NORMAL
- en: Another approach could be to describe the CD process at the idea level; however,
    I strongly believe that giving an exact example, along with the code extract –
    something that you can run by yourself – results in a much better understanding
    of the concept.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to read this book. The first is to read and understand the
    concepts of the CD process. The second is to create an environment and execute
    all the scripts while reading to understand the details.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a quick look at the tools we will use throughout this book. This
    section, however, is only a brief introduction to each technology – more details
    will be provided later in this book.
  prefs: []
  type: TYPE_NORMAL
- en: The Docker ecosystem
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Docker, as the clear leader of the containerization movement, has dominated
    the software industry in recent years. It allows us to package an application
    in an environment-agnostic image and treats servers as a farm of resources, rather
    than machines that must be configured for each application. Docker was a clear
    choice for this book because it fits the (micro) service world and the CD process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker entails several additional technologies, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Hub**: This is a registry for Docker images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Kubernetes**: This is a container orchestrator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the first edition of this book, Docker Compose and Docker Swarm were presented
    as tools for clustering and scheduling multi-container applications. Since that
    time, however, Kubernetes has become the market leader and is used instead.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Jenkins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jenkins is by far the most popular automation server on the market. It helps
    create CI and CD pipelines and, in general, any other automated sequence of scripts.
    Highly plugin-oriented, it has a great community that constantly extends it with
    new features. What's more, it allows us to write the pipeline as code and supports
    distributed build environments.
  prefs: []
  type: TYPE_NORMAL
- en: Ansible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Ansible is an automation tool that helps with software provisioning, configuration
    management, and application deployment. It is trending faster than any other configuration
    management engine and will soon overtake its two main competitors: Chef and Puppet.
    It uses an agentless architecture and integrates smoothly with Docker.'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: GitHub is the best of all hosted version control systems. It provides a very
    stable system, a great web-based UI, and a free service for public repositories.
    Having said that, any source control management service or tool will work with
    CD, irrespective of whether it's in the cloud or self-hosted, and whether it's
    based on Git, SVN, Mercurial, or any other tool.
  prefs: []
  type: TYPE_NORMAL
- en: Java/Spring Boot/Gradle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Java has been the most popular programming language for years. That's why it
    will be used for most of the code examples in this book. Together with Java, most
    companies develop with the Spring framework, so we used it to create a simple
    web service to explain some concepts. Gradle is used as a build tool. It's still
    less popular than Maven, but it's trending much faster. As always, any programming
    language, framework, or build tool can be exchanged and the CD process would stay
    the same, so don't worry if your technology stack is different.
  prefs: []
  type: TYPE_NORMAL
- en: The other tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Cucumber was chosen arbitrarily as the acceptance testing framework. Other similar
    solutions are FitNesse and Jbehave. For the database migration process, we will
    use Flyway, but any other tool would do, such as Liquibase.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a complete CD system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can look at how this book is organized from two perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is based on the steps of the automated deployment pipeline. Each
    chapter takes you closer to the complete CD process. If you look at the names
    of the chapters, some of them are even named like the pipeline phases:'
  prefs: []
  type: TYPE_NORMAL
- en: The CI pipeline
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automated acceptance testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuration management with Ansible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The rest of the chapters provide an introduction, summary, or additional information
    that's complementary to the process.
  prefs: []
  type: TYPE_NORMAL
- en: There is also a second perspective to the content of this book. Each chapter
    describes one piece of the environment, which, in turn, is well prepared for the
    CD process. In other words, this book presents, step by step, technology by technology,
    how to build a complete system. To help you get a feel of what we plan to build
    throughout this book, let's have a look at how the system will evolve in each
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry if you don't understand the concepts and terminology at this point.
    We will be learning everything from scratch in the corresponding chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Docker
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034), *Introducing Docker*,
    we will start from the center of our system and build a working application that''s
    been packaged as a Docker image. The output of this chapter is presented in the
    following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.8 – Introducing Docker'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.8 – Introducing Docker
  prefs: []
  type: TYPE_NORMAL
- en: A dockerized application (web service) is run as a container on a **Docker Host** and
    is reachable as it will run directly on the host machine. This is possible thanks
    to port forwarding (port publishing in Docker's terminology).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jenkins
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 3*](B18223_03_ePub.xhtml#_idTextAnchor073), *Configuring Jenkins*,
    we will prepare the Jenkins environment. Thanks to the support of multiple agent
    (slave) nodes, it can handle the heavy concurrent load. The result is presented
    in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.9 – Configuring Jenkins'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.9 – Configuring Jenkins
  prefs: []
  type: TYPE_NORMAL
- en: The **Jenkins** master accepts a build request, but the execution is started
    at one of the **Jenkins Slave** (agent) machines. Such an approach provides horizontal
    scaling of the Jenkins environment.
  prefs: []
  type: TYPE_NORMAL
- en: The CI pipeline
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 4*](B18223_04_ePub.xhtml#_idTextAnchor106), *Continuous Integration
    Pipeline*, we''ll show you how to create the first phase of the CD pipeline: the
    commit stage. The output of this chapter is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.10 – The CI pipeline'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.10 – The CI pipeline
  prefs: []
  type: TYPE_NORMAL
- en: The application is a simple web service written in Java with the Spring Boot
    framework. Gradle is used as a build tool and GitHub is used as the source code
    repository. Every commit to GitHub automatically triggers the Jenkins build, which
    uses Gradle to compile Java code, run unit tests, and perform additional checks
    (code coverage, static code analysis, and so on). Once the Jenkins build is complete,
    a notification is sent to the developers.
  prefs: []
  type: TYPE_NORMAL
- en: After this chapter, you will be able to create a complete CI pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Automated acceptance testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 5*](B18223_05_ePub.xhtml#_idTextAnchor133), *Automated Acceptance
    Testing*, we''ll merge the two technologies mentioned in this book''s title: *Docker* and *Jenkins*.
    This will result in the system presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.11 – Automated acceptance testing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.11 – Automated acceptance testing
  prefs: []
  type: TYPE_NORMAL
- en: 'The additional elements in the preceding diagram are related to the automated
    acceptance testing stage:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker Registry**: After the CI phase, the application is packaged into a
    JAR file and then as a Docker image. That image is then pushed to the **Docker
    Registry**, which acts as storage for dockerized applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Docker Host**: Before performing the acceptance test suite, the application
    must be started. Jenkins triggers a **Docker Host** machine to pull the dockerized
    application from the **Docker Registry** and starts it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cucumber**: After the application is started on the **Docker Host**, Jenkins
    runs a suite of acceptance tests written in the **Cucumber** framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clustering with Kubernetes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 6*](B18223_06_ePub.xhtml#_idTextAnchor152), *Clustering with Kubernetes*,
    we replace a single Docker host with a Kubernetes cluster and a single standalone
    application with two dependent containerized applications. The output is the environment
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.12 – Clustering with Kubernetes'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.12 – Clustering with Kubernetes
  prefs: []
  type: TYPE_NORMAL
- en: Kubernetes provides an abstraction layer for a set of Docker hosts and allows
    simple communication between dependent applications. We no longer have to think
    about which machine our applications are deployed on. All we care about is the
    number of instances.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration management with Ansible
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In [*Chapter 7*](B18223_07_ePub.xhtml#_idTextAnchor185), *Configuration Management
    with Ansible*, we will create multiple environments using Ansible. The output
    is presented in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Configuration management with Ansible'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – Configuration management with Ansible
  prefs: []
  type: TYPE_NORMAL
- en: Ansible takes care of the environments and lets you deploy the same applications
    on multiple machines. As a result, we have a mirrored environment for testing
    and production.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll also touch on IaC and show you how to use Terraform if
    you use cloud environments.
  prefs: []
  type: TYPE_NORMAL
- en: The CD pipeline/advanced CD
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last two chapters – that is, [*Chapter 8*](B18223_08_ePub.xhtml#_idTextAnchor218), *Continuous
    Delivery Pipeline*, and [*Chapter 9*](B18223_09_ePub.xhtml#_idTextAnchor242),
    *Advanced Continuous Delivery* – we will deploy the application to the staging
    environment, run the acceptance testing suite, and release the application to
    the production environment, usually in many instances. The final improvement is
    that we''ll be able to automatically manage the database schemas using Flyway
    migrations that have been integrated into the delivery process. The final environment
    that will be created in this book is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – The CD pipeline/advanced CD'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.14 – The CD pipeline/advanced CD
  prefs: []
  type: TYPE_NORMAL
- en: I hope you are already excited by what we plan to build throughout this book.
    We will approach this step by step, explaining every detail and all the possible
    options to help you understand the procedures and tools. After reading this book,
    you will be able to introduce or improve the CD process in your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced the CD process, including the idea behind it,
    its prerequisites, and the tools that will be used throughout this book. The key
    takeaway from this chapter is that the delivery process that''s currently used
    in most companies has significant shortcomings and can be improved using modern
    automation tools. The CD approach provides several benefits, of which the most
    significant ones are fast delivery, a fast feedback cycle, and low-risk releases.
    The CD pipeline consists of three stages: CI, automated acceptance testing, and
    configuration management. Introducing CD usually requires the organization to
    change its culture and structure. The most important tools in the context of CD
    are Docker, Jenkins, and Ansible.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll introduce Docker and show you how to build a dockerized
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test your knowledge of this chapter, please answer the following questions:'
  prefs: []
  type: TYPE_NORMAL
- en: What are the three phases of the traditional delivery process?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three main stages of the CD pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least three benefits of using CD.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the types of tests that should be automated as part of the CD pipeline?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should we have more integration or unit tests? Explain why.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the term DevOps mean?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What software tools will be used throughout this book? Name at least four.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the concept of CD and its background, please refer to the
    following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Continuous Delivery*, by Jez Humble and David Farley: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*TestPyramid*, by Martin Fowler: [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Succeeding with Agile: Software Development Using Scrum*, by Mike Cohn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Building Microservices: Designing Fine-Grained Systems*, by Sam Newman'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
