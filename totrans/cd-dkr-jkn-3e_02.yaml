- en: '*Chapter 1*: Introducing Continuous Delivery'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第1章*：介绍持续交付'
- en: A common problem that's faced by most developers is how to release the implemented
    code quickly and safely. The delivery process that's traditionally used is a source
    of pitfalls and usually leads to the disappointment of both developers and clients.
    This chapter will present the idea of the **continuous delivery** (**CD**) approach
    and provide the context for the rest of this book.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发人员面临的一个常见问题是如何快速且安全地发布实现的代码。传统的交付过程充满了陷阱，通常会导致开发人员和客户的失望。本章将介绍**持续交付**（**CD**）方法的理念，并为本书的其余部分提供背景。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding CD
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CD
- en: The automated deployment pipeline
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化部署流水线
- en: Prerequisites to CD
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CD的前提条件
- en: Combining CD and microservices
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合CD和微服务
- en: Building the CD process
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建CD过程
- en: Understanding CD
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解CD
- en: 'The most accurate definition of CD is stated by *Jez Humble* and reads as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: CD的最准确定义由*Jez Humble*提出，内容如下：
- en: '"Continuous delivery is the ability to get changes of all types – including
    new features, configuration changes, bug fixes, and experiments – into production,
    or into the hands of users, safely and quickly, in a sustainable way."'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: “持续交付是将所有类型的变更——包括新功能、配置更改、错误修复和实验——安全、快速且可持续地推送到生产环境或用户手中的能力。”
- en: This definition covers the key points.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义涵盖了关键点。
- en: 'To understand this better, let''s imagine a scenario. You are responsible for
    a product – let''s say, an email client application. Users come to you with a
    new requirement: they want to sort emails by size. You decide that the development
    will take around 1 week. *When can the user expect to use the feature?* Usually,
    after the development is done, you hand over the completed feature to the **Quality
    Assurance** (**QA**) team and then to the operations team, which takes additional
    time, ranging from days to months.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个问题，让我们假设一个场景。你负责一个产品——比如说，一个电子邮件客户端应用。用户向你提出一个新需求：他们希望按大小排序电子邮件。你决定开发大约需要1周时间。*用户何时能使用这个功能？*
    通常，在开发完成后，你会将完成的功能交给**质量保证**（**QA**）团队，然后再交给运维团队，这会花费额外的时间，从几天到几个月不等。
- en: Therefore, even though the development only took 1 week, the user receives it
    in a couple of months! The CD approach addresses this issue by automating manual
    tasks so that the user can receive a new feature as soon as it's implemented.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管开发只花了1周时间，但用户需要等几个月才能收到！CD方法通过自动化手动任务解决了这个问题，使用户能够在新功能实现的第一时间就收到它。
- en: To help you understand what to automate and how, we'll start by describing the
    delivery process that is currently used for most software systems.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你理解需要自动化什么以及如何自动化，我们将首先描述当前大多数软件系统所使用的交付过程。
- en: The traditional delivery process
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 传统交付过程
- en: The traditional delivery process, as its name suggests, has been in place for
    many years and is implemented in most IT companies. Let's define how it works
    and comment on its shortcomings.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 传统交付过程，如其名称所示，已经实施多年，并且在大多数IT公司中得到应用。我们来定义它是如何工作的，并评论它的不足之处。
- en: Introducing the traditional delivery process
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 介绍传统的交付过程
- en: 'Every delivery process begins with the requirements that have been defined
    by a customer and ends with the product being released to production. There are
    differences between these two stages. Traditionally, this process looks as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每个交付过程都以客户定义的需求开始，并以产品发布到生产环境结束。这两个阶段之间存在差异。传统上，这个过程是这样的：
- en: '![Figure 1.1 – Release cycle diagram'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.1 – 发布周期图'
- en: '](img/B18223_01_01.png)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_01.png)'
- en: Figure 1.1 – Release cycle diagram
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.1 – 发布周期图
- en: 'The release cycle starts with the requirements provided by the **Product Owner**,
    who represents the **Customer** (stakeholders). Then, there are three phases,
    during which the work is passed between different teams:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 发布周期从**产品负责人**提供的需求开始，产品负责人代表**客户**（利益相关者）。然后，分为三个阶段，在这些阶段中，工作会在不同的团队之间传递：
- en: '**Development**: The developers (sometimes together with business analysts)
    work on the product. They often use agile techniques (Scrum or Kanban) to increase
    the development velocity and improve communication with the client. Demo sessions
    are organized to obtain a customer''s quick feedback. All good development techniques
    (such as **test-driven development** (**TDD**) or extreme programming practices)
    are welcome. Once the implementation is complete, the code is passed to the QA
    team.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：开发人员（有时与业务分析师一起）进行产品开发。他们通常使用敏捷技术（Scrum或Kanban）来提高开发速度并改善与客户的沟通。会组织演示会议以获得客户的快速反馈。所有优秀的开发技术（如**测试驱动开发**（**TDD**）或极限编程实践）都是欢迎的。一旦实现完成，代码会传给QA团队。'
- en: '**Quality Assurance**: This phase is usually called **User Acceptance Testing** (**UAT**)
    and it requires the code to be frozen on the trunk code base so that no new development
    will break the tests. The QA team performs a suite of **integration testing**, **acceptance
    testing**, and **non-functional analysis** (performance, recovery, security, and
    so on). Any bug that is detected goes back to the development team, so the developers
    usually have their hands full. After the UAT phase is completed, the QA team approves
    the features that have been planned for the next release.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量保证**：这个阶段通常称为**用户验收测试**（**UAT**），需要将代码冻结在主代码库上，以确保没有新的开发会破坏测试。QA团队会进行一系列的**集成测试**、**验收测试**和**非功能性分析**（性能、恢复、安全等）。任何检测到的缺陷都会返回给开发团队，所以开发人员通常工作非常繁忙。在UAT阶段完成后，QA团队会批准已计划好用于下一个发布的功能。'
- en: '**Operations**: The final phase, and usually the shortest one, involves passing
    the code to the operations team so that they can perform the release and monitor
    the production environment. If anything goes wrong, they contact the developers
    so that they can help with the production system.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运维**：最后阶段，通常也是最短的阶段，涉及将代码交给运维团队，以便他们执行发布并监控生产环境。如果出现任何问题，他们会联系开发人员，帮助解决生产系统的问题。'
- en: 'The length of the release cycle depends on the system and the organization,
    but it usually ranges from 1 week to a few months. The longest I''ve heard about
    was 1 year. The longest I worked on one was quarterly-based, and each part was
    as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 发布周期的长短取决于系统和组织，但通常从1周到几个月不等。我听说过最长的周期是1年。我亲自参与过的最长周期是按季度进行的，每个部分如下：
- en: '**Development**: 1.5 months'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发**：1.5个月'
- en: '**UAT**: 1 month and 3 weeks'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UAT**：1个月3周'
- en: '**Release (and strict production monitoring)**: 1 week'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发布（和严格的生产监控）**：1周'
- en: The traditional delivery process is widely used in the IT industry, so this
    is probably not the first time you've read about such an approach. Nevertheless,
    it has several drawbacks. Let's look at them explicitly to understand why we need
    to strive for something better.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 传统交付过程在IT行业广泛使用，因此这可能不是你第一次读到这样的方式。然而，它也有几个缺点。让我们明确地看看它们，以便理解为何我们需要追求更好的方法。
- en: Shortcomings of the traditional delivery process
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 传统交付过程的缺点
- en: 'The most significant shortcomings of the traditional delivery process are as
    follows:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 传统交付过程的最显著缺点如下：
- en: '**Slow delivery**: The customer receives the product long after the requirements
    were specified. This results in unsatisfactory time to market and delays customer
    feedback.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**慢速交付**：客户在需求明确后很久才收到产品。这导致市场响应时间不理想，且客户反馈延迟。'
- en: '**Long feedback cycle**: The feedback cycle is not only related to customers
    but developers. Imagine that you accidentally created a bug, and you learn about
    it during the UAT phase. *How long does it take to fix something you worked on
    2 months ago?* Even dealing with minor bugs can take weeks.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长反馈周期**：反馈周期不仅与客户有关，也与开发人员相关。想象一下，如果你不小心创建了一个BUG，并且在UAT阶段才得知。*修复你两个月前做的事情需要多久？*
    即便是处理小BUG，也可能需要几周。'
- en: '**Lack of automation**: Rare releases do not encourage automation, which leads
    to unpredictable releases.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缺乏自动化**：稀少的发布不鼓励自动化，这导致发布过程不可预测。'
- en: '**Risky hotfixes**: Hotfixes cannot usually wait for the full UAT phase, so
    they tend to be tested differently (the UAT phase is shortened) or not tested
    at all.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险较大的热修复**：热修复通常不能等待完整的UAT阶段，因此它们通常会以不同的方式进行测试（UAT阶段会缩短）或根本不进行测试。'
- en: '**Stress**: Unpredictable releases are stressful for the operations team. What''s
    more, the release cycle is usually tightly scheduled, which imposes additional
    stress on developers and testers.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压力**：不可预测的发布对运维团队来说是很有压力的。更糟糕的是，发布周期通常安排得很紧，这给开发人员和测试人员增加了额外的压力。'
- en: '**Poor communication**: Work that''s passed from one team to another represents
    the waterfall approach, in which people start to care only about their part, rather
    than the complete product. If anything goes wrong, that usually leads to the blame
    game instead of cooperation.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**沟通不畅**：从一个团队传递到另一个团队的工作代表着瀑布式方法，人们开始只关心他们自己的部分，而不是完整的产品。如果出了什么问题，这通常导致责备游戏，而不是合作。'
- en: '**Shared responsibility**: No team takes responsibility for the product from
    A to Z:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**责任共享**：没有团队从头到尾对产品负责：'
- en: '**For developers**: *Done* means that the requirements have been implemented.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对开发人员来说**：*完成* 意味着需求已经被实现。'
- en: '**For testers**: *Done* means that the code has been tested.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对测试人员来说**：*完成* 意味着代码已经经过测试。'
- en: '**For operations**: *Done* means that the code has been released.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对运维人员来说**：*完成* 意味着代码已经发布。'
- en: '**Lower job satisfaction**: Each phase is interesting for a different team,
    but other teams need to support the process. For example, the development phase
    is interesting for developers but, during the other two phases, they still need
    to fix bugs and support the release, which is usually not interesting for them
    at all.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低工作满意度**：每个阶段对不同的团队都很有趣，但其他团队需要支持这个过程。例如，开发阶段对开发人员来说很有趣，但在其他两个阶段，他们仍然需要修复bug并支持发布，这通常对他们来说一点都不有趣。'
- en: These drawbacks represent just the tip of the iceberg of the challenges related
    to the traditional delivery process. You may already feel that there must be a
    better way to develop software and this better way is, obviously, the CD approach.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缺点仅仅是传统交付过程挑战的冰山一角。你可能已经感受到，开发软件必须有更好的方法，而这种更好的方法显然就是CD方法。
- en: The benefits of CD
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CD的好处
- en: '*How long would it take your organization to deploy a change that involves
    just a single line of code?* *Do you do this on a repeatable, reliable basis?* These
    are the famous questions from *Mary* and *Tom Poppendieck* (authors of *Implementing
    Lean Software Development*), which have been quoted many times by *Jez Humble* and
    others. The answers to these questions are the only valid measurement of the health
    of your delivery process.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '*你的组织部署一个涉及单行代码的更改需要多长时间？* *你是否可以重复、可靠地做到这一点？* 这些是**玛丽**和**汤姆·波彭迪克**（《实施精益软件开发》的作者）提出的著名问题，被**杰兹·汉布尔**和其他人引用了很多次。对这些问题的回答是你交付过程健康状况的唯一有效衡量标准。'
- en: To be able to deliver continuously, and not spend a fortune on the army of operations
    teams working 24/7, we need automation. That is why, in short, CD is all about
    changing each phase of the traditional delivery process into a sequence of scripts
    called the *automated deployment pipeline*, or the *CD pipeline*. Then, if no
    manual steps are required, we can run the process after every code change and
    deliver the product continuously to users.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够持续交付，并且不需要大量花费在全天候工作的运维团队上，我们需要自动化。简而言之，持续交付（CD）就是将传统交付过程的每个阶段转变为一系列称为*自动化部署流水线*或*CD流水线*的脚本。然后，如果不需要手动步骤，我们可以在每次代码更改后运行这个流程，并持续将产品交付给用户。
- en: 'CD lets us get rid of the tedious release cycle and brings the following benefits:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: CD让我们摆脱乏味的发布周期，并带来以下好处：
- en: '**Fast delivery**: Time to market is significantly reduced as customers can
    use the product as soon as development is completed. Remember that the software
    delivers no revenue until it is in the hands of its users.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速交付**：市场推出时间显著缩短，因为客户可以在开发完成后立即使用产品。记住，软件直到交到用户手中才能产生收益。'
- en: '**Fast feedback cycle**: Imagine that you created a bug in the code, which
    goes into production the same day. *How much time does it take to fix something
    you worked on the same day?* Probably not much. This, together with the quick
    rollback strategy, is the best way to keep production stable.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速反馈周期**：想象一下，你在代码中引入了一个bug，而这个bug当天就进入了生产环境。*修复当天工作的问题需要多长时间？*可能不会太久。这与快速回滚策略一起，是保持生产稳定的最佳方式。'
- en: '**Low-risk releases**: If you release daily, the process becomes repeatable
    and much safer. As the saying goes, *if it hurts, do it more often*.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**低风险发布**：如果你每天发布，这个过程就会变得可重复且安全得多。俗话说，*如果它伤害你，那就更频繁地做它*。'
- en: '**Flexible release options**: If you need to release immediately, everything
    is already prepared, so there is no additional time/cost associated with the release
    decision.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活的发布选项**：如果你需要立即发布，一切已经准备就绪，因此没有额外的时间/成本与发布决策相关。'
- en: Needless to say, we could achieve all these benefits simply by eliminating all
    the delivery phases and proceeding with development directly from production.
    However, this would result in a reduction in quality. The whole difficulty of
    introducing CD is the concern that the quality would decrease alongside eliminating
    any manual steps. In this book, we will show you how to approach CD safely and
    explain why, contrary to common beliefs, products that are delivered continuously
    contain fewer bugs and are better adjusted to the customer's needs.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不用多说，我们完全可以通过消除所有交付阶段，直接从生产环境开始开发，来实现所有这些好处。然而，这样做会导致质量的下降。引入持续交付的困难在于，大家担心在消除所有手动步骤的同时，质量也会下降。在本书中，我们将向你展示如何安全地进行持续交付，并解释为什么，与普遍的看法相反，持续交付的产品包含的
    bug 更少，更能满足客户的需求。
- en: Success stories
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成功案例
- en: My favorite story on CD was told by Rolf Russell at one of his talks. It goes
    as follows. In 2005, Yahoo! acquired Flickr, and it was a clash of two cultures
    in the developer's world. Flickr, by that time, was a company with the start-up
    approach in mind. Yahoo!, on the other hand, was a huge corporation with strict
    rules and a safety-first attitude. Their release processes differed a lot. While
    Yahoo used the traditional delivery process, Flickr released many times a day.
    Every change that was implemented by developers went into production the same
    day. They even had a footer at the bottom of their page showing the time of the
    last release and the avatars of the developers who made the changes.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我最喜欢的关于持续交付的故事是在 Rolf Russell 的一次演讲中听到的。故事如下。2005 年，Yahoo! 收购了 Flickr，这在开发者的世界中是两种文化的碰撞。那时，Flickr
    是一家具有初创公司思维的公司，而 Yahoo! 则是一个庞大的企业，拥有严格的规则和安全至上的态度。他们的发布流程差异巨大。Yahoo! 使用传统的交付流程，而
    Flickr 每天发布多次。开发者实施的每个变化都会在当天进入生产环境。他们甚至在页面底部放置了一个页脚，显示上次发布的时间和做出更改的开发者头像。
- en: 'Yahoo! deployed rarely, and each release brought a lot of changes that were
    well-tested and prepared. Flickr worked in very small chunks; each feature was
    divided into small incremental parts, and each part was deployed to production
    quickly. The difference is presented in the following diagram:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo! 很少进行部署，每次发布都会带来很多经过充分测试和准备的变化。Flickr 则采用非常小的增量方式工作；每个功能被划分为小的增量部分，每一部分都会迅速部署到生产环境中。差异如下面的图示所示：
- en: '![Figure 1.2 – Comparison of the release cycles of Yahoo! and Flickr'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.2 – Yahoo! 和 Flickr 发布周期的比较'
- en: '](img/B18223_01_02.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_02.jpg)'
- en: Figure 1.2 – Comparison of the release cycles of Yahoo! and Flickr
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2 – Yahoo! 和 Flickr 发布周期的比较
- en: You can imagine what happened when the developers from the two companies met.
    Yahoo! treated Flickr's colleagues as irresponsible junior developers, a bunch
    of software cowboys who didn't know what they were doing. So, the first thing
    they wanted to do was add a QA team and the UAT phase to Flickr's delivery process.
    Before they applied the change, however, Flickr's developers had only one wish.
    They asked to evaluate the most reliable products throughout Yahoo! as a whole.
    It came as a surprise when they saw that even with all the software in Yahoo!,
    Flickr had the lowest downtime. The Yahoo! team didn't understand it at first,
    but they let Flickr stay with their current process anyway. After all, they were
    engineers, so the evaluation result was conclusive. Only after some time had passed
    did the Yahoo! developers realize that the CD process could be beneficial for
    all the products in Yahoo! and they started to gradually introduce it everywhere.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以想象，当两家公司开发者碰面时发生了什么。Yahoo! 把 Flickr 的同事当作不负责任的初级开发者，一群不懂自己在做什么的软件牛仔。所以，他们首先想做的就是为
    Flickr 的交付流程增加一个 QA 团队和 UAT 阶段。然而，在他们进行更改之前，Flickr 的开发者只有一个愿望。他们希望评估整个 Yahoo!
    所有产品中最可靠的那些。令他们吃惊的是，即使是 Yahoo! 的所有软件，Flickr 也有着最低的宕机时间。最初，Yahoo! 团队不明白这一点，但他们还是让
    Flickr 保持现有流程。毕竟，他们是工程师，因此评估结果是确凿的。过了一段时间，Yahoo! 的开发者才意识到，持续交付流程对 Yahoo! 的所有产品都有好处，并开始逐步在各个产品中推广。
- en: 'The most important question of the story remains: *how come Flickr was the
    most reliable system?* The reason behind this was what we already mentioned in
    the previous sections. A release is less risky if the following is true:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 故事中最重要的问题仍然是：*为什么Flickr是最可靠的系统？* 其背后的原因就是我们在前面提到过的内容。如果以下情况成立，则发布的风险较小：
- en: The delta of code changes is small
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码变更的差异很小
- en: The process is repeatable
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个过程是可重复的
- en: That is why, even though the release itself is a difficult activity, it is much
    safer when it's done frequently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么，尽管发布本身是一项复杂的活动，但如果频繁进行发布，它反而更安全。
- en: The story of Yahoo! and Flickr is only one example of many successful companies
    where the CD process proved to be the correct choice. Nowadays, it's common for
    even small organizations to release frequently and market leaders such as Amazon,
    Facebook, Google, and Netflix perform thousands of releases per day.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Yahoo!和Flickr的故事只是众多成功公司的一个例子，在这些公司中，CD过程证明是正确的选择。如今，即使是小型组织，也通常会频繁发布软件，像亚马逊、Facebook、谷歌和Netflix这样的行业领袖每天都会执行成千上万次的发布。
- en: Information
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: You can read more about the research on the CD process and individual case studies
    at [https://continuousdelivery.com/evidence-case-studies/](https://continuousdelivery.com/evidence-case-studies/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://continuousdelivery.com/evidence-case-studies/](https://continuousdelivery.com/evidence-case-studies/)上阅读更多关于CD过程和个案研究的内容。
- en: Keep in mind that the statistics get better every day. However, even without
    any numbers, just imagine a world in which every line of code you implement goes
    safely into production. Clients can react quickly and adjust their requirements,
    developers are happy as they don't have to solve that many bugs, and managers
    are satisfied because they always know the current state of work. After all, remember
    that the only true measure of progress is the software that is released.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，统计数据每天都在改善。然而，即使没有任何数据，想象一下这样一个世界：你实现的每一行代码都安全地进入了生产环境。客户能够快速反应并调整需求，开发人员很高兴，因为他们不需要解决那么多的漏洞，而管理者也满意，因为他们总是知道工作进展的当前状态。毕竟，记住唯一真正衡量进展的标准是已发布的软件。
- en: The automated deployment pipeline
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动化部署管道
- en: We already know what the CD process is and why we use it. In this section, we'll
    describe how to implement it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经知道什么是CD过程以及为什么要使用它。在这一节中，我们将描述如何实施它。
- en: 'Let''s start by emphasizing that each phase in the traditional delivery process
    is important. Otherwise, it would never have been created in the first place.
    No one wants to deliver software without testing it! The role of the UAT phase
    is to detect bugs and ensure that what the developers have created is what the
    customer wanted. The same applies to the operations team – the software must be
    configured, deployed to production, and monitored. That''s out of the question.
    So, *how do we automate the process so that we preserve all the phases?* That
    is the role of the automated deployment pipeline, which consists of three stages,
    as shown in the following diagram:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要强调，传统交付过程中的每一个阶段都非常重要，否则这个过程根本不会被创造出来。没有人愿意在没有测试的情况下交付软件！UAT阶段的角色是发现漏洞，确保开发人员创建的内容正是客户所需要的。运维团队的角色也是如此——软件必须被配置、部署到生产环境并进行监控。这是不可忽视的。因此，*我们如何自动化这个过程，以保持所有阶段的完整性？*
    这就是自动化部署管道的作用，它由三个阶段组成，如下图所示：
- en: '![Figure 1.3 – Automated deployment pipeline'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3 – 自动化部署管道](img/B18223_01_03.jpg)'
- en: '](img/B18223_01_03.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_03.jpg)'
- en: Figure 1.3 – Automated deployment pipeline
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.3 – 自动化部署管道
- en: The automated deployment pipeline is a sequence of scripts that is executed
    after every code change is committed to the repository. If the process is successful,
    it ends up being deployed to the production environment.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化部署管道是一系列脚本，执行顺序是在每次代码变更提交到仓库后进行的。如果过程成功，它最终会被部署到生产环境。
- en: 'Each step corresponds to a phase in the traditional delivery process, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个步骤都对应于传统交付过程中的一个阶段，如下所示：
- en: '**Continuous integration**: This checks to make sure that the code that''s
    been written by different developers is integrated.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续集成**：这会检查不同开发者编写的代码是否已被整合。'
- en: '**Automated acceptance testing**: This checks if the client''s requirements
    have been met by the developers implementing the features. This testing also replaces
    the manual QA phase.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化验收测试**：这会检查开发人员实现的功能是否满足客户的需求。这个测试还替代了手动QA阶段。'
- en: '**Configuration management**: This replaces the manual operations phase; it
    configures the environment and deploys the software.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置管理**：这取代了手动操作阶段；它配置环境并部署软件。'
- en: Let's take a deeper look at each phase to understand its responsibility and
    what steps it includes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更深入地了解每个阶段，理解它的责任以及它包括哪些步骤。
- en: Continuous integration
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 持续集成
- en: The **continuous integration** (**CI**) phase provides the first set of feedback
    to developers. It checks out the code from the repository, compiles it, runs unit
    tests, and verifies the code's quality. If any step fails, the pipeline's execution
    is stopped and the first thing the developers should do is fix the CI build. The
    essential aspect of this phase is time; it must be executed promptly. For example,
    if this phase took 1 hour to complete, the developers would commit the code faster,
    which would result in a constantly failing pipeline.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**持续集成**（**CI**）阶段为开发人员提供了第一轮反馈。它从代码库中检出代码，编译它，运行单元测试，并验证代码的质量。如果任何一步失败，管道执行将被停止，开发人员应该做的第一件事是修复CI构建。这个阶段的关键是时间；它必须及时执行。例如，如果这个阶段花费了1小时才能完成，开发人员就会更快地提交代码，这将导致管道不断失败。'
- en: The CI pipeline is usually the starting point. Setting it up is simple because
    everything is done within the development team, and no agreement with the QA and
    operations teams is necessary.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: CI管道通常是起点。设置它很简单，因为一切都在开发团队内部完成，不需要与QA和运维团队达成协议。
- en: Automated acceptance testing
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化验收测试
- en: The automated acceptance testing phase is a suite of tests written together
    with the client (and QAs) that is supposed to replace the manual UAT stage. It
    acts as a quality gate to decide whether a product is ready to be released. If
    any of the acceptance tests fail, pipeline execution is stopped and no further
    steps are run. It prevents movement to the configuration management phase and,
    hence, the release.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化验收测试阶段是一套与客户（和QA）一起编写的测试，旨在取代手动UAT阶段。它作为质量门，决定产品是否准备好发布。如果任何一个验收测试失败，管道执行将被停止，后续步骤将不再运行。它阻止了配置管理阶段的继续，因此也阻止了发布。
- en: The whole idea of automating the acceptance phase is to build quality into the
    product instead of verifying it later. In other words, when a developer completes
    the implementation, the software is delivered together with the acceptance tests,
    which verify that the software is what the client wanted. That is a large shift
    in thinking concerning testing software. There is no longer a single person (or
    team) who approves the release, but everything depends on passing the acceptance
    test suite. That is why creating this phase is usually the most difficult part
    of the CD process. It requires close cooperation with the client and creating
    tests at the beginning (not at the end) of the process.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 自动化验收阶段的整个理念是将质量融入产品，而不是事后验证。换句话说，当开发人员完成实现时，软件会与验收测试一起交付，这些测试验证软件是否符合客户的要求。这是软件测试思维的一大转变。现在不再是由单个人（或团队）批准发布，而是所有的一切都取决于通过验收测试套件。这也是为什么创建这个阶段通常是CD过程最困难的部分。它需要与客户的密切合作，并在过程开始时（而不是结束时）创建测试。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Introducing automated acceptance tests is especially challenging in the case
    of legacy systems. We will discuss this topic in more detail in [*Chapter 9*](B18223_09_ePub.xhtml#_idTextAnchor242), *Advanced
    Continuous Delivery*.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在遗留系统中引入自动化验收测试尤其具有挑战性。我们将在[*第9章*](B18223_09_ePub.xhtml#_idTextAnchor242)《高级持续交付》中详细讨论这个话题。
- en: There is usually a lot of confusion about the types of tests and their place
    in the CD process. It's also often unclear as to how to automate each type, what
    the coverage should be, and what the role of the QA team should be in the development
    process. Let's clarify this using the Agile testing matrix and the testing pyramid.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通常会有很多关于测试类型及其在CD过程中的位置的混淆。如何自动化每种类型的测试，覆盖范围应该是什么，以及QA团队在开发过程中的角色通常也不清晰。让我们通过敏捷测试矩阵和测试金字塔来澄清这些问题。
- en: The Agile testing matrix
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 敏捷测试矩阵
- en: 'Brian Marick, in a series of his blog posts, classified software tests in the form of
    the agile testing matrix. It places tests in two dimensions – business - or technology-facing
    – and supports programmers or a critique of the product. Let''s have a look at
    this classification:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Brian Marick在一系列博客文章中，以敏捷测试矩阵的形式对软件测试进行了分类。它将测试分为两个维度——面向业务或技术，并支持程序员或对产品的批评。让我们来看一下这种分类：
- en: '![Figure 1.4 – Brian Marick''s testing matrix'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – Brian Marick 的测试矩阵'
- en: '](img/B18223_01_04.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_04.jpg)'
- en: Figure 1.4 – Brian Marick's testing matrix
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – Brian Marick 的测试矩阵
- en: 'Let''s look at each type of test:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看每种测试类型：
- en: '**Acceptance Testing (automated)**: These are tests that represent the functional
    requirements that are seen from the business perspective. They are written in
    the form of stories or examples by clients and developers so that they can agree
    on how the software should work.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验收测试（自动化）**：这些测试代表了从业务角度来看功能性要求。它们以故事或示例的形式由客户和开发人员编写，以便双方能就软件应如何工作达成一致。'
- en: '**Unit Testing (automated)**: These are tests that help developers provide
    high-quality software and minimize the number of bugs.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单元测试（自动化）**：这些测试帮助开发人员提供高质量的软件，并最小化错误的数量。'
- en: '**Exploratory Testing (manual)**: This is the manual black-box testing phase,
    which tries to break or improve the system.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索性测试（手动）**：这是手动的黑盒测试阶段，旨在打破或改进系统。'
- en: '**Non-Functional Testing (automated)**: These are tests that represent system
    properties related to performance, scalability, security, and so on.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性测试（自动化）**：这些测试代表了与性能、可扩展性、安全性等相关的系统属性。'
- en: This classification answers one of the most important questions about the CD
    process: *what is the role of a QA in the process?*
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分类回答了关于 CD 过程中的一个重要问题：*质量保证（QA）在过程中的角色是什么？*
- en: Manual QAs perform exploratory testing, which means they play with the system,
    try to break it, ask questions, and think about improvements. Automation QAs help
    with non-functional and acceptance testing; for example, they write code to support
    load testing. In general, QAs don't have a special place in the delivery process,
    but rather have a role in the development team.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 手动 QA 执行探索性测试，这意味着他们会与系统进行互动，尝试打破它，提问并思考改进之处。自动化 QA 则帮助进行非功能性测试和验收测试；例如，他们编写代码来支持负载测试。通常，QA
    在交付过程中没有特殊的位置，而是作为开发团队的一员。
- en: Note
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In the automated CD process, there is no longer a place for manual QAs who perform
    repetitive tasks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在自动化的 CD 流程中，执行重复任务的手动 QA 已经没有位置了。
- en: You may look at the classification and wonder why you see no integration tests
    there. *Where are they according to Brian Marick, and where can we put them in
    the CD pipeline?*
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看着这个分类，想知道为什么没有看到集成测试。*根据 Brian Marick 的说法，它们在哪里，我们又该如何在 CD 流水线中放置它们？*
- en: To explain this well, we need to mention that the meaning of an integration test
    differs based on the context. For (micro) service architectures, they usually mean
    the same as acceptance testing, as services are small and need nothing more than
    unit and acceptance tests. If you build a modular application, then integration
    tests usually mean component tests that bind multiple modules (but not the whole
    application) and test them together. In that case, integration tests place themselves
    somewhere between acceptance and unit tests. They are written in a similar way
    to acceptance tests, but they are usually more technical and require mocking not
    only external services but also internal modules. Integration tests, similar to
    unit tests, represent the code's point of view, while acceptance tests represent
    the user's point of view. In regards to the CD pipeline, integration tests are
    simply implemented as a separate phase in the process.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地解释这一点，我们需要提到集成测试的含义在不同上下文中的差异。对于（微）服务架构，集成测试通常意味着与验收测试相同，因为服务较小，只需要单元测试和验收测试。如果你构建一个模块化应用程序，那么集成测试通常意味着组件测试，绑定多个模块（但不是整个应用程序）并一起测试。在这种情况下，集成测试介于验收测试和单元测试之间。它们的编写方式类似于验收测试，但通常更加技术性，且需要模拟不仅是外部服务，还有内部模块。集成测试类似于单元测试，代表了代码的视角，而验收测试代表了用户的视角。在
    CD 流水线中，集成测试作为一个单独的阶段实现。
- en: The testing pyramid
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试金字塔
- en: The previous section explained what each test type represents in the process,
    but mentioned nothing about how many tests we should develop. So, *what should
    the code coverage be in the case of unit testing? What about acceptance testing?*
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 前一部分解释了每种测试类型在过程中的含义，但并未提到我们应该开发多少测试。那么，*在单元测试的情况下，代码覆盖率应该是多少？验收测试又该如何？*
- en: 'To answer these questions, *Mike Cohn*, in his book *Succeeding with Agile*,
    created a so-called **testing pyramid**. The following diagram should help you
    develop a better understanding of this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回答这些问题，*Mike Cohn*在他的书《*Succeeding with Agile*》中创造了所谓的**测试金字塔**。下图应能帮助你更好地理解这一点：
- en: '![Figure 1.5 – Mike Cohn''s testing pyramid'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.5 – Mike Cohn的测试金字塔](img/B18223_01_05.jpg)'
- en: '](img/B18223_01_05.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_05.jpg)'
- en: Figure 1.5 – Mike Cohn's testing pyramid
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – Mike Cohn的测试金字塔
- en: When we move up the pyramid, the tests become slower and more expensive to create.
    They often require user interfaces to be touched and a separate test automation
    team to be hired. That is why acceptance tests should not target 100% coverage.
    On the contrary, they should be feature-oriented and only verify selected test
    scenarios. Otherwise, we would spend a fortune on test development and maintenance,
    and our CD pipeline build would take ages to execute.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们往金字塔上层移动时，测试变得更慢且更昂贵。它们通常需要触及用户界面，并且需要雇佣一个独立的测试自动化团队。这就是为什么验收测试不应该追求100%的覆盖率。相反，它们应该以功能为导向，只验证选定的测试场景。否则，我们将花费大量资金用于测试开发和维护，而我们的CD管道构建将需要很长时间才能执行完毕。
- en: The case is different at the bottom of the pyramid. Unit tests are cheap and
    fast, so we should strive for 100% code coverage. They are written by developers,
    and providing them should be a standard procedure for any mature team.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在金字塔的底部，情况则不同。单元测试既便宜又快速，因此我们应该追求100%的代码覆盖率。它们由开发人员编写，提供它们应该是任何成熟团队的标准流程。
- en: I hope that the agile testing matrix and the testing pyramid clarified the role
    and the importance of acceptance testing.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望敏捷测试矩阵和测试金字塔能澄清验收测试的作用和重要性。
- en: 'Now, let''s look at the last phase of the CD process: configuration management.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看一下CD过程的最后一个阶段：配置管理。
- en: Configuration management
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置管理
- en: The configuration management phase is responsible for tracking and controlling
    changes in the software and its environment. It involves taking care of preparing
    and installing the necessary tools, scaling the number of service instances and
    their distribution, infrastructure inventory, and all the tasks related to application
    deployment.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理阶段负责追踪和控制软件及其环境中的变化。它包括准备和安装必要工具、扩展服务实例的数量及其分布、基础设施清单以及所有与应用程序部署相关的任务。
- en: Configuration management is a solution to the problems that are posed by manually
    deploying and configuring applications in production. This common practice results
    in an issue whereby we no longer know where each service is running and with what
    properties. Configuration management tools (such as Ansible, Chef, and Puppet)
    enable us to store configuration files in the version control system and track
    every change that was made to the production servers.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 配置管理是解决手动部署和配置生产环境中的应用程序所带来问题的一种方案。这个常见做法会导致一个问题，即我们无法再知道每个服务的运行位置及其属性。配置管理工具（如Ansible、Chef和Puppet）使我们能够将配置文件存储在版本控制系统中，并跟踪对生产服务器所做的每一次更改。
- en: Additional effort to replace the operations team's manual tasks involves taking
    care of application monitoring. This is usually done by streaming the logs and
    metrics of the running systems to a common dashboard, which is monitored by developers
    (or the DevOps team, as explained in the next section).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 替换运营团队手动任务的额外工作包括处理应用监控。这通常通过将运行系统的日志和指标流式传输到一个公共仪表盘来完成，该仪表盘由开发人员（或下节中提到的DevOps团队）进行监控。
- en: One other term related to configuration management that has recently gained
    a lot of traction is **Infrastructure as Code** (**IaC**). If you use the cloud
    instead of bare-metal servers, then tools such as Terraform or AWS CloudFormation
    let you store the description of your infrastructure, not only your software,
    in the version control system. We will discuss both configuration management and
    IaC in[*Chapter 7*](B18223_07_ePub.xhtml#_idTextAnchor185), *Configuration Management
    with Ansible*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 近期与配置管理相关的另一个术语是**基础设施即代码**（**IaC**）。如果你使用云而不是裸机服务器，那么像Terraform或AWS CloudFormation这样的工具可以让你将基础设施的描述（不仅仅是软件）存储在版本控制系统中。我们将在[*第7章*](B18223_07_ePub.xhtml#_idTextAnchor185)中讨论配置管理和IaC，*使用Ansible进行配置管理*。
- en: Prerequisites to CD
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CD的前提条件
- en: 'The rest of this book is dedicated to technical details on how to implement
    a successful CD pipeline. The success of this process, however, depends not only
    on the tools we present throughout this book. In this section, we will take a
    holistic look at the whole process and define the CD requirements in three areas:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的其余部分将专注于如何实现成功CD管道的技术细节。然而，这一过程的成功不仅仅依赖于本书中介绍的工具。在这一部分，我们将从整体上审视整个过程，并在以下三个方面定义CD的要求：
- en: Your organization's structure and its impact on the development process
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组织结构及其对开发过程的影响
- en: Your products and their technical details
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的产品及其技术细节
- en: Your development team and the practices you adopt
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你的开发团队及你们采用的实践
- en: Let's start with the organizational prerequisites.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从组织先决条件开始。
- en: Organizational prerequisites
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织先决条件
- en: 'The way your organization works has a high impact on the success of introducing
    the CD process. It''s a bit similar to introducing Scrum. Many organizations would
    like to use the Agile process, but they don''t change their culture. You can''t
    use Scrum in your development team unless the organization''s structure has been
    adjusted for that. For example, you need a product owner, stakeholders, and a
    management team that understands that no requirement changes are possible during
    the sprint. Otherwise, even with good intentions, you won''t make it. The same
    applies to the CD process; it requires you to adjust how the organization is structured.
    Let''s have a look at three aspects: the DevOps culture, a client in the process,
    and business decisions.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你们组织的运作方式对引入CD过程的成功有很大的影响。这有点类似于引入Scrum。许多组织想要使用敏捷流程，但他们并没有改变他们的文化。除非组织的结构为此进行了调整，否则你无法在开发团队中使用Scrum。例如，你需要一个产品负责人、相关利益方和一个管理团队，他们理解在sprint过程中需求不可能变更。否则，即使你有好的意图，也无法成功。同样的情况适用于CD过程；它要求你调整组织的结构。我们来看三个方面：DevOps文化、过程中的客户和商业决策。
- en: DevOps culture
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: DevOps文化
- en: A long time ago, when software was written by individuals or micro teams, there
    was no clear separation between development, quality assurance, and operations.
    A person developed the code, tested it, and then put it into production. If anything
    went wrong, the same person investigated the issue, fixed it, and redeployed it
    to production. The way the development process is organized changed gradually;
    systems became larger and development teams grew. Then, engineers started to become
    specialized in one area. This made perfect sense as specialization caused a boost
    in productivity. However, the side effect was the communication overhead. This
    is especially visible if developers, QAs, and operations are in separate departments
    in the organization, sit in different buildings, or are outsourced to different
    countries. This organizational structure is not good for the CD process. We need
    something better; we need to adopt the DevOps culture.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，当软件由个人或小团队编写时，开发、质量保证和运维之间没有明确的分隔。一个人编写代码，测试它，然后将其投入生产。如果出现问题，同一个人会调查问题，修复它，并重新部署到生产环境中。随着开发过程的组织方式逐渐变化，系统变得更大，开发团队也在不断壮大。于是，工程师们开始在某个领域中变得更加专业化。这是非常有道理的，因为专业化提升了生产力。然而，副作用是沟通成本的增加。如果开发人员、QA和运维位于组织的不同部门，坐在不同的楼栋，或者外包到不同的国家，这种现象尤为明显。这种组织结构不利于CD过程。我们需要更好的方法；我们需要采用DevOps文化。
- en: 'DevOps culture means, in a sense, going back to the roots. A single person
    or a team is responsible for all three areas, which are shown in the following
    diagram:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: DevOps文化在某种意义上意味着回归根本。一个人或一个团队负责所有三个领域，如下图所示：
- en: '![Figure 1.6 – DevOps culture'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – DevOps文化'
- en: '](img/B18223_01_06.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_06.jpg)'
- en: Figure 1.6 – DevOps culture
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – DevOps文化
- en: The reason it's possible to move to the DevOps model without losing productivity
    is automation. Most of the tasks that are related to QA and operations are moved
    to the automated delivery pipeline, so they can be managed by the development
    team.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在不降低生产力的情况下转向DevOps模式的原因是自动化。与QA和运维相关的大部分任务被移到自动化交付管道中，因此可以由开发团队来管理。
- en: Information
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: A DevOps team doesn't necessarily need to consist of only developers. A very
    common scenario in many organizations that are transforming is to create teams
    with four developers, one QA, and one person from operations. However, they need
    to work closely together (sit in one area, have stand-ups together, and work on
    the same product).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一个DevOps团队不一定需要由开发人员组成。许多转型中的组织中，一个非常常见的场景是创建由四个开发人员、一个QA和一个运维人员组成的团队。然而，他们需要紧密合作（坐在同一片区域，一起进行站立会议，共同开发同一个产品）。
- en: The culture of small DevOps teams affects the software architecture. Functional
    requirements have to be separated into (micro) services or modules so that each
    team can take care of an independent part.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 小型DevOps团队的文化会影响软件架构。功能需求必须被分离为（微）服务或模块，以便每个团队可以处理独立的部分。
- en: Information
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'The impact of the organization''s structure on the software architecture was
    observed in 1967 and formulated as Conway''s law: "*Any organization that designs
    a system (defined broadly) will produce a design whose structure is a copy of
    the organization''s communication structure*."'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 组织结构对软件架构的影响早在1967年就被观察到，并被公式化为Conway定律：“*任何设计系统的组织（广义定义）都会产生一个设计，其结构是该组织沟通结构的复制*。”
- en: A client in the process
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 客户在过程中
- en: The role of a client (or a product owner) changes slightly during CD adoption.
    Traditionally, clients are involved in defining requirements, answering questions
    from developers, attending demos, and taking part in the UAT phase to determine
    whether what was built is what they had in mind.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在持续交付（CD）采纳过程中，客户（或产品负责人）的角色略有变化。传统上，客户参与定义需求、回答开发人员的问题、参加演示并参与用户验收测试（UAT）阶段，以确定所构建的产品是否符合他们的预期。
- en: In CD, there is no UAT, and a client is essential in the process of writing
    acceptance tests. For some clients, who have already written their requirements
    in a testable manner, this is not a big shift. For others, it means changing their
    way of thinking to make the requirements more technically oriented.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在CD中，没有UAT，客户在编写验收测试的过程中至关重要。对于一些已经以可测试的方式编写需求的客户来说，这并不是一个很大的变化。而对另一些客户来说，则意味着需要改变他们的思维方式，使需求更加面向技术。
- en: Information
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: In the agile environment, some teams don't even accept user stories (requirements)
    without acceptance tests attached. These techniques, even though they may sound
    too strict, often lead to better development productivity.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在敏捷环境中，有些团队甚至不接受没有附带验收测试的用户故事（需求）。这些技术，尽管听起来可能过于严格，但往往能带来更高的开发生产力。
- en: Business decisions
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 业务决策
- en: In most companies, the business has an impact on the release schedule. After
    all, the decision of what features are delivered, and when, is related to different
    departments within the company (for example, marketing) and can be strategic for
    the enterprise. That is why the release schedule has to be re-approached and discussed
    between the business and the development teams.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数公司中，业务对发布计划有一定的影响。毕竟，决定交付哪些功能以及何时交付，涉及到公司内不同部门（例如，市场部）的协调，并且可能对企业的战略至关重要。因此，发布计划必须在业务和开发团队之间重新审视和讨论。
- en: There are techniques, such as feature toggles or manual pipeline steps, that
    help with releasing features at the specified time. We will describe them later
    in this book. To be precise, the term *continuous delivery* is not the same as *continuous
    deployment*. The latter means that each commit to the repository is automatically
    released to production. Continuous delivery is less strict and means that each
    commit ends up with a release candidate, so it allows the last step (from release
    to production) to be manual.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些技术手段，比如功能切换（feature toggles）或手动管道步骤，能够帮助按指定时间发布功能。我们将在本书后续部分描述这些技术。准确来说，*持续交付*（continuous
    delivery）与*持续部署*（continuous deployment）并不相同。后者意味着每次提交到代码仓库都会自动发布到生产环境。持续交付则更为宽松，它意味着每次提交都会生成一个发布候选版本，从而允许最后一步（从发布到生产）是手动进行的。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Throughout the remainder of this book, we will use the terms continuous delivery
    and continuous deployment interchangeably.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的其余部分，我们将交替使用“持续交付”和“持续部署”这两个术语。
- en: Technical and development prerequisites
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术和开发前提
- en: 'From the technical side, there are a few requirements to keep in mind. We will discuss them
    throughout this book, so let''s only mention them here without going into detail:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从技术角度来看，有一些要求需要牢记。我们将在本书中讨论这些要求，因此这里只简单提及，不再详细说明：
- en: '**Automated build, test, package, and deploy operations**: All operations need
    to be able to be automated. If we deal with a system that is non-automatable,
    for example, due to security reasons or its complexity, it is impossible to create
    a fully automated delivery pipeline.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化构建、测试、打包和部署操作**：所有操作都需要能够自动化。如果我们处理的是一个无法自动化的系统，例如由于安全原因或其复杂性，便无法创建完全自动化的交付管道。'
- en: '**Quick pipeline execution**: The pipeline must be executed promptly, preferably
    in 5-15 minutes. If our pipeline execution takes hours or days, it will not be
    possible to run it after every commit to the repository.'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速管道执行**：管道必须迅速执行，最好在5到15分钟内完成。如果我们的管道执行需要数小时或数天，那就无法在每次提交代码时都执行。'
- en: '**Quick failure recovery**: The possibility of a quick rollback or system recovery
    is necessary. Otherwise, we risk production health due to frequent releases.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速故障恢复**：需要能够快速回滚或恢复系统的可能性。否则，由于频繁发布，我们会危及生产环境的健康。'
- en: '**Zero-downtime deployment**: The deployment cannot have any downtime since
    we release it many times a day.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**零停机部署**：部署过程中不能有任何停机时间，因为我们每天都会发布多次。'
- en: '**Trunk-based development**: Developers must check into one main branch regularly.
    Otherwise, if everyone develops in their branches, integration is rare, which
    means that releases are rare, which is exactly the opposite of what we want to
    achieve.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基于主干的开发**：开发人员必须定期提交代码到一个主分支。如果每个人都在自己的分支中开发，集成就会变得稀少，这意味着发布也会很少，而这正是我们想要避免的。'
- en: We will learn more about these prerequisites and how to address them throughout
    this book. With this in mind, let's move to the last section of this chapter and
    introduce what system we plan to build in this book and what tools we will use
    for that purpose.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们将详细了解这些前提条件以及如何解决它们。考虑到这一点，让我们进入本章的最后一节，介绍我们计划在本书中构建的系统，以及我们将为此目的使用的工具。
- en: Combining CD and microservices
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合持续交付（CD）和微服务
- en: We live in the world of microservices. Nowadays, every system is either microservice-based
    or in the process of becoming microservice-based. After the first publication
    of the bestseller book by Sam Newman, *Building Microservices*, the software world
    has shifted into the fine-grained modular systems in which all communication happens
    over the network. Some companies have gone one step further and realized that
    they need to consolidate some of the microservices as they created too many of
    them. Some other companies even take a step back and consolidate microservices
    into a monolith.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在微服务的世界里。如今，每个系统要么是基于微服务的，要么正在变成基于微服务的。在Sam Newman的畅销书《构建微服务》首次发布之后，软件世界转向了这种细粒度模块化的系统，所有的通信都是通过网络进行的。一些公司更进一步，意识到他们需要整合一些微服务，因为他们创建了太多的微服务。还有一些公司甚至退回一步，将微服务整合成单体系统。
- en: While the topic of microservices is broad on its own and outside the scope of
    this book, it is important to understand how the microservice architecture affects
    the CD pipeline. Should we create a separate pipeline for each service? If yes,
    then how do we test the interaction between the services and the system as a whole?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务的话题本身非常广泛，超出了本书的范围，但了解微服务架构如何影响持续交付管道仍然很重要。我们是否应该为每个服务创建单独的管道？如果是，那我们该如何测试各个服务之间以及服务与整个系统之间的交互？
- en: 'Before answering these questions, let''s look at the following diagram, which
    represents a small microservice-based system:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在回答这些问题之前，让我们看看下图，它展示了一个小型基于微服务的系统：
- en: '![Figure 1.7 – Sample microservice system'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7 – 示例微服务系统'
- en: '](img/B18223_01_07.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_07.jpg)'
- en: Figure 1.7 – Sample microservice system
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.7 – 示例微服务系统
- en: There are three services in our system, each with a database. A user only interacts
    with *Service 1*. As a more concrete example, this system could represent an online
    store, where *Service 1* could represent the checkout service, *Service 2* could
    represent the product catalog service, and *Service 3* could represent customer
    service.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的系统中有三个服务，每个服务都有一个数据库。用户只与*服务1*进行交互。作为一个更具体的例子，这个系统可以代表一个在线商店，其中*服务1*可能代表结账服务，*服务2*可能代表产品目录服务，*服务3*可能代表客户服务。
- en: We could either implement one CD pipeline for the entire system or a separate
    CD pipeline for each microservice. Which approach is the right one? Let's consider
    both options. If we create one CD pipeline, this means that the automated acceptance
    testing phase runs against the entire system from the end user's perspective,
    which seems correct. However, one CD pipeline also means that we deploy all the
    services at the same time, which is completely against the microservice principles.
    Remember that in every microservice-based system, services are loosely coupled
    and should always be independently deployable.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以为整个系统实现一个 CD 流水线，或者为每个微服务实现一个单独的 CD 流水线。哪种方法更合适呢？我们来考虑一下这两种选择。如果我们创建一个 CD
    流水线，这意味着自动化验收测试阶段将从最终用户的角度对整个系统进行测试，这似乎是正确的。然而，一个 CD 流水线也意味着我们同时部署所有服务，这与微服务原则完全相悖。记住，在每个基于微服务的系统中，服务是松耦合的，并且应该始终是可独立部署的。
- en: So, we need to take the second approach and create a separate CD pipeline for
    each service. However, in such a case, the automated acceptance testing phase
    never runs against the entire system. So, how can we be sure that everything works
    correctly from the end user's perspective? To answer this question, we need a
    little more context about the microservice architecture.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们需要采取第二种方法，为每个服务创建一个单独的 CD 流水线。然而，在这种情况下，自动化验收测试阶段从未对整个系统进行测试。那么，我们如何确保从最终用户的角度来看，一切都正常呢？为了回答这个问题，我们需要更多关于微服务架构的背景信息。
- en: In the microservice architecture, each service is a separate unit that's usually
    developed and maintained by a separate team. Services are loosely coupled, and
    they communicate over a well-defined API, which should always be kept backward
    compatible. In that context, each internal microservice does not differ much from
    an external service. That's why we should always be able to deploy a new service
    without testing other services. Note that it does not exclude the possibility
    of having a separate acceptance test for the entire system. All it explains is
    that the acceptance test of the entire system should not be a gatekeeper for deploying
    a single service.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构中，每个服务都是一个独立的单元，通常由一个独立的团队开发和维护。服务是松耦合的，它们通过一个明确定义的 API 进行通信，该 API 应始终保持向后兼容。在这种情况下，每个内部微服务与外部服务没有太大区别。这就是为什么我们应该始终能够在不测试其他服务的情况下部署新服务。请注意，这并不排除为整个系统进行单独验收测试的可能性。它解释的是，整个系统的验收测试不应成为单个服务部署的门槛。
- en: Information
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: The CD process is suitable for both monolith and microservice-based systems.
    In the former case, we should always create a separate CD pipeline for each microservice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: CD 流程适用于单体系统和基于微服务的系统。在前者的情况下，我们应该始终为每个微服务创建一个单独的 CD 流水线。
- en: For the sake of simplicity, all the examples in this book present a system that
    consists of a single service.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，本书中的所有示例都呈现了一个由单一服务组成的系统。
- en: Building the CD process
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建 CD 流程
- en: So far, we've introduced the idea, benefits, and prerequisites concerning the
    CD process. In this section, we will describe the tools that will be used throughout
    this book and their place in the system as a whole.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了关于 CD 流程的理念、好处和前提条件。在本节中，我们将描述本书中将使用的工具及其在整个系统中的位置。
- en: Information
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: 'If you''re interested in the idea of the CD process, have a look at the excellent
    book by *Jez Humble* and *David Farley*, called *Continuous Delivery: Reliable
    Software Releases through Build, Test, and Deployment Automation*.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你对 CD 流程的概念感兴趣，可以看看 *Jez Humble* 和 *David Farley* 合著的精彩书籍《*Continuous Delivery:
    Reliable Software Releases through Build, Test, and Deployment Automation*》。'
- en: Introducing tools
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍工具
- en: First of all, the tool is always less important than understanding its role
    in the process. In other words, any tool can be replaced with another one that
    plays the same role. For example, Jenkins can be replaced with Atlassian Bamboo,
    and Chef can be used instead of Ansible. This is why each chapter will begin with
    a general description of why such a tool is necessary and its role in the whole
    process. Then, the tool will be described in comparison to its substitutes. This
    will give you the flexibility to choose the right one for your environment.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，工具的重要性总是低于理解它在流程中的作用。换句话说，任何工具都可以被一个执行相同角色的工具替代。例如，Jenkins 可以被 Atlassian
    Bamboo 替代，Chef 可以用 Ansible 代替。这就是为什么每一章都会以该工具为何必要以及它在整个流程中作用的概述开始。然后，工具会与其替代品进行比较。这将为你提供在你的环境中选择合适工具的灵活性。
- en: Another approach could be to describe the CD process at the idea level; however,
    I strongly believe that giving an exact example, along with the code extract –
    something that you can run by yourself – results in a much better understanding
    of the concept.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '另一种方法可能是从理念层面描述CD过程；然而，我坚信，提供一个精确的例子，并附上代码片段——这样你自己也能运行的示例——会让你对这个概念有更好的理解。  '
- en: Information
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '信息  '
- en: There are two ways to read this book. The first is to read and understand the
    concepts of the CD process. The second is to create an environment and execute
    all the scripts while reading to understand the details.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '本书有两种阅读方式。第一种是阅读并理解CD过程的概念。第二种是在阅读的同时创建环境并执行所有脚本，以理解细节。  '
- en: Let's take a quick look at the tools we will use throughout this book. This
    section, however, is only a brief introduction to each technology – more details
    will be provided later in this book.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们快速了解一下本书中将使用的工具。然而，本节仅是对每项技术的简要介绍——更多的细节将在本书后续章节中提供。  '
- en: The Docker ecosystem
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Docker生态系统  '
- en: Docker, as the clear leader of the containerization movement, has dominated
    the software industry in recent years. It allows us to package an application
    in an environment-agnostic image and treats servers as a farm of resources, rather
    than machines that must be configured for each application. Docker was a clear
    choice for this book because it fits the (micro) service world and the CD process.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker，作为容器化运动的明确领导者，近年来在软件行业占据了主导地位。它允许我们将应用程序打包成环境无关的镜像，并将服务器视为资源的农场，而不是必须为每个应用程序配置的机器。Docker是本书的明确选择，因为它适应了（微）服务世界和CD过程。  '
- en: 'Docker entails several additional technologies, as follows:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'Docker包含以下几项额外技术：  '
- en: '**Docker Hub**: This is a registry for Docker images'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker Hub**：这是一个Docker镜像的注册中心  '
- en: '**Kubernetes**: This is a container orchestrator'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Kubernetes**：这是一个容器编排工具  '
- en: Information
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '信息  '
- en: In the first edition of this book, Docker Compose and Docker Swarm were presented
    as tools for clustering and scheduling multi-container applications. Since that
    time, however, Kubernetes has become the market leader and is used instead.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在本书的第一版中，Docker Compose和Docker Swarm被介绍为用于集群化和调度多容器应用的工具。然而，从那时起，Kubernetes已成为市场的领导者，并被取而代之。  '
- en: Jenkins
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Jenkins
- en: Jenkins is by far the most popular automation server on the market. It helps
    create CI and CD pipelines and, in general, any other automated sequence of scripts.
    Highly plugin-oriented, it has a great community that constantly extends it with
    new features. What's more, it allows us to write the pipeline as code and supports
    distributed build environments.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 'Jenkins是目前市场上最流行的自动化服务器。它有助于创建CI和CD管道，通常也可用于任何其他自动化脚本序列。Jenkins高度依赖插件，并且拥有一个活跃的社区，不断通过新功能扩展其功能。更重要的是，它允许我们将管道写成代码，并支持分布式构建环境。  '
- en: Ansible
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Ansible  '
- en: 'Ansible is an automation tool that helps with software provisioning, configuration
    management, and application deployment. It is trending faster than any other configuration
    management engine and will soon overtake its two main competitors: Chef and Puppet.
    It uses an agentless architecture and integrates smoothly with Docker.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 'Ansible是一种自动化工具，帮助进行软件配置、配置管理和应用部署。它的流行速度超过了任何其他配置管理引擎，并将很快超越其两大竞争对手：Chef和Puppet。它采用无代理架构，并与Docker无缝集成。  '
- en: GitHub
  id: totrans-194
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'GitHub  '
- en: GitHub is the best of all hosted version control systems. It provides a very
    stable system, a great web-based UI, and a free service for public repositories.
    Having said that, any source control management service or tool will work with
    CD, irrespective of whether it's in the cloud or self-hosted, and whether it's
    based on Git, SVN, Mercurial, or any other tool.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 'GitHub是所有托管版本控制系统中最好的。它提供了一个非常稳定的系统，一个出色的基于Web的UI，并且为公共仓库提供免费服务。话虽如此，任何源代码管理服务或工具都可以与CD（持续交付）配合使用，无论它是基于云的还是自托管的，是否基于Git、SVN、Mercurial或任何其他工具。  '
- en: Java/Spring Boot/Gradle
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 'Java/Spring Boot/Gradle  '
- en: Java has been the most popular programming language for years. That's why it
    will be used for most of the code examples in this book. Together with Java, most
    companies develop with the Spring framework, so we used it to create a simple
    web service to explain some concepts. Gradle is used as a build tool. It's still
    less popular than Maven, but it's trending much faster. As always, any programming
    language, framework, or build tool can be exchanged and the CD process would stay
    the same, so don't worry if your technology stack is different.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Java 多年来一直是最流行的编程语言。因此，它将用于本书中的大多数代码示例。与 Java 一起，许多公司使用 Spring 框架进行开发，所以我们也使用它来创建一个简单的
    Web 服务，解释一些概念。Gradle 用作构建工具，它虽然不如 Maven 流行，但发展势头更快。像往常一样，任何编程语言、框架或构建工具都可以替换，CD
    流程保持不变，所以如果你的技术栈不同，也不必担心。
- en: The other tools
  id: totrans-198
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他工具
- en: Cucumber was chosen arbitrarily as the acceptance testing framework. Other similar
    solutions are FitNesse and Jbehave. For the database migration process, we will
    use Flyway, but any other tool would do, such as Liquibase.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Cucumber 被任意选作验收测试框架。其他类似的解决方案包括 FitNesse 和 Jbehave。对于数据库迁移过程，我们将使用 Flyway，但任何其他工具都可以，如
    Liquibase。
- en: Creating a complete CD system
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个完整的 CD 系统
- en: You can look at how this book is organized from two perspectives.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从两个角度来了解本书的组织方式。
- en: 'The first one is based on the steps of the automated deployment pipeline. Each
    chapter takes you closer to the complete CD process. If you look at the names
    of the chapters, some of them are even named like the pipeline phases:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个角度是基于自动化部署流水线的步骤。每一章都会将你带得更接近完整的 CD 流程。如果你查看各章的名称，其中有些甚至与流水线的阶段名称相同：
- en: The CI pipeline
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CI 流水线
- en: Automated acceptance testing
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动化验收测试
- en: Configuration management with Ansible
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行配置管理
- en: The rest of the chapters provide an introduction, summary, or additional information
    that's complementary to the process.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的章节提供了对过程的介绍、总结或补充信息。
- en: There is also a second perspective to the content of this book. Each chapter
    describes one piece of the environment, which, in turn, is well prepared for the
    CD process. In other words, this book presents, step by step, technology by technology,
    how to build a complete system. To help you get a feel of what we plan to build
    throughout this book, let's have a look at how the system will evolve in each
    chapter.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 本书还有第二个角度的内容。每一章描述了环境中的一个部分，这些部分也为 CD 流程的顺利进行做好了充分准备。换句话说，本书一步一步、技术一项一项地展示了如何构建一个完整的系统。为了帮助你了解我们将在本书中构建的系统，接下来我们来看看每一章中系统如何逐步演变。
- en: Note
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Don't worry if you don't understand the concepts and terminology at this point.
    We will be learning everything from scratch in the corresponding chapters.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此时你还不理解这些概念和术语，不用担心。我们将在相应的章节中从头开始学习所有内容。
- en: Introducing Docker
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 引入 Docker
- en: 'In [*Chapter 2*](B18223_02_ePub.xhtml#_idTextAnchor034), *Introducing Docker*,
    we will start from the center of our system and build a working application that''s
    been packaged as a Docker image. The output of this chapter is presented in the
    following diagram:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第2章*](B18223_02_ePub.xhtml#_idTextAnchor034)，*引入 Docker*中，我们将从系统的核心开始，构建一个已打包为
    Docker 镜像的工作应用。本章的输出如下图所示：
- en: '![Figure 1.8 – Introducing Docker'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.8 – 引入 Docker'
- en: '](img/B18223_01_08.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_08.jpg)'
- en: Figure 1.8 – Introducing Docker
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8 – 引入 Docker
- en: A dockerized application (web service) is run as a container on a **Docker Host** and
    is reachable as it will run directly on the host machine. This is possible thanks
    to port forwarding (port publishing in Docker's terminology).
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 Docker 化的应用（Web 服务）作为容器在**Docker 主机**上运行，并且可以访问，因为它将直接在主机机器上运行。这是通过端口转发（在
    Docker 术语中是端口发布）实现的。
- en: Configuring Jenkins
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置 Jenkins
- en: 'In [*Chapter 3*](B18223_03_ePub.xhtml#_idTextAnchor073), *Configuring Jenkins*,
    we will prepare the Jenkins environment. Thanks to the support of multiple agent
    (slave) nodes, it can handle the heavy concurrent load. The result is presented
    in the following diagram:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第3章*](B18223_03_ePub.xhtml#_idTextAnchor073)，*配置 Jenkins*中，我们将准备 Jenkins
    环境。得益于多个代理（从属）节点的支持，它能够处理繁重的并发负载。结果如下图所示：
- en: '![Figure 1.9 – Configuring Jenkins'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 配置 Jenkins'
- en: '](img/B18223_01_09.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_09.jpg)'
- en: Figure 1.9 – Configuring Jenkins
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 配置 Jenkins
- en: The **Jenkins** master accepts a build request, but the execution is started
    at one of the **Jenkins Slave** (agent) machines. Such an approach provides horizontal
    scaling of the Jenkins environment.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**Jenkins** 主机接收构建请求，但执行过程从某个 **Jenkins Slave**（代理）机器开始。这种方法提供了 Jenkins 环境的水平扩展。'
- en: The CI pipeline
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: CI 管道
- en: 'In [*Chapter 4*](B18223_04_ePub.xhtml#_idTextAnchor106), *Continuous Integration
    Pipeline*, we''ll show you how to create the first phase of the CD pipeline: the
    commit stage. The output of this chapter is shown in the following diagram:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B18223_04_ePub.xhtml#_idTextAnchor106)，《*持续集成管道*》中，我们将向您展示如何创建 CD
    管道的第一阶段：提交阶段。该章节的输出如下图所示：
- en: '![Figure 1.10 – The CI pipeline'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – CI 管道'
- en: '](img/B18223_01_10.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_10.jpg)'
- en: Figure 1.10 – The CI pipeline
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – CI 管道
- en: The application is a simple web service written in Java with the Spring Boot
    framework. Gradle is used as a build tool and GitHub is used as the source code
    repository. Every commit to GitHub automatically triggers the Jenkins build, which
    uses Gradle to compile Java code, run unit tests, and perform additional checks
    (code coverage, static code analysis, and so on). Once the Jenkins build is complete,
    a notification is sent to the developers.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序是一个简单的 Web 服务，使用 Java 和 Spring Boot 框架编写。Gradle 用作构建工具，GitHub 用作源代码仓库。每次提交到
    GitHub 都会自动触发 Jenkins 构建，Jenkins 使用 Gradle 编译 Java 代码，运行单元测试并执行其他检查（如代码覆盖率、静态代码分析等）。一旦
    Jenkins 构建完成，会发送通知给开发人员。
- en: After this chapter, you will be able to create a complete CI pipeline.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束后，您将能够创建一个完整的 CI 管道。
- en: Automated acceptance testing
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自动化验收测试
- en: 'In [*Chapter 5*](B18223_05_ePub.xhtml#_idTextAnchor133), *Automated Acceptance
    Testing*, we''ll merge the two technologies mentioned in this book''s title: *Docker* and *Jenkins*.
    This will result in the system presented in the following diagram:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 5 章*](B18223_05_ePub.xhtml#_idTextAnchor133)，《*自动化验收测试*》中，我们将结合本书标题中提到的两项技术：*Docker*
    和 *Jenkins*。这将导致下图所示的系统：
- en: '![Figure 1.11 – Automated acceptance testing'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – 自动化验收测试'
- en: '](img/B18223_01_11.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_11.jpg)'
- en: Figure 1.11 – Automated acceptance testing
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 自动化验收测试
- en: 'The additional elements in the preceding diagram are related to the automated
    acceptance testing stage:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表中的额外元素与自动化验收测试阶段相关：
- en: '**Docker Registry**: After the CI phase, the application is packaged into a
    JAR file and then as a Docker image. That image is then pushed to the **Docker
    Registry**, which acts as storage for dockerized applications.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 注册库**：在 CI 阶段之后，应用程序被打包成 JAR 文件，然后作为 Docker 镜像。该镜像随后被推送到 **Docker
    注册库**，它充当容器化应用程序的存储库。'
- en: '**Docker Host**: Before performing the acceptance test suite, the application
    must be started. Jenkins triggers a **Docker Host** machine to pull the dockerized
    application from the **Docker Registry** and starts it.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Docker 主机**：在执行验收测试套件之前，必须先启动应用程序。Jenkins 触发 **Docker 主机** 机器从 **Docker 注册库**
    拉取容器化的应用程序并启动它。'
- en: '**Cucumber**: After the application is started on the **Docker Host**, Jenkins
    runs a suite of acceptance tests written in the **Cucumber** framework.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cucumber**：在应用程序启动在 **Docker 主机** 上之后，Jenkins 会运行一套使用 **Cucumber** 框架编写的验收测试。'
- en: Clustering with Kubernetes
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Kubernetes 集群
- en: 'In [*Chapter 6*](B18223_06_ePub.xhtml#_idTextAnchor152), *Clustering with Kubernetes*,
    we replace a single Docker host with a Kubernetes cluster and a single standalone
    application with two dependent containerized applications. The output is the environment
    shown in the following diagram:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第 6 章*](B18223_06_ePub.xhtml#_idTextAnchor152)，《*使用 Kubernetes 集群*》中，我们将用
    Kubernetes 集群替换单个 Docker 主机，并将单个独立应用程序替换为两个依赖的容器化应用程序。输出为下图所示的环境：
- en: '![Figure 1.12 – Clustering with Kubernetes'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – 使用 Kubernetes 集群'
- en: '](img/B18223_01_12.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B18223_01_12.jpg)'
- en: Figure 1.12 – Clustering with Kubernetes
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – 使用 Kubernetes 集群
- en: Kubernetes provides an abstraction layer for a set of Docker hosts and allows
    simple communication between dependent applications. We no longer have to think
    about which machine our applications are deployed on. All we care about is the
    number of instances.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes 提供了一层抽象，管理一组 Docker 主机，并允许依赖应用程序之间的简单通信。我们不再需要考虑应用程序部署在哪台机器上。我们关心的只是实例的数量。
- en: Configuration management with Ansible
  id: totrans-244
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Ansible 进行配置管理
- en: 'In [*Chapter 7*](B18223_07_ePub.xhtml#_idTextAnchor185), *Configuration Management
    with Ansible*, we will create multiple environments using Ansible. The output
    is presented in the following diagram:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.13 – Configuration management with Ansible'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_13.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.13 – Configuration management with Ansible
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: Ansible takes care of the environments and lets you deploy the same applications
    on multiple machines. As a result, we have a mirrored environment for testing
    and production.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we'll also touch on IaC and show you how to use Terraform if
    you use cloud environments.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
- en: The CD pipeline/advanced CD
  id: totrans-251
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the last two chapters – that is, [*Chapter 8*](B18223_08_ePub.xhtml#_idTextAnchor218), *Continuous
    Delivery Pipeline*, and [*Chapter 9*](B18223_09_ePub.xhtml#_idTextAnchor242),
    *Advanced Continuous Delivery* – we will deploy the application to the staging
    environment, run the acceptance testing suite, and release the application to
    the production environment, usually in many instances. The final improvement is
    that we''ll be able to automatically manage the database schemas using Flyway
    migrations that have been integrated into the delivery process. The final environment
    that will be created in this book is shown in the following diagram:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.14 – The CD pipeline/advanced CD'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B18223_01_14.jpg)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: Figure 1.14 – The CD pipeline/advanced CD
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
- en: I hope you are already excited by what we plan to build throughout this book.
    We will approach this step by step, explaining every detail and all the possible
    options to help you understand the procedures and tools. After reading this book,
    you will be able to introduce or improve the CD process in your projects.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we introduced the CD process, including the idea behind it,
    its prerequisites, and the tools that will be used throughout this book. The key
    takeaway from this chapter is that the delivery process that''s currently used
    in most companies has significant shortcomings and can be improved using modern
    automation tools. The CD approach provides several benefits, of which the most
    significant ones are fast delivery, a fast feedback cycle, and low-risk releases.
    The CD pipeline consists of three stages: CI, automated acceptance testing, and
    configuration management. Introducing CD usually requires the organization to
    change its culture and structure. The most important tools in the context of CD
    are Docker, Jenkins, and Ansible.'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll introduce Docker and show you how to build a dockerized
    application.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To test your knowledge of this chapter, please answer the following questions:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
- en: What are the three phases of the traditional delivery process?
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the three main stages of the CD pipeline?
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name at least three benefits of using CD.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the types of tests that should be automated as part of the CD pipeline?
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Should we have more integration or unit tests? Explain why.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does the term DevOps mean?
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What software tools will be used throughout this book? Name at least four.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本书将使用哪些软件工具？请列出至少四个。
- en: Further reading
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the concept of CD and its background, please refer to the
    following resources:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于CD概念及其背景的信息，请参考以下资源：
- en: '*Continuous Delivery*, by Jez Humble and David Farley: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*持续交付*，作者：Jez Humble 和 David Farley: [https://continuousdelivery.com/](https://continuousdelivery.com/)'
- en: '*TestPyramid*, by Martin Fowler: [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*测试金字塔*，作者：Martin Fowler: [https://martinfowler.com/bliki/TestPyramid.html](https://martinfowler.com/bliki/TestPyramid.html)'
- en: '*Succeeding with Agile: Software Development Using Scrum*, by Mike Cohn'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*敏捷成功之道：使用Scrum进行软件开发*，作者：Mike Cohn'
- en: '*Building Microservices: Designing Fine-Grained Systems*, by Sam Newman'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建微服务：设计精细化系统*，作者：Sam Newman'
