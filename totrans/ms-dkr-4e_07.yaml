- en: '*Chapter 7*'
  prefs: []
  type: TYPE_NORMAL
- en: Moving from Linux to Windows Containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will discuss and take a look at Windows containers. Microsoft
    has embraced containers as a way of deploying older applications on new hardware.
    Unlike Linux containers, Windows containers are only available on Windows-based
    Docker hosts.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Windows containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up your Docker host for Windows containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Windows containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Windows container Dockerfile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows containers and Docker Compose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the containers we will be launching will only work on a Windows
    Docker host. We will be using VirtualBox and Vagrant on macOS- and Linux-based
    machines to assist in getting a Windows Docker host up and running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/2DEwopT](https://bit.ly/2DEwopT)'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to Windows containers
  prefs: []
  type: TYPE_NORMAL
- en: As someone who has been using mostly macOS and Linux computers and laptops alongside
    Linux servers pretty much daily for the past 20 years, coupled with the fact that
    my only experience of running Microsoft Windows was the Windows XP and Windows
    10 gaming PCs I have had (along with the odd Windows server I was unable to avoid
    at work), the advent of Windows containers was an interesting development.
  prefs: []
  type: TYPE_NORMAL
- en: Now, I would never have classed myself as a Linux/Unix fanboy; however, Microsoft’s
    actions over the last few years have surprised even me. Back in 2014, at one of
    its Azure events, Microsoft declared “Microsoft Linux”, and it hasn’t looked back
    since.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some notable headlines since Microsoft’s declaration of love for Linux include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Linux is a first-class citizen in Microsoft Azure.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Core is cross-platform, meaning that you can run your .NET applications
    on Linux, macOS, and Windows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SQL Server has been available on Linux for a few years.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can run Linux shells, such as Ubuntu, on Windows 10 Professional machines.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PowerShell has been ported to Linux and macOS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has developed cross-platform tools, such as Visual Studio Code, and open
    sourced them.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It acquired GitHub for $7.5 billion!!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is clear that the Microsoft of old, where former **chief executive officer**
    (**CEO**) Steve Ballmer famously roasted both the open source and Linux communities
    by calling them something that would not be appropriate to repeat here, has gone.
  prefs: []
  type: TYPE_NORMAL
- en: Hence, the announcement made in October 2014, months after Microsoft publicly
    declared its love for Linux, that Docker and Microsoft were forming a partnership
    to drive the adoption of containers on Windows-based operating systems such as
    Windows 10 Professional and Windows Server 2016 came as no surprise to anyone.
  prefs: []
  type: TYPE_NORMAL
- en: So, what are Windows containers?
  prefs: []
  type: TYPE_NORMAL
- en: Well, on the face of it, they are no different from Linux containers. The work
    by Microsoft on the Windows kernel has introduced the same process isolation as
    found on Linux. Also, like Linux containers, this isolation extends to a sandboxed
    filesystem and even a Windows registry.
  prefs: []
  type: TYPE_NORMAL
- en: As each container is effectively a fresh Windows Core or Windows Nano installation,
    which, in turn, are cut-down Windows Server images (think Alpine Linux but for
    Windows), installation administrators can run multiple dockerized applications
    on the same host without having to worry about any custom registry changes or
    requirements clashing and causing problems.
  prefs: []
  type: TYPE_NORMAL
- en: Couple this with the same ease of use supplied by the Docker command-line client,
    and administrators have a way to migrate their legacy applications to more modern
    hardware, and also to host operating systems without the worries and overhead
    of having to manage multiple **virtual machines** (**VMs**) running older unsupported
    versions of Windows.
  prefs: []
  type: TYPE_NORMAL
- en: There is also another layer of isolation provided by Windows containers. **Hyper-V
    isolation** runs the container processes within a minimal hypervisor when the
    container is started. This further isolates the container processes from the host
    machine. However, there is a small cost of additional resources that are needed
    for each container running with Hyper-V isolation, while these containers will
    also have an increased start time as the hypervisor needs to be launched before
    the container can be started.
  prefs: []
  type: TYPE_NORMAL
- en: While Hyper-V isolation does use Microsoft’s hypervisor, which can be found
    in both Windows Server and Desktop editions, as well as the Xbox One system software,
    you can’t manage Hyper-V isolated containers using the standard Hyper-V management
    tools. You have to use Docker.
  prefs: []
  type: TYPE_NORMAL
- en: After all the work and effort Microsoft had to put into enabling containers
    in the Windows kernel, why did they choose Docker over just creating their own
    container management tool?
  prefs: []
  type: TYPE_NORMAL
- en: Docker had already established itself as the go-to tool for managing containers
    with a set of proven **application programming interfaces** (**APIs**) and a large
    community. Also, it was an open source application, which meant that Microsoft
    could not only adapt it for use on Windows but also contribute to its development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram gives an overview of how Docker on Windows works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Docker on Windows overview'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0011.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Docker on Windows overview
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I said Docker *on* Windows, not Docker *for* Windows; they are very
    different products. Docker on Windows is the native version of the Docker engine
    and client that interacts with the Windows kernel to provide Windows containers.
    Docker for Windows is a native-as-possible experience for developers to run both
    Linux and Windows containers on their desktops.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at preparing your host so that we can run Windows containers.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up your Docker host for Windows containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may have guessed, you are going to need access to a Windows host running
    Docker. Don’t worry too much if you are not running a Windows 10 Professional
    machine; there are ways in which you can achieve this on macOS and Linux. Before
    we talk about those, let’s look at how you can run Windows containers on Windows
    10 Professional with your Docker for Windows installation.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling Windows Container Support on Windows 10 Professional
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Windows 10 Professional supports Windows containers out of the box. By default,
    however, it is configured to run Linux containers. To switch from running Linux
    containers to Windows containers, right-click on the **Docker** icon in your system
    tray and select **Switch to Windows containers…** from the menu, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Switching to Windows containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0021.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Switching to Windows containers
  prefs: []
  type: TYPE_NORMAL
- en: 'This will bring up the following prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – An important note on what happens to your Linux containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0031.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – An important note on what happens to your Linux containers
  prefs: []
  type: TYPE_NORMAL
- en: 'Hit the **Switch** button and, after a few seconds, you will now be managing
    Windows containers. You can see this by opening up Command Prompt on your host
    and running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This can be seen from the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Checking the output of running docker version'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0041.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Checking the output of running docker version
  prefs: []
  type: TYPE_NORMAL
- en: The Docker Engine has an `OS/Arch of windows/amd64` version, rather than the
    `linux/amd64` version we have been used to seeing up until now. So, that covers
    Windows 10 Professional. But what about people like me who prefer macOS or Linux?
  prefs: []
  type: TYPE_NORMAL
- en: Up and running on MacOS and Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get access to Windows containers on macOS and Linux machines, we will be
    using the excellent resources put together by Stefan Scherer. In the `chapter07`
    folder of the repository that accompanies this book, there is a forked version
    of Stefan’s `docker-windows-box` repo as a Git submodule, which contains all of
    the files you need to get up and running with Windows containers on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: 'To check out the forked version, you will need to run the following command
    within the repository folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, before we start to launch the VM, you will need the following tools:
    Vagrant by HashiCorp, and VirtualBox by Oracle, which we covered in the last chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We do, however, need to install a `vagrant` plugin. To do this, run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the plugin is installed, we can start using Docker on Windows by opening
    a Terminal, going to the `chapter07/docker-machine` repository folder, and running
    the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will download a VirtualBox Windows Server 2019 `Core Eval` image that contains
    everything needed to get you up and running with Windows containers. The download
    is just over 6 **gigabytes** (**GB**), so please make sure that you have the bandwidth
    and disk space needed to run the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Vagrant will launch the image and configure Docker on the VM, along with a
    few other sensible defaults such as the Atom **integrated development environment**
    (**IDE**), Docker Compose, Docker Machine, and Git. Once the VM has launched,
    open your preferred Microsoft **Remote Desktop Protocol** (**RDP**) client, and
    then run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: If you are prompted for the password, enter `vagrant`, and you will be logged
    in to your newly launched Windows 2019 Server environment, with all of the tools
    you need to run Docker in Windows installed and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Also, if you don’t want to run something locally, a Windows 10 Professional
    instance in Azure has all of the necessary components enabled to be able to run
    Docker for Windows, which—as discussed in the previous section—allows you to run
    Windows containers, which we will be looking at next.
  prefs: []
  type: TYPE_NORMAL
- en: Running Windows containers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As already hinted at in the first part of this chapter, launching and interacting
    with Windows containers using the Docker command-line client is no different from
    what we have been running so far. Let’s test this by running the `hello-world`
    container, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Just as before, this will download the `hello-world` container and return a
    message, as illustrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Running the Windows-based hello-world container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0051.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Running the Windows-based hello-world container
  prefs: []
  type: TYPE_NORMAL
- en: The only difference on this occasion is that rather than the Linux image, Docker
    pulled the `windows-amd64` version of the image that is based on the `nanoserver-sac2016`
    image.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s look at running a container in the foreground, this time running
    PowerShell, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Once your shell is active, running the following command will give you the
    computer name, which is the container ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the full Terminal output of the preceding commands in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Running PowerShell within a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0061.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.6 – Running PowerShell within a container
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have exited PowerShell by running `exit`, you can see the container
    ID by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see the expected output in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Checking the containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0071.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.7 – Checking the containers
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at building an image that does something a little more
    adventurous than run PowerShell—instead, let’s install a web server.
  prefs: []
  type: TYPE_NORMAL
- en: A Windows container Dockerfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Windows container images use Dockerfile commands in the same format as for
    Linux containers. The following Dockerfile will download, install, and enable
    the **Internet Information Services** (**IIS**) web server on the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'You can build the image using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Once built, running `docker image ls` should show you the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Building and listing our image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0081.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.8 – Building and listing our image
  prefs: []
  type: TYPE_NORMAL
- en: 'The one immediate thing you will notice about Windows container images is that
    they are big. Running the container with the following command will start the
    IIS image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see your newly launched container in action by opening your browser.
    However, going to `http://localhost:8080/` won’t work as we have not provided
    any ports. If you remember, we are running Docker on Windows, so the containers
    are running directly on the host machine. Thus, there is no need to use localhost
    or mapped ports as we can access the container’s **network address translation**
    (**NAT**) **Internet Protocol** (**IP**) directly on the host machine of the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find the NAT IP address, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Running our Windows container image'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0091.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.9 – Running our Windows container image
  prefs: []
  type: TYPE_NORMAL
- en: 'This will give you an IP address. To access IIS, we simply need to put the
    IP address into a browser running on the Windows host. In this case, the `http://172.26.30.80/`.
    You should see the following default holding page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – The IIS web server running in a container'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0101.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.10 – The IIS web server running in a container
  prefs: []
  type: TYPE_NORMAL
- en: 'To stop and remove the containers we have launched so far, run the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: So far, I am sure you will agree that the experience is no different from using
    Docker with Linux-based containers.
  prefs: []
  type: TYPE_NORMAL
- en: Windows containers and Docker Compose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final section of this chapter, we are going to look at using Docker Compose
    with our Windows Docker host. As you will have already guessed, there isn’t much
    change from the commands we ran in [*Chapter 5*](B15659_05_Final_JM_ePub.xhtml#_idTextAnchor157),
    *Docker Compose*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `chapter07` folder in the repository, you will find a `docker-compose.yml`
    file that looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'There is also a supporting `.env` file—this is used by Docker Compose to populate
    variables in the Docker Compose file and should be placed in the same folder as
    the `docker-compose.yml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is using the same structure, flags, and commands as the
    previous Docker Compose files we have looked at, the only difference being that
    we are using images from the Docker Hub that are designed for Windows containers.
    The Docker Compose file will download Microsoft `database` and Octopus Deploy
    (`octopus`). To pull the required images, simply run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, once pulled, we need to create the folders required to launch Octopus
    Deploy, using the following commands in the same folder as the `docker-compose.yml`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we can launch Octopus Deploy by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Octopus can take around 10 minutes to start up. I would recommend running the
    following command to watch the container logs, to be certain that Octopus Deploy
    is up and running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the message `Completed System Integrity Check. Overall Result:
    Passed` in the log output, which should look something similar to the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Watching the output of our containers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0111.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.11 – Watching the output of our containers
  prefs: []
  type: TYPE_NORMAL
- en: 'As before, you can then use this command to find out the IP address on Windows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you have the IP address, which for me was `172.26.30.12`, open a browser
    and access the admin interface on port `81`. For me, that was `http://172.26.30.12:81/`.
    This should show you a login prompt—here, enter the username `admin`, with a password
    of `Passw0rd123`. Once logged in, you should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Octopus Deploy up and running'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/image_00_0121.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.12 – Octopus Deploy up and running
  prefs: []
  type: TYPE_NORMAL
- en: 'When you are ready, you can remove the containers by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Before we finish, there are a few things to note—the first is the use of a `.env`
    file. As already mentioned, this saves us having to use hard variables into our
    Docker Compose files; so, if you ever use them, don’t check them into a Git repo
    like I have done. Secondly, you may have noticed that when we ran the `docker-compose`
    command, we passed the `--project-name Octopus` parameter. This means that when
    we launch our project, rather than the application inheriting the name of the
    folder where the Docker Compose file is, it will be prefixed with `octopus`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have briefly looked at Windows containers. As you have seen,
    thanks to Microsoft’s adoption of Docker as a management tool for Windows containers,
    the experience is familiar to anyone who has used Docker to manage Linux containers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to take a look at Docker Swarm. This will
    be the first time we have moved from single Docker hosts to a cluster of hosts.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Docker on Windows introduces which additional layer of isolation?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command would you use to find out the NAT IP address of your Windows container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false: Docker on Windows introduces an additional set of commands you
    need to use in order to manage your Windows containers.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find more information on the topics mentioned in this chapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker and Microsoft Partnership Announcement: [https://blog.docker.com/2014/10/docker-microsoft-partner-distributed-applications/](https://blog.docker.com/2014/10/docker-microsoft-partner-distributed-applications/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Windows Server and Docker – The Internals Behind Bringing Docker & Containers
    to Windows: [https://www.youtube.com/watch?v=85nCF5S8Qok](https://www.youtube.com/watch?v=85nCF5S8Qok)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Stefan Scherer on GitHub: [https://github.com/stefanScherer/](https://github.com/stefanScherer/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Octopus Deploy: [https://octopus.com](https://octopus.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
