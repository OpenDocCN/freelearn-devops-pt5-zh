- en: '15'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Ansible with GitHub Actions and Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will start running Ansible in the cloud instead of our local
    machines, something we have been doing up to this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, this chapter will examine two services I often use during my day job:'
  prefs: []
  type: TYPE_NORMAL
- en: Running GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running pipelines in Azure DevOps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we move on, we will examine tools designed to execute Ansible from a
    central location in [*Chapter 16*](B21620_16.xhtml#_idTextAnchor716), *Introducing
    Ansible AWX and Red Hat Ansible* *Automation Platform*.
  prefs: []
  type: TYPE_NORMAL
- en: Neither of the two services we will be looking at has what you would call native
    support for Ansible; however, they both provide ephemeral compute resources that
    can be configured using YAML, which you can ship alongside your playbook code.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will cover a more complex playbook in both **GitHub Actions** and
    **Azure DevOps**. We will also discuss some considerations when running Ansible
    away from your machine.
  prefs: []
  type: TYPE_NORMAL
- en: So, rather than discussing it anymore, let’s dive straight in and look at GitHub
    Actions.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are following along with the example code that we will be working through,
    then you will need access to a GitHub and an Azure DevOps account, as well as
    an Azure account since we will be launching a WordPress instance running in Azure
    as part of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete copy of the playbook, GitHub Action config, and Azure
    DevOps Pipeline code accompanying this chapter in this book’s GitHub repository
    at [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15).
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub Actions is a comprehensive platform for **continuous integration** (**CI**)
    and **continuous delivery** (**CD**) from GitHub. It enables you to automate your
    build, test, and deployment pipeline while hosting your code and GitHub’s exhaustive
    suite of code management tools. Using GitHub Actions, you can define custom workflows
    that automatically build and test every pull request made to your repository or
    deploy merged pull requests to production.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions offers more than just DevOps functionality as it is closely integrated
    with GitHub. This allows you to run workflows in response to other repository
    events. For instance, you can have a workflow that adds relevant labels automatically
    when a new issue is created in your repository.
  prefs: []
  type: TYPE_NORMAL
- en: With GitHub Actions, you’re in control. You can run your workflows using GitHub’s
    Linux, Windows, and macOS virtual machines. You can also take full charge and
    operate self-hosted runners in your own data center or cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a GitHub Action workflow to utilize the Linux agents hosted by
    GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: Preparation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to configure a few things before we can start working through our GitHub
    Action workflow code:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a GitHub repository to host our code and workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate an SSH key pair; this will be used to access our Azure-hosted virtual
    machine instance from the GitHub-hosted compute resource when the workflow runs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Configure some repository secrets that will be used in our workflow; these will
    store things such as our Azure credentials and the SSH key pair we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the files from [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15)
    to your new repo and run the workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let’s look at these steps in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s start by creating a repository in GitHub that we will use to host our
    code and workflow.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need to log into GitHub. Once you’ve logged in, go to **Repositories**
    and then click on the **New** button; you will be taken to the **Create a new
    repository** page, where you need to update the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Owner**: Here, you need to select an owner for the repository. This will
    typically be your GitHub user; however, if you belong to any organization, you
    may have the option of creating the repository under one of those organizations.
    If you do that, please ensure that you have permission to do so as we will be
    spinning up temporary compute resources, which may not be allowed by your organization’s
    admins.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Repository name**: I recommend using something descriptive, such as *Learn-Ansible-Second-Edition-Chapter15*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Description**: While this is optional, it is always best to add one; for
    example, let’s add *Following along with* [*Chapter 15*](B21620_15.xhtml#_idTextAnchor641)
    *of* *Learn Ansible*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public** or **Private**: I recommend setting your repository’s visibility
    to *private*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can leave the remaining options as-is and then click on the **Create repository**
    button at the end of the form. Once the repository has been created, you should
    be presented with a page that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.1 – Our new repository](img/B21620_15_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.1 – Our new repository
  prefs: []
  type: TYPE_NORMAL
- en: Let’s move on to the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the SSH key pair and Azure Service Principle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We need to generate an SSH key pair and an Azure Service Principle before adding
    secrets to our newly created repository.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Remember to run the commands in Windows Subsystem for Linux if you’re following
    along on a Windows machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, open a Terminal and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When prompted to enter a passphrase, just hit *Enter*; we don’t want to use
    one. This should give you two files: one called `id_rsa`, which contains the private
    portion of our key – please keep this private – and another called `id_rsa.pub`.
    As its name implies, it includes the public portion of our SSH key.'
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to generate an Azure Service Principle and grant permissions to
    our Azure subscription.
  prefs: []
  type: TYPE_NORMAL
- en: From [*Chapter 7*](B21620_07.xhtml#_idTextAnchor336), *Ansible Windows Modules*,
    and [*Chapter 9*](B21620_09.xhtml#_idTextAnchor411), *Moving to the Cloud*, we
    used the Azure command-line tool to log in using our Azure credentials. However,
    when interacting with Azure using services such as GitHub Actions, we don’t want
    to use our credentials as they will be locked down with multi-factor authentication,
    and you don’t want to hand out your credentials.
  prefs: []
  type: TYPE_NORMAL
- en: To get around this, we can create a service principal and grant it permissions
    to the Azure subscription so that it can launch resources from the GitHub Action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the service principle, you need to log into Azure using the Azure
    CLI by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are already logged in, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Both commands will return a list of subscription IDs your account can access.
    Please make a note of the ID; we will need it momentarily.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of the sort of output you can expect to see; this is the
    JSON that is being returned by the API request that the Azure CLI has made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The information we are after is labeled as `id` against the subscription to
    which we would like to grant the service principal access. Using the preceding
    example, the command I would need to run would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: When you run this command, replace the subscription ID in the scope with your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output you get will look something like this; please note it down as you
    will not be able to retrieve the password again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Also, as I am sure you will have already guessed, none of the information in
    the preceding examples is valid data, so please use your values in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub personal access token
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one more set of credentials we need to generate; because our GitHub
    repository is set to private, we need to be able to authenticate to check the
    code out and write logs back to the repository during the workflow run. To do
    this, we will need to generate a personal access token.
  prefs: []
  type: TYPE_NORMAL
- en: A personal access token for GitHub is a secure, revocable, and customizable
    credential that allows you to authenticate with GitHub and access its API or command-line
    tools without using your main account password.
  prefs: []
  type: TYPE_NORMAL
- en: Rather than documenting the process here, as GitHub is moving from classic to
    fine-grained tokens at the time of writing, an up-to-date copy of the documentation
    can be found at [https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens).
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, you need to name your token, select just your repository,
    and grant it the following access:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Contents**: Read-only'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metadata**: Read-only; this will be selected automatically once the permission
    is set'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have your token, please note it somewhere secure; it will not be displayed
    again.
  prefs: []
  type: TYPE_NORMAL
- en: Adding secrets to the repository
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Go back to the repository in GitHub by choosing **Settings** | **Secrets and
    Variables** | **Actions**. Click the **New repository secret** button for each
    of the secrets listed in the following table. Please make sure that you call each
    secret as per the following naming conventions since our workflow code references
    these secrets by their name:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Secret Name** | **Secret Content** |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_CLIENT_ID` | This is the `appId` value from when you create the service
    principle. In this example, this would be `2616e3df-826d-4d9b-9152-3de141465a69`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_CLIENT_SECRET` | This is the `password` value that was given when you
    created the service principle. In this example, this would be `Y4j8Q~gVO*NoTaREalPa55w0rdpP-pdaw`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_SUBSCRIPTION_ID` | This is your Azure subscription ID; use the one you
    granted the service principal access to. In this example, this would be `e80d5ad9-e2c5-4ade-a866-bcfbae2b8aea`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_TENANT_ID` | This is the ID of the `tenant` value listed when you created
    the service principle. In this example, this would be `c5df827f-a940-4d7c-b313-426cb3c6b1fe`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SSH_PRIVATE_KEY` | Open the `id_rsa` file in a text editor and copy and
    paste the contents here. |'
  prefs: []
  type: TYPE_TB
- en: '| `SSH_PUBLIC_KEY` | Open the `id_rsa.pub` file in a text editor and copy and
    paste the contents here. |'
  prefs: []
  type: TYPE_TB
- en: '| `GH_PAT` | This should contain your GitHub personal access token. |'
  prefs: []
  type: TYPE_TB
- en: Table 15.1 – Information needed for GitHub Actions
  prefs: []
  type: TYPE_NORMAL
- en: 'Once they have all been added, your **Actions secrets and variables** page
    should look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.2 – All of the repository secrets have been added](img/B21620_15_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.2 – All of the repository secrets have been added
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all the basic configurations for the GitHub Action, let’s look
    at the workflow itself.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the GitHub Action workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The workflow file, which lives in the `.github/workflows/action.yml` file,
    contains, as its name suggests, the YAML code containing the jobs, steps, and
    tasks that will be executed during the workflow run. In our case, the workflow
    will execute the following two jobs, with each job being made up of multiple steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scan the Ansible Playbook:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check out the code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a folder to store the scan results.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a KICS scan on the checked-out code.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload a copy of the results to GitHub.
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, if KICS detects a problem with our playbook, it will report an error,
    and the workflow will stop here – if everything looks good with the KICS scan,
    then the workflow will proceed by running the following job:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install and run the Ansible Playbook:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if a cached version of our Ansible modules and Python packages is available.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If not cached, download and install the Ansible Azure modules and the supporting
    Python packages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check out the code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log into Azure using the Azure CLI and the service principle we created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the SSH key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the Ansible Playbook, logging the output of the Playbook so that we can
    store a copy alongside the scan results in the workflow logs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the Playbook execution summary.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we know what the workflow will do, let’s dive into the code. We’ll
    start with some basic configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line disables a KICS check – while the workflow does not form part
    of our Playbook, it is stored in the repository and will be scanned as part of
    the workflow’s execution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are also setting the name of the workflow, which is how it will appear in
    the GitHub web interface, before finally setting up some variables that we will
    use during the workflow’s execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next up, we have the configuration that defines the workflow that should run;
    for our needs, we will run the workflow each time the code is committed to the
    main branch:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, we must define our first job, which is the one that scans the Playbook
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are defining it as `scan_ansible_playbook`, which runs on
    the latest version of the Ubuntu image supplied by GitHub, and the default action
    for tasks is to run bash. With the job defined, we can move on to the next steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start with the ones that check out the code and create the directory where
    we are going to be storing the results of the scan we will be running:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The step downloads a copy of the repository in which the workflow is hosted;
    as you can see, we are using `${{secrets.GH_PAT}}`. We will look at secret variables
    a little later. Now, we must create the folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The section step creates a directory whose name is referenced as the `RESULTS_DIR`
    environment variable, which we defined in the top section of the workflow file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'When referencing an environment variable, we use the `${{env.VARIABLE_NAME}}`
    format. So, in our case, we are using `${{env.RESULTS_DIR}}`. In the next step,
    we have a dedicated task for running KICS, which is managed and maintained by
    Checkmarx:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, we are instructing the task to output the JSON and SARIF files,
    `${{env.RESULTS_DIR}}` directory we created in the previous step and also for
    the workflow fail if the results of the scan contain anything with a severity
    defined in `${{ env.FAIL_ON }}`. We set this to `medium` at the start of the workflow
    file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that we have completed the scan, we can review the workflow code for the
    job that installs and runs Ansible. This is called `run_ansible_playbook`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, the job is defined the same as the first job, with one exception:
    we have added a `needs` line with a value of `scan_ansible_playbook`. This instructs
    the job to only run once `scan_ansible_playbook` has completed with a successful
    status.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The step of the job checks for the presence of three folders; if they exist,
    a cached version of those folders will be used, meaning that once the workflow
    has been run once, subsequent executions will be much quicker as we don’t have
    to install the Ansible Galaxy modules and their requirements each time the workflow
    runs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, we have the step that checks out our repo:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You might be wondering, “*Why do we need to check out the code again? We already
    did that during the last job.*” This is a great question.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The answer is that the compute resource that ran the job was terminated when
    the last job finished running, and all data was lost. When the current job started,
    a new resource was launched, and we started again with a completely fresh installation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The next step in the workflow uses the `Azure/login@2` task to install the
    Azure CLI if it’s not already installed and then log in using the service principal
    information we defined as repository secrets earlier in this chapter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to embed secrets using the `${{ secrets.SECRET_NAME }}` format. Here,
    we are using the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`${{``secrets.ARM_CLIENT_ID }}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${{``secrets.ARM_CLIENT_SECRET}}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${{` `secrets.ARM_SUBSCRIPTION_ID }}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`${{` `secrets.ARM_TENANT_ID }}`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Because these are all defined as secrets, the values will never appear in any
    of the Pipeline run logs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This means that while we know the values, someone else who has permission to
    run the workflow will never need to be told the credentials for our service principle
    as they can consume the secrets. They will also never accidentally be exposed
    to them if they check any logs or try and output them due to the workflow’s execution
    as they will be automatically redacted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final step before we run Ansible is to add and configure the SSH key pair
    to our host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The SSH key pair is the final piece we needed. Now, we can run Ansible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, there is slightly more to running Ansible here than we have
    been doing on our local machines. The reason we are running the Ansible playbook
    is to capture its output and format the output so that it can be displayed in
    the GitHub Actions job log.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a breakdown of what’s happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Run the playbook (with ansible-playbook)` for clarity in the workflow’s execution
    log.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible-playbook-run` so that we can refer to this step’s outputs in the subsequent
    step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`continue-on-error` to `true`, we are allowing the workflow to continue even
    if this step encounters an error. This is useful for ensuring that the workflow
    can proceed to steps that might, for example, provide diagnostic information or
    perform cleanup actions, even if the Ansible playbook fails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Run**: This key starts a multi-line script block that’s executed in the jobs
    shell. The script does the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This command runs the Ansible playbook defined in `site.yml` with an inventory
    file, `inv`. The `2>&1` part redirects `stderr` to `stdout`, so both standard
    output and errors from the `ansible-playbook` command are piped to the `tee` command.
    `tee ansible_output.log` writes the output to `ansible_output.log` and displays
    it in the workflow’s log for real-time monitoring.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Subsequent `echo` commands and `cat` append a formatted summary of the Ansible
    output to the special `GITHUB_OUTPUT` environment variable. As you may have noticed,
    we are mostly using Markdown to format the text.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`env` section defines environment variables for this step. `ANSIBLE_HOST_KEY_CHECKING:
    "False"` disables Ansible’s SSH host key checking. This option is often used in
    automated environments to avoid manual interventions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final step in our workflow takes the output of the previous step and outputs
    it to `$GITHUB_STEP_SUMMARY`. This is a special variable that’s used by a GitHub
    Actions workflow to record the results of a step in the workflow executions log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: While that completes our workflow code review, one more task happens in the
    background that we don’t have to define. As you may recall, in the first step
    of the `run_ansible_playbook` job, we had a step that looked for any caches associated
    with the workflow. Well, by defining that step, there is a post-deploy task that
    runs at the end of the workflow and creates the cache if one doesn’t exist.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand our workflow code, let’s check out a copy of our newly
    created repository. Copy the code from the example repository and then check in
    the changes.
  prefs: []
  type: TYPE_NORMAL
- en: Committing the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned previously, before running the workflow, we need to check out the
    empty repository we created at the start of this chapter. This will vary depending
    on how you interact with GitHub. I use the command line, but you might use the
    GitHub Desktop application or an IDE such as Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the GitHub desktop application, see [https://desktop.github.com/](https://desktop.github.com/).
    For details on how to configure an SSH connection to GitHub, see [https://docs.github.com/en/authentication/connecting-to-github-with-ssh.](https://docs.github.com/en/authentication/connecting-to-github-with-ssh.)
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to follow along on the command line, you must update the repository’s
    name to reflect your own and ensure you have SSH access to your GitHub repositories:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once I was in the folder, I copied across the contents of [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15),
    ensuring that I also copied the `.github` folder as this contains the workflow
    we want to execute.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once copied, I ran the following commands to add the new files and create the
    first commit, then pushed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything goes as planned, if you go to your repository and click on the
    **Actions** tab, you should see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.3 – Our first commit is running the GitHub Action](img/B21620_15_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.3 – Our first commit is running the GitHub Action
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking the name of the commit should show you the progress of the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.4 – Viewing the progress of the workflow](img/B21620_15_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.4 – Viewing the progress of the workflow
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the running job – in my example, this is the *Install Ansible and
    Run Playbook* job. This will show you its real-time progress:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.5 – Viewing the real-time output](img/B21620_15_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.5 – Viewing the real-time output
  prefs: []
  type: TYPE_NORMAL
- en: If everything works as planned, the Ansible playbook will run, the Azure resources
    will be deployed, and we should have a running WordPress instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on the **Summary** link at the top of the page will show you the full
    output. Here, we’ll see any warnings or information that was logged during the
    workflow run, followed by the KICS results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.6 – The KICS scan results](img/B21620_15_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.6 – The KICS scan results
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also be able to expand the **Ansible Playbook Output** area and view
    the logs:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 15.7 – Ansible Playb\uFEFF\uFEFFook Output](img/B21620_15_07.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 15.7 – Ansible Playbook Output
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we remove the Azure resources, let’s see what happens when the scan
    fails. To do this, open `roles/azure/tasks/main.yml` and remove the line that
    reads as follows (it should be around line *61*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Once removed, check in the updated code. This will trigger a new workflow run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.8 – Triggering a second workflow run](img/B21620_15_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.8 – Triggering a second workflow run
  prefs: []
  type: TYPE_NORMAL
- en: 'As the line we removed will trigger a medium severity rule, our workflow run
    should fail, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.9 – Our second workflow run failed due to our change](img/B21620_15_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.9 – Our second workflow run failed due to our change
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished testing, I recommend logging into Azure and manually
    deleting the resource group containing the resources we’ve just launched.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, while there are considerations you need to make for your deployments
    – such as ensuring all the connectivity and steps are in place to interact with
    your cloud provider securely – the general gist and approach to running our Playbooks
    remains much the same as on our local machine.
  prefs: []
  type: TYPE_NORMAL
- en: The same can also be said about the next tool we will examine, Azure DevOps.
  prefs: []
  type: TYPE_NORMAL
- en: Azure DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The description we used for GitHub Actions also applies to Azure DevOps Pipelines
    and repositories, two of the Azure DevOps services we will use in this section.
    Again, we will use platform-provided computing resources to run our Ansible Playbook,
    and many approaches will be the same. So, rather than covering old ground, let’s
    start with preparing an Azure DevOps project to host our code and run our Playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and configuring our project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, you will need to create an Azure DevOps project. Like our GitHub repository,
    I’ve called it `Learn-Ansible-Second-Edition-Chapter15`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.10 – Our newly created Azure DevOps project](img/B21620_15_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.10 – Our newly created Azure DevOps project
  prefs: []
  type: TYPE_NORMAL
- en: We need to configure a few things before checking our code in and adding our
    pipeline; the first is to create a service connection to Azure itself. To do this,
    click on the **Project Settings** button, which can be found at the bottom far
    left-hand corner of the page.
  prefs: []
  type: TYPE_NORMAL
- en: Once **Project Settings** is open, in the left-hand menu under **Pipelines**,
    click **Service connections**, then click the **Create service** **connection**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: Select **Azure Resource Manager**, then click **Next**; from here, select **Service
    principal (manual)** and click **Next** again.
  prefs: []
  type: TYPE_NORMAL
- en: We are taking this approach rather than any of the others, which would automatically
    create the service principle for us, as we already have the details of a service
    principle noted from the *GitHub* *Actions* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table contains the information you need to enter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Option** | **Content** |'
  prefs: []
  type: TYPE_TB
- en: '| **Subscription Id** | This is your Azure subscription ID; use the one you
    granted the service principal access to. In this example, this would be `e80d5ad9-e2c5-4ade-a866-bcfbae2b8aea`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Subscription Name** | Enter the name of your Azure subscription. Since
    we are going to be referring to the subscription ID in the pipeline code, this
    can be set to anything you like. |'
  prefs: []
  type: TYPE_TB
- en: '| **Service** **Principal Id** | This is the `appId` value from when you create
    the service principle. In this example, this would be `2616e3df-826d-4d9b-9152-3de141465a69`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Service** **principal key** | This is the `password` value that was given
    when you created the service principle. In this example, this would be `Y4j8Q~gVO*NoTaREalPa55w0rdpP-pdaw`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Tenant ID** | This is the ID of the `tenant` value listed when you created
    the service principle. In this example, this would be `c5df827f-a940-4d7c-b313-426cb3c6b1fe`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| **Service** **connection nam****e** | Enter `azConnection` here as this is
    how we are referencing the connection in the pipeline code. |'
  prefs: []
  type: TYPE_TB
- en: '| **Security** | Ensure that **Grant access permission to all pipelines** is
    selected. |'
  prefs: []
  type: TYPE_TB
- en: Table 15.2 – Information needed for your pipeline in Azure DevOps
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve entered this information, click the **Verify and Save** button.
    This will check the details you entered are correct and save the service connection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to install a few extensions from the Visual Studio Marketplace,
    allowing us to publish our KICS report and an overview of our Playbook run:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Markdown** **Reports**: [https://marketplace.visualstudio.com/items?itemName=MasamitsuMurase.publish-markdown-reports](https://marketplace.visualstudio.com/items?itemName=MasamitsuMurase.publish-markdown-reports)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sarif** **Tools**: [https://marketplace.visualstudio.com/items?itemName=sariftools.scans](https://marketplace.visualstudio.com/items?itemName=sariftools.scans)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To enable the extensions on your Azure DevOps organization, follow the preceding
    URLs and the instructions when you click the **Get it** **free** button.
  prefs: []
  type: TYPE_NORMAL
- en: The final configuration piece is adding a pipeline variable group and secure
    file. To do this, click on **Pipelines** in the left-hand side menu and then click
    **Library**. Once on the **Library** page, click the **+ Variable** **group**
    button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Name the variable group `playbook` and enter the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** | **Value** |'
  prefs: []
  type: TYPE_TB
- en: '| `breakSeverity` | `MEDIUM` |'
  prefs: []
  type: TYPE_TB
- en: '| `SSH_PUBLIC_KEY` | Paste the contents of the `id_rsa.pub` file here |'
  prefs: []
  type: TYPE_TB
- en: '| `subscriptionName` | `azConnection` – this is the name of the connection
    we created at the start of this section |'
  prefs: []
  type: TYPE_TB
- en: Table 15.3 – Information required for the variable group
  prefs: []
  type: TYPE_NORMAL
- en: Once you have filled in the preceding information, click `id_rsa` file.
  prefs: []
  type: TYPE_NORMAL
- en: We now have all the base configurations ready and can upload our code.
  prefs: []
  type: TYPE_NORMAL
- en: Cloning the repository and uploading the code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we must clone the repository and upload our code, including the `azure-pipelines.yml`
    file we will cover in the next section. To do this, click on **Repos** in the
    left-hand side menu; you will be presented with several ways to clone the repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'I’ve chosen to clone using SSH again; if you are following along, update the
    `git clone` command to reflect your repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I then copied the files across from [https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15](https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter15).
    This time, I didn’t worry about copying the `.github` directory as it isn’t required.
    Once the files were in my locally cloned folder, I ran the following commands
    to add the new files and create the first commit, then push:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Unlike when we first checked our code into GitHub, nothing will happen because
    we haven’t configured our pipeline yet.
  prefs: []
  type: TYPE_NORMAL
- en: The Azure DevOps pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our pipeline is defined in the `azure-pipelines.yml` file, which can be found
    at the root of our repository file. Let’s quickly review the content before we
    create the pipeline using that file.
  prefs: []
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: Structurally, our `azure-pipelines.yml` file is close to what we have already
    covered for GitHub Actions; in fact, you might almost think they are interchangeable
    and compatible – however, they aren’t, so please be careful not to mix the two
    up.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our pipeline file starts with a basic configuration that instructs the pipeline
    when to trigger, which variable group to load, and which underlying image to use.
    Right at the top, there’s an exclusion rule for KICS, something we covered in
    [*Chapter 13*](B21620_13.xhtml#_idTextAnchor566), *Scanning Your* *Ansible Playbooks*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the basic configuration is complete, we can start the stages:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first run is the KICS scan on the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This stage is made up of a single job:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you may have noticed, here, we are using the `checkmarx/kics:debian` container
    image to deploy KICS. This will spin up the container and run the following steps
    from within it. Our step contains two tasks – the first creates the output folder,
    checks out the code, and runs the scan:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The second task publishes the content of the output directory, which contains
    all of our scan results as a build artifact:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the files published, we no longer need the resources that were generated
    during this stage, so we can move on to the second stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As you can see, this stage parses our scan results; the first task we run downloads
    a copy of the artifact we uploaded during the last stage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have the results files, we need to review them to figure out if
    the Ansible Playbook should be run or not. This task runs a bash script that reads
    the JSON results and sets some pipeline variables to control what happens next.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We start the task with some configuration:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have the script itself, which starts by setting some local variables
    and printing some results out to the screen using the `echo` command. These will
    appear in our pipeline run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then, we create a *group*, which means that when we review the pipeline output,
    the following information will be minimized, making it easier to read.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the group, we have an `if` statement that states that if less than (`-lt`)
    `1` issues are detected (that is, zero issues), then the output variable, `OK_TO_DEPLOY`,
    is set to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If this condition is not met – that is, there are one or more issues – then
    `OK_TO_DEPLOY` is set to `false` and an error is logged:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Logging the error will stop the remainder of the pipeline from running. The
    next and final stage runs the Ansible Playbook. It has a dependency on the previous
    stage being successfully executed and `OK_TO_DEPLOY` being set to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first task logs us into Azure and sets the service principle details as
    environment variables for use in a later task:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next up, we need to add our SSH key to our environment. This uses the secure
    file we uploaded earlier:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we need to add the public portion of the SSH key, install the bits we
    need to run the Ansible Playbook, and then actually run it, remembering to add
    the details for the service principle:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the environment ready, we can run the script, which starts by adding the
    `id_rsa.pub` file and adding the right permissions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next part of the script installs the Azure Ansible collection from Ansible
    Galaxy and installs the requirements. We are using `--force` here to ensure that
    the latest copy of all the collection is pulled down from Ansible Galaxy:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With those installed, we can now run the playbook; we are taking a similar
    approach to running the playbook as we did for our GitHub Action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final part of our script takes our Ansible output and creates a Markdown
    file called `summary.md`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final task of the pipeline is to upload a copy of the `markdown/summary.md`
    file to our pipeline:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, our pipeline is complete. So, now that we know what it does, let’s
    add it to our Azure DevOps project and run it for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: If you click on `azure-pipelines.yml` file will be loaded and you will have
    the option to **Run** or **Save**. We’ll click **Run**.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be presented with something like the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.11 – Running the pipeline for the first time](img/B21620_15_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.11 – Running the pipeline for the first time
  prefs: []
  type: TYPE_NORMAL
- en: 'However, not is all as it seems! If you click on the first stage, you will
    be presented with the following. The pipeline needs permissions to access the
    variable group we created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.12 – Granting the permissions for the variable group](img/B21620_15_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.12 – Granting the permissions for the variable group
  prefs: []
  type: TYPE_NORMAL
- en: Click **View** and follow the onscreen instructions to grant the permissions.
    The KICS scan will run, and the stage will be complete. It will then move on to
    the **Parse Scan Results** stage, which should be completed again.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you go back to the summary, you’ll see that more permissions are required,
    this time to access the secure file we uploaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.13 – Grant the permissions for the secure file](img/B21620_15_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.13 – Grant the permissions for the secure file
  prefs: []
  type: TYPE_NORMAL
- en: Again, click **View** and follow the onscreen instructions to grant permission.
    This should be the last permission that needs to be given. From now on, when we
    run the pipeline, permissions will already be given.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you click on the **Run Ansible** stage, you can keep track of the Playbook
    run. If everything goes as planned, returning to the summary should show you something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.14 – Everything worked!!!](img/B21620_15_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.14 – Everything worked!!!
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on **Markdown reports** will show the result of the Playbook run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.15 – The Markdown report](img/B21620_15_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.15 – The Markdown report
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking **Scans** will show you the results of the KICS scan:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.16 – The scan report](img/B21620_15_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.16 – The scan report
  prefs: []
  type: TYPE_NORMAL
- en: 'Like GitHub Actions, let’s see what happens when the scan fails. Again, open
    `roles/azure/tasks/main.yml` and remove the line that reads as follows (it should
    be around line *61*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Once removed, check in the updated code. This will trigger a new workflow run:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 15.17 – The pipeline has errored](img/B21620_15_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 15.17 – The pipeline has errored
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have a message stating **Pipeline failed due to 1 issue(s)
    found**, and the **Run Ansible** stage was skipped as we didn’t meet the conditions
    for it to run.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have finished testing, log into Azure and manually delete the resource
    group containing the resources we have just launched.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at running our Ansible Playbooks using the compute
    resources GitHub and Azure DevOps provide. We discovered that this is great for
    running our playbook code as we can ship code that defines the configuration for
    the computing resources alongside our Playbook code.
  prefs: []
  type: TYPE_NORMAL
- en: We also learned that by using the built-in tools, we can securely configure
    our environment so as not to expose secrets, such as our service principle credentials,
    to other users who have access to run the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The only downside is that we had to create the logic that runs the playbook.
    Wouldn’t it be great to use a tool designed to centrally run our Playbooks from
    a single user interface? Well, in our next chapter, we will cover exactly that
    – so if you like the approach we have taken so far, read on.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**GitHub** **Actions**: [https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Azure** **DevOps**: [https://azure.microsoft.com/en-gb/products/devops](https://azure.microsoft.com/en-gb/products/devops)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
