- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rebasing, Amend, and Cherry-Picking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you say "rebasing" to most novice Git programmers, they burst into tears
    and run screaming from the room. But the truth is that this is only because of
    how it is explained in so many books and magazines, where rebasing is (correctly
    but confusingly) shown with diagrams of commits being copied and moved along with
    dense and technical text.
  prefs: []
  type: TYPE_NORMAL
- en: In truth, rebasing is not hard to understand, and it is not hard to do if you
    understand what it is for. In this chapter, we will review rebasing without fear.
  prefs: []
  type: TYPE_NORMAL
- en: '**Rebasing** is a command that allows you to take a feature branch and place
    it on the tip of another branch. We''ll discuss how, and more importantly *why*,
    you would do this.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Amending** is a quick command that allows you to modify the most recent commit.
    You can use this to add a file you forgot to put in the commit or to fix up a
    botched message.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cherry-picking** is the ability to take one or more commits from a branch
    and apply them onto the tip of another branch.'
  prefs: []
  type: TYPE_NORMAL
- en: Git programmers describe these three commands as **rewriting history** and that
    is what they all have in common. Each has the ability to change how commits were
    added to the repository, and thus clean up your list of commits.
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Rebasing is nothing more than taking one branch and adding it to the tip of
    another, where the tip is simply the last commit in the branch. For example, suppose
    you have the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Git structure'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can''t do a fast forward here, because **Main** has moved on since you
    branched from it. You can do a true merge, but a true merge adds a commit to your
    history every time you do one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: True merges'
  prefs: []
  type: TYPE_NORMAL
- en: A rebase solves the same problem, but without adding merges to the commit history.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that as you review this history, you have to skip over a significant
    number of commits since they are just merges. Rebase eliminates most of these
    commits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here comes the important part:'
  prefs: []
  type: TYPE_NORMAL
- en: You merge branch **Feature1** *into* **Main**, but you rebase **Feature1** *onto*
    **Main**.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning to our earlier example, if you rebase **Feature1** onto **Main**,
    it looks like this:![](img/B17741_05_03.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 5.3: After the rebase'
  prefs: []
  type: TYPE_NORMAL
- en: There is now a clear path from the first commit of **Main** to the last commit
    of **Feature1** without leaving anything out. This is most often drawn like this:![](img/B17741_05_04.png)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Figure 5.4: Another way to look at the commits after rebasing'
  prefs: []
  type: TYPE_NORMAL
- en: This emphasizes that you have rebased **Feature1** onto the tip of **Main**
    (the tip is **Main**'s latest commit).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That is all there is to rebasing. Honest.
  prefs: []
  type: TYPE_NORMAL
- en: How Git does it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, I don't spend time or brain cells on how Git does what it does, but
    here it is worth noting that to rebase, Git rolls back history to the first **Feature1**
    commit and then makes a copy and adds it to the tip of **Main**. It then makes
    a copy of the second **Feature1** commit and puts that on top of the latest commit,
    and so forth.
  prefs: []
  type: TYPE_NORMAL
- en: The reason this is important is that a copy is made, and thus will have a different
    ID. Okay, you are now free to forget all this and treat rebasing as the magic
    it is.
  prefs: []
  type: TYPE_NORMAL
- en: Getting your head around it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rebasing is not hard, as you have seen. But truly grokking what is happening
    and why it is okay takes anywhere from five minutes to five years. We are taking
    our feature and putting it on top of Main. Remember that our feature started as
    a branch off of Main.
  prefs: []
  type: TYPE_NORMAL
- en: Now we're incorporating all that is in Main into our feature.
  prefs: []
  type: TYPE_NORMAL
- en: That is the critical part. Because we do this locally, we are just saying "no
    matter how much Main has advanced, I will eventually need to merge into it. For
    now, I'm going to rebase onto Main, making it one long branch, and make sure there
    are no conflicts."
  prefs: []
  type: TYPE_NORMAL
- en: Rebase early and rebase often
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very good practice to rebase frequently, so as to surface any conflicts
    that might arise. Each time you rebase, you end up with a stack of commits that
    has all that came before and then your new commits at the tip. If a conflict arises
    between what you just added and what was there, you will see it immediately and
    can fix it on the spot.
  prefs: []
  type: TYPE_NORMAL
- en: Rebase locally only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You rebase *only* on your local machine, and *never* on the shared repository
    in the cloud (for example, GitHub). This is because rebasing "rewrites history"
    – remember that it makes copies of Feature1 – and if another programmer is working
    on that branch, they will not be happy with you if you rebase. This is the kind
    of "not happy" that can lead to felony charges.
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing in practice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new repository named Rebasing. We''re going to watch Adam as
    he creates a branch named `Person` by taking the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to the main root directory
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a branch named `Person`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Visual Studio and create a project named `Person`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new class named `Person`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Rebasing` repo to your local repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the repository and commit it (which will also commit `Person`)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add an age property to `Person` and commit (but don''t push):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a name property and commit but don't push
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After we add a height property, we are in this situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: History of commits in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: 'We could push now, but there is more work to be done on the `Person` class.
    On the other hand, we don''t want main to have moved so far away from us that
    we''ll have too many conflicts when we are done with person. The answer: rebase.
    Make sure you are on person, then right-click on main and choose **Rebase ''person''
    onto ''main''**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Rebasing in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: With that done, we can continue working on the `Person` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that you have only four outgoing commits:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Rebasing does not add a commit'
  prefs: []
  type: TYPE_NORMAL
- en: The rebase did not add a commit, and keeps your history clean.
  prefs: []
  type: TYPE_NORMAL
- en: Seeing the rebase at work
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see that your rebase did actually rewind the history of your commits and
    then add each commit back on top of main, go to the command line and issue the
    command `git log --name-only --oneline`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: Rebase rewinds history'
  prefs: []
  type: TYPE_NORMAL
- en: What we see here going from top to bottom is the addition of the final property
    (height) and then we rebase `Person.cs` and add the name property. Next, we rebase
    and add the age property. We continue this all the way back until we've rebased
    all of the files onto the tip of main.
  prefs: []
  type: TYPE_NORMAL
- en: Conflicts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When rebasing we may well run into conflicts. You will remember that we have
    one branch: `Person.` Let''s have a second programmer clone the repository. That
    second programmer is happily working away in their branch (teacher) when they
    realize they need person to have a different age. They add this to the file (okay,
    no one is quite that stupid, but this kind of thing happens in more subtle ways):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.9: Rebasing caused conflicts'
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, Git tells you what to do.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, you can at any time enter `git rebase --abort` and go back to where
    you were before you started the rebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, however, we''ll fix the problem by hand. Open the file pointed to
    `Person.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The part that looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'is the code in the current revision; the next set of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: is coming from the code to be rebased.
  prefs: []
  type: TYPE_NORMAL
- en: Bleh. What a mess. You can fix this by hand, making the adjustments and then
    removing the conflict markers, or you can use a tool as mentioned in the previous
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: To fix this, we'll adjust the age in the branch onto which we rebase the patches;
    i.e. 35 is the authoritative age, therefore the 35 line is the one we want to
    keep, and we want to remove the rest.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, once you have resolved the conflicts, return to the command line
    and enter `git rebase --continue`. This will resume the rebase, checking for other
    conflicts. If there are none, Git will ask you to enter a message and the rebase
    will be completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The key with rebase conflicts is not to panic, but to work your way through
    them one by one. Take heart, had you not done the rebase, you would have run into
    these issues and more when trying to merge into main once you were done with your
    feature branch.
  prefs: []
  type: TYPE_NORMAL
- en: Amending
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you check in a change and then realize you've left out a file or have mangled
    the message, you can use the `amend` command. However, you can only amend the
    most recent commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we return to person and we add a weight property and then commit
    it. Before we push it, we realize we left out a change to `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since the error was in the most recent commit, we can amend that commit. All
    we need to do is put the `Program.cs` file into the index and then issue the command
    `git commit --amend`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because amend rewrites history, **you must do this only before you push** (that
    is, while the commit is only in your local repo), for the same reasons as noted
    above:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.10: Amending (before pushing!)'
  prefs: []
  type: TYPE_NORMAL
- en: Let's take this one line at a time from the top. First we notice that one commit
    is waiting to be pushed. That is the commit we're going to amend.
  prefs: []
  type: TYPE_NORMAL
- en: On the second line, we add the file we want to amend to the index.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add the amend command: `git commit --amend`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git will respond by opening your editor so that you can amend the message (which
    we see here: `add person and in person add weight`).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it tells you all the usual information about the commit.
  prefs: []
  type: TYPE_NORMAL
- en: Notice, however, that you still have only one commit waiting to be pushed. The
    amend did not appear to create a new commit (okay, technically it did, but you
    can safely ignore that).
  prefs: []
  type: TYPE_NORMAL
- en: 'If you use a commit with no file name but with the message flag, you change
    only the message for that most recent commit. You don''t even need the flag; if
    there are no new, modified, or deleted files in the index, it will open your editor
    for you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.11: This will cause your editor to open'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get the history now, with log, you''ll see the amended message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.12: The message amended in the editor'
  prefs: []
  type: TYPE_NORMAL
- en: Amend can save you a lot of work down the road, and it is important to have
    a well-written message to clarify the purpose of the commit.
  prefs: []
  type: TYPE_NORMAL
- en: Cherry-picking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you just need one or a small number of commits from one branch to
    be added to the tip of another branch. A common case is this: you have a release
    branch and a feature branch. The release branch is "frozen" but then you need
    to add a commit from a feature branch to the release branch (possibly a patch
    to fix a problem). When you cherry-pick, the picked commit goes to the tip of
    the branch you are cherry-picking onto.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An illustration will help. Here''s our starting point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.13: Before cherry-picking'
  prefs: []
  type: TYPE_NORMAL
- en: We discover that we do not want all of **Feature1** on **Main**, but we do want
    **Feature1B** (it has the fix or feature set we need). To do this at the command
    line you enter `git cherry-pick a2cb5f3` where `a2cb5f3` is the ID of the feature
    commit you want to cherry-pick.
  prefs: []
  type: TYPE_NORMAL
- en: 'What you end up with looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.14: After the cherry-pick'
  prefs: []
  type: TYPE_NORMAL
- en: Notice that **Feature1B** is now added to the tip of main, but it is also left
    on the feature branch.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio cherry-picking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Visual Studio has terrific support for cherry-picking. Just go to the branch
    you want and then open the history. Right-click on the commit you want and choose
    **Cherry-Pick**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_15.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.15: Cherry-picking in Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: Cherry-picking can be essential when you've branched off your develop branch
    but create something on a feature branch that you realize you need.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we looked at a few advanced topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amending
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cherry-picking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What all three of these have in common is that they all rewrite history. Rebasing
    does so by copying all the commits of one branch onto the tip of another. Amending
    does so by allowing you to add files and/or change the message on a commit. Finally,
    cherry-picking acts like rebasing, but using just one or a few commits.
  prefs: []
  type: TYPE_NORMAL
- en: You saw that many of these activities are easier in Visual Studio but that some
    things you want to do are much clearer at the command line.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explained why you merge *into* main, but you rebase *onto* main.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create a new repository called Panofy, which supplies MP3 music to its subscribers.
    There will be three branches: main, which you get when you create the repo, and
    two feature branches. Demonstrate the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Two programmers creating feature branches
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Frequent rebasing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amending a commit to add a file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Amending a commit to change the message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cherry-picking one commit onto main
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Answer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once again, there are many ways to solve this challenge. Here is how I went
    about it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new repository on GitHub
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen this before, so I''ll do it quickly. I''ll navigate to [GitHub.com](http://GitHub.com)
    and fill in the usual form, making this demo program public:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.16: Creating a new repository'
  prefs: []
  type: TYPE_NORMAL
- en: Once you've created the repository, you and anyone else who wants to develop
    against it (and has the right permissions) can clone it locally.
  prefs: []
  type: TYPE_NORMAL
- en: Creating two feature branches with fake programmers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To do this, I''ll create two directories, and clone to each. My first directory
    I''ll call `GitHub/DirA` and my second `GitHub/DirB`. I will then clone into each:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_17.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.17: Cloning the program to the local repository'
  prefs: []
  type: TYPE_NORMAL
- en: Only Mateo will program in `DirA`, and only Kim will program in `DirB`.
  prefs: []
  type: TYPE_NORMAL
- en: Create a C# program in both `DirA` and `DirB`. Once done, use `git status` to
    ensure they are both pointing to main. To be certain, make a small change in `DirA`
    and make sure it is reflected in `DirB`. It is easy to become confused as to which
    directory your Visual Studio is pointing to. You can always right-click on the
    project and choose **Open folder in File Explorer** to double-check.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps I''ll take to confirm that both directories have the same main branch
    are:'
  prefs: []
  type: TYPE_NORMAL
- en: In branch B I will make a change and push it
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In branch A I will pull the change to make my local repository
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, I will inspect Visual Studio in branch A to prove that it is identical
    to branch B:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17741_05_18.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.18: Cloning to ensure the two repositories are identical'
  prefs: []
  type: TYPE_NORMAL
- en: To keep track of what I'm looking at, I changed the name of the project for
    B to `PanofyB`. I then pushed that and on A I pulled it, so that both stay in
    sync.
  prefs: []
  type: TYPE_NORMAL
- en: This approach is fraught with danger, not least of which is that it is easy
    to overwrite the work of another developer, or to create conflicts. To avoid that,
    I'll create a branch for each programmer. I'll create a branch called `Calculator`
    on A and a branch called `Converter` on B.
  prefs: []
  type: TYPE_NORMAL
- en: Frequent rebasing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have two branches, and to keep this simple, we'll build a new version
    of UtilityKnife, this time with small features and frequent merging. Mateo will
    go first, creating the structure of the calculator, checking it in and you would
    merge it into main (you would not normally do it this way – you would build a
    few aspects of the feature, checking it in frequently, and then when you are done
    merging it, but we need some demo code).
  prefs: []
  type: TYPE_NORMAL
- en: 'When I first add to `Calculator`, main is identical, so when I rebase, essentially
    nothing happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_19.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.19: Rebase early and Rebase often'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a bit of work on `Calculator` and then get ready to push it. Before
    we do, however, let''s do a rebase, in case work was done and pushed to main on
    a different thread:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.20: Pull changes and then get calculator, remembering to rebase onto
    main'
  prefs: []
  type: TYPE_NORMAL
- en: Yes! Even though another thread (in this case converter) is added to main, we
    were able to rebase calculator's code on top of it. We now know that there will
    be no conflicts, at least so far in development.
  prefs: []
  type: TYPE_NORMAL
- en: Amending a commit to add a file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s return to the `Calculator` class. We''ll add a division example using
    doubles, check it in, and commit it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_21.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.21: Using amend to add a file to the most recent commit'
  prefs: []
  type: TYPE_NORMAL
- en: 'After we make the commit, we realize that we intended to add a square root
    method as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We'd rather not create a new commit just for that. What we want to do is amend
    the most recent commit. We do that with the `--amend` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we put the file(s) we want to add into the index and issue the
    `git commit --amend` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_22.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.22: Amending the commit to include the change in Calculator.cs'
  prefs: []
  type: TYPE_NORMAL
- en: 'We take the following steps in the code shown above:'
  prefs: []
  type: TYPE_NORMAL
- en: Call `git status`. Note that we have a modified file, so add it to the index
    with `git add`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Invoke `git commit --amend`, which commits the new code as part of the previous
    commit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The editor will open; put in the new message. Notice that the new message is
    now displayed (second arrow).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This allows us to amend the message to something more meaningful. You'll see
    another way to do this in the chapter on interactive rebasing.
  prefs: []
  type: TYPE_NORMAL
- en: Amending a commit to change the message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If there is nothing new in the index then `git commit --amend` will just give
    you an opportunity to change the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_23.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.23: Using amend to modify the message of the most recent commit'
  prefs: []
  type: TYPE_NORMAL
- en: We do a `git status` to make sure that nothing is in the index. We then call
    `git commit --amend` just as we did before, but we add a message (if we didn't
    add a message our editor would come up). Since there was nothing in the index,
    Git just changes the messages.
  prefs: []
  type: TYPE_NORMAL
- en: Cherry-picking one commit onto main
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here is the log for main and for calculator:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_24.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.24: Cheryy-pick onto main'
  prefs: []
  type: TYPE_NORMAL
- en: We don't want to merge all of calculator into main but we do want to add the
    multiply and divide commits.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, that is silly, but for a real-world example imagine that main is your
    release branch, and calculator has an important function that you want to add.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice the seven-integer ID next to each commit. To cherry-pick `972d77a` into
    main, we make sure main is the current branch and then we issue the cherry-pick
    command with the ID of the commit we want to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_25.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.25: Issuing the cherry-pick command'
  prefs: []
  type: TYPE_NORMAL
- en: 'You have committed `972d77a` into main, and main has one commit to push. Before
    we push let''s look at those logs again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17741_05_26.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.26: Examining the log after the cherry-pick'
  prefs: []
  type: TYPE_NORMAL
- en: 'Three things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: Main now has the add multiply and divide commit
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Multiply and divide have not been removed from calculator
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The ID is different for the two commits, meaning they are separate commits and
    manipulation of one will not affect the other
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example answer meets the requirements of creating two feature branches
    off a new repo, and the "programmers" rebase frequently. We also amended a message
    (while local) and used cherry-picking to copy one commit onto the main branch.
  prefs: []
  type: TYPE_NORMAL
