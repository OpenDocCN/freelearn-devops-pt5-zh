- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Increasing Productivity with Docker Tips and Tricks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter introduces miscellaneous tips, tricks, and concepts that are useful
    when containerizing complex distributed applications or when using Docker to automate
    sophisticated tasks. You will also learn how to leverage containers to run your
    whole development environment in them. Here is the list of topics we are going
    to discuss:'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your Docker environment clean
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a `.``dockerignore` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Executing simple admin tasks in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the resource usage of a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding running a container as `root`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running Docker from within Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Optimizing your build process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scanning for vulnerabilities and secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running your development environment in a container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After reading this chapter, you will have learned how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Successfully restore your Docker environment after it has been messed up completely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a `.dockerignore` file to speed up builds, reduce image size, and enhance
    security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run various tools to perform tasks on your computer without installing them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limit the number of resources a containerized application uses during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Harden your system by not running containers as root
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enable advanced scenarios by running Docker inside of a Docker container
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerate and improve the build process of your custom Docker images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scan your Docker images for common vulnerabilities and exposures and the accidental
    inclusion of secrets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run a whole development environment inside a container running locally or remotely
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, if you want to follow along with the code, you need Docker
    Desktop installed on your local machine as well as the Visual Studio Code editor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let’s create a folder for the samples that we will be using
    during this part of the book. Open a new terminal window and navigate to the folder
    you clone the sample code to. Usually, this is `~/The-Ultimate-Docker-Container-Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a new subfolder for [*Chapter 8*](B19199_08.xhtml#_idTextAnchor174)
    called `ch08` and navigate to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now that you are ready, let’s start with the tips and tricks on how to keep
    our Docker environment clean.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the sample code here: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch08](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch08).'
  prefs: []
  type: TYPE_NORMAL
- en: Keeping your Docker environment clean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we want to learn how we can delete dangling images. A dangling Docker
    image is an unused image that has no association with any tagged images or containers.
    It usually occurs when a new image is built using the same tag as an existing
    image. Instead of removing the old image, Docker preserves it but removes the
    tag reference, leaving the image without a proper tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'Dangling images are not referenced by any container or tagged image, and they
    consume disk space without providing any benefit. They can accumulate over time,
    especially in environments with frequent image builds and updates. Thus, it is
    better to remove them from time to time. Here is the command to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we have added the `-f` (or `--force`) parameter to the `prune`
    command. This is to prevent the CLI from asking you to confirm that you really
    want to delete those superfluous layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Stopped containers can waste precious resources too. If you’re sure that you
    don’t need these containers anymore, then you should remove them. You can remove
    them individually with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also remove them as a batch by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the command for removing them individually, `<container-id|container-name>`
    means that we can either use the container ID or its name to identify the container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unused Docker volumes can also quickly fill up disk space. It is good practice
    to tender your volumes, specifically in a development or **Continuous Integration**
    (**CI**) environment where you create a lot of mostly temporary volumes. But I
    have to warn you, Docker volumes are meant to store data. Often, this data must
    live longer than the life cycle of a container. This is specifically true in a
    production or production-like environment where the data is often mission-critical.
    Hence, be 100% sure of what you’re doing when using the following command to prune
    volumes on your Docker host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: We recommend using this command without the `-f` (or `--force`) flag. It is
    a dangerous and terminal operation and it’s better to give yourself a second chance
    to reconsider your action. Without the flag, the CLI outputs the warning you see
    in the preceding command. You have to explicitly confirm by typing `y` and pressing
    the *Enter* key.
  prefs: []
  type: TYPE_NORMAL
- en: 'On production or production-like systems, you should abstain from the preceding
    command and rather delete unwanted volumes one at a time by using this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: I should also mention that there is a command to prune Docker networks. But
    since we have not yet officially introduced networks, I will defer this to [*Chapter
    10*](B19199_10.xhtml#_idTextAnchor218),*Using* *Single-Host Networking*.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to show how we can exclude some folders and
    files from being included in the build context for a Docker image.
  prefs: []
  type: TYPE_NORMAL
- en: Using a .dockerignore file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `.dockerignore` file is a text file that tells Docker to ignore certain
    files and directories when building a Docker image from a Dockerfile. This is
    similar to how the `.gitignore` file works in Git.
  prefs: []
  type: TYPE_NORMAL
- en: The primary benefit of using a `.dockerignore` file is that it can significantly
    speed up the Docker build process. When Docker builds an image, it first sends
    all of the files in the current directory (known as the “build context”) to the
    Docker daemon. If this directory contains large files or directories that aren’t
    necessary for building the Docker image (such as log files, local environment
    variables, cache files, etc.), these can be ignored to speed up the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, using a `.dockerignore` file can help to improve security and maintain
    clean code practices. For instance, it helps prevent potentially sensitive information
    (such as `.env` files containing private keys) from being included in the Docker
    image. It can also help to keep the Docker image size minimal by avoiding unnecessary
    files, which is particularly beneficial when deploying the image or transferring
    it across networks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example of a .`dockerignore` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, all files are ignored except those in the `my-app/` and `scripts/`
    directories. However, log files within `my-app/` and all files in the `scripts/temp/`
    subdirectory are ignored. This level of granularity provides developers with fine
    control over what is included in the Docker build context.
  prefs: []
  type: TYPE_NORMAL
- en: In conclusion, the use of a `.dockerignore` file is a best practice for Docker
    builds, helping to speed up builds, reduce image size, and enhance security by
    excluding unnecessary or sensitive files from the build context. In the next section,
    we are going to show how to execute simple administrative tasks within a Docker
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Executing simple admin tasks in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we want to provide a few examples of tasks you may want to
    run in a container instead of natively on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Perl script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s assume you need to strip all leading whitespaces from a file and you
    found the following handy Perl script to do exactly that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'As it turns out, you don’t have Perl installed on your working machine. What
    can you do? Install Perl on the machine? Well, that would certainly be an option,
    and it’s exactly what most developers or system admins do. But wait a second,
    you already have Docker installed on your machine. Can’t we use Docker to circumvent
    the need to install Perl? And can’t we do this on any operating system supporting
    Docker? Yes, we can. This is how we’re going to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the chapter’s code folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new subfolder called `simple-task`, and navigate to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open VS Code from within this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this folder, create a `sample.txt` file with the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note the whitespaces at the beginning of each line. Save the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can run a container with Perl installed in it. Thankfully, there is
    an official Perl image on Docker Hub. We are going to use the slim version of
    the image. The primary difference between the normal Perl Docker image and the
    slim version lies in their size and the components included in the images. Both
    images provide the Perl runtime environment, but they are optimized for different
    use cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding command runs a Perl container (`perl:slim`) interactively, maps
    the content of the current folder into the `/usr/src/app` folder of the container,
    and sets the working folder inside the container to `/usr/src/app`. The command
    that is run inside the container is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It basically spawns a Bourne shell and executes our desired Perl command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Analyze the output generated by the preceding command. It should look like
    this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is, all trailing blanks have been removed.
  prefs: []
  type: TYPE_NORMAL
- en: Without needing to install Perl on our machine, we were able to achieve our
    goal. The nice thing is that, after the script has run, the container is removed
    from your system without leaving any traces because we used the `--rm` flag in
    the `docker container run` command, which automatically removes a stopped container.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'If that doesn’t convince you yet because, if you’re on macOS, you already have
    Perl installed, then consider you’re looking into running a Perl script named
    `your-old-perl-script.pl` that is old and not compatible with the newest release
    of Perl that you happen to have installed on your system. Do you try to install
    multiple versions of Perl on your machine and potentially break something? No,
    you just run a container with the (old) version of Perl that is compatible with
    your script, as in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`$ docker container run -it --``rm \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-v $(``pwd):/usr/src/app \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`-w /``usr/src/app \`'
  prefs: []
  type: TYPE_NORMAL
- en: '`perl:<old-version>` `perl your-old-perl-script.p`l'
  prefs: []
  type: TYPE_NORMAL
- en: Here, `<old-version>` corresponds to the tag of the version of Perl that you
    need to run your script.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to demonstrate how to run a Python script.
  prefs: []
  type: TYPE_NORMAL
- en: Running a Python script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lot of people use quick and dirty Python scripts or mini apps to automate
    tasks that are not easily coded with, say, Bash. Now, if the Python script has
    been written in Python 3.x and you only happen to have Python 2.7 installed or
    no version at all on your machine, then the easiest solution is to execute the
    script inside a container. Let’s assume a simple example where the Python script
    counts lines, words, and letters in a given file and outputs the result to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Still in the `simple-task` folder, add a `stats.py` file and add the following
    content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Python script to calculate statistics of a sample text](img/B19199_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Python script to calculate statistics of a sample text
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving the file, you can run it with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Note that, in this example, we are reusing the `sample.txt` file from the previous
    *Running a Perl script* section. The output in my case is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The beauty of this approach is that the Perl script before and this last Python
    script will now run on any computer with any OS installed, as long as the machine
    is a Docker host and hence, can run containers.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to learn how to limit the number of resources a container
    running on the system can consume.
  prefs: []
  type: TYPE_NORMAL
- en: Limiting the resource usage of a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'One of the great features of a container, apart from encapsulating application
    processes, is the possibility of limiting the resources a single container can
    consume at most. This includes CPU and memory consumption. Let’s have a look at
    how limiting the amount of memory (RAM) works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once inside the container, install the `stress` tool, which we will use to
    simulate memory pressure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Open another terminal window and execute the `docker stats` command to observe
    the resource consumption of all running Docker containers. You should see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – The Docker stats showing a resource-limited container](img/B19199_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – The Docker stats showing a resource-limited container
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at `MEM USAGE` and `LIMIT`. Currently, the container uses only `36.57MiB`
    memory and has a limit of `512MiB`. The latter corresponds to what we have configured
    for this container. Now, let’s use the `stress` tool to simulate three workers,
    which will allocate memory using the `malloc()` function in blocks of `256MiB`.
    Run this command inside the container to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command puts stress on the system’s memory by creating three child
    processes that will `malloc()` and touch memory until the system runs out of memory.
    In the terminal running Docker stats, observe how the value for `MEM USAGE` approaches
    but never exceeds `LIMIT`. This is exactly the behavior we expected from Docker.
    Docker uses Linux **cgroups** to enforce those limits.
  prefs: []
  type: TYPE_NORMAL
- en: What are cgroups?
  prefs: []
  type: TYPE_NORMAL
- en: Linux **cgroups**, short for **control groups**, is a kernel-level feature that
    allows you to organize processes into hierarchical groups, and to allocate, restrict,
    and monitor system resources such as CPU, memory, disk I/O, and network among
    these groups. Cgroups provide a way to manage and limit the resource usage of
    processes, ensuring fair distribution and preventing individual processes from
    monopolizing system resources.
  prefs: []
  type: TYPE_NORMAL
- en: We could similarly limit the amount of CPU a container can consume with the
    `--``cpu` switch.
  prefs: []
  type: TYPE_NORMAL
- en: With this operation, engineers can avoid the noisy neighbor problem on a busy
    Docker host, where a single container starves all of the others by consuming an
    excessive amount of resources.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding running a container as root
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications or application services that run inside a container do not
    need `root` access. To tighten security, it is helpful in those scenarios to run
    these processes with minimal necessary privileges. These applications should not
    be run as `root` nor assume that they have `root`-level privileges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, let’s illustrate what we mean with an example. Assume we have a
    file with top-secret content. We want to secure this file on our Unix-based system
    using the `chmod` tool so that only users with `root` permissions can access it.
    Let’s assume I am logged in as `demo` on the dev host and hence my prompt is `demo@dev
    $`. I can use `sudo su` to impersonate a superuser. I have to enter the superuser
    password though:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, as the `root` user, I can create this file called `top-secret.txt` and
    secure it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'If I try to access the file as user `demo`, the following happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'I get a `Permission denied` message, which is what we wanted. No other user
    except `root` can access this file. Now, let’s build a Docker image that contains
    this secured file and when a container is created from it, tries to output the
    content of the `secrets` file. The Dockerfile could look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We can build an image from that Dockerfile (as `root`!) with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, by running a container with the image built in the previous step, we
    get the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will generate this output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so although I am impersonating the `demo` user on the host and running
    the container under this user account, the application running inside the container
    automatically runs as `root`, and hence has full access to protected resources.
    That’s bad, so let’s fix it! Instead of running with the default, we define an
    explicit user inside the container. The modified Dockerfile looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We use the `groupadd` tool to define a new group, `demo-group`, with the ID
    `3000`. Then, we use the `useradd` tool to add a new user, `demo-user`, to this
    group. The user has the ID `4000` inside the container. Finally, with the `USER
    demo-user` statement, we declare that all subsequent operations should be executed
    as `demo-user`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Rebuild the image—again, as `root`—and then try to run a container from it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: And as you can see on the last line, the application running inside the container
    runs with restricted permissions and cannot access resources that need root-level
    access. By the way, what do you think would happen if I ran the container as `root`?
    Try it out!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to show how we can automate Docker from within
    a container.
  prefs: []
  type: TYPE_NORMAL
- en: Running Docker from within Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At times, we may want to run a container hosting an application that automates
    certain Docker tasks. How can we do that? Docker Engine and the Docker CLI are
    installed on the host, yet the application runs inside the container. Well, from
    early on, Docker has provided a means to bind-mount Linux sockets from the host
    into the container. On Linux, sockets are used as very efficient data communications
    endpoints between processes that run on the same host. The Docker CLI uses a socket
    to communicate with Docker Engine; it is often called the **Docker socket**. If
    we can give access to the Docker socket to an application running inside a container,
    then we can just install the Docker CLI inside this container, and we will then
    be able to run an application in the same container that uses this locally installed
    Docker CLI to automate container-specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are not talking about running Docker Engine inside the container but
    rather only the Docker CLI and bind-mounting the Docker socket from the host into
    the container so that the CLI can communicate with Docker Engine running on the
    host computer. This is an important distinction.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running Docker Engine inside a container is generally not recommended due to
    several reasons, including security, stability, and potential performance issues.
    This practice is often referred to as **Docker-in-Docker** or **DinD**. The main
    concerns are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: Running Docker Engine inside a container requires elevated privileges,
    such as running the container in privileged mode or mounting the Docker socket.
    This can expose the host system to potential security risks, as a compromised
    container could gain control over the host’s Docker daemon and escalate privileges,
    affecting other containers and the host itself.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stability**: Containers are designed to be isolated, lightweight, and ephemeral.
    Running Docker Engine inside a container can create complex dependencies and increase
    the chances of conflicts or failures, particularly when managing storage, networking,
    and process namespaces between the host and the nested container environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performance**: Running Docker Engine inside a container can introduce performance
    overhead, as it adds another layer of virtualization, particularly in terms of
    storage and networking. This can lead to increased latency and reduced throughput,
    particularly when managing large numbers of containers or when working with high-performance
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource management**: Docker-in-Docker can make it challenging to manage
    and allocate resources effectively, as nested containers may not inherit resource
    limits and restrictions from their parent container, leading to potential resource
    contention or over-commitment on the host.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To illustrate the concept, let’s look at an example using the preceding technique.
    We are going to use a copy of the `library` component we built in the previous
    chapter ([*Chapter 7*](B19199_07.xhtml#_idTextAnchor150)) for this:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the chapter folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Copy the `library` component from the `ch07` directory to this folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open the component in VS Code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a new file called `pipeline.sh` to the root of the project and add the
    following code to it, which automates the building, testing, and pushing of a
    Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Script to build, test, and push a Java application](img/B19199_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Script to build, test, and push a Java application
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we’re using four environment variables: `$HUB_USER` and `$HUB_PWD`
    being the credentials for Docker Hub, and `$REPOSITORY` and `$TAG` being the name
    and tag of the Docker image we want to build. Eventually, we will have to pass
    values for those environment variables in the `docker container run` command,
    so that they are available for any process running inside the container.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file and make it an executable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want to run the `pipeline.sh` script inside a builder container. Since the
    script uses the Docker CLI, our builder container must have the Docker CLI installed,
    and to access Docker Engine, the builder container must have the Docker socket
    bind-mounted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start creating a Docker image for such a builder container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called `Dockerfile.builder` to the root of the project and add the
    following content to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Dockerfile for the builder](img/B19199_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Dockerfile for the builder
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the long `RUN` command on line 3 onward. This is needed to install Docker
    in the container. For more details about this command, you may want to consult
    the Docker online documentation here: [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Building a Docker image with this Dockerfile is straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We are now ready to try the `builder` command with a real Java application;
    for example, let’s take the sample app we defined in the `ch08/library` folder.
    Make sure you replace `<user>` and `<password>` with your own credentials for
    Docker Hub:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Docker run command for the builder](img/B19199_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Docker run command for the builder
  prefs: []
  type: TYPE_NORMAL
- en: Notice how, in the preceding command, we mounted the Docker socket into the
    container with `-v /var/run/docker.sock:/var/run/docker.sock`. If everything goes
    well, you should have a container image built for the sample application, the
    test should have been run, and the image should have been pushed to Docker Hub.
    This is only one of the many use cases where it is very useful to be able to bind-mount
    the Docker socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'A special notice to those of you who want to try Windows containers on a Windows
    computer: on Docker Desktop for Windows, you can create a similar environment
    by bind-mounting Docker’s **named pipe** instead of a socket. A named pipe on
    Windows is roughly the same as a socket on a Unix- based system. Assuming you’re
    using a PowerShell terminal, the command to bind-mount a named pipe when running
    a Windows container hosting Jenkins looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note the special syntax, `\\.\pipe\docker_engine`, to access Docker’s named
    pipe.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have shown how to run Docker from within Docker by mounting
    the Docker socket into the respective container.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to revisit the topic of how to make your Docker build as
    fast as possible to reduce friction in the development cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Optimizing your build process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Docker build process can and should be optimized. This will remove a lot
    of friction in the software development life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Many Docker beginners make the following mistake when crafting their first
    Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Unoptimized Dockerfile for a Node.js application](img/B19199_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Unoptimized Dockerfile for a Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: Can you spot the weak point in this typical Dockerfile for a Node.js application?
    In[*Chapter 4*](B19199_04.xhtml#_idTextAnchor083), *Creating and Managing Container
    Images*, we learned that an image consists of a series of layers. Each (logical)
    line in a Dockerfile creates a layer, except the lines with the `CMD` and/or `ENTRYPOINT`
    keywords. We also learned that the Docker builder tries to do its best by caching
    layers and reusing them if they have not changed between subsequent builds. But
    the caching only uses cached layers that occur before the first changed layer.
    All subsequent layers need to be rebuilt. That said, the preceding structure of
    the Dockerfile invalidates – or as we often hear said – *busts* the image layer
    cache!
  prefs: []
  type: TYPE_NORMAL
- en: 'Why? Well, from experience, you certainly know that the `npm install` command
    can be a pretty expensive operation in a typical Node.js application with many
    external dependencies. The execution of this command can take from seconds to
    many minutes. That said, each time one of the source files changes, and we know
    that happens frequently during development, line 3 in the Dockerfile causes the
    corresponding image layer to change. Hence, the Docker builder cannot reuse this
    layer from the cache, nor can it reuse the subsequent layer created by `RUN npm
    install`. Any minor change in code causes a complete rerun of `npm install`. That
    can be avoided. The `package.json` file containing the list of external dependencies
    rarely changes. With all of that information, let’s fix the Dockerfile:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Optimized Dockerfile for a Node.js application](img/B19199_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Optimized Dockerfile for a Node.js application
  prefs: []
  type: TYPE_NORMAL
- en: This time, on line 3, we only copy the `package.json` file into the container,
    which rarely changes. Hence, the subsequent `npm install` command has to be executed
    equally rarely. The `COPY` command on line 5 is then a very fast operation and
    hence rebuilding an image after some code has changed only needs to rebuild this
    last layer. Build times reduce to merely a fraction of a second.
  prefs: []
  type: TYPE_NORMAL
- en: The very same principle applies to most languages or frameworks, such as Python,
    .NET, or Java. Avoid busting your image layer cache!
  prefs: []
  type: TYPE_NORMAL
- en: Scanning for vulnerabilities and secrets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What exactly are vulnerabilities, or to be more accurate, **Common Vulnerabilities
    and** **Exposures** (**CVE**)?
  prefs: []
  type: TYPE_NORMAL
- en: A database of information security problems that have been made publicly known
    is called **Common Vulnerabilities and Exposures**. A number uniquely identifies
    each vulnerability from the list of all other entries in the database. This list
    is continuously reviewed and updated by experts who include any new vulnerabilities
    or exposures as soon as they are found.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can scan the various layers of our Docker images using specialist software,
    such as Snyk, to find software libraries that are known to have such CVE. If we
    find that our image is flawed, we should and can repair the issue by switching
    to a more recent version of the flawed library. The image will then need to be
    rebuilt.
  prefs: []
  type: TYPE_NORMAL
- en: But our work is not yet done. Security experts frequently find new CVE, as was
    already mentioned previously. As a result, a software library that was previously
    secure may suddenly be vulnerable as a result of newly revealed CVE.
  prefs: []
  type: TYPE_NORMAL
- en: This means that we must ensure that all of our active Docker images are routinely
    inspected, notify our developers and security experts about the issue, and take
    other steps to ensure a speedy resolution of the issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few ways to scan a Docker image for vulnerabilities and secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: Use a vulnerability scanner such as Clair, Anchore, or Trivy. These tools can
    scan a Docker image and check it against a database of known vulnerabilities in
    order to identify any potential security risks.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a tool such as Aquasec or Sysdig to scan the image for secrets. These tools
    can detect and alert on sensitive information such as private keys, passwords,
    and other sensitive data that may have been accidentally committed to the image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a combination of both tools, for example, Docker Bench for Security, which
    checks for dozens of common best practices around deploying Docker containers
    in production.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a tool such as OpenSCAP, which can perform vulnerability scans, security
    configuration assessments, and compliance checks on a Docker image.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s important to note that it’s always good practice to keep your images updated
    and only use official and trusted images.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will investigate how we can discover vulnerabilities
    inside our Docker images.
  prefs: []
  type: TYPE_NORMAL
- en: Using Snyk to scan a Docker image
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Snyk is a security platform that can be used to scan Docker images for vulnerabilities.
    Here is an example of how to use Snyk to scan a Docker image for vulnerabilities:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we have to install the Snyk CLI on our machine. We can do this by running
    the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once Snyk is installed, we can authenticate with our Snyk account by running
    the following command and following the prompts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can run the following command to scan a specific Docker image for
    vulnerabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding command will perform a vulnerability scan on the specified Docker
    image and print the results in the console. The results will show the number of
    vulnerabilities found, the severity of each vulnerability, and the package and
    version that is affected.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use the `--file` flag to scan a Dockerfile instead of a built image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Additionally, we can also use the `--org` flag to specify an organization,
    if we’re a member of multiple organizations:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can use the `--fix` flag to automatically fix the vulnerabilities
    found by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please note that this feature is only available for images that are built using
    a Dockerfile and it will update the Dockerfile with the new package versions,
    and you will need to rebuild the image to take advantage of the fix.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Snyk free plan is limited to a certain number of scans, and it does not
    include the *Protect* feature. You will have to upgrade to a paid plan to have
    access to this feature.
  prefs: []
  type: TYPE_NORMAL
- en: Using docker scan to scan a Docker image for vulnerabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are once again going to use Snyk to scan a Docker image
    for vulnerabilities. Snyk should be included with your Docker Desktop installation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check by using this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output should look similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s try to scan a sample `whoami` application from the author’s Docker Hub
    account. First, make sure you have the `whoami` image in your local cache:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Scan the image for vulnerabilities:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You will be asked the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Please answer this with `y`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The result of the preceding scan looks like this on my computer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – Scanning the gnschenker/whoami:1.0 Docker image](img/B19199_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – Scanning the gnschenker/whoami:1.0 Docker image
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, there were three vulnerabilities found in this version of the
    image: one of *medium*, one of *high*, and one of *critical* severity. It is clear
    that we should address critical vulnerabilities as soon as possible. Let’s do
    this now:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we copy over the original `whoami` project including the Dockerfile we
    used to build this image. You can find the copy in your `~/``The-Ultimate-Docker-Container-Book/sample-solutions/``ch14`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Dockerfile and inspect it. We used version `6.0-alpine` for both the
    .NET SDK and the runtime. Let’s see whether Microsoft has updated the vulnerabilities
    in this version already.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to your `…/``ch08/whoami` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Build a new version of the Docker image with this command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note, you may want to replace `gnschenker` with your own Docker account name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Scan the new image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This time, the output should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Scanning the rebuilt whoami Docker image](img/B19199_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Scanning the rebuilt whoami Docker image
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, this time, the image is free from any vulnerabilities. We should
    now instruct our DevOps to use this new version of the image. We can use a rolling
    update in production and should be just fine, as the application itself did not
    change.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to learn how to run a complete development
    environment inside a container.
  prefs: []
  type: TYPE_NORMAL
- en: Running your development environment in a container
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine that you only have access to a workstation with Docker Desktop installed,
    but no possibility to add or change anything else on this workstation. Now you
    want to do some proofs of concept and code some sample applications using Java.
    Unfortunately, Java and SpringBoot are not installed on your computer. What can
    you do? What if you could run a whole development environment inside a container,
    including a code editor and debugger? What if, at the same time, you could still
    have your code files on your host machine?
  prefs: []
  type: TYPE_NORMAL
- en: Containers are awesome, and genius engineers have come up with solutions for
    exactly this kind of problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Microsoft and the community are continuously updating VS Code and the plugins.
    Thus your version of VS Code may be newer than the one used during the writing
    of this book. As such, expect a slightly different experience. Refer to the official
    documentation for more details on how to work with Dev containers: [https://code.visualstudio.com/docs/devcontainers/containers](https://code.visualstudio.com/docs/devcontainers/containers).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using Visual Studio Code, our favorite code editor, to show how
    to run a complete Java development environment inside a container:'
  prefs: []
  type: TYPE_NORMAL
- en: 'But first, we need to install the necessary VS Code extension. Open VS Code
    and install the extension called **Remote Development**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Adding the Remote Development extension to VS Code](img/B19199_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Adding the Remote Development extension to VS Code
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, click the green quick actions status bar item in the lower-left of the
    Visual Studio Code window. In the popup, select **Remote-Containers** | **Open
    Folder** **in Container...**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Open Folder in Container](img/B19199_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Open Folder in Container
  prefs: []
  type: TYPE_NORMAL
- en: Select the project folder you want to work with in the container. In our case,
    we selected the `~/``The-Ultimate-Docker-Container-Book/ch08/library` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A popup will appear asking you to define how you want to create the development
    container. From the list, select **From ‘Dockerfile’**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Selecting the method to create the development container](img/B19199_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Selecting the method to create the development container
  prefs: []
  type: TYPE_NORMAL
- en: When asked to add additional features to install, just click **OK** to continue.
    At this time, we do not need anything special.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: VS Code will now start preparing the environment, which, the very first time,
    can take a couple of minutes or so.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the environment is ready, you should notice that in the lower-left corner,
    the prompt has changed to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This indicates that VS Code has indeed run a container based on the Dockerfile
    found in the library folder and is allowing you to work within it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will be asked to install the extension pack for Java since VS Code has
    recognized that this is a Java project. Click `dev` container and only the UI
    is still running on your laptop. Thus, the extension pack will be installed for
    the engine inside the container. You will notice this when you open the **EXTENSIONS**
    panel and find a list of remote extensions under **DEV CONTAINER**. In our case,
    by installing the Java extensions pack, we now have the following eight remote
    extensions installed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Remote extensions installed on the dev container](img/B19199_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Remote extensions installed on the dev container
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a Terminal inside VS Code with *Shift* + *Ctrl* + *‘* and notice the prompt
    revealing that the terminal session is ins[ide the `dev` container and that we
    are *not* runni](mailto:root@c96b82891be7:/workspaces/.../ch08/library)ng directly
    on our Docker host:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that for readability, we have shortened the preceding prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Now, try to run the Java application by locating the `main` method in the `LibraryApplication`
    class and clicking the **Run** link just above the method. The application should
    start as normal, but notice that our context is inside the dev container and not
    directly on our working machine.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Alternatively, we could have started the application from the command line
    with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, add a file called `DefaultController.java` to the `controllers` folder
    and give it this content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.14 – Adding a default controller while working inside the dev container](img/B19199_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – Adding a default controller whil[e working inside the](http://localhost:8080)
    dev container
  prefs: []
  type: TYPE_NORMAL
- en: Restart the application and open a browser as `http://localhost:8080`. The message
    `Library component` should be displayed as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When done experimenting, click on the green area in the lower-left corner of
    VS Code and select **Open folder locally** from the pop-up menu to quit the dev
    container and open the project locally.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Observe that a new folder, `.devcontainer`, has been added to the project containing
    a `devcontainer.json` file. This file contains the configuration needed to run
    a dev container from this project. Please read the documentation of VS Code to
    familiarize yourself with the possibilities this file offers to you.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: These have been a few tips and tricks for pros that are useful in the day-to-day
    usage of containers. There are many more. Google them. It is worth it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we presented miscellaneous tips, tricks, and concepts that
    are useful when containerizing complex distributed applications or when using
    Docker to automate sophisticated tasks. We also learned how to leverage containers
    to run a whole development environment inside of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concept of a distributed application
    architecture and discuss the various patterns and best practices that are required
    to run a distributed application successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are a few questions you should try to answer to assess your progress:'
  prefs: []
  type: TYPE_NORMAL
- en: Name the reasons why you would want to run a complete development environment
    inside a container.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why should you avoid running applications inside a container as `root`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you ever bind-mount the Docker socket into a container?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When pruning your Docker resources to make space, why do you need to handle
    volumes with special care?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Why would you want to run certain admin tasks inside a Docker container and
    not natively on the host machine?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here are sample answers for the questions in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: You could be working on a workstation with limited resources or capabilities,
    or your workstation could be locked down by your company so that you are not allowed
    to install any software that is not officially approved. Sometimes, you might
    need to do proofs of concept or experiments using languages or frameworks that
    are not yet approved by your company (but might be in the future if the proof
    of concept is successful).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bind-mounting a Docker socket into a container is the recommended method when
    a containerized application needs to automate some container-related tasks. This
    can be an application such as an automation server (such as Jenkins) that you
    are using to build, test, and deploy Docker images.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most business applications do not need `root`-level authorizations to do their
    job. From a security perspective, it is therefore strongly recommended to run
    such applications with the least necessary access rights to their job. Any unnecessary
    elevated privileges could possibly be exploited by hackers in a malicious attack.
    By running the application as a non-`root` user, you make it more difficult for
    potential hackers to compromise your system.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Volumes contain data and the lifespan of data most often needs to go far beyond
    the life cycle of a container, or an application, for that matter. Data is often
    mission-critical and needs to be stored safely for days, months, or even years.
    When you delete a volume, you irreversibly delete the data associated with it.
    Hence, make sure you know what you’re doing when deleting a volume.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'There are several reasons why you might want to run certain admin tasks inside
    a Docker container, rather than natively on the host machine:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Isolation**: Containers provide a level of isolation from the host machine,
    so running admin tasks inside a container can help to prevent conflicts with other
    processes or dependencies on the host machine.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Containers are designed to be lightweight and portable, which
    allows for easy deployment of admin tasks across different environments. This
    can be particularly useful for tasks that need to be run in multiple environments
    or on multiple machines.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consistency**: Containers provide a consistent environment for running admin
    tasks, regardless of the underlying host machine’s configuration. This can be
    useful for ensuring that tasks are run in a predictable and repeatable manner,
    which can help to minimize errors and improve efficiency.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: Containers allow for easy versioning of admin tasks, which
    allows for rollbacks and roll forward of the tasks. This can be useful for testing,
    troubleshooting, and production environments.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: Running admin tasks inside a container can help to improve security
    by isolating the task from the host machine, and by making it easier to limit
    the permissions and access that the task has.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: Containers can be easily scaled up and down, allowing you
    to increase or decrease the resources that the admin task needs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Please note that this is not a comprehensive list and different use cases may
    require different approaches. It’s important to weigh the pros and cons of running
    admin tasks inside a container versus natively on the host machine and to choose
    the approach that best fits your particular use case.
  prefs: []
  type: TYPE_NORMAL
- en: Part 3:Orchestration Fundamentals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By the end of *Part 3*, you will be familiar with the concepts of a Dockerized
    distributed application and container orchestrators, and be able to use Docker
    Swarm to deploy and run your applications.
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19199_09.xhtml#_idTextAnchor194), *Learning about* *Distributed
    Application Architecture*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using Singl**e-H**ost Networking*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B19199_11.xhtml#_idTextAnchor237), *Managing Containers with
    Docker Compose*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 12*](B19199_12.xhtml#_idTextAnchor251), *Shipping Logs and Monitoring
    Containers*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 13*](B19199_13.xhtml#_idTextAnchor276), *Introducing Container Orchestration*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 14*](B19199_14.xhtml#_idTextAnchor303),*Introducing Introducing*
    *Docker Swarm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 15*](B19199_15.xhtml#_idTextAnchor328), *Deploying and Running a
    Distributed Application on Docker Swarm*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
