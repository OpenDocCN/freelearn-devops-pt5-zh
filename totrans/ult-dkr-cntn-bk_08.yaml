- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Increasing Productivity with Docker Tips and Tricks
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提高生产力的 Docker 技巧与窍门
- en: 'This chapter introduces miscellaneous tips, tricks, and concepts that are useful
    when containerizing complex distributed applications or when using Docker to automate
    sophisticated tasks. You will also learn how to leverage containers to run your
    whole development environment in them. Here is the list of topics we are going
    to discuss:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了在容器化复杂分布式应用程序或使用 Docker 自动化复杂任务时有用的各种技巧、窍门和概念。你还将学习如何利用容器运行整个开发环境。以下是我们将要讨论的主题列表：
- en: Keeping your Docker environment clean
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持 Docker 环境的整洁
- en: Using a `.``dockerignore` file
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.dockerignore` 文件
- en: Executing simple admin tasks in a container
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中执行简单的管理员任务
- en: Limiting the resource usage of a container
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器的资源使用
- en: Avoiding running a container as `root`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免以 `root` 用户身份运行容器
- en: Running Docker from within Docker
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Docker 内部运行 Docker
- en: Optimizing your build process
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化构建过程
- en: Scanning for vulnerabilities and secrets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描漏洞和密钥
- en: Running your development environment in a container
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在容器中运行开发环境
- en: 'After reading this chapter, you will have learned how to do the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，你将学会如何完成以下操作：
- en: Successfully restore your Docker environment after it has been messed up completely
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成功地恢复被彻底破坏的 Docker 环境
- en: Use a `.dockerignore` file to speed up builds, reduce image size, and enhance
    security
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `.dockerignore` 文件来加速构建，减少镜像大小并增强安全性
- en: Run various tools to perform tasks on your computer without installing them
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行各种工具以执行计算机上的任务，无需安装它们
- en: Limit the number of resources a containerized application uses during runtime
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制容器化应用程序在运行时使用的资源数量
- en: Harden your system by not running containers as root
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过避免以 root 用户身份运行容器来加固系统
- en: Enable advanced scenarios by running Docker inside of a Docker container
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在 Docker 容器内运行 Docker，启用高级场景
- en: Accelerate and improve the build process of your custom Docker images
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加速并改进自定义 Docker 镜像的构建过程
- en: Scan your Docker images for common vulnerabilities and exposures and the accidental
    inclusion of secrets
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扫描你的 Docker 镜像，查找常见的漏洞、暴露点以及不小心包含的密钥
- en: Run a whole development environment inside a container running locally or remotely
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在本地或远程运行的容器中运行完整的开发环境
- en: Let’s get started!
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Technical requirements
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: In this chapter, if you want to follow along with the code, you need Docker
    Desktop installed on your local machine as well as the Visual Studio Code editor.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，如果你想跟着代码一起操作，你需要在本地机器上安装 Docker Desktop 和 Visual Studio Code 编辑器。
- en: 'Before we start, let’s create a folder for the samples that we will be using
    during this part of the book. Open a new terminal window and navigate to the folder
    you clone the sample code to. Usually, this is `~/The-Ultimate-Docker-Container-Book`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们先创建一个文件夹，用于存放在本书这部分内容中将要使用的示例文件。打开一个新的终端窗口，并导航到你克隆示例代码的文件夹。通常，该文件夹是
    `~/The-Ultimate-Docker-Container-Book`：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new subfolder for [*Chapter 8*](B19199_08.xhtml#_idTextAnchor174)
    called `ch08` and navigate to it:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `ch08` 的新子文件夹，并进入该文件夹：[ *第 8 章* ](B19199_08.xhtml#_idTextAnchor174)：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that you are ready, let’s start with the tips and tricks on how to keep
    our Docker environment clean.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经准备好了，我们开始介绍如何保持 Docker 环境整洁的技巧与窍门。
- en: 'You can find the sample code here: [https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch08](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch08).'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此找到示例代码：[https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch08](https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book/tree/main/sample-solutions/ch08)。
- en: Keeping your Docker environment clean
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保持 Docker 环境的整洁
- en: First, we want to learn how we can delete dangling images. A dangling Docker
    image is an unused image that has no association with any tagged images or containers.
    It usually occurs when a new image is built using the same tag as an existing
    image. Instead of removing the old image, Docker preserves it but removes the
    tag reference, leaving the image without a proper tag.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们要学习如何删除悬挂镜像。悬挂的 Docker 镜像是指没有与任何标签镜像或容器关联的未使用镜像。它通常发生在使用与现有镜像相同标签构建新镜像时。Docker
    会保留旧镜像而不是删除它，但会移除标签引用，从而使镜像没有正确的标签。
- en: 'Dangling images are not referenced by any container or tagged image, and they
    consume disk space without providing any benefit. They can accumulate over time,
    especially in environments with frequent image builds and updates. Thus, it is
    better to remove them from time to time. Here is the command to do so:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 悬空镜像（Dangling images）是指没有被任何容器或标签镜像引用的镜像，它们占用磁盘空间却没有提供任何好处。特别是在频繁构建和更新镜像的环境中，悬空镜像会随着时间积累。因此，最好定期删除它们。以下是执行此操作的命令：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Please note that we have added the `-f` (or `--force`) parameter to the `prune`
    command. This is to prevent the CLI from asking you to confirm that you really
    want to delete those superfluous layers.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们在 `prune` 命令中添加了 `-f`（或 `--force`）参数。这是为了防止 CLI 在执行时询问你是否确定删除那些多余的层。
- en: 'Stopped containers can waste precious resources too. If you’re sure that you
    don’t need these containers anymore, then you should remove them. You can remove
    them individually with the following command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 停止的容器也可能浪费宝贵的资源。如果你确定这些容器不再需要，应该将它们删除。你可以使用以下命令单独删除它们：
- en: '[PRE3]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You can also remove them as a batch by using this command:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过使用以下命令批量删除它们：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the command for removing them individually, `<container-id|container-name>`
    means that we can either use the container ID or its name to identify the container.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在删除容器时的命令中，`<container-id|container-name>` 表示我们可以使用容器的ID或名称来标识该容器。
- en: 'Unused Docker volumes can also quickly fill up disk space. It is good practice
    to tender your volumes, specifically in a development or **Continuous Integration**
    (**CI**) environment where you create a lot of mostly temporary volumes. But I
    have to warn you, Docker volumes are meant to store data. Often, this data must
    live longer than the life cycle of a container. This is specifically true in a
    production or production-like environment where the data is often mission-critical.
    Hence, be 100% sure of what you’re doing when using the following command to prune
    volumes on your Docker host:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 未使用的 Docker 卷也可能很快占满磁盘空间。在开发环境或 **持续集成**（**CI**）环境中，创建大量大多是临时的卷时，养成清理卷的好习惯非常重要。但我必须警告你，Docker
    卷用于存储数据，通常这些数据需要比容器的生命周期更长。特别是在生产或类似生产的环境中，这些数据往往至关重要。因此，使用以下命令清理 Docker 主机上的卷时，请确保自己100%确信操作是正确的：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We recommend using this command without the `-f` (or `--force`) flag. It is
    a dangerous and terminal operation and it’s better to give yourself a second chance
    to reconsider your action. Without the flag, the CLI outputs the warning you see
    in the preceding command. You have to explicitly confirm by typing `y` and pressing
    the *Enter* key.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们建议使用没有 `-f`（或 `--force`）标志的命令。这个标志是一个危险且终极的操作，最好给自己一个重新考虑的机会。如果没有该标志，CLI会输出你在前一个命令中看到的警告。你必须明确确认，输入
    `y` 然后按下 *Enter* 键。
- en: 'On production or production-like systems, you should abstain from the preceding
    command and rather delete unwanted volumes one at a time by using this command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产或类似生产的系统中，你应该避免使用前面的命令，而是通过以下命令逐一删除不需要的卷：
- en: '[PRE6]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: I should also mention that there is a command to prune Docker networks. But
    since we have not yet officially introduced networks, I will defer this to [*Chapter
    10*](B19199_10.xhtml#_idTextAnchor218),*Using* *Single-Host Networking*.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我还应该提到，有一个命令可以清理 Docker 网络。但由于我们尚未正式介绍网络功能，因此我将在 [*第10章*](B19199_10.xhtml#_idTextAnchor218)中讲解，*使用*
    *单主机网络*。
- en: In the next section, we are going to show how we can exclude some folders and
    files from being included in the build context for a Docker image.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将展示如何排除一些文件夹和文件，使其不包含在 Docker 镜像的构建上下文中。
- en: Using a .dockerignore file
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `.dockerignore` 文件
- en: The `.dockerignore` file is a text file that tells Docker to ignore certain
    files and directories when building a Docker image from a Dockerfile. This is
    similar to how the `.gitignore` file works in Git.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`.dockerignore` 文件是一个文本文件，告诉 Docker 在从 Dockerfile 构建 Docker 镜像时忽略某些文件和目录。这类似于
    Git 中的 `.gitignore` 文件。'
- en: The primary benefit of using a `.dockerignore` file is that it can significantly
    speed up the Docker build process. When Docker builds an image, it first sends
    all of the files in the current directory (known as the “build context”) to the
    Docker daemon. If this directory contains large files or directories that aren’t
    necessary for building the Docker image (such as log files, local environment
    variables, cache files, etc.), these can be ignored to speed up the build process.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `.dockerignore` 文件的主要好处是它可以显著加速 Docker 构建过程。当 Docker 构建一个镜像时，它首先将当前目录中的所有文件（即“构建上下文”）发送到
    Docker 守护进程。如果该目录包含不必要的巨大文件或文件夹（如日志文件、本地环境变量、缓存文件等），这些文件可以被忽略，从而加速构建过程。
- en: Moreover, using a `.dockerignore` file can help to improve security and maintain
    clean code practices. For instance, it helps prevent potentially sensitive information
    (such as `.env` files containing private keys) from being included in the Docker
    image. It can also help to keep the Docker image size minimal by avoiding unnecessary
    files, which is particularly beneficial when deploying the image or transferring
    it across networks.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，使用 `.dockerignore` 文件有助于提高安全性并保持干净的代码实践。例如，它可以防止可能包含敏感信息的文件（如包含私钥的 `.env`
    文件）被包含在 Docker 镜像中。它还可以通过避免不必要的文件来保持 Docker 镜像的最小化大小，这在部署镜像或跨网络传输时尤其有利。
- en: 'Here’s an example of a .`dockerignore` file:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `.dockerignore` 文件的示例：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In this example, all files are ignored except those in the `my-app/` and `scripts/`
    directories. However, log files within `my-app/` and all files in the `scripts/temp/`
    subdirectory are ignored. This level of granularity provides developers with fine
    control over what is included in the Docker build context.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，除了 `my-app/` 和 `scripts/` 目录中的文件外，其他所有文件都被忽略。然而，`my-app/` 目录中的日志文件和 `scripts/temp/`
    子目录中的所有文件都被忽略。这种粒度的控制为开发者提供了对 Docker 构建上下文中包含内容的精细控制。
- en: In conclusion, the use of a `.dockerignore` file is a best practice for Docker
    builds, helping to speed up builds, reduce image size, and enhance security by
    excluding unnecessary or sensitive files from the build context. In the next section,
    we are going to show how to execute simple administrative tasks within a Docker
    container.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，使用 `.dockerignore` 文件是 Docker 构建的最佳实践，它可以加速构建、减小镜像大小，并通过排除不必要或敏感的文件来提高安全性。在下一节中，我们将展示如何在
    Docker 容器内执行简单的管理任务。
- en: Executing simple admin tasks in a container
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内执行简单的管理任务
- en: In this section, we want to provide a few examples of tasks you may want to
    run in a container instead of natively on your computer.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将提供一些示例，展示你可能希望在容器内而不是在本地计算机上执行的任务。
- en: Running a Perl script
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Perl 脚本
- en: 'Let’s assume you need to strip all leading whitespaces from a file and you
    found the following handy Perl script to do exactly that:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要从一个文件中去除所有前导空格，你找到以下这个非常实用的 Perl 脚本来完成这个任务：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'As it turns out, you don’t have Perl installed on your working machine. What
    can you do? Install Perl on the machine? Well, that would certainly be an option,
    and it’s exactly what most developers or system admins do. But wait a second,
    you already have Docker installed on your machine. Can’t we use Docker to circumvent
    the need to install Perl? And can’t we do this on any operating system supporting
    Docker? Yes, we can. This is how we’re going to do it:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，你的工作机器上没有安装 Perl。你该怎么办？安装 Perl 吗？嗯，这当然是一个选择，实际上大多数开发者或系统管理员都会这么做。但等一下，你的机器上已经安装了
    Docker。我们不能利用 Docker 来避免安装 Perl 吗？而且我们能在任何支持 Docker 的操作系统上做到这一点吗？没错，我们可以。接下来就是这样做的：
- en: 'Navigate to the chapter’s code folder:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入章节的代码文件夹：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create a new subfolder called `simple-task`, and navigate to it:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `simple-task` 的新子文件夹，并进入该文件夹：
- en: '[PRE10]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open VS Code from within this folder:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从该文件夹中打开 VS Code：
- en: '[PRE11]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In this folder, create a `sample.txt` file with the following content:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件夹中，创建一个名为 `sample.txt` 的文件，并添加以下内容：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Please note the whitespaces at the beginning of each line. Save the file.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意每行开头的空格。保存文件。
- en: 'Now, we can run a container with Perl installed in it. Thankfully, there is
    an official Perl image on Docker Hub. We are going to use the slim version of
    the image. The primary difference between the normal Perl Docker image and the
    slim version lies in their size and the components included in the images. Both
    images provide the Perl runtime environment, but they are optimized for different
    use cases:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以运行一个已安装 Perl 的容器。幸运的是，Docker Hub 上有一个官方的 Perl 镜像。我们将使用该镜像的 slim 版本。正常的
    Perl Docker 镜像与 slim 版本的主要区别在于它们的大小和镜像中包含的组件。两个镜像都提供 Perl 运行环境，但它们针对不同的使用场景进行了优化：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The preceding command runs a Perl container (`perl:slim`) interactively, maps
    the content of the current folder into the `/usr/src/app` folder of the container,
    and sets the working folder inside the container to `/usr/src/app`. The command
    that is run inside the container is as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 前述命令交互式地运行一个 Perl 容器（`perl:slim`），将当前文件夹的内容映射到容器的 `/usr/src/app` 文件夹，并将容器内部的工作目录设置为
    `/usr/src/app`。在容器内执行的命令如下：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: It basically spawns a Bourne shell and executes our desired Perl command.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 它基本上启动一个 Bourne shell 并执行我们所需的 Perl 命令。
- en: 'Analyze the output generated by the preceding command. It should look like
    this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析前述命令生成的输出。它应该如下所示：
- en: '[PRE15]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That is, all trailing blanks have been removed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，所有尾随空格已被删除。
- en: Without needing to install Perl on our machine, we were able to achieve our
    goal. The nice thing is that, after the script has run, the container is removed
    from your system without leaving any traces because we used the `--rm` flag in
    the `docker container run` command, which automatically removes a stopped container.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们无需在机器上安装 Perl，就能够实现我们的目标。好的一点是，脚本运行完后，容器会从系统中被移除，不会留下任何痕迹，因为我们在 `docker container
    run` 命令中使用了 `--rm` 标志，这会自动删除已停止的容器。
- en: Tip
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: 'If that doesn’t convince you yet because, if you’re on macOS, you already have
    Perl installed, then consider you’re looking into running a Perl script named
    `your-old-perl-script.pl` that is old and not compatible with the newest release
    of Perl that you happen to have installed on your system. Do you try to install
    multiple versions of Perl on your machine and potentially break something? No,
    you just run a container with the (old) version of Perl that is compatible with
    your script, as in this example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这还不能说服你，因为如果你在 macOS 上，你已经安装了 Perl，那么考虑一下你正在运行一个名为 `your-old-perl-script.pl`
    的 Perl 脚本，这个脚本是旧版的，并且与你系统上安装的最新版本的 Perl 不兼容。你会尝试在机器上安装多个版本的 Perl 并可能破坏某些东西吗？不，你只需运行一个容器，容器中包含与脚本兼容的（旧版）Perl，如下所示：
- en: '`$ docker container run -it --``rm \`'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`$ docker container run -it --``rm \`'
- en: '`-v $(``pwd):/usr/src/app \`'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`-v $(``pwd):/usr/src/app \`'
- en: '`-w /``usr/src/app \`'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`-w /``usr/src/app \`'
- en: '`perl:<old-version>` `perl your-old-perl-script.p`l'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`perl:<old-version>` `perl your-old-perl-script.p`l'
- en: Here, `<old-version>` corresponds to the tag of the version of Perl that you
    need to run your script.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<old-version>` 对应于你需要运行脚本的 Perl 版本标签。
- en: In the next section, we are going to demonstrate how to run a Python script.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将演示如何运行 Python 脚本。
- en: Running a Python script
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运行 Python 脚本
- en: 'A lot of people use quick and dirty Python scripts or mini apps to automate
    tasks that are not easily coded with, say, Bash. Now, if the Python script has
    been written in Python 3.x and you only happen to have Python 2.7 installed or
    no version at all on your machine, then the easiest solution is to execute the
    script inside a container. Let’s assume a simple example where the Python script
    counts lines, words, and letters in a given file and outputs the result to the
    console:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 很多人使用快速且粗糙的 Python 脚本或小型应用程序来自动化一些用 Bash 等语言不易编码的任务。如果 Python 脚本是用 Python 3.x
    编写的，而你机器上仅安装了 Python 2.7 或根本没有安装任何版本，那么最简单的解决方法就是在容器中执行该脚本。假设有一个简单的例子，Python 脚本用于计算给定文件中的行数、单词数和字母数，并将结果输出到控制台：
- en: 'Still in the `simple-task` folder, add a `stats.py` file and add the following
    content:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `simple-task` 文件夹中，添加一个 `stats.py` 文件，并添加以下内容：
- en: '![Figure 8.1 – Python script to calculate statistics of a sample text](img/B19199_08_01.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 用于计算示例文本统计数据的 Python 脚本](img/B19199_08_01.jpg)'
- en: Figure 8.1 – Python script to calculate statistics of a sample text
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 用于计算示例文本统计数据的 Python 脚本
- en: 'After saving the file, you can run it with the following command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件后，你可以使用以下命令运行它：
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Note that, in this example, we are reusing the `sample.txt` file from the previous
    *Running a Perl script* section. The output in my case is as follows:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请注意，在此示例中，我们正在重用之前 *运行 Perl 脚本* 部分中的 `sample.txt` 文件。在我的例子中，输出如下：
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The beauty of this approach is that the Perl script before and this last Python
    script will now run on any computer with any OS installed, as long as the machine
    is a Docker host and hence, can run containers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点是，之前的 Perl 脚本和最后的 Python 脚本现在可以在任何安装了操作系统的计算机上运行，只要该机器是 Docker 主机，并且能够运行容器。
- en: Next, we are going to learn how to limit the number of resources a container
    running on the system can consume.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将学习如何限制系统上运行的容器可以消耗的资源数量。
- en: Limiting the resource usage of a container
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 限制容器的资源使用
- en: 'One of the great features of a container, apart from encapsulating application
    processes, is the possibility of limiting the resources a single container can
    consume at most. This includes CPU and memory consumption. Let’s have a look at
    how limiting the amount of memory (RAM) works:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 容器的一个重要特性，除了封装应用程序进程外，还包括限制单个容器最多可以消耗的资源量。这包括 CPU 和内存消耗。让我们来看看如何限制内存（RAM）使用量：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once inside the container, install the `stress` tool, which we will use to
    simulate memory pressure:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 进入容器后，安装 `stress` 工具，我们将用它来模拟内存压力：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open another terminal window and execute the `docker stats` command to observe
    the resource consumption of all running Docker containers. You should see something
    like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打开另一个终端窗口，执行 `docker stats` 命令，观察所有正在运行的 Docker 容器的资源消耗。你应该会看到如下内容：
- en: '![Figure 8.2 – The Docker stats showing a resource-limited container](img/B19199_08_02.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.2 – 显示资源受限容器的 Docker stats](img/B19199_08_02.jpg)'
- en: Figure 8.2 – The Docker stats showing a resource-limited container
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2 – 显示资源受限容器的 Docker stats
- en: 'Look at `MEM USAGE` and `LIMIT`. Currently, the container uses only `36.57MiB`
    memory and has a limit of `512MiB`. The latter corresponds to what we have configured
    for this container. Now, let’s use the `stress` tool to simulate three workers,
    which will allocate memory using the `malloc()` function in blocks of `256MiB`.
    Run this command inside the container to do so:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 查看 `MEM USAGE` 和 `LIMIT`。目前，容器仅使用了 `36.57MiB` 的内存，并且限制为 `512MiB`。后者对应我们为该容器配置的内存限制。现在，让我们使用
    `stress` 工具来模拟三个工人，它们将使用 `malloc()` 函数按 `256MiB` 的块分配内存。在容器内运行以下命令：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding command puts stress on the system’s memory by creating three child
    processes that will `malloc()` and touch memory until the system runs out of memory.
    In the terminal running Docker stats, observe how the value for `MEM USAGE` approaches
    but never exceeds `LIMIT`. This is exactly the behavior we expected from Docker.
    Docker uses Linux **cgroups** to enforce those limits.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令通过创建三个子进程来给系统内存施加压力，这些进程会使用`malloc()`分配内存并持续触碰内存，直到系统内存耗尽。在运行 `docker stats`
    的终端中，观察 `MEM USAGE` 的值如何接近但从不超过 `LIMIT`。这正是我们期望从 Docker 中看到的行为。Docker 使用 Linux
    **cgroups** 来强制执行这些限制。
- en: What are cgroups?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 cgroups？
- en: Linux **cgroups**, short for **control groups**, is a kernel-level feature that
    allows you to organize processes into hierarchical groups, and to allocate, restrict,
    and monitor system resources such as CPU, memory, disk I/O, and network among
    these groups. Cgroups provide a way to manage and limit the resource usage of
    processes, ensuring fair distribution and preventing individual processes from
    monopolizing system resources.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Linux **cgroups**，即**控制组**，是一种内核级特性，允许将进程组织成层次结构的组，并在这些组之间分配、限制和监控系统资源，如 CPU、内存、磁盘
    I/O 和网络。Cgroups 提供了一种管理和限制进程资源使用的方法，确保资源公平分配，并防止单个进程独占系统资源。
- en: We could similarly limit the amount of CPU a container can consume with the
    `--``cpu` switch.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以类似地使用 `--cpu` 选项限制容器可以消耗的 CPU 数量。
- en: With this operation, engineers can avoid the noisy neighbor problem on a busy
    Docker host, where a single container starves all of the others by consuming an
    excessive amount of resources.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 通过此操作，工程师可以避免在繁忙的 Docker 主机上出现“噪声邻居”问题，在这种问题中，单个容器通过消耗过多的资源而导致所有其他容器处于资源匮乏状态。
- en: Avoiding running a container as root
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免以 root 身份运行容器
- en: Most applications or application services that run inside a container do not
    need `root` access. To tighten security, it is helpful in those scenarios to run
    these processes with minimal necessary privileges. These applications should not
    be run as `root` nor assume that they have `root`-level privileges.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数在容器内运行的应用程序或服务不需要 `root` 权限。在这种情况下，为了提高安全性，运行这些进程时使用最小必要权限是非常有帮助的。这些应用程序不应该以
    `root` 身份运行，也不应假设它们具有 `root` 级别的权限。
- en: 'Once again, let’s illustrate what we mean with an example. Assume we have a
    file with top-secret content. We want to secure this file on our Unix-based system
    using the `chmod` tool so that only users with `root` permissions can access it.
    Let’s assume I am logged in as `demo` on the dev host and hence my prompt is `demo@dev
    $`. I can use `sudo su` to impersonate a superuser. I have to enter the superuser
    password though:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 再次通过一个示例来说明我们的意思。假设我们有一个包含机密内容的文件。我们希望使用 `chmod` 工具在基于 Unix 的系统上保护该文件，使得只有具有
    `root` 权限的用户可以访问它。假设我以 `demo` 用户身份登录开发主机，因此我的提示符是 `demo@dev $`。我可以使用 `sudo su`
    来模拟超级用户身份。不过，我需要输入超级用户密码：
- en: '[PRE21]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now, as the `root` user, I can create this file called `top-secret.txt` and
    secure it:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为 `root` 用户，我可以创建名为 `top-secret.txt` 的文件并保护它：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'If I try to access the file as user `demo`, the following happens:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我以 `demo` 用户身份尝试访问该文件，将发生以下情况：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'I get a `Permission denied` message, which is what we wanted. No other user
    except `root` can access this file. Now, let’s build a Docker image that contains
    this secured file and when a container is created from it, tries to output the
    content of the `secrets` file. The Dockerfile could look like this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我收到一条 `Permission denied` 消息，这正是我们想要的。除了 `root` 用户外，没有其他用户可以访问此文件。现在，让我们构建一个包含此加密文件的
    Docker 镜像，当从中创建容器时，尝试输出 `secrets` 文件的内容。Dockerfile 可能如下所示：
- en: '[PRE24]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can build an image from that Dockerfile (as `root`!) with the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用以下命令（作为 `root` 用户！）从该 Dockerfile 构建镜像：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, by running a container with the image built in the previous step, we
    get the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过运行上一步骤构建的镜像，我们得到以下结果：
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The preceding command will generate this output:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将生成以下输出：
- en: '[PRE27]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'OK, so although I am impersonating the `demo` user on the host and running
    the container under this user account, the application running inside the container
    automatically runs as `root`, and hence has full access to protected resources.
    That’s bad, so let’s fix it! Instead of running with the default, we define an
    explicit user inside the container. The modified Dockerfile looks like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，尽管我在主机上模拟了 `demo` 用户并且在该用户帐户下运行容器，但容器内运行的应用程序自动以 `root` 身份运行，因此具有对受保护资源的完全访问权限。这很糟糕，所以让我们解决这个问题！我们不使用默认设置，而是定义容器内的一个明确用户。修改后的
    Dockerfile 如下所示：
- en: '[PRE28]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use the `groupadd` tool to define a new group, `demo-group`, with the ID
    `3000`. Then, we use the `useradd` tool to add a new user, `demo-user`, to this
    group. The user has the ID `4000` inside the container. Finally, with the `USER
    demo-user` statement, we declare that all subsequent operations should be executed
    as `demo-user`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `groupadd` 工具定义一个新的组 `demo-group`，组 ID 为 `3000`。然后，使用 `useradd` 工具将一个新的用户
    `demo-user` 添加到该组中。该用户在容器内的 ID 为 `4000`。最后，通过 `USER demo-user` 语句，我们声明所有后续操作都应该以
    `demo-user` 身份执行。
- en: 'Rebuild the image—again, as `root`—and then try to run a container from it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 重新构建镜像——再次以 `root` 身份——然后尝试从中运行容器：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: And as you can see on the last line, the application running inside the container
    runs with restricted permissions and cannot access resources that need root-level
    access. By the way, what do you think would happen if I ran the container as `root`?
    Try it out!
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你在最后一行看到的，容器内运行的应用程序具有受限权限，无法访问需要 root 级别权限的资源。顺便问一下，如果我以 `root` 身份运行容器，你觉得会发生什么？试试看！
- en: In the next section, we are going to show how we can automate Docker from within
    a container.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分，我们将展示如何从容器内部自动化 Docker 操作。
- en: Running Docker from within Docker
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器内运行 Docker
- en: At times, we may want to run a container hosting an application that automates
    certain Docker tasks. How can we do that? Docker Engine and the Docker CLI are
    installed on the host, yet the application runs inside the container. Well, from
    early on, Docker has provided a means to bind-mount Linux sockets from the host
    into the container. On Linux, sockets are used as very efficient data communications
    endpoints between processes that run on the same host. The Docker CLI uses a socket
    to communicate with Docker Engine; it is often called the **Docker socket**. If
    we can give access to the Docker socket to an application running inside a container,
    then we can just install the Docker CLI inside this container, and we will then
    be able to run an application in the same container that uses this locally installed
    Docker CLI to automate container-specific tasks.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能希望运行一个托管应用程序的容器，该应用程序自动化某些 Docker 任务。我们如何实现呢？Docker 引擎和 Docker CLI 安装在宿主机上，但应用程序运行在容器内。其实，Docker
    一开始就提供了从宿主机将 Linux 套接字绑定挂载到容器中的方法。在 Linux 中，套接字是进程间非常高效的数据通信端点，通常在同一宿主机上运行的进程间进行通信。Docker
    CLI 使用套接字与 Docker 引擎进行通信，通常称为 **Docker 套接字**。如果我们能让容器内的应用程序访问 Docker 套接字，那么我们可以在这个容器内安装
    Docker CLI，然后就可以使用这个本地安装的 Docker CLI 来自动化容器特定的任务。
- en: Important note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Here, we are not talking about running Docker Engine inside the container but
    rather only the Docker CLI and bind-mounting the Docker socket from the host into
    the container so that the CLI can communicate with Docker Engine running on the
    host computer. This is an important distinction.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是在讨论在容器内运行 Docker 引擎，而仅仅是运行 Docker CLI，并将 Docker 套接字从宿主机绑定挂载到容器中，以便 CLI
    可以与宿主机上运行的 Docker 引擎进行通信。这是一个重要的区别。
- en: 'Running Docker Engine inside a container is generally not recommended due to
    several reasons, including security, stability, and potential performance issues.
    This practice is often referred to as **Docker-in-Docker** or **DinD**. The main
    concerns are as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在容器内运行 Docker 引擎通常不建议使用，原因有很多，包括安全性、稳定性和潜在的性能问题。这种做法通常称为 **Docker-in-Docker**
    或 **DinD**。主要的关注点如下：
- en: '**Security**: Running Docker Engine inside a container requires elevated privileges,
    such as running the container in privileged mode or mounting the Docker socket.
    This can expose the host system to potential security risks, as a compromised
    container could gain control over the host’s Docker daemon and escalate privileges,
    affecting other containers and the host itself.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：在容器内运行 Docker 引擎需要提升的权限，如在特权模式下运行容器或挂载 Docker 套接字。这可能会使宿主系统面临潜在的安全风险，因为被攻破的容器可能会控制宿主机的
    Docker 守护进程，并提升权限，从而影响其他容器和宿主机本身。'
- en: '**Stability**: Containers are designed to be isolated, lightweight, and ephemeral.
    Running Docker Engine inside a container can create complex dependencies and increase
    the chances of conflicts or failures, particularly when managing storage, networking,
    and process namespaces between the host and the nested container environment.'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定性**：容器设计上是为了实现隔离、轻量和短暂的运行。将 Docker 引擎运行在容器内可能会产生复杂的依赖关系，增加冲突或失败的可能性，尤其是在管理宿主机和嵌套容器环境之间的存储、网络和进程命名空间时。'
- en: '**Performance**: Running Docker Engine inside a container can introduce performance
    overhead, as it adds another layer of virtualization, particularly in terms of
    storage and networking. This can lead to increased latency and reduced throughput,
    particularly when managing large numbers of containers or when working with high-performance
    applications.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能**：在容器内运行 Docker 引擎可能会引入性能开销，因为它增加了另一层虚拟化，特别是在存储和网络方面。这可能导致延迟增加和吞吐量下降，特别是在管理大量容器或处理高性能应用程序时。'
- en: '**Resource management**: Docker-in-Docker can make it challenging to manage
    and allocate resources effectively, as nested containers may not inherit resource
    limits and restrictions from their parent container, leading to potential resource
    contention or over-commitment on the host.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源管理**：Docker-in-Docker 可能会使有效管理和分配资源变得具有挑战性，因为嵌套容器可能无法继承其父容器的资源限制和约束，这可能导致资源争用或宿主机上资源过度分配。'
- en: 'To illustrate the concept, let’s look at an example using the preceding technique.
    We are going to use a copy of the `library` component we built in the previous
    chapter ([*Chapter 7*](B19199_07.xhtml#_idTextAnchor150)) for this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明这一概念，让我们看一个使用前述技术的示例。我们将使用上一章中构建的`library`组件的副本（见[*第 7 章*](B19199_07.xhtml#_idTextAnchor150)）来进行演示：
- en: 'Navigate to the chapter folder:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到章节文件夹：
- en: '[PRE30]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Copy the `library` component from the `ch07` directory to this folder:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`library`组件从`ch07`目录复制到此文件夹：
- en: '[PRE31]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Open the component in VS Code:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中打开该组件：
- en: '[PRE32]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add a new file called `pipeline.sh` to the root of the project and add the
    following code to it, which automates the building, testing, and pushing of a
    Docker image:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目根目录添加一个名为`pipeline.sh`的新文件，并将以下代码添加到其中，该代码实现了 Docker 镜像的构建、测试和推送自动化：
- en: '![Figure 8.3 – Script to build, test, and push a Java application](img/B19199_08_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 构建、测试并推送 Java 应用的脚本](img/B19199_08_03.jpg)'
- en: Figure 8.3 – Script to build, test, and push a Java application
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 构建、测试并推送 Java 应用的脚本
- en: 'Note that we’re using four environment variables: `$HUB_USER` and `$HUB_PWD`
    being the credentials for Docker Hub, and `$REPOSITORY` and `$TAG` being the name
    and tag of the Docker image we want to build. Eventually, we will have to pass
    values for those environment variables in the `docker container run` command,
    so that they are available for any process running inside the container.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，我们使用了四个环境变量：`$HUB_USER`和`$HUB_PWD`是 Docker Hub 的凭证，`$REPOSITORY`和`$TAG`是我们希望构建的
    Docker 镜像的名称和标签。最终，我们将需要在`docker container run`命令中传递这些环境变量的值，以便它们可以在容器内的任何进程中使用。
- en: 'Save the file and make it an executable:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并使其可执行：
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We want to run the `pipeline.sh` script inside a builder container. Since the
    script uses the Docker CLI, our builder container must have the Docker CLI installed,
    and to access Docker Engine, the builder container must have the Docker socket
    bind-mounted.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在构建器容器中运行`pipeline.sh`脚本。由于该脚本使用 Docker CLI，因此我们的构建器容器必须安装 Docker CLI，并且为了访问
    Docker 引擎，构建器容器必须绑定挂载 Docker 套接字。
- en: 'Let’s start creating a Docker image for such a builder container:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始为构建器容器创建 Docker 镜像：
- en: 'Add a file called `Dockerfile.builder` to the root of the project and add the
    following content to it:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目根目录添加一个名为`Dockerfile.builder`的文件，并将以下内容添加到其中：
- en: '![Figure 8.4 – Dockerfile for the builder](img/B19199_08_04.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 构建器的 Dockerfile](img/B19199_08_04.jpg)'
- en: Figure 8.4 – Dockerfile for the builder
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 构建器的 Dockerfile
- en: 'Note the long `RUN` command on line 3 onward. This is needed to install Docker
    in the container. For more details about this command, you may want to consult
    the Docker online documentation here: [https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/).'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意从第 3 行开始的长`RUN`命令。此命令用于在容器中安装 Docker。有关此命令的更多详细信息，您可以参考 Docker 在线文档：[https://docs.docker.com/engine/install/ubuntu/](https://docs.docker.com/engine/install/ubuntu/)。
- en: 'Building a Docker image with this Dockerfile is straightforward:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个 Dockerfile 构建 Docker 镜像非常简单：
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We are now ready to try the `builder` command with a real Java application;
    for example, let’s take the sample app we defined in the `ch08/library` folder.
    Make sure you replace `<user>` and `<password>` with your own credentials for
    Docker Hub:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在准备好尝试使用真实 Java 应用程序的`builder`命令了；例如，我们可以使用在`ch08/library`文件夹中定义的示例应用程序。确保用您自己的
    Docker Hub 凭证替换 `<user>` 和 `<password>`：
- en: '![Figure 8.5 – Docker run command for the builder](img/B19199_08_05.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.5 – 构建器的 Docker 运行命令](img/B19199_08_05.jpg)'
- en: Figure 8.5 – Docker run command for the builder
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 构建器的 Docker 运行命令
- en: Notice how, in the preceding command, we mounted the Docker socket into the
    container with `-v /var/run/docker.sock:/var/run/docker.sock`. If everything goes
    well, you should have a container image built for the sample application, the
    test should have been run, and the image should have been pushed to Docker Hub.
    This is only one of the many use cases where it is very useful to be able to bind-mount
    the Docker socket.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，在前面的命令中，我们通过`-v /var/run/docker.sock:/var/run/docker.sock`将 Docker 套接字挂载到容器中。如果一切顺利，您应该已经为示例应用程序构建了容器镜像，测试已经运行，并且镜像已经推送到
    Docker Hub。这只是许多非常有用的使用场景之一，在这些场景中，将 Docker 套接字绑定挂载非常重要。
- en: 'A special notice to those of you who want to try Windows containers on a Windows
    computer: on Docker Desktop for Windows, you can create a similar environment
    by bind-mounting Docker’s **named pipe** instead of a socket. A named pipe on
    Windows is roughly the same as a socket on a Unix- based system. Assuming you’re
    using a PowerShell terminal, the command to bind-mount a named pipe when running
    a Windows container hosting Jenkins looks like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 特别提示给那些想在 Windows 计算机上尝试 Windows 容器的用户：在 Windows 上的 Docker Desktop 中，你可以通过绑定挂载
    Docker 的 **命名管道** 来创建一个类似的环境，而不是套接字。在 Windows 上，命名管道大致相当于 Unix 系统上的套接字。假设你正在使用
    PowerShell 终端，当运行托管 Jenkins 的 Windows 容器时，绑定挂载命名管道的命令如下所示：
- en: '[PRE35]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note the special syntax, `\\.\pipe\docker_engine`, to access Docker’s named
    pipe.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意特殊语法`\\.\pipe\docker_engine`，用于访问 Docker 的命名管道。
- en: In this section, we have shown how to run Docker from within Docker by mounting
    the Docker socket into the respective container.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何通过将 Docker 套接字挂载到相应的容器中，从容器内运行 Docker。
- en: Next, we are going to revisit the topic of how to make your Docker build as
    fast as possible to reduce friction in the development cycle.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将重新探讨如何使你的 Docker 构建尽可能快速，以减少开发周期中的摩擦。
- en: Optimizing your build process
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化构建过程
- en: The Docker build process can and should be optimized. This will remove a lot
    of friction in the software development life cycle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: Docker 构建过程可以且应该得到优化。这将减少软件开发生命周期中的很多摩擦。
- en: 'Many Docker beginners make the following mistake when crafting their first
    Dockerfile:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Docker 初学者在编写第一个 Dockerfile 时会犯以下错误：
- en: '![Figure 8.6 – Unoptimized Dockerfile for a Node.js application](img/B19199_08_06.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.6 – 一个未优化的 Node.js 应用程序 Dockerfile](img/B19199_08_06.jpg)'
- en: Figure 8.6 – Unoptimized Dockerfile for a Node.js application
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 未优化的 Node.js 应用程序 Dockerfile
- en: Can you spot the weak point in this typical Dockerfile for a Node.js application?
    In[*Chapter 4*](B19199_04.xhtml#_idTextAnchor083), *Creating and Managing Container
    Images*, we learned that an image consists of a series of layers. Each (logical)
    line in a Dockerfile creates a layer, except the lines with the `CMD` and/or `ENTRYPOINT`
    keywords. We also learned that the Docker builder tries to do its best by caching
    layers and reusing them if they have not changed between subsequent builds. But
    the caching only uses cached layers that occur before the first changed layer.
    All subsequent layers need to be rebuilt. That said, the preceding structure of
    the Dockerfile invalidates – or as we often hear said – *busts* the image layer
    cache!
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你能发现这个典型的 Node.js 应用程序 Dockerfile 中的薄弱点吗？在[*第 4 章*](B19199_04.xhtml#_idTextAnchor083)《创建和管理容器镜像》中，我们了解到，一个镜像由一系列的层组成。Dockerfile
    中的每一行（逻辑行）都会创建一个层，`CMD` 和/或 `ENTRYPOINT` 关键字的行除外。我们还了解到，Docker 构建器会尽力通过缓存层并在后续构建中重用未发生变化的层来优化构建过程。但缓存机制仅使用发生变化之前的缓存层，所有之后的层都需要重新构建。也就是说，Dockerfile
    的上述结构会使得镜像层缓存失效——或者我们常听到的说法是，*破坏*了镜像层缓存！
- en: 'Why? Well, from experience, you certainly know that the `npm install` command
    can be a pretty expensive operation in a typical Node.js application with many
    external dependencies. The execution of this command can take from seconds to
    many minutes. That said, each time one of the source files changes, and we know
    that happens frequently during development, line 3 in the Dockerfile causes the
    corresponding image layer to change. Hence, the Docker builder cannot reuse this
    layer from the cache, nor can it reuse the subsequent layer created by `RUN npm
    install`. Any minor change in code causes a complete rerun of `npm install`. That
    can be avoided. The `package.json` file containing the list of external dependencies
    rarely changes. With all of that information, let’s fix the Dockerfile:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？嗯，根据经验，你肯定知道 `npm install` 命令在一个典型的 Node.js 应用程序中，尤其是有很多外部依赖的情况下，可能是一个非常耗时的操作。执行这个命令的时间可能从几秒钟到好几分钟不等。也就是说，每当其中一个源文件发生变化，而我们知道在开发过程中这种情况经常发生，Dockerfile
    中的第 3 行会导致相应的镜像层发生变化。因此，Docker 构建器不能从缓存中重用该层，也不能重用由 `RUN npm install` 创建的后续层。代码的任何细微变化都会导致
    `npm install` 被完全重新执行。这是可以避免的。包含外部依赖列表的 `package.json` 文件很少发生变化。根据这些信息，让我们来修复
    Dockerfile：
- en: '![Figure 8.7 – Optimized Dockerfile for a Node.js application](img/B19199_08_07.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.7 – 优化后的 Node.js 应用程序 Dockerfile](img/B19199_08_07.jpg)'
- en: Figure 8.7 – Optimized Dockerfile for a Node.js application
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 优化后的 Node.js 应用程序 Dockerfile
- en: This time, on line 3, we only copy the `package.json` file into the container,
    which rarely changes. Hence, the subsequent `npm install` command has to be executed
    equally rarely. The `COPY` command on line 5 is then a very fast operation and
    hence rebuilding an image after some code has changed only needs to rebuild this
    last layer. Build times reduce to merely a fraction of a second.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在第 3 行，我们只将 `package.json` 文件复制到容器中，该文件很少发生变化。因此，随后的 `npm install` 命令也很少需要执行。第
    5 行的 `COPY` 命令是一个非常快速的操作，因此在代码发生变化后，只需要重新构建这一层，重建镜像的时间缩短到几乎为零。
- en: The very same principle applies to most languages or frameworks, such as Python,
    .NET, or Java. Avoid busting your image layer cache!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的原则适用于大多数语言或框架，如 Python、.NET 或 Java。避免破坏你的镜像层缓存！
- en: Scanning for vulnerabilities and secrets
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扫描漏洞和机密信息
- en: What exactly are vulnerabilities, or to be more accurate, **Common Vulnerabilities
    and** **Exposures** (**CVE**)?
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 究竟什么是漏洞，或者更准确地说，**常见漏洞与暴露**（**CVE**）是什么？
- en: A database of information security problems that have been made publicly known
    is called **Common Vulnerabilities and Exposures**. A number uniquely identifies
    each vulnerability from the list of all other entries in the database. This list
    is continuously reviewed and updated by experts who include any new vulnerabilities
    or exposures as soon as they are found.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 一个公开已知的信息安全问题的数据库称为 **常见漏洞与暴露**。每个漏洞在数据库中的条目都有一个唯一的标识符。这个列表由专家不断审查和更新，任何新的漏洞或暴露都会在发现后立即加入。
- en: Now, we can scan the various layers of our Docker images using specialist software,
    such as Snyk, to find software libraries that are known to have such CVE. If we
    find that our image is flawed, we should and can repair the issue by switching
    to a more recent version of the flawed library. The image will then need to be
    rebuilt.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用专业软件（如 Snyk）扫描 Docker 镜像的各个层，以查找已知存在 CVE 的软件库。如果我们发现镜像存在缺陷，我们应该通过切换到更新版本的有问题的库来修复问题，然后重新构建镜像。
- en: But our work is not yet done. Security experts frequently find new CVE, as was
    already mentioned previously. As a result, a software library that was previously
    secure may suddenly be vulnerable as a result of newly revealed CVE.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们的工作还没有完成。安全专家经常会发现新的 CVE，正如前面提到的那样。因此，之前安全的软件库可能因为新公开的 CVE 而突然变得脆弱。
- en: This means that we must ensure that all of our active Docker images are routinely
    inspected, notify our developers and security experts about the issue, and take
    other steps to ensure a speedy resolution of the issue.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们必须确保定期检查所有活跃的 Docker 镜像，通知我们的开发人员和安全专家这个问题，并采取其他措施确保问题尽快解决。
- en: 'There are a few ways to scan a Docker image for vulnerabilities and secrets:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以扫描 Docker 镜像中的漏洞和机密信息：
- en: Use a vulnerability scanner such as Clair, Anchore, or Trivy. These tools can
    scan a Docker image and check it against a database of known vulnerabilities in
    order to identify any potential security risks.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用像 Clair、Anchore 或 Trivy 这样的漏洞扫描工具。这些工具可以扫描 Docker 镜像，并将其与已知漏洞的数据库进行对比，以识别潜在的安全风险。
- en: Use a tool such as Aquasec or Sysdig to scan the image for secrets. These tools
    can detect and alert on sensitive information such as private keys, passwords,
    and other sensitive data that may have been accidentally committed to the image.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如 Aquasec 或 Sysdig 等工具扫描镜像中的机密信息。这些工具可以检测并提醒敏感信息，如私钥、密码以及可能无意中提交到镜像中的其他敏感数据。
- en: Use a combination of both tools, for example, Docker Bench for Security, which
    checks for dozens of common best practices around deploying Docker containers
    in production.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合使用两种工具，例如 Docker Bench for Security，它检查部署 Docker 容器到生产环境中时的常见最佳实践。
- en: Use a tool such as OpenSCAP, which can perform vulnerability scans, security
    configuration assessments, and compliance checks on a Docker image.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用如 OpenSCAP 等工具，它可以执行漏洞扫描、安全配置评估以及对 Docker 镜像的合规性检查。
- en: It’s important to note that it’s always good practice to keep your images updated
    and only use official and trusted images.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，保持镜像更新并只使用官方和可信的镜像始终是一种良好的实践。
- en: In the next section, we will investigate how we can discover vulnerabilities
    inside our Docker images.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将研究如何发现 Docker 镜像中的漏洞。
- en: Using Snyk to scan a Docker image
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Snyk 扫描 Docker 镜像
- en: 'Snyk is a security platform that can be used to scan Docker images for vulnerabilities.
    Here is an example of how to use Snyk to scan a Docker image for vulnerabilities:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Snyk是一个安全平台，可用于扫描Docker镜像中的漏洞。以下是使用Snyk扫描Docker镜像漏洞的示例：
- en: 'First, we have to install the Snyk CLI on our machine. We can do this by running
    the following command:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在机器上安装Snyk CLI。我们可以通过运行以下命令来完成：
- en: '[PRE36]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Once Snyk is installed, we can authenticate with our Snyk account by running
    the following command and following the prompts:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦安装了Snyk，我们可以通过运行以下命令并按照提示完成身份验证：
- en: '[PRE37]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, we can run the following command to scan a specific Docker image for
    vulnerabilities:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以运行以下命令来扫描特定的Docker镜像漏洞：
- en: '[PRE38]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding command will perform a vulnerability scan on the specified Docker
    image and print the results in the console. The results will show the number of
    vulnerabilities found, the severity of each vulnerability, and the package and
    version that is affected.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 上述命令将对指定的Docker镜像进行漏洞扫描，并在控制台中打印结果。结果将显示发现的漏洞数量、每个漏洞的严重性，以及受影响的包和版本。
- en: 'We can also use the `--file` flag to scan a Dockerfile instead of a built image:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以使用`--file`标志来扫描一个Dockerfile，而不是扫描已经构建好的镜像：
- en: '[PRE39]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Additionally, we can also use the `--org` flag to specify an organization,
    if we’re a member of multiple organizations:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果我们是多个组织的成员，我们还可以使用`--org`标志来指定一个组织：
- en: '[PRE40]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, we can use the `--fix` flag to automatically fix the vulnerabilities
    found by running the following command:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以使用`--fix`标志来自动修复扫描中发现的漏洞，方法是运行以下命令：
- en: '[PRE41]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Please note that this feature is only available for images that are built using
    a Dockerfile and it will update the Dockerfile with the new package versions,
    and you will need to rebuild the image to take advantage of the fix.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，此功能仅适用于通过Dockerfile构建的镜像，它将更新Dockerfile中的新包版本，并且你需要重新构建镜像才能利用此修复。
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The Snyk free plan is limited to a certain number of scans, and it does not
    include the *Protect* feature. You will have to upgrade to a paid plan to have
    access to this feature.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: Snyk的免费计划有限制扫描次数，并且不包括*Protect*功能。你需要升级到付费计划才能访问此功能。
- en: Using docker scan to scan a Docker image for vulnerabilities
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用docker scan扫描Docker镜像中的漏洞
- en: 'In this section, we are once again going to use Snyk to scan a Docker image
    for vulnerabilities. Snyk should be included with your Docker Desktop installation:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将再次使用Snyk扫描Docker镜像中的漏洞。Snyk应该已经随Docker Desktop的安装包一同安装：
- en: 'Check by using this command:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令进行检查：
- en: '[PRE42]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output should look similar to this:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果应类似于此：
- en: '[PRE43]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Let’s try to scan a sample `whoami` application from the author’s Docker Hub
    account. First, make sure you have the `whoami` image in your local cache:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们尝试扫描作者Docker Hub账户中的示例`whoami`应用。首先，确保你在本地缓存中有`whoami`镜像：
- en: '[PRE44]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Scan the image for vulnerabilities:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描镜像中的漏洞：
- en: '[PRE45]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'You will be asked the following:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将被询问以下内容：
- en: '[PRE46]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Please answer this with `y`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 请回答`y`。
- en: 'The result of the preceding scan looks like this on my computer:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述扫描的结果在我的电脑上看起来是这样的：
- en: '![Figure 8.8 – Scanning the gnschenker/whoami:1.0 Docker image](img/B19199_08_08.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.8 – 扫描gnschenker/whoami:1.0 Docker镜像](img/B19199_08_08.jpg)'
- en: Figure 8.8 – Scanning the gnschenker/whoami:1.0 Docker image
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 扫描gnschenker/whoami:1.0 Docker镜像
- en: 'As you can see, there were three vulnerabilities found in this version of the
    image: one of *medium*, one of *high*, and one of *critical* severity. It is clear
    that we should address critical vulnerabilities as soon as possible. Let’s do
    this now:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在该版本的镜像中发现了三处漏洞：其中一个为*中等*级别，一个为*高*级别，一个为*严重*级别。显然，我们应尽快解决严重漏洞。让我们现在就来做：
- en: First, we copy over the original `whoami` project including the Dockerfile we
    used to build this image. You can find the copy in your `~/``The-Ultimate-Docker-Container-Book/sample-solutions/``ch14`
    folder.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们复制原始的`whoami`项目，包括用于构建该镜像的Dockerfile。你可以在`~/``The-Ultimate-Docker-Container-Book/sample-solutions/``ch14`文件夹中找到该副本。
- en: Open the Dockerfile and inspect it. We used version `6.0-alpine` for both the
    .NET SDK and the runtime. Let’s see whether Microsoft has updated the vulnerabilities
    in this version already.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Dockerfile并检查它。我们为.NET SDK和运行时都使用了版本`6.0-alpine`。让我们看看Microsoft是否已经更新了这个版本中的漏洞。
- en: Navigate to your `…/``ch08/whoami` folder.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`…/``ch08/whoami`文件夹。
- en: 'Build a new version of the Docker image with this command:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此命令构建一个新的Docker镜像版本：
- en: '[PRE47]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note, you may want to replace `gnschenker` with your own Docker account name.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，你可能需要将 `gnschenker` 替换为你自己的 Docker 账户名。
- en: 'Scan the new image:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扫描新镜像：
- en: '[PRE48]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This time, the output should look like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，输出应该如下所示：
- en: '![Figure 8.9 – Scanning the rebuilt whoami Docker image](img/B19199_08_09.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.9 – 扫描重建的 whoami Docker 镜像](img/B19199_08_09.jpg)'
- en: Figure 8.9 – Scanning the rebuilt whoami Docker image
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – 扫描重建的 whoami Docker 镜像
- en: As you can see, this time, the image is free from any vulnerabilities. We should
    now instruct our DevOps to use this new version of the image. We can use a rolling
    update in production and should be just fine, as the application itself did not
    change.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这次镜像不含任何漏洞。我们现在应该指示 DevOps 使用这个新版本的镜像。我们可以在生产环境中进行滚动更新，应该不会有问题，因为应用本身并未更改。
- en: In the next section, we are going to learn how to run a complete development
    environment inside a container.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将学习如何在容器中运行一个完整的开发环境。
- en: Running your development environment in a container
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在容器中运行你的开发环境
- en: Imagine that you only have access to a workstation with Docker Desktop installed,
    but no possibility to add or change anything else on this workstation. Now you
    want to do some proofs of concept and code some sample applications using Java.
    Unfortunately, Java and SpringBoot are not installed on your computer. What can
    you do? What if you could run a whole development environment inside a container,
    including a code editor and debugger? What if, at the same time, you could still
    have your code files on your host machine?
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你只有一个安装了 Docker Desktop 的工作站，但无法在该工作站上添加或更改其他任何内容。现在你想进行一些概念验证并使用 Java 编写一些示例应用程序。不幸的是，Java
    和 SpringBoot 并未安装在你的电脑上。你该怎么办？如果你能在容器中运行一个完整的开发环境，包括代码编辑器和调试器，会怎么样？同时，你还能将代码文件保留在主机上呢？
- en: Containers are awesome, and genius engineers have come up with solutions for
    exactly this kind of problem.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 容器真是太棒了，天才工程师们为这种问题提供了解决方案。
- en: Note
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注
- en: 'Microsoft and the community are continuously updating VS Code and the plugins.
    Thus your version of VS Code may be newer than the one used during the writing
    of this book. As such, expect a slightly different experience. Refer to the official
    documentation for more details on how to work with Dev containers: [https://code.visualstudio.com/docs/devcontainers/containers](https://code.visualstudio.com/docs/devcontainers/containers).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 微软和社区一直在不断更新 VS Code 和插件。因此，你的 VS Code 版本可能比本书编写时使用的版本更新。因此，可能会有稍微不同的体验。有关如何使用
    Dev 容器的更多细节，请参考官方文档：[https://code.visualstudio.com/docs/devcontainers/containers](https://code.visualstudio.com/docs/devcontainers/containers)。
- en: 'We will be using Visual Studio Code, our favorite code editor, to show how
    to run a complete Java development environment inside a container:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Visual Studio Code，这个我们最喜欢的代码编辑器，来演示如何在容器中运行一个完整的 Java 开发环境：
- en: 'But first, we need to install the necessary VS Code extension. Open VS Code
    and install the extension called **Remote Development**:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但首先，我们需要安装必要的 VS Code 扩展。打开 VS Code 并安装名为 **Remote Development** 的扩展：
- en: '![Figure 8.10 – Adding the Remote Development extension to VS Code](img/B19199_08_10.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.10 – 将 Remote Development 扩展添加到 VS Code](img/B19199_08_10.jpg)'
- en: Figure 8.10 – Adding the Remote Development extension to VS Code
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – 将 Remote Development 扩展添加到 VS Code
- en: 'Then, click the green quick actions status bar item in the lower-left of the
    Visual Studio Code window. In the popup, select **Remote-Containers** | **Open
    Folder** **in Container...**:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 Visual Studio Code 窗口左下角的绿色快速操作状态栏项。在弹出的对话框中，选择 **Remote-Containers**
    | **在容器中打开文件夹...**：
- en: '![Figure 8.11 – Open Folder in Container](img/B19199_08_11.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.11 – 在容器中打开文件夹](img/B19199_08_11.jpg)'
- en: Figure 8.11 – Open Folder in Container
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – 在容器中打开文件夹
- en: Select the project folder you want to work with in the container. In our case,
    we selected the `~/``The-Ultimate-Docker-Container-Book/ch08/library` folder.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你想在容器中使用的项目文件夹。在我们的例子中，我们选择了 `~/``The-Ultimate-Docker-Container-Book/ch08/library`
    文件夹。
- en: 'A popup will appear asking you to define how you want to create the development
    container. From the list, select **From ‘Dockerfile’**:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 会弹出一个对话框，询问你如何创建开发容器。在列表中，选择 **From ‘Dockerfile’**：
- en: '![Figure 8.12 – Selecting the method to create the development container](img/B19199_08_12.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.12 – 选择创建开发容器的方法](img/B19199_08_12.jpg)'
- en: Figure 8.12 – Selecting the method to create the development container
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – 选择创建开发容器的方法
- en: When asked to add additional features to install, just click **OK** to continue.
    At this time, we do not need anything special.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当要求你添加其他要安装的功能时，只需点击 **OK** 继续。此时，我们不需要任何特别的功能。
- en: VS Code will now start preparing the environment, which, the very first time,
    can take a couple of minutes or so.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code 现在将开始准备环境，首次启动可能需要几分钟时间。
- en: 'Once the environment is ready, you should notice that in the lower-left corner,
    the prompt has changed to the following:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦环境准备好，你应该注意到左下角的提示符已经变成如下所示：
- en: '[PRE49]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: This indicates that VS Code has indeed run a container based on the Dockerfile
    found in the library folder and is allowing you to work within it.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，VS Code 确实已根据 `library` 文件夹中的 Dockerfile 运行了一个容器，并允许你在其中工作。
- en: 'You will be asked to install the extension pack for Java since VS Code has
    recognized that this is a Java project. Click `dev` container and only the UI
    is still running on your laptop. Thus, the extension pack will be installed for
    the engine inside the container. You will notice this when you open the **EXTENSIONS**
    panel and find a list of remote extensions under **DEV CONTAINER**. In our case,
    by installing the Java extensions pack, we now have the following eight remote
    extensions installed:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 VS Code 识别这是一个 Java 项目，你将被要求安装 Java 扩展包。点击 `dev` 容器，注意，只有 UI 仍然在你的笔记本电脑上运行，因此扩展包将被安装在容器内部的引擎中。你会在打开
    **EXTENSIONS** 面板时注意到，在 **DEV CONTAINER** 下列出了远程扩展。在我们的例子中，安装 Java 扩展包后，我们现在安装了以下八个远程扩展：
- en: '![Figure 8.13 – Remote extensions installed on the dev container](img/B19199_08_13.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.13 – 在开发容器中安装的远程扩展](img/B19199_08_13.jpg)'
- en: Figure 8.13 – Remote extensions installed on the dev container
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.13 – 在开发容器中安装的远程扩展
- en: 'Open a Terminal inside VS Code with *Shift* + *Ctrl* + *‘* and notice the prompt
    revealing that the terminal session is ins[ide the `dev` container and that we
    are *not* runni](mailto:root@c96b82891be7:/workspaces/.../ch08/library)ng directly
    on our Docker host:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 内打开终端，按 *Shift* + *Ctrl* + *‘*，并注意到提示符显示我们正处于 `dev` 容器内，而不是直接在 Docker
    主机上运行：
- en: '[PRE50]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note that for readability, we have shortened the preceding prompt.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，为了提高可读性，我们已简化了前面的提示。
- en: Now, try to run the Java application by locating the `main` method in the `LibraryApplication`
    class and clicking the **Run** link just above the method. The application should
    start as normal, but notice that our context is inside the dev container and not
    directly on our working machine.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，尝试通过在 `LibraryApplication` 类中找到 `main` 方法并点击方法上方的 **Run** 链接来运行 Java 应用程序。应用程序应该像往常一样启动，但请注意，我们的上下文是在开发容器内，而不是直接在工作机器上。
- en: 'Alternatively, we could have started the application from the command line
    with this command:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们也可以通过命令行使用以下命令来启动应用程序：
- en: '[PRE51]'
  id: totrans-277
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now, add a file called `DefaultController.java` to the `controllers` folder
    and give it this content:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，向 `controllers` 文件夹添加一个名为 `DefaultController.java` 的文件，并添加以下内容：
- en: '![Figure 8.14 – Adding a default controller while working inside the dev container](img/B19199_08_14.jpg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.14 – 在开发容器内添加默认控制器](img/B19199_08_14.jpg)'
- en: Figure 8.14 – Adding a default controller whil[e working inside the](http://localhost:8080)
    dev container
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.14 – 在开发容器内添加默认控制器 [工作中](http://localhost:8080)
- en: Restart the application and open a browser as `http://localhost:8080`. The message
    `Library component` should be displayed as expected.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重启应用程序，并在浏览器中打开 `http://localhost:8080`。应该会显示 `Library component` 消息，符合预期。
- en: When done experimenting, click on the green area in the lower-left corner of
    VS Code and select **Open folder locally** from the pop-up menu to quit the dev
    container and open the project locally.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实验完成后，点击 VS Code 左下角的绿色区域，并从弹出菜单中选择 **Open folder locally**，退出开发容器并将项目本地打开。
- en: Observe that a new folder, `.devcontainer`, has been added to the project containing
    a `devcontainer.json` file. This file contains the configuration needed to run
    a dev container from this project. Please read the documentation of VS Code to
    familiarize yourself with the possibilities this file offers to you.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意到项目中添加了一个新的文件夹 `.devcontainer`，其中包含一个 `devcontainer.json` 文件。该文件包含从此项目运行开发容器所需的配置。请阅读
    VS Code 的文档，了解此文件为你提供的功能。
- en: These have been a few tips and tricks for pros that are useful in the day-to-day
    usage of containers. There are many more. Google them. It is worth it.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是一些对专业人士有用的技巧和窍门，适用于容器的日常使用。还有更多内容，可以去 Google 查找，值得一试。
- en: Summary
  id: totrans-285
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this chapter, we presented miscellaneous tips, tricks, and concepts that
    are useful when containerizing complex distributed applications or when using
    Docker to automate sophisticated tasks. We also learned how to leverage containers
    to run a whole development environment inside of them.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了在容器化复杂的分布式应用程序时或使用 Docker 自动化复杂任务时有用的各种技巧、窍门和概念。我们还学习了如何利用容器在其中运行完整的开发环境。
- en: In the next chapter, we will introduce the concept of a distributed application
    architecture and discuss the various patterns and best practices that are required
    to run a distributed application successfully.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍分布式应用架构的概念，并讨论成功运行分布式应用所需的各种模式和最佳实践。
- en: Questions
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Here are a few questions you should try to answer to assess your progress:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些你应该尝试回答的问题，以评估你的进展：
- en: Name the reasons why you would want to run a complete development environment
    inside a container.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出你希望在容器内运行完整开发环境的原因。
- en: Why should you avoid running applications inside a container as `root`?
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该避免以 `root` 用户身份在容器内运行应用程序？
- en: Why would you ever bind-mount the Docker socket into a container?
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会将 Docker 套接字绑定到容器中？
- en: When pruning your Docker resources to make space, why do you need to handle
    volumes with special care?
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在清理 Docker 资源以腾出空间时，为什么需要特别小心处理卷？
- en: Why would you want to run certain admin tasks inside a Docker container and
    not natively on the host machine?
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么你会希望在 Docker 容器内运行某些管理员任务，而不是在主机机器上本地运行？
- en: Answers
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'Here are sample answers for the questions in this chapter:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是本章问题的示例答案：
- en: You could be working on a workstation with limited resources or capabilities,
    or your workstation could be locked down by your company so that you are not allowed
    to install any software that is not officially approved. Sometimes, you might
    need to do proofs of concept or experiments using languages or frameworks that
    are not yet approved by your company (but might be in the future if the proof
    of concept is successful).
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能正在使用资源或能力有限的工作站，或者你的工作站可能被公司锁定，禁止安装任何未经官方批准的软件。有时，你可能需要使用尚未被公司批准的语言或框架来做概念验证或实验（但如果概念验证成功，未来可能会被批准）。
- en: Bind-mounting a Docker socket into a container is the recommended method when
    a containerized application needs to automate some container-related tasks. This
    can be an application such as an automation server (such as Jenkins) that you
    are using to build, test, and deploy Docker images.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Docker 套接字绑定到容器内是推荐的方法，当容器化应用程序需要自动化某些与容器相关的任务时。这可以是像 Jenkins 这样的自动化服务器，用于构建、测试和部署
    Docker 镜像。
- en: Most business applications do not need `root`-level authorizations to do their
    job. From a security perspective, it is therefore strongly recommended to run
    such applications with the least necessary access rights to their job. Any unnecessary
    elevated privileges could possibly be exploited by hackers in a malicious attack.
    By running the application as a non-`root` user, you make it more difficult for
    potential hackers to compromise your system.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数业务应用程序不需要 `root` 级别的权限就能完成工作。因此，从安全的角度来看，强烈建议以最少必要的访问权限运行此类应用程序。任何不必要的提升权限可能会被黑客在恶意攻击中利用。通过以非
    `root` 用户身份运行应用程序，你可以使潜在黑客更难以侵入你的系统。
- en: Volumes contain data and the lifespan of data most often needs to go far beyond
    the life cycle of a container, or an application, for that matter. Data is often
    mission-critical and needs to be stored safely for days, months, or even years.
    When you delete a volume, you irreversibly delete the data associated with it.
    Hence, make sure you know what you’re doing when deleting a volume.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卷包含数据，而数据的生命周期通常需要超出容器或应用程序的生命周期。数据通常是关键任务，需要安全存储数天、数月甚至数年。当你删除一个卷时，你会不可逆地删除与之关联的数据。因此，在删除卷时，请确保你知道自己在做什么。
- en: 'There are several reasons why you might want to run certain admin tasks inside
    a Docker container, rather than natively on the host machine:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能希望在 Docker 容器内运行某些管理员任务，而不是在主机机器上本地运行，有几个原因：
- en: '**Isolation**: Containers provide a level of isolation from the host machine,
    so running admin tasks inside a container can help to prevent conflicts with other
    processes or dependencies on the host machine.'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隔离性**：容器提供了与宿主机的隔离，这样在容器中运行管理任务可以帮助防止与宿主机上其他进程或依赖项的冲突。'
- en: '**Portability**: Containers are designed to be lightweight and portable, which
    allows for easy deployment of admin tasks across different environments. This
    can be particularly useful for tasks that need to be run in multiple environments
    or on multiple machines.'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可移植性**：容器设计为轻量级和可移植，允许在不同环境中轻松部署管理任务。这对于需要在多个环境或多台机器上运行的任务尤其有用。'
- en: '**Consistency**: Containers provide a consistent environment for running admin
    tasks, regardless of the underlying host machine’s configuration. This can be
    useful for ensuring that tasks are run in a predictable and repeatable manner,
    which can help to minimize errors and improve efficiency.'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**一致性**：容器为运行管理任务提供了一个一致的环境，无论宿主机的配置如何。这有助于确保任务以可预测和可重复的方式运行，从而减少错误并提高效率。'
- en: '**Versioning**: Containers allow for easy versioning of admin tasks, which
    allows for rollbacks and roll forward of the tasks. This can be useful for testing,
    troubleshooting, and production environments.'
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本管理**：容器允许对管理任务进行轻松的版本控制，这使得任务可以回滚或向前推进。这对于测试、故障排除和生产环境非常有用。'
- en: '**Security**: Running admin tasks inside a container can help to improve security
    by isolating the task from the host machine, and by making it easier to limit
    the permissions and access that the task has.'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全性**：在容器中运行管理任务有助于通过将任务与宿主机隔离，并且更容易限制任务的权限和访问，从而提高安全性。'
- en: '**Scalability**: Containers can be easily scaled up and down, allowing you
    to increase or decrease the resources that the admin task needs.'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可扩展性**：容器可以轻松地进行水平扩展和缩减，允许你增加或减少管理任务所需的资源。'
- en: Please note that this is not a comprehensive list and different use cases may
    require different approaches. It’s important to weigh the pros and cons of running
    admin tasks inside a container versus natively on the host machine and to choose
    the approach that best fits your particular use case.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这并不是一个详尽无遗的列表，不同的使用场景可能需要不同的方法。在容器中运行管理任务与直接在宿主机上运行之间，权衡其利弊是非常重要的，你需要选择最适合特定使用场景的方法。
- en: Part 3:Orchestration Fundamentals
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第三部分：编排基础
- en: By the end of *Part 3*, you will be familiar with the concepts of a Dockerized
    distributed application and container orchestrators, and be able to use Docker
    Swarm to deploy and run your applications.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 到了*第三部分*结束时，你将熟悉 Docker 化的分布式应用程序和容器编排器的概念，并能够使用 Docker Swarm 部署和运行你的应用程序。
- en: '[*Chapter 9*](B19199_09.xhtml#_idTextAnchor194), *Learning about* *Distributed
    Application Architecture*'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第9章*](B19199_09.xhtml#_idTextAnchor194)，*学习分布式应用架构*'
- en: '[*Chapter 10*](B19199_10.xhtml#_idTextAnchor218), *Using Singl**e-H**ost Networking*'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第10章*](B19199_10.xhtml#_idTextAnchor218)，*使用单主机网络*'
- en: '[*Chapter 11*](B19199_11.xhtml#_idTextAnchor237), *Managing Containers with
    Docker Compose*'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第11章*](B19199_11.xhtml#_idTextAnchor237)，*使用 Docker Compose 管理容器*'
- en: '[*Chapter 12*](B19199_12.xhtml#_idTextAnchor251), *Shipping Logs and Monitoring
    Containers*'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第12章*](B19199_12.xhtml#_idTextAnchor251)，*传输日志和监控容器*'
- en: '[*Chapter 13*](B19199_13.xhtml#_idTextAnchor276), *Introducing Container Orchestration*'
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第13章*](B19199_13.xhtml#_idTextAnchor276)，*介绍容器编排*'
- en: '[*Chapter 14*](B19199_14.xhtml#_idTextAnchor303),*Introducing Introducing*
    *Docker Swarm*'
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19199_14.xhtml#_idTextAnchor303)，*介绍 Docker Swarm*'
- en: '[*Chapter 15*](B19199_15.xhtml#_idTextAnchor328), *Deploying and Running a
    Distributed Application on Docker Swarm*'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19199_15.xhtml#_idTextAnchor328)，*在 Docker Swarm 上部署和运行分布式应用程序*'
