- en: Chapter 3. Separating Code and Data – Variables, Facts, and Templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we looked at how to write a role to provide modularity
    and abstraction. While doing so, we created the configuration file and copied
    the file over to the destination host using Ansible's copy module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: How do you separate data from code?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are Jinja2 templates? How are these created?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are variables? How and where are they used?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are system facts? How are they discovered?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are the different types of variables?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a variable merge order? What are its precedence rules?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static content explosion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s imagine that we are managing a cluster of hundreds of web servers spanning
    across multiple data centers. Since we have the `server_name` parameter hardcoded
    in to the `config` file, we will have to create one file per server. This also
    means that we will manage hundreds of static files, which will quickly get out
    of control. Our infrastructure is dynamic, and managing change is one of the most
    common aspects of a DevOps engineer''s routine tasks. If tomorrow, our company
    policy states that we should run web servers on the port 8080 instead of the port
    80, only in a production environment, imagine the headache you''d get having to
    change all these files individually. Wouldn''t it be better to have a single file
    that takes dynamic inputs, which are specific to the host it''s running on? This
    is exactly what templates are for and, as depicted in the following diagram, a
    single template could replace a multitude of static files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Static content explosion](img/B03800_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Before we define what a template is, let's begin by understanding how to separate
    code from data and how this would help us solve the problem of static content
    explosion.
  prefs: []
  type: TYPE_NORMAL
- en: Separating code and data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The real magic of infrastructure as code tools, such as Ansible, lies in its
    ability to separate data and code. In our example, the `default.conf` file is
    a configuration file that is specific to an Nginx web server. The configuration
    parameters, such as ports, users, paths, and so on, remain generic and constant
    at all times, no matter who installs and configures them. What is not constant
    are the values those parameters take. That''s what is specific to our organization.
    So, for this, we would decide the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Which port should Nginx run on?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which user should own the web server process?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where should the log files go?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How many worker processes should be run?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our organization-specific policies may also require us to pass different values
    to these parameters based on the environment or geography the hosts run in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible splits these in to two parts:'
  prefs: []
  type: TYPE_NORMAL
- en: The code that is generic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data that is specific to an organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This has two advantages; one advantage is that it solves our problem of static
    data explosion. Now that we have separated the code and data, we can create `config`
    files flexibly and dynamically. The second advantage, you may realize, is now
    that the code and data are split, there is nothing in the code that is specific
    to a particular organization. This makes it easy to share the site with the world
    for anyone who finds it useful. That's exactly what you would find on Ansible-Galaxy
    or even on GitHub, fueling the growth of tools, such as Ansible. Instead of reinventing
    the wheel, you can download the code that someone else has written, customize
    it, fill in the data specific to the code, and get the work done.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, how is this code separate from the data? The answer is that Ansible has
    two primitives:'
  prefs: []
  type: TYPE_NORMAL
- en: Jinja templates (code)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variables (data)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram explains how the resulting file is generated from templates
    and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Separating code and data](img/B03800_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Templates provide placeholders in place of parameter values, which are then
    defined in variables. Variables can then be fed in from various places, including
    roles, playbooks, inventories, and even from the command line when you launch
    Ansible. Let's now understand templates and variables in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Jinja2 templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is **Jinja** all about? **Jinja2** is a very popular and powerful Python-based
    template engine. Since Ansible is written in Python, it becomes the default choice
    for most users, just like other Python-based configuration management systems,
    such as **Fabric** and **SaltStack**. The name Jinja originated from the Japanese
    word for temple, which is similar in phonetics to the word template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the important features of Jinja2 are:'
  prefs: []
  type: TYPE_NORMAL
- en: It is fast and compiled just in time with the Python byte code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an optional sandboxed environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to debug
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It supports template inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The template formation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Templates look very similar to normal text-based files except for the occasional
    variables or code that surrounds the special tags. These get evaluated and are
    mostly replaced by values at runtime, creating a text file, which is then copied
    to the destination host. The following are the two types of tags that Jinja2 templates
    accept:'
  prefs: []
  type: TYPE_NORMAL
- en: '`{{ }}` embeds variables inside a template and prints its value in the resulting
    file. This is the most common use of a template.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`{% %}` embeds statements of code inside a template, for example, for a loop,
    it embeds the if-else statements, which are evaluated at runtime but are not printed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Facts and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have looked at the code that Jinja2 templates provide, let's understand
    where this data comes from, which is then embedded in the template at runtime.
    Data can come from either facts or variables. When it comes to a Jinja2 template,
    the same rules apply to the usage of facts and variables. Facts are a type of
    variable; the differentiating factor here is the origin of the two. Facts are
    automatically available and discovered at runtime, and variables are user-defined.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic variables – facts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A lot of data in our systems is automatically discovered and made available
    to Ansible by the managed hosts during the handshake process. This data is very
    useful and tells us everything about that system, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The hostname, network interface, and IP address
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The system architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The operating system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The disk drives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The processor used and amount of memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whether it is a VM; if yes, is it a virtualization/cloud provider?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Facts are collected at the very beginning of an Ansible run. Remember the line
    in the output that says **GATHERING FACTS *********? That's exactly when this
    happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find facts about any system by running the following command followed
    by a shortened output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding output is in Ansible''s own format and uses its core setup module.
    Akin to the setup module, there is another module by the name `facter`, which
    discovers and displays facts in the format discovered with Puppet, another configuration
    management system. The following is an example of how to use the `facter` module
    to discover facts for the same host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: While using the `facter` module, a point that you need to note is that this
    module is not a core module and comes as part of extra modules. Extras modules
    are a subset of the Ansible module, which is used less frequently and is less
    popular in comparison with the core modules. Moreover, to use the `facter` module,
    you require the "`facter`" and "`ruby-json`" packages preinstalled on the target
    host.
  prefs: []
  type: TYPE_NORMAL
- en: User-defined variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We looked at facts, which are automatically available, and the amount of data
    that is discovered is overwhelming. However, it does not provide us with every
    attribute of our infrastructure that we need. For example, Ansible can not discover:'
  prefs: []
  type: TYPE_NORMAL
- en: Which port we want our web server to listen to
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which user should own a process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which system the users need to create, with which authorization rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All this data is external to a system profile and is to be provided by us, the
    users. It's user-defined for sure, but how and where should we define it? That's
    what we are going to look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Where to define a variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Where a variable can be defined from is a complex phenomenon, as Ansible offers
    abundant choices in this regard. This also offers a lot of flexibility to users
    to configure portions of their infrastructures divergently. For example, all Linux
    hosts in a production environment should use local package repositories or web
    servers in staging and should run on the port 8080\. All this without changing
    the code, and driven by data alone is done, by variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the places from where Ansible accepts variables:'
  prefs: []
  type: TYPE_NORMAL
- en: The `default` directory inside a role
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inventory variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `host_vars` and `group_vars` parameters defined in separate directories
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `host/group vars` parameter defined in an inventory file
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables in playbooks and role parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `vars` directory inside a role and variables defined inside a play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extra variables provided with the `-e` option at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to define a variable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: After looking at where to define the variable from, we will start looking at
    how to define it at various places.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some simple rules you can use to form a valid Ansible variable:'
  prefs: []
  type: TYPE_NORMAL
- en: A variable should always start with a letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It can contain:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Letters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Underscores
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Valid variable | Invalid variable |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `app_port` | `app-port` |'
  prefs: []
  type: TYPE_TB
- en: '| `userid_5` | `5userid` |'
  prefs: []
  type: TYPE_TB
- en: '| `logdir` | `log.dir` |'
  prefs: []
  type: TYPE_TB
- en: We looked at the precedence rules and now we know that there are multiple places
    where you can define variables. Irrespective of the precedence levels, all use
    the same syntax to define a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a simple variable in a key-value pair format, use, `var: value`,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary or hash can be defined as Nginx:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'An array could be defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Templating the Nginx configurations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You have learnt a lot about facts, variables, and templates. Now, lets transform
    our Nginx role to be data driven. We will start templating the `default.conf`
    file for Nginx that we created earlier. The approach toward converting a file
    into a template would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the directories required to hold templates and default variables inside
    a role:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Always start with the actual configuration file, our end result of this process,
    to know all of the parameters it would take. Then, work backwards. For example,
    the configuration for the `default.conf` file on our system is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Identify the configuration parameters that you would like to generate dynamically,
    remove the values for those parameters, note them down separately, and replace
    them with template variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If the values for any of the configuration parameters are supposed to be sourced
    from facts, typically system parameters or topology information, such as the hostname,
    IP address, and so on, then find out the relevant facts with the help of the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To find out the hostname of the system:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the discovered fact inside the template instead of a user-defined variable.
    For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the resulting file inside the template''s directory, ideally with the
    `.j2` extension. For example, for `roles/nginx/templates/default.conf.j2`, the
    resulting file becomes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create `roles/nginx/defaults/main.yml` and store the sane defaults as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the template has been created, change the task in the `configure.yml` file
    to use the template instead of the copy module:![Templating the Nginx configurations](img/B03800_03_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, it''s time to remove the static file we used earlier with the copy
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then it''s time to run the Ansible playbook:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Templating the Nginx configurations](img/B03800_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s analyze what happened during this run:'
  prefs: []
  type: TYPE_NORMAL
- en: We changed the configuration task to use the template instead of the copy module,
    which is reflected in the screenshot when a task shows its changed status
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since the task has been updated, a notification gets triggered, which calls
    the handler to restart the service
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our code tree for the Nginx role looks like the following after we make this
    change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Templating the Nginx configurations](img/B03800_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding another layer – the MySQL role
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been focusing on the single tier of our infrastructure, that
    is, the web server layer. Writing code for just one tier is not a lot of fun.
    Being a cool DevOps team, we will create a multi-tier infrastructure with database,
    web server, and then, a load balancer. We will start creating the MySQL role next,
    apply everything that we have learnt so far, and extend that knowledge with a
    few new concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is our specification for the MySQL role:'
  prefs: []
  type: TYPE_NORMAL
- en: It should install the MySQL server package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should configure '`my.cnf`', which is the main configuration for the MySQL
    server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should start the MySQL server daemon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It should support Ubuntu 12.04 as well as CentOS/RedHat Enterprise 6.x
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the scaffolding for the roles with Ansible-Galaxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have been doing all the hard work to understand and create the directory
    structure required by the roles. However, to make our lives easier, Ansible ships
    with a tool called **Ansible-Galaxy**, which should help us initialize a role
    by creating the scaffolding automatically and could help us follow the best practices.
    Ansible-Galaxy actually does more than that. It's a utility to connect to the
    repository of the freely available Ansible roles hosted at [http://galaxy.ansible.com](http://galaxy.ansible.com).
    This is similar to the way we use **CPAN** or **RubyGems**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by initializing the MySQL role with Ansible-Galaxy using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, the following is the analysis of the preceding command:'
  prefs: []
  type: TYPE_NORMAL
- en: '`init`: This is the subcommand given to Ansible-Galaxy to create the scaffolding'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--init-path` or `-p`: These provide the path to the roles directory, under
    which the directory structure is created'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mysql`: This is the name of the role'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the scaffolding for the roles with Ansible-Galaxy](img/B03800_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The preceding diagram shows the directory layout created after you initialize
    the role with Ansible-Galaxy, which creates an empty role with a structure suitable
    for upload on to Galaxy. It also initializes the necessary components, including
    tasks, handlers, vars, and meta files with placeholders.
  prefs: []
  type: TYPE_NORMAL
- en: Adding metadata to the role
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used the `meta` file earlier to specify the dependency on another role.
    In addition to specifying the dependencies, meta files can specify much more data
    for the roles, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The author and company information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The supported OS and platforms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief description of what a role does
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Ansible versions supported
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The category of software that this role attempts to automate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The licensing information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s update all this data by editing `roles/meta/main.yml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we added metadata to the role, such as the author
    and company details, a brief description of what a role does, its compatibility
    with Ansible versions, the supported platforms, the category the role belongs
    to, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Using variables in tasks and handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have learnt how to use variables in templates. That''s not all the code
    there is used to define the variables. In addition to templates, we can also use
    variables inside tasks, plays, and so on. This time around, we have also committed
    to provide a multiplatform role, supporting Ubuntu and RedHat both. Unlike **Chef**
    and **Puppet**, Ansible uses OS-specific modules (for example, `apt` and `yum`)
    and not platform-independent resources (package). We will have to create OS-specific
    task files and call them selectively based on the OS they are going to run on.
    Here''s how we do so:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will find a fact that will determine the OS platform/family. We have a couple
    of options here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_distribution`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ansible_os_family`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: RedHat, CentOS, and Amazon Linux are all based on `rpm` and have similar behavior.
    The same goes for Ubuntu and Debian operating systems, which are part of the same
    platform family. Hence, we choose to use the `ansible_os_family` fact, which will
    give us wider support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will define variables from two places in the roles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: From the default `vars` file with the sane defaults for Debian.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: From the variables specific to `os_family` if not Debian.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also create OS-specific task files, since we may need to call different
    modules (`apt` versus `yum`) and additional tasks that are specific to that OS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For handlers and tasks, we will use variables to provide OS-specific names (for
    example, MySQL versus mysqld, for service).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, we will create the `main.yml` file, which will selectively include
    host-specific vars as well as task files by checking the value of this fact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will begin with the creation of variables. Let''s set up the sane defaults
    for Debian/Ubuntu inside the `/mysql/defaults/main.yml` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Then it will run on RedHat/CentOS machines, however, we will need to override
    a few of these variables to configure the RedHat-specific parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that the filename should match the exact name (RedHat) that is returned
    by the `ansible_os_family` fact with the correct case.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create and edit the `roles/mysql/vars/RedHat.yml` file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will create the `group_vars` fact with one variable to override
    our default settings. You have learnt that you can specify variables in the `inventory`
    files, the `group_vars` and the `host_vars` facts. We will start using the `group_vars`
    fact for now. You could either create these in your inventory file or create a
    separate directory for it with the name `group_vars`. We are going to take the
    second approach, which is recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Edit the `group_vars`/`all` file and add the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Creating tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s now time to create tasks. Following the best practices, we will split
    tasks into multiple files and use include statements, just like we did for Nginx.
    Let''s start by creating the default `main.yml` file inside `roles/mysql/tasks`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw the `include` statements earlier. What''s new here is the `include_vars`
    fact and the use of the `ansible_os_family` fact. If you notice:'
  prefs: []
  type: TYPE_NORMAL
- en: We are using the `ansible_os_family` fact here with the `include_vars` fact
    to determine whether to include OS-specific variables when the OS family is not
    Debian. Why not for the Debian system? That's because we are already specifying
    Debian-specific configurations in the `default` file. The `include_vars` fact
    works well with the preceding conditionals.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also calling OS-specific installation scripts using the `when` condition.
    We have included two scripts for now to support the Debian and RedHat families.
    However, later on, we could just extend the scripts by adding more `install_<os_family>.yml`
    scripts to support additional platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s create the install tasks for Debian and RedHat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Then edit the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding command, edit the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding example, we used the `apt` and `yum` modules, respectively,
    for Debian- and RedHat-based systems. Following the best practices, we will write
    a data-driven role by providing the package name using a variable `mysql_pkg`.
    This variable is set based on the platform it runs on. Let''s take a look at the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a task to configure MySQL. Since we know that every
    configuration file should be a template, we will create one for the `my.cnf` file,
    the default configuration file for the MySQL server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then edit the file, as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We created a template with the `.j2` extension since it's a Jinja2 template.
    It's not a must, but a recommended practice.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All configuration parameters come from variables in the `{{var}}` format. This
    is a recommended practice for managing a configuration file. We could let the
    attribute precedence decide where the values comes from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's good practice to add a notice to every file being managed by Ansible. This
    will avoid possible manual updates or ad hoc changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will write a task that will manage this template, and copy over the resulting
    file to the desired path on the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We have a common configuration file template; however, the path to copy this
    varies from platform to platform, also based on the flavor of MySQL that you plan
    to use. Here, we are using a MySQL distribution that comes with the Ubuntu and
    CentOS repositories by default, and we will set the `mysql_cnfpath` path from
    the role variables, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On Ubuntu/Debian, use the command: `mysql_cnfpath = /etc/mysql/my.cnf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On RedHat/CentOS, use the command: `mysql_cnfpath = /etc/my.cnf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, we are sending the notification to the MySQL service restart handler.
    This will make sure that if there are any changes to the configuration file, the
    service will automatically be restarted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To manage a service, we will create a service task and handler:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then edit the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The handler:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'After running the preceding commands, edit the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Here, the task and handler are similar to the Nginx service, so nothing much
    needs to be described. The only change is that we are using the `mysql_service`
    variable to decide the service name to start, or restart, the service.
  prefs: []
  type: TYPE_NORMAL
- en: Using variables in playbooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables can also be specified in playbooks. The preferred method of doing
    so would be to pass them as role parameters, an example of which is shown as follows.
    This is typically useful when you have defaults in the role and you'd like to
    override some configuration parameters specific to your setup. That way, roles
    are still generic and sharable, and do not contain organization-specific data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a playbook to manage our databases and then we will
    include it in the site-wide playbook, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Then edit the file, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we assume that the host''s inventory contains a host group by the name
    `db`. In our example, we have two `db` servers, one running on Ubuntu, the other
    running on CentOS. This is added as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding playbook, we used a parameterized role, which overrides one
    variable, that is, `mysql_bind`. The value is set from a multilevel fact.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using variables in playbooks](img/B03800_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A multilevel fact can also be specified as `ansible_eth1["ipv4"]["address"]`
    and both the formats are valid. Parameterized roles are also useful when we want
    to create multiple instances of the role, for example, virtual hosts and WordPress
    instances running on different ports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now include this playbook in the top-level `site.yml` file using the
    `include` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Edit the `site.yml` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Applying a MySQL role to the DB servers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We are all set to configure our database servers. Let''s go ahead and apply
    the newly created role to all the `db` servers we have in the inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The following image contains the snippet of the output which is only relevant
    to the database play:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a MySQL role to the DB servers](img/B03800_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have explained the Ansible run in the previous chapters, when we created
    our first playbook as well as when we applied the Nginx role. The only new concept
    here is the `include_var` part. Ansible will check our condition based on the
    `ansible_os_family` fact and call variables specific to the OS. In our case, we
    have one Ubuntu and CentOS host each, and both of them call for the `RedHat.yml`
    file when it runs on the CentOS host alone.
  prefs: []
  type: TYPE_NORMAL
- en: What will be really interesting here is to find out what happened to our configuration
    files on each platform and which variables took precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Variable precedence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We specified variable defaults, used them in inventory files, and defined the
    same variable from different places (for example, defaults, vars, and inventory).
    Let's now analyze the output of the templates to understand what happened with
    all those variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the figure showing the `my.cnf` file on Ubuntu:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable precedence](img/B03800_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The following is the analysis of the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: The file has a notice in the comments section. This can deter admins from making
    manual changes to the file.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Most of the variables come from the defaults in a role. This is because Debian
    is our default family of operating systems and we already have sane defaults set
    for it. Similarly, for other operating system platforms, we are setting variable
    defaults from the `vars` directory in a role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though the `bind_address` parameter is specified in the defaults and `group_vars`,
    it takes a value from the playbook's role parameter, which has a higher precedence
    over the other two levels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram explains what happens when there are variables defined
    at various levels. All of them are merged at runtime. If the same variables are
    defined in more than one place, the precedence rules apply:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable precedence](img/B03800_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To understand the precedence rules, let''s look at what happened on our CentOS
    host. The following is the `my.cnf` file created on CentOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable precedence](img/B03800_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As seen in the preceding figure, in the case of CentOS, we see some interesting
    results:'
  prefs: []
  type: TYPE_NORMAL
- en: The values for **user**, **pid**, **datadir**, and **port** come from the defaults.
    We have looked at the merge order. If the variables are not identical, they are
    merged to create the final configuration.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value for a socket comes from vars as that's the only place it has been
    defined. Nevertheless, we want this socket to be constant for the RedHat-based
    system, hence, we specified it in the vars directory of the role.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `bind_address` parameter comes from the vars directory again. This is interesting
    as we have the `mysql_bind` variable defined at the following locations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Default` in a role'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_vars`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`playbook`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vars` in a role'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure depicts the precedence rules when we define the same variable
    more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Variable precedence](img/B03800_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since our role defines the `bind_address` parameter in the `vars` directory,
    it takes precedence over the rest.
  prefs: []
  type: TYPE_NORMAL
- en: There is a way to override a role parameter using extra variables or the `-e`
    switch while running Ansible. This is the supreme level of precedence for a variable
    that Ansible manages.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding launch command, we used the `-e` switch, which will override
    all the other variable levels and make sure that the MySQL server is bound to
    `127.0.0.1`.
  prefs: []
  type: TYPE_NORMAL
- en: The best practices for variable usage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Overwhelming, eh? Do not worry. We will give you the recommendations on the
    best practices while using variables:'
  prefs: []
  type: TYPE_NORMAL
- en: Start with defaults in a role. This has the lowest precedence of all. This is
    also a good place to provide the sane defaults of your application, which can
    be later overridden from various places.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Group variables are very useful. A lot of the time we will do region-specific
    or environment-specific configurations. We would also apply certain roles to a
    certain group of servers, for example, for all web servers in Asia, we apply the
    Nginx role. There is also a default group by the name "`all`", which will contain
    all the hosts for all groups. It's a good practice to put the variables common
    for all groups in "`all`" (`group_vars/all`), which can then be overridden by
    more specific groups.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there are host-specific exceptions, use `hosts_vars`, for example, `host_vars/specialhost.example.org`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you would like to separate variables in different files, create directories
    named after the hosts and put the variable files inside it. All files inside those
    directories will be evaluated:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`group_vars/asia/web`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host_vars/specialhost/nginx`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`host_vars/specialhost/mysql`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If you would like to keep your roles generic and sharable, use defaults in the
    roles and then specify organization-specific variables from playbooks. These can
    be specified as role parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you would like role variables to always take precedence over inventory variables
    and playbooks, specify them in the `vars` directory inside a role. This is useful
    for providing role constants for specific platforms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, if you would like to override any of the preceding variables and provide
    some data during runtime, provide an extra variable with Ansible commands using
    the `-e` option.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'By now, our tree for the MySQL role and DB playbook should look like the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The best practices for variable usage](img/B03800_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Review questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Do you think you''ve understood the chapter well enough? Try answering the
    following questions to test your understanding:'
  prefs: []
  type: TYPE_NORMAL
- en: How are Jinja2 templates different from static files?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are facts? How are they discovered?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between `{{ }}` and `{% %}` in the context of Jinja2
    templates?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you use a variable anywhere apart from templates? If yes, where?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you define a variable `foo` in the `vars` directory in a role and the same
    variable in the `hosts_var` file, which of these will take precedence?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you write Ansible roles that are supported on multiple platforms?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Where can you specify the author and licensing information in a role?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you provide variables while launching an Ansible-playbook command?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which command would you use to create a directory structure required by the
    roles automatically?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you override a variable specified in the `vars` directory of a role?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started this chapter by learning about why and how to separate data from
    code using Ansible variables, facts, and Jinja2 templates. You learnt how to create
    data-driven roles by providing variables and facts in templates, tasks, handlers,
    and playbooks. Additionally, we created a new role for the database tier, which
    supports both the Debian and RedHat families of operating systems. You learnt
    what system facts are and how they are discovered and used. You learnt how variables
    can be specified from more than one place, how they are merged, and the precedence
    rules. Finally, you learnt about the best practices for using variables.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will work with custom commands and scripts, understand
    what registered variables are, and deploy a sample WordPress application using
    all this information.
  prefs: []
  type: TYPE_NORMAL
