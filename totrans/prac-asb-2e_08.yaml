- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible can help you automate almost all your daily IT tasks, from mundane tasks,
    such as applying patches or deploying configuration files, to deploying entirely
    new infrastructure as code. The use of, and engagement with, Ansible has been
    growing year by year as more and more people realize its power and simplicity.
    You will find many examples of Ansible playbooks, roles, blog articles, and so
    on across the internet, and combined with resources such as this book, you will
    become proficient at writing your own Ansible playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: Yet, how can you tell whether an example you found on the internet is actually
    a good way of doing things? In this chapter, we will take you through a practical
    guide of the best practices in Ansible, showing you what is currently considered
    good practice when it comes to directory structure and playbook layout, how to
    make effective use of inventories (especially on the cloud), and how best to differentiate
    your environments. By the end of this chapter, you should be able to proceed with
    confidence in writing everything from small single-task playbooks to large-scale
    playbooks for complex environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The preferred directory layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Differentiating between different environment types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The proper approach to defining group and host variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using top-level playbooks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Leveraging version control tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting OS and distribution variances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Porting between Ansible versions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have set up your control host with Ansible, as
    in [*Chapter 1*](B20846_01.xhtml#_idTextAnchor015), *Getting Started with Ansible*,
    and that you are using the most recent version available; the examples in this
    chapter were tested on Ansible 2.15\. This chapter also assumes that you have
    at least one additional host to test against; ideally, this should be Linux-based.
    Although we will give specific examples of hostnames in this chapter, you are
    welcome to substitute them with your own hostname and/or IP addresses, and details
    of how to do this are provided in the appropriate places.
  prefs: []
  type: TYPE_NORMAL
- en: The code bundle used in this chapter is available at [https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%208](https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%208).
  prefs: []
  type: TYPE_NORMAL
- en: The preferred directory layout
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have explored Ansible throughout this book, we have shown many times that
    the more your playbook grows in size and scale, the more likely you are to want
    to divide it up into multiple files and directories. A great example of this is
    roles, which we covered in [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks
    and Roles*, where we defined roles to not only enable us to reuse common automation
    code but also to split up what could potentially be a massive, single playbook
    into smaller, logically organized, manageable chunks. We also looked, in [*Chapter
    3*](B20846_03.xhtml#_idTextAnchor158), *Defining Your Inventory*, at the process
    of defining your inventory file and how you can also split this up across multiple
    files and directories. What we have not looked at, however, is how we can put
    all of this together. All of this is documented in the official Ansible documentation
    at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.xhtml#content-organization](https://docs.ansible.com/ansible/latest/user_guide/playbooks_best_practices.xhtml#content-organization).
  prefs: []
  type: TYPE_NORMAL
- en: However, in this chapter, let’s get started with a practical example of this
    to show you a great way of setting up your directory structure for a simple role-based
    playbook that has two different inventories—one for a development environment
    and one for a production environment (you would want to keep these separate in
    any real-world use case; although, ideally, you should be able to execute the
    same plays on both for consistency and for testing purposes).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get started by building the directory structure:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory tree for your development inventory with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[app]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app01.dev.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app02.dev.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To further our example, we’ll add a group variable to our app group. As discussed
    in [*Chapter 3*](B20846_03.xhtml#_idTextAnchor158), *Defining Your Inventory*,
    create a file called `app.yml` in the `group_vars` directory we created in the
    previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create a `production` directory structure using the same method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[app]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app01.prod.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app02.prod.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll define a different value for the `http_port` group variable for
    our `production` inventory. Add the following contents to `inventories/production/group_vars/app.yml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That completes our inventory definition. Next, we will add any custom modules
    or plugins that we might find useful for our playbook. Suppose we want to use
    the `remote_filecopy.py` module we created in [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279),
    *Creating and Consuming* *Modules*. Just as we discussed in that chapter, we first
    create the directory for this module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Then, we add the `remote_filecopy.py` module to this library. We won’t relist
    the code here to save space, but you can copy it from the section called *Developing
    custom modules* from [*Chapter 5*](B20846_05.xhtml#_idTextAnchor279), *Creating
    and Consuming* *Modules*, or take advantage of the example code that accompanies
    this book on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same can be done for the plugins; if we also want to use the `filter` plugin
    that we created in [*Chapter 6*](B20846_06.xhtml#_idTextAnchor318), *Creating
    and Consuming* *Plugins*, we would create an appropriately named directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Then, copy the `filter` plugin code into this directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we’ll create a role to use in our new playbook structure. Naturally,
    you will have many roles, but we’ll create one as an example and then you can
    repeat the process for each role. We’ll call our role `installapp` and use the
    `ansible-galaxy` command (covered in [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207),
    *Playbooks and Roles*) to create the directory structure for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in our `roles/installapp/tasks/main.yml` file, we’ll add the following
    contents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we’ve reused a number of examples from earlier chapters
    of this book. You can also define the handlers, variables, default values, and
    so on to the role, as discussed previously, but for our example, this will suffice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final stage in creating our best practice directory structure is to add
    a top-level playbook to run. By convention, this will be called `site.yml` and
    it will have the following simple contents (note that the directory structure
    we have built takes care of many things, allowing the top-level playbook to be
    incredibly simple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For the purpose of clarity, your resulting directory structure should look
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can simply run our playbook in the normal manner. For example, to run
    it on the `development` inventory, execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, run the following for the `production` inventory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the appropriate hosts and associated variables are picked up for
    each inventory and how tidy and well organized our directory structure is. This
    is the ideal way for you to lay out your playbooks and will ensure that they can
    be scaled up to whatever size you need them to be, without them becoming unwieldy
    and difficult to manage or troubleshoot. In the next section, we will explore
    differentiating between different environment types.
  prefs: []
  type: TYPE_NORMAL
- en: Differentiating between different environment types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In almost every business, you will need to split your technology environment
    by type. For example, you will almost certainly have a development environment,
    where all the testing and development work is performed, and a production environment,
    where all of the stable test code is run. The environments should (in a best-case
    scenario) make use of the same Ansible playbooks—after all, the logic is that
    if you can successfully deploy and test an application in your development environment,
    then you should be able to deploy it in the same way in a production environment
    and have it work just as well. However, there are always differences between the
    two environments, not just in the hostnames but also sometimes in the parameters,
    the load balancer names, the port numbers, and so on—the list can seem endless.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the *The preferred directory layout* section of this chapter, we covered
    a way of differentiating between a development and production environment using
    two separate inventory directory trees. This is how you should proceed when it
    comes to differentiating these environments; obviously, we won’t repeat the examples,
    but it’s important to note that when working with multiple environments, your
    goals should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Try and reuse the same playbooks for all of your environments that run the same
    code. For example, if you deploy a web app in your development environment, you
    should be confident that your playbooks will deploy the same app in the production
    environment (and your **Quality Assurance** (**QA**) environment, as well as any
    others that it might need to be deployed in).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This means that not only are you testing your application deployments and code
    but you are also testing your Ansible playbooks and roles as part of your overall
    testing process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your inventories for each environment should be kept in separate directory trees
    (as we saw in the *The preferred directory layout* section of this chapter), but
    all roles, playbooks, plugins, and modules (if used) should be in the same directory
    structure (this should be the case for both environments).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is normal for different environments to require different authentication
    credentials; you should keep these separate not only for security but also to
    ensure that playbooks are not accidentally run in the wrong environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Your playbooks should be in your version control system, just as your code is.
    This enables you to track changes over time and ensure that everyone is working
    from the same copy of the automation code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you pay attention to these simple pointers, you will find that your automation
    workflow becomes a real asset to your business and ensures reliability and consistency
    across all of your deployments. Conversely, failure to follow these pointers puts
    you at risk of experiencing the dreaded, *it worked in development but it doesn’t
    work in production* deployment failures that so often plague the technology industry.
    Let’s now build on this discussion in the next section by looking at best practices
    when handling host and group variables—something that, as we saw in the *The preferred
    directory layout* section, you need to apply, especially when working with multiple
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: The proper approach to defining group and host variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When working with group and host variables, you can split them up using the
    directory-based approach we used in the *The preferred directory layout* section.
    However, there are a few additional pointers to managing this that you should
    be aware of. First and foremost, you should always pay attention to variable precedence.
    A detailed list of variable precedence order can be found at [https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable](https://docs.ansible.com/ansible/latest/user_guide/playbooks_variables.xhtml#variable-precedence-where-should-i-put-a-variable).
    However, the key takeaways for working with multiple environments are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Host variables are always of a higher order of precedence than group variables,
    so you can override any group variable with a host variable. This behavior is
    useful if you take advantage of it in a controlled manner, but can yield unexpected
    results if you are not aware of it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is a special group variables definition called `all`, which is applied
    to all inventory groups. This has a lower order of precedence than specifically
    defined group variables.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What happens if you define the same variable twice in two groups? If this happens,
    both groups have the same order of precedence, so which one wins? To demonstrate
    this (and our earlier examples), we will create a simple practical example for
    you to follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get started, let’s create a directory structure for our inventories. To
    keep this example as concise as possible, we will only create a development environment.
    However, you are free to expand on these concepts by building on the more complete
    example we covered in the *The preferred directory layout* section of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an inventory directory structure with the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[app]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app01.dev.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app02.dev.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create a special group variable file for all the groups in the inventory;
    this file will be called `inventories/development/group_vars/all.yml` and should
    contain the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let’s create a simple playbook called `site.yml` to query and print
    the value of the variable we just created:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we run this playbook, we’ll see that the variable (which we only defined
    in one place) takes the value we would expect:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'http_port: 8081'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have now defined the same variable twice—once in a special group called
    `all` and once in the `app` group (which both servers in our `development` inventory
    belong to). So, what happens if we now run our playbook? The output should appear
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[app]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app01.dev.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app02.dev.example.com
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[centos:children]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[newcentos:children]'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: app
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s redefine the `http_port` variable for the `centos` group by creating
    a file called `inventories/development/group_vars/centos.yml`, which contains
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Just to add to the confusion, let’s also define this variable for the `newcentos`
    group in `inventories/development/group_vars/newcentos.yml`, which will contain
    the following content:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ve now defined the same variable four times at the group level! Let’s rerun
    our playbook and see which value comes through:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '---'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'http_port: 9090'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, if we run our playbook one final time, we will see that the value we defined
    at the host level completely overrides any value that we set at the group level
    for `app01.dev.example.com`. `app02.dev.example.com` is unaffected as we did not
    define a host variable for it, so the next highest level of precedence—the group
    variable from the `newcentos` group—won:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this knowledge, you can now make advanced decisions about how to structure
    your variables within your inventory to make sure you achieve the desired results
    at both a host and group level. It’s important to know about variable precedence
    ordering, as these examples have demonstrated, but following the documented order
    will also allow you to produce powerful, flexible playbook inventories that work
    well across multiple environments. Now, you may have noticed that, throughout
    this chapter, we have used a top-level playbook in our directory structure, called
    `site.yml`. We will look at this playbook in greater detail in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using top-level playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In all of the examples so far, we have built out using the best practice directory
    structure recommended by Ansible and continually referred to a top-level playbook,
    typically called `site.yml`. The idea behind this playbook (and, indeed, its common
    name across all of our directory structures) is so that it can be used across
    your entire server estate—that is to say, your **site**.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, this is not to say that you have to use the same set of playbooks
    across every server in your infrastructure or for every single function; rather,
    it means only you can make the best decision as to what suits your environment
    best. However, the whole aim of Ansible automation is that the created solution
    is simple to run and operate. Imagine handing a playbook directory structure with
    100 different playbooks to a new system administrator—how would they know which
    ones to run and in which circumstances? The task of training someone to use the
    playbooks would be immense and would simply move complexity from one area to another.
  prefs: []
  type: TYPE_NORMAL
- en: At the other end of the spectrum, you could make use of the `when` clauses with
    facts and inventory grouping, such that your playbook knows exactly what to run
    on each server in every possible circumstance. This, of course, is unlikely to
    happen, and the truth is that your automation solution will end up somewhere in
    the middle.
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing is that, on receipt of a new playbook directory structure,
    a new operator at least knows what the starting point for both running the playbooks
    and understanding the code is. If the top-level playbook they encounter is always
    `site.yml`, then at least everyone knows where to start. Through the clever use
    of roles and the `import_*` and `include_*` statements, you can split your playbook
    up into logical portions of reusable code, as we previously discussed, all from
    one playbook file.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have learned about the importance of top-level playbooks, let’s
    take a look, in the next section, at how to take advantage of version control
    tools to ensure good practices are adhered to when it comes to centralizing and
    maintaining your automation code.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging version control tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we discussed earlier in this chapter, it is vital that you version control
    and test not only your code but also your Ansible automation code. This should
    include inventories (or dynamic inventory collections), any custom modules, plugins,
    roles, and playbook code. The reason for this is simple—the ultimate goal of Ansible
    automation is likely to be to deploy an entire environment using a playbook (or
    set of playbooks). This might even involve deploying infrastructure as code, especially
    if you are deploying to a cloud environment.
  prefs: []
  type: TYPE_NORMAL
- en: Any changes to your Ansible code could mean big changes to your environment
    and possibly even determine whether an important production service works or not.
    As a result, it is vital that you maintain a version history of your Ansible code
    and that everyone works from the same version. You are free to choose the version
    control system that suits you best; most corporate environments will already have
    some kind of version control system in place. However, if you haven’t worked with
    version control systems before, we recommend that you sign up for a free account
    somewhere such as GitHub or GitLab, which both offer version control repositories
    for free, along with more advanced paid-for plans.
  prefs: []
  type: TYPE_NORMAL
- en: A complete discussion of version control with Git is beyond the scope of this
    book, but there are entire books devoted to the subject. However, we will take
    you through the simplest possible use case. It is assumed, in the following examples,
    that you are using a free account on GitHub, but if you are using a different
    provider, simply change the URLs to match those given to you by your version control
    repository host.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to this, you will need to install the command-line Git tools on
    your Linux host.
  prefs: []
  type: TYPE_NORMAL
- en: 'On CentOS, you would install these as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'On Ubuntu, the process is similarly straightforward:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'On macOS, you can use the `brew` package manager to install Git tools as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once the tools are installed and your account is set up, your next task is to
    clone a Git repository to your machine. If you want to start working with your
    own repository, you will need to set this up with your provider—excellent documentation
    is provided by both GitHub and GitLab and you should follow this to set up your
    first repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once it is set up and initialized, you can clone a copy to your local machine
    to make changes to your code. This local copy is called a working copy, and you
    can work through the process of cloning it and making changes as follows (note
    that these are purely hypothetical examples to give you an idea of the commands
    you will need to run; you should adapt them for your own use case):'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone your `git` repository to your local machine to create a working copy
    using a command such as the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change to the directory of the code you cloned (the working copy) and make
    any code changes you need to make:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Be sure to test your code and, when you are happy with it, add the changed
    files that are ready for committing a new version using a command such as the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: $ git commit -m 'Added new spongle-widget deployment to myplaybook.yml'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[master ed14138] Added new spongle-widget deployment to myplaybook.yml'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Committer: Daniel Oh <doh@danieloh.redhat.com>'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Your name and email address were configured automatically based
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: on your username and hostname. Please check that they are accurate.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can suppress this message by setting them explicitly. Run the
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: following command and follow the instructions in your editor to edit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'your configuration file:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git config --global --edit
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After doing this, you may fix the identity used for this commit with:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: git commit --amend --reset-author
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 1 file changed, 1 insertion(+), 1 deletion(-)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Right now, all of these changes live solely in the working copy on your local
    machine. This is good by itself, but it would be better if the code was available
    to everyone who needs to view it on the version control system. To push your updated
    commits back to (for example) GitHub, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That’s all there is to it!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, other collaborators can clone your code just as we did in *Step 1*. Alternatively,
    if they already have a working copy of your repository, they can update their
    working copy using the following command (you can also do this if you want to
    update your working copy to see changes made by someone else):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are some incredibly advanced topics and use cases for Git that are beyond
    the scope of this book. However, you will find that roughly 80% of the time, the
    preceding commands are all the Git command-line knowledge you need. There are
    also a number of graphical frontends to Git, as well as code editors and **Integrated
    Development Environments** (**IDEs**), that integrate with Git repositories and
    can assist you further in taking advantage of them. With that complete, let’s
    take a look at how to ensure you can use the same playbook (or role) across multiple
    hosts, even though they might have different OSs and versions.
  prefs: []
  type: TYPE_NORMAL
- en: Setting OS and distribution variances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated earlier, our goal is to try to use the same automation code as widely
    as possible. However, as much as we try to standardize our technology environments,
    variants always creep in. For example, it is impossible to simultaneously perform
    a major upgrade on all your servers in one go, so when a major new OS version
    comes out, such as **Red Hat Enterprise Linux** (**RHEL**) 8 or Ubuntu Server
    20.04, it is inevitable that some machines will remain on older versions as others
    are upgraded. Similarly, an environment might be standardized on Ubuntu, but then
    an application is introduced that has only been certified to run on CentOS. In
    short, as important as standardization is, variances will always creep in.
  prefs: []
  type: TYPE_NORMAL
- en: When writing Ansible playbooks, especially roles, your goal should be for them
    to be as widely applicable as possible throughout your environment. A classic
    example of this is package management—let’s say you are writing a role to install
    the Apache 2 web server. If you have to support both Ubuntu and CentOS with this
    role, not only do you have different package managers to deal with (`yum` and
    `apt`) but you also have different package names (`httpd` and `apache2`).
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 4*](B20846_04.xhtml#_idTextAnchor207), *Playbooks and Roles*, we
    looked at how to apply conditions to tasks using the `when` clause, along with
    facts gathered by Ansible, such as `ansible_distribution`. However, there is another
    way of running tasks on specific hosts that we haven’t yet looked at. In the same
    chapter, we also looked at the concept of defining multiple plays in one playbook—there
    is a special module that can create inventory groups for us based on Ansible facts,
    and we can leverage this along with multiple plays to create a playbook that runs
    the appropriate tasks on each host based on its type. This is best explained by
    a practical example, so let’s get started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume that we are using the following simple inventory file for this example,
    which has two hosts in a single group called `app`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Let’s now build a simple playbook that demonstrates how you can group the groups
    using an Ansible fact so that the OS distribution determines which play in a playbook
    is run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create this playbook and observe its operation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new playbook—we’ll call it `osvariants.yml`—with the following
    `Play` definition. It will also contain a single task, as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The playbook structure will be, by now, incredibly familiar to you. However,
    the use of the `group_by` module is new. It dynamically creates new inventory
    groups based on the key that we specify—in this example, we are creating groups
    based on a key comprising the `os_` fixed string, followed by the OS distribution
    fact obtained from the `Gathering Facts` stage. The original inventory group structure
    is preserved and unmodified, but all the hosts are also added to the newly created
    groups according to their facts.
  prefs: []
  type: TYPE_NORMAL
- en: So, the two servers in our simple inventory remain in the `app` group, but if
    they are based on Ubuntu, they will be added to a newly created inventory group
    called `os_Ubuntu`. Similarly, if they are based on CentOS, they will be added
    to a group called `os_CentOS`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Armed with this information, we can go ahead and create additional plays based
    on the newly created groups. Let’s add the following `Play` definition to the
    same playbook file to install Apache on CentOS:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a perfectly normal `Play` definition that uses the `yum` module to install
    the `httpd` package (as required on CentOS). The only thing that differentiates
    it from our earlier work is the `hosts` definition at the top of the play. This
    uses the newly created inventory group created by the `group_by` module in the
    first play.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, we can add a third `Play` definition—this time, for installing the
    `apache2` package on Ubuntu using the `apt` module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If our environment is based on CentOS servers and we run this playbook, the
    results are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Notice how the task to install Apache on CentOS was run. It was run this way
    because the `group_by` module created a group called `os_CentOS` and our second
    play only runs on hosts in the group called `os_CentOS`. As there were no servers
    running on Ubuntu in the inventory, the `os_Ubuntu` group was never created and
    so the third play does not run. We receive a warning about the fact that there
    is no host pattern that matches `os_Ubuntu`, but the playbook does not fail—it
    simply skips this play.
  prefs: []
  type: TYPE_NORMAL
- en: We provided this example to show you another way of managing the inevitable
    variance in OS types that you will come across in your automation coding. At the
    end of the day, it is up to you to choose the coding style most appropriate to
    you. You can make use of the `group_by` module, as detailed here, or write your
    tasks in blocks and add a `when` clause to the blocks so that they only run when
    a certain fact-based condition is met (for example, the OS distribution is CentOS)—or
    perhaps even a combination of the two. The choice is ultimately yours, and these
    different examples are provided to empower you with multiple options that you
    can choose between to create the best possible solution for your scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, let’s round off this chapter with a look at porting your automation
    code between Ansible versions.
  prefs: []
  type: TYPE_NORMAL
- en: Porting between Ansible versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible is a fast-moving project, and with releases and new features added,
    new modules (and module enhancements) are released and the inevitable bugs that
    come with the software are fixed. There is no doubt that you will end up writing
    your code against one version of Ansible only to need to run it on a newer version
    again at some point. By way of example, when we started writing the second edition,
    the current release of Ansible was 2.15.
  prefs: []
  type: TYPE_NORMAL
- en: 'Often, you will find that your code from an earlier version *just about works*
    when you upgrade it, but this isn’t always a given. Modules are sometimes deprecated
    (although usually not without warning) and features do change. You can find more
    details on the 2.15 release notes here: [https://github.com/ansible/ansible/blob/v2.15.2/changelogs/CHANGELOG-v2.15.rst](https://github.com/ansible/ansible/blob/v2.15.2/changelogs/CHANGELOG-v2.15.rst).'
  prefs: []
  type: TYPE_NORMAL
- en: So, the question remains—how can you ensure that your playbooks, roles, modules,
    and plugins still work when you update your Ansible installation?
  prefs: []
  type: TYPE_NORMAL
- en: 'The first part of the answer is to establish which version of Ansible you are
    starting from. For example, let’s say you are preparing for the release of Ansible
    2.10\. If you query the version of Ansible you already have installed and see
    something like the following, then you know you are starting from Ansible release
    2.15.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, your first port of call should be to review the porting guide for the Ansible
    release; a porting guide is normally written for every major release (such as
    2.10, 8, and so on). Note that Ansible 8 includes Ansible Core 2.15.
  prefs: []
  type: TYPE_NORMAL
- en: The guide for Ansible 8 can be found at [https://docs.ansible.com/ansible/latest/porting_guides/porting_guide_8.xhtml](https://docs.ansible.com/ansible/latest/porting_guides/porting_guide_8.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: If we review this document, we can see that there are a number of changes coming—whether
    they are significant to you really depends on the code you are running. For example,
    if we review the *Added Collections* section of the guide, we can see that the
    `grafana.grafana` (version `2.0.0`) collection has been added.
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding link, there are several known issues in the eight
    releases of Ansible. To that end, it is also important to note that the porting
    guides are written from the perspective of an upgrade from the previous major
    release. If you query your Ansible version and it returns the following, you are
    porting from Ansible 2.8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: If you move straight to Ansible 8 (Core 2.15), then you need to review the porting
    guides for both 2.9 (which covers the changes required to your code between releases
    2.8 and 2.9) and 2.10 (which covers the changes required to upgrade from 2.9 to
    2.10). An index of all the porting guides can be found on the official Ansible
    website at [https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.xhtml](https://docs.ansible.com/ansible/devel/porting_guides/porting_guides.xhtml).
  prefs: []
  type: TYPE_NORMAL
- en: Another great source of information, especially more fine-grained information,
    on the changes between releases is the changelogs. These are released and updated
    for every minor release and can currently be found in the official Ansible GitHub
    repository on the `stable` branch for the release you wish to query. For example,
    if you wish to review all the changelogs for Ansible 2.15, you would need to go
    to [https://github.com/ansible/ansible/blob/stable-2.15/changelogs/CHANGELOG-v2.15.rst](https://github.com/ansible/ansible/blob/stable-2.15/changelogs/CHANGELOG-v2.15.rst).
  prefs: []
  type: TYPE_NORMAL
- en: The trick to porting code between Ansible releases (if, indeed, you can call
    it a trick) is simply to read the excellent documentation released by the Ansible
    project team. A lot of effort goes into creating this documentation, so you are
    advised to make good use of it. That concludes our look at the best practices
    for working with Ansible. We hope you have found this chapter valuable.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible automation projects often start out small, but as people come to realize
    the power and simplicity of Ansible, both the code and the inventories tend to
    grow at an exponential pace (at least in my experience). It is important that
    in the push for greater automation, the Ansible automation code and the infrastructure
    itself don’t become another headache. By embedding a few good practices early
    on and applying them consistently throughout your automation journey with Ansible,
    you will find that managing your Ansible automation is easy and is a true benefit
    to your technology infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned new ways of differentiating environments by OS
    type, as well as more about variable precedence and how to leverage it when working
    with host and group variables. You then explored the importance of the top-level
    playbook, before looking at how to make use of version control tools to manage
    your automation code. Finally, you explored the new techniques for creating single
    playbooks that will manage servers of different OS versions and distributions,
    before finally looking at the important topic of porting your code to new Ansible
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at some of the more advanced ways that you
    can use Ansible to take care of some special cases that may arise on your automation
    journey.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a safe and easy way to manage (that is, modify, fix, and create) code
    changes continuously and share them with others?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Playbook revision
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Task history
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Ad hoc creation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With a Git repository
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Log management
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false? Ansible Galaxy supports sharing roles with other users from
    a central, community-supported repository:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True or false? Ansible modules are guaranteed to be available in all future
    releases of Ansible:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Manage multiple repositories, versions, or tasks by creating branches and tags
    to control multiple versions effectively. Refer to the following links for more
    details:'
  prefs: []
  type: TYPE_NORMAL
- en: 'How to use Git tagging: [https://git-scm.com/book/en/v2/Git-Basics-Tagging](https://git-scm.com/book/en/v2/Git-Basics-Tagging%0D)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'How to use Git branches: [https://git-scm.com/docs/git-branch](https://git-scm.com/docs/git-branch)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
