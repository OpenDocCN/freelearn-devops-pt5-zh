<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-30"><a id="_idTextAnchor027"/>2</h1>
<h1 id="_idParaDest-31"><a id="_idTextAnchor028"/>Setting Up a Working Environment</h1>
<p>In the previous chapter, we learned what Docker containers are and why they’re important. We learned what kinds of problems containers solve in a modern software supply chain. In this chapter, we are going to prepare our personal or working environment to work efficiently and effectively with Docker. We will discuss in detail how to set up an ideal environment for developers, DevOps, and operators that can be used when working with Docker containers.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>The Linux command shell</li>
<li>PowerShell for Windows</li>
<li>Installing and using a package manager</li>
<li>Installing Git and cloning the code repository</li>
<li>Choosing and installing a code editor</li>
<li>Installing Docker Desktop on macOS or Windows</li>
<li>Installing Docker Toolbox</li>
<li>Enabling Kubernetes on Docker Desktop</li>
<li>Installing minikube</li>
<li>Installing Kind</li>
</ul>
<h1 id="_idParaDest-32"><a id="_idTextAnchor029"/>Technical requirements</h1>
<p>For this chapter, you will need a laptop or a workstation with either macOS or Windows, preferably Windows 11, installed. You should also have free internet access to download applications and permission to install those applications on your laptop. It is also possible to follow along with this book if you have a Linux distribution as your operating system, such as Ubuntu 18.04 or newer. I will try to indicate where commands and samples differ significantly from the ones on macOS or Windows.</p>
<h1 id="_idParaDest-33"><a id="_idTextAnchor030"/>The Linux command shell</h1>
<p>Docker containers were first developed on Linux<a id="_idIndexMarker039"/> for Linux. Hence, it is natural that the primary command-line tool<a id="_idIndexMarker040"/> used to work with Docker, also called a shell, is a Unix shell; remember, Linux derives from Unix. Most developers use the Bash shell. On some lightweight Linux distributions, such as Alpine, Bash is not installed and consequently, you must use the simpler Bourne shell, just called <code>sh</code>. Whenever we are working in a Linux environment, such as inside a container or on a Linux VM, we will use either <code>/bin/bash</code> or <code>/bin/sh</code>, depending on their availability.</p>
<p>Although Apple’s macOS is not a Linux OS, Linux and macOS are both flavors of Unix and hence support the same set of tools. Among those tools are the shells. So, when working on macOS, you will probably be using the Bash or zsh shell.</p>
<p>In this book, we expect you to be familiar with the most basic scripting commands in Bash and PowerShell, if you are working on Windows. If you are an absolute beginner, then we strongly recommend that you familiarize yourself with the following cheat sheets:</p>
<ul>
<li><em class="italic">Linux Command Line Cheat Sheet</em> by Dave Child at <a href="http://bit.ly/2mTQr8l">http://bit.ly/2mTQr8l</a></li>
<li><em class="italic">PowerShell Basic Cheat Sheet</em> at <a href="http://bit.ly/2EPHxze">http://bit.ly/2EPHxze</a></li>
</ul>
<h1 id="_idParaDest-34"><a id="_idTextAnchor031"/>PowerShell for Windows</h1>
<p>On a Windows computer, laptop, or server, we have multiple<a id="_idIndexMarker041"/> command-line tools available. The most familiar is the command shell. It has been available on any Windows computer for decades. It is a very simple shell. For more advanced scripting, Microsoft has developed PowerShell. PowerShell is very powerful and very popular among engineers working on Windows. Finally, on Windows<a id="_idIndexMarker042"/> 10 or later, we have the so-called Windows Subsystem for Linux, which allows us to use any Linux tool, such as the Bash or Bourne shells. Apart from this, other tools install a Bash shell on Windows, such as the Git Bash shell. In this book, all commands will use Bash syntax. Most of the commands also run in PowerShell.</p>
<p>Therefore, we recommend that you either use PowerShell<a id="_idIndexMarker043"/> or any other Bash tool to work with Docker on Windows.</p>
<h1 id="_idParaDest-35"><a id="_idTextAnchor032"/>Installing and using a package manager</h1>
<p>The easiest way to install software<a id="_idIndexMarker044"/> on a Linux, macOS, or Windows laptop<a id="_idIndexMarker045"/> is to use a good package manager. On macOS, most people use Homebrew, while on Windows, Chocolatey is a good choice. If you’re using a Debian-based Linux distribution such as Ubuntu, then the package manager of choice for most is <code>apt</code>, which is installed by default.</p>
<h2 id="_idParaDest-36"><a id="_idTextAnchor033"/>Installing Homebrew on macOS</h2>
<p>Homebrew is the most popular<a id="_idIndexMarker046"/> package manager on macOS, and it is easy<a id="_idIndexMarker047"/> to use and very versatile. Installing Homebrew on macOS<a id="_idIndexMarker048"/> is simple; just follow the instructions at <a href="https://brew.sh/">https://brew.sh/</a>:</p>
<ol>
<li>In a nutshell, open a new Terminal window and execute the following command to install Homebrew:<pre class="source-code">
$ /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"</pre></li> <li>Once the installation has finished, test whether Homebrew is working by entering <code>brew --version</code> in the Terminal. You should see something like this:<pre class="source-code">
$ brew --versionHomebrew 3.6.16Homebrew/homebrew-core (git revision 025fe79713b; last commit 2022-12-26)Homebrew/homebrew-cask (git revision 15acb0b64a; last commit 2022-12-26)</pre></li> <li>Now, we are ready to use Homebrew to install tools and utilities. If we, for example, want to install the iconic Vi text editor (note that this is not a tool we will use in this book; it serves just as an example), we can do so like this:<pre class="source-code">
$ brew install vim</pre></li> </ol>
<p>This will download<a id="_idIndexMarker049"/> and install the editor<a id="_idIndexMarker050"/> for you.</p>
<h2 id="_idParaDest-37"><a id="_idTextAnchor034"/>Installing Chocolatey on Windows</h2>
<p>Chocolatey is a popular<a id="_idIndexMarker051"/> package manager<a id="_idIndexMarker052"/> for Windows, built on PowerShell. To install the Chocolatey package<a id="_idIndexMarker053"/> manager, please follow the instructions at <a href="https://chocolatey.org/">https://chocolatey.org/</a> or open a new PowerShell window in admin mode and execute the following command:</p>
<pre class="source-code">
PS&gt; Set-ExecutionPolicy Bypass -Scope Process -Force; iex ((New-Object System.Net.WebClient).DownloadString('https://chocolatey.org/install.ps1'))</pre> <p class="callout-heading">Note</p>
<p class="callout">It is important to run the preceding command as an administrator; otherwise, the installation will not succeed. It is also important to note that the preceding command is one single line and has only been broken into several lines here due to the limited line width.</p>
<p>Once Chocolatey has been installed, test it with the <code>choco --version</code> command. You should see output similar to the following:</p>
<pre class="source-code">
PS&gt; choco --version0.10.15</pre>
<p>To install an application such as the Vi editor, use the following command:</p>
<pre class="source-code">
PS&gt; choco install -y vim</pre> <p>The <code>-y</code> parameter makes sure that the installation happens without Chocolatey asking for a reconfirmation. As mentioned previously, we will not use Vim<a id="_idIndexMarker054"/> in our exercises; it has only been used<a id="_idIndexMarker055"/> as an example.</p>
<p class="callout-heading">Note</p>
<p class="callout">Once Chocolatey has installed an application, you may need to open a new PowerShell window to use that application.</p>
<h1 id="_idParaDest-38"><a id="_idTextAnchor035"/>Installing Git and cloning the code repository</h1>
<p>We will be using Git<a id="_idIndexMarker056"/> to clone the sample code<a id="_idIndexMarker057"/> accompanying this book from its GitHub repository. If you already have Git installed on your computer, you can skip this section:</p>
<ol>
<li value="1">To install Git on macOS, use the following command in a Terminal window:<pre class="source-code">
$ brew install git</pre></li> <li>To install Git on Windows, open a PowerShell window and use Chocolatey to install it:<pre class="source-code">
PS&gt; choco install git -y</pre></li> <li>Finally, on a Debian or Ubuntu machine, open a Bash console and execute the following command:<pre class="source-code">
$ sudo apt update &amp;&amp; sudo apt install -y git</pre></li> <li>Once Git has been installed, verify that it is working. On all platforms, use the following command:<pre class="source-code">
$ git --version</pre></li> </ol>
<p>This should output the version of Git that’s been installed. On the author’s MacBook Air, the output is as follows:</p>
<pre class="source-code">
git version 2.39.1</pre> <p class="callout-heading">Note</p>
<p class="callout">If you see an older version, then you are probably using the version that came installed with macOS by default. Use Homebrew to install the latest version by running <code>$ brew </code><code>install git</code>.</p>
<ol>
<li value="5">Now that Git is working, we can clone the source code accompanying this book from GitHub. Execute the following command:<pre class="source-code">
$ cd ~$ git clone https://github.com/PacktPublishing/The-Ultimate-Docker-Container-Book</pre></li> </ol>
<p>This will clone the content of the main branch into your local folder, <code>~/The-Ultimate-Docker-Container-Book</code>. This folder will now contain all of the sample solutions for the labs we are going to do together in this book. Refer to these sample solutions if you get stuck.</p>
<p>Now that we have<a id="_idIndexMarker058"/> installed the<a id="_idIndexMarker059"/> basics, let’s continue with the code editor.</p>
<h1 id="_idParaDest-39"><a id="_idTextAnchor036"/>Choosing and installing a code editor</h1>
<p>Using a good code editor<a id="_idIndexMarker060"/> is essential to working<a id="_idIndexMarker061"/> productively with Docker. Of course, which editor is the best is highly controversial and depends on your personal preference. A lot of people<a id="_idIndexMarker062"/> use Vim, or others such as Emacs, Atom, Sublime, or <strong class="bold">Visual Studio Code</strong> (<strong class="bold">VS Code</strong>), to just name a few. VS Code is a completely free and lightweight editor, yet it is very powerful and is available for macOS, Windows, and Linux. According to Stack Overflow, it is currently by far the most popular code editor. If you are not yet sold on another editor, I highly recommend that you give VS Code a try.</p>
<p>But if you already have a favorite code editor, then please continue using it. So long as you can edit text files, you’re good to go. If your editor supports syntax highlighting for Dockerfiles and JSON and YAML files, then even better. The only exception will be <a href="B19199_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Debugging Code Running in  Containers</em>. The examples presented<a id="_idIndexMarker063"/> in that chapter will be heavily tailored<a id="_idIndexMarker064"/> toward VS Code.</p>
<h2 id="_idParaDest-40"><a id="_idTextAnchor037"/>Installing VS Code on macOS</h2>
<p>Follow these<a id="_idIndexMarker065"/> steps for <a id="_idIndexMarker066"/>installation:</p>
<ol>
<li value="1">Open a new Terminal window and execute the following command:<pre class="source-code">
$ brew cask install visual-studio-code</pre></li> <li>Once VS Code has been installed successfully, navigate to your home directory:<pre class="source-code">
$ cd ~</pre></li> <li>Now, open VS Code from within this folder:<pre class="source-code">
$ code The-Ultimate-Docker-Container-Book</pre></li> </ol>
<p>VS will start and open the <code>The-Ultimate-Docker-Container-Book</code> folder, where you just downloaded the repository that contains the source code for this book, as the working folder.</p>
<p class="callout-heading">Note</p>
<p class="callout">If you already have VS Code<a id="_idIndexMarker067"/> installed without using brew, then the guide at <a href="https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line">https://code.visualstudio.com/docs/setup/mac#_launching-from-the-command-line</a> will add code to your path.</p>
<ol>
<li value="4">Use VS Code to explore the code that you can see in the folder you just opened.</li>
</ol>
<h2 id="_idParaDest-41"><a id="_idTextAnchor038"/>Installing VS Code on Windows</h2>
<p>Follow these<a id="_idIndexMarker068"/> steps for<a id="_idIndexMarker069"/> installation:</p>
<ol>
<li value="1">Open a new PowerShell window in <em class="italic">admin mode</em> and execute the following command:<pre class="source-code">
PS&gt; choco install vscode -y</pre></li> <li>Close your PowerShell window and open a new one, to make sure VS Code is in your path.</li>
<li>Now, navigate to your home directory:<pre class="source-code">
PS&gt; cd ~</pre></li> <li>Now, open VS Code from within this folder:<pre class="source-code">
PS&gt; code The-Ultimate-Docker-Container-Book</pre></li> </ol>
<p>VS will start and open the <code>The-Ultimate-Docker-Container-Book</code> folder, where you just downloaded the repository that contains the source code for this book, as the working folder.</p>
<ol>
<li value="5">Use VS Code to explore<a id="_idIndexMarker070"/> the code that you can see in the folder<a id="_idIndexMarker071"/> you just opened.</li>
</ol>
<h2 id="_idParaDest-42"><a id="_idTextAnchor039"/>Installing VS Code on Linux</h2>
<p>Follow these<a id="_idIndexMarker072"/> steps for<a id="_idIndexMarker073"/> installation:</p>
<ol>
<li value="1">On your Debian or Ubuntu-based Linux machine, you can use Snap to install VS Code. Open a Bash Terminal and execute the following statement to install VS Code:<pre class="source-code">
$ sudo snap install --classic code</pre></li> <li>If you’re using a Linux distribution that’s not based on Debian or Ubuntu, then please follow the following link for more details: <a href="https://code.visualstudio.com/docs/setup/linux">https://code.visualstudio.com/docs/setup/linux</a>.</li>
<li>Once VS Code has been installed successfully, navigate to your home directory:<pre class="source-code">
$ cd ~</pre></li> <li>Now, open VS Code from within this folder:<pre class="source-code">
$ code The-Ultimate-Docker-Container-Book</pre></li> </ol>
<p>VS will start and open the <code>The-Ultimate-Docker-Container-Book</code> folder, where you just downloaded the repository that contains the source code for this book, as the working folder.</p>
<ol>
<li value="5">Use VS Code to explore<a id="_idIndexMarker074"/> the code that you can see in the folder<a id="_idIndexMarker075"/> you just opened.</li>
</ol>
<h2 id="_idParaDest-43"><a id="_idTextAnchor040"/>Installing VS Code extensions</h2>
<p>Extensions are what make VS Code<a id="_idIndexMarker076"/> such a versatile editor. On all three platforms (macOS, Windows, and Linux), you can install VS Code extensions the same way:</p>
<ol>
<li value="1">Open a Bash console (or PowerShell in Windows) and execute the following group of commands to install the most essential extensions we are going to use in the upcoming examples in this book:<pre class="source-code">
code --install-extension vscjava.vscode-java-packcode --install-extension ms-dotnettools.csharpcode --install-extension ms-python.pythoncode --install-extension ms-azuretools.vscode-dockercode --install-extension eamodio.gitlens</pre></li> </ol>
<p>We are installing extensions that enable us to work with Java, C#, .NET, and Python much more productively. We’re also installing an extension built to enhance our experience with Docker.</p>
<ol>
<li value="2">After the preceding extensions have been installed successfully, restart VS Code to activate the extensions. You can now click the <strong class="bold">Extensions</strong> icon in the <strong class="bold">activity</strong> pane on the left-hand side of VS Code to see all of the installed extensions.</li>
<li>To get a list of all installed extensions in your VS Code, use this command:<pre class="source-code">
$ code --list-extensions</pre></li> </ol>
<p>Next, let’s install Docker Desktop.</p>
<h1 id="_idParaDest-44"><a id="_idTextAnchor041"/>Installing Docker Desktop on macOS or Windows</h1>
<p>If you are using macOS<a id="_idIndexMarker077"/> or have Windows 10 or later<a id="_idIndexMarker078"/> installed on your laptop, then we strongly recommend <a id="_idIndexMarker079"/>that you install Docker Desktop. Since early 2022, Docker has also released a version of Docker Desktop for Linux. Docker Desktop gives you the best experience when working with containers. Follow these steps to install Docker Desktop for your system:</p>
<ol>
<li value="1">No matter what OS you’re us<a href="https://www.docker.com/get-started">ing, navigate to the Docker start </a>page at <a href="https://www.docker.com/get-started">https://www.docker.com/get-started</a>:</li>
</ol>
<div><div><img alt="Figure 2.1 – Get Started with Docker" height="1043" src="img/B19199_02_01.jpg" width="957"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.1 – Get Started with Docker</p>
<ol>
<li value="2">On the right-hand<a id="_idIndexMarker080"/> side of the view, you will find<a id="_idIndexMarker081"/> a blue <strong class="bold">Sign up</strong> button for Docker Hub. Click<a id="_idIndexMarker082"/> this button if you don’t have an account<a id="_idIndexMarker083"/> on Docker Hub yet, then create one. It is free, but you need an account to download the software.</li>
<li>On the left-hand side of the view, you will find a blue button called <strong class="bold">Download for &lt;your OS&gt;</strong>, where <strong class="bold">&lt;your OS&gt;</strong> can be Linux, Mac, or Windows, depending on which OS you are working with. In the authors’ case, it shows Mac as the target OS, but it got the CPU type wrong since the author is using a Mac with Apple’s M1 chip.</li>
</ol>
<p>Click the small drop-down triangle on the right-hand side of the button to get the full list of available downloads:</p>
<div><div><img alt="Figure 2.2 – List of Docker Desktop targets" height="237" src="img/B19199_02_02.jpg" width="265"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.2 – List of Docker Desktop targets</p>
<p>Select the one that is appropriate for you and observe the installation package being downloaded.</p>
<ol>
<li value="4">Once the package has been completely<a id="_idIndexMarker084"/> downloaded, proceed <a id="_idIndexMarker085"/>with the installation, usually<a id="_idIndexMarker086"/> by double-clicking<a id="_idIndexMarker087"/> on the download package.</li>
</ol>
<h2 id="_idParaDest-45"><a id="_idTextAnchor042"/>Testing Docker Engine</h2>
<p>Now that you have successfully<a id="_idIndexMarker088"/> installed Docker Desktop, let’s test it. We will start by running a simple Docker container directly from the command line:</p>
<ol>
<li value="1">Open a Terminal window and execute the following command:<pre class="source-code">
$ docker version</pre></li> </ol>
<p>You should see something like this:</p>
<div><div><img alt="Figure 2.3 – Docker version of Docker Desktop" height="636" src="img/B19199_02_03.jpg" width="630"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.3 – Docker version of Docker Desktop</p>
<p>In the preceding output, we can see<a id="_idIndexMarker089"/> that it consists of two parts – a client and a server. Here, the server corresponds to Docker Engine, which is responsible for hosting and running containers. At the time of writing, the version of Docker Engine is <code>20.10.21</code>.</p>
<ol>
<li value="2">To see whether you can run containers, enter the following command into the Terminal window and hit <em class="italic">Enter</em>:<pre class="source-code">
$ docker container run hello-world</pre></li> </ol>
<p>If all goes well, your output should look something like the following:</p>
<div><div><img alt="Figure 2.4 – Running Hello-World on Docker Desktop for macOS" height="576" src="img/B19199_02_04.jpg" width="821"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.4 – Running Hello-World on Docker Desktop for macOS</p>
<p>If you read the preceding output<a id="_idIndexMarker090"/> carefully, you will have noticed that Docker didn’t find an image called <code>hello-world:latest</code> and thus decided to download it from a Docker image registry. Once downloaded, Docker Engine created a container from the image and ran it. The application runs inside the container and then outputs all the text, starting with <code>Hello </code><code>from Docker!</code>.</p>
<p>This is proof that Docker is installed and working correctly on your machine.</p>
<ol>
<li value="3">Let’s try another funny test image that’s usually used to check the Docker installation. Run the following command:<pre class="source-code">
$ docker container run rancher/cowsay Hello</pre></li> </ol>
<p>You should see this or a similar output:</p>
<p class="IMG---Figure"><img alt="Figure 2.5 – Running the cowsay image from Rancher" height="406" src="img/B19199_02_05.png" width="821"/></p>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.5 – Running the cowsay image from Rancher</p>
<p>Great – we have confirmed that Docker Engine<a id="_idIndexMarker091"/> works on our local computer. Now, let’s make sure the same is true for Docker Desktop.</p>
<h2 id="_idParaDest-46"><a id="_idTextAnchor043"/>Testing Docker Desktop</h2>
<p>Depending on the operating system<a id="_idIndexMarker092"/> you are working with, be it Linux, Mac, or Windows, you can access the context menu for Docker Desktop in different areas. In any case, the symbol you are looking for is the little whale carrying containers. Here is the symbol as found on a Mac –        :</p>
<div><div><img alt="" height="23" role="presentation" src="img/B19199_02_Icon.jpg" width="27"/>
</div>
</div>
<ul>
<li><strong class="bold">Mac</strong>: You’ll find the icon on the right-hand side of your menu bar at the top of the screen.</li>
<li><strong class="bold">Windows</strong>: You’ll find the icon in the Windows system tray.</li>
<li><code>Docker Desktop</code> via the <strong class="bold">Applications</strong> menu and open it. This will launch the Docker menu icon and open the Docker dashboard, reporting the status of Docker Desktop.</li>
</ul>
<p>Once you have located the context menu for Docker Desktop on your computer, proceed with the following steps:</p>
<ol>
<li value="1">Click the <em class="italic">whale</em> icon to display the context menu<a id="_idIndexMarker093"/> of Docker Desktop. On the authors’ Mac, it looks like this:</li>
</ol>
<div><div><img alt="Figure 2.6 – Context menu for Docker Desktop" height="424" src="img/B19199_02_06.jpg" width="257"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.6 – Context menu for Docker Desktop</p>
<ol>
<li value="2">From the menu, select <strong class="bold">Dashboard</strong>. The dashboard of Docker Desktop will open:</li>
</ol>
<div><div><img alt="Figure 2.7 – Dashboard of Docker Desktop" height="516" src="img/B19199_02_07.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.7 – Dashboard of Docker Desktop</p>
<p>We can see that the dashboard has multiple<a id="_idIndexMarker094"/> tabs, indicated on the left-hand side of the view. Currently, the <code>hello-world</code> and <code>rancher/cowsay</code> Docker images. They both have a status of <strong class="bold">Exited</strong>.</p>
<p>Please take some time and explore this dashboard a bit. Don’t worry if you get lost. It will all become much clearer as we proceed through the various chapters of this book.</p>
<ol>
<li value="3">When you’re done exploring, close the dashboard window.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">Closing the dashboard will not stop Docker Desktop. The application, as well as Docker Engine, will continue to run in the background. If for some reason you want to stop Docker on your system completely, you can select <strong class="bold">Quit Docker Desktop</strong> from the context menu shown in <em class="italic">Step 1</em>.</p>
<p>Congratulations, you have successfully installed<a id="_idIndexMarker095"/> and tested Docker Desktop on your working computer! Now, let’s continue with a few other useful tools.</p>
<h1 id="_idParaDest-47"><a id="_idTextAnchor044"/>Installing Docker Toolbox</h1>
<p>Docker Toolbox has been available for developers<a id="_idIndexMarker096"/> for a few years. It precedes newer tools such as Docker Desktop. Toolbox allows a user to work very elegantly with containers on any macOS or Windows computer. Containers must run on a Linux host. Neither Windows nor macOS can run containers natively. Hence, we need to run a Linux VM on our laptop, where we can then run our containers. Docker Toolbox installs VirtualBox on our laptop, which is used to run the Linux VMs we need.</p>
<p class="callout-heading">Note</p>
<p class="callout">Docker Toolbox has been deprecated recently and thus we won’t be discussing it further. For certain scenarios, it may still be of interest though, which is why we are mentioning it here.</p>
<h1 id="_idParaDest-48"><a id="_idTextAnchor045"/>Enabling Kubernetes on Docker Desktop</h1>
<p>Docker Desktop<a id="_idIndexMarker097"/> comes with integrated support<a id="_idIndexMarker098"/> for Kubernetes.</p>
<p class="callout-heading">What is Kubernetes?</p>
<p class="callout">Kubernetes is a powerful platform<a id="_idIndexMarker099"/> for automating the deployment, scaling, and management of containerized applications. Whether you’re a developer, DevOps engineer, or system administrator, Kubernetes provides the tools and abstractions you need to manage your containers and applications in a scalable and efficient manner.</p>
<p>This support is turned off by default. But worry not – it is very easy to turn on:</p>
<ol>
<li value="1">Open the dashboard of Docker Desktop.</li>
<li>In the top-left corner, select the cog wheel icon. This will open the <strong class="bold">settings</strong> page.</li>
<li>On the left-hand<a id="_idIndexMarker100"/> side, select<a id="_idIndexMarker101"/> the <strong class="bold">Kubernetes</strong> tab and then check the <strong class="bold">Enable </strong><strong class="bold">Kubernetes</strong> checkbox:</li>
</ol>
<div><div><img alt="Figure 2.8 – Enabling Kubernetes on Docker Desktop" height="935" src="img/B19199_02_08.jpg" width="1274"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.8 – Enabling Kubernetes on Docker Desktop</p>
<ol>
<li value="4">Click the <strong class="bold">Apply &amp; </strong><strong class="bold">restart</strong> button.</li>
</ol>
<p>Now, you will have to be patient since Docker is downloading all the supporting infrastructure and then starting Kubernetes.</p>
<p>Once Docker<a id="_idIndexMarker102"/> has restarted, you are ready<a id="_idIndexMarker103"/> to use Kubernetes. Please refer to the <em class="italic">Installing minikube</em> section on how to test Kubernetes.</p>
<h1 id="_idParaDest-49"><a id="_idTextAnchor046"/>Installing minikube</h1>
<p>If you are using Docker Desktop, you may not need minikube at all since the former already provides out-of-the-box support for Kubernetes. If you cannot use Docker Desktop or, for some reason, you only have access to an older version of the tool that does not yet support Kubernetes, then it is a good idea to install minikube. minikube provisions a single-node Kubernetes cluster on your workstation and is accessible through kubectl, which is the command-line tool used to work with Kubernetes.</p>
<h2 id="_idParaDest-50"><a id="_idTextAnchor047"/>Installing minikube on Linux, macOS, and Windows</h2>
<p>To<a id="_idIndexMarker104"/> install<a id="_idIndexMarker105"/> mi<a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">nikube on Linux, macOS, or Windows, navigate to the</a><a id="_idIndexMarker110"/> following link: <a href="https://kubernetes.io/docs/tasks/tools/install-minikube/">https://kubernetes.io/docs/tasks/tools/install-minikube/</a>.</p>
<p>Follow the instructions carefully. Specifically, do the following:</p>
<ol>
<li value="1">Make sure you have a hypervisor installed, as described here:</li>
</ol>
<div><div><img alt="Figure 2.9 – Prerequisites for minikube" height="516" src="img/B19199_02_09.jpg" width="791"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.9 – Prerequisites for minikube</p>
<ol>
<li value="2">Under <strong class="bold">1 Installation</strong>, select the combination<a id="_idIndexMarker111"/> that is valid<a id="_idIndexMarker112"/> for you. As an<a id="_idIndexMarker113"/> example, you<a id="_idIndexMarker114"/> can see the<a id="_idIndexMarker115"/> authors’ selection<a id="_idIndexMarker116"/> for a <em class="italic">MacBook Air M1 laptop</em> as the target machine:</li>
</ol>
<div><div><img alt="Figure 2.10 – Selecting the configuration" height="716" src="img/B19199_02_10.jpg" width="794"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.10 – Selecting the configuration</p>
<h3>Installing minikube for a MacBook Air M1 using Homebrew</h3>
<p>Follow these steps:</p>
<ol>
<li value="1">In a Terminal window, execute<a id="_idIndexMarker117"/> the steps shown<a id="_idIndexMarker118"/> previously. In the authors’ case, this is as follows:<pre class="source-code">
$ brew install minikube</pre></li> <li>Test the installation with the following command:<pre class="source-code">
$ brew versionminikube version: v1.28.0commit: 986b1ebd987211ed16f8cc10aed7d2c42fc8392f</pre></li> <li>Now, we’re ready to start a cluster. Let’s start with the default:<pre class="source-code">
$ minikube start</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">minikube allows you to define single and multi-node clusters.</p>
<ol>
<li value="4">The first time you do this, it will take a while since minikube needs to download all the Kubernetes binaries. When it’s done, the last line of the output on your screen should be something like this:<pre class="source-code">
Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</pre></li> </ol>
<p>Great, we have successfully installed minikube on our system! Let’s try to play with minikube a bit by creating a cluster and running our first application in a container on it. Don’t worry if the following<a id="_idIndexMarker119"/> commands do not make<a id="_idIndexMarker120"/> a lot of sense to you at this time. We will discuss everything in this book in the coming chapters.</p>
<h2 id="_idParaDest-51"><a id="_idTextAnchor048"/>Testing minikube and kubectl</h2>
<p>Let’s start. Please<a id="_idIndexMarker121"/> follow these steps<a id="_idIndexMarker122"/> carefully:</p>
<ol>
<li value="1">Let’s try to access our cluster using kubectl. First, we need to make sure we have the correct context selected for kubectl. If you have previously installed Docker Desktop and now minikube, you can use the following command:<pre class="source-code">
$ kubectl config get-contexts</pre></li> </ol>
<p>You should see this:</p>
<div><div><img alt="Figure 2.11 – List of contexts for kubectl after installing minikube" height="165" src="img/chainner_txt_B19199_02_11.jpg" width="1500"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.11 – List of contexts for kubectl after installing minikube</p>
<p>The asterisk next to the context called minikube tells us that this is the current context. Thus, when using kubectl, we will work with the new cluster created by minikube.</p>
<ol>
<li value="2">Now, let’s see how<a id="_idIndexMarker123"/> many nodes<a id="_idIndexMarker124"/> our cluster has with this command:<pre class="source-code">
$ kubectl get nodes</pre></li> </ol>
<p>You should get something similar to this. Note that the version shown could differ in your case:</p>
<div><div><img alt="Figure 2.12 – Showing the list of cluster nodes for the minikube cluster" height="70" src="img/B19199_02_12.jpg" width="713"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.12 – Showing the list of cluster nodes for the minikube cluster</p>
<p>Here, we have a single-node cluster. The node’s role is that of the control plane, which means it is a master node. A typical Kubernetes cluster consists of a few master nodes and many worker nodes. The version of Kubernetes we’re working with here is <code>v1.25.3</code>.</p>
<ol>
<li value="3">Now, let’s try to run something on this cluster. We will use Nginx, a popular web server for this. If you have previously cloned the GitHub repository accompanying this book to the <code>The-Ultimate-Docker-Container-Book</code> folder in your home directory (<code>~</code>), then you should find a folder setup inside this folder that contains a <code>.yaml</code> file, which we’re going to use for this test:<ol><li>Open a new Terminal window.</li><li>Navigate to the <code>The-Ultimate-Docker-Container-Book</code> folder:</li></ol><pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book</pre><ol><li value="3">Create a pod running Nginx with the following command:</li></ol><pre class="source-code">$ kubectl apply -f setup/nginx.yaml</pre></li> </ol>
<p>	       You should see this output:</p>
<pre class="source-code">
pod/nginx created</pre> <ol>
<li value="4">We can double-check<a id="_idIndexMarker125"/> whether the pod is running<a id="_idIndexMarker126"/> with kubectl:</li>
</ol>
<pre class="source-code">
$ kubectl get pods</pre> <p>	       We should see this:</p>
<pre class="source-code">
NAME     READY   STATUS     RESTARTS   AGEnginx     1/1    Running       0       11m</pre>
<p>	       This indicates that we have 1 pod with Nginx running and that it has been restarted 	       0 times.</p>
<ol>
<li value="4">To access the Nginx server, we need to expose the application running in the pod with the following command:<pre class="source-code">
$ kubectl expose pod nginx --type=NodePort --port=80</pre></li> </ol>
<p>This is the only way can we access Nginx from our laptop – for example, via a browser. With the preceding command, we’re creating a Kubernetes service, as indicated in the output generated for the command:</p>
<pre class="source-code">
service/nginx exposed</pre> <ol>
<li value="5">We can use kubectl to list all the services defined in our cluster:<pre class="source-code">
$ kubectl get services</pre></li> </ol>
<p>We should see this:</p>
<div><div><img alt="Figure 2.13 – List of services on the minikube cluster" height="87" src="img/B19199_02_13.jpg" width="772"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.13 – List of services on the minikube cluster</p>
<p>In the preceding output, we can see the second service called Nginx, which we just created. The service is of the <code>NodePort</code> type; port <code>80</code> of the pod had been mapped to port <code>30373</code> of the cluster node of our Kubernetes cluster in minikube.</p>
<ol>
<li value="6">Now, we can use minikube to make<a id="_idIndexMarker127"/> a tunnel to our cluster and open a browser<a id="_idIndexMarker128"/> with the correct URL to access the Nginx web server. Use this command:<pre class="source-code">
$ minikube service nginx</pre></li> </ol>
<p>The output in your Terminal window will be as follows:</p>
<div><div><img alt="Figure 2.14 – Opening access to the Kubernetes cluster on minikube" height="301" src="img/B19199_02_14.jpg" width="956"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.14 – Opening access to the Kubernetes cluster on minikube</p>
<p>The preceding output shows that minikube created a tunnel for the nginx service listening on node port <code>30373</code> to port <code>64171</code> on the host, which is on our lapto<a href="http://127.0.0.1:64171">p.</a></p>
<ol>
<li value="7"><a href="http://127.0.0.1:64171">A new browser tab s</a>hould have been opened automatically and should have navigated you to <code>http://127.0.0.1:64171</code>. You should see the welcome screen for Nginx:</li>
</ol>
<div><div><img alt="Figure 2.15 – Welcome screen of Nginx running on a Kubernetes cluster on minikube" height="325" src="img/B19199_02_15.jpg" width="648"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.15 – Welcome screen of Nginx running on a Kubernetes cluster on minikube</p>
<p>Wonderful, we have successfully run and accessed an Nginx web server on our little single-node Kubernetes cluster on minikube! Once you are done playing around, it is time to clean up:</p>
<ol>
<li value="1">Stop the tunnel to the cluster by pressing <em class="italic">Ctrl </em>+ <em class="italic">C</em> inside your Terminal window.</li>
<li>Delete the nginx service and pod on the cluster:<pre class="source-code">
$ kubectl delete service nginx$ kubectl delete pod nginx</pre></li> <li>Stop the cluster with the following command:<pre class="source-code">
$ minikube stop</pre></li> <li>You should<a id="_idIndexMarker129"/> see<a id="_idIndexMarker130"/> this:</li>
</ol>
<div><div><img alt="Figure 2.16 – Stopping minikube" height="87" src="img/B19199_02_16.jpg" width="676"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.16 – Stopping minikube</p>
<h2 id="_idParaDest-52"><a id="_idTextAnchor049"/>Working with a multi-node minikube cluster</h2>
<p>At times, testing with a single-node cluster<a id="_idIndexMarker131"/> is not enough. Worry not – minikube has got you covered. Follow these instructions to create a true multi-node Kubernetes cluster in minikube:</p>
<ol>
<li value="1">If we want to work with a cluster consisting of multiple nodes in minikube, we can use this command:<pre class="source-code">
$ minikube start --nodes 3 –p demo</pre></li> </ol>
<p>The preceding command creates a cluster with three nodes and calls it <code>demo</code>.</p>
<ol>
<li value="2">Use kubectl to list all your cluster nodes:<pre class="source-code">
$ kubectl get nodesNAME          STATUS    ROLES            AGE      VERSIONdemo          Ready     control-plane    84s      v1.25.3demo-m02      Ready     &lt;none&gt;           45s      v1.25.3demo-m03      Ready     &lt;none&gt;           22s      v1.25.3</pre></li> </ol>
<p>We have a 3-node cluster where the <code>demo</code> node is a master node, and the two remaining nodes are work nodes.</p>
<ol>
<li value="3">We are not going to go any further with this example here, so use the following command to stop the cluster:<pre class="source-code">
$ minikube stop -p demo</pre></li> <li>Delete all the clusters on your system with this command:<pre class="source-code">
$ minikube delete --all</pre></li> </ol>
<p>This will delete the default cluster (called minikube) and the demo cluster in our case.</p>
<p>With this, we will move on to the next interesting tool useful when working with containers and Kubernetes. You should have this installed and readily available on your work computer.</p>
<h1 id="_idParaDest-53"><a id="_idTextAnchor050"/>Installing Kind</h1>
<p>Kind is another popular tool<a id="_idIndexMarker132"/> that can be used to run a multi-node Kubernetes cluster locally on your machine. It is super<a id="_idIndexMarker133"/> easy to install and use. Let’s go:</p>
<ol>
<li value="1">Use the appropriate package manager for your platf<a href="https://kind.sigs.k8s.io/docs/user/quick-start/">orm to install Kind. You can find more detailed</a> information about the installation process here: <a href="https://kind.sigs.k8s.io/docs/user/quick-start/">https://kind.sigs.k8s.io/docs/user/quick-start/</a>:<ol><li>On MacOS, use Homebrew to install Kind with the following command:</li></ol><pre class="source-code">
$ brew install kind</pre><ol><li value="2">On a Windows machine, use Chocolatey to do the same with this command:</li></ol><pre class="source-code">$ choco install kind -y</pre><ol><li value="3">Finally, on a Linu<a href="https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64">x machine, you can use the following script to insta</a>ll Kind from its binaries:</li></ol><pre class="source-code">$ curl -Lo ./kind https://kind.sigs.k8s.io/dl/v0.17.0/kind-linux-amd64$ chmod +x ./kind$ sudo mv ./kind /usr/local/bin/kind</pre></li> <li>Once Kind has been installed, test it with the following command:<pre class="source-code">
$ kind version</pre></li> </ol>
<p>If you’re on a Mac, it should output something like this:</p>
<pre class="source-code">
kind v0.17.0 go1.19.2 darwin/arm64</pre> <ol>
<li value="3">Now, try to create a simple Kubernetes cluster consisting of one master node and two worker nodes. Use this command to accomplish this:<pre class="source-code">
$ kind create cluster</pre></li> </ol>
<p>After some time, you should see this output:</p>
<div><div><img alt="Figure 2.17 – Creating a cluster with Kind" height="297" src="img/B19199_02_17.jpg" width="909"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.17 – Creating a cluster with Kind</p>
<ol>
<li value="4">To verify that a cluster has been created, use this command:<pre class="source-code">
$ kind get clusters</pre></li> </ol>
<p>The preceding output shows<a id="_idIndexMarker134"/> that there is exactly one cluster called <strong class="bold">kind</strong>, which is the default name.</p>
<ol>
<li value="5">We can create an additional cluster with a different name using the <code>--name</code> parameter, like so:<pre class="source-code">
$ kind create cluster --name demo</pre></li> <li>Listing the clusters will then show this:<pre class="source-code">
$ kind show clustersKinddemo</pre></li> </ol>
<p>And this works<a id="_idIndexMarker135"/> as expected.</p>
<h2 id="_idParaDest-54"><a id="_idTextAnchor051"/>Testing Kind</h2>
<p>Now that we have used kind<a id="_idIndexMarker136"/> to create two sample<a id="_idIndexMarker137"/> clusters, let’s use kubectl to play with one of the clusters and run the first application on it. We will be using Nginx for this, similar to what we did with minikube:</p>
<ol>
<li value="1">We can now use <strong class="bold">kubectl</strong> to access and work with the clusters <a id="_idIndexMarker138"/>we just created. While creating a cluster, Kind also updated the configuration file for our kubectl. We can double-check this with the following command:<pre class="source-code">
$ kubectl config get-contexts</pre></li> </ol>
<p>It should produce the following output:</p>
<div><div><img alt="Figure 2.18 – List of contexts defined for kubectl" height="109" src="img/B19199_02_18.jpg" width="751"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.18 – List of contexts defined for kubectl</p>
<p>You can see that the kind and demo clusters are part of the list of known clusters and that the demo cluster is the current context for kubectl.</p>
<ol>
<li value="2">Use the following command to make the demo cluster your current cluster if the asterisk is indicating that another cluster is current:<pre class="source-code">
$ kubectl config use-context kind-demo</pre></li> <li>Let’s list all the nodes of the <code>sample-cluster</code> cluster:<pre class="source-code">
$ kubectl get nodes</pre></li> </ol>
<p>The output should be like this:</p>
<div><div><img alt="Figure 2.19 – Showing the list of nodes on the kind cluster" height="66" src="img/B19199_02_19.jpg" width="715"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.19 – Showing the list of nodes on the kind cluster</p>
<ol>
<li value="4">Now, let’s try to run the first container on this cluster. We will use our trusted Nginx web server, as we did earlier. Use the following command to run it:<pre class="source-code">
$ kubectl apply -f setup/nginx.yaml</pre></li> </ol>
<p>The output should be as follows:</p>
<pre class="source-code">
pod/nginx created</pre> <ol>
<li value="5">To access the Nginx server, we need<a id="_idIndexMarker139"/> to do port forwarding<a id="_idIndexMarker140"/> using kubectl. Use this command to do so:<pre class="source-code">
$ kubectl port-forward nginx 8080 80</pre></li> </ol>
<p>The output should look like this:</p>
<pre class="source-code">
Forwa<a href="http://localhost:8080">rding from 127.0.0.1:</a>8080 -&gt; 80Forwarding from [::1]:8080 -&gt; 80</pre>
<ol>
<li value="6">Open a new browser tab and navigate to <code>http://localhost:8080</code>; you should see the welcome screen of Nginx:</li>
</ol>
<div><div><img alt="Figure 2.20 – Welcome screen of Nginx running on a Kind cluster" height="329" src="img/B19199_02_20.jpg" width="637"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 2.20 – Welcome screen of Nginx running on a Kind cluster</p>
<ol>
<li value="7">Once you’ve finished playing with Nginx, use this command to delete the pod from the cluster:<pre class="source-code">
$ kubectl delete –f setup/nginx.yaml</pre></li> <li>Before we continue, let’s clean up and delete the two clusters we just created:<pre class="source-code">
$ kind delete cluster --name kind$ kind delete cluster --name demo</pre></li> </ol>
<p>With this, we have installed<a id="_idIndexMarker141"/> all the tools<a id="_idIndexMarker142"/> that we will need to successfully work with containers on our local machine.</p>
<h1 id="_idParaDest-55"><a id="_idTextAnchor052"/>Summary</h1>
<p>In this chapter, we set up and configured our personal or working environment so that we can productively work with Docker containers. This equally applies to developers, DevOps, and operations engineers.</p>
<p>We started with a package manager that should be at the fingertip of every serious engineer. It makes installing and managing applications and tools so much easier. Next, we made sure that we used a good shell for scripting – a powerful editor. We then made sure to have Docker Desktop installed, which we can use to run and test containers natively. Finally, we installed and quickly tested minikube and Kind on our machine. The latter are tools that can be used to run and test our containers on a local Kubernetes cluster.</p>
<p>In the next chapter, we’re going to learn important facts about containers. For example, we will explore how we can run, stop, list, and delete containers, but more than that, we will also dive deep into the anatomy of containers.</p>
<h1 id="_idParaDest-56"><a id="_idTextAnchor053"/>Furthe<a href="https://chocolatey.org/">r reading</a></h1>
<p><a href="https://chocolatey.org/">Consider the </a>following links for further reading:<a href="https://dockr.ly/2nuZUkU"/></p>
<ul>
<li><a href="https://dockr.ly/2nuZUkU"><em class="italic">Chocolatey – The Packag</em></a><em class="italic">e Manager for </em><em class="italic">Windows</em>: <a href="https://chocolatey.org/">https://chocolatey.org/</a></li>
<li><em class="italic">Run Docker on Hyper-V with Docker </em><em class="italic">Machine</em>: <a href="http://bit.ly/2HGMPiI">http://bit.ly/2HGMPiI</a></li>
<li><em class="italic">Developing inside a </em><em class="italic">Container</em>: <a href="https://code.visualstudio.com/docs/remote/containers">https://code.visualstudio.com/docs/remote/containers</a></li>
</ul>
<h1 id="_idParaDest-57"><a id="_idTextAnchor054"/>Questions</h1>
<p>Based on what was covered in this chapter, please answer the following questions:</p>
<ol>
<li value="1">Why would we care about installing and using a package manager on our local computer?</li>
<li>With Docker Desktop, you can develop and run Linux containers.<ol><li>True</li><li>False</li></ol></li>
<li>Why are good scripting skills (such as Bash or PowerShell) essential for the productive use of containers?</li>
<li>Name three to four Linux distributions on which Docker is certified to run.</li>
<li>You installed minikube on your system. What kind of tasks will you use this tool for?</li>
</ol>
<h1 id="_idParaDest-58"><a id="_idTextAnchor055"/>Answers</h1>
<p>The following are the answers to this chapter’s questions:</p>
<ol>
<li value="1">Package managers such as <code>apk</code>, <code>apt</code>, or <code>yum</code> on Linux systems, Homebrew on macOS, and Chocolatey on Windows make it easy to automate the installation of applications, tools, and libraries. It is a much more repeatable process when an installation happens interactively, and the user has to click through a series of views.</li>
<li>The answer is <em class="italic">True</em>. Yes, with Docker Desktop, you can develop and run Linux containers. It is also possible, but not discussed in this book, to develop and run native Windows containers with this edition of Docker Desktop. With the macOS and Linux editions, you can only develop and run Linux containers.</li>
<li>Scripts are used to automate processes and hence avoid human errors. Building, testing, sharing, and running Docker containers are tasks that should always be automated to increase their reliability and repeatability.</li>
<li>The following Linux distros are certified to run Docker: <strong class="bold">Red Hat Linux</strong> (<strong class="bold">RHEL</strong>), CentOS, Oracle Linux, Ubuntu, and more.</li>
<li>minikube makes it possible to define and run a single or multi-node cluster on a local computer such as a developer’s laptop. This way, using minikube, you can run and test containerized applications locally on your machine and do not have to rely on a remote Kubernetes cluster such as one running in the cloud on, say, AWS, Microsoft Azure, or Google cloud.</li>
</ol>
</div>
</div>

<div><div><h1 id="_idParaDest-59"><a id="_idTextAnchor056"/>Part 2:Containerization Fundamentals</h1>
<p>This part teaches you how to start, stop, and remove containers, and how to inspect containers to retrieve additional metadata from them. Furthermore, it explains how to run additional processes and how to attach to the main process in an already running container. It also covers how to retrieve logging information from a container, which is produced by the processes running inside it. Finally, this part introduces the inner workings of a container, including such things as Linux namespaces and groups.</p>
<ul>
<li><a href="B19199_03.xhtml#_idTextAnchor057"><em class="italic">Chapter 3</em></a>, <em class="italic">Mastering Containers</em></li>
<li><a href="B19199_04.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating and Managing Container Images</em></li>
<li><a href="B19199_05.xhtml#_idTextAnchor109"><em class="italic">Chapter 5</em></a>, <em class="italic">Data Volumes and Configuration</em></li>
<li><a href="B19199_06.xhtml#_idTextAnchor130"><em class="italic">Chapter 6</em></a>, <em class="italic">Debugging Code Running in Containers</em></li>
<li><a href="B19199_07.xhtml#_idTextAnchor150"><em class="italic">Chapter 7</em></a>, <em class="italic">Testing </em><em class="italic">Applications</em><em class="italic"> Running in Containers</em></li>
<li><a href="B19199_08.xhtml#_idTextAnchor174"><em class="italic">Chapter 8</em></a>, <em class="italic">Increasing Productivity with Docker Tips and Tricks</em></li>
</ul>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
<div><div></div>
</div>
</div></body></html>