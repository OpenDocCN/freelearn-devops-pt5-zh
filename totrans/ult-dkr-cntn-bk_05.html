<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-112"><a id="_idTextAnchor109"/>5</h1>
<h1 id="_idParaDest-113"><a id="_idTextAnchor110"/>Data Volumes and Configuration</h1>
<p>In the previous chapter, we learned how to build and share our container images. Focus was placed on how to build images that are as small as possible by only containing artifacts that are needed by the containerized application.</p>
<p>In this chapter, we are going to learn how we can work with stateful containers – that is, containers that consume and produce data. We will also learn how to configure our containers at runtime and at image build time, using environment variables and config files.</p>
<p>Here is a list of the topics we’re going to discuss:</p>
<ul>
<li>Creating and mounting data volumes</li>
<li>Sharing data between containers</li>
<li>Using host volumes</li>
<li>Defining volumes in images</li>
<li>Configuring containers</li>
</ul>
<p>After working through this chapter, you will be able to do the following:</p>
<ul>
<li>Create, delete, and list data volumes</li>
<li>Mount an existing data volume into a container</li>
<li>Create durable data from within a container using a data volume</li>
<li>Share data between multiple containers using data volumes</li>
<li>Mount any host folder into a container using data volumes</li>
<li>Define the access mode (read/write or read-only) for a container when accessing data in a data volume</li>
<li>Configure environment variables for applications running in a container</li>
<li>Parameterize a Dockerfile by using build arguments</li>
</ul>
<h1 id="_idParaDest-114"><a id="_idTextAnchor111"/>Technical requirements</h1>
<p>For this chapter, you need Docker Desktop installed on your machine. There is no code accompanying this chapter.</p>
<p>Before we start, we need to create a folder for <a href="B19199_05.xhtml#_idTextAnchor109"><em class="italic">Chapter 5</em></a> inside our code repository:</p>
<ol>
<li>Use this command to navigate to the folder where you checked out the code from GitHub:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">If you did not check out the GitHub repository at the default location, the preceding command may vary for you.</p>
<ol>
<li value="2">Create a sub-folder for <a href="B19199_05.xhtml#_idTextAnchor109"><em class="italic">Chapter 5</em></a> and navigate to it:<pre class="source-code">
$ mkdir ch05 &amp;&amp; cd ch05</pre></li> </ol>
<p>Let’s get started!</p>
<h1 id="_idParaDest-115"><a id="_idTextAnchor112"/>Creating and mounting data volumes</h1>
<p>All meaningful <a id="_idIndexMarker347"/>applications consume or produce data. Yet containers <a id="_idIndexMarker348"/>are, ideally, meant to be stateless. How are we going to deal with this? One way is to use Docker volumes. Volumes allow containers to consume, produce, and modify a state. Volumes have a life cycle that goes beyond the life cycle of containers. When a container that uses a volume dies, the volume continues to exist. This is great for the durability of the state.</p>
<h2 id="_idParaDest-116"><a id="_idTextAnchor113"/>Modifying the container layer</h2>
<p>Before we dive into volumes, let’s first discuss what happens if an application in a container <a id="_idIndexMarker349"/>changes something in the filesystem of the container. In this case, the changes are all happening in the writable container layer that we introduced in <a href="B19199_04.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating and Managing Container Images</em>. Let’s quickly demonstrate this:</p>
<ol>
<li value="1">Run a container and execute a script in it that is creating a new file, like this:<pre class="source-code">
$ docker container run --name demo \   alpine /bin/sh -c 'echo "This is a test" &gt; sample.txt'</pre></li> <li>The preceding command creates a container named <code>demo</code>, and, inside this container, creates a file called <code>sample.txt</code> with the content <code>This is a test</code>. The container exits after running the <code>echo</code> command but remains in memory, available for us to do our investigations.</li>
<li>Let’s use the <code>diff</code> command to find out what has changed in the container’s filesystem concerning the filesystem of the original image, as follows:<pre class="source-code">
$ docker container diff demo</pre></li> </ol>
<p>The output should look like this:</p>
<pre class="source-code">
A /sample.txt</pre> <ol>
<li value="4">A new file, as indicated by the letter <code>A</code>, has been added to the filesystem of the container, as expected. Since all layers that stem from the underlying image (Alpine, in this case) are immutable, the change could only happen in the writeable container layer.</li>
</ol>
<p>Files that have changed compared to the original image will be marked with a <code>C</code> and those that have been deleted with a <code>D</code>.</p>
<p>Now, if we remove the container from memory, its container layer will also be removed, and with it, all the changes will be irreversibly deleted. If we need our changes to persist even beyond the lifetime of the container, this is not a solution. Luckily, we have better options, in the form of Docker volumes. Let’s get to know them.</p>
<h2 id="_idParaDest-117"><a id="_idTextAnchor114"/>Creating volumes</h2>
<p>When using Docker Desktop on a macOS or Windows computer, containers are not running natively <a id="_idIndexMarker350"/>on macOS or Windows but rather in a (hidden) VM created by Docker Desktop.</p>
<p>To demonstrate how and where the underlying data structures are created in the respective filesystem (macOS or Windows), we need to be a bit creative. If, on the other hand, we are doing the same on a Linux computer, things are straightforward.</p>
<p>Let’s start with a simple exercise to create a volume:</p>
<ol>
<li value="1">Open a new Terminal window and type in this command:<pre class="source-code">
$ docker volume create sample</pre></li> </ol>
<p>You should get this response:</p>
<pre class="source-code">
sample</pre> <p>Here, the name of the created volume will be the output.</p>
<p>The default volume <a id="_idIndexMarker351"/>driver is the so-called <strong class="bold">local driver</strong>, which stores the data locally in the host filesystem.</p>
<ol>
<li value="2">The easiest way to find out where the data is stored on the host is by using the <code>docker volume inspect</code> command on the volume we just created. The actual location can differ from system to system, so this is the safest way to find the target folder. So, let’s use this command:<pre class="source-code">
$ docker volume inspect sample</pre></li> </ol>
<p>We should see something like this:</p>
<div><div><img alt="Figure 5.1 – Inspecting the Docker volume called sample" height="445" src="img/B19199_05_01.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Inspecting the Docker volume called sample</p>
<p>The host folder <a id="_idIndexMarker352"/>can be found in the output under <code>Mountpoint</code>. In our case, the folder is <code>/var/lib/docker/volumes/sample/_data</code>.</p>
<ol>
<li value="3">Alternatively, we can create a volume using the dashboard of Docker Desktop:<ol><li>Open the Dashboard of Docker Desktop.</li><li>On the left-hand side, select the <strong class="bold">Volumes</strong> tab.</li><li>In the top-right corner, click the <strong class="bold">Create</strong> button, as shown in the following screenshot:</li></ol></li>
</ol>
<div><div><img alt="Figure 5.2 – Creating a new Docker volume with Docker Desktop" height="605" src="img/B19199_05_02.jpg" width="1028"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Creating a new Docker volume with Docker Desktop</p>
<ol>
<li value="4">Type in <code>sample-2</code> as the <a id="_idIndexMarker353"/>name for the new volume and click <strong class="bold">Create</strong>. You should now see this:</li>
</ol>
<div><div><img alt="Figure 5.3 – List of Docker volumes shown in Docker Desktop" height="464" src="img/B19199_05_03.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – List of Docker volumes shown in Docker Desktop</p>
<p>There are other volume drivers available from third parties, in the form of plugins. We can use the <code>--driver</code> parameter in the <code>create</code> command to select a different volume driver.</p>
<p>Other volume drivers use different types of storage systems to back a volume, such as cloud storage, <strong class="bold">Network File System</strong> (<strong class="bold">NFS</strong>) drives, software-defined storage, and more. The discussion <a id="_idIndexMarker354"/>of the correct usage of other volume drivers is beyond the scope of this book, though.</p>
<h2 id="_idParaDest-118"><a id="_idTextAnchor115"/>Mounting a volume</h2>
<p>Once we have <a id="_idIndexMarker355"/>created a named volume, we can mount it into a container by following these steps:</p>
<ol>
<li value="1">For this, we can use the <code>--volume</code> or <code>-v</code> parameter in the <code>docker container run</code> command, like this:<pre class="source-code">
$ docker container run --name test -it \     -v sample:/data \     alpine /bin/sh</pre></li> </ol>
<p>If you are working on a clean Docker environment, then the output produced by this command should look similar to this:</p>
<pre class="source-code">
Unable to find image 'alpine:latest' locally latest:Pulling from library/alpine
050382585609: Pull complete
Digest: sha256: 8914eb54f968791faf6a86...
Status: Downloaded newer image for alpine:latest
/ #</pre>
<p>Otherwise, you should just see the prompt of the Bourne shell running inside the Alpine container:</p>
<pre class="source-code">
/ #</pre> <p>The preceding command mounts the sample volume to the <code>/data</code> folder inside the container.</p>
<ol>
<li value="2">Inside the container, we can now create files in the <code>/data</code> folder, as follows:<pre class="source-code">
/ # cd /data/ # echo "Some data" &gt; data.txt/ # echo "Some more data" &gt; data2.txt</pre></li> <li>If we were to navigate to the host folder that contains the data of the volume and list its content, we should see the two files we just created inside the container. But this is a bit more involved so long as we are working on a Mac or Windows computer and will be explained in detail in the <em class="italic">Accessing Docker volumes</em> section. Stay tuned.</li>
<li>Exit the <a id="_idIndexMarker356"/>tool container by pressing <em class="italic">Ctrl</em> + <em class="italic">D</em>.</li>
<li>Now, let’s delete the dangling <code>test</code> container:<pre class="source-code">
$ docker container rm test</pre></li> <li>Next, we must run another one based on CentOS. This time, we are even mounting our volume to a different container folder, <code>/app/data</code>, like this:<pre class="source-code">
$ docker container run --name test2 -it --rm \     -v sample:/app/data \     centos:7 /bin/bash</pre></li> </ol>
<p>You should see an output similar to this:</p>
<pre class="source-code">
Unable to find image 'centos:7' locally7: Pulling from library/centos
8ba884070f61: Pull complete
Digest: sha256:a799dd8a2ded4a83484bbae769d9765...
Status: Downloaded newer image for centos:7
[root@275c1fe31ec0 /]#</pre>
<p>The last line of the preceding output indicates that we are at the prompt of the Bash shell running inside the CentOS container.</p>
<ol>
<li value="7">Once inside the CentOS container, we can navigate to the <code>/app/data</code> folder to which we have mounted the volume and list its content, as follows:<pre class="source-code">
[root@275c1fe31ec0 /]# cd /app/data[root@275c1fe31ec0 /]# ls –l</pre></li> </ol>
<p>As expected, we should see these two files:</p>
<pre class="source-code">
-rw-r--r-- 1 root root 10 Dec  4 14:03 data.txt-rw-r--r-- 1 root root 15 Dec  4 14:03 data2.txt</pre>
<p>This is the <a id="_idIndexMarker357"/>definitive proof that data in a Docker volume persists beyond the lifetime of a container, as well as that volumes can be reused by other, even different, containers from the one that used it first.</p>
<p>It is important to note that the folder inside the container to which we mount a Docker volume is excluded from the Union filesystem. That is, each change inside this folder and any of its subfolders will not be part of the container layer but will be persisted in the backing storage provided by the volume driver. This fact is really important since the container layer is deleted when the corresponding container is stopped and removed from the system.</p>
<ol>
<li value="8">Exit the CentOS container with <em class="italic">Ctr</em>l + <em class="italic">D</em>.</li>
</ol>
<p>Great – we have learned how to mount Docker volumes into a container! Next, we will learn how to delete existing volumes from our system.</p>
<h2 id="_idParaDest-119"><a id="_idTextAnchor116"/>Removing volumes</h2>
<p>Volumes can be removed using the <code>docker volume rm</code> command. It is important to remember <a id="_idIndexMarker358"/>that removing a volume destroys the containing data irreversibly, and thus is to be considered a dangerous command. Docker helps us a bit in this regard, as it does not allow us to delete a volume that is still in use by a container. Always make sure before you remove or delete a volume that you either have a backup of its data or you don’t need this data anymore. Let’s learn how to remove volumes by following these steps:</p>
<ol>
<li value="1">The following command deletes the sample volume that we created earlier:<pre class="source-code">
$ docker volume rm sample</pre></li> <li>After executing the preceding command, double-check that the folder on the host has been deleted. You can use this command to list all volumes defined on your system:<pre class="source-code">
$ docker volume ls</pre></li> </ol>
<p>Make sure the <code>sample</code> volume has been deleted.</p>
<ol>
<li value="3">Now, also remove the <code>sample-2</code> volume from your system.</li>
<li>To remove <a id="_idIndexMarker359"/>all running containers to clean up the system, run the following command:<pre class="source-code">
$ docker container rm -v -f $(docker container ls -aq)</pre></li> <li>Note that by using the <code>-v</code> or <code>--volume</code> flag in the command you use to remove a container, you can ask the system to also remove any anonymous volume associated with that particular container. Of course, that will only work if the particular volume is only used by this container.</li>
</ol>
<p>In the next section, we will show you how to access the backing folder of a volume when working with Docker Desktop.</p>
<h2 id="_idParaDest-120"><a id="_idTextAnchor117"/>Accessing Docker volumes</h2>
<p>Now, let’s for a moment assume that we are on a Mac with macOS. This operating system is <a id="_idIndexMarker360"/>not based on Linux but on a different Unix flavor. Let’s see whether we can find the data structure for the <code>sample</code> and <code>sample-2</code> volumes, where the <code>docker volume inspect</code> command told us so:</p>
<ol>
<li value="1">First, let’s create two named Docker volumes, either using the command line or doing the same via the dashboard of Docker Desktop:<pre class="source-code">
$ docker volume create sample$ docker volume create sample-2</pre></li> <li>In your Terminal, try to navigate to that folder:<pre class="source-code">
$ cd /var/lib/docker/volumes/sample/_data</pre></li> </ol>
<p>On the author’s MacBook Air, this is the response to the preceding command:</p>
<pre class="source-code">
cd: no such file or directory: /var/lib/docker/volumes/sample/_data</pre> <p>This was expected since Docker is not running natively on Mac but inside a slim VM, as mentioned earlier in this chapter.</p>
<p>Similarly, if you are using a Windows machine, you won’t find the data where the <code>inspect</code> command indicated.</p>
<p>It turns out that on a Mac, the data for the VM that Docker creates can be found in the <code>~/</code><code>Library/Containers/com.docker.docker/Data/vms/0</code> folder.</p>
<p>To access <a id="_idIndexMarker361"/>this data, we need to somehow get into this VM. On a Mac, we have two options to do so. The first is to use the <code>terminal screen</code> command. However, this is very specific to macOS and thus we will not discuss it here. The second option is to get access to the filesystem of Docker on Mac via the special <code>nsenter</code> command, which should be executed inside a Linux container such as Debian. This also works on Windows, and thus we will show the steps needed using this second option.</p>
<ol>
<li value="3">To run a container that can inspect the underlying host filesystem on your system, use this command:<pre class="source-code">
$ docker container run -it --privileged --pid=host \    debian nsenter -t 1 -m -u -n -i sh</pre></li> </ol>
<p>When running the container, we execute the following command inside the container:</p>
<pre class="source-code">
nsenter -t 1 -m -u -n -i sh</pre> <p>If that sounds complicated to you, don’t worry; you will understand more as we proceed through this book. If there is one takeaway, then it is to realize how powerful the right use of containers can be.</p>
<ol>
<li value="4">From within this container, we can now list all the volumes that are defined with<code> / # ls -l /var/lib/docker/volumes</code>. What we get should look similar to this:</li>
</ol>
<div><div><img alt="Figure 5.4 – List of Docker volumes via nsenter" height="211" src="img/B19199_05_04.jpg" width="1099"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – List of Docker volumes via nsenter</p>
<ol>
<li value="5">Next, navigate <a id="_idIndexMarker362"/>to the folder representing the mount point of the volume:<pre class="source-code">
/ # cd /var/lib/docker/volumes/sample/_data</pre></li> <li>And then list its content, as follows:<pre class="source-code">
/var/lib/docker/volumes/sample/_data # ls –l</pre></li> </ol>
<p>This should output the following:</p>
<pre class="source-code">
total 0</pre> <p>The folder is currently empty since we have not yet stored any data in the volume.</p>
<ol>
<li value="7">Similarly, for our <code>sample-2</code> volume, we can use the following command:<pre class="source-code">
/ # cd /var/lib/docker/volumes/sample-2/_data/var/lib/docker/volumes/sample-2/ # ls –l</pre></li> </ol>
<p>This should output the following:</p>
<pre class="source-code">
total 0</pre> <p>Again, this indicates that the folder is currently empty.</p>
<ol>
<li value="8">Next, let’s generate two files with data in the <code>sample</code> volume from within an Alpine container. First, open a new Terminal window, since the other one is blocked by our <code>nsenter</code> session.</li>
<li>To run the container and mount the <code>sample</code> volume to the <code>/data</code> folder of the container, use the following code:<pre class="source-code">
$ docker container run --rm -it \    -v sample:/data alpine /bin/sh</pre></li> <li>Generate <a id="_idIndexMarker363"/>two files in the <code>/data</code> folder inside the container, like this:<pre class="source-code">
/ # echo "Hello world" &gt; /data/sample.txt/ # echo "Other message" &gt; /data/other.txt</pre></li> <li>Exit the Alpine container by pressing <em class="italic">Ctrl</em> + <em class="italic">D</em>.</li>
<li>Back in the <code>nsenter</code> session, try to list the content of the sample volume again using this command:<pre class="source-code">
/ # cd /var/lib/docker/volumes/sample/_data/ # ls -l</pre></li> </ol>
<p>This time, you should see this:</p>
<pre class="source-code">
total 8-rw-r--r--    1 root    root    10 Dec  4 14:03 data.txt
-rw-r--r--    1 root    root    15 Dec  4 14:03 data2.txt</pre>
<p>This indicates that we have data written to the filesystem of the host.</p>
<ol>
<li value="13">Let’s try to create a file from within this special container, and then list the content of the folder, as follows:<pre class="source-code">
/ # echo "I love Docker" &gt; docker.txt</pre></li> <li>Now, let’s see what we got:<pre class="source-code">
/ # ls –l</pre></li> </ol>
<p>This gives us something like this:</p>
<pre class="source-code">
total 12-rw-r--r--    1 root    root    10 Dec  4 14:03 data.txt
-rw-r--r--    1 root    root    15 Dec  4 14:03 data2.txt
-rw-r--r--    1 root    root    14 Dec  4 14:25 docker.txt</pre>
<ol>
<li value="15">Let’s see whether <a id="_idIndexMarker364"/>we can see this new file from within a container mounting the sample volume. From within a new Terminal window, run this command:<pre class="source-code">
$ docker container run --rm \    -v sample:/data \    centos:7 ls -l /data</pre></li> </ol>
<p>That should output this:</p>
<pre class="source-code">
total 12-rw-r--r-- 1 root root 10 Dec  4 14:03 data.txt
-rw-r--r-- 1 root root 15 Dec  4 14:03 data2.txt
-rw-r--r-- 1 root root 14 Dec  4 14:25 docker.txt</pre>
<p>The preceding output is showing us that we can add content directly to the host folder backing the volume and then access it from a container that has the volume mounted.</p>
<ol>
<li value="16">To exit our special privileged container with the <code>nsenter</code> tool, we can just press <em class="italic">Ctrl</em> + <em class="italic">D</em> twice.</li>
</ol>
<p>We have <a id="_idIndexMarker365"/>now created data using two different methods:</p>
<ul>
<li>From within a container that has a sample volume mounted</li>
<li>Using a special privileged folder to access the hidden VM used by Docker Desktop, and directly writing into the backing folder of the sample volume</li>
</ul>
<p>In the next section, we will learn how to share data between containers.</p>
<h1 id="_idParaDest-121"><a id="_idTextAnchor118"/>Sharing data between containers</h1>
<p>Containers are like sandboxes for the applications running inside them. This is mostly beneficial and wanted, to protect applications running in different containers from each other. It also <a id="_idIndexMarker366"/>means that the whole filesystem visible to <a id="_idIndexMarker367"/>an application running inside a container is private to this application, and no other application running in a different container can interfere with it.</p>
<p>At times, though, we want to share data between containers. Say an application running in <strong class="bold">container A</strong> produces some data that will be consumed by another application running in <strong class="bold">container B</strong>. How can we achieve this? Well, I’m sure you’ve already guessed it – we can use Docker volumes for this purpose. We can create a volume and mount it to container A, as well as to container B. In this way, both applications A and B have access to the same data.</p>
<p>Now, as always when multiple applications or processes concurrently access data, we have to be very careful to avoid inconsistencies. To avoid concurrency problems such as race conditions, we should ideally have only one application or process that is creating or modifying data, while all other processes concurrently accessing this data only read it.</p>
<p class="callout-heading">Race condition</p>
<p class="callout">A race condition is a <a id="_idIndexMarker368"/>situation that can occur in computer programming when the output of a program or process is affected by the order and timing of events in ways that are unpredictable or unexpected. In a race condition, two or more parts of a program are trying to access or modify the same data or resource simultaneously, and the outcome depends on the timing of these events. This can result in incorrect or inconsistent output, errors, or crashes.</p>
<p>We can enforce a process running in a container to only be able to read the data in a volume by mounting this volume as read-only. Here’s how we can do this:</p>
<ol>
<li value="1">Execute the following command:<pre class="source-code">
$ docker container run -it --name writer \    -v shared-data:/data \    .alpine /bin/sh</pre></li> </ol>
<p>Here, we are creating a container called <code>writer</code> that has a volume, <code>shared-data</code>, mounted in default read/write mode.</p>
<ol>
<li value="2">Try to <a id="_idIndexMarker369"/>create a file inside this container, like this:<pre class="source-code">
# / echo "I can create a file" &gt; /data/sample.txt</pre></li> </ol>
<p>It should succeed.</p>
<ol>
<li value="3">Exit this <a id="_idIndexMarker370"/>container by pressing <em class="italic">Ctrl</em> + <em class="italic">D</em> or typing <code>exit</code> and hitting the <em class="italic">Enter</em> key at the prompt.</li>
<li>Then, execute the following command:<pre class="source-code">
$ docker container run -it --name reader \    -v shared-data:/app/data:ro \    ubuntu:22.04 /bin/bash</pre></li> </ol>
<p>Here we have <a id="_idIndexMarker371"/>a container called <code>reader</code> that has the same volume mounted as <strong class="bold">read-only</strong> (<strong class="bold">ro</strong>).</p>
<ol>
<li value="5">First, make sure you can see the file created in the first container, like this:<pre class="source-code">
$ ls -l /app/data</pre></li> </ol>
<p>This should give you something like this:</p>
<pre class="source-code">
total 4-rw-r--r-- 1 root root 20 Jan 28 22:55 sample.txt</pre>
<ol>
<li value="6">Then, try to create a file, like this:<pre class="source-code">
# / echo "Try to break read/only" &gt; /app/data/data.txt</pre></li> </ol>
<p>It will fail with the following message:</p>
<pre class="source-code">
bash: /app/data/data.txt: Read-only file system</pre> <p>This is expected since the volume was mounted as read-only.</p>
<ol>
<li value="7">Let’s exit the <a id="_idIndexMarker372"/>container by typing <code>exit</code> at the <a id="_idIndexMarker373"/>command prompt. Back on the host, let’s clean up all containers and volumes, as follows:<pre class="source-code">
$ docker container rm -f $(docker container ls -aq)$ docker volume rm $(docker volume ls -q)</pre></li> </ol>
<p><strong class="bold">Exercise</strong>: Analyze the preceding commands carefully and try to understand what exactly they do and how they work.</p>
<p>Next, we will show you how to mount arbitrary folders from the Docker host into a container.</p>
<h1 id="_idParaDest-122"><a id="_idTextAnchor119"/>Using host volumes</h1>
<p>In certain scenarios, such as <a id="_idIndexMarker374"/>when developing new containerized applications or when a containerized application needs to consume data from a certain folder produced – say, by a legacy application – it is very helpful to use volumes that mount a specific host folder. Let’s look at the following example:</p>
<pre class="source-code">
$ docker container run --rm -it \    -v $(pwd)/src:/app/src \
    alpine:latest /bin/sh</pre>
<p>The preceding expression interactively starts an Alpine container with a shell and mounts the <code>src</code> subfolder of the current directory into the container at <code>/app/src</code>. We need to use <code>$(pwd)</code> (or <code>pwd</code>, for that matter), which is the current directory, as when working with volumes, we always need to use absolute paths.</p>
<p>Developers use these techniques all the time when they are working on their application that runs in a container and wants to make sure that the container always contains the latest changes <a id="_idIndexMarker375"/>to the code, without the need to rebuild the image and rerun the container after each change.</p>
<p>Let’s make a sample to demonstrate how that works. Let’s say we want to create a simple static website while using Nginx as our web server, as follows:</p>
<ol>
<li value="1">First, let’s create a new subfolder on the host. The best place to do this is inside the chapter folder we created at the beginning of the chapter. There, we will put our web assets such as HTML, CSS, and JavaScript files. Use this command to create the subfolder and navigate to it:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch05$ mkdir my-web &amp;&amp; cd my-web</pre></li> <li>Then, create a simple web page, like this:<pre class="source-code">
$ echo "&lt;h1&gt;Personal Website&lt;/h1&gt;" &gt; index.xhtml</pre></li> <li>Now, add a Dockerfile that will contain instructions on how to build the image containing our sample website. Add a file called <code>Dockerfile</code> to the folder, with this content:<pre class="source-code">
FROM nginx:alpineCOPY . /usr/share/nginx/html</pre></li> </ol>
<p>The Dockerfile starts with the latest Alpine version of Nginx and then copies all files from the current host directory into the <code>/usr/share/nginx/html</code> containers folder. This is where Nginx expects web assets to be located.</p>
<ol>
<li value="4">Now, let’s build the image with the following command:<pre class="source-code">
$ docker image build -t my-website:1.0 .</pre></li> </ol>
<p>Please do <a id="_idIndexMarker376"/>not forget the period (<code>.</code>) at the end of the preceding command. The output of this command will look similar to this:</p>
<div><div><img alt="Figure 5.5 – Building a Docker image for a sample Nginx web server" height="547" src="img/B19199_05_05.jpg" width="1100"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Building a Docker image for a sample Nginx web server</p>
<ol>
<li value="5">Finally, we will run a container from this image. We will run the container in detached mode, like this:<pre class="source-code">
$ docker container run -d \    --name my-site \    -p 8080:80 \    my-website:1.0</pre></li> </ol>
<p>Note the <code>-p 8080:80</code> parameter. We haven’t discussed this yet, but we will do so in detail in <a href="B19199_10.xhtml#_idTextAnchor218"><em class="italic">Chapter 10</em></a>, <em class="italic">Using </em><em class="italic">Single-Host Networking</em>. At the moment, just know that this maps the container port <code>80</code> on which Nginx is listening for incoming requests to port <code>8080</code> of your laptop, where you can then access the application.</p>
<ol>
<li value="6">Now, open a browser tab and navigate to <code>http://localhost:8080/index.xhtml</code>; you should see your website, which currently consists only of a title, <strong class="bold">Personal Website</strong>.</li>
<li>Now, edit the <code>index.xhtml</code> file in your favorite editor so that it looks like this:<pre class="source-code">
&lt;h1&gt;Personal Website&lt;/h1&gt;&lt;p&gt;This is some text&lt;/p&gt;</pre></li> <li>Now, save it, and then refresh the browser. Oh! That didn’t work. The browser still displays <a id="_idIndexMarker377"/>the previous version of the <code>index.xhtml</code> file, which consists only of the title. So, let’s stop and remove the current container, then rebuild the image and rerun the container, as follows:<pre class="source-code">
$ docker container rm -f my-site$ docker image build -t my-website:1.0 .$ docker container run -d \    --name my-site \    -p 8080:80 \    my-website:1.0</pre></li> <li>Refresh the browser again. This time, the new content should be shown. Well, it worked, but there is way too much friction involved. Imagine having to do this every time that you make a simple change to your website. That’s not sustainable.</li>
<li>Now is the time to use host-mounted volumes. Once again, remove the current container and rerun it with the volume mount, like this:<pre class="source-code">
$ docker container rm -f my-site$ docker container run -d \    --name my-site \    -v $(pwd):/usr/share/nginx/html \    -p 8080:80 \    my-website:1.0</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">If you are working on Windows, a pop-up window will be displayed that says Docker wants to access the hard drive and that you have to click on the <strong class="bold">Share </strong><strong class="bold">access</strong> button.</p>
<ol>
<li value="11">Now, append some <a id="_idIndexMarker378"/>more content to the <code>index.xhtml</code> file and save it. Then, refresh your browser. You should see the changes. This is exactly what we wanted to achieve; we also call this an edit-and-continue experience. You can make as many changes in your web files and always immediately see the result in the browser, without having to rebuild the image and restart the container containing your website.</li>
<li>When you’re done playing with your web server and wish to clean up your system, remove the container with the following command:<pre class="source-code">
$ docker container rm -f my-site</pre></li> </ol>
<p>It is important to note that the updates are now propagated bi-directionally. If you make changes on the host, they will be propagated to the container, and vice versa. It’s also important to note that when you mount the current folder into the container target folder, <code>/usr/share/nginx/html</code>, the content that is already there is replaced by the content of the host folder.</p>
<p>In the next section, we will learn how to define volumes used in a Docker image.</p>
<h1 id="_idParaDest-123"><a id="_idTextAnchor120"/>Defining volumes in images</h1>
<p>If we go <a id="_idIndexMarker379"/>back to what we have learned about containers <a id="_idIndexMarker380"/>in <a href="B19199_04.xhtml#_idTextAnchor083"><em class="italic">Chapter 4</em></a>, <em class="italic">Creating and Managing Container Images</em>, for more moment, then we have this: the filesystem of each container, when started, is made up of the immutable layers of the underlying image, plus a writable container layer specific to this very container. All changes that the processes running inside the container make to the filesystem will be persisted in this container layer. Once the container is stopped and removed from the system, the corresponding container layer is deleted from the system and irreversibly lost.</p>
<p>Some applications, such as databases running in containers, need to persist their data beyond the lifetime of the container. In this case, they can use volumes. To make things a bit more explicit, let’s look at a concrete example. MongoDB is a popular open source document database. Many developers use MongoDB as a storage service for their applications. The maintainers of MongoDB have created an image and published it on Docker Hub, which can <a id="_idIndexMarker381"/>be used to run an instance of <a id="_idIndexMarker382"/>the database in a container. This database will be producing data that needs to be persisted long term, but the MongoDB maintainers do not know who uses this image and how it is used. So, they can’t influence the <code>docker container run</code> command with which the users of the database will start this container. So, how can they define volumes?</p>
<p>Luckily, there is a way of defining volumes in the Dockerfile. The keyword to do so is <code>VOLUME</code>, and we can either add the absolute path to a single folder or a comma-separated list of paths. These paths represent the folders of the container’s filesystem. Let’s look at a few samples of such volume definitions, as follows:</p>
<pre class="source-code">
VOLUME /app/dataVOLUME /app/data, /app/profiles, /app/config
VOLUME ["/app/data", "/app/profiles", "/app/config"]</pre>
<p>The first line in the preceding snippet defines a single volume to be mounted at <code>/app/data</code>. The second line defines three volumes as a comma-separated list. The last one defines the same as the second line, but this time, the value is formatted as a JSON array.</p>
<p>When a container is started, Docker automatically creates a volume and mounts it to the corresponding target folder of the container for each path defined in the Dockerfile. Since each volume is created automatically by Docker, it will have an SHA-256 as its ID.</p>
<p>At container runtime, the folders defined as volumes in the Dockerfile are excluded from the Union filesystem, and thus any changes in those folders do not change the container layer but are persisted to the respective volume. It is now the responsibility of the operations engineers to make sure that the backing storage of the volumes is properly backed up.</p>
<p>We can use the <code>docker image inspect</code> command to get information about the volumes defined in the Dockerfile. Let’s see what MongoDB gives us by following these steps:</p>
<ol>
<li value="1">First, we will <a id="_idIndexMarker383"/>pull the image with the following command:<pre class="source-code">
$ docker image pull mongo:5.0</pre></li> <li>Then, we will <a id="_idIndexMarker384"/>inspect this image, and use the <code>--format</code> parameter to only extract the essential part from the massive amount of data, as follows:<pre class="source-code">
$ docker image inspect \    --format='{{json .ContainerConfig.Volumes}}' \    mongo:5.0 | jq .</pre></li> </ol>
<p>Note <code>| jq .</code> at the end of the command. We are piping the output of <code>docker image inspect</code> into the <code>jq</code> tool, which nicely formats the output.</p>
<p class="callout-heading">Tip</p>
<p class="callout">If you haven’t installed <code>jq</code> yet on your system, you can do so with <code>brew install jq </code>on macOS or <code>choco install jq</code> on Windows.</p>
<p>The preceding command will return the following result:</p>
<pre class="source-code">
{    "/data/configdb": {},
    "/data/db": {}
}</pre>
<p>As we can see, the Dockerfile for MongoDB defines two volumes at <code>/data/configdb</code> and <code>/data/db</code>.</p>
<ol>
<li value="3">Now, let’s run an instance of MongoDB in the background as a daemon, as follows:<pre class="source-code">
$ docker run --name my-mongo -d mongo:5.0</pre></li> <li>We can now use the <code>docker container inspect</code> command to get information <a id="_idIndexMarker385"/>about the volumes that have been <a id="_idIndexMarker386"/>created, among other things. Use this command to just get the volume information:<pre class="source-code">
$ docker inspect --format '{{json .Mounts}}' my-mongo | jq .</pre></li> </ol>
<p>The preceding command should output something like this (shortened):</p>
<div><div><img alt="Figure 5.6 – Inspecting the MongoDB volumes" height="415" src="img/B19199_05_06.jpg" width="1101"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Inspecting the MongoDB volumes</p>
<p>The <code>Source</code> field gives us the path to the host directory, where the data produced by MongoDB inside the container will be stored.</p>
<p>Before you leave, clean up the Mongo DB container with the following command:</p>
<pre class="source-code">
$ docker rm -f my-mongo</pre> <p>That’s it for the moment concerning volumes. In the next section, we will explore how we can configure applications running in containers, and the container image build process itself.</p>
<h1 id="_idParaDest-124"><a id="_idTextAnchor121"/>Configuring containers</h1>
<p>More often than not, we need to provide some configuration to the application running inside a container. The configuration is often used to allow the same container to run in very different <a id="_idIndexMarker387"/>environments, such as in development, test, staging, or production environments. In Linux, configuration values are often provided via environment variables.</p>
<p>We have learned that an application running inside a container is completely shielded from its host environment. Thus, the environment variables that we see on the host are different from the ones that we see within a container.</p>
<p>Let’s prove this by looking at what is defined on our host:</p>
<ol>
<li value="1">Use this command to display a list of all environment variables defined for your Terminal session:<pre class="source-code">
$ export</pre></li> </ol>
<p>On the author’s macOS, the output is something like this (shortened):</p>
<pre class="source-code">
...COLORTERM=truecolor
COMMAND_MODE=unix2003
...
HOME=/Users/gabriel
HOMEBREW_CELLAR=/opt/homebrew/Cellar
HOMEBREW_PREFIX=/opt/homebrew
HOMEBREW_REPOSITORY=/opt/homebrew
INFOPATH=/opt/homebrew/share/info:/opt/homebrew/...:
LANG=en_GB.UTF-8
LESS=-R
LOGNAME=gabriel
...</pre>
<ol>
<li value="2">Next, let’s run a shell inside an Alpine container:<ol><li>Run the container with this command:</li></ol><pre class="source-code">
<code>$ docker container run --rm -it alpine /bin/sh</code></pre></li> </ol>
<p>Just as a reminder, we are using the <code>--rm</code> command-line parameter so that we do not have to remove the dangling container once we stop it.</p>
<ol>
<li value="2">Then, list the <a id="_idIndexMarker388"/>environment variables we can see there with this command:</li>
</ol>
<pre class="source-code">
<code>/ # export</code></pre> <p>This should produce the following output:</p>
<pre class="source-code">
<code>export HOME='/root'</code><code>export HOSTNAME='91250b722bc3'</code>
<code>export PATH='/usr/local/sbin:/usr/local/bin:...'</code>
<code>export PWD='/'</code>
<code>export SHLVL='1'</code>
<code>export TERM='xterm'</code></pre>
<p>The preceding output is different than what we saw directly on the host.</p>
<ol>
<li value="3">Hit <em class="italic">Ctrl</em> + <em class="italic">D</em> to leave and stop the Alpine container.</li>
</ol>
<p>Next, let’s define environment variables for containers.</p>
<h2 id="_idParaDest-125"><a id="_idTextAnchor122"/>Defining environment variables for containers</h2>
<p>Now, the good <a id="_idIndexMarker389"/>thing is that we can pass some configuration values into the container at start time. We can use the <code>--env</code> (or the short form, <code>-e</code>) parameter in the form of <code>--env &lt;key&gt;=&lt;value&gt;</code> to do so, where <code>&lt;key&gt;</code> is the name of the environment variable and <code>&lt;value&gt;</code> represents the value to be associated with that variable. Let’s assume we want the app that is to be run in our container to have access to an environment variable called <code>LOG_DIR</code>, with a value of <code>/var/log/my-log</code>. We can do so with this command:</p>
<pre class="source-code">
$ docker container run --rm -it \    --env LOG_DIR=/var/log/my-log \
    alpine /bin/sh
/ #</pre>
<p>The preceding code starts a shell in an Alpine container and defines the requested environment inside the running container. To prove that this is true, we can execute this command inside the Alpine container:</p>
<pre class="source-code">
/ # export | grep LOG_DIR</pre> <p>The output should be as follows:</p>
<pre class="source-code">
export LOG_DIR='/var/log/my-log'</pre> <p>The output <a id="_idIndexMarker390"/>looks as expected. We now have the requested environment variable with the correct value available inside the container. We can, of course, define more than just one environment variable when we run a container. We just need to repeat the <code>--env</code> (or <code>-e</code>) parameter. Have a look at this sample:</p>
<pre class="source-code">
$ docker container run --rm -it \    --env LOG_DIR=/var/log/my-log \
    --env MAX_LOG_FILES=5 \
    --env MAX_LOG_SIZE=1G \
    alpine /bin/sh</pre>
<p>After running the preceding command, we are left at the command prompt inside the Alpine container:</p>
<pre class="source-code">
/ #</pre> <p>Let’s list the environment variables with the following command:</p>
<pre class="source-code">
/ # export | grep LOG</pre> <p>We will see the following:</p>
<pre class="source-code">
export LOG_DIR='/var/log/my-log'export MAX_LOG_FILES='5'
export MAX_LOG_SIZE='1G'</pre>
<p>Now, let’s look <a id="_idIndexMarker391"/>at situations where we have many environment variables to configure.</p>
<h2 id="_idParaDest-126"><a id="_idTextAnchor123"/>Using configuration files</h2>
<p>Complex applications can have many environment variables to configure, and thus our command to <a id="_idIndexMarker392"/>run the corresponding container can quickly become unwieldy. For this purpose, Docker allows us to pass a collection of environment variable definitions as a file. We have the <code>--env-file</code> parameter in the <code>docker container run</code> command for this purpose.</p>
<p>Let’s try this out, as follows:</p>
<ol>
<li value="1">Navigate to the source folder for <code>chapter 5</code> that we created at the beginning of this chapter:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch05</pre></li> <li>Create a <code>config-file</code> subfolder and navigate to it, like this:<pre class="source-code">
$ mkdir config-file &amp;&amp; cd config-file</pre></li> <li>Use your favorite editor to create a file called <code>development.config</code> in this folder. Add the following content to the file and save it, as follows:<pre class="source-code">
LOG_DIR=/var/log/my-logMAX_LOG_FILES=5MAX_LOG_SIZE=1G</pre></li> </ol>
<p>Notice how we have the definition of a single environment variable per line in <code>&lt;key&gt;=&lt;value&gt;</code> format, where, once again, <code>&lt;key&gt;</code> is the name of the environment variable, and <code>&lt;value&gt;</code> represents the value to be associated with that variable.</p>
<ol>
<li value="4">Now, from within the <code>config-file</code> subfolder, let’s run an Alpine container, pass the file as an environment file, and run the <code>export</code> command inside the container to verify that the variables listed inside the file have indeed been created as environment variables inside the container, like this:<pre class="source-code">
$ docker container run --rm -it \    --env-file ./development.config \    alpine sh -c "export | grep LOG"</pre></li> </ol>
<p>And indeed, the variables are defined, as we can see in the output generated:</p>
<pre class="source-code">
export LOG_DIR='/var/log/my-log'export MAX_LOG_FILES='5'
export MAX_LOG_SIZE='1G'</pre>
<p>This is exactly what we expected.</p>
<p>Next, let’s look <a id="_idIndexMarker393"/>at how to define default values for environment variables that are valid for all container instances of a given Docker image.</p>
<h2 id="_idParaDest-127"><a id="_idTextAnchor124"/>Defining environment variables in container images</h2>
<p>Sometimes, we want to define some default value for an environment variable that must be <a id="_idIndexMarker394"/>present in each container instance of a given container image. We can do so in the Dockerfile that is used to create that image by following these steps:</p>
<ol>
<li value="1">Navigate to the source folder for <code>chapter 5</code> that we created at the beginning of this chapter:<pre class="source-code">
$ cd ~/The-Ultimate-Docker-Container-Book/ch05</pre></li> <li>Create a subfolder called <code>config-in-image</code> and navigate to it, like this:<pre class="source-code">
$ mkdir config-in-image &amp;&amp; cd config-in-image</pre></li> <li>Use your favorite editor to create a file called <code>Dockerfile</code> in the <code>config-in-image</code> subfolder. Add the following content to the file and save it:<pre class="source-code">
FROM alpine:latestENV LOG_DIR=/var/log/my-logENV MAX_LOG_FILES=5ENV MAX_LOG_SIZE=1G</pre></li> <li>Create a <a id="_idIndexMarker395"/>container image called <code>my-alpine</code> using the preceding Dockerfile, as follows:<pre class="source-code">
$ docker image build -t my-alpine .</pre></li> </ol>
<p class="callout-heading">Note</p>
<p class="callout">Don’t forget the period at the end of the preceding line!</p>
<ol>
<li value="5">Run a container instance from this image that outputs the environment variables defined inside the container, like this:<pre class="source-code">
$ docker container run --rm -it \    my-alpine sh -c "export | grep LOG"</pre></li> </ol>
<p>You should see the following in your output:</p>
<pre class="source-code">
export LOG_DIR='/var/log/my-log'export MAX_LOG_FILES='5'
export MAX_LOG_SIZE='1G'</pre>
<p>This is exactly what we expected.</p>
<ol>
<li value="6">The good thing, though, is that we are not stuck with those variable values at all. We can override one or many of them by using the <code>--env</code> parameter in the <code>docker container run</code> command. Use this command:<pre class="source-code">
$ docker container run --rm -it \    --env MAX_LOG_SIZE=2G \    --env MAX_LOG_FILES=10 \    my-alpine sh -c "export | grep LOG"</pre></li> <li>Now, have a look at the following command and its output:<pre class="source-code">
export LOG_DIR='/var/log/my-log'export MAX_LOG_FILES='10'export MAX_LOG_SIZE='2G'</pre></li> <li>We can <a id="_idIndexMarker396"/>also override default values by using environment files together with the <code>--env-file</code> parameter in the <code>docker container run</code> command. Please try it out for yourself.</li>
</ol>
<p>In the next section, we are going to introduce environment variables that are used at the build time of a Docker image.</p>
<h2 id="_idParaDest-128"><a id="_idTextAnchor125"/>Environment variables at build time</h2>
<p>Sometimes, we want to be able to define some environment variables that are valid at the time <a id="_idIndexMarker397"/>when we build a container image. Imagine that you want to define a <code>BASE_IMAGE_VERSION</code> environment variable that shall then be used as a parameter in your Dockerfile. Imagine the following Dockerfile:</p>
<pre class="source-code">
ARG BASE_IMAGE_VERSION=12.7-stretchFROM node:${BASE_IMAGE_VERSION}
WORKDIR /app
COPY packages.json .
RUN npm install
COPY . .
CMD npm start</pre>
<p>We are using the <code>ARG</code> keyword to define a default value that is used each time we build an image from the preceding Dockerfile. In this case, that means that our image uses the <code>node:12.7-stretch</code> base image.</p>
<p>Now, if we want to create a special image for, say, testing purposes, we can override this variable at image build time using the <code>--build-arg</code> parameter, as follows:</p>
<pre class="source-code">
$ docker image build \    --build-arg BASE_IMAGE_VERSION=12.7-alpine \
    -t my-node-app-test .</pre>
<p>In this <a id="_idIndexMarker398"/>case, the resulting <code>my-node-test:latest</code> image will be built from the <code>node:12.7-alpine</code> base image and not from the <code>node:12.7-stretch</code> default image.</p>
<p>To summarize, environment variables defined via <code>--env</code> or <code>--env-file</code> are valid at container runtime. Variables defined with <code>ARG</code> in the Dockerfile or <code>--build-arg</code> in the <code>docker container build</code> command are valid at container image build time. The former is used to configure an application running inside a container, while the latter is used to parameterize the container image build process.</p>
<p>And with that, we have come to the end of this chapter.</p>
<h1 id="_idParaDest-129"><a id="_idTextAnchor126"/>Summary</h1>
<p>In this chapter, we introduced Docker volumes, which can be used to persist the state produced by containers and make them durable. We can also use volumes to provide containers with data originating from various sources. We learned how to create, mount, and use volumes. We also learned various techniques for defining volumes such as by name, by mounting a host directory, or by defining volumes in a container image.</p>
<p>In this chapter, we also discussed how we can configure environment variables that can be used by applications running inside a container. We have shown how to define those variables in the <code>docker container run</code> command, either explicitly, one by one, or as a collection in a configuration file. Finally, we learned how to parameterize the build process of container images by using build arguments.</p>
<p>In the next chapter, we are going to introduce techniques commonly used to allow a developer to evolve, modify, debug, and test their code while running in a container.</p>
<h1 id="_idParaDest-130"><a id="_idTextAnchor127"/>Further reading</h1>
<p>The following arti<a href="http://dockr.ly/2EUjTml">cles provide more in-de</a>pth information:</p>
<ul>
<li><em class="italic">Use </em><em class="italic">volumes</em>: <a href="http://dockr.ly/2EUjTml">http://dockr.ly/2EUjTml</a></li>
<li><em class="italic">Manage data in </em><em class="italic">Docker</em>: <a href="http://dockr.ly/2EhBpzD">http://dockr.ly/2EhBpzD</a></li>
<li><em class="italic">Docker volumes</em> on <strong class="bold">Play with Docker</strong> (<strong class="bold">PWD</strong>): <a href="http://bit.ly/2sjIfDj">http://bit.ly/2sjIfDj</a></li>
<li><code>nsenter</code> —Linux man page, at <a href="https://bit.ly/2MEPG0n">https://bit.ly/2MEPG0n</a></li>
<li><em class="italic">Set environment </em><em class="italic">variables</em>: <a href="https://dockr.ly/2HxMCjS">https://dockr.ly/2HxMCjS</a></li>
<li><em class="italic">Understanding how ARG and FROM </em><em class="italic">interact</em>: <a href="https://dockr.ly/2OrhZgx">https://dockr.ly/2OrhZgx</a></li>
</ul>
<h1 id="_idParaDest-131"><a id="_idTextAnchor128"/>Questions</h1>
<p>Please try to answer the following questions to assess your learning progress:</p>
<ol>
<li value="1">How would you create a named data volume with a name such as <code>my-products</code> using the default driver?</li>
<li>How would you run a container using the Alpine image and mount the <code>my-products</code> volume in read-only mode into the <code>/data</code> container folder?</li>
<li>How would you locate the folder that is associated with the <code>my-products </code>volume and navigate to it? Also, how would you create a file, <code>sample.txt</code>, with some content?</li>
<li>How would you run another Alpine container where you mount the <code>my-products</code> volume to the <code>/app-data</code> folder, in read/write mode? Inside this container, navigate to the <code>/app-data</code> folder and create a <code>hello.txt</code> file with some content.</li>
<li>How would you mount a host volume – for example, <code>~/my-project</code> – into a container?</li>
<li>How would you remove all unused volumes from your system?</li>
<li>The list of environment variables that an application running in a container sees is the same as if the application were to run directly on the host.<ol><li>True</li><li>False</li></ol></li>
<li>Your application, which shall run in a container, needs a huge list of environment variables for configuration. What is the simplest method to run a container with your application and provide all this information to it?</li>
</ol>
<h1 id="_idParaDest-132"><a id="_idTextAnchor129"/>Answers</h1>
<p>Here are the answers to this chapter’s questions:</p>
<ol>
<li value="1">To create a named volume, run the following command:<pre class="source-code">
$ docker volume create my-products</pre></li> <li>Execute the following command:<pre class="source-code">
$ docker container run -it --rm \    -v my-products:/data:ro \    alpine /bin/sh</pre></li> <li>To achieve this result, do this:<ol><li>To get the path on the host for the volume, use this command</li></ol><pre class="source-code">
<code>$ docker volume inspect my-products | grep Mountpoint</code></pre><ol><li value="2">This should result in the following output</li></ol><pre class="source-code"><code>"Mountpoint": "/var/lib/docker/volumes/my-products/_data"</code></pre><ol><li value="1">Now, execute the following command to run a container and execute <code>nsenter</code> within it:</li></ol><pre class="source-code"><code>$ docker container run -it --privileged --pid=host \</code><code>    debian nsenter -t 1 -m -u -n -i sh</code></pre><ol><li value="1">Navigate to the folder containing the data for the <code>my-products</code> volume:</li></ol><pre class="source-code"><code>/ # cd /var/lib/docker/volumes/my-products/_data</code></pre><ol><li value="4">Create a file containing the text <code>"I love Docker"</code> within this folder:</li></ol><pre class="source-code"><code>/ # echo "I love Docker" &gt; sample.txt</code></pre><ol><li value="5">Exit <code>nsenter</code> and its container by pressing <em class="italic">Ctrl</em> + <em class="italic">D</em>.</li><li>Execute the following command to verify that the file generated in the host filesystem is indeed part of the volume and accessible to the container to which we’ll mount this volume:</li></ol><pre class="source-code"><code>$ docker container run --rm \</code><code>    --volume my-products:/data \</code><code>    alpine ls -l /data</code></pre></li> </ol>
<p>The output of the preceding command should look similar to this:</p>
<pre class="source-code">
<code>total 4</code><code>-rw-r--r--    1 root     root    14 Dec  4 17:35 sample.txt</code></pre>
<p>And indeed, we can see the file.</p>
<ol>
<li value="7">Optional: Run a modified version of the command to output the content of the <code>sample.txt</code> file.</li>
</ol>
<ol>
<li value="4">Execute the following command:<pre class="source-code">
$ docker run -it --rm -v my-products:/data:ro alpine /bin/sh/ # cd /data/data # cat sample.txt</pre></li> </ol>
<p>In another Terminal, execute this command:</p>
<pre class="source-code">
$ docker run -it --rm -v my-products:/app-data alpine /bin/sh/ # cd /app-data
/app-data # echo "Hello other container" &gt; hello.txt
/app-data # exit</pre>
<ol>
<li value="5">Execute a command such as this:<pre class="source-code">
$ docker container run -it --rm \    -v $HOME/my-project:/app/data \    alpine /bin/sh</pre></li> <li>Exit both containers and then, back on the host, execute this command:<pre class="source-code">
$ docker volume prune</pre></li> <li>The answer is <em class="italic">False</em> (B). Each container is a sandbox and thus has its very own environment.</li>
<li>Collect all environment variables and their respective values in a configuration file, which you then provide to the container with the <code>--env-file</code> command-line parameter in the <code>docker container run</code> command, like so:<pre class="source-code">
$ docker container run --rm -it \    --env-file ./development.config \    alpine sh -c "export"</pre></li> </ol>
</div>
</div></body></html>