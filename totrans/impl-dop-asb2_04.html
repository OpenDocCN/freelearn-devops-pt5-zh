<html><head></head><body>
        

                            
                    <h1 class="header-title">Playbooks and Inventory Files</h1>
                
            
            
                
<p>As we discovered in the previous chapters, Ansible offers unique, easy-to-comprehend implementations for creating automation, implementing Configuration Management solutions, maintaining infrastructure, and scaling out automation. Automation and Configuration Management implementations are developed and maintained using Ansible playbooks (as we discussed in the previous chapter), whereas infrastructure inventory is managed through one or many Ansible inventory hosts file. A playbook in Ansible is really quite simple to understand; it's simply a set of tasks to execute that are ordered in a structured format. These two very easy-to-understand concepts have helped pave the way and made Ansible as popular and robust as it is today.</p>
<p>The concept of an Ansible playbook is an easy one to grasp and understand. The same can be said for the the implementation of Ansible inventory files. Playbook's and roles in Ansible make up the bulk of the automation we will be developing throughout this book and are a core construct of the Ansible implementation. This chapter however will focus on Playbook's and Inventory files specifically. Inventory files exist to help us maintain the infrastructure we will target via a playbook and allow us to group similar devices and infrastructure when targeting remote hosts. These two constructs combined provide a highly scalable automation solution that can be used to maintain one machine or 10,000.</p>
<p>In this chapter, we will discuss and learn all about Ansible playbook's and Inventory solutions, and learn how to develop, maintain, and expand an Ansible footprint within an organization. The learning areas we are going to cover will include the following topics:</p>
<ul>
<li>Ansible Playbook Constructs</li>
<li>Ansible Play's and Task's</li>
<li>Variables and Variable Files</li>
<li>Hosts and Inventory</li>
<li>Targeting Infrastructure</li>
<li>Ansible Modules</li>
</ul>
<p>As we progress through this chapter, we will try to gain a clear understanding of how Ansible playbooks are created and how to create automation that is fault tolerant, robust, and easy to maintain.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible Playbook Constructs</h1>
                
            
            
                
<p>The Ansible playbook is at the heart of the Ansible Configuration Management and Automation System. Each playbook is made up of one or more plays. The concept of a playbook was derived from sporting references, where a coach would create a set of plays off the field and execute them during a game. The creators of Ansible leveraged this idea to create and successfully deliver an easy-to-use automation and Configuration Management solution. Playbook's are developed using YAML (more about this in the next section), and optionally Jinja2 for more comprehensive automation implementations.</p>
<p>Ansible playbook comprise a few specific structural and formatting elements, namely the following:</p>
<ul>
<li>YAML syntax (the language Ansible leverages for automation)</li>
<li>Jinja2 (optional)</li>
<li>The hosts section (which defines the host groups to target during execution)</li>
<li>One or many configuration overrides (this section allows playbook developers to override configuration options or set specific playbook flags)</li>
<li>The vars section (optional)</li>
<li>Plays with tasks inside them</li>
</ul>
<p>In addition to these elements, YAML (and by nature Ansible) supports commenting within the YAML file. Comments are simply notation documentation that has no programmatic meaning but is useful for developers and playbook authors to keep notes within the playbook directly. Comments in YAML are initiated with the <kbd>#</kbd> operator, and everything on that line after the <kbd>#</kbd> is ignored by YAML and Ansible.</p>
<p>Let's spend a few minutes looking at the hosts, vars, and play sections of an Ansible playbook and learn how we can leverage them to create effective and maintainable automation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The programming languages that make up a playbook</h1>
                
            
            
                
<p>In the Ansible world, playbook's are developed using YAML and Jinja. <strong>YAML</strong> stands for <strong>YAML Ain't Another Markup Language</strong>, and Jinja2 is its own independent name. Of the two, YAML is the primary language whereas Jinja is supplementary.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">YAML</h1>
                
            
            
                
<p>As mentioned earlier, YAML™ is the primary language used to create playbooks. But what exactly is YAML? Here is what <a href="http://yaml.org/">http://yaml.org/</a> has to say on the subject:</p>
<p>"YAML (rhymes with "camel") is a human-friendly, cross language, Unicode based data serialization language designed around the common native data types of agile programming languages. It is broadly useful for programming needs ranging from configuration files to internet messaging to object persistence to data auditing. Together with the Unicode standard for characters (<a href="http://unicode.org/">http://unicode.org/</a>), this specification provides all the information necessary to understand YAML version 1.2 and to create programs that process YAML information."</p>
<p>As described in the excerpt, YAML is designed to be human-friendly. This means that while it can contain data and basic logic (typically provided by Jinja2), it emphasizes the concept of readability and convention over complexity and features. Additional information on YAML can be found at <a href="http://www.yaml.org">http://www.yaml.org</a>.</p>
<p>YAML uses tab-indented formatting and key/value pair dictionaries to express the data that is inside a given YAML file. This makes it parseable for Ansible and makes it easy to read at the same time. YAML's unique yet simplistic structure provides Ansible playbook developers with a guess-free way of developing playbooks and ensuring that they will be executable through Ansible. While YAML's structure is easy to read, sometimes it's tabbing can trip some users up. Let's take a look at a couple of simple examples of YAML files and see what the basic data structure looks like:</p>
<pre>
# Simple YAML Data Structure<br/>---<br/>planets:<br/>  - earth: 'welcome to earth'<br/>    species: humans<br/><br/>  - mars: 'we come from mars'<br/>    species: martians
</pre>
<p>From the previous example, we can easily see the content is simply a list of planets, species, and greetings. Are we saying that all YAML really is is an easy-to-read way of managing lists? In a way, yes. Let's explore this idea further.</p>
<p>Basic data in YAML is structured into key/value pairs; the information is organized by indentation. For programmers, this is nothing surprising, but for a novice this may sound confusing. A basic key/value-paired data structure is similar to a list of items. In a key/value data structure, there are two intrinsically linked data items. A <strong>key</strong> is essentially a pointer, which references the value. The <strong>value</strong> can be raw data (a simple bit of text) or even another set of key/value pairs. This makes managing lists of key/value pairs very easy. The indentation in YAML syntax makes organizing the data it represents easy to read. It ensures that nothing is garbled or badly formatted and the information is easily identifiable and legible.</p>
<p>As we can see from the previous YAML example, YAML is a well-formatted (tab-enforced) language. Tabs in YAML are a bit of a misnomer, as you can't actually use the Tab key. Use spaces instead. Tabs are forbidden in YAML because different text editors provide different implementations of tabbing and the implementations are not consistent.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Jinja2 – a brief introduction</h1>
                
            
            
                
<p>Jinja on the other hand is a bit more feature rich than YAML. It has been integrated into Ansible's runtime engine and provides a bit of the more scripting language-like features that developers are used to. Its syntax fits nicely into YAML (as described previously) and allows the developer to use things such as conditionals, loops, variable substitution, and environment variable retrieval. Further information related to jinja2 and its syntax can be found at <a href="http://jinja.pocoo.org/docs/2.9/">http://jinja.pocoo.org/docs/2.9/</a>. Let's take a quick look at some basic Jinja syntax:</p>
<pre>
# Simple Jinja syntax<br/>{{my_var}}
</pre>
<p>This code doesn't look very useful at first, but once we put it in context, it becomes much more valuable. Let's take a peek at how Jinja fits in with YAML:</p>
<pre>
# Example Jinja Playbook<br/>- hosts: all<br/>  vars:<br/>    foo: "{{ lookup('env', 'FOO' }}"<br/>  tasks:<br/>    - name: Copy file<br/>      copy: src="img/{{ foo }}" dest=/some/path mode=0775 owner=user group=user
</pre>
<p>This simple example of an Ansible playbook with YAML and Jinja combined provides a way for us to use the contents of a system environment variable within our playbook. We will go into this type of implementation in much more detail later within this book, but for now, we at least can see one structured example of how Jinja can be leveraged within a YAML file.</p>
<p>Jinja offers many more solutions and manipulations of an Ansible playbook, which we will discuss in <a href="af2931a0-b22f-4501-8d98-fb54e3d081f9.xhtml" target="_blank">Chapter 6</a>, <em>Jinja in Ansible</em>. This introduction is simply to provide you with an understanding of how YAML and Jinja can coexist.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Constructing an Ansible playbook</h1>
                
            
            
                
<p>YAML's unique and well-formatted syntax provides a highly structured yet human-readable format for expressing data. More specifically, YAML's data structure is expressed in lists, with each list item containing key/value pairs (or dictionaries). At the beginning of each YAML file, YAML optionally supports a <kbd>---</kbd> initiator (to notate the beginning of the YAML file), and conversely, at the end of each, YAML supports a <kbd>...</kbd> terminator, which (as you may have guessed) indicates the end of a YAML file. Let's take a look at a very simple playbook as an example:</p>
<pre>
---<br/>- hosts: all<br/>  vars :<br/>    http_port : 80<br/>    tasks:<br/>    - name: Install nginx web server<br/>      apt: pkg=nginx state=installed update_cache=true<br/>      notify:<br/>        - start nginx
</pre>
<p>Now that we have seen an example of an Ansible playbook, let's look at the possible available sections within a playbook, and see what each does.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hosts</h1>
                
            
            
                
<p>The hosts section is where we can target groups of inventory. The inventory in Ansible represents one or many devices that Ansible can connect to and run automation against.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Variables (vars/vars_files)</h1>
                
            
            
                
<p>The <kbd>vars</kbd> and <kbd>vars_file</kbd> sections of an Ansible playbook contain a set of variable data that can be used later in the playbook. This information is known as <strong>facts</strong>. The variable concept in Ansible is identical in nature to computer programming variables but with different scopes, depending on where it's defined.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tasks/plays</h1>
                
            
            
                
<p>The aim of Ansible plays is to connect one or more groups of hosts to a set of roles, represented by things, which Ansible calls tasks. At its most basic definition, an Ansible task is nothing more than a callout to an Ansible module.</p>
<p>Great; we now have a basic understanding of the sections that make up a playbook, but we really don't know how to effectively use them to create a playbook or how to target a specific set of servers or infrastructure.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible Play's and Task's</h1>
                
            
            
                
<p>As we have already discovered, within the heart of the Ansible configuration and Automation System is the the playbook. The most important element of the playbook is the idea of plays and tasks. Plays represent a categorization of a collection of Ansible tasks, whereas tasks are individual automation steps that make up the play.</p>
<p>Consider plays as the overarching grouping and tasks as the items that reside within a given play. For example, you may have a database play, a web server play, or even a load balancer play. In this section, we will discover how plays and tasks work in the Ansible world.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible plays</h1>
                
            
            
                
<p>Ansible plays are named after sports plays. In YAML, plays are represented via one or more tasks sections within a playbook. The plays section (or sections) of an Ansible playbook represents the heart of the Ansible automation engine. In Ansible, each task has a name (a user-friendly description of the action to be executed) and a set of parameters that define how the system should execute, report on, or handle the aftermath of the execution. Let's take a look at a couple of ways in which we can implement Ansible plays within a given playbook.</p>
<p>The example provided next provides us with a glimpse into an Ansible playbook with a single play:</p>
<pre>
tasks:<br/>    - name: Can we use Ansible to Install Apache2 web server<br/>      apt: pkg=apache2 state=installed update_cache=true
</pre>
<p>Looks pretty basic, right? Plays can have one or more tasks underneath them. They are pretty easy to read and very easy to write. However, a playbook does not need to be isolated into a single play. For example, we could just as easily do something like the following:</p>
<pre>
tasks:<br/>    - name: Use Ansible to Install nginx web server<br/>      apt: pkg=nginx state=installed update_cache=true<br/><br/>tasks:<br/>    - name: Use Ansible to Install MySQL web server<br/>      apt: pkg=mysql-server state=installed update_cache=true
</pre>
<p>This second example is also human-readable but has two specific plays defined within. The first play handles the installation of nginx, whereas the second play handles the installation of the MySQL server. By using multiple plays in a single playbook, we can group automation into a single playbook yet segregate the actual tasks. Neat, huh? Now that we have a good understanding of what an Ansible play is, let's take a look at Ansible tasks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible tasks</h1>
                
            
            
                
<p>In the previous section, we talked primarily about Ansible plays. Underneath a given play is a set of Ansible tasks. Ansible tasks can perform numerous actions on a local or target system. This includes installing packages (such as <kbd>apt</kbd>, <kbd>yum</kbd>, and <kbd>opencsw</kbd>), copying files, starting services, and much, much more. Ansible tasks make up the glue that binds automation and human-readable actions. Let's take a look at the elements of the Ansible tasks section and see how to write them:</p>
<pre>
tasks:<br/>  - name: &lt;some description&gt;     <br/>   &lt;API&gt;: PARAM1=foo PARAM2=foo PARAM3=foo
</pre>
<p>This snippet is pretty simplistic; there is a single play (notated by tasks:) and a single task underneath the play. Within the task itself, the name parameter has (in plain English) a description of what we are trying to accomplish when this task is executed. The <kbd>&lt;API&gt;</kbd> tag on the next line (below the <kbd>name</kbd> definition) will simply be the Ansible module we are invoking. After the module <kbd>name</kbd>, there is a set of parameters that are passed to the module that specify more granularly the details about the module we are invoking. So to have a better real-world example, let's take a look at the following code excerpt:</p>
<pre>
tasks:<br/>  - name: Can we use Ansible to Install nginx web server<br/>    apt: pkg=nginx state=installed update_cache=true
</pre>
<p>The aforementioned play simply tells Ansible to install the nginx web server on an Ubuntu-based system. We know this because the module the task is calling is <kbd>apt</kbd> and the parameters instruct Ansible to ensure the package (<kbd>pkg</kbd>) <kbd>nginx</kbd> is in the state installed. Additionally, prior to installing the package, we have also instructed the <kbd>apt</kbd> module to update its local cache. Simple, right?</p>
<p>One of the nicest things about Ansible is its ability to skip over tasks that will not effect change on a given system. For example, if the package <kbd>nginx</kbd> is already installed, Ansible will skip the step entirely as it is smart enough to know that the <kbd>nginx</kbd> package already exists on the system.</p>
<p>So now that we know the basic structures of an Ansible playbook, we will want to know how to extend our playbooks to handle more complex parameters within our tasks. The next step in this learning process is understanding multiline parameters. Let's proceed.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multiline task parameters</h1>
                
            
            
                
<p>Some Ansible tasks can have a bunch of parameters (so much so that the simplicity and readability of the task become ambiguous). The YAML implementation has also matured in such a way as to support parameters across multiple lines for better readability. This is specifically a <em>scalar folded approach</em> that is available within the YAML language directly. Let's take a look at an example provided by the YAML creators to understand how line folding works in YAML:</p>
<pre>
# Multiple-line strings can be written either as a 'literal block' (using |),
# or a 'folded block' (using '&gt;').
literal_block: |
    This entire block of text will be the value of the 'literal_block' key,
    with line breaks being preserved.

    The literal continues until de-dented, and the leading indentation is
    stripped.

        Any lines that are 'more-indented' keep the rest of their indentation -
        these lines will be indented by 4 spaces.
folded_style: &gt;
    This entire block of text will be the value of 'folded_style', but this
    time, all newlines will be replaced with a single space.

    Blank lines, like above, are converted to a newline character.

        'More-indented' lines keep their newlines, too -
        this text will appear over two lines.
</pre>
<p>So in the context of Ansible playbook's we can use the scalar folded approach to perform multiline playbook tasks. As a result, we can reformat a task as follows:</p>
<pre>
# Initial task definition <br/>tasks:<br/>    - name: Can we use Ansible to Install nginx web server<br/>      apt: pkg=nginx state=installed update_cache=true<br/><br/># Same task using the scalar folded approach to task definitions<br/>tasks:     <br/>    - name: Can we use Ansible to Install nginx web server       <br/>      apt: &gt;<br/>        pkg=nginx <br/>        state=installed <br/>        update_cache=true
</pre>
<p>Multiline implementations of Ansible tasks are based on preference and formatting. So in some cases you may have a playbook task that is really long and in that case you would want to consider using a multiline task. On the converse, shorter playbook tasks would probably not need such an implementation. Again its simply a matter of readability and preference.</p>
<p>Now that we have a good idea of how to better organize our playbook data structures, let's look at variables and how those fit into our playbook creation process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Variables and Variable Files</h1>
                
            
            
                
<p>Variables are a critical part of any scripting or development language, and Ansible is no different. Variables act as named placeholders for data elements, important information, numerical values, and more. Ansible provides a <kbd>vars</kbd> section and a <kbd>vars_files</kbd> section, which are optionally included in a playbook. Variables defined here are playbook-centric and can be used within the playbook. These sections of the playbook allow us to define variables in two unique ways. Let's look at an example to better understand how variables are defined:</p>
<pre>
---<br/>- hosts: all<br/>  vars:<br/>    myvar: helloworld<br/>  vars_files:<br/>    - /vars/my_vars.yml
</pre>
<p>As we can see from the example, we can be rather creative when defining variables that Ansible can use in its playbook. Variables can be specified via the <kbd>vars</kbd> section, the <kbd>vars_files</kbd> section, or even via the command line through the <kbd>ExtraVars</kbd> parameter. Let's take a look at the key/value implementation of variables as well as a <kbd>vars_file</kbd> implementation and discover how these can be leveraged to provide reusable data to our Ansible playbooks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic variable syntax</h1>
                
            
            
                
<p>The most obvious solution for managing variables within Ansible is to leverage the key/value vars section in the beginning of an Ansible playbook, which allows us to define a set of simple key/value datasets that we can make available to the remaining tasks in our playbook.</p>
<p>The <kbd>vars</kbd> section in an Ansible playbook provides us with an easy location from where we can create a list of globally available Ansible variables. Ansible reads this <kbd>vars</kbd> section and its associated key/value based variables during the initialization of a playbook (specifically, during the facts-gathering phase). Each data item retrieved during this phase is known as a <strong>fact</strong>. The variables can then be used elsewhere in the playbook.</p>
<p>Let's look at a few examples of key/value variable sets in Ansible and how to use them in a playbook:</p>
<pre>
Example: Simple Key/Value Variables in Ansible. <br/>---<br/>- hosts: all<br/>  vars:<br/>    # Single Variable(s) Example<br/>    myvar: helloworld<br/><br/>  tasks:<br/>    - name: $myvar<br/>      ping:
</pre>
<p>The example shows how to create and use a simple <kbd>$myvar</kbd> variable and use it in a playbook play. Next, let's look at a slightly different implementation of Ansible variables (at the task level). Consider the following playbook fragment:</p>
<pre>
# Task specific variables<br/>tasks:<br/>  - name: copy files<br/>    copy: src={{ item }} dest=/opt/{{ item }}<br/>    with_items:<br/>      - foo<br/>      - bar
</pre>
<p>In the example, we have illustrated a simple iterative loop of sorts to copy the files <kbd>foo</kbd> and <kbd>bar</kbd> into the specified destination. Now that we have a good idea of basic Ansible variables, let's take a look at some more scalable ways to manage Ansible variable data.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Variable files</h1>
                
            
            
                
<p>As we just discussed, Ansible has the <kbd>vars</kbd> section within a playbook. This is perfectly sufficient for a limited number of data points. However, if the amount of information is expected to grow or pertain to various environments, the <kbd>vars</kbd> section can get highly unwieldy if not managed carefully. Instead of using the vars section for managing data, we can use a <kbd>vars</kbd> file (or many <kbd>vars</kbd> files). A <kbd>vars</kbd> file represents a way to encapsulate a set of data points into an external file on the Ansible control server's disk. We then specify the <kbd>vars</kbd> file in our Ansible playbook, and Ansible will load it at the appropriate time.</p>
<p>When using a <kbd>vars</kbd> file, it's important to note that we can include the <kbd>vars</kbd> file in our playbook in a couple of possible locations: a <kbd>vars_file</kbd> section or within an Ansible task (task-specific scoped). The examples provided next will help better illustrate this.</p>
<p>Let's look at an example of the <kbd>vars</kbd> files in action. The following example shows the contents of a simple <kbd>vars</kbd> file:</p>
<pre>
east_coast_host_local: virginia<br/>west_coast_host_local: oregon<br/>definitions:<br/>- servers: web<br/>   instance: apache<br/>- servers: db<br/>   instance: cassandra<br/>ping_server: 192.168.10.10
</pre>
<p>As we can see from the content of the <kbd>vars</kbd> file, it's nothing more than a YAML file. Who would have guessed? The neat thing here really isn't its content but rather the construction. But before we move on to any really neat things, let's take a look at how to reference the file and data within via a playbook. The corresponding playbook for the previous <kbd>vars</kbd> file is as follows:</p>
<pre>
# Example: Simple Variables File in Ansible. <br/>---<br/>- hosts: all<br/>  vars_files:<br/>    - my_vars_file.yml<br/><br/>  tasks:<br/>    - name: ping target server<br/>      ping: $ping_server
</pre>
<p>So based on the content of this playbook, we can see that it simply has an added <kbd>vars_file</kbd> section, which is loaded during startup.</p>
<p>These two file examples are very simple in nature. Let's look at another way of loading a variables file based on the context of the aforementioned examples. Here is an alternate playbook:</p>
<pre>
# Example: Simple Variables File in Ansible. <br/>---<br/>- hosts: all<br/>  tasks:<br/>    - name: include default step variables<br/>      include_vars: my_vars_file.yml<br/>      ping: $ping_server
</pre>
<p>So we can see based on this code provided that we can scope a <kbd>vars</kbd> file to a specific task as well. This can be very handy for altering certain data points in a task based on specific criteria (per environment or per host).</p>
<p>Now that we have a good idea of how <kbd>vars</kbd> files work, let's take a look at one more example of how a <kbd>vars</kbd> file might be leveraged:</p>
<pre>
# Example: Simple Variables File in Ansible. <br/>---<br/>- hosts: all<br/>  vars_files:<br/>    - my_vars_file.yml<br/>    - "/opt/varsfiles/{{ env_vars }}.yml"<br/>  <br/>  tasks:<br/>    - name: ping target server<br/>      ping: $ping_server
</pre>
<p>Can you guess what this will do yet? Let's take a look at how we might execute this playbook from the command line for a hint:</p>
<pre>
<strong>$&gt; ansible-playbook site.yml -e "env_vars=dev" -c local</strong>
</pre>
<p>Okay so let's understand how this works. Basically, the command specifies a variable of <kbd>env_vars=dev</kbd>, and this makes the playbook then load a <kbd>vars</kbd> file it thinks should be located at <kbd>/opt/varsfiles/dev.yml</kbd>. So we can set specific variable data for different environments (dev, QA, and so on) and reuse our playbooks. Nice, right?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Hosts and Inventory</h1>
                
            
            
                
<p>Ansible offers an inventory system that helps administrators manage the devices they intend to target via Ansible playbook execution or ad hoc command execution. The inventory system allows the administrator to identify inventory items (devices) and group them according to their needs. These inventory items are maintained via Ansible inventory files, which can then be targeted directly via the command line.</p>
<p>Out-of-the-box, Ansible offers a default inventory file, which is typically located in the <kbd>/etc/ansible/hosts</kbd> file location. If one inventory file is not enough to effectively manage your inventory, additional inventory files can be created and stored either in the same location or in a location of your choosing. When calling the <kbd>ansible-playbook</kbd> command to invoke Ansible and execute either an ad hoc command or trigger a <kbd>playbook run</kbd>, Ansible has the <kbd>-i</kbd> option to allow alternate inventory files to be specified directly on the command line. The following is a set of examples that illustrate targeting inventory files from the command line:</p>
<pre>
# This example uses the default hosts file provided by Ansible<br/># and executes playbook.yml<br/><strong>$&gt; ansible-playbook -i hosts playbook.yml</strong><br/><br/># This example specifies an alternative hosts file<br/># and executes playbook.yml<br/><strong>$&gt; ansible-playbook -i /opt/mynewinventoryfile playbook.yml</strong><br/><br/># This example specifies a set of hosts directly on the<br/># command line and executes playbook.yml<br/><strong>$&gt; ansible-playbook -i fqdn.example.com,playbook.yml</strong>
</pre>
<p>Now that we have a good idea of how to specify alternate inventory files via the command line, let's take a look at some ways in which we can leverage an Ansible inventory file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Targeting Infrastructure</h1>
                
            
            
                
<p>When creating automation that is aimed at targeting one or multiple devices, we need a way to instruct Ansible which hosts to target and which playbooks should target which hosts. In order for Ansible to maintain an orderly congregation of hostnames, IP addresses, and domain names, the creators of Ansible have provided an Ansible inventory hosts file and the ability to group and target groups of hosts via Ansible playbooks. Ansible host are generally defined within the Ansible inventory <kbd>hosts</kbd> file, which is traditionally located at the following file location on the Ansible control server:</p>
<pre>
/etc/ansible/hosts
</pre>
<p>As we mentioned in the previous chapter, the Ansible <kbd>hosts</kbd> file allows the Ansible developer to maintain a list or set of groups of devices that Ansible can target via playbooks. The way we instruct Ansible to target specific groups of hosts is through the <kbd>hosts</kbd> line entry within a given Ansible playbook. Let's consider the following hosts groups and Ansible playbook examples:</p>
<p>Ansible hosts file example (<strong><kbd>/etc/ansible/hosts</kbd></strong>):</p>
<pre>
# Example Ansible hosts file with two defined groups<br/><br/>[WEB]<br/>192.168.10.10<br/>[DATABASE]<br/>192.168.10.11
</pre>
<p>Targeting the <kbd>WEB</kbd> hosts group via an Ansible playbook (<kbd>playbook.yml</kbd>):</p>
<pre>
# Example Ansible Playbook, which targets the 'WEB' group<br/>---<br/>- hosts: WEB<br/>  vars :<br/>    http_port : 80<br/>  tasks:<br/>    - name: Install nginx web server<br/>      apt: pkg=nginx state=installed update_cache=true<br/>      notify:<br/>        - start nginx
</pre>
<p>To execute the previous example, simply change into the directory that contains the <kbd>playbook.yml</kbd> file and execute the following command:</p>
<pre>
# Run Ansible and instruct it to execute the contents of<br/># playbook.yml against the inventory file of hosts<br/># (the default Ansible inventory)<br/><strong>$&gt; ansible-playbook playbook.yml -i hosts</strong>
</pre>
<p>It is important to understand that Ansible doesn't necessarily need to target an inventory group via the hosts line entry in a playbook. It can also target multiple groups, single hosts, wild cards, and more. Let's take a look at some examples of other ways in which we can input the data within the <kbd>hosts</kbd> section:</p>
<pre>
# Example hosts line values:<br/><strong><br/>hosts: all</strong> -- Applies the current playbook to all hosts in the specified inventory file<br/>  <strong>hosts: hostname</strong> -- Applies the playbook ONLY to the specified host 'hostname'<br/>  <strong>hosts: groupname</strong> -- Applies the playbook to all hosts in specified groupname<br/>  <strong>hosts: groupA,groupB</strong> -- Applies the playbook to hosts in groupB and groupB<br/>  <strong>hosts: group1,host1</strong> -- A combination of single hosts and groups<br/>  <strong>hosts: *.google.com</strong> -- Applies the playbook to wildcard matches
</pre>
<p>In addition to these examples of loose host line values, the <kbd>hosts</kbd> section can also contain groupings such as these:</p>
<pre>
[WEB]<br/>192.168.10.10<br/>[PRODUCTION]<br/>192.168.10.11
</pre>
<p>In addition to these examples, the <kbd>hosts</kbd> section can also leverage Ansible variables to target specific hosts. An example of this type of implementation is provided next:</p>
<pre>
hosts: $myhosts -- apply the playbook to all hosts specified in the variable $myhosts
</pre>
<p>Once the playbook reflects the <kbd>$myhosts</kbd> variable, we can set that variable with something like the example provided next:</p>
<pre>
<strong>$&gt; ansible-playbook playbook.yml --extra-vars="groups=PRODUCTION"</strong>
</pre>
<p>Based on this command, we can see that the we are able to target the production group (defined in the previous <kbd>hosts</kbd> file).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Ansible Modules</h1>
                
            
            
                
<p>Ansible provides a very robust set of tools that can aid immensely in operational implementations. Common operational implementations include managing the configuration of a given system (ensuring that packages are installed, files are present, directory structures exist, and so on), provisioning a given system to meet a set of prerequisites, and more. As we discovered earlier, playbooks and their tasks help us achieve these goals by executing a set of automations against a given system.</p>
<p>While the knowledge we have gained can give us the basics we need to implement simple automations, we have really just barely scratched the surface of how Ansible works. Ansible integrates with hundreds of system-level tasks and thousands of external third-party solutions and can be leveraged in ways we haven't even begun to fathom. Let's peel back the layers a bit and see how we can leverage Ansible for basic Configuration Management.</p>
<p>Ansible provides the bulk of its task functionality through Ansible modules. Ansible modules are essentially standalone interfaces that integrate Ansible with an OS or another technology. For example, Ansible has a module that integrates Ansible playbook automation with JIRA. So the JIRA module provides a direct link between the functionality available via the JIRA API and the automation formatting that makes up an Ansible playbook task.</p>
<p>The Ansible implementation has three different module types. These module types are Core, Curated, Community, and Custom. Each of these modules have their own specific function and role within the Ansible solution. Let's take a minute to look at what the Ansible documentation has to say about these different module types:</p>
<ul>
<li><strong>Core</strong>: These are modules that the core Ansible team maintains and will always ship with ansible itself. They will also receive slightly higher priority for all requests. Non-core modules are still fully usable.</li>
<li class="mce-root"><strong>Curated</strong>: Some examples of curated modules are submitted by other companies or maintained by the community. Maintainers of these types of modules must watch for any issues reported or pull requests raised against the module.</li>
</ul>
<p>Core committers will review all modules becoming curated. Core committers will review proposed changes to existing curated modules once the community maintainers of the module have approved the changes. Core committers will also ensure that any issues that arise due to Ansible engine changes will be remediated. Also, it is strongly recommended (but not presently required) for these types of modules to have unit tests.<br/>
These modules are currently shipped with Ansible, but might be shipped separately in the future.</p>
<ul>
<li class="mce-root"><strong>Community</strong>: These modules are not supported by core committers or by companies/partners associated to the module. They are maintained by the community.</li>
</ul>
<p>They are still fully usable, but the response rate to issues is purely up to the community. Best effort support will be provided but is not covered under any support contracts.<br/>
These modules are currently shipped with Ansible, but will most likely be shipped separately in the future.</p>
<p>In this section we are going to look at the core module solution and try to understand how it functions and the capabilities that it provides.</p>
<p>At the time of writing, there are 1,021 unique Ansible modules available and provided by Ansible's out-of-the-box solution. This means that Ansible has the potential to integrate very tightly with any number of operating systems, tools, and open source software. To better illustrate this, let's take a quick look at just the categories of the Ansible modules provided at the official documentation (<a href="http://docs.ansible.com/ansible/modules_by_category.html">http://docs.ansible.com/ansible/modules_by_category.html</a>):</p>
<ul>
<li>Cloud modules</li>
<li>Clustering modules</li>
<li>Commands modules</li>
<li>Crypto modules</li>
<li>Database modules</li>
<li>Files modules</li>
<li>Identity modules</li>
<li>Inventory modules</li>
<li>Messaging modules</li>
<li>Monitoring modules</li>
<li>Network modules</li>
<li>Notification modules</li>
<li>Packaging modules</li>
<li>Remote management modules</li>
<li>Source control modules</li>
<li>Storage modules</li>
<li>System modules</li>
<li>Utilities modules</li>
<li>Web infrastructure modules</li>
<li>Windows modules</li>
</ul>
<p>As we can see from the list, Ansible's integration is highly robust. Let's explore some of the more common modules and see how we can use them within our playbook tasks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing packages in Ansible</h1>
                
            
            
                
<p>Ansible integrates very tightly with a number of Linux flavors. This integration enables Ansible playbooks to maintain packages on target systems in a succinct and structured manner. From <kbd>yum</kbd> to <kbd>apt</kbd> and <kbd>opencws</kbd>, the package-management solution provided by the Ansible developers is robust and feature-rich. In this section, we will understand the fundamentals of package management through Ansible playbooks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Yum</h1>
                
            
            
                
<p>Ansible provides a complete yum module, which effectively integrates it with common RHEL implementations of the yum repository system. Through Ansible's yum interface, it is possible to perform almost all yum-related operations. Some examples of Ansibe's yum capabilities include:</p>
<ul>
<li>Installing packages</li>
<li>Removing packages</li>
<li>Adding repositories</li>
<li>Managing GPG checks</li>
<li>Listing packages</li>
</ul>
<p>Now that we have a good idea of Ansible's yum ninja skills, let's take a look at some basic examples of how to perform operations with yum:</p>
<pre>
- name: install the latest version of Apache<br/>  yum:<br/>    name: httpd<br/>    state: latest<br/>- name: remove the Apache package<br/>  yum:<br/>    name: httpd<br/>    state: absent<br/>- name: install the latest version of Apache from the testing repo<br/>  yum:<br/>    name: httpd<br/>    enablerepo: testing<br/>    state: present<br/>- name: install one specific version of Apache<br/>  yum:<br/>    name: httpd-2.2.29-1.4.amzn1<br/>    state: present<br/>- name: upgrade all packages<br/>  yum:<br/>    name: '*'<br/>    state: latest<br/>- name: install the nginx rpm from a remote repo<br/>  yum:<br/>    name: http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm<br/>    state: present<br/>- name: install nginx rpm from a local file<br/>  yum:<br/>    name: /usr/local/src/nginx-release-centos-6-0.el6.ngx.noarch.rpm<br/>    state: present<br/>- name: install the 'Development tools' package group<br/>  yum:<br/>    name: "@Development tools"<br/>    state: present- name: install the 'Gnome desktop' environment group<br/>  yum:<br/>    name: "@^gnome-desktop-environment"<br/>    state: present<br/>- name: List Ansible packages and register result to print with debug later.<br/>  yum:<br/>    list: ansible<br/>  register: result
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">The apt-get and dpkg</h1>
                
            
            
                
<div><p>Ansible's integration with <kbd>apt-get</kbd> is equally as tight as Ansible's integration with yum. The <kbd>apt-get</kbd> package, for those who are not familiar with it, is a package-management solution leveraged by Debian-based operating systems. The implementation of <kbd>apt-get</kbd> actuality sits on top of another solution called <kbd>dpkg</kbd>, and Ansible provides modules that support both. In this specific section, we will discuss apt-get specifically. In order to better understand the architecture that we are referencing, an illustration is provided next:</p>
<img height="181" width="420" class="image-border" src="img/be077343-54d0-4b60-827d-6f344a4b7ca3.png"/></div>
<p class="CDPAlignLeft CDPAlign">Now that we have a good understanding of how <kbd>apt-get</kbd> works, let's take a look at some examples of how Ansible integrates with this specific package manager:</p>
<pre>
- name: Update repositories cache and install "foo" package<br/>  apt:<br/>    name: foo<br/>    update_cache: yes<br/><br/>- name: Remove "foo" package<br/>  apt:<br/>    name: foo<br/>    state: absent<br/><br/>- name: Install the package "foo"<br/>  apt:<br/>    name: foo<br/>    state: present<br/><br/>- name: Install the version '1.00' of package "foo"<br/>  apt:<br/>    name: foo=1.00<br/>    state: present<br/><br/>- name: Update the repository cache and update package "nginx" to latest version using default release squeeze-backport<br/>  apt:<br/>    name: nginx<br/>    state: latest<br/>    default_release: squeeze-backports<br/>    update_cache: yes<br/><br/>- name: Install latest version of "openjdk-6-jdk" ignoring "install-recommends"<br/>  apt:<br/>    name: openjdk-6-jdk<br/>    state: latest<br/>    install_recommends: no<br/><br/>- name: Update all packages to the latest version<br/>  apt:<br/>    upgrade: dist<br/><br/>- name: Run the equivalent of "apt-get update" as a separate step<br/>  apt:<br/>    update_cache: yes<br/><br/>- name: Only run "update_cache=yes" if the last one is more than 3600 seconds ago<br/>  apt:<br/>    update_cache: yes<br/>    cache_valid_time: 3600<br/><br/>- name: Pass options to dpkg on run<br/>  apt:<br/>    upgrade: dist<br/>    update_cache: yes<br/>    dpkg_options: 'force-confold,force-confdef'<br/><br/>- name: Install a .deb package<br/>  apt:<br/>    deb: /tmp/mypackage.deb<br/><br/>- name: Install the build dependencies for package "foo"<br/>  apt:<br/>    pkg: foo<br/>    state: build-dep<br/><br/>- name: Install a .deb package from the internet.<br/>  apt:<br/>    deb: https://example.com/python-ppq_0.1-1_all.deb
</pre>
<div><p>In addition to <kbd>yum</kbd> and <kbd>apt</kbd> integration, Ansible actually integrates very well with a number of additional package-management solutions for other Linux distributions. Each of these (like the previous two) is supported through an Ansible module. The modules for these other flavors of Linux are crafted in such a way so as to provide as robust an integration as possible. For a complete module list of supported package-management solutions, the following link should provide a comprehensive guide:</p>
<p><a href="http://docs.ansible.com/ansible/list_of_packaging_modules.html">http://docs.ansible.com/ansible/list_of_packaging_modules.html</a>.<a href="http://docs.ansible.com/ansible/list_of_packaging_modules.html"/></p>
<a href="http://docs.ansible.com/ansible/list_of_packaging_modules.html"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing users in Ansible</h1>
                
            
            
                
<p class="mce-root">Managing users within an Ansible playbook need not be a daunting task. Ansible's <kbd>user</kbd> module set provides tight integration with the Ansible core and the system-level users solution. The Ansible user module provides us with the ability to manage users and user attributes via YAML. As a result, operations such as add, remove, and update are usually quite easy to implement. Let's take a look at how to perform some basic user operations using Ansible in conjunction with the users module:</p>
<pre>
<strong># Create a User 'dortiz' <br/></strong>---<br/>- hosts: all<br/><br/>  tasks:<br/>    - name: Add David Ortiz User to the System<br/>      user: <br/>        name: dortiz<br/>        comment: "David Ortiz has entered the building"<br/><br/><strong># Create a User 'jdaemon' and add to group baseballplayers<br/></strong>---<br/>- hosts: all<br/><br/>  tasks:  <br/>    - name: Add Johnny Daemon User to the System<br/>      user: <br/>        name: jdaemon<br/>        comment: "Johnny Daemon has entered the building"<br/>        groups: baseballplayers
</pre>
<p>For a complete list of parameters that can be passed through the Ansible users module, refer to the official documentation on the users module located at <a href="http://docs.ansible.com/ansible/user_module.html">http://docs.ansible.com/ansible/user_module.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">File and directory management in Ansible</h1>
                
            
            
                
<p>Ansible's file module provides integration between Ansible playbooks and the filesystem itself. This enables us to perform directory operations and basic file operations via an Ansible playbook task. In addition to basic <strong>create</strong>, <strong>remove</strong>, <strong>update</strong>, and <strong>delete</strong> (<strong>CRUD</strong>) operations, we can also set permissions, change owners, set group owners, operate on recursive folder trees, and more.</p>
<p>Let's take a look at some examples of basic file and directory management operations using the <kbd>file</kbd> module:</p>
<pre>
# Create a directory using an Ansible Task<br/><br/>- name: Creates a directory<br/>  file: path=/opt/helloWorld state=directory<br/><br/># Create a directory using an Ansible Task,<br/># which is owned by the baseballplayersgroup<br/><br/>- name: Creates a directory<br/>  file: path=/opt/helloWorld state=directory<br/><br/># Creates a directory owned by the baseballplayers group<br/># with CHMO 0775 permissions<br/>- name: Creates directory<br/>  file: path=/opt/helloWorld state=directory owner=baseballplayers group=baseballplayers mode=0775<br/><br/># Changes the ownership of myconfiguration.conf to <br/># bob and changes permissions to 0644<br/>- name:<br/>    file:<br/>      path: /opt/myconfiguration.conf<br/>      owner: bob<br/>      group: admin<br/>      mode: 0644
</pre>
<p>These examples provide just a glimpse into file management and Ansible's file module. For a complete list of available options, consult the Ansible documentation located at <a href="http://docs.ansible.com/ansible/file_module.html">http://docs.ansible.com/ansible/file_module.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Managing services in Ansible</h1>
                
            
            
                
<p>Managing services using Ansible is a breeze. Service management can be a complex operation and is usually highly dependent on the OS and system type. However, with Ansible's service module, we can easily stop, start, and restart services. This integration provides a high level of reliability and abstracts the fundamental OS-level operations that must be performed. Let's take a look at the Ansible <kbd>service</kbd> module and see its capabilities:</p>
<pre>
# Example action to start service httpd, if not running<br/>- service:<br/>    name: httpd<br/>    state: started<br/><br/># Example action to stop service httpd, if running<br/>- service:<br/>    name: httpd<br/>    state: stopped<br/><br/># Example action to restart service httpd, in all cases<br/>- service:<br/>    name: httpd<br/>    state: restarted<br/><br/># Example action to reload service httpd, in all cases<br/>- service:<br/>    name: httpd<br/>    state: reloaded<br/><br/># Example action to enable service httpd, and not touch the running state<br/>- service:<br/>    name: httpd<br/>    enabled: yes<br/><br/># Example action to start service foo, based on running process /usr/bin/foo<br/>- service:<br/>    name: foo<br/>    pattern: /usr/bin/foo<br/>    state: started<br/><br/># Example action to restart network service for interface eth0<br/>- service:<br/>    name: network<br/>    state: restarted<br/>    args: eth0
</pre>
<p>These examples provide us with some insight into Ansible's service control solution and how to manage services using Ansible playbooks. Now that we have a grasp on that, let's take a look at how to transfer files using Ansible.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Transferring files in Ansible</h1>
                
            
            
                
<p>Transferring files from the local Ansible control server to a set of target machines is critical for software deployment implementations. Ansible provides a very handy <kbd>copy</kbd> module that can help us accomplish exactly this. The <kbd>copy</kbd> module provides a number of handy property knobs, which can further our goal by allowing us to set file permissions, change ownership, decrypt the file, create backups, and more. Let's take a look at how to deliver files from the local Ansible control server over to target machines using the <kbd>copy</kbd> module:</p>
<pre>
# Example from Ansible Playbooks<br/>- copy:<br/>    src: /srv/myfiles/foo.conf<br/>    dest: /etc/foo.conf<br/>    owner: foo<br/>    group: foo<br/>    mode: 0644<br/><br/># The same example as above, but using a symbolic mode<br/># equivalent to 0644<br/>- copy:<br/>    src: /srv/myfiles/foo.conf<br/>    dest: /etc/foo.conf<br/>    owner: foo<br/>    group: foo<br/>    mode: "u=rw,g=r,o=r"<br/><br/># Another symbolic mode example, adding some permissions<br/># and removing others<br/>- copy:<br/>    src: /srv/myfiles/foo.conf<br/>    dest: /etc/foo.conf<br/>    owner: foo<br/>    group: foo<br/>    mode: "u+rw,g-wx,o-rwx"<br/><br/># Copy a new "ntp.conf file into place, backing up the<br/># original if it differs from the copied version<br/>- copy:<br/>    src: /mine/ntp.conf<br/>    dest: /etc/ntp.conf<br/>    owner: root<br/>    group: root<br/>    mode: 0644<br/>    backup: yes<br/><br/># Copy a new "sudoers" file into place, after passing<br/># validation with visudo<br/>- copy:<br/>    src: /mine/sudoers<br/>    dest: /etc/sudoers<br/>    validate: 'visudo -cf %s'
</pre>
<p>Now that we have a good idea of how Ansible modules work and some implementation details, let's look at how to expand our knowledge and capabilities in developing robust and easy to maintain playbooks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This was quite a chapter. And we are nearing the halfway point in our journey through this book. In this chapter, we learned the basic constructs of Ansible playbook files, what YAML is, and the basic idea of how Jinja is incorporated as well. In addition to understanding the basic constructs, we learned how to create Ansible playbook YAML files, how to create and manage inventory files, and so much more. This chapter was quite a ride: acquiring knowledge and implementing it.</p>
<p>In the next chapter, we will look at playbook syntax. This includes roles, includes, playbook directory structures, and loops and blocks. Consider the next chapter to be progression from of this chapter. Let's get started on it then, shall we?</p>


            

            
        
    </body></html>