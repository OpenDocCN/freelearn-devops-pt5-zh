<html><head></head><body><div class="chapter" title="Chapter&#xA0;4.&#xA0;Configuring Network Devices Using Ansible"><div class="titlepage"><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Configuring Network Devices Using Ansible</h1></div></div></div><p>This chapter will focus on some of the most popular networking vendors in the market today, namely Cisco, Juniper, and Arista, and look at how each of these market leading vendors have developed their own proprietary operating system to control network operations. The aim of this book is not to discuss which network vendor's solution is better, but instead look at ways network operators can utilize configuration management tooling today to manage network devices, now that most network vendors have created APIs and SDKs to programmatically control the network.</p><p>Once the basics of each operating system have been established, we will then shift focus to the hugely <a id="id257" class="indexterm"/>popular open source configuration management tool from Red Hat named Ansible (<a class="ulink" href="https://www.ansible.com/">https://www.ansible.com/</a>).</p><p>We will look at ways it can be used to configure network devices programmatically and assist with network operations. This chapter will show practical configuration management processes that can be used to manage network devices.</p><p>In this chapter, the following topics will be covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Network vendors' operating systems</li><li class="listitem" style="list-style-type: disc">Introduction to Ansible</li><li class="listitem" style="list-style-type: disc">Ansible modules currently available for network automation</li><li class="listitem" style="list-style-type: disc">Configuration management processes to manage network devices</li></ul></div><div class="section" title="Network vendors' operating systems"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec24"/>Network vendors' operating systems</h1></div></div></div><p>Market leading <a id="id258" class="indexterm"/>networking vendors, such as Cisco, Juniper, and Arista, have all developed their own <a id="id259" class="indexterm"/>operating systems that allow network operators to issue a series of commands to network devices via a <span class="strong"><strong>command-line interface</strong></span> (CLI).</p><p>Each vendor's CLI is run from their bespoke operating systems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Cisco Ios and Nxos</li><li class="listitem" style="list-style-type: disc">Juniper Junos</li><li class="listitem" style="list-style-type: disc">Arista Eos</li></ul></div><p>All of these operating systems have meant that it has become easier to programmatically control switches, routers, and security devices provided by these vendors, as they seek to simplify operating network devices.</p><p>The rise of DevOps in industry has also meant that it is no longer acceptable to not provide programmatic APIs or SDK to aid automation, with networking vendors now integrating with configuration management tooling, such as Puppet, Chef, Ansible, and Salt, to plug into DevOps tool chains.</p><div class="section" title="Cisco Ios and Nxos operating system"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Cisco Ios and Nxos operating system</h2></div></div></div><p>The Cisco IOS operating system when released was the first of its kind, providing a set of command lines that network operators could use to mutate the state of the network. However, it still had its <a id="id260" class="indexterm"/>challenges; it had a monolithic <a id="id261" class="indexterm"/>architecture, which meant that all processes shared the same memory space, with no protection between parallel processes, so it didn't align <a id="id262" class="indexterm"/>itself well to parallel updates, but <a id="id263" class="indexterm"/>at the time it was the clear market leader. This changed network operations and meant that network engineers would each individually log onto network switches and routers to make updates using its fully featured CLI.</p><p>At the time, this greatly reduced the complexity of network operations, and Cisco standardized the way the networking industry carried out network operations in a data center. Network operators would log onto appliances and run an industry standard series of command lines to make changes to routers or switches, and Cisco ran certification programs to teach administrators how to operate the equipment and learn all the commands.</p><p>Today with efficiency and cost reductions key to businesses surviving and a shift towards more agile processes, this model in the modern data centers has an obvious scaling issue with <span class="emphasis"><em>x</em></span> amount of network engineers required per network device. </p><p>The emergence of private clouds has meant that the number of network devices each network engineer needs to manage has grown dramatically, so automation has become key to managing the growing amount of devices in a consistent way. If a businesses competitors can put products to market quicker if they have automated operational models, then they will be able to put products to market quicker than organizations that are doing manual changes. Automation has become a necessity to keep up with the rapid churn of change required on the network. As IT is changing and evolving, then automation has become a prerequisite to facilitate that evolution.</p><p>Cisco, as the networking market has evolved in recent years, has since developed a new operating system <a id="id264" class="indexterm"/>named <span class="strong"><strong>Nxos</strong></span>, which has allowed itself to integrate with open source technologies and lend itself to automation. The Nxos operating system is deployed with all new Nexus <a id="id265" class="indexterm"/>switches and routers, and this operating system has shifted Cisco towards open and modular <a id="id266" class="indexterm"/>standards by integrating <a id="id267" class="indexterm"/>with open protocols, such as <span class="strong"><strong>BGP</strong></span>, <span class="strong"><strong>EVNP</strong></span>, and <span class="strong"><strong>VXLAN</strong></span>, and the appliances <a id="id268" class="indexterm"/>can even run <span class="strong"><strong>LXC</strong></span> containers, which is an operating system-level virtualization method in order to run <a id="id269" class="indexterm"/>multiple <a id="id270" class="indexterm"/>isolated processes on a virtual machine<a id="id271" class="indexterm"/> or physical server.</p><p>Cisco have also provided a set of REST APIs that allows network operators to run native Linux and bash shells to carry out regular administration commands server side. In a world where AWS and OpenStack programmatic APIs are available to mutate network infrastructure, networking vendors needed to adapt to survive or they risked being left behind, so Cisco have made their own switches and routers as easy to configure and operate as the virtual appliances.</p><p>The Nxos operating system allows the use of the Red Hat enterprise Linux rpm package manager to control software updates. This means that software updates can be done on the Nxos in an industry standard way, the same as patching a Linux guest operating system would be carried out by an infrastructure system administrator. Consequently, Cisco network devices are now more intuitive to Linux system administrators and more like native Linux to end users, which has undoubtedly made them simpler to administrate.</p><p>The Cisco Nxos operating system means that the speed that network changes can be pushed increases, as operations staff can use their own tool chains and configuration management tools to automate updates. The Nxos operating system has become less vendor specific; therefore, lowering the barrier to entry to use networking products and automation of its product suites have become easier.</p></div><div class="section" title="Juniper Junos operating system"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec39"/>Juniper Junos operating system</h2></div></div></div><p>The Juniper Junos operating systems driver is programmatically controlled to control network operations, Junipers Junos operating system was created to provide  CLI that users can execute to retrieve <a id="id272" class="indexterm"/>facts about the running system. The <a id="id273" class="indexterm"/>Junos operating system is based on a clearly defined hierarchical model as opposed to using a series of unrelated configuration files. The hierarchical model also comes complete with operational and configuration modes of operation.</p><p>Intuitively, operational mode is used to upgrade the operating system, monitor the system, and also check the status of juniper devices. Configuration mode, on the other hand, allows network operators to configure user access and security, interfaces, hardware, and the set of protocols used on the device, which gives a clear separation of roles between those installing the system and those operating it. The Junos operating system supports all open protocols, such as BGP, VXLAN, and EVPN, as well as in-built roll forward and roll back capability.</p><p>Juniper provide a <a id="id274" class="indexterm"/>Python library named <span class="strong"><strong>PyEZ</strong></span> for the Junos operating system as well as a PowerShell option for Windows administrators that utilizes PowerShell wrapped in Python. The Python library PyEZ can retrieve any configuration information using tables and <a id="id275" class="indexterm"/>views that allow network operators to script against runtime information provided by the Junos <a id="id276" class="indexterm"/>operating system. Once a table items have been extracted by utilizing a python script using a <code class="literal">get()</code> method, tables can subsequently be treated as a Python dictionary and iterated, which allows users to carry out complex scripting if required, allowing network operators to automate all network operations. The Junos PYEZ library is also fully extensible and network operators can add functionality they deem appropriate using its widget system.</p></div><div class="section" title="Arista EOS operating system"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec40"/>Arista EOS operating system</h2></div></div></div><p>The Arista <a id="id277" class="indexterm"/>EOS operating system is based on <a id="id278" class="indexterm"/>open standards to promote automation of network functions. It relies upon a centralized <span class="strong"><strong>CloudVision eXchange</strong></span> (<span class="strong"><strong>CVX</strong></span>) and the CVX servers <a id="id279" class="indexterm"/>hold the centralized state of the network. The EOS operating system separates the functional control <a id="id280" class="indexterm"/>on every switch using <span class="strong"><strong>Sysdb</strong></span>, which is the Arista EOS operating systems database. The Arista Sysdb is an in-memory database running in user space and contains the complete state of the Arista switch. Sysdb is maintained in memory on the device so if an Arista switch is either restarted or powered down all information for that switch is lost.</p><p>The CVX server acts as an aggregator managing all the state information from every switch's Sysdb into a network-wide database depending on what services are enabled on the cluster of CVX servers. When state changes occur to Sysdb on a switch then the change is pushed to the CVX centralized database, which then updates its configuration and notifies agents running on CVX of the change.</p><p>The Arista EOS operating system supports modern open protocols, such as MLAG, ECMP, BGP, and VXLAN. It utilizes overlay technologies such as VXLAN allowing applications to be deployed and remain portable in the modern data center. Arista heavily promotes the use of the Leaf-Spine architecture with ECMP, which allows a scale out model to be implemented; this aligns itself to modern cloud solutions such as OpenStack and makes it agnostic to SDN controller solutions.</p><p>The Arista EOS operating system is a Linux-based operating system designed to be programmatically controlled. The main driver for the EOS operating system is to allow network operators to carry out network operations' using a well structured set of APIs including the eAPI, CLI command as well as Python, Ruby, and GO libraries available as part of its SDK portfolio.</p><p>The EOS operating system also allows <span class="strong"><strong>Smart System Upgrade</strong></span> (<span class="strong"><strong>SSU</strong></span>) to allow scale out of Arista appliances <a id="id281" class="indexterm"/>with live patching and upgrades simplified and made more intuitive, this helps to support businesses 99.99% uptime targets. Switches can now be racked and cabled in the data center by data <a id="id282" class="indexterm"/>center operations teams, then handed over to Arista's <span class="strong"><strong>Zero Touch Provisioning</strong></span> (<span class="strong"><strong>ZTP</strong></span>) process that automates <a id="id283" class="indexterm"/>the initialization of switches and <span class="strong"><strong>Zero Touch Replacement</strong></span> (<span class="strong"><strong>ZTR</strong></span>) allows switches to be replaced in the data center.</p><p>The Arista EOS solution CVX product can be used to automate <a id="id284" class="indexterm"/>networking workflow tasks through the portal if <a id="id285" class="indexterm"/>users require a visual view of switches and routers and the CVX allows integration with SDN controllers using OVSDB, eAPI, or OpenFlow. Like Cisco and Juniper, the EOS API lends due to it having multiple SDK options so Arista products can be easily managed by configuration management tools, such as Puppet, Chef, Ansible, and Salt, so that no network operation needs to be carried out manually.</p></div></div></div>
<div class="section" title="Introduction to Ansible"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Introduction to Ansible</h1></div></div></div><p>Ansible is primarily <a id="id286" class="indexterm"/>a push-based configuration management tool that uses a single <span class="strong"><strong>Ansible Control Host</strong></span>, and it can connect to multiple Linux guest operating <a id="id287" class="indexterm"/>systems via SSH to configure them and recently added WinRM support, so it can now also configure Windows guests in the same way as Linux-based operating systems. As Ansible can connect to multiple servers simultaneously, it aids operators by allowing them to carry out uniform operations across multiple Linux or Windows servers at the same time. This allows Ansible to help simplify the automation of repeatable tasks by defining them in YAML, so they can be consistently executed against target servers. Ansible can also be used as a centralized orchestration tool that can connect to API endpoints and sequence API operations.</p><p>Here, we can see an example of the way an Ansible Control Host connects to servers or acts as a centralized orchestration tool:</p><div class="mediaobject"><img src="graphics/5559_04_28.jpg" alt="Introduction to Ansible"/></div><p>Every operation that Ansible carries out should be idempotent as a standard, meaning that if the desired state is already configured on a server, then Ansible will check the intended state from a playbook or role and not take any action if a server is already in the correct state. Only if the state is different from what is specified in a playbook or role will the operation be executed to mutate the state of the server.</p><p>Ansible is a Python-based configuration management tool that controls servers from a Linux-based Control Host, using YAML files to define and describe desired state. Ansible is packaged with a <a id="id288" class="indexterm"/>rich set of extensible modules, which are primarily written in Python, but can also be written in any language that a user wishes. Ansible modules allow Python SDKs or REST API's to be wrapped in Ansible's plug-in boilerplate and then utilized from Ansible roles or playbooks in an easy-to-use architecture. Before going into more detailed examples, it is important to understand some of the Ansible terminology.</p><div class="section" title="Ansible directory structure"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec41"/>Ansible directory structure</h2></div></div></div><p>Ansible is made<a id="id289" class="indexterm"/> up of a series of YAML files that are laid out in a customizable <a id="id290" class="indexterm"/>directory structure.</p><p>In this customized structure, the Ansible Controller Node has the following directory structure:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">inventories</code> folder <a id="id291" class="indexterm"/>holds the Ansible inventory</li><li class="listitem" style="list-style-type: disc">The <code class="literal">library</code> folder holds any custom python plugins</li><li class="listitem" style="list-style-type: disc">The <code class="literal">playbooks</code> folder holds all playbooks</li><li class="listitem" style="list-style-type: disc">The <code class="literal">roles</code> folder holds <a id="id292" class="indexterm"/>all the Ansible roles</li></ul></div><p>The overall directory structure is shown here:</p><div class="mediaobject"><img src="graphics/5559_04_02.jpg" alt="Ansible directory structure"/></div><p>This provides logical groupings of all Ansible components, which will be useful as the amount of playbooks or roles <a id="id293" class="indexterm"/>grow in size. It is best practice to version the <code class="literal">ansible</code> folder structure in a source control management system <a id="id294" class="indexterm"/>such as <span class="strong"><strong>Git</strong></span>. Git is a distributed <a id="id295" class="indexterm"/>open source version control repository, which is <a id="id296" class="indexterm"/>designed to version control development code to facilitate speed and efficiency (<a class="ulink" href="https://en.wikipedia.org/wiki/Git).">https://en.wikipedia.org/wiki/Git).</a>
</p></div><div class="section" title="Ansible inventory"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec42"/>Ansible inventory</h2></div></div></div><p>An Ansible inventory file is simply a set of DNS hostnames or IP addresses defined in a YAML file. This allows Ansible to connect to those target hosts and execute specific commands on servers.</p><p>Ansible allows users to <a id="id297" class="indexterm"/>use inventory files to group servers into particular types or use cases. For example, in networking terms, when utilizing Ansible to set up a Leaf-Spine architecture, a <a id="id298" class="indexterm"/>network operator could have a group for Leaf switches and another for the Spine switches. This is because a different set of run-book commands would be required to configure each, so limits can be applied upon execution to only execute a command against a small subset of servers limited to one particular group.</p><p>An example of an inventory file defining Leaf and Spine switches can be found in the following image, showing the definition of two groups in the inventory file, one for Leaf switches named <code class="literal">leaf</code> and one for Spine switches named <code class="literal">spine</code> containing all the DNS entries for the switches:</p><div class="mediaobject"><img src="graphics/5559_04_03.jpg" alt="Ansible inventory"/></div><p>The same inventory can be described in an abbreviated format:</p><div class="mediaobject"><img src="graphics/5559_04_04.jpg" alt="Ansible inventory"/></div></div><div class="section" title="Ansible modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec43"/>Ansible modules</h2></div></div></div><p>An Ansible module is typically written in Python or can be written in any other programming language. An Ansible module's code defines a set of operations to add or remove functionality from a <a id="id299" class="indexterm"/>guest operating system or alternately execute a command against an API if it is <a id="id300" class="indexterm"/>being used for orchestration. Ansible modules can be used to wrap either a simple command line, API call or any other operation a user desires that can be coded programmatically. Modules are set up, so they can be reused in multiple playbooks or roles in order to promote reusing code and the standardization of operations.</p><p>Code specified in an Ansible module is wrapped in Ansible's module boilerplate, which structures the layout of the module. The boilerplate promotes a set of standards, so each module is idempotent by design, meaning that the code will first detect the state of the system and then determine if a change in state is required or not before executing the operation.</p><p>When a state change is executed in Ansible, it is donated by a yellow output on the console. If no action is taken, it will display the color green to state that the operation ran successfully, but no state change was made, whereas a red console output indicates a failure on the module.</p><p>Ansible modules expose a set of command-line arguments for the module that can either be mandatory or optional and can have default values. Modules that adhere to the Ansible standard are created with a state variable that contains <code class="literal">present</code> or <code class="literal">absent</code>, as one of the command-line variables. A module, when set to <code class="literal">present</code>, will add the feature that has been specified by the playbook and when it is set to <code class="literal">absent</code>, it will remove the specified feature. All modules will typically have code to deal with both of these use cases.</p><p>Once an Ansible module has <a id="id301" class="indexterm"/>been written, it is placed in the <code class="literal">library</code> folder, which means that it is available as <a id="id302" class="indexterm"/>a library to the Python interpreter and the code can then be utilized by defining it in an Ansible <code class="literal">playbooks</code> or <code class="literal">roles</code>. Ansible comes with a set of prepackaged core and extras modules that can all be accessed by writing some YAML to describe the operation that is required, all modules are packaged with documentation that are part of the boilerplate and available on the Ansible website.</p><p>Core modules are maintained by the Ansible core team in joint initiatives with software vendors and are generally of high quality. Extras modules can also be of a good quality but are not maintained by vendors and sometimes maintained by users that have committed back the modules to Ansible to help out the open source community.</p><p>A simple core <code class="literal">yum</code> module donated by <code class="literal">yum:</code> can be seen in the following screenshot that takes two command-line variables <code class="literal">name</code> which is used to specify the rpm to install and <code class="literal">state</code>, which determines whether to install or remove it from the target server:</p><div class="mediaobject"><img src="graphics/5559_04_05.jpg" alt="Ansible modules"/></div></div><div class="section" title="Ansible roles"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec44"/>Ansible roles</h2></div></div></div><p>Roles are a further level of abstraction in Ansible and also defined using YAML files. Roles can be called <a id="id303" class="indexterm"/>from playbooks; this aims to simplify playbooks as much as <a id="id304" class="indexterm"/>possible. As increased sets of functionality are added to <code class="literal">playbooks</code>, they can become cluttered and difficult to maintain from a single file. So roles allow operators to create minimal playbooks that then pull all the information from the Ansible directory structure, which then determines the configuration steps that need to execute on servers or be run locally.</p><p>Ansible roles attempt to strip out repeatable parts of playbooks and group them, so they can be used by multiple playbooks if required. Roles are groupings to determine what the server profile should actually be, rather than just focusing on multiple ad hoc instructions, so a playbook could <a id="id305" class="indexterm"/>be named <code class="literal">spine.yml</code> and the playbook could contain a set of modular roles used <a id="id306" class="indexterm"/>to define the particular Spine switches run-list, when executed this playbook will build the Spine switch on each target server specified in the Ansible inventory. If designed correctly some of these roles should be modular enough that they can be reused when creating Leaf switches.</p></div><div class="section" title="Ansible playbooks"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec45"/>Ansible playbooks</h2></div></div></div><p>An Ansible playbook is a YAML file that dictates the run-list to carry out on a particular set of host servers <a id="id307" class="indexterm"/>that are defined in an inventory file. A playbook specifies an ordered <a id="id308" class="indexterm"/>set of instructions to execute commands locally from Ansible Controller Node or on a target set of hosts specified in the Ansible inventory file.</p><p>An Ansible playbook can be used to create a run-list that calls out to modules or specific roles, which dictate the operations that should be executed against a server.</p><p>In this example, we see a playbook targeting the <code class="literal">spine</code> hosts in the inventory file and executing multiple <code class="literal">roles</code> to set up the Spine servers:</p><div class="mediaobject"><img src="graphics/5559_04_06.jpg" alt="Ansible playbooks"/></div><p>An alternate playbook could not use roles at all and call Ansible yum core module directly to install the apache <code class="literal">httpd-2.2.29</code> yum package on the inventory group named <code class="literal">server</code>:</p><div class="mediaobject"><img src="graphics/5559_04_07.jpg" alt="Ansible playbooks"/></div><p>Playbooks can also specify <code class="literal">when</code> conditions to dictate if an action in the playbook should be executed or not based on the output of a proceeding operation. The <code class="literal">register</code> command is used to store JSON output from a task that can then be utilized in playbooks or roles by subsequent tasks to validate if they should be invoked by reading the result of the JSON and evaluating the when condition.</p><p>Ansible playbooks from version 2.x onwards can now utilize block rescue functionality too. So if an operation <a id="id309" class="indexterm"/>nested in a block command fails, then the rescue section of the <a id="id310" class="indexterm"/>playbook is invoked. This can be useful for doing cleanup of failed actions to make playbooks more robust.</p><p>The usefulness of a block rescue operation shouldn't be underestimated, when requiring to copy a large database <code class="literal">dmp</code> file to a backup location this operation could sometimes be error-prone due to the volume of data being copied. So if the disk space is too low on the target directory, then that operation could fail half way through leaving only part of the file copied and the server in an unusable state and the server could run out of disk space. Therefore, a rescue command could be used to clean up the copied file immediately, so the server isn't left in a bad state if the copy operation fails. After the rescue command has completed, the playbook will exit with an error but remain in its original state.</p><p>In the following example, we can see a playbook using the copy: module to copy the source file <code class="literal">/var/files/db.dmp</code> to <code class="literal">/backups/db.dmp</code> and the file: module being used to delete the file if the original command fails:</p><div class="mediaobject"><img src="graphics/5559_04_08.jpg" alt="Ansible playbooks"/></div></div><div class="section" title="Executing an Ansible playbook"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec46"/>Executing an Ansible playbook</h2></div></div></div><p>After playbook and inventory files have been created utilizing the specified folder structure, it can now be <a id="id311" class="indexterm"/>executed by specifying the <code class="literal">ansible-playbook</code> command.</p><p>In the following example, the:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">ansible-playbook</code> tells Ansible that a YAML playbook file should be specified</li><li class="listitem" style="list-style-type: disc"><code class="literal">-i</code> flag is used to specify the inventory file</li><li class="listitem" style="list-style-type: disc"><code class="literal">-l</code> limits the execution only to the servers under the inventory group (servers)</li><li class="listitem" style="list-style-type: disc"><code class="literal">-e</code> passes additional variables to the playbook in this example production</li><li class="listitem" style="list-style-type: disc"><code class="literal">-v</code> sets the verbosity of the output:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>ansible-playbook –i inventories/inventory –l servers –e environment=production playbooks/devops-for-networking.yml -v</strong></span>
</pre></div></li></ul></div></div><div class="section" title="Ansible var files and jinja2 templates"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Ansible var files and jinja2 templates</h2></div></div></div><p>Ansible <code class="literal">var</code> files <a id="id312" class="indexterm"/>are just another YAML file that specify a set of variables that will be substituted into a <a id="id313" class="indexterm"/>playbook at runtime using the Ansible <code class="literal">include_vars</code> statement.</p><p>The <code class="literal">var</code> files are just a way of breaking out variables that are required by playbooks or roles at runtime. This means that different <code class="literal">var</code> files can be passed at runtime without having to hardcode variables into playbooks or roles.</p><p>An example of a <code class="literal">var</code> file syntax is shown in the following screenshot, this shows the contents of a <code class="literal">common.yml</code> <code class="literal">var</code> file containing one defined variable named <code class="literal">cert_name</code>:</p><div class="mediaobject"><img src="graphics/5559_04_09.jpg" alt="Ansible var files and jinja2 templates"/></div><p>The following example shows the <code class="literal">common.yml</code> variable above and other <code class="literal">environment.yml</code> variables , both being loaded into the playbook. The <code class="literal">{{ environment }}</code> is useful as it means that different values could be passed from the <code class="literal">ansible-playbook</code> command line to control the variables that are imported into the playbook using the <code class="literal">-e “environment=production”</code> option at runtime:</p><div class="mediaobject"><img src="graphics/5559_04_10.jpg" alt="Ansible var files and jinja2 templates"/></div><p>The <code class="literal">common.yml</code> <code class="literal">var</code> files variables value cert1 can then be used by specifying <code class="literal">{{ cert_name }}</code> variable in the playbook:</p><div class="mediaobject"><img src="graphics/5559_04_11.jpg" alt="Ansible var files and jinja2 templates"/></div><p>Ansible also has the <a id="id314" class="indexterm"/>ability to utilize Python jinja2 templates that can be transformed at <a id="id315" class="indexterm"/>runtime, to populate the configuration files information utilizing a set of <code class="literal">var</code> files; for example, the <code class="literal">{{ environment }}</code> variable in the preceding example can be specified at runtime to load variables that populate unique environment information. The jinja2 template once transformed using the template module will be parameterized to use the variables specified in the <code class="literal">environment.yml</code> file.</p><p>In the following example, we can see the Ansible <code class="literal">template:</code> module being executed as part of a role copying a jinja2 template <code class="literal">network_template.j2</code> and transforming it to <code class="literal">/etc/network.conf</code>:</p><div class="mediaobject"><img src="graphics/5559_04_12.jpg" alt="Ansible var files and jinja2 templates"/></div></div><div class="section" title="Prerequisites using Ansible to configure network devices"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec48"/>Prerequisites using Ansible to configure network devices</h2></div></div></div><p>The base constructs covered in the <span class="emphasis"><em>Introduction to Ansible</em></span> section in this chapter are all relevant to the Ansible <a id="id316" class="indexterm"/>networking modules, and to a<a id="id317" class="indexterm"/> networking team wishing to utilize Ansible for configuration management. Before starting, it is important to check with the networking vendors that the version of the networking operating system can be used with Ansible. The next step is to configure a small provisioning server to utilize as the Ansible Control Host, this is typically created on the management network so it has access appropriate to all switches.</p><p>The provisioning server can be relatively <a id="id318" class="indexterm"/>small in size as it will just be <a id="id319" class="indexterm"/>required to connect over SSH to the Linux-based networking operating systems. Ensure that the API command line is enabled on the network device. It is also a good idea to create a temporary user account on each of the networking devices, which will allow you to set up a public key on the Ansible Control Host and <span class="strong"><strong>Secure Copy</strong></span> (<span class="strong"><strong>SCP</strong></span>) the created <code class="literal">id_rsa.pub</code> to the <code class="literal">authorized_keys</code> folder <a id="id320" class="indexterm"/>on the network devices using the temporary account. This will allow Ansible to use that private key to connect to all of the hosts without the need for dealing with passwords. The temporary password can then be deleted from each of the network devices once this setup activity has been completed, you could even use Ansible to do this as a first activity.</p><p>All being well, the next step would be to create the Ansible folder structure on the provisioning server and fill out the Ansible inventory file with all the DNS names of all the network devices and finally install Ansible when you are ready to start executing playbooks. Ansible is now packaged by Red Hat in rpm format, so this should just be a simple yum install as long as the Ansible Control Host has outbound Internet access to the Red Hat repositories when using a centos image or Red Hat Enterprise Linux. Ansible will of course work on any Linux-based operating system as is still available as a PyPi package that can be installed on Ubuntu.</p></div><div class="section" title="Ansible Galaxy"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Ansible Galaxy</h2></div></div></div><p>If a network operator is looking for a start point and not well-versed in coding, they could look for examples on Ansible Galaxy, which hosts open source community roles that carry out many complex commands.</p><p>The network engineer <a id="id321" class="indexterm"/>can navigate to the Ansible Galaxy repository at <a class="ulink" href="https://galaxy.ansible.com/">https://galaxy.ansible.com/</a>.</p><div class="mediaobject"><img src="graphics/5559_04_13.jpg" alt="Ansible Galaxy"/></div><p>Ansible Galaxy houses thousands of Ansible roles that have been developed by the Open Source community.</p><p>Some available examples of <a id="id322" class="indexterm"/>networking roles are the Arista EOS role that can be used to automate Arista switch devices. Alternately, the Cisco EVPN VXLAN Spine role can be used to build Spine switches on Cisco devices or the Juniper Junos role can be used to automate Juniper network devices. So there is a wide variety of modules for a variety of technologies and use cases.</p><p>Take a <a id="id323" class="indexterm"/>look <a id="id324" class="indexterm"/>at the <a id="id325" class="indexterm"/>following useful links:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Arista EOS (<a class="ulink" href="https://galaxy.ansible.com/arista/eos-system/">https://galaxy.ansible.com/arista/eos-system/</a>)</li><li class="listitem" style="list-style-type: disc">Cisco (<a class="ulink" href="https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/">https://galaxy.ansible.com/rogerscuall/evpn_vxlan-spine/</a>)</li><li class="listitem" style="list-style-type: disc">Juniper (<a class="ulink" href="https://galaxy.ansible.com/Juniper/junos/">https://galaxy.ansible.com/Juniper/junos/</a>)</li></ul></div><p>Users can browse roles and search for a particular networking vendor. In this example, a search for Arista has returned the <span class="strong"><strong>eos</strong></span> role, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5559_04_14.jpg" alt="Ansible Galaxy"/></div><p>Each role returned has a link to their corresponding GitHub repository:</p><div class="mediaobject"><img src="graphics/5559_04_15.jpg" alt="Ansible Galaxy"/></div><p>Ansible Galaxy is a <a id="id326" class="indexterm"/>very useful tool, where users can take roles as a start point and customize them to meet their needs. Rather than just taking from the community, any new roles that may be of use to others should be contributed back to the Ansible community.</p></div></div>
<div class="section" title="Ansible core modules available for network operations"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Ansible core modules available for network operations</h1></div></div></div><p>Since the release of Ansible 2.0, the Ansible configuration management tool been packaged with some<a id="id327" class="indexterm"/> of the core networking modules from Arista, Citrix, Cumulus, and Juniper. Ansible can be used to edit configuration for any network device. It isn't restricted to just these modules. Ansible Galaxy has a wide range of roles that have been developed by the open source community.</p><p>A subnet of the Ansible 2.x networking modules can be shown in the following screenshot focusing upon the Juniper <span class="strong"><strong>Junos</strong></span>, Arista <span class="strong"><strong>Eos</strong></span>, Cisco <span class="strong"><strong>Nxos</strong></span>, and <span class="strong"><strong>Ios</strong></span>:</p><div class="mediaobject"><img src="graphics/5559_04_16.jpg" alt="Ansible core modules available for network operations"/></div><p>Ansible 2.x has sought to simplify networking modules by giving them a standard set of operations across all modules to make it feel more intuitive to network engineers. As many network engineers are not familiar with configuration management tooling, having a set of standards across <a id="id328" class="indexterm"/>modules simplifies the initial barrier to entry. As network engineers are able to see commands that they would utilize everyday being used as part of a playbook or a role, so Ansible can initially be utilized as a scheduling tool, before network operators delve into more complex modules.</p><p>One of the main fears network engineers have when first using configuration management tooling is not trusting the system or understanding what is going on under the covers. So, being able to easily read playbooks or roles and see the operations that are being executed builds confidence in the tooling and makes adoption easier.</p><p>It is fully expected that more complex networking modules will be built out over time by the open source community some of which are already available with roles from Arista, Juniper, and Cisco available in Ansible Galaxy. However, the following Ansible core modules have been standardized to allow configuration of Arista, Cisco, and Juniper network devices in the same way. These modules can be used in any playbook or role.</p><div class="section" title="The _command module"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec50"/>The _command module</h2></div></div></div><p>The main module <a id="id329" class="indexterm"/>packaged with a vendor's networking <a id="id330" class="indexterm"/>modules in Ansible 2.x is the <code class="literal">_command</code> module. This is a conscious choice by Ansible as it is more intuitive to network engineers initially to use native network commands when switching to configuration management tooling.</p><p>This module allows Ansible to connect to hosts using SSH as network device's operating systems are primarily Linux-based operating systems.</p><p>The <code class="literal">_command</code> module allows network operators to apply configuration changes to switches by connecting from the Ansible Control Host. The syntax used by Ansible on this command is identical to what network operators would execute on network devices using CLI.</p><p>In the following example, the <a id="id331" class="indexterm"/>EOS command <code class="literal">show ip bgp summary</code> is <a id="id332" class="indexterm"/>executed by the <code class="literal">eos_command</code>, and it connects to every specified <code class="literal">{{ inventory_hostname }}</code>, which is a special Ansible variable that substitutes the DNS name of every node listed in the host group specified in the inventory file. It then registers the output of the command in the <code class="literal">eos_command_output</code> variable.</p><div class="mediaobject"><img src="graphics/5559_04_17.jpg" alt="The _command module"/></div><p>Junos syntax is identical. In the following example, a similar network command executed on Junos to show interfaces with the JSON output captures in the <code class="literal">junos_command_output</code> variable.</p><div class="mediaobject"><img src="graphics/5559_04_18.jpg" alt="The _command module"/></div><p>The Cisco example shows Nxos, <a id="id333" class="indexterm"/>but the configuration is also the <a id="id334" class="indexterm"/>same in IOS. The <code class="literal">nxos_command</code> command issues a <code class="literal">show version</code> command and places the result in the <code class="literal">nxos_command_output</code> variable:</p><div class="mediaobject"><img src="graphics/5559_04_19.jpg" alt="The _command module"/></div></div><div class="section" title="The _config module"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec51"/>The _config module</h2></div></div></div><p>The <code class="literal">_config</code> module is used <a id="id335" class="indexterm"/>to configure updates in a deterministic way that could <a id="id336" class="indexterm"/>be used to implement change requests, by batching up a number of commands.</p><p>This module allows operators to update selected lines or blocks of running configuration programmatically on the network device. The module will connect to the device, extracting the running configuration before pushing batch updates in a completely deterministic way.</p><p>In the following example, the Arista switches configuration will be loaded by the module. The <code class="literal">no spanning-tree vlan 4094</code> command will be executed on the EOS operating system if the running configuration doesn't match the existing state, so the desired end state will be implemented on the switch.</p><div class="mediaobject"><img src="graphics/5559_04_20.jpg" alt="The _config module"/></div></div><div class="section" title="The _template module"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec52"/>The _template module</h2></div></div></div><p>The <code class="literal">_template</code> module is used to update configuration utilizing a jinja2 template file. This can be extracted <a id="id337" class="indexterm"/>from the running configuration of a <a id="id338" class="indexterm"/>network device, updated and then pushed back to the device.</p><p>Another use case for the <code class="literal">_template</code> module would be allowing network administrators to extract the running config into a jinja2 template from one network device and apply it to other's switches to propagate the same changes.</p><p>The <code class="literal">_template</code> module will only push incremental changes unless the force command is specified as a command-line variable, which will carry out overwrite.</p><p>In the following example, the <code class="literal">eos_config</code> jinja2 template is pushed to the Arista device and will do an incremental change to the configuration if the jinja2 template has configuration changes.</p><div class="mediaobject"><img src="graphics/5559_04_21.jpg" alt="The _template module"/></div></div></div>
<div class="section" title="Configuration management processes to manage network devices"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Configuration management processes to manage network devices</h1></div></div></div><p>DevOps is primarily all about people and process, so just focusing on some examples of playbooks or roles<a id="id339" class="indexterm"/> in isolation against a switch or firewall wouldn't help network engineer deal with the real-world networking challenges that they encounter every day. Selecting the correct <a id="id340" class="indexterm"/>tooling to facilitate processes is also important after the actual goals of a project have been established. Tooling should be selected after the business requirements have been made clear and not the opposite way round.</p><p>A network engineer could easily type in those commands into a network operating system as they could type commands into an Ansible playbook, so it is important to look at where the use of a <a id="id341" class="indexterm"/>configuration management tool such as Ansible adds real business value.</p><p>Implementing <a id="id342" class="indexterm"/>a new tool in isolation doesn't really help the network teams improve efficiency as a standalone activity, but the modules that have been created in Ansible to manage Arista, Juniper, and Cisco are facilitators of process that help simplify and standardize processes and approaches. However, it really is the process that wraps and utilizes these modules that is the key differentiator.</p><p>Ansible can be used to help with network operations in many ways, but it is good to try and categorize tasks into the following categories:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Desired state</li><li class="listitem" style="list-style-type: disc">Change requests</li><li class="listitem" style="list-style-type: disc">Self-service operations</li></ul></div><div class="section" title="Desired state"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Desired state</h2></div></div></div><p>A day one set of playbooks should be used to set the desired state of the network, utilizing a set of roles and modules to build out brand new network devices and are and control the network's <a id="id343" class="indexterm"/>intended state. An example of a day one playbook could be the first time a network engineer needs to configure a Leaf-Spine architecture utilizing Arista Leaf and Spine switches, which can seem a pretty daunting activity at first. But the beauty is that the state of the whole underlay network could be described in Ansible, but the same can be said for a firewall or any other device.</p><p>In the case of the Leaf-Spine network, activities will include configuring multiple Leaf and Spine switches, so creating a set of roles to abstract the common operations and calling them from a playbook is desirable, as the same configuration will need to be carried out on multiple servers.</p><p>A network engineer will begin by setting up the Ansible Control Host as covered in the Ansible prerequisites section. They will then create their inventory file for the Leaf-Spine architecture to configure the network devices.</p><p>The network engineer should define the inventory for all the network devices they plan to configure. In the following example, we see two host groups containing two <code class="literal">spine</code> switches and four <code class="literal">leaf</code> switches:</p><div class="mediaobject"><img src="graphics/5559_04_22.jpg" alt="Desired state"/></div><p>The network operator will also <a id="id344" class="indexterm"/>need to specify the playbook containing the roles that they wish to execute in the <code class="literal">spine.yml</code> playbook, as shown in the following screenshot, to first build out the Spine switches with the desired configuration.</p><p>In the following example playbook, we see that the playbook targets the Spine host group and executes <code class="literal">common</code>, <code class="literal">interfaces</code>, <code class="literal">bridging</code>, <code class="literal">ipv4</code>, and <code class="literal">bgp</code> roles against the servers:</p><div class="mediaobject"><img src="graphics/5559_04_23.jpg" alt="Desired state"/></div><p>The executed roles carry out the following configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>common role</strong></span>: This role is <a id="id345" class="indexterm"/>used to configure the IP routing table on the Spine</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>interfaces role</strong></span>: This role is <a id="id346" class="indexterm"/>used to configure interfaces on the Spine</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>bridging role</strong></span>: This role is <a id="id347" class="indexterm"/>used to configure all necessary VLANs and switch ports on the Spine</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ipv4 role</strong></span>: This role <a id="id348" class="indexterm"/>is used to configure the Spine's IP interfaces</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>bgp role</strong></span>: This role is <a id="id349" class="indexterm"/>used to configure BGP protocol to allow the switches to be meshed together</li></ul></div><p>All these reusable roles combined will be used to configure the Arista Spine switches and utilize the <code class="literal">eos_command</code> module heavily.</p><p>Similarly, a lot of the same <a id="id350" class="indexterm"/>modules can be utilized to configure the Leaf switches in the <code class="literal">leaf.yml</code> playbook, which targets the Leaf host group in the inventory and executes <code class="literal">common</code>, <code class="literal">interfaces</code>, <code class="literal">bridging</code>, <code class="literal">ipv4</code>, <code class="literal">bgp</code>, <code class="literal">ecmp</code>, and <code class="literal">mlag</code> roles, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/5559_04_24.jpg" alt="Desired state"/></div><p>The executed roles are used to carry out the following configuration:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>common role</strong></span>: This <a id="id351" class="indexterm"/>role is used to configure the IP routing table on the Spine</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>interfaces role</strong></span>: This <a id="id352" class="indexterm"/>is used to configure interfaces on the Spine</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bridging role</strong></span>: This is <a id="id353" class="indexterm"/>used to configure all necessary VLANs and switch ports on the Spine</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ipv4 role</strong></span>: This role<a id="id354" class="indexterm"/> is used to configure the Spine's IP interfaces</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>bgp</strong></span>: This is used <a id="id355" class="indexterm"/>to configure BGP protocol to allow the switches to be meshed together</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ecmp</strong></span>: This is used <a id="id356" class="indexterm"/>to ensure equal cost multipathing is configured in the Leaf-Spine topology</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>mlag</strong></span>: This is used <a id="id357" class="indexterm"/>to configure the switches redundantly at the top of the rack using mlag</li></ul></div><p>This shows that roles can be reused if they are kept granular enough, with <code class="literal">var</code> files providing the necessary configuration changes to the roles, so it is important to avoid any hardcoded values.</p><p>The Leaf-Spine build out is a day one playbook, but why should a network engineer be interesting in taking all this time to set this up when it will only be used once? This, of course, is a common misconception as playbooks and roles have described the whole desired state of the network, and once the initial <a id="id358" class="indexterm"/>roles are written, going forward they can be used to mutate the desired state of the network at any point in the future. </p><p>The Ansible playbooks and roles could also be used to build the second data center in the same way, used as a disaster recovery solution, help to mutate the state if a data center re-IP is required, or even scale out more Spine and Leaf switches in the data center. </p><p>Taking the last example, in terms of scaling out a data center, this would be as simple as adding more Spine or Leaf switches to the Ansible inventory. Once the additional Arista switches have been zero touch provisioned after being racked and cabled by a data center operations team. </p><p>The network operator would then only need to make a small update to the <code class="literal">var</code> files to specify the VLANs that need to be used and update the inventory.</p><p>In the following example, the infrastructure is scaled to 15 Spine switches and 44 Leaf switches by modifying the inventory file:</p><div class="mediaobject"><img src="graphics/5559_04_25.jpg" alt="Desired state"/></div><p>Although this is a pretty extreme scale out example, it should highlight the point and benefits of investing in automation. As such a scale out would take a network engineer weeks, whereas Ansible can carry out the same operations in minutes once the initial roles have been built out.</p><p>It really is worth the investment, this also means that the switches are built out consistently the same way as all the other switches, which alleviates manual error and makes the delivery of network changes more precise. Some people believe that automation is all about pace, but in networking, it should really be about consistency.</p><p>The same <code class="literal">spine.yml</code> and <code class="literal">leaf.yml</code> playbooks could also be executed against existing switches during the scale out, as Ansible is idempotent by nature, meaning only state changes will be pushed to the switches if the configuration has changed. If roles are not idempotent, then the modules being called are at fault.</p><p>This idempotency<a id="id359" class="indexterm"/> means the same day one playbook forming a <code class="literal">site.yml</code> that calls both <code class="literal">spine.yml</code> and <code class="literal">leaf.yml</code> could be run over existing switches and not change any configuration and be re-used without having to target just the changed switches. It is important to note that all Ansible changes should be tested against a test environment before being run in production.</p></div><div class="section" title="Change requests"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Change requests</h2></div></div></div><p>Network engineers despite this automation still need a separate process for manual change requests, right? The simple answer is no, manual changes would break the <a id="id360" class="indexterm"/>desired state that has been described in the day one playbooks. All network changes going forward should be pushed through the same configuration mechanism; there should be no such thing as a separate stream of work or an ad hoc command.</p><p>Making changes outside the process will only serve to break the Ansible playbooks and roles that were used to maintain the desired state and break the automation. It is important to note that utilizing network automation is an all or nothing approach that needs to be adopted by all team members and no changes should be done outside of the process or it breaks the model of repeatability and reliable changes. If features are lacking, the day one playbooks should be extended to incorporate the changes.</p></div><div class="section" title="Self-service operations"><div class="titlepage"><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Self-service operations</h2></div></div></div><p>With the use of Ansible for network operations, one of the typical bottle necks is the reluctance for network <a id="id361" class="indexterm"/>engineers to give development teams access to carry out network changes themselves, so this places a bottle neck on networking teams as usually a company will have more developers than network engineers.</p><p>This reluctance is because network changes are traditionally complex and a developer's forte is to develop code and create applications, not log onto networking devices to make firewall changes for their application.</p><p>However, if network engineers created a self-service playbook that defined a safe set of workflow actions, then developers could use it to interface with network devices in a safe way, this opens up a whole world of opportunity to remove that bottleneck.</p><p>This puts network engineers in the position of a <span class="strong"><strong>subject matter expert</strong></span> (<span class="strong"><strong>SME</strong></span>) role to help architect and use their network experience to create network automation that embodies networking best <a id="id362" class="indexterm"/>practices, to serve the needs of development teams.</p><p>This is instead of network engineers carrying out manual actions such as opening firewall ports manually when a developer raises a ticket. It is of course a change in role, but an automated approach is the way the industry is evolving.</p><p>Take the example of a firewall request, a development team have created a new application and need a test environment to deploy it in. When configuring the test environment, it needs networking, and a network engineer will ask the developer the ports they need to open in the firewall.</p><p>The developer doesn't know how to answer this question yet as they haven't finalized the application and want to start incrementally developing it in the test environment. Therefore, each time a new port needs to be opened, it means that a new network ticket is required to open the incremental port the development team discovers. This is not the optimum use of the <a id="id363" class="indexterm"/>network engineer or the developer's time as it causes frustration on both sides. A network engineer's time is better spent optimizing the network or adding improved alerting, not processing tickets to open firewall ports.</p><p>Instead Ansible could be used to create a self-service file. A developer could create a jinja2 template that could be checked into source control that lists the configuration file used to make firewall changes using the <code class="literal">template:</code> module. This shows the existing firewall line items and is available to developers to add new line items and submit a pull request to open a port on the firewall.</p><p>The network engineer then reviews the change and approves or rejects it. Ansible upon approval can be automatically triggered to push the change to a test environment; this makes sure that the config is valid.</p><p>In the following example, we see the playbook that replaces the <code class="literal">firewall.config</code> file with the updated jinja2 <code class="literal">firewall.j2</code> template and then reloads the firewall configuration from the new template:</p><div class="mediaobject"><img src="graphics/5559_04_26.jpg" alt="Self-service operations"/></div><p>This allows network teams to enable a self-service model. This speeds up the pace of network changes. It also removes the networking team as the bottleneck and pushes them to create appropriate tests and controls for network changes.</p><p>Self-service doesn't mean network engineers are no longer required. This means that they become the gatekeepers of the process instead of constantly rushing to keep up with the never ending chain of ad hoc requests they receive on a daily basis.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Summary</h1></div></div></div><p>In this chapter, we looked at how Ansible can be used for server-side configuration management of network devices and looked at some of the industry leading network vendors, such as Arista, Cisco, and Juniper, who have all changed their operational models to use open standards and protocols that are well-suited to automation.</p><p>After reading this chapter, you should now be familiar with networking operating system from Cisco, Juniper, and Arista. The Ansible configuration management tool and concepts, such as Ansible Inventory, Ansible Modules, Ansible Playbooks, Ansible Roles, and Ansible var files and Jinja2 templates. Readers should also be familiar with Ansible Galaxy, the core Ansible modules available for network automation and methodologies to manage network devices using Ansible.</p><p>This chapter gave readers an understanding of use cases where tools such as Ansible can be used to automate everyday network operations that are carried out by network engineers. It should also give readers an insight into ways they could improve their network automation by utilizing configuration management tooling. </p><p>The key takeaways from this chapter are that configuration management tools such as Ansible now support network operations natively and vendors, such as Cisco, Juniper, and Arista, have created modules to facilitate automation of network operations. There is now no reason not to start automating network operations as these methods are fully supported by leading network vendors who understand that SDN operations are the future of network operations.</p><p>We have witnessed that Ansible is a very flexible tool. One of its main strengths is its ability to orchestrate APIs and help schedule software releases. Load balancing applications is a fundamental component of the software development release process, so in the the following chapter we will look at configuration management principles that can help orchestrate load balancers and help networking teams easily maintain complex load balancing solutions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>Useful <a id="id364" class="indexterm"/>links for Ansible network automation:</p><p>
<a class="ulink" href="https://www.youtube.com/watch?v=7FphWEFQbac">https://www.youtube.com/watch?v=7FphWEFQbac</a>
</p><p>
<a class="ulink" href="https://www.youtube.com/watch?v=VYEVjKvMKqU">https://www.youtube.com/watch?v=VYEVjKvMKqU</a>
</p><p>Useful<a id="id365" class="indexterm"/> links for Cisco:</p><p>
<a class="ulink" href="https://pynet.twb-tech.com/blog/automation/cisco-ios.html">https://pynet.twb-tech.com/blog/automation/cisco-ios.html</a>
</p><p>
<a class="ulink" href="http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html">http://www.cisco.com/c/en/us/support/switches/nexus-7000-series-switches/products-command-reference-list.html</a>
</p><p>Useful <a id="id366" class="indexterm"/>links for Juniper:</p><p>
<a class="ulink" href="https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html">https://www.juniper.net/documentation/en_US/junos15.1/topics/concept/junos-script-automation-overview.html</a>
</p><p>
<a class="ulink" href="http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf">http://www.juniper.net/techpubs/software/junos-security/junos-security10.4/junos-security-cli-reference/junos-security-cli-reference.pdf</a>
</p><p>Useful<a id="id367" class="indexterm"/> links for Arista:</p><p>
<a class="ulink" href="https://www.arista.com/en/products/eos/automation">https://www.arista.com/en/products/eos/automation</a>
</p><p>
<a class="ulink" href="https://www.arista.com/docs/Manuals/ConfigGuide.pdf">https://www.arista.com/docs/Manuals/ConfigGuide.pdf</a>
</p></div></div></div></body></html>