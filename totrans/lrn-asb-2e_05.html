<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-77"><a id="_idTextAnchor253"/>5</h1>
<h1 id="_idParaDest-78"><a id="_idTextAnchor254"/>Deploying WordPress</h1>
<p>In the previous chapter, we built a playbook that installs and configures a basic <strong class="bold">LAMP stack</strong>. In this chapter, we will be building on top of the techniques we used there to create a playbook that installs a <strong class="bold">LEMP stack</strong>, which, as you might recall, replaces Apache with NGINX and then installs WordPress.</p>
<p>Once we finish this chapter, you should be able to do the following:</p>
<ul>
<li>Prepare our initial playbook</li>
<li>Download and install the WordPress CLI</li>
<li>Install and configure WordPress</li>
<li>Log in to your WordPress installation</li>
</ul>
<p>The chapter covers the following topics:</p>
<ul>
<li>Preinstallation tasks</li>
<li>The <code>stack_install</code> role</li>
<li>The <code>stack_config</code> role</li>
<li>The <code>wordpress</code> role</li>
<li>Running the WordPress playbook</li>
</ul>
<p>Before we start, we should quickly cover what WordPress is; you have likely visited a website powered by WordPress at some point in the last 24 hours.</p>
<p>It is an open-source <strong class="bold">content management system</strong> (<strong class="bold">CMS</strong>) powered by PHP and MySQL and used by around 810 million websites, which is around 43% of all the websites on the internet today, according to the statistics published by Colorlib in August of 2023.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor255"/>Technical requirements</h1>
<p>Like in <a href="B21620_04.xhtml#_idTextAnchor202"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying a LAMP Stack</em>, we will use the local <a id="_idTextAnchor256"/><strong class="bold">Multipass <a id="_idTextAnchor257"/>virtual machine</strong> we have been using throughout the title. Again, additional packages will be downloaded when launching the virtual machine and deploying WordPress.</p>
<p>You can find a complete copy of the playbook in the repository accompanying this title at <a href="https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05">https://github.com/PacktPublishing/Learn-Ansible-Second-Edition/tree/main/Chapter05</a>.</p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor258"/>Preinstallation tasks</h1>
<p>As<a id="_idIndexMarker302"/> mentioned in <a href="B21620_04.xhtml#_idTextAnchor202"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying a LAMP Stack</em>, a LEMP stack is composed of the following elements:</p>
<ul>
<li><strong class="bold">Linux</strong>: In our case, this will be the Ubuntu Multipass virtual machine</li>
<li><strong class="bold">NGINX</strong>: If you remember, it is pronounced as <em class="italic">engine-x</em>, which means there is an <em class="italic">E</em> in <em class="italic">LEMP</em> and not an <em class="italic">N</em> (which would also make it impossible to pronounce as an abbreviation)</li>
<li><strong class="bold">MariaDB</strong>: As we have already seen, this will be the database component</li>
<li><strong class="bold">PHP</strong>: We will be using PHP 8 again for this</li>
</ul>
<p>Before we install WordPress, we need to install and configure these components. Also, as this playbook will eventually be executed against publicly available cloud servers, we must consider some best practices around our NGINX configuration.</p>
<p>However, before we start looking at the playbook, let’s start things off by getting the initial structure of the playbook set up:</p>
<pre class="console">
$ mkdir Chapter05 Chapter05/group_vars Chapter05/roles
$ touch Chapter05/group_vars/common.yml Chapter05/hosts Chapter05/site.yml
$ cd Chapter05</pre> <p>This gives us our basic layout. Next, we must copy the <code>cloud-init.yaml</code>, <code>example_key</code>, <code>example_key.pub</code>, and <code>hosts.example</code> files from the previous chapters, so when it is time to run the playbook, we have everything we need to launch the virtual machine using Multipass.</p>
<p>Now that we have the basics configured, we can make a start by writing the playbook to deploy and configure our initial software stack.</p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor259"/>The stack_install role</h1>
<p>We are<a id="_idIndexMarker303"/> going to start by creating a role called <code>stack_install</code> using <code>ansible-galaxy </code><code>role init</code>:</p>
<pre class="console">
$ ansible-galaxy role init roles/stack_install</pre> <p>This will install our initial software stack. Once installed, we hand it over to a second role, which will then configure the software stack before a third role starts the WordPress installation.</p>
<p>So, what packages do we need? WordPress has the following requirements:</p>
<ul>
<li>PHP 7.4 or greater</li>
<li>MySQL 5.7 or greater OR MariaDB 10.4 or greater</li>
<li>Nginx or Apache with the <code>mod_rewrite</code> module</li>
<li>HTTPS support</li>
</ul>
<p>We know from the previous chapter that the versions of PHP and MariaDB we are installing meet this requirement, leaving just NGINX, which we can download and install from the principal NGIN<a id="_idTextAnchor260"/>X repository to get the latest and greatest version.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor261"/>Enabling the NGINX repository</h2>
<p>Before we<a id="_idIndexMarker304"/> look at the tasks and variables that we will need to enable the mainline NGINX repository, let’s start o<a id="_idTextAnchor262"/>ff the <code>roles/stack_install/tasks/main.yml</code> file with a task that updates the operating system and the cache of available packages:</p>
<pre class="source-code">
- name: "Update apt-cache and upgrade packages"
  ansible.builtin.apt:
    name: "*"
    state: "latest"
    update_cache: true</pre> <p>The <a id="_idIndexMarker305"/>remainder of the tasks we will be defining enable the repository before we finally install the packages.</p>
<p>Moving o<a id="_idTextAnchor263"/><a id="_idTextAnchor264"/>nto the <code>roles/stack_install/default/main.yml</code> file, we need to set some variables containing information on the repository, which we will add alongside the default Ubuntu ones.</p>
<p>These variables start with one that contains the URL of the signing key for the repository that will be enabled:</p>
<pre class="source-code">
repo_keys_url:
  - "http://nginx.org/keys/nginx_signing.key"</pre> <p>We will then add the following repository URLs:</p>
<pre class="source-code">
repo_packages:
  - "deb http://nginx.org/packages/mainline/ubuntu/ {{ ansible_distribution_release }} nginx"
  - "deb-src http://nginx.org/packages/mainline/ubuntu/<a id="_idTextAnchor265"/> {{ ansi<a id="_idTextAnchor266"/>ble_distribution_release }} nginx"</pre> <p>You may have noticed that we are using the <code>ansible_distribution_release</code> fact to dynamically run into the URL to put the correct version number of the Ubuntu distribution.</p>
<p>Now, back<a id="_idTextAnchor267"/> to the <code>roles/stack_install/tasks/main.yml</code> file and the two tasks that call these variables – these will look like the following, starting with the addition of the signing key:</p>
<pre class="source-code">
- name: "Add the apt keys from a URL"
  ansible.builtin.apt_key:
    url: "{{ item }}"
    state: "present"
  with_items: "{{ repo_keys_url }}"</pre> <p>As you can see, we are using <code>with_items</code>, so, if you need to, you could define more than one URL and add additional signing keys.</p>
<p>This approach <a id="_idIndexMarker306"/>is carried forward to the next task, where we are adding more than one repository:</p>
<pre class="source-code">
- name: "Install the repo packages"
  ansible.builtin.apt_repository:
    repo: "{{ item }}"
    state: "present"
    update_cache: true
  with_items: "{{ repo_packages }}"</pre> <p>The final task in the <code>roles/stack_install/tasks/main.yml</code> file is the one that installs all of the packages:</p>
<pre class="source-code">
- name: "Update cache and install the stack packages"
  ansible.builtin.apt:
    state: "present"
    update_cache: true
    pkg: "{{ system_packages + extra_packages + stack_packages }}"</pre> <p>You will notice that rather than defining the packages in a single variable, I have split them into three, and we are combining them by using <code>+</code> when calling the variables.</p>
<p>So, what do these three variables contain, and why don’t we define them as a single variable?</p>
<p>Back to the <code>roles/stack_install/default/main.yml</code> file, you can see that <code>system_packages</code> is defined as the following:</p>
<pre class="source-code">
system_packages:
  - "software-properties-common"
  - "python3-pymysql"
  - "acl"</pre> <p>Following that, the <code>extra_packages</code> variable contains the following package list:</p>
<pre class="source-code">
extra_packages:
  - "vim"
  - "git"
  - "unzip"</pre> <p>Finally, we <a id="_idIndexMarker307"/>have the list of packages that make up the bulk of our software stack:</p>
<pre class="source-code">
stack_packages:
  - "nginx"
  - "mariadb-server"
  - "mariadb-client"
  - "php-cli"
  - "php-curl"
  - "php-fpm"
  - "php-gd"
  - "php-intl"
  - "php-mbstring"
  - "php-mysql"
  - "php-soap"
  - "php-xml"
  - "php-xmlrpc"
  - "php-zip"</pre> <p>As we are defining three variables for the packages, it means that we can, if required, overwrite them elsewhere in our playbook.</p>
<p>Let us, for example, assume that we need to install the Amazon Web Services command-line tool on the virtual machine.</p>
<p>This would allow us to push data, such as images, to an Amazon S3 bucket or clear a cache on a CloudFront content delivery network endpoint.</p>
<p>Rather than <a id="_idIndexMarker308"/>overriding a long list of packages from a single variable, we could take the <code>extra_packages</code> variable, add it to <code>group_vars/common.yml</code>, and append it to the end of the list of packages so that it will now look like the foll<a id="_idTextAnchor268"/>owing:</p>
<pre class="source-code">
extra_packages:
  - "vim"
  - "git"
  - "unzip"
  - "awscli"</pre> <p>As you can see, this is a lot more efficient than repeating all the packages we want to install.</p>
<p>Another advantage of using <code>+</code> to combine everything is that we only need to call a single <code>ansible.builtin.apt</code> task to install everything we need for the following role, which we will dive into now.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor269"/>The stack_config role</h1>
<p>Now that <a id="_idIndexMarker309"/>we have our base software stack installed we need to configure it, let’s start by creating the role by running the following command:</p>
<pre class="console">
$ ansible-galaxy role init roles/stack_config</pre> <p>This gives us the basic file structure needed for the <code>stack_config</code> role. With that in place, we can now look at configuring the role itself – in this role, we will need to do the following:</p>
<ul>
<li>Add a system user for our WordPress installation to run under</li>
<li>Configure NGINX as per the best practices on the WordPress documentation</li>
<li>Configure PHP-FPM to run as the WordPress user we created earlier</li>
</ul>
<p>As we need a user for WordPress to run under, we should make a start there.</p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor270"/>WordPress system user</h2>
<p>The <a id="_idIndexMarker310"/>defaults for the WordPress system user, which should be placed in <code>roles/stackconfig/defaults/main.yml</code>, are as follows:</p>
<pre class="source-code">
wordpress_system:
  user: "wordpress"
  group: "php-fpm"
  comment: "wordpress system user"
  home: "/var/www/wordpress"
  state: "present"</pre> <p>We refer to this as the system user, as we will create a user in WordPress itself later in the chapter. This user’s details will also be defined in Ansible, so we do not want to get the two different users confused.</p>
<p>The two tasks that use these variables, found in <code>roles/stack_config/tasks/main.yml</code>, should look like this:</p>
<pre class="source-code">
- name: "add the wordpress group"
  ansible.builtin.group:
    name: "{{ wordpress_system.group }}"
    state: "{{ wordpress_system.state }}"</pre> <p>The preceding task ensures that the group is present, and the next task adds an operating system-level user, which is added to the group that has just been created:</p>
<pre class="source-code">
- name: "Add the wordpress user"
  ansible.builtin.user:
    name: "{{ wordpress_system.user }}"
    group: "{{ wordpress_system.group }}"
    comment: "{{ wordpress_system.comment }}"
    home: "{{ wordpress_system.home }}"
    state: "{{ wordpress_system.state }}"</pre> <p>As you can see, we are not adding a key to the user this time as we don’t want to log in to the user <a id="_idIndexMarker311"/>account to start manipulating files and other actions. This should all be done within WordPress itself or by using Ansible.</p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor271"/>NGINX configuration</h2>
<p>We <a id="_idIndexMarker312"/>are going to be using several template files for our NGINX configuration. The first template is called <code>roles/stack_config/templates/nginx-nginx.conf.j2</code>, and it will replace the <a id="_idIndexMarker313"/>main NGINX configuration deployed by the package installation:</p>
<pre class="source-code">
# {{ ansible_managed }}
user  nginx;
worker_processes  {{ ansible_processor_count }};
error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;
events {
    worker_connections  1024;
}
http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;
    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';
    access_log  /var/log/nginx/access.log  main;
    sendfile        on;
    keepalive_timeout  65;
    client_max_body_size 20m;
    include /etc/nginx/conf.d/*.conf;
}</pre> <p>The <a id="_idIndexMarker314"/>file’s <a id="_idIndexMarker315"/>content is the same as the file that will be replaced, except that we are updating <code>worker_processes</code> to use the number of processors detected by Ansible when the setup module runs rather than a hardcoded value.</p>
<p>The task to deploy the configuration file is as you would expect, and it should be placed in <code>roles/stack_config/tasks/main.yml</code>:</p>
<pre class="source-code">
- name: "Copy the nginx.conf to /etc/nginx/"
  ansible.builtin.template:
    src: nginx-nginx.conf.j2
    dest: /etc/nginx/nginx.conf
    mode: "0644"
  notify: "Restart nginx"</pre> <p>As you can see, we are notifying the restart <code>nginx</code> handler, which is stored in the <code>roles/stack_config/handlers/main.yml</code> file:</p>
<pre class="source-code">
- name: "Restart nginx"
  ansible.builtin.service:
    name: nginx
    state: restarted
    enabled: true</pre> <p>Next, we have the default site template, <code>roles/stack_config/templates/nginx-confd-default.conf.j2</code>:</p>
<pre class="source-code">
# {{ ansible_managed }}
upstream {{ php.upstream }} {
        server {{ php.ip }}:{{ php.port }};
}
server {
     listen       80;
     server_name  {{ ansible_nodename }};
     root         {{ wordpress_system.home }};
     index        index.php index.html index.htm;
    include global/restrictions.conf;
    include global/wordpress_shared.conf;
}</pre> <p>To help<a id="_idIndexMarker316"/> identify where the template files will be <a id="_idIndexMarker317"/>placed on the target host, I am naming them so that the full path is in the filename. In this case, the filename is <code>nginx-confd-default.conf.j2</code>, and it will be deployed to <code>/etc/nginx/conf.d/default.conf</code>; the task to do this follows:</p>
<pre class="source-code">
- name: "Copy the default.conf to /etc/nginx/conf.d/"
  ansible.builtin.template:
    src: nginx-confd-default.conf.j2
    dest: /etc/nginx/conf.d/default.conf
    mode: "0644"
  notify: "Restart nginx"</pre> <p>The following two files we are deploying are going into a folder that doesn’t exist. So, we first need to create the destination folder. To do this, we need to add the following to <code>roles/stack_config/tasks/main.yml</code>:</p>
<pre class="source-code">
- name: "Create the global directory in /etc/nginx/"
  ansible.builtin.file:
    dest: /etc/nginx/global/
    state: directory
    mode: "0644"</pre> <p>As we <a id="_idIndexMarker318"/>are not making any replacements in the <code>nginx-global-restrictions.conf</code> file, we are using the <code>ansible.builtin.copy</code> module rather than <code>ansible.builtin.template</code> here; the<a id="_idIndexMarker319"/> file is stored <code>in roles/stack_config/files/</code> and the task that copies it is as follows:</p>
<pre class="source-code">
- name: "Copy the restrictions.conf to /etc/nginx/global/"
  ansible.builtin.copy:
    src: nginx-global-restrictions.conf
    dest: /etc/nginx/global/restrictions.conf
    mode: "0644"
  notify: "Restart nginx"</pre> <p>This file has some sensible defaults in it, such as denying access to files that are included as part of the WordPress installation:</p>
<pre class="source-code">
location ~* /(wp-config.php|readme.html|license.txt|nginx.conf) {
    deny all;
}</pre> <p>Another import inclusion is adding a configuration to deny access to <code>.php</code> files within <code>/wp-content/</code> and its sub-folders:</p>
<pre class="source-code">
location ~* ^/wp-content/.*.(php|phps)$ {
    deny all;
}</pre> <p>There are several other configurations in the <code>nginx-global-restrictions.conf</code> file; see the repository, which accompanies the book, for the complete configuration, as there are too many snippets for us to go into here.</p>
<p>The<a id="_idIndexMarker320"/> same can be said for the next and final block of <a id="_idIndexMarker321"/>the NGINX configuration; review the repository for more information on the configuration deployed by the following task:</p>
<pre class="source-code">
- name: "Copy the wordpress_shared.conf to /etc/nginx/global/"
  ansible.builtin.template:
    src: nginx-global-wordpress_shared.conf.j2
    dest: /etc/nginx/global/wordpress_shared.conf
    mode: "0644"
  notify: "Restart nginx"</pre> <p>When we reviewed the def<a id="_idTextAnchor272"/>ault site template, <code>roles/stack_config/templates/nginx-confd-default.conf.j2</code>, you may have noticed the use of a few variables we haven’t yet defined; they were <code>php.ip</code> and <code>php.port</code>.</p>
<p>As you may have already guessed from the variable labeling, these have to do with the configuration of PHP, so, let us look at configuring the PHP and PHP-FPM part of our deployment.</p>
<h3>PHP and PHP-FPM configuration</h3>
<p>As we <a id="_idIndexMarker322"/>saw in the previous section, there are a few variables defined for PHP in <code>roles/stack_config/defaults/main.yml</code>, and these are as follows:</p>
<pre class="source-code">
php:
  ip: "127.0.0.1"
  port: "9000"
  upstream: "php"
  ini:
    - { regexp: "^;date.timezone =", replace: "date.timezone = Europe/London" }
    - { regexp: "^expose_php = On", replace: "expose_php = Off" }
    - {
        regexp: "^upload_max_filesize = 2M",
        replace: "upload_max_filesize = 20M",
      }</pre> <p>We then <a id="_idIndexMarker323"/>have some variables that define some information on the paths for the various files and service names:</p>
<pre class="source-code">
php_fpm_path: "/etc/php/8.1/fpm/pool.d/www.conf"
php_ini_path: "/etc/php/8.1/fpm/php.ini"
php_service_name: "php8.1-fpm"</pre> <p>The first configuration of the two tasks we will be running deploys the PHP-FPM configuration; this is, what the template, which can be found at <code>roles/stack_config/templates/php-fpmd-www.conf.j2</code>, looks like:</p>
<pre class="source-code">
; {{ ansible_managed }}
[{{ wordpress_system.user }}]
user = {{ wordpress_system.user }}
group = {{ wordpress_system.group }}
listen = {{ php.ip }}:{{ php.port }}
listen.allowed_clients = {{ php.ip }}
pm = dynamic
pm.max_children = 50
pm.start_servers = 5
pm.min_spare_servers = 5
pm.max_spare_servers = 35
php_admin_value[error_log] = /var/log/php-fpm/{{ wordpress_system.user }}-error.log
php_admin_flag[log_errors] = on
php_value[session.save_handler] = files
php_value[session.save_path]    = /var/lib/php/fpm/session
php_value[soap.wsdl_cache_dir]  = /var/lib/php/fpm/wsdlcache</pre> <p>As you can <a id="_idIndexMarker324"/>see, we have a few replacements in this file. Starting at the top between the square brackets, we are defining the PHP-FPM pool name and using the content of the <code>wordpress_system.user</code> variable for this.</p>
<p>Next, we have the user and group we want our pool to run under; here, we use <code>wordpress_system.user</code> and <code>wordpress_system.group</code>.</p>
<p>Finally, we are setting the IP address and port we want our PHP-FPM pool to listen on by using the <code>php.ip</code> and <code>php.port</code> variables.</p>
<p>The task in <code>roles/stack_config/tasks/main.yml</code> to deploy the template looks as follows:</p>
<pre class="source-code">
- name: "Copy the www.conf to /etc/php-fpm.d/"
  ansible.builtin.template:
    src: php-fpmd-www.conf.j2
    dest: "{{ php_fpm_path }}"
    mode: "0644"
  notify: "Restart php-fpm"</pre> <p>The handler to restart PHP-FPM in <code>roles/stack_config/handlers/main.yml</code> is very similar to the ones we have already been defining throughout the book:</p>
<pre class="source-code">
- name: "Restart php-fpm"
  ansible.builtin.service:
    name: "{{ php_service_name }}"
    state: restarted
    enabled: true</pre> <p>The <a id="_idIndexMarker325"/>next task in <code>roles/stack_config/tasks/main.yml</code> uses the <code>ansible.builtin.lineinfile</code> module:</p>
<pre class="source-code">
- name: "Configure php.ini settings"
  ansible.builtin.lineinfile:
    dest: "{{ php_ini_path }}"
    regexp: "{{ item.regexp }}"
    line: "{{ item.replace }}"
    backup: "true"
    backrefs: "true"
  with_items: "{{ php.ini }}"
  notify: "Restart php-fpm"</pre> <p>We are taking the <code>php.ini</code> file and looping through it by looking for the values defined by the <code>regexp</code> key. Once we find the value, we replace it with the content of the replace key. If there are changes to the file, we are making a backup first, just in case.</p>
<p>Also, we are using <code>backrefs</code> to ensure that if there is no matching <code>regex</code> in the file, then it will be left unchanged; if we didn’t use them, the <code>restart php-fpm</code> handler would be called every time the playbook runs, and we do not want PHP-FPM to be restarted if there is no reason for it be.</p>
<h3>Starting NGINX and PHP-FPM</h3>
<p>Now that <a id="_idIndexMarker326"/>we have NGINX and PHP-FPM installed and configured, we need to start the two services rather than wait until the end of the playbook run.</p>
<p>If we don’t do this now, our upcoming role to install WordPress will fail. The first of the two tasks in <code>roles/stackconfig/tasks/main.yml</code> looks like the following:</p>
<pre class="source-code">
- name: "Start php-fpm"
  ansible.builtin.service:
    name: "{{ php_service_name }}"
    state: "started"</pre> <p>The second task looks pretty much the same:</p>
<pre class="source-code">
- name: "Start nginx"
  ansible.builtin.service:
    name: "nginx"
    state: "started"</pre> <p>If you look at the two tasks, they are the same as the two handlers we have already defined.</p>
<p>However, if you look closer, you will notice that while we are using the <code>ansible.builtin.service</code> module, we are only setting the <code>state</code> setting to <code>started</code> rather than <code>restarted</code>, and we are missing the configuration for <code>enabled</code>, which sets the service to start on boot.</p>
<p>Another thing you may have noticed is the use of the <code>php_service_name</code> variable; to explain why we are using this, you will need to wait until <a href="B21620_06.xhtml#_idTextAnchor291"><em class="italic">Chapter 6</em></a>, <em class="italic">Targeting </em><em class="italic">Multiple Distributions</em>.</p>
<p>The final component of our software stack that we need to configure is MariaDB, so let us review that before we move on to the WordPress installation and configuration.</p>
<h3>MariaDB configuration</h3>
<p>The<a id="_idIndexMarker327"/> MariaDB configuration will closely match its configuration in <a href="B21620_04.xhtml#_idTextAnchor202"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying a LAMP Stack</em>, minus a few steps, so I will not go into too much detail here.</p>
<p>The default variables for this part of the role in <code>roles/stack_config/defaults/main.yml</code> are as follows:</p>
<pre class="source-code">
mariadb:
  bind: "127.0.0.1"
  server_config: "/etc/my.cnf.d/mariadb-server.cnf"
  username: "root"
  password: "Pa55W0rd123"
  hosts:
    - "127.0.0.1"
    - "::1"
    - "{{ ansible_nodename }}"
    - "localhost"</pre> <p>As you can see, we are now using a nested variable and have removed the host wildcard, which we had previously defined as <code>%</code> in <a href="B21620_04.xhtml#_idTextAnchor202"><em class="italic">Chapter 4</em></a>, <em class="italic">Deploying a </em><em class="italic">LAMP Stack</em>.</p>
<p>Our first task is to start MariaDB so that we can interact with it:</p>
<pre class="source-code">
- name: "Start mariadb"
  ansible.builtin.service:
    name: "mariadb"
    state: "started"
    enabled: true</pre> <p>Check for the presence of the <code>~/.</code><code>my.cnf</code> file:</p>
<pre class="source-code">
- name: "Check to see if the ~/.my.cnf file exists"
  ansible.builtin.stat:
    path: "~/.my.cnf"
  register: mycnf</pre> <p>Set a<a id="_idIndexMarker328"/> password:</p>
<pre class="source-code">
- name: "Change mysql root password if we need to"
  community.mysql.mysql_user:
    name: "{{ mariadb.username }}"
    host: "{{ item }}"
    password: "{{ mariadb.password }}"
    check_implicit_admin: "true"
    priv: "*.*:ALL,GRANT"
    login_user: "{{ mariadb.username }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
  with_items: "{{ mariadb.hosts }}"
  when: not mycnf.stat.exists</pre> <p>Create the <code>~/</code><code>my.cnf</code> file:</p>
<pre class="source-code">
- name: "Set up .my.cnf file"
  ansible.builtin.template:
    src: "my.cnf.j2"
    dest: "~/.my.cnf"
    mode: "0644"</pre> <p>Then, remove the anonymous user:</p>
<pre class="source-code">
- name: "Delete anonymous MySQL user"
  community.mysql.mysql_user:
    user: ""
    host: "{{ item }}"
    state: "absent"
  with_items: "{{ mariadb.hosts }}"</pre> <p>Now, we<a id="_idIndexMarker329"/> have come to our final task, which is to remove the test database:</p>
<pre class="source-code">
- name: "Remove the MySQL test database"
  community.mysql.mysql_db:
    db: "test"
    state: "absent"</pre> <p>Now, with everything we need to install and run WordPress configured, we can start on WordPress itself.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor273"/>The wordpress role</h1>
<p>Now<a id="_idIndexMarker330"/> that we have completed the roles that prepare our target virtual machine, we can proceed with the actual WordPress installation; this will be split into a few different parts, starting with downloading <code>wp-cli</code> and setting up the database.</p>
<p>Before we progress, we should create the role:</p>
<pre class="console">
$ ansible-galaxy role init roles/wordpress</pre> <p>Now that we have the empty role files, we can start populating the tasks and variables in the files.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor274"/>Some facts</h2>
<p>Before installing <a id="_idIndexMarker331"/>WordPress, we must set some facts using the <code>ansible.builtin.set_fact</code> module. The fol<a id="_idTextAnchor275"/>lowing task, the first in the <code>roles/wordpress/tasks/main.yml</code> file, sets two variables using the information gathered when Ansible first connects to the hosts:</p>
<pre class="source-code">
- name: "Set a fact for the wordpress domain"
  ansible.builtin.set_fact:
    wordpress_domain: "{{ ansible_ssh_host }}"
    os_family: "{{ ansible_distribution }} {{ ansible_distribution_version }}"</pre> <p>We will use <a id="_idIndexMarker332"/>these two variables when we install WordPress using the WordPress CLI, which we will be do<a id="_idTextAnchor276"/>wnloading and installing next.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor277"/>WordPress CLI installation</h2>
<p>WordPress CLI (<code>wp-cli</code>) is a command-line tool used to administer your WordPress installation; we <a id="_idIndexMarker333"/>will be using it throughout the role, so, the first thing our role should do is download it. To do this, we need to download the following variables in <code>roles/wordpress/defaults/main.yml</code>:</p>
<pre class="source-code">
wp_cli:
  download: "https://raw.githubusercontent.com/wp-cli/builds/gh-pages/phar/wp-cli.phar"
  path: "/usr/local/bin/wp"</pre> <p>Moving back to the <code>roles/wordpress/tasks/main.yml</code> file, we use these two variables in the following task, which downloads <code>wp-cli</code> and places it on our host:</p>
<pre class="source-code">
- name: "Download wp-cli"
  ansible.builtin.get_url:
    url: "{{ wp_cli.download }}"
    dest: "{{ wp_cli.path }}"
    mode: "0755"</pre> <p>Now, we have <code>wp-cli</code> on our host with the correct execute permissions.</p>
<p>Before we start to use <code>wp-cli</code>, we have one more bit of preparation work to do: create the database and user, which we will use with our WordPress installation.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor278"/>Creating the WordPress database</h2>
<p>The <a id="_idIndexMarker334"/>next part of the role creates the database our WordPress installation will use; as per the other tasks in this chapter, it uses a nested variable, which can be found in <code>roles/wordpress/defaults/main.yml</code>:</p>
<pre class="source-code">
wp_database:
  name: "wordpress"
  username: "wordpress"
  password: "W04DPr3S5"</pre> <p>The tasks in <code>roles/wordpress/tasks/main.yml</code> to create the database are as follows:</p>
<pre class="source-code">
- name: "Create the wordpress database"
  community.mysql.mysql_db:
    db: "{{ wp_database.name }}"
    state: "present"</pre> <p>Now that the database has been created, we can add the user:</p>
<pre class="source-code">
- name: "Create the user for the wordpress database"
  community.mysql.mysql_user:
    name: "{{ wp_database.username }}"
    password: "{{ wp_database.password }}"
    priv: "{{ wp_database.name }}.*:ALL"
    state: "present"
  with_items: "{{ mariadb.hosts }}"</pre> <p>Notice how we are using the <code>mariadb.hosts</code> variable from the previous role. Now that we have the database created, we can start downloading and installing WordPress.</p>
<h2 id="_idParaDest-90"><a id="_idTextAnchor279"/>Downloading, configuring, and installing WordPress</h2>
<p>Now that <a id="_idIndexMarker335"/>we have everything in place to install WordPress, we can make a start, first by setting some default variables in <code>roles/wordpress/defaults/main.yml</code>:</p>
<pre class="source-code">
wordpress:
  domain: "http://{{ wordpress_domain }}/"
  title: "WordPress installed by Ansible on {{ os_family }}"
  username: "ansible"
  password: "password"
  email: "test@example.com"
  plugins:
    - "jetpack"
    - "wp-super-cache"
    - "wordpress-seo"
    - "wordfence"
    - "nginx-helper"</pre> <p>Now that we have <a id="_idIndexMarker336"/>our variables, we can start our download if we need to. To find out whether we need to download WordPress, we should check for the <a id="_idIndexMarker337"/>presence of an existing WordPress installation. The task to do this in <code>roles/wordpress/tasks/main.yml</code> looks like the following:</p>
<pre class="source-code">
- name: "Are the wordpress files already there?"
  ansible.builtin.stat:
    path: "{{ wordpress_system.home }}/index.php"
  register: wp_installed</pre> <p>As you can see, the first task uses the <code>ansible.builtin.stat</code> module to check for an <code>index.php</code> file in our system user’s home directory, which in our case is also the webroot.</p>
<p>If this is the<a id="_idIndexMarker338"/> first time that the playbook is being run against the host, then we <a id="_idIndexMarker339"/>will need to download WordPress:</p>
<pre class="source-code">
- name: "Download wordpresss"
  ansible.builtin.command: "{{ wp_cli.path }} core download"
  args:
    chdir: "{{ wordpress_system.home }}"
  become_user: "{{ wordpress_system.user }}"
  become: true
  when: not wp_installed.stat.exists</pre> <p>This task uses the <code>ansible.builtin.shell</code> m<a id="_idTextAnchor280"/>odule to issue the following command:</p>
<pre class="console">
$ su wordpress -
$ cd /var/www/wordpress
$ /usr/local/bin/wp core download</pre> <p>There are a few arguments<a id="_idIndexMarker340"/> we should work through before moving on to the next task, which are the following:</p>
<ul>
<li><code>args</code> and <code>chdir</code>: You can pass additional arguments to the <code>ansible.builtin.shell</code> module using <code>args</code>. Here, we are passing <code>chdir</code>, which instructs Ansible to change to the directory we specify before running the shell command we provide.</li>
<li><code>become_user</code>: This is the user we want to run the command as. The command will run as the root user if we do not use this flag.</li>
<li><code>become</code>: This instructs Ansible to execute the task as the defined user.</li>
</ul>
<p>The next task in the playbook sets the correct permissions on the user’s home directory:</p>
<pre class="source-code">
- name: "Set the correct permissions on the homedir"
  ansible.builtin.file:
    path: "{{ wordpress_system.home }}"
    mode: "0755"
  when: not wp_installed.stat.exists</pre> <p>Now that WordPress is <a id="_idIndexMarker341"/>downloaded, we can start the installation. First, we need to check whether this has already been done:</p>
<pre class="source-code">
- name: "Is wordpress already configured?"
  ansible.builtin.stat:
    path: "{{ wordpress_system.home }}/wp-config.php"
  register: wp_configured</pre> <p>If there is no <code>wp-config.php</code> file, then the following task will be executed:</p>
<pre class="source-code">
- name: "Sort the basic wordpress configuration"
  ansible.builtin.command: "{{ wp_cli.path }} core config --dbhost={{ mariadb.bind }} --dbname={{ wp_database.name }} --dbuser={{ wp_database.username }} --dbpass={{ wp_database.password }}"
  args:
    chdir: "{{ wordpress_system.home }}"
  become_user: "{{ wordpress_system.user }}"
  become: true
  when: not wp_configured.stat.exists</pre> <p>This is like you logging in and running the following:</p>
<pre class="console">
$ su wordpress -
$ cd /var/www/wordpress
$ /usr/local/bin/wp core config \
--dbhost=127.0.0.1\
--dbname=wordpress\
--dbuser=wordpress \
--dbpass=W04DPr3S5</pre> <p>As you can see, we are using Ansible to execute commands as if we had a local terminal open.</p>
<p>Now that we<a id="_idIndexMarker342"/> have our <code>wp-config.php</code> file created, with the database credentials in place, we can install WordPress.</p>
<p>First, we need to check <a id="_idIndexMarker343"/>whether WordPress has already been installed:</p>
<pre class="source-code">
- name: "Do we need to install wordpress?"
  ansible.builtin.command: "{{ wp_cli.path }} core is-installed"
  args:
    chdir: "{{ wordpress_system.home }}"
  become_user: "{{ wordpress_system.user }}"
  become: true
  ignore_errors: true
  register: wp_installed</pre> <p>As you can see from the presence of the <code>ignore_errors</code> option, if WordPress is not installed, this command will give us an error. We are then using this to our advantage when registering the results, as you can see from the following task:</p>
<pre class="source-code">
- name: "Install wordpress if needed"
  ansible.builtin.command: "{{ wp_cli.path }} core install --url='{{ wordpress.domain }}' --title='{{ wordpress.title }}' --admin_user={{ wordpress.username }} --admin_password={{ wordpress.password }} --admin_email={{ wordpress.email }}"
  args:
    chdir: "{{ wordpress_system.home }}"
  become_user: "{{ wordpress_system.user }}"
  become: true
  when: wp_installed.rc == 1</pre> <p>This task is only<a id="_idIndexMarker344"/> executed if the previous task returns an error, which is what happens if WordPress is not installed.</p>
<p>Now that our primary WordPress site is installed, we can continue installing the plugins.</p>
<h2 id="_idParaDest-91"><a id="_idTextAnchor281"/>WordPress plugins installation</h2>
<p>The final<a id="_idIndexMarker345"/> part of our WordPress installation is to download and install the plugins we defined in the <code>wordpress.plugins</code> variable.</p>
<p>As per previous tasks, we will build a little logic into the tasks. First, we run the following task to see whether all the plugins are already installed:</p>
<pre class="source-code">
- name: "Do we need to install the plugins?"
  ansible.builtin.command: "{{ wp_cli.path }} plugin is-installed {{ item }}"
  args:
    chdir: "{{ wordpress_system.home }}"
  become_user: "{{ wordpress_system.user }}"
  become: true
  with_items: "{{ wordpress.plugins }}"
  ignore_errors: true
  register: wp_plugin_installed</pre> <p>If the plugins are not installed, this task should fail, so we have <code>ignore_errors</code> in there.</p>
<p>As you<a id="_idIndexMarker346"/> can see, we are registering the results of the entire task, because, if you remember, we are installing several plugins, such as <code>wp_plugin_installed</code>.</p>
<p>The next two tasks take the results of <code>wp_plugin_installed</code> and use the <code>ansible.builtin.set_fact</code> module to set a fact depending on the results:</p>
<pre class="source-code">
- name: "Set a fact if we don't need to install the plugins"
  ansible.builtin.set_fact:
    wp_plugin_installed_skip: true
  when: wp_plugin_installed.failed is undefined</pre> <p>The preceding task is set if we don’t need to install any of the plugins, and the following one is used if we need to install at least one of the plugins:</p>
<pre class="source-code">
- name: "Set a fact if we need to install the plugins"
  ansible.builtin.set_fact:
    wp_plugin_installed_skip: false
  when: wp_plugin_installed.failed is defined</pre> <p>As you can see, we are setting <code>wp_plugin_installed_skip</code> to be <code>true</code> or <code>false</code>: if the fact is set to <code>false</code>, then the next task will loop through installing the plugins:</p>
<pre class="source-code">
- name: "Install the plugins if we need to or ignore if not"
  ansible.builtin.command: "{{ wp_cli.path }} plugin install {{ item }} --activate"
  args:
    chdir: "{{ wordpress_system.home }}"
  become_user: "{{ wordpress_system.user }}"
  become: true
  with_items: "{{ wordpress.plugins }}"
  when: not wp_plugin_installed_skip</pre> <p>Now that<a id="_idIndexMarker347"/> we have the plugins’ tasks defined, we can have a go at running our playbook.</p>
<h1 id="_idParaDest-92"><a id="_idTextAnchor282"/>Running the WordPress playbook</h1>
<p>To run the playbook <a id="_idIndexMarker348"/>and install WordPress, we need to finish walking through the files; <code>site.yml</code> should look as follows:</p>
<pre class="source-code">
---
- name: "Install and configure WordPress and supporting software"
  hosts: "ansible_hosts"
  gather_facts: true
  become: true
  become_method: "ansible.builtin.sudo"
  vars_files:
    - "group_vars/common.yml"
  roles:
    - "stack_install"
    - "stack_config"
    - "wordpress"</pre> <p>With that out of the way, we can run the playbook.</p>
<p class="callout-heading">Note</p>
<p class="callout">The <code>Chapter05</code> folder in the GitHub repository accompanying this title contains the example <code>hosts</code> file and keys for launching a local virtual machine using Multipass. If you are following along, please refer to the instructions in <a href="B21620_01.xhtml#_idTextAnchor017"><em class="italic">Chapter 1</em></a>, <em class="italic">Installing and Running Ansible</em>; these detail how to launch the virtual machine and prepare your <code>hosts</code> file.</p>
<p>As we know, to run the playbook, we need to issue the following command once our Multipass virtual machine is up and running:</p>
<pre class="console">
$ ansible-playbook -i hosts site.yml</pre> <p>Let’s cover <a id="_idIndexMarker349"/>some of the highlights rather than go through the whole output here, starting with adding the NGINX repository:</p>
<pre class="console">
TASK [roles/stack_install : add the apt keys from a URL] **
changed: [ansiblevm] =&gt; (item=http://nginx.org/keys/nginx_signing.key)
TASK [roles/stack_install : install the repo packages] ****
changed: [ansiblevm] =&gt; (item<a id="_idTextAnchor283"/>=deb http://nginx.org/packages/mainline/ubuntu/ jammy nginx)
changed: [ansiblevm] =&gt; (item=deb-src http://nginx.org/packages/mainline/ubuntu/ jammy nginx)</pre> <p>As you can see, the name of the Ubuntu release is added – in the example, this is <code>jammy</code>.</p>
<p>When making changes to the <code>php.ini</code> file, only two of the three changes we defined need to be applied, as <code>expose_php</code> is already set to <code>Off</code>:</p>
<pre class="console">
TASK [roles/stack_config : configure php.ini] *************
changed: [ansiblevm] =&gt; (item={'regexp': '^;date.timezone =', 'replace': 'date.timezone = Europe/<a id="_idTextAnchor284"/>London'})
ok: [ansiblevm] =&gt; (item={'regexp': '^expose_php = On', 'replace': 'expose_php = Off'})
changed: [ansiblevm] =&gt; (item={'regexp': '^upload_max_filesize = 2M', 'replace': 'upload_max_filesize = 20M'})</pre> <p>Remember <a id="_idIndexMarker350"/>that we set the <code>ignore_errors</code> flag for some of the checks when it came to installing and configuring WordPress; this is why:</p>
<pre class="console">
TASK [roles/wordpress : do we need to install wordpress?] *
fatal: [ansiblevm]: FAILED! =&gt; {"changed": true, "cmd": "/usr/local/bin/wp core is-installed", "delta": "0:00:00.142910", "end": "2023-09-17 12:28:16.500304", "msg": "non-zero return code", "rc": 1, "start": "2023-09-17 12:28:16.357394", "stderr": "PHP Warning:  Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135\nWarning: Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135\nPHP Warning:  Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135\nWarning: Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135", "stderr_lines": ["PHP Warning:  Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135", "Warning: Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135", "PHP Warning:  Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135", "Warning: Undefined array key \"HTTP_HOST\" in /var/www/wordpress/wp-includes/functions.php on line 6135"], "stdout": "", "stdout_lines": []}
...ignoring
TASK [roles/wordpress : install wordpress if needed] ******
changed: [ansiblevm]</pre> <p>As you can see, an error was ignored, and the task to install WordPress was triggered. The same thing happened for the plugins:</p>
<pre class="console">
TASK [roles/wordpress : set a fact if we don't need to install the plugins] **************************************
skipping: [ansiblevm]
TASK [roles/wordpress : set a fact if we need to install the plugins] **********************************************
ok: [ansiblevm]</pre> <p>On first <a id="_idIndexMarker351"/>execution, the recap looked something like the following:</p>
<pre class="console">
PLAY RECAP ************************************************
ansiblevm                  : ok=39   changed=28   unreachable=0    failed=0    skipped=1    rescued=0    ignored=2</pre> <p>Rerunning the playbook immediately after shows how the logic we have added throughout the task execution kicks in, which results in a lot of the later tasks being skipped entirely:</p>
<pre class="console">
TASK [roles/wordpress : are the wordpress files already there?] ***************************************************
ok: [ansiblevm]
TASK [roles/wordpress : download wordpresss] **************
skipping: [ansiblevm]</pre> <p>Note that, this time, the check for the plugins doesn’t result in an error:</p>
<pre class="console">
TASK [roles/wordpress : do we need to install the plugins?]
changed: [ansiblevm] =&gt; (item=jetpack)
changed: [ansiblevm] =&gt; (item=wp-super-cache)
changed: [ansiblevm] =&gt; (item=wordpress-seo)
changed: [ansiblevm] =&gt; (item=wordfence)
changed: [ansiblevm] =&gt; (item=nginx-helper)
TASK [roles/wordpress : set a fact if we don't need to install the plugins] **************************************
ok: [ansiblevm]
TASK [roles/wordpress : set a fact if we need to install the plugins] **********************************************
skipping: [ansiblevm]
TASK [roles/wordpress : install the plugins if we need to or ignore if not] *****************************************
skipping: [ansiblevm] =&gt; (item=jetpack)
skipping: [ansiblevm] =&gt; (item=wp-super-cache)
skipping: [ansiblevm] =&gt; (item=wordpress-seo)
skipping: [ansiblevm] =&gt; (item=wordfence)
skipping: [ansiblevm] =&gt; (item=nginx-helper)</pre> <p>Now that <a id="_idIndexMarker352"/>WordPress is installed, we should be able to access it in a browser by going to the hos<a id="_idTextAnchor285"/>t you h<a id="_idTextAnchor286"/>ave defined in your <code>hosts</code> file, in my case, <code>http://192.168.64.26.nip.io/</code>; yours will be diff<a id="_idTextAnchor287"/>erent.</p>
<p>You will see the default WordPress site:</p>
<div><div><img alt="Figure 5.1 – Our freshly installed WordPress website" src="img/B21620_05_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Our freshly installed WordPress website</p>
<p>As you can see, the site’s description in the top left reads <strong class="bold">WordPress installed by Ansible on Ubuntu 22.04</strong>, which is what we set when installing WordPress.</p>
<p>Also, if you<a id="_idIndexMarker353"/> go to the WordPress admin area by appending <code>/wp-admin/</code> to the end of your URL, for example, <code>http://192.168.64.26.nip.io/wp-admin/</code>, you should be able to log in to WordPr<a id="_idTextAnchor288"/>ess using the username and password we defined:</p>
<div><div><img alt="Figure 5.2 – The WordPress admin login page" src="img/B21620_05_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The WordPress admin login page</p>
<p>Once logged in, you should see a few messages about the plugins we installed during the playbook run needing to be configured:</p>
<div><div><img alt="Figure 5.3 – Prompts when first logging into WordPress" src="img/B21620_05_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Prompts when first logging into WordPress</p>
<p>Feel free to<a id="_idIndexMarker354"/> play with the WordPress installation and even, if you are so inclined, try and break it – if you needed to, you could delete and relaunch the Multipass virtual machine and quickly rerun the playbook to reinstall WordPress.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor289"/>Summary</h1>
<p>In this chapter, we have reused many of the same principles we covered in the previous chapter and moved on to deploying a complete application. What is good about this is that the process is both repeatable and just a single command.</p>
<p>So far, we have been targeting an Ubuntu virtual machine. If we ran our playbook against a Red-Hat-based virtual machine, the playbook would give an error as commands and paths are different.</p>
<p>The next chapter will target multiple operating systems using the same playbook.</p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor290"/>Further reading</h1>
<p>You can find out more information on the technologies we have covered in this chapter at the following links:</p>
<ul>
<li><strong class="bold">Colorlib WordPress </strong><strong class="bold">statistics</strong>: <a href="https://colorlib.com/wp/wordpress-statistics">https://colorlib.com/wp/wordpress-statistics</a></li>
<li><strong class="bold">NGINX</strong>: <a href="http://nginx.org/">http://nginx.org/</a></li>
<li><strong class="bold">WordPress</strong>: <a href="https://wordpress.org/">https://wordpress.org/</a></li>
<li><strong class="bold">WP-CLI</strong>: <a href="http://wp-cli.org/">http://wp-cli.org/</a></li>
<li><strong class="bold">WordPress on </strong><strong class="bold">NGINX</strong>: <a href="https://wordpress.org/documentation/article/nginx/">https://wordpress.org/documentation/article/nginx/</a></li>
</ul>
<p>The project pages for the plugins we installed can be found at the following links:</p>
<ul>
<li><strong class="bold">Jetpack</strong>: <a href="https://en-gb.wordpress.org/plugins/jetpack/">https://en-gb.wordpress.org/plugins/jetpack/</a></li>
<li><strong class="bold">WP Super </strong><strong class="bold">Cache</strong>: <a href="https://en-gb.wordpress.org/plugins/wp-super-cache/">https://en-gb.wordpress.org/plugins/wp-super-cache/</a></li>
<li><strong class="bold">Yoast </strong><strong class="bold">SEO</strong>: <a href="https://en-gb.wordpress.org/plugins/wordpress-seo/">https://en-gb.wordpress.org/plugins/wordpress-seo/</a></li>
<li><strong class="bold">Wordfence</strong>: <a href="https://en-gb.wordpress.org/plugins/wordfence/">https://en-gb.wordpress.org/plugins/wordfence/</a></li>
<li><strong class="bold">NGINX </strong><strong class="bold">Helper</strong>: <a href="https://wordpress.org/plugins/nginx-helper/">https://wordpress.org/plugins/nginx-helper/</a></li>
</ul>
</div>
</body></html>