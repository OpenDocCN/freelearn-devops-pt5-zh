<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-78"><a id="_idTextAnchor279"/>5</h1>
<h1 id="_idParaDest-79"><a id="_idTextAnchor280"/>Creating and Consuming Modules</h1>
<p>Throughout this book, we have almost constantly referred to and made use of Ansible modules. We have treated these<a id="_idIndexMarker353"/> as <em class="italic">black boxes</em> – that is to say, we have just accepted that they exist and that they will work in a certain documented manner. However, one of the many great things about Ansible is that it is an open source project, and as such, not only can you view and modify its source code, but you can also develop your own additions. At the time of writing, there are 3,300+ modules available for Ansible, handling everything from simple commands such as copying files and installing packages to configuring highly complex and bespoke networking equipment. This large array of modules has grown out of a genuine need to solve problems with Ansible, and the number included with each release of Ansible increases every time.</p>
<p>Sooner or later, you will come across a specific piece of functionality that doesn’t exist in any of the current Ansible modules. Of course, you could attempt to fill this gap functionally, either by writing your own module or by contributing enhancements to one of the existing modules back to the Ansible project for everyone else to benefit from. In this chapter, you will learn the basics of creating modules, as well as how to contribute your code back to the upstream Ansible project if you wish.</p>
<p>Specifically, in this chapter, you will cover the following topics:</p>
<ul>
<li>Executing multiple modules using the command line</li>
<li>Reviewing the module index</li>
<li>Accessing module documentation from the command line</li>
<li>Module return values</li>
<li>Developing custom modules</li>
</ul>
<p>Let’s get started!<a id="_idTextAnchor281"/></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor282"/>Technical requirements</h1>
<p>This chapter assumes that you have set up your control host with Ansible, as detailed in <a href="B20846_01.xhtml#_idTextAnchor015"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting Started with Ansible</em>, and are using the most recent version available – the examples in this chapter were tested with <code>ansible-core</code> version 2.15. This chapter also assumes that you have at least one additional host to test against. Ideally, this should be Linux-based. Although we will give specific examples of hostnames in this chapter, you are free to substitute them with your own hostname and/or IP address. Details of how to do this will be provided in the appropriate places.</p>
<p>The module development work that will be covered in this chapter assumes the presence of a Python 3 development environment on your computer and that you are running either Linux, FreeBSD, or macOS. Where additional Python modules are needed, their installation is documented. The task of building module documentation has some very specific requirements around Python 3.10 or later, so you will need to install a suitable Python environment if you wish to attempt this.</p>
<p>The code bundle for this chapter is available here: <a href="https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%205">https://github.com/PacktPublishing/Practical-Ansible-Second-Edition/tree/main/Chapter%205</a>.<a id="_idTextAnchor283"/></p>
<h1 id="_idParaDest-81"><a id="_idTextAnchor284"/>Executing multiple modules using the command line</h1>
<p>As this<a id="_idIndexMarker354"/> chapter is all about modules and how to create them, let’s recap how to use modules. We’ve done this throughout this book, but<a id="_idIndexMarker355"/> we have not drawn attention to some of the specifics related to how they work. One of the key things we have not discussed is how the Ansible engine talks to its modules and vice versa, so let’s explore this now.</p>
<p>As ever, when working with Ansible commands, we need an inventory to run our commands against. For this chapter, as our focus is on the modules themselves, we will use a very simple and small inventory, as shown here:</p>
<pre class="source-code">
[frontends]
frt01.example.com
[appservers]
app01.example.com</pre> <p>Now, for the first part of our recap, you can run a module very easily via an ad hoc command and use the <code>-m</code> switch to tell Ansible which module you want to run. Hence, one of the simplest commands you can run is the Ansible <code>ping</code> command, as shown here:</p>
<pre class="console">
$ ansible -i hosts appservers -m ping</pre> <p>Now, let’s examine the output of the preceding command:</p>
<pre class="console">
$ ansible -i hosts appservers -m ping
app01.example.com | SUCCESS =&gt; {
    "ansible_facts": {
        "discovered_interpreter_python": "/usr/bin/python3"
    },
    "changed": false,
    "ping": "pong"
}</pre> <p>Did you notice the structure of the output – the curly braces, colons, and commas? Yes, Ansible uses JSON-formatted data to talk to its modules, and the modules report their data back to Ansible in JSON as well. The preceding output is a subset of the JSON-formatted data returned to the Ansible engine by the <code>ping</code> module.</p>
<p>Of course, we never have to worry about this as we work with the modules using either <code>key=value</code> pairs on the command line or YAML in playbooks and roles. Hence, the JSON is shielded from us, but this is an important fact to bear in mind as we head into the world of module development later in this chapter.</p>
<p>Ansible modules are just like functions in a high-level programming language, in that they take a well-defined list of arguments as input, perform their function, and then provide a set of output data, which is also well defined and documented. We’ll look at this in more detail later in this chapter. Of course, the preceding command didn’t include any arguments, so this was the simplest possible invocation of a module via Ansible.</p>
<p>Now, let’s run another command that takes an argument and passes that data to the module:</p>
<pre class="console">
$ ansible -i hosts appservers -m command -a "/bin/echo 'hello modules'"</pre> <p>In this case, we <a id="_idIndexMarker356"/>provided a single string as an argument to <a id="_idIndexMarker357"/>the command module, which Ansible, in turn, converts into JSON and passes down to the command module when it’s invoked. When you run this ad hoc command, you will see an output similar to the following:</p>
<pre class="console">
$  ansible -i hosts appservers -m command -a "/bin/echo 'hello modules'"
app01.example.com | CHANGED | rc=0 &gt;&gt;
hello modules</pre> <p>In this instance, the output data does not appear to be JSON formatted; however, what Ansible prints to the Terminal when you run a module is only a subset of the data that each module returns – for example, both the <code>CHANGED</code> status and <code>rc=0</code> exit code from our command were passed back to Ansible in a JSON-formatted data structure – this was just hidden from us.</p>
<p>This point doesn’t need to be labored too much, but it is important to set the context. It is this context that we shall build upon throughout this chapter, so simply remember these key points:</p>
<ul>
<li>Communication between Ansible and its modules is done through JSON-formatted data structures</li>
<li>Modules take input data that controls how they function (arguments)</li>
<li>Modules always return data – at the very least, the status of the module’s execution (for example, <code>changed</code>, <code>ok</code>, or <code>failed</code>)</li>
</ul>
<p>Of course, before you start coding modules, it makes sense to check whether a module that can perform all (or some) of the functionality you need already exists. We will explore this in the next s<a id="_idTextAnchor285"/>e<a id="_idTextAnchor286"/>ction.</p>
<h1 id="_idParaDest-82"><a id="_idTextAnchor287"/>Reviewing the module index</h1>
<p>As <a id="_idIndexMarker358"/>discussed in the preceding section, Ansible provides thousands of modules to make it fast and easy to develop playbooks and run them across multiple host machines. How do you go about finding the right module to begin with, though, when there are so many? Fortunately, the Ansible documentation features a well-organized, indexed list of modules that you can consult to find your desired module – this is available here: <a href="https://docs.ansible.com/ansible/latest/collections/index_module.xhtml">https://docs.ansible.com/ansible/latest/collections/index_module.xhtml</a>.</p>
<p>Let’s suppose you want to see whether there is a native Ansible module that can help you configure and manage your Amazon Web Services S3 buckets. That’s a fairly precise, well-defined need, so let’s approach this logically:</p>
<ol>
<li>Begin by opening the index of all modules in your web browser, as discussed previously: https://docs.ansible.com/ansible/latest/collections/index_module.xhtml.</li>
<li>Now, we know that <code>amazon.aws</code> modules are certainly indexed at the very beginning of this page.</li>
<li>There are still thousands of modules listed on this page! So, let’s use the find function (<em class="italic">Ctrl</em> + <em class="italic">F</em>) in the browser to see whether the <code>amazon.aws.s3</code> keyword appears anywhere:</li>
</ol>
<div><div><img alt="Figure 5.1 – Amazon modules" height="721" src="img/B20846_05_001.jpg" width="897"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Amazon modules</p>
<p>We<a id="_idIndexMarker359"/> now have a shortlist of modules to work with – granted, there are several, so we still need to work out which one (or ones) we will need for our playbook. As shown from the preceding short descriptions, this will depend on what your intended task is.</p>
<ol>
<li value="4">The short descriptions should be enough to give you some clues about whether the module will suit your needs or not. Once you have an idea, you can click on the appropriate document links to view more details about the module and how to work with it:</li>
</ol>
<div><div><img alt="Figure 5.2 – Amazon S3 module details" height="682" src="img/B20846_05_002.jpg" width="1185"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Amazon S3 module details</p>
<ol>
<li value="5">As you <a id="_idIndexMarker360"/>can see, the documentation page for each module provides a great deal of information, including a longer description. If you scroll down the page, you will see a list of the possible arguments that you can provide the module with, some practical examples of how to use them, and some details about the outputs from the module. Also, note the <code>aws_s3</code> module from a playbook without installing the <code>boto3</code> and <code>botocore</code> modules on Python 3.6 or later, you will simply receive an error.</li>
</ol>
<p>All modules must have documentation like this created before they will be accepted as part of the Ansible project, so you must keep this in mind if you intend to submit your own modules. This is also one of the reasons for Ansible’s popularity – with easy-to-maintain and well-documented standards, it is the perfect community platform for automation. The official Ansible website isn’t the only place you can obtain documentation, however, as it is even available on the command line. We shall look at how to retrieve documentation via this route in the next <a id="_idTextAnchor288"/>s<a id="_idTextAnchor289"/>ection.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor290"/>Accessing module documentation from the command line</h1>
<p>As discussed in <a id="_idIndexMarker361"/>the preceding section, the Ansible project prides itself on its documentation, and making this <a id="_idIndexMarker362"/>documentation readily accessible is an important part of the project itself. Now, suppose you are working on an Ansible task (in a playbook, role, or even an ad hoc command) and you are in a data center environment where you only have access to the shell of the machine you are working on. How would you get access to the Ansible documentation?</p>
<p>Fortunately, part of the Ansible installation that we have not discussed yet is the <code>ansible-doc</code> tool, which is installed as standard along with the familiar <code>ansible</code> and <code>ansible-playbook</code> executables. The <code>ansible-doc</code> command includes a complete (text-based) library of documentation for all the modules that ship with the version of Ansible you have installed. This means that the very information you need to work with modules is at your fingertips, even if you are in the middle of a data center and without a working internet connection!</p>
<p>The following are some examples to show you how to interact with the <code>ansible-doc</code> tool:</p>
<ul>
<li>You can list all of the modules that there’s documentation for on your Ansible control machine by simply issuing the following command:<pre class="source-code">
<strong class="bold">$ ansible-doc -l</strong></pre></li> </ul>
<p>You should see an output similar to the following:</p>
<pre class="source-code">
<strong class="bold">amazon.aws.autoscaling_group Create or delete AWS AutoScaling..</strong>
<strong class="bold">amazon.aws.autoscaling_group_info Gather information about...</strong>
<strong class="bold">amazon.aws.aws_az_info Gather information about availability...</strong>
<strong class="bold">amazon.aws.aws_caller_info Get information about the user...</strong></pre> <p>There are many pages of output, which shows you just how many modules there are! You can even count them:</p>
<pre class="source-code">
<strong class="bold">$ ansible-doc -l | wc -l</strong>
<strong class="bold">7484</strong></pre> <p>That’s right – 7,484 modules ship with Ansible 2.15!</p>
<ul>
<li>As <a id="_idIndexMarker363"/>before, you can search for specific modules using your favorite shell tools to process the index; for example, you could <code>grep</code> for <code>s3</code> to find all of the S3-related modules, as we did interactively in the web browser in the previous section:<pre class="source-code">
<strong class="bold">$ ansible-doc -l | grep s3</strong>
<strong class="bold">amazon.aws.s3_bucket Manage S3 buckets in AWS...</strong>
<strong class="bold">amazon.aws.s3_object_info Gather informatio...</strong>
<strong class="bold">community.aws.s3_bucket_info Li...</strong>
<code>aws_s3</code> module – just as we did on the website, simply run the following:<pre class="source-code">
<strong class="bold">$ ansible-doc aws_s3</strong></pre></li> </ul>
<p>This should produce an output similar to the following:</p>
<pre class="source-code">
<strong class="bold">$ ansible-doc aws_s3</strong>
<strong class="bold">&gt; AMAZON.AWS.S3_OBJECT    (/Users/danieloh/Library/Python/3.11/lib/python/site-packages/ansible_collections/amazon/aws/plugins/modules/s3_object.py)</strong>
<strong class="bold">        This module allows the user to manage the objects and directories within S3 buckets. Includes support for creating and deleting objects and directories, retrieving</strong>
<strong class="bold">        objects as files or strings, generating download links and copying objects that are already stored in Amazon S3. Support for creating or deleting S3 buckets with</strong>
<strong class="bold">...</strong>
<strong class="bold">ADDED IN: version 1.0.0 of amazon.aws</strong>
<strong class="bold">  * note: This module has a corresponding action plugin.</strong>
<strong class="bold">OPTIONS (= is mandatory):</strong>
<strong class="bold">- access_key</strong>
<strong class="bold">        AWS access key ID.</strong>
<strong class="bold">        See the AWS documentation for more information about access tokens https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.xhtml#access-keys-and-secret-</strong>
<code>ansible-doc</code> tells us about the module, provides a list of all of the arguments (<code>OPTIONS</code>) that we can pass it, and as we scroll down, even gives some working examples and possible return values. We shall explore the topic of return values in the next section as they are important to understand, especially as we approach the topic of devel<a id="_idTextAnchor291"/>o<a id="_idTextAnchor292"/>ping modules.</p>
<h1 id="_idParaDest-84"><a id="_idTextAnchor293"/>Module return values</h1>
<p>As we discussed <a id="_idIndexMarker367"/>earlier in this chapter, Ansible modules return their results as structured data, formatted behind the scenes in JSON. You came across this return data in the previous example, both in the form of an exit code and where we used the <code>register</code> keyword to capture the results of a task in an Ansible variable. In this section, we shall explore how to discover the return values for an Ansible module so that we can work with them later on in a playbook, for example, with conditional processing (see <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks </em><em class="italic">and Roles</em>).</p>
<p>Due to conserving space, we shall choose what is perhaps one of the simplest Ansible modules to work with when it comes to return values – the <code>ping</code> module.</p>
<p>Without<a id="_idIndexMarker368"/> further ado, let’s use the <code>ansible-doc</code> tool that we learned about in the previous section and see what this says about the return values for this module:</p>
<pre class="console">
$ ansible-doc ping</pre> <p>If you scroll to the bottom of the output from the preceding command, you should see something like this:</p>
<pre class="console">
$ ansible-doc ping
&gt; ANSIBLE.BUILTIN.PING    (/home/james/.local/lib/python3.10/site-packages/ansible/modules/ping.py)
...
RETURN VALUES:
ping:
 description: value provided with the data parameter
 returned: success
sample: pong
 type: str</pre> <p>Hence, we can see that the <code>ping</code> module will only return one value, and that is called <code>ping</code>. <code>description</code> tells us what we should expect this particular return value to contain, while the <code>returned</code> field tells us that it will only be returned on <code>success</code> (if it were to be returned on other conditions, these would be listed here). The <code>type</code> return value is a string (denoted by <code>str</code>), and although you can change the value with an argument provided to the <code>ping</code> module, the default return value (and hence <code>sample</code>) is <code>pong</code>.</p>
<p>Now, let’s see <a id="_idIndexMarker369"/>what this looks like in practice. For example, there’s nothing contained in those return values that would tell us whether the module ran successfully and whether anything was changed; however, we know that these are fundamental pieces of information about every module run.</p>
<p>Let’s put a very simple playbook together. We’re going to run the <code>ping</code> module with no arguments, capture the return values using the <code>register</code> keyword, and then use the <code>debug</code> module to dump the return values onto the Terminal:</p>
<pre class="source-code">
---
- name: Simple play to demonstrate a return value
hosts: localhost
tasks:
- name: Perform a simple module based task
  ansible.builtin.ping:
  register: pingresult
- name: Display the result
  ansible.builtin.debug:
    var: pingresult</pre> <p>Now, let’s see what happens when we run this playbook:</p>
<pre class="console">
$ ansible-playbook retval.yml
[WARNING]: provided hosts list is empty, only localhost is available. Note that
the implicit localhost does not match 'all'
PLAY [Simple play to demonstrate a return value] *******************************
TASK [Gathering Facts] *********************************************************
ok: [localhost]
TASK [Perform a simple module based task] **************************************
ok: [localhost]
TASK [Display the result] ******************************************************
ok: [localhost] =&gt; {
 "pingresult": {
 "changed": false,
 "failed": false,
 "ping": "pong"
 }
}
PLAY RECAP *********************************************************************
localhost : ok=3 changed=0 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>Notice that the <code>ping</code> module does indeed return a value called <code>ping</code>, which contains the <code>pong</code> string (as the ping was successful). However, you can see that there are, in fact, two<a id="_idIndexMarker370"/> additional return values that were not listed in the Ansible documentation. These accompany every single task run, and are hence implicit – that is to say, you can assume they will be among the data that’s returned from every module. The <code>changed</code> return value will be set to <code>true</code> if the module run resulted in a change on the target host, while the <code>failed</code> return value will be set to <code>true</code> if the module run failed for some reason.</p>
<p>Using the <code>debug</code> module to print the output from a module run is an incredibly useful trick if you want to gather more information about a module, how it works, and what sort of data is returned. At this point, we’ve covered just about all of the fundamentals of working with modules, so in the next section, we’ll make a start on developing our very ow<a id="_idTextAnchor294"/>n<a id="_idTextAnchor295"/> (simple) module.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor296"/>Developing custom modules</h1>
<p>Now that<a id="_idIndexMarker371"/> we’re familiar with modules, how to call them, how to interpret their results, and how to find documentation on them, we can make a start on writing a simple module. Although this will not include the deep and intricate functionality of many of the modules that ship with Ansible, it is hoped that this will give you enough information to proceed with confidence when you build out your own, more complex, ones.</p>
<p>One important<a id="_idIndexMarker372"/> point to note is that Ansible is written in Python 3, and as such, so are its modules. As a result, you will need to write your module in Python 3; to get started with developing your own module, you will need to make sure you have Python 3 and a few essential tools installed. If you are already running Ansible on your development machine, you probably have the required packages installed, but if you are starting from scratch, you will need to install Python 3, the Python 3 package manager (<code>pip3</code>), and perhaps some other development packages. The exact process will vary widely between operating systems, but here are some examples to get you started:</p>
<ul>
<li>On Fedora, you would run the following command to install the required packages:<pre class="source-code">
<strong class="bold">$ sudo dnf install python python-devel</strong></pre></li> <li>Similarly, on CentOS, you would run the following command to install the required packages:<pre class="source-code">
<strong class="bold">$ sudo yum install python3 python3-devel</strong></pre></li> <li>On Ubuntu, you would run the following commands to install the packages you need:<pre class="source-code">
<strong class="bold">$ sudo apt-get update</strong>
<strong class="bold">$ sudo apt-get install python3-pip python3-dev build-essential</strong></pre></li> <li>If you are working on macOS and are using the Homebrew packaging system, the following command will install the packages you need:<pre class="source-code">
<strong class="bold">$ brew install python</strong></pre></li> </ul>
<p>Once you<a id="_idIndexMarker373"/> have the required packages installed, you will <a id="_idIndexMarker374"/>need to clone the Ansible Git repository to your local machine as there are some valuable scripts in there that we will need later on in the module development process. Use the following command to clone the Ansible repository to your current directory on your development machine:</p>
<pre class="console">
$ git clone https://github.com/ansible/ansible.git</pre> <p>Finally (although optionally), it is good practice to develop your Ansible modules in a <strong class="bold">virtual environment</strong> (<strong class="bold">venv</strong>) as this<a id="_idIndexMarker375"/> means any Python packages you need to install go in here, rather than in with your global system Python modules. Installing modules for the entire system in an uncontrolled manner can, at times, cause compatibility issues or even break local tools, so although this is not a required step, it is highly recommended.</p>
<p>The exact command to create a virtual environment for your Python module development work will depend on both the operating system you are running and the version of Python you are using. You should refer to the documentation for your Linux distribution for more information; however, the following commands were tested on CentOS 8 with the default Python 3.11 and higher to create a virtual environment called <code>moduledev</code> inside the Ansible source code directory you just cloned from GitHub:</p>
<pre class="console">
$ cd ansible
$ python -m virtualenv moduledev
New python executable in /home/james/ansible/moduledev/bin/python
Installing setuptools, pip, wheel...done.</pre> <p>With our <a id="_idIndexMarker376"/>development environment set up, let’s start writing our first module. This module will be very simple as it’s beyond the scope of this book to provide an in-depth discussion about how to write large amounts of Python code. However, we will code something that can use a function from a Python library to copy a file locally on the target machine.</p>
<p>This overlaps <a id="_idIndexMarker377"/>heavily with existing module functionality, but it will serve as a nice concise example of how to write a simple Python program in a manner that allows Ansible to make use of it as a module. Now, let’s start coding our first module:</p>
<ol>
<li>In your preferred editor, create a new file called (for example) <code>remote_filecopy.py</code>:<pre class="source-code">
<strong class="bold">$ vi remote_filecopy.py</strong></pre></li> <li>Start with a shebang to indicate that this module should be executed with Python:<pre class="source-code">
 #!/usr/bin/env python</pre></li> <li>Although not mandatory, it is good practice to add copyright information, as well as your details, in the headers of your new module. By doing this, anyone using it will understand the terms under which they can use, modify, or redistribute it. The text given here is merely an example; you should investigate the various appropriate licenses for yourself and determine which is the best for your module:<pre class="source-code">
# Copyright: (c) 2018, Jesse Keating &lt;jesse.keating@example.org&gt;
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)</pre></li> <li>It is also good practice to add an Ansible metadata section that includes <code>metadata_version</code>, <code>status</code>, and <code>supported_by</code> information immediately after the copyright section. Note that the <code>metadata_version</code> field represents the Ansible metadata version (which, at the time of writing, should be <code>1.1</code>) and is not related to the version of your module or the Ansible version you are using. The values suggested in the following code will be fine for just getting started, but <a id="_idIndexMarker378"/>if your module gets accepted into the official Ansible source code, they are likely to change:<pre class="source-code">
ANSIBLE_METADATA = {'metadata_version': '1.1',
                    'status': ['preview'],
                    'supported_by': 'community'}</pre></li> <li>Remember <code>ansible-doc</code> and that excellent documentation that is available on the <a id="_idIndexMarker379"/>Ansible documentation website? That all gets automatically generated from special sections you add to this file. Let’s get started by adding the following code to our module:<pre class="source-code">
DOCUMENTATION = '''
---
module: remote_filecopy
version_added: "2.15"
short_description: Copy a file on the remote host
description:
- The remote_copy module copies a file on the remote host from a given source to a provided destination.
options:
source:
description:
- Path to a file on the source file on the remote host
required: True
dest:
description:
- Path to the destination on the remote host for the copy
required: True
author:
- Jesse Keating (@omgjlk)
'''</pre></li> </ol>
<p>Pay particular <a id="_idIndexMarker380"/>attention to the <code>author</code> dictionary – to pass the syntax checks for inclusion in the official Ansible code base, the <a id="_idIndexMarker381"/>author’s name should be appended with their GitHub ID in brackets. If you don’t do this, your module will still work, but it won’t pass the test we’ll perform later.</p>
<p class="callout-heading">Notice how the documentation is in YAML format, enclosed between triple single quotes?</p>
<p class="callout">The fields listed should be common to just about all modules, but naturally, if your module takes different options, you would specify these so that they match your module.</p>
<ol>
<li value="6">The examples that you will find in the documentation are also generated from this file – they have a special documentation section immediately after <code>DOCUMENTATION</code> and should provide practical examples of how you might create a task using your module, as shown in the following example:<pre class="source-code">
EXAMPLES = '''
# Example from Ansible Playbooks
- name: backup a config file
  remote_copy:
    source: /etc/herp/derp.conf
    dest: /root/herp-derp.conf.bak
'''</pre></li> <li>The data<a id="_idIndexMarker382"/> that’s returned by your module to Ansible should also be documented in its own section. Our<a id="_idIndexMarker383"/> example module will return the following values:<pre class="source-code">
RETURN = '''
source:
  description: source file used for the copy
  returned: success
  type: str
  sample: "/path/to/file.name"
dest:
  description: destination of the copy
  returned: success
  type: str
  sample: "/path/to/destination.file"
gid:
  description: group ID of destination target
  returned: success
  type: int
  sample: 502
group:
  description: group name of destination target
  returned: success
  type: str
  sample: "users"
uid:
  description: owner ID of destination target
  returned: success
  type: int
  sample: 502
owner:
  description: owner name of destination target
  returned: success
  type: str
  sample: "fred"
mode:
  description: permissions of the destination target
  returned: success
  type: int
  sample: 0644
size:
  description: size of destination target
  returned: success
  type: int
  sample: 20
state:
  description: state of destination target
  returned: success
  type: str
  sample: "file"
'''</pre></li> <li>Immediately after<a id="_idIndexMarker384"/> we have finished our documentation section, we should import any Python modules we’re going to use. Here, we will include the <code>shutil</code> module, which will be used to perform our file copy:<pre class="source-code">
<code>main</code> function, in which we will create an object of the <code>AnsibleModule</code> type and use an <code>argument_spec</code> dictionary to obtain the options that the module was called with:<pre class="source-code">
def main():
    module = AnsibleModule(
        argument_spec = dict(
            source=dict(required=True, type='str'),
            dest=dict(required=True, type='str')
        ),
    )</pre></li> <li>At this stage, we<a id="_idIndexMarker386"/> have everything we need to write our module’s functional code – even the options that it was called with. Hence, we can use the Python <code>shutil</code> module to perform the local file copy, based on the arguments provided:<pre class="source-code">
    shutil.copy(module.params['source'],
                module.params['dest'])</pre></li> <li>At this point, we’ve<a id="_idIndexMarker387"/> executed the task our module was designed to complete. However, it is fair to say that we’re not done yet – we need to exit the module cleanly and provide our return values to Ansible. Normally, at this point, you would write some conditional logic to detect whether the module was successful and whether it performed a change on the target host or not. However, for simplicity, we’ll simply exit with the <code>changed</code> status every time – expanding this logic and making the return status more meaningful is left as an exercise for you:<pre class="source-code">
module.exit_json(changed=True)</pre></li> </ol>
<p>The <code>module.exit_json</code> method comes from <code>AnsibleModule</code>, which we created earlier – remember, we said it was important to know that data was passed back and forth using JSON!</p>
<ol>
<li value="12">As we approach the end of our module code, we must now tell Python where it can import the <code>AnsibleModule</code> object from. This can be done with the following line of code:<pre class="source-code">
from ansible.module_utils.basic import *</pre></li> <li>Now, let’s look at the final two lines of code for the module – this is where we tell the module that it should be running the <code>main</code> function when it starts:<pre class="source-code">
if __name__ == '__main__':
    main()</pre></li> </ol>
<p>That’s it – with a series of well-documented steps, you can write your own Ansible modules in Python. The next step is, of course, to test it (and you will need to write formal tests to merge it with Ansible’s GitHub repository). Before we test it in Ansible, let’s see whether we can<a id="_idIndexMarker388"/> run it manually in the shell. Of course, to make the module think it is being run within Ansible, we must generate some arguments in – you guessed it – JSON format. Create a file with the following contents to provide the arguments:</p>
<pre class="source-code">
{
    "ANSIBLE_MODULE_ARGS": {
        "source": "/tmp/foo",
        "dest": "/tmp/bar"
    }
}</pre> <p>Armed with <a id="_idIndexMarker389"/>this little snippet of JSON, you can execute your module directly with Python. If you haven’t already done so, you’ll need to set up your Ansible development environment as follows. Note that we also manually create the source file, <code>/tmp/foo</code>, so that our module can perform the file copy:</p>
<pre class="console">
$ touch /tmp/foo
$ . moduledev/bin/activate
(moduledev) $ . hacking/env-setup
running egg_info
creating lib/ansible_base.egg-info
writing requirements to lib/ansible_base.egg-info/requires.txt
writing lib/ansible_base.egg-info/PKG-INFO
writing top-level names to lib/ansible_base.egg-info/top_level.txt
writing dependency_links to lib/ansible_base.egg-info/dependency_links.txt
writing manifest file 'lib/ansible_base.egg-info/SOURCES.txt'
reading manifest file 'lib/ansible_base.egg-info/SOURCES.txt'
reading manifest template 'MANIFEST.in'
warning: no files found matching 'SYMLINK_CACHE.json'
warning: no previously-included files found matching 'docs/docsite/rst_warnings'
warning: no previously-included files matching '*' found under directory 'docs/docsite/_build'
warning: no previously-included files matching '*.pyc' found under directory 'docs/docsite/_extensions'
warning: no previously-included files matching '*.pyo' found under directory 'docs/docsite/_extensions'
warning: no files found matching '*.ps1' under directory 'lib/ansible/modules/windows'
warning: no files found matching '*.psm1' under directory 'test/support'
writing manifest file 'lib/ansible_base.egg-info/SOURCES.txt'
Setting up Ansible to run out of checkout...
PATH=/home/james/ansible/bin:/home/james/ansible/moduledev/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/home/james/bin
PYTHONPATH=/home/james/ansible/lib
MANPATH=/home/james/ansible/docs/man:/usr/local/share/man:/usr/share/man
Remember, you may wish to specify your host file with -i
Done!</pre> <p>Now, you’re finally ready to run your module for the first time. You can do this as follows:</p>
<pre class="console">
(moduledev) $ python remote_filecopy.py args.json
{"invocation": {"module_args": {"dest": "/tmp/bar", "source": "/tmp/foo"}}, "changed": true}
(moduledev) $ ls -l /tmp/bar
-rw-r--r-- 1 root root 0 Apr 26 12:35 /tmp/bar</pre> <p>Success! Your <a id="_idIndexMarker390"/>module works – and it both ingests and produces JSON data, as we discussed earlier in this chapter. Of course, there’s much <a id="_idIndexMarker391"/>more to add to your module – we’ve not addressed <code>failed</code> or <code>ok</code> returns from the module, nor does it support check mode. However, we’re off to a flying start. If you want to learn more about Ansible modules and fleshing out your functionality, you can find more details here: <a href="https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/developing_modules_general.xhtml</a>.</p>
<p>Note that when it comes to testing your module, creating arguments in a JSON file is hardly intuitive, although, as we have seen, it does work well. Luckily for us, it is easy to run our Ansible module in a playbook! By default, Ansible will check the playbook directory for a subdirectory called <code>library/</code> and will run referenced modules from here. Hence, we might create the following:</p>
<pre class="console">
$ cd ~
$ mkdir testplaybook
$ cd testplaybook
$ mkdir library
$ cp ~/ansible/moduledev/remote_filecopy.py library/</pre> <p>Now, create a simple<a id="_idIndexMarker392"/> inventory file in this playbook directory, just as we did <a id="_idIndexMarker393"/>previously, and add a playbook with the following contents:</p>
<pre class="source-code">
---
- name: Playbook to test custom module
  hosts: all
tasks:
- name: Test the custom module
  remote_filecopy:
    source: /tmp/foo
    dest: /tmp/bar
  register: testresult
- name: Print the test result data
  ansible.builtin.debug:
    var: testresult</pre> <p>For clarity, your final directory structure should look like this:</p>
<pre class="source-code">
testplaybook
├── hosts
├── library
│ └── remote_filecopy.py
└── testplaybook.yml</pre> <p>Now, try running <a id="_idIndexMarker394"/>the playbook in the usual manner and <a id="_idIndexMarker395"/>see what happens:</p>
<pre class="console">
$ ansible-playbook -i hosts testplaybook.yml
PLAY [Playbook to test custom module] ******************************************
TASK [Gathering Facts] *********************************************************
ok: [frt01.example.com]
ok: [app01.example.com]
TASK [Test the custom module] **************************************************
changed: [app01.example.com]
changed: [frt01.example.com]
TASK [Print the test result data] **********************************************
ok: [app01.example.com] =&gt; {
 "testresult": {
 "changed": true,
 "failed": false
 }
}
ok: [frt01.example.com] =&gt; {
 "testresult": {
 "changed": true,
 "failed": false
 }
}
PLAY RECAP *********************************************************************
app01.example.com : ok=3 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0
frt01.example.com : ok=3 changed=1 unreachable=0 failed=0 skipped=0 rescued=0 ignored=0</pre> <p>Success! Not <a id="_idIndexMarker396"/>only <a id="_idIndexMarker397"/>have you tested your Python code locally, but you have also successfully run it on two remote servers in an Ansible playbook. That was really easy, which proves just how straightforward it is to get started expanding your Ansible modules so that they meet your own bespoke needs.</p>
<p>Despite the success of running this piece of code, we’ve not checked the documentation yet, nor tested its operation from Ansible. Before we address these issues in more detail, in the next section, we’ll take a look at some of the common pitfalls<a id="_idTextAnchor297"/> <a id="_idTextAnchor298"/>of module development and how to avoid them.</p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor299"/>Avoiding common pitfalls</h2>
<p>Your <a id="_idIndexMarker398"/>modules must be well thought out and handle error conditions gracefully – people are going to rely on your module someday to automate a task on perhaps thousands of servers, so the last thing they want is to spend significant amounts of time debugging errors, especially trivial ones that could have been trapped or handled gracefully. In this section, we’ll look specifically at error handling and ways to do this so that playbooks will still run and exit gracefully.</p>
<p>One piece of overall guidance before we get started is that just like documentation receives a high degree of attention in Ansible, so should your error messages. They should be meaningful and easy to interpret, and you should steer clear of meaningless strings such as <code>Error!</code>.</p>
<p>So, right <a id="_idIndexMarker399"/>now, if we remove the source file that we’re attempting to copy and then rerun our module with the same arguments, I think you’ll agree that the output is neither pretty nor meaningful unless you happen to be a hardened Python developer:</p>
<pre class="console">
(moduledev) $ rm -f /tmp/foo
(moduledev) $ python3 remote_filecopy.py args.json
 Traceback (most recent call last):
  File "remote_filecopy.py", line 101, in &lt;module&gt;
    main()
    ^^^^^^
  File "remote_filecopy.py", line 94, in main
    shutil.copy(module.params['source'],
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/opt/homebrew/Cellar/python@3.11/3.11.4/Frameworks/Python.framework/Versions/3.11/lib/python3.11/shutil.py", line 419, in copy
    copyfile(src, dst, follow_symlinks=follow_symlinks)
  File "/opt/homebrew/Cellar/python@3.11/3.11.4/Frameworks/Python.framework/Versions/3.11/lib/python3.11/shutil.py", line 256, in copyfile
    with open(src, 'rb') as fsrc:
         ^^^^^^^^^^^^^^^
FileNotFoundError: [Errno 2] No such file or directory: '/tmp/foo'</pre> <p>We can, without<a id="_idIndexMarker400"/> a doubt, do better. Let’s make a copy of our module and add a little code to it. First of all, replace the <code>shutil.copy</code> lines of code with the following:</p>
<pre class="source-code">
try:
  shutil.copy(module.params['source'], module.params['dest'])
except:
  module.fail_json(msg="Failed to copy file")</pre> <p>This is some incredibly basic exception handling in Python, but what it does is allow the code to try the <code>shutil.copy</code> task. However, if this fails and an exception is raised, rather than exiting with a traceback, we exit cleanly using the <code>module.fail_json</code> call. This will tell Ansible that the module failed and cleanly send a JSON-formatted error message back. Naturally, we could do a lot to improve the error message; for example, we could obtain the exact error message from the <code>shutil</code> module and pass it back to Ansible, but again, this is left as an exercise for you to complete.</p>
<p>Now, when we try and run the module with a non-existent source file, we will see the following cleanly formatted JSON output:</p>
<pre class="console">
(moduledev) $ rm -f /tmp/foo
(moduledev) $ python3 better_remote_filecopy.py args.json
{"msg": "Failed to copy file", "failed": true, "invocation": {"module_args": {"dest": "/tmp/bar", "source": "/tmp/foo"}}}</pre> <p>However, the module still works in the same manner as before if the copy succeeds:</p>
<pre class="console">
(moduledev) $ touch /tmp/foo
(moduledev) $ python3 better_remote_filecopy.py args.json
{"invocation": {"module_args": {"dest": "/tmp/bar", "source": "/tmp/foo"}}, "changed": true}</pre> <p>With this simple <a id="_idIndexMarker401"/>change to our code, we can now cleanly and gracefully handle the failure of the file copy operation and report something more meaningful back to the user rather than using a traceback. Some additional pointers for exception handling and processing in your modules are as follows:</p>
<ul>
<li>Fail quickly – don’t attempt to keep processing after an error</li>
<li>Return the most meaningful possible error messages using the various module JSON return functions</li>
<li>Never return a traceback if there’s any way you can avoid it</li>
<li>Try making errors meaningful in the context of the module and what it does (for example, for our module, <code>File copy error</code> is more meaningful than <code>File error</code> – and I think you’ll easily come up with even better error messages)</li>
<li>Don’t bombard the user with errors; instead, try to focus on reporting the most meaningful ones, especially when your module code is complex</li>
</ul>
<p>That completes our brief yet practical look at error handling in Ansible modules. In the next section, we shall return to the documentation we included in our module, including how to build it into HTML documentation so that it can go on the Ansible website (and indeed, if your module gets accepted into the Ansible source code, this is exac<a id="_idTextAnchor300"/>t<a id="_idTextAnchor301"/>ly how the web documentation will be generated).</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor302"/>Testing and documenting your module</h2>
<p>We have already put a great deal of work into <a id="_idIndexMarker402"/>documenting our module, as we discussed earlier in this chapter. However, how can we see it, and how can we check that it compiles correctly into the HTML that would go on the Ansible website if it were accepted as part of the Ansible source code?</p>
<p>Before we get into actually viewing <a id="_idIndexMarker403"/>our documentation, we should make use of a tool called <code>ansible-test</code>, which <a id="_idIndexMarker404"/>was newly added in the 2.15 release. This tool can perform a sanity check on our module code to ensure that our documentation meets all the standards required by the Ansible project team and that the code is structured correctly (for example, the Python <code>import</code> statements should always come after the documentation blocks). Let’s get started:</p>
<ol>
<li>To run the sanity tests, assuming you have cloned the official repository, change into this directory and set up your environment. Note that if your standard Python binary isn’t Python 3, the <code>ansible-test</code> tool will not run, so you should ensure Python 3 is installed and, if necessary, set up a virtual environment to ensure you are using Python 3. This can be done as follows:<pre class="source-code">
<strong class="bold">$ cd ansible$ python 3 -m venv venv</strong>
<strong class="bold">$ . venv/bin/activate</strong>
<strong class="bold">(venv) $ source hacking/env-setup</strong>
<strong class="bold">running egg_info</strong>
<strong class="bold">creating lib/ansible.egg-info</strong>
<strong class="bold">writing lib/ansible.egg-info/PKG-INFO</strong>
<strong class="bold">writing dependency_links to lib/ansible.egg-info/dependency_links.txt</strong>
<strong class="bold">writing requirements to lib/ansible.egg-info/requires.txt</strong>
<strong class="bold">writing top-level names to lib/ansible.egg-info/top_level.txt</strong>
<strong class="bold">writing manifest file 'lib/ansible.egg-info/SOURCES.txt'</strong>
<strong class="bold">reading manifest file 'lib/ansible.egg-info/SOURCES.txt'</strong>
<strong class="bold">reading manifest template 'MANIFEST.in'</strong>
<strong class="bold">warning: no files found matching 'SYMLINK_CACHE.json'</strong>
<strong class="bold">writing manifest file 'lib/ansible.egg-info/SOURCES.txt'</strong>
<strong class="bold">Setting up Ansible to run out of checkout...</strong>
<strong class="bold">PATH=/home/james/ansible/bin:/home/james/ansible/venv/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/home/james/bin</strong>
<strong class="bold">PYTHONPATH=/home/james/ansible/lib</strong>
<strong class="bold">MANPATH=/home/james/ansible/docs/man:/usr/local/share/man:/usr/share/man</strong>
<strong class="bold">Remember, you may wish to specify your host file with -i</strong>
<code>pip</code> to install the<a id="_idIndexMarker405"/> Python requirements so that you can run the <code>ansible-test</code> tool:<pre class="source-code">
<strong class="bold">(venv) $ pip install -r test/runner/requirements/sanity.txt</strong></pre></li> <li>Now, provided you have copied your module code into the appropriate location in the source tree (an example copy command is shown here), you can run the sanity tests as follows:<pre class="source-code">
<strong class="bold">(venv) $ cp ~/moduledev/remote_filecopy.py ./lib/ansible/modules/files/</strong>
<strong class="bold">(venv) $ ansible-test sanity --test validate-modules remote_filecopy</strong>
<strong class="bold">Sanity check using validate-modules</strong>
<strong class="bold">WARNING: Cannot perform module comparison against the base branch. Base branch not detected when running locally.</strong>
<strong class="bold">WARNING: Reviewing previous 1 warning(s):</strong>
<strong class="bold">WARNING: Cannot perform module comparison against the base branch. Base branch not detected when running locally.</strong></pre></li> </ol>
<p>From the <a id="_idIndexMarker406"/>preceding output, you can see that apart from one warning related to us not having a base branch to compare against, the module code that we developed earlier in this chapter has passed all the tests. If you had an issue with the documentation (for example, the author’s name format was incorrect), this would be given as an error.</p>
<p>Now that we have passed the sanity checks with <code>ansible-test</code>, let’s see whether the documentation looks right by using the <code>ansible-doc</code> command. This is very easy to do. First of all, exit your virtual environment, if you are still in it, and change to the Ansible source code directory you cloned from GitHub earlier. Now, you can manually tell <code>ansible-doc</code> where to look for modules instead of the default path. This means that you could run the following:</p>
<pre class="console">
$ cd ~/ansible
$ ansible-doc -M moduledev/ remote_filecopy</pre> <p>You should be presented with the textual rendering of the documentation we created earlier – an example of the first page is shown here to give you an idea of how it should look:</p>
<pre class="console">
&gt; REMOTE_FILECOPY (/home/james/ansible/moduledev/remote_filecopy.py)
 The remote_copy module copies a file on the remote host from a
 given source to a provided destination.
 * This module is maintained by The Ansible Community
OPTIONS (= is mandatory):
= dest
 Path to the destination on the remote host for the copy
= source
 Path to a file on the source file on the remote host</pre> <p>Excellent! So, we <a id="_idIndexMarker407"/>can already access our module documentation using <code>ansible-doc</code> and indeed confirm that it renders correctly in text mode. However, how do we go about building the HTML version? Fortunately, there is a well-defined process for this, which we shall outline here:</p>
<ol>
<li>Under <code>lib/ansible/modules/</code>, you will find a series of categorized directories that modules are placed under – ours fits best under the <code>files</code> category, so copy it to this location in preparation for the build process to come:<pre class="source-code">
<code>docs/docsite/</code> directory as the next step in the documentation creation process:<pre class="source-code">
<strong class="bold">$ cd docs/docsite/</strong></pre></li> <li>Build a documentation-based Python file. Use the following command to do so:<pre class="source-code">
<strong class="bold">$ MODULES=hello_module make webdocs</strong></pre></li> </ol>
<p>Now, in theory, making the Ansible documentation should be this simple to get the <code>make webdocs</code> command to run at all.</p>
<p>Even in this <a id="_idIndexMarker408"/>environment, on CentOS 7, the <code>make webdocs</code> command fails unless you have some very specific Python 3 requirements in place. These are not well documented, but from testing, I can tell you that Sphinx v2.4.4 works. The version that’s supplied with CentOS 7 is too old and fails, while the newest version available from the Python module repositories is not compatible with the build process and fails.</p>
<p>Once I’d started working from the Ansible source tree, I had to make sure I had removed any preexisting <code>sphinx</code> modules from my Python 3 environment (you need Python 3.11 or above to build the documentation locally – if you don’t have this installed on your node, please do this before proceeding) and then ran the following commands:</p>
<pre class="console">
$ pip3 uninstall sphinx
$ pip3 install sphinx==2.4.4
$ pip3 install sphinx-notfound-page</pre> <p>With this in place, you will be able to successfully run <code>make webdocs</code> to build your documentation. You will see pages of output. A successful run should end with something like the output shown here:</p>
<pre class="console">
generating indices... genindex py-modindexdone
writing additional pages... search/home/james/ansible/docs/docsite/_themes/sphinx_rtd_theme/search.xhtml:21: RemovedInSphinx30Warning: To modify script_files in the theme is deprecated. Please insert a &lt;script&gt; tag directly in your theme instead.
  {% endblock %}
 opensearchdone
copying images... [100%] dev_guide/style_guide/images/thenvsthan.jpg
copying downloadable files... [ 50%] network/getting_started/sample_files/first_copying downloadable files... [100%] network/getting_started/sample_files/first_playbook_ext.yml
copying static files... ... done
copying extra files... done
dumping search index in English (code: en)... done
dumping object inventory... done
build succeeded, 35 warnings.
The HTML pages are in _build/html.
make[1]: Leaving directory `/home/james/ansible/docs/docsite'</pre> <p>Now, notice how, at the end of this process, the <code>make</code> command tells us where to look for the compiled documentation. If you look in here, you will find the following:</p>
<pre class="console">
$ find /home/james/ansible/docs/docsite -name remote_filecopy*
/home/james/ansible/docs/docsite/rst/modules/remote_filecopy_module.rst
/home/james/ansible/docs/docsite/_build/html/modules/remote_filecopy_module.xhtml
/home/james/ansible/docs/docsite/_build/doctrees/modules/remote_filecopy_module.doctree</pre> <p>Try opening <a id="_idIndexMarker409"/>the HTML file in your web browser – you should see that the page renders just like one of the documentation pages from the official Ansible project documentation! This enables you to check that your documentation builds correctly and looks and reads well in the context that it will be viewed. It also gives you confidence that, when you submit your code to the Ansible project (if you are doing so), you are submitting something consistent with Ansible’s documentation quality standards.</p>
<p>More information on building the documentation locally is provided here: <a href="https://docs.ansible.com/ansible/latest/community/documentation_contributions.xhtml#building-the-documentation-locally">https://docs.ansible.com/ansible/latest/community/documentation_contributions.xhtml#building-the-documentation-locally</a>.</p>
<p>The current process of building the documentation is a little fussy around the environments that are supported; however, hopefully, this is something that will be resolved in due <a id="_idIndexMarker410"/>course. In the meantime, the process outlined in this section<a id="_idTextAnchor303"/> <a id="_idTextAnchor304"/>has given you a tested and working process to start from.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor305"/>The module checklist</h2>
<p>In addition<a id="_idIndexMarker411"/> to the pointers and good practices that we have covered so far, there are a few more things you should adhere to in your module code to produce something that will be considered of a high standard for potential inclusion with Ansible. The following list is not exhaustive but will give you a good idea of the practices you should adhere to as a module developer:</p>
<ul>
<li>Test your modules as much as you can, both in cases that will succeed and in those that cause errors. You can test them using JSON data, as we did in this chapter, or make use of them within a test playbook.</li>
<li>Try and keep your Python requirements to a minimum. Sometimes, there is no way to avoid the need for additional Python dependencies (such as the <code>boto</code> requirements of the AWS-specific modules), but in general, the less you can use, the better.</li>
<li>Don’t cache data for your module – the execution strategies of Ansible across differing hosts mean you are unlikely to get good results from doing this. Expect to gather all of the data you need on each run.</li>
<li>Modules should be a single Python file – they shouldn’t be distributed across multiple files.</li>
<li>Make sure you investigate and run the Ansible integration tests when you are submitting your module code. More information on these is available here: <a href="https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.xhtml">https://docs.ansible.com/ansible/latest/dev_guide/testing_integration.xhtml</a>.</li>
<li>Make sure you include exception handling at the appropriate points in your module code, as we did in this chapter, to prevent issues.</li>
</ul>
<p>Armed with the information you’ve gained from this chapter, you should have everything you need to start creating modules. You may not decide to submit them to the Ansible project, and there is certainly no requirement to do so. However, even if you don’t, following the practices outlined in this chapter will ensure that you build a good-quality module, regardless of its<a id="_idIndexMarker412"/> intended audience. Finally, on the basis that you do want to submit your source code to the Ansible project, in the next section, we’ll look at h<a id="_idTextAnchor306"/>o<a id="_idTextAnchor307"/>w to do this through a pull request to the Ansible project.</p>
<h2 id="_idParaDest-89"><a id="_idTextAnchor308"/>Contributing upstream – submitting a GitHub pull request</h2>
<p>When you’ve<a id="_idIndexMarker413"/> worked hard on your module and thoroughly tested and documented it, you might feel that it is time to submit it to the Ansible <a id="_idIndexMarker414"/>project for inclusion. Doing this means creating a pull request on the official Ansible repository. Although the intricacies of working with GitHub are beyond the scope of this book, we will give you a practically focused outline of the basic procedures involved.</p>
<p class="callout-heading">Note</p>
<p class="callout">Following the process outlined here will generate a real request against the Ansible project on GitHub so that the code you are committing can be merged with their code. <em class="italic">Do not</em> follow this process unless you genuinely have a new module that is ready for submission to the Ansible code base.</p>
<p>To submit your module as a pull request of the Ansible repository, you need to fork the collection repository.</p>
<p>Now, we will walk through the commands you need to run to add your module code to it. Then, we’ll show you how to create the<a id="_idIndexMarker415"/> required <strong class="bold">pull requests</strong> (also known as <strong class="bold">PRs</strong>) so that you can merge your new module with the upstream Ansible project:</p>
<ol>
<li>Fork a collection repository that you want to create a PR for using GitHub (<a href="https://github.com/ansible-collections">https://github.com/ansible-collections</a>). For example, if you need to create a PR in the <code>community.mysql</code> collection, you need to select <strong class="bold">Fork</strong>:</li>
</ol>
<div><div><img alt="Figure 5.3 – The community.mysql collection" height="530" src="img/B20846_05_003.jpg" width="908"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The community.mysql collection</p>
<ol>
<li value="2">Clone<a id="_idIndexMarker416"/> the forked repository to your local <a id="_idIndexMarker417"/>machine. Use a command similar to the following, but be sure to replace the URL with the one that matches your own GitHub account:<pre class="source-code">
<code>https://github.com/YOUR_ACCOUNT/COLLECTION_REPO.git ~/YOUR_WORKING_DIRECTORY</code></pre></li> <li>Add the upstream repository after you go to your cloned repository:<pre class="source-code">
<strong class="bold">$ cd ~/ YOUR_WORKING_DIRECTORY</strong>
<code>https://github.com/ansible-collections/COLLECTION_REPO.git</code></pre></li> <li>Update your local branch:<pre class="source-code">
<strong class="bold">$ git fetch upstream</strong>
<strong class="bold">$ git rebase upstream/YOUR_BRANCH</strong></pre></li> <li>Create a branch for the PR:<pre class="source-code">
<strong class="bold">$ git checkout -b name_of_my_branch</strong></pre></li> <li>Change your code in the collection.</li>
<li>Submit your pull request:<pre class="source-code">
<code>http://github.com/ansible-collections/COLLECTION_REPO</code>). Then, select the <strong class="bold">Pull requests</strong> tab. Fill out the PR template with your changes. Then, select <strong class="bold">create a pull request</strong>. Note that<a id="_idIndexMarker418"/> if your PR looks good to the <a id="_idIndexMarker419"/>community, it will be merged:</li>
</ol>
<div><div><img alt="Figure 5.4 – The Pull requests tab" height="761" src="img/B20846_05_004.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The Pull requests tab</p>
<p>There are many more ways to contribute to the Ansible project other than creating pull requests for custom modules. Here are some examples of other ways you can contribute to the project:</p>
<ul>
<li>Review the Ansible documentation and report any bugs you find in it (one was filed in the creation of <a href="B20846_04.xhtml#_idTextAnchor207"><em class="italic">Chapter 4</em></a>, <em class="italic">Playbooks </em><em class="italic">and Roles</em>)</li>
<li>Create a local Ansible MeetUp to spread your knowledge about Ansible. If you are lucky enough to have one in your area already, consider attending it regularly.</li>
<li>Spread Ansible knowledge and awareness via social media with the appropriate account references and hashtags; for example, <code>@ansible</code>, <code>#ansible</code>, and so on.</li>
</ul>
<p>That completes <a id="_idIndexMarker420"/>our journey of learning how to create modules, from <a id="_idIndexMarker421"/>the very first steps of looking into the theory of module operation, all the way through to contributing your new module code to the official Ansible project on GitHub. We hope you have found this journey informative and valuable and that it enhances your abilit<a id="_idTextAnchor309"/>y<a id="_idTextAnchor310"/> to work with Ansible and extend its functionality where required.</p>
<h1 id="_idParaDest-90"><a id="_idTextAnchor311"/>Summary</h1>
<p>Modules are the very lifeblood of Ansible – without them, Ansible could not perform all of the complex and varied tasks it performs so well across a wide variety of systems. By being an open source project, it is incredibly easy to extend the functionality of Ansible by yourself, and in this chapter, we explored how you can, with a little Python knowledge, write a custom module from scratch. Ansible is, at the time of writing, incredibly feature-rich, but this ease of customization and extension makes Ansible virtually limitless in terms of its potential, especially given the power and popularity of Python as a programming language.</p>
<p>In this chapter, we started with a recap of how to execute multiple modules using the command line. We then explored the process of interrogating the current module index, as well as how to obtain documentation about modules to evaluate their suitability for our needs, regardless of whether we have an active internet connection or not. We then explored module data and its JSON format, before finally going on a journey through which we put together the code for a simple custom module. This provided you with a basis for creating modules in the future if you so desire.</p>
<p>In the next chapter, we will explore the process of<a id="_idTextAnchor312"/> <a id="_idTextAnchor313"/>using and creating another core Ansible feature, known as plugins.</p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor314"/>Questions</h1>
<p>Answer the following questions to test your knowledge of this chapter:</p>
<ol>
<li>Which command line can be passed down as a parameter to a module?<ol><li><code>ansible dbservers -m command "/bin/echo '</code><code>hello modules'"</code></li><li><code>ansible dbservers -m command -d "/bin/echo '</code><code>hello modules'"</code></li><li><code>ansible dbservers -z command -a "/bin/echo '</code><code>hello modules'"</code></li><li><code>ansible dbservers -m command -a "/bin/echo '</code><code>hello modules'"</code></li><li><code>ansible dbservers -a "/bin/echo '</code><code>hello modules'"</code></li></ol></li>
<li>Which of the following practices is not recommended when you create a custom module and address exceptions?<ol><li>Design a custom module simply and never provide a traceback to the user, if you can avoid it.</li><li>Fail your module code quickly, and verify that you are providing helpful and understandable exception messages.</li><li>Only display error messages for the most relevant exceptions, rather than all possible errors.</li><li>Ensure that your module documentation is relevant and easy to understand.</li><li>Delete playbooks that result in errors and then recreate them from scratch.</li></ol></li>
<li>True or false: To contribute to the Ansible upstream pr<a id="_idTextAnchor315"/>o<a id="_idTextAnchor316"/>ject, you need to submit your code to the <code>devel</code> branch.<ol><li>True</li><li>False</li></ol></li>
</ol>
<h1 id="_idParaDest-92"><a id="_idTextAnchor317"/>Further reading</h1>
<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul>
<li>Documentation regarding the common return values of modules in Ansible can be found here: <a href="https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.xhtml#common%0D">https://docs.ansible.com/ansible/latest/reference_appendices/common_return_values.xhtml#common</a></li>
<li>Check out the following documentation for all the existing modules on Windows machines that you can use: <a href="https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml">https://docs.ansible.com/ansible/latest/collections/ansible/windows/index.xhtml</a></li>
</ul>
</div>
</div></body></html>