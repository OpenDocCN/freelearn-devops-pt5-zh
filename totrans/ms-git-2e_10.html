<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-175"><a id="_idTextAnchor196" class="pcalibre1 pcalibre calibre6"/>8</h1>
<h1 id="_idParaDest-176" class="calibre5"><a id="_idTextAnchor197" class="pcalibre1 pcalibre calibre6"/>Advanced Branching Techniques</h1>
<p class="calibre3"><a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>, described how to arrange teamwork while focusing on repository-level interactions. In that chapter, you learned about various centralized and distributed workflows, as well as their advantages and disadvantages.</p>
<p class="calibre3">This chapter will dive deeper into the details of collaboration in distributed development. We’ll explore the relationships between local branches and branches in remote repositories. Then, we’ll introduce the concept of remote-tracking branches, branch tracking, and upstream. This chapter will also teach us how to specify the synchronization of branches between repositories by using <em class="italic">refspecs</em> and <em class="italic">push modes</em>.</p>
<p class="calibre3">You will also learn branching techniques: how branches can be used to create new features, prepare new releases, and fix bugs. You will learn about the advantages and disadvantages of different branching patterns. Among other things, this chapter will show you how to use branches so that it would be easy for you to select which features will go into the next version of the project.</p>
<p class="calibre3">In this chapter, we will cover the following topics:</p>
<ul class="calibre16">
<li class="calibre15">Different kinds of branches, both long-lived and short-lived, and their purpose</li>
<li class="calibre15">Various branching patterns, and how they can be composed into workflows</li>
<li class="calibre15">Release engineering for different branching models</li>
<li class="calibre15">Using branches to fix a security issue in more than one released version</li>
<li class="calibre15">Remote-tracking branches and refspecs</li>
<li class="calibre15">Rules for fetching and pushing branches and tags</li>
<li class="calibre15">Selecting a push mode to fit the chosen collaboration workflow</li>
</ul>
<h1 id="_idParaDest-177" class="calibre5"><a id="_idTextAnchor198" class="pcalibre1 pcalibre calibre6"/>The purpose of branching</h1>
<p class="calibre3">A <strong class="bold">branch</strong> in a version control <a id="_idIndexMarker582" class="pcalibre1 pcalibre calibre6"/>system is an active parallel line of development (also called a <strong class="bold">codeline</strong>). They are used to isolate, separate, and gather different types of work. For <a id="_idIndexMarker583" class="pcalibre1 pcalibre calibre6"/>example, branches <a id="_idIndexMarker584" class="pcalibre1 pcalibre calibre6"/>can be used to prevent your current unfinished work on a feature in progress from interfering with the management of bug fixes (isolation), or to gather fixes for an older version of the developed software (gathering and integration).</p>
<p class="calibre3">A single Git repository can have<a id="_idIndexMarker585" class="pcalibre1 pcalibre calibre6"/> an arbitrarily large number of branches. Moreover, with a distributed version control system, such as Git, there could be many repositories for a <a id="_idIndexMarker586" class="pcalibre1 pcalibre calibre6"/>single project (known as <strong class="bold">forks</strong> or <strong class="bold">clones</strong>), some public and some private; each<a id="_idIndexMarker587" class="pcalibre1 pcalibre calibre6"/> such repository will have<a id="_idIndexMarker588" class="pcalibre1 pcalibre calibre6"/> their own local branches. This can be considered <strong class="bold">source branching</strong>. Each developer <a id="_idIndexMarker589" class="pcalibre1 pcalibre calibre6"/>would have at least one private clone of the project’s public repository to work in.</p>
<p class="callout-heading">A bit of history – a note on the evolution of branch management</p>
<p class="callout">Early distributed version control <a id="_idIndexMarker590" class="pcalibre1 pcalibre calibre6"/>systems used one branch per repository model. Both <em class="italic">Bazaar</em> (then Bazaar-NG) and <em class="italic">Mercurial documentation</em>, at the time when they began their existence, recommended cloning the repository to create a new branch.</p>
<p class="callout">Git, on the other hand, had good support for multiple branches in a single repository almost from the start. However, in the beginning, it was assumed that there would be one central multibranch repository interacting with many single-branch repositories (see, for example, the legacy <strong class="source-inline1">.git/branches</strong> directory, which was used to specify URLs and fetch branches, as described in the <strong class="source-inline1">gitrepository-layout(7)</strong> man page), though with Git it was more about defaults than capabilities.</p>
<p class="callout">Because branching is cheap in Git (and merging is easy), and collaboration is quite flexible, people started using branches more and more, even for solitary work. This led to the wide use of the extremely useful<a id="_idIndexMarker591" class="pcalibre1 pcalibre calibre6"/> topic branch workflow (also known as feature branching).</p>
<h2 id="_idParaDest-178" class="calibre7"><a id="_idTextAnchor199" class="pcalibre1 pcalibre calibre6"/>Isolation versus integration</h2>
<p class="calibre3">Version control systems such as Git allow different people to work on the same code base without interfering with each<a id="_idIndexMarker592" class="pcalibre1 pcalibre calibre6"/> other. They also makes it easy to switch between different types of work. But this separated work would then need to be merged <a id="_idIndexMarker593" class="pcalibre1 pcalibre calibre6"/>back together into some integration target to be useful and to be later included in a release.</p>
<p class="calibre3">We need <em class="italic">isolation</em>, but we also need to <em class="italic">integrate</em> changes, combining work into a coherent whole. To avoid conflicts as best as possible, our changes need to be visible to others, or even better be integrated. For example, if we change a calling convention of some API, but our work remains isolated, others cannot easily adjust to those changes. They would use the old version of the API in their work – leading to merge conflicts and a more difficult integration in the future. So, from this point of view, earlier and more <em class="italic">frequent integration</em> is something to be desired.</p>
<p class="calibre3">However, some features are more involved, and their development consists of many steps. The goal of frequent integration conflicts with the need to <em class="italic">isolate unfinished work</em>, and to prevent such work from being visible. If we want frequent integration, we need to be able to handle such issues.</p>
<h2 id="_idParaDest-179" class="calibre7"><a id="_idTextAnchor200" class="pcalibre1 pcalibre calibre6"/>The path to production release</h2>
<p class="calibre3">The main goal of <a id="_idIndexMarker594" class="pcalibre1 pcalibre calibre6"/>software development is to deploy code into production, to create a usable release of the project, and to have something to be used. A proper branching technique helps us achieve a stable base for creating such a release.</p>
<p class="calibre3">What branching pattern to use depends on the particularities of the project. For example, the team may need to isolate a work in progress from a stable base. There can also be more or less friction in the release process. Additionally, you might need to manage multiple versions of releases, or multiple versions of the project in production.</p>
<p class="calibre3">There are specific branching patterns to help you handle such issues.</p>
<h2 id="_idParaDest-180" class="calibre7"><a id="_idTextAnchor201" class="pcalibre1 pcalibre calibre6"/>Long-running and short-lived branches</h2>
<p class="calibre3">Branches whose main purpose is to gather and integrate changes need to be long-lived, or even permanent. They are intended to last indefinitely, or at least for a very long time; they are rarely deleted.</p>
<p class="calibre3">From a collaboration<a id="_idIndexMarker595" class="pcalibre1 pcalibre calibre6"/> point of view, a <strong class="bold">long-lived branch</strong> can be expected to be there when you are next<a id="_idIndexMarker596" class="pcalibre1 pcalibre calibre6"/> updating data or publishing changes. This means that you can <a id="_idIndexMarker597" class="pcalibre1 pcalibre calibre6"/>safely start work by forking off any of the long-lived branches in the remote repository, and be assured that there should be no problems with integrating that work. This means that at least one such branch must exist. Branches that people usually base their work on, that<a id="_idIndexMarker598" class="pcalibre1 pcalibre calibre6"/> define the <em class="italic">current version</em> of the project, are sometimes called <strong class="bold">mainlines</strong>.</p>
<p class="calibre3">While long-lived branches stay forever, <strong class="bold">short-lived</strong> or <strong class="bold">temporary branches</strong> are created to deal with single issues, and are<a id="_idIndexMarker599" class="pcalibre1 pcalibre calibre6"/> usually removed (deleted) after dealing with said issue (after the branch is merged or the feature is dropped). They are intended to last only as long as the issue is present. Their purpose is time-limited.</p>
<p class="calibre3">Having a separate branch for a separate issue helps us isolate and gather subsequent steps in the process of resolving a problem, whether it’s adding a new feature or creating an urgent bug fix. Those branches are usually named after their topic.</p>
<h2 id="_idParaDest-181" class="calibre7"><a id="_idTextAnchor202" class="pcalibre1 pcalibre calibre6"/>Visibility of branches</h2>
<p class="calibre3">What you can find in <em class="italic">public repositories</em> are usually only <em class="italic">long-lived branches</em>. In most cases, these branches should <a id="_idIndexMarker600" class="pcalibre1 pcalibre calibre6"/>never rewind (the <a id="_idIndexMarker601" class="pcalibre1 pcalibre calibre6"/>new version is always a descendant of the old versions). This makes it possible for you to safely build your work on top of the public branch.</p>
<p class="calibre3">There are some special cases here, though; there can be branches that are rebuilt after each new release (requiring forced fetch at that time), and there can be branches that do not fast forward. Each such case should be explicitly mentioned in the developer documentation to help you avoid unpleasant surprises.</p>
<p class="calibre3">Because of their provisional <a id="_idIndexMarker602" class="pcalibre1 pcalibre calibre6"/>nature, <em class="italic">short-lived branches</em> are usually only present in the <em class="italic">local private repository</em> of a developer or integration manager (maintainer), and are not pushed to public distribution repositories. If they appear in public repositories, they are often only present in a public repository of an individual contributor as a target for a pull request (see the blessed repository workflow in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development </em><em class="italic">with Git</em>).</p>
<h2 id="_idParaDest-182" class="calibre7"><a id="_idTextAnchor203" class="pcalibre1 pcalibre calibre6"/>Alternatives to branching</h2>
<p class="calibre3">With frequent integration, potential conflicts are discovered early. However, some features take longer to develop, and they <a id="_idIndexMarker603" class="pcalibre1 pcalibre calibre6"/>are simply not ready when the time comes to push them to the mainline. But teams don’t want to expose half-developed features. With a branching workflow geared toward integration rather than isolation, there is often a need for some kind of mechanism to hide unfinished work.</p>
<p class="calibre3">One technique is to build backend code first, and only create the user interface for it when it is ready, like a keystone. On the other hand, changing the existing code can be done by creating a temporary abstraction layer, which would then allow you to switch the underlying implementation to the new one when it is ready.</p>
<p class="calibre3">Another useful method is to hide different <a id="_idIndexMarker604" class="pcalibre1 pcalibre calibre6"/>unfinished implementations behind <strong class="bold">feature switches</strong> or <strong class="bold">feature toggles</strong>. This technique is useful outside providing <a id="_idIndexMarker605" class="pcalibre1 pcalibre calibre6"/>separation for integrated but unfinished features. For example, with runtime feature toggles, you can compare two different algorithms on live production data, or you can perform A/B tests.</p>
<h2 id="_idParaDest-183" class="calibre7"><a id="_idTextAnchor204" class="pcalibre1 pcalibre calibre6"/>Visibility without integration</h2>
<p class="calibre3">An alternative to frequent integration into the mainline could be to use outside channels. It can be done by creating a <code>proposed-updates</code> type of branch, which would be used to merge all feature <a id="_idIndexMarker606" class="pcalibre1 pcalibre calibre6"/>branches. This improves the visibility of changes and provides a place to test branch integrations.</p>
<p class="calibre3">Tools and services such as <em class="italic">GitLive</em> (available as a VS Code extension and as a JetBrains IDE plugin) exist that can show who is working on which branch, on which issue, and even show working copy local changes of teammates.</p>
<h1 id="_idParaDest-184" class="calibre5"><a id="_idTextAnchor205" class="pcalibre1 pcalibre calibre6"/>Branching patterns</h1>
<p class="calibre3">In many cases, the choice of branching pattern (of the branching technique) depends on how stable the branch is, or in other words how healthy it is. A <strong class="bold">stable branch</strong>, or a <strong class="bold">healthy branch</strong> is a branch in such a state<a id="_idIndexMarker607" class="pcalibre1 pcalibre calibre6"/> that the current tip commit on that branch always builds <a id="_idIndexMarker608" class="pcalibre1 pcalibre calibre6"/>and deploys successfully, and the software runs with zero or at most a few bugs.</p>
<p class="calibre3">Ensuring that a branch is healthy pretty much requires doing daily builds and having a comprehensive suite of automated tests that are run frequently – if not at each commit, then at least at each integration (merge). However, explaining how to do this is outside the scope of this book.</p>
<h2 id="_idParaDest-185" class="calibre7"><a id="_idTextAnchor206" class="pcalibre1 pcalibre calibre6"/>Integration patterns</h2>
<p class="calibre3">Deciding what branching strategy to use to<a id="_idIndexMarker609" class="pcalibre1 pcalibre calibre6"/> integrate individual changes into a coherent and healthy mainline depends on various factors. Techniques that tend toward frequent integration, such as continuous integration, require the branch being merged into to be healthy. This requires a disciplined team, where each developer can make sure that each change is well-tested and does not break the developed <a id="_idIndexMarker610" class="pcalibre1 pcalibre calibre6"/>application.</p>
<p class="calibre3">On the other hand, if it isn’t certain that the feature being developed is of a good enough quality, and we want it assessed as a unit only after it is finished, then integrating less frequently might make more sense. Requiring pre-integration code reviews also drives you toward specific branching patterns.</p>
<h3 class="calibre9">Mainline integration</h3>
<p class="calibre3">The simplest possible branching strategy is<a id="_idIndexMarker611" class="pcalibre1 pcalibre calibre6"/> to work directly out of<a id="_idIndexMarker612" class="pcalibre1 pcalibre calibre6"/> the mainline (the <strong class="bold">trunk</strong>) and merge your changes (commits) directly into it. In this workflow, the developer starts from the mainline and creates their work on top of it.</p>
<p class="calibre3">This strategy is called <strong class="bold">mainline integration</strong> or <strong class="bold">trunk-based development</strong> (the name depends on how the <a id="_idIndexMarker613" class="pcalibre1 pcalibre calibre6"/>main branch is called).</p>
<p class="calibre3">After the developer reaches a point <a id="_idIndexMarker614" class="pcalibre1 pcalibre calibre6"/>where they want to integrate, they start by fetching the current state of the mainline. If other developers published their changes when they were working on the<a id="_idIndexMarker615" class="pcalibre1 pcalibre calibre6"/> project, they would need to combine those changes, using either a merge or a rebase operation – see <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em> for more detail. Then, they verify that the code is healthy and push integrated changes into the mainline.</p>
<h3 class="calibre9">Topic branches-based development</h3>
<p class="calibre3">In the <strong class="bold">topic branching</strong> pattern (also called <strong class="bold">feature branching</strong>), the idea is to make a new separate branch for each<a id="_idIndexMarker616" class="pcalibre1 pcalibre calibre6"/> topic. This might be creating a new feature or a bug fix. This type of branch intends to gather <a id="_idIndexMarker617" class="pcalibre1 pcalibre calibre6"/>subsequent development steps of a feature (where each step – a commit – should be a self-contained piece, easy to review), and to isolate the work on one <a id="_idIndexMarker618" class="pcalibre1 pcalibre calibre6"/>feature from work on other topics. Using a feature branch allows topical changes to be kept together, and not mixed with other commits. It also makes it possible for a whole topic to be dropped (or reverted) as a unit, be reviewed as a unit, and be accepted (integrated) as a unit.</p>
<p class="calibre3">The end goal for the commits on a topic branch is to have them included in a released version of a product. This means that, ultimately, the short-lived topic branch is to be merged into the long-lived branch, which is gathering stable work, and must be deleted.</p>
<p class="calibre3">To make it easier to integrate topic branches, the recommended practice is to create such branches by forking off the oldest, most stable integration branch that you will eventually merge into. Usually, this means creating a branch, starting from the stable-work graduation branch. However, if a given feature does depend on a topic not yet in the stable line, you need to fork off the appropriate topic branch containing the dependency you need.</p>
<p class="calibre3">Note that if it turns out that you forked off the wrong branch, you can always fix it by rebasing (see <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>, and <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>), because topic<a id="_idIndexMarker619" class="pcalibre1 pcalibre calibre6"/> branches are not public.</p>
<h3 class="calibre9">Continuous integration</h3>
<p class="calibre3">When using the mainline integration pattern, integrations are as frequent as possible: after each commit. Feature branching implies a lower bound to the period of integrations – you<a id="_idIndexMarker620" class="pcalibre1 pcalibre calibre6"/> integrate fully developed cohesive features.</p>
<p class="calibre3">With the <strong class="bold">continuous integration pattern</strong> (which is also called <strong class="bold">scaled trunk-based development</strong>), you try to integrate<a id="_idIndexMarker621" class="pcalibre1 pcalibre calibre6"/> as frequently as possible – that is, whenever you have made a worthwhile number of changes and the branch is still healthy. The work is <a id="_idIndexMarker622" class="pcalibre1 pcalibre calibre6"/>best done with short-lived feature branches, just integrated more frequently. The recommended practice is to integrate at least daily, with the feature branch living a few days at most.</p>
<p class="calibre3">When using this pattern, you need to be able to deal with a partially built feature. If mainline code runs in production (continuous delivery), you need to consider how to avoid exposing such unfinished features in the running code. This was described in the <em class="italic">Alternatives to </em><em class="italic">branching</em> section.</p>
<h2 id="_idParaDest-186" class="calibre7"><a id="_idTextAnchor207" class="pcalibre1 pcalibre calibre6"/>Release engineering</h2>
<p class="calibre3">If the mainline is kept healthy enough and is in an always-releasable state (following the tenets of continuous delivery), you can mark revision for release simply by creating a Git tag from the current tip. This simple<a id="_idIndexMarker623" class="pcalibre1 pcalibre calibre6"/> branching pattern is<a id="_idIndexMarker624" class="pcalibre1 pcalibre calibre6"/> called the <strong class="bold">release-ready mainline</strong>.</p>
<p class="calibre3">But if this is not the case, or if you <a id="_idIndexMarker625" class="pcalibre1 pcalibre calibre6"/>need to manage more than one version of the product, more complex branching patterns are needed. In that case, specialized branches are required on the path from the integration branch to the production release.</p>
<h3 class="calibre9">Progressive-stability branches</h3>
<p class="calibre3">One possible solution to the problem of ongoing<a id="_idIndexMarker626" class="pcalibre1 pcalibre calibre6"/> development not being stable enough to be always ready for the release (temporarily including some unstable code), is to put less mature and more mature code in separate <code>maint</code>, to <code>master</code>, to <code>next</code>:</p>
<div><div><img alt="Figure 8.1 – A linear view and a “silo” view of the maturity branches (also called progressive-stability branches)" src="img/B21194_08_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.1 – A linear view and a “silo” view of the maturity branches (also called progressive-stability branches)</p>
<p class="calibre3">These branches form a hierarchy with a decreasing level of <strong class="bold">graduation</strong> or <strong class="bold">stability</strong> of work, as shown in <em class="italic">Figure 8</em><em class="italic">.1</em>. In the linear view (top of the figure), the stable revisions are further down the line in your commit history, and the cutting-edge unstable work is further up the history. Alternatively, we can think of branches as work silos (bottom of the figure), where work goes depending on the stability (graduation) of changes. Note that, in real development, progressive-stability branches would not keep being this simple. There would be new revisions on the branches after the forking points. Nevertheless, the overall shape will be the same, even in the presence of merging.</p>
<p class="calibre3">Here and in the following figures, the chosen commit names (C1, C2, C3, and so on) are only to distinguish commits, and in some cases also to make it easy to see which commit corresponds to another.</p>
<p class="calibre3">With maturation branches, the <a id="_idIndexMarker629" class="pcalibre1 pcalibre calibre6"/>rule is to always merge more stable branches into less<a id="_idIndexMarker630" class="pcalibre1 pcalibre calibre6"/> stable ones – that is, <strong class="bold">merge upwards</strong>. This would preserve the overall shape of branch silos (see <em class="italic">Figure 8</em><em class="italic">.3</em> in the <em class="italic">Graduation or progressive-stability branches workflow</em> section of this chapter). This is because merging means including all the changes from the merged branch.</p>
<p class="calibre3">Therefore, merging a less stable branch into a more stable one would bring unstable work to the stable branch, violating the purpose and the contract of a stable branch.</p>
<p class="calibre3">Often, we see the graduation branches of the following levels of stability:</p>
<ul class="calibre16">
<li class="calibre15">The <strong class="source-inline1">maint</strong>, <strong class="source-inline1">maintenance</strong>, or <strong class="source-inline1">fixes</strong> branch only contains bug fixes to the last major release; minor releases are done with the help of this branch.</li>
<li class="calibre15">The <strong class="source-inline1">main</strong>, <strong class="source-inline1">master</strong>, <strong class="source-inline1">trunk</strong>, or <strong class="source-inline1">stable</strong> branch, with the development intended for the next major release; the tip of this branch should always be in the production-ready state.</li>
<li class="calibre15">The <strong class="source-inline1">next</strong> <strong class="source-inline1">devel</strong>, <strong class="source-inline1">development</strong>, <strong class="source-inline1">unstable</strong> branch, where the new development goes to test whether it is ready for the next release; the tip can be used for nightly builds.</li>
<li class="calibre15">The <strong class="source-inline1">pu</strong> or <strong class="source-inline1">proposed</strong> branch for the proposed updates. This is the integration testing branch and is meant for checking compatibility between different new features.</li>
</ul>
<p class="calibre3">Having multiple long-running branches is not necessary, but it’s often helpful, especially in very large or complex projects. Often, in operations, each level of stability corresponds to its own platform or deployment environment.</p>
<p class="calibre3">You don’t need to – and probably shouldn’t – use every type of branch listed here. Pick only what is needed for your project.</p>
<h3 class="calibre9">Per-release branches and per-release maintenance</h3>
<p class="calibre3">Preparing for the new release of a project can be a lengthy and involved process. <strong class="bold">Per-release branches</strong> can help with this. The<a id="_idIndexMarker631" class="pcalibre1 pcalibre calibre6"/> release branch is meant to separate the ongoing development from<a id="_idIndexMarker632" class="pcalibre1 pcalibre calibre6"/> preparing for the new release. It allows other developers to continue working on writing new features and on integration testing, while the quality <a id="_idIndexMarker633" class="pcalibre1 pcalibre calibre6"/>assurance team, with the help of the release manager, takes time to test and stabilize the release candidate.</p>
<p class="calibre3">After creating a new release, keeping such per-release branches allows us to support and maintain older released versions of the software. At these times, such branches work as a place to gather bug fixes (for their software versions) and create minor releases.</p>
<p class="calibre3">Not all projects need to utilize per-release branches. You can prepare a new release on the stable-work graduation branch, or use a separate repository in place of using a separate branch. Also, not all projects must provide support for more than the latest version.</p>
<p class="calibre3">This type of branch is often named after the release it is intended for – for example, <code>release-v1.4</code>. It is better not to give the branch the same name that the tag has for the release.</p>
<h3 class="calibre9">Release train with feature-freeze</h3>
<p class="calibre3">If your project is doing releases on a regular cadence (such as every 2 weeks or every 6 months), and the release process is<a id="_idIndexMarker634" class="pcalibre1 pcalibre calibre6"/> complex and involved (for example, there is external testing or a verification process), then it might be beneficial to use a release train branching pattern. It can be considered a variant of the per-release branch pattern. It is depicted in <em class="italic">Figure 8</em><em class="italic">.2</em>:</p>
<div><div><img alt="Figure 8.2 – Release train branching pattern for monthly releases, with the May “train” tagged and released into production and the June “train” in a state just after a feature freeze" src="img/B21194_08_02.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Release train branching pattern for monthly releases, with the May “train” tagged and released into production and the June “train” in a state just after a feature freeze</p>
<p class="calibre3">In this approach, each per-release branch is coupled with a feature-freeze date (in advance of the planned<a id="_idIndexMarker635" class="pcalibre1 pcalibre calibre6"/> release date). A new branch for the new release is created no later than the feature-freeze date for the previous release. After the feature freeze, an integration branch turns into a release branch, accepting only bug fixes and changes that prepare the project for release. This approach is often used with feature branching.</p>
<p class="calibre3">If there’s more than one per-release branch active and accepting features, the developer can estimate how long would it take to finish the new feature and push it to the “train” corresponding to the later date (loading future trains). Earlier departing “trains” can be regularly merged into later departing ones.</p>
<p class="calibre3">This pattern can be transitioned into the continuous delivery pattern (production-ready mainline) by increasing the frequency of “trains” and reducing friction in the release process.</p>
<h3 class="calibre9">Hotfix branches for security fixes</h3>
<p class="calibre3"><strong class="bold">Hotfix branches</strong> are like release branches but for unplanned releases. Their purpose is to act upon the undesired state of a live <a id="_idIndexMarker636" class="pcalibre1 pcalibre calibre6"/>production or a widely <a id="_idIndexMarker637" class="pcalibre1 pcalibre calibre6"/>deployed version, usually to resolve some critical bug in production (usually a severe security bug). This type of branch can be considered a longer-lived equivalent of the bugfix topic branches (see the <em class="italic">Bugfix branches</em> section of this chapter).</p>
<h2 id="_idParaDest-187" class="calibre7"><a id="_idTextAnchor208" class="pcalibre1 pcalibre calibre6"/>Other branching patterns involving long-lived branches</h2>
<p class="calibre3">The main purpose of the different types branches is to isolate <a id="_idIndexMarker638" class="pcalibre1 pcalibre calibre6"/>and/or integrate lines of development. However, branching patterns exist that do not fit around the themes of team integration or the path to production (to release).</p>
<h3 class="calibre9">Per-customer or per-deployment branches</h3>
<p class="calibre3">Let’s say that some of your project’s <a id="_idIndexMarker639" class="pcalibre1 pcalibre calibre6"/>customers require a few customization tweaks since they do things differently, or perhaps some deployment sites have special requirements. Suppose that these customizations cannot be done by simply changing the configuration. In this case, you would need to create separate lines of development for these customers or customizations.</p>
<p class="calibre3">But you don’t want these lines of development to remain separate. You expect that there will be changes that apply to all of them. One solution is to use one branch for each customization set, per customer, or per deployment. Another would be to use separate repositories. Both solutions help maintain parallel lines of development and transfer changes from one line to another.</p>
<p class="calibre3">Such environment branches can be considered an <em class="italic">anti-pattern</em>. With this approach, it is very easy to introduce changes that lead to different behavior in production and on the developer’s workstation, or end with having to maintain wildly divergent products for each customer.</p>
<h3 class="calibre9">Automation branches</h3>
<p class="calibre3">Say that you are working on a web application, and you want to automate its deployment using a version control system. One <a id="_idIndexMarker640" class="pcalibre1 pcalibre calibre6"/>solution would be to set up a daemon to watch a specific branch (for example, the one named <code>deploy</code>) for changes. Updating this branch would automatically update and reload the application.</p>
<p class="calibre3">This is, of course, not the only possible solution. Another possibility would be to use a separate <code>deploy</code> repository and set up hooks there, so pushing would cause the web application to refresh. Alternatively, you could configure a hook in a public repository so that pushing to a specific branch triggers redeployment (this mechanism will be described in <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>, <em class="italic">Git Administration</em>).</p>
<p class="calibre3">These techniques can also be<a id="_idIndexMarker641" class="pcalibre1 pcalibre calibre6"/> used for continuous integration; instead of deploying the application, pushing it into a specific branch would cause the test suite to run (the trigger could create a new commit on this branch or merge it).</p>
<h3 class="calibre9">Mob branches for anonymous push access</h3>
<p class="calibre3">Having a branch in a remote repository (on a server) with special treatment on push is a technique that has many uses, including <a id="_idIndexMarker642" class="pcalibre1 pcalibre calibre6"/>helping to collaborate. It can be used to enable <em class="italic">controlled anonymous push access</em> for a project.</p>
<p class="calibre3">Let’s assume that you want to allow random contributors to push into the central repository. However, you would want to do this in a managed way: one solution is to create a special <code>mob</code> branch or a <code>mob/*</code> namespace (set of branches) with relaxed access control.</p>
<p class="calibre3">You’ll learn how to set this up in <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>, <em class="italic">Git Administration</em>.</p>
<h3 class="calibre9">The orphan branch trick</h3>
<p class="calibre3">The different types of branches described up to this point differed in their purpose and management. However, from a<a id="_idIndexMarker643" class="pcalibre1 pcalibre calibre6"/> technical point of view (that is, from the point of view of the graph of commits), they all look the same. This is not the case with the so-called orphan branches.</p>
<p class="calibre3">An <strong class="bold">orphan branch</strong> is a parallel disconnected (orphaned) line of development that shares no revisions with the main history of <a id="_idIndexMarker644" class="pcalibre1 pcalibre calibre6"/>a project. It is a reference to a disjoint subgraph in the DAG of revisions, without any intersection with the main DAG graph. In most cases, their checkout is also composed of different files.</p>
<p class="calibre3">Such branches are sometimes used as a trick to store tangentially related contents in a single repository, instead of using separate repositories. (When using separate  repositories to store related content, you might want to use some naming convention to denote this fact – for example, a common prefix.) They can be used to do the following:</p>
<ul class="calibre16">
<li class="calibre15">Store the project’s web page files. For example, GitHub uses a branch named <strong class="source-inline1">gh-pages</strong> for the project’s pages.</li>
<li class="calibre15">Store generated files when the process of creating them requires some nonstandard toolchain. For example, the project documentation can be stored in the <strong class="source-inline1">html</strong>, <strong class="source-inline1">man</strong>, and <strong class="source-inline1">pdf</strong> orphan branches (the <strong class="source-inline1">html</strong> branch can be also used to deploy the<a id="_idIndexMarker645" class="pcalibre1 pcalibre calibre6"/> documentation). This way, the user can get specific format of the documentation without needing to install the toolchain required to generate it.</li>
<li class="calibre15">Store the project TODO notes (for example, in the <strong class="source-inline1">todo</strong> branch), perhaps together with storing there some specialized maintainer tools (scripts).</li>
<li class="calibre15">Have deployment configuration for GitOps in the same repository as the source code, instead of having two separate repositories – one for code and one for deployment configuration.</li>
</ul>
<p class="calibre3">You can create such a branch with <code>git checkout --orphan &lt;new branch&gt;</code> or by pushing into (or fetching into) a specific branch from a separate repository, as follows:</p>
<pre class="console">
$ git fetch repo-htmldocs master:html</pre>
<p class="calibre3">This command fetches the <code>master</code> branch from the unrelated <code>repo-htmldocs</code> repository into the unconnected <code>html</code> “orphan” branch.</p>
<p class="callout-heading">Trivia</p>
<p class="callout">Creating an orphan branch with <strong class="source-inline1">git checkout --orphan</strong> does not technically create a branch – that is, it does not make a new branch reference. What it does is point the symbolic <strong class="source-inline1">HEAD</strong> reference to an unborn branch. The reference is created after the first commit on a new orphan branch. That’s why there is no option to create an orphan branch with the <strong class="source-inline1">git </strong><strong class="source-inline1">branch</strong> command.</p>
<h2 id="_idParaDest-188" class="calibre7"><a id="_idTextAnchor209" class="pcalibre1 pcalibre calibre6"/>Other types of short-lived branches</h2>
<p class="calibre3">While long-lived branches stay forever, short-lived or temporary branches are created to deal with single issues, and are <a id="_idIndexMarker646" class="pcalibre1 pcalibre calibre6"/>usually removed after dealing with said issue. They are intended to last only as long as the issue is present.</p>
<p class="calibre3">Because of their provisional<a id="_idIndexMarker647" class="pcalibre1 pcalibre calibre6"/> nature, they are usually only present in the local private repository of a developer or integration manager (maintainer), and are not pushed to public distribution repositories. If they appear in public repositories, they are there only in a public repository of an individual contributor (see the blessed repository workflow in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>), as a target for a pull request.</p>
<h3 class="calibre9">Bugfix branches</h3>
<p class="calibre3">We can distinguish a special case of a topic branch whose purpose is fixing a bug. Such a branch should be created starting from the oldest integration branch it applies to (the most stable branch that contains the bug). This usually means forking off the maintenance branch or the<a id="_idIndexMarker648" class="pcalibre1 pcalibre calibre6"/> divergence point of all the integration branches rather than the tip of the stable branch. A bugfix branch’s goal is to be merged into relevant long-lived integration branches.</p>
<p class="calibre3">Bugfix branches can be thought of as a short-lived equivalent of a long-lived hotfix branch. Using them is a better alternative to simply committing fixes on the maintenance branch (or another appropriate integration branch).</p>
<h3 class="calibre9">Detached HEAD – the anonymous branch</h3>
<p class="calibre3">You can think<a id="_idIndexMarker649" class="pcalibre1 pcalibre calibre6"/> of the <strong class="bold">detached HEAD</strong> state (described in <a href="B21194_02.xhtml#_idTextAnchor028" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 2</em></a>, <em class="italic">Developing with Git</em>) as the ultimate<a id="_idIndexMarker650" class="pcalibre1 pcalibre calibre6"/> in temporary branches – so temporary that it even doesn’t have a name. Git uses such anonymous branches automatically in a few situations, such as during bisection and rebasing.</p>
<p class="calibre3">Because, in Git, there is only one anonymous branch and it must always be the current branch, it is usually better to create a true temporary branch with a temporary name; you can always change the name of the branch later.</p>
<p class="calibre3">One possible use of<a id="_idIndexMarker651" class="pcalibre1 pcalibre calibre6"/> the detached <code>HEAD</code> is for proof-of-concept work. However, you need to remember to set the name of the branch if the changes turn out to be worthwhile (or if you need to switch branches). It is easy to go from an anonymous branch to a named branch. You simply need to create a new branch from the current detached <code>HEAD</code> state.</p>
<h1 id="_idParaDest-189" class="calibre5"><a id="_idTextAnchor210" class="pcalibre1 pcalibre calibre6"/>Branching workflows and release engineering</h1>
<p class="calibre3">Now that we know about the different branching patterns and their purposes, let’s examine how they can be <a id="_idIndexMarker652" class="pcalibre1 pcalibre calibre6"/>composed into different branching workflows. Different situations call for different uses of branches, as well as different policies. For example, smaller projects are better suited for simpler branching workflows, while larger projects might need more advanced ones.</p>
<p class="calibre3">In this section, we’ll describe how to use a few common workflows. Each workflow is distinguished by the various types of branches it uses. In addition to getting to know what the ongoing development looks like for a given workflow, we’ll also examine what it recommends doing at the time of the new release (major and minor, where relevant).</p>
<h2 id="_idParaDest-190" class="calibre7"><a id="_idTextAnchor211" class="pcalibre1 pcalibre calibre6"/>The release and trunk branches workflow</h2>
<p class="calibre3">One of the simplest workflows is to use just a <a id="_idIndexMarker653" class="pcalibre1 pcalibre calibre6"/>single integration branch. Such branches are sometimes called <code>main</code> or <code>master</code> branch (it is the default branch when creating a<a id="_idIndexMarker655" class="pcalibre1 pcalibre calibre6"/> repository). In a pure version of this workflow, you would commit everything to the said branch, at least during the normal development stage. This way of working comes from the times of centralized version control, when branching and especially merging were more expensive, and people avoided branch-heavy workflows.</p>
<p class="calibre3">This workflow is well-suited for continuous integration. If you can maintain a healthy trunk, new releases can be cut directly from it via tagging.</p>
<p class="calibre3">On the other hand, if the release process is more involved, this workflow can be used together with per-release branches. In this case, when we decide to cut the new release, we create the new release <a id="_idIndexMarker656" class="pcalibre1 pcalibre calibre6"/>branch out of the trunk. This is done to avoid the interference between stabilizing for release and the ongoing development work. The rule is that all the stabilization work goes on the release branch, while all the ongoing development goes to the<a id="_idIndexMarker657" class="pcalibre1 pcalibre calibre6"/> trunk. <strong class="bold">Release candidates</strong> are cut (tagged) from the release branch, as is the final version of a <strong class="bold">major release</strong>. The <a id="_idIndexMarker658" class="pcalibre1 pcalibre calibre6"/>release branch for a given version can be later used to gather bug<a id="_idIndexMarker659" class="pcalibre1 pcalibre calibre6"/> fixes and to cut <strong class="bold">minor releases</strong> from it.</p>
<p class="calibre3">The disadvantage of such a simple workflow is that it requires maintaining a healthy branch. Otherwise, if we get in an unstable state during development, it can be hard to come up with a good starting point for a new release. An alternative solution is to create revert commits on the release branch, undoing the work that isn’t ready. However, this can be a lot of work, and it would make the history of a project hard to follow.</p>
<p class="calibre3">Another difficulty with this workflow is that a feature that looks good at first glance might cause problems later. This is something this workflow has trouble dealing with. If it turns out during development that some feature created with multiple commits feature is not a good idea, reverting it can be difficult. This is true especially if its commits are spread across the timeline (across the history).</p>
<p class="calibre3">Despite these problems, this simple workflow can be a good fit for a small or well-disciplined team.</p>
</div>


<div><h2 id="_idParaDest-191" class="calibre7"><a id="_idTextAnchor212" class="pcalibre1 pcalibre calibre6"/>The graduation branches workflow</h2>
<p class="calibre3">To be able to provide a stable<a id="_idIndexMarker660" class="pcalibre1 pcalibre calibre6"/> line of the product, and to be able to <a id="_idIndexMarker661" class="pcalibre1 pcalibre calibre6"/>test it in practice as a kind of floating beta version, you need to separate work that is stable from the work that is ongoing and might <a id="_idIndexMarker662" class="pcalibre1 pcalibre calibre6"/>destabilize code. That’s what <strong class="bold">graduation branches</strong> are for – to integrate revisions with different degrees of maturation<a id="_idIndexMarker663" class="pcalibre1 pcalibre calibre6"/> and stability (this type of<a id="_idIndexMarker664" class="pcalibre1 pcalibre calibre6"/> long-running branch is also called an <strong class="bold">integration</strong> branch or <strong class="bold">progressive-stability</strong> branch). See <em class="italic">Figure 8</em><em class="italic">.1</em> in the <em class="italic">Maturity or progressive-stability branches</em> section, which shows a graph view and a silo view of a simple case with progressive-stability branches and linear history. Let’s call the technique that utilizes mainly (or only) this type of branch the <strong class="bold">graduation </strong><strong class="bold">branches workflow</strong>.</p>
<p class="calibre3">Besides keeping stable and unstable development separate, there is also a need for ongoing maintenance. If<a id="_idIndexMarker665" class="pcalibre1 pcalibre calibre6"/> there is only one version of the product to support, and the process of creating a new release is simple enough, you can also use the graduation-type branch for this.</p>
<p class="calibre3">Here, simple enough means that you can just create the next major release out of the stable branch.</p>
<p class="calibre3">In such a situation, you would<a id="_idIndexMarker666" class="pcalibre1 pcalibre calibre6"/> have at least three integration branches. There would be one branch for the ongoing maintenance work (containing only bug fixes to the last version), to create minor releases, another branch for stable work to create major releases (this branch can also be used for nightly stable builds), and another branch for ongoing development, possibly unstable:</p>
<div><div><img alt="Figure 8.3  – The graduation or progressive-stability branches workflow. You should never merge a less stable branch into a more stable one as it would bring all the unstable history" src="img/B21194_08_03.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.3  – The graduation or progressive-stability branches workflow. You should never merge a less stable branch into a more stable one as it would bring all the unstable history</p>
<p class="calibre3">You can use this workflow as-is, with only graduation branches, and no other types of branches:</p>
<ul class="calibre16">
<li class="calibre15">You commit bug fixes on the maintenance branch and merge it into the stable branch and development branch, if necessary</li>
<li class="calibre15">You create revisions with the well-tested work on the stable branch, merging it into the development branch when needed (for example, if the new work depends on them)</li>
<li class="calibre15">You put the work in progress, which might be unstable, on the development branch</li>
</ul>
<p class="calibre3">During normal development, you <a id="_idIndexMarker667" class="pcalibre1 pcalibre calibre6"/>should never merge less stable branches into more stable ones as this decreases their stability. This simple version of this workflow is shown in <em class="italic">Figure 8</em><em class="italic">.3</em>.</p>
<p class="calibre3">This, of course, requires that<a id="_idIndexMarker668" class="pcalibre1 pcalibre calibre6"/> you know upfront whether the feature that you are working on should be considered stable or unstable. There is also an underlying assumption that different features work well together from the start. In practice, however, you would expect that each piece of the development matures from the proof of concept, through being a work in progress during possibly several iterations, before it stabilizes. This problem can be solved by using topic branches, as described next.</p>
<p class="calibre3">In the pure graduation branches workflow, you would create minor releases (with bug fixes) out of the maintenance branch. Major releases (with new features) are created out of the stable-work branch. After a major release, the stable-work branch is merged into the maintenance branch to begin supporting the new release that was just created. At this point, an unstable (development) branch can be merged into a stable one. This is the only time when merging upstream –<a id="_idTextAnchor213" class="pcalibre1 pcalibre calibre6"/> that is, merging fewer stable branches into more stable branches – should be done.</p>
<h2 id="_idParaDest-192" class="calibre7"><a id="_idTextAnchor214" class="pcalibre1 pcalibre calibre6"/>The topic branches workflow</h2>
<p class="calibre3">The idea behind the topic branches <a id="_idIndexMarker669" class="pcalibre1 pcalibre calibre6"/>workflow is to create a separate short-lived branch <a id="_idIndexMarker670" class="pcalibre1 pcalibre calibre6"/>for each topic or feature so that all the commits belonging to a given topic (all the steps in its development) are kept together. The purpose of each <strong class="bold">topic branch</strong> is to develop a new feature or create a bug fix:</p>
<div><div><img alt="Figure 8.4 – The topic branches workflow with one integration branch (master) and three topic or feature branches. One of the topic branches is merged into the integration branch and deleted" src="img/B21194_08_04.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.4 – The topic branches workflow with one integration branch (master) and three topic or feature branches. One of the topic branches is merged into the integration branch and deleted</p>
<p class="calibre3">In the <strong class="bold">topic branches workflow</strong> (also called the <strong class="bold">feature branches workflow</strong>), you have at least two different types of branches. First, there<a id="_idIndexMarker671" class="pcalibre1 pcalibre calibre6"/> needs to be at least one permanent (or just long-lived) <em class="italic">integration branch</em>. This type of branch is used purely for merging. Integration branches are public.</p>
<p class="calibre3">Second, there are separate short-lived temporary <em class="italic">feature branches</em>, each intended for the development of a <a id="_idIndexMarker672" class="pcalibre1 pcalibre calibre6"/>topic or the creation of a bug fix. They are used to carry all the steps, and only the steps required in the development of a feature or a fix – this is a unit of work for a developer. These branches can be deleted after the feature or the bug fix is merged. Topic branches are usually private and are often not present in public repositories.</p>
<p class="calibre3">When a feature is ready for review, its topic branch is often rebased to make integration easier, and optionally to make the history clearer. It is then sent for review as a whole. The topic branch can be used in a <code>git format-patch</code> and <code>git send-email</code>). It is then often saved as a separate topic branch in a maintainer’s working repository (for example, using <code>git am --3way</code> if it was sent as patches) to help in examining and managing it.</p>
<p class="calibre3">Then, the integration manager (the maintainer in the blessed repository workflow, or simply another developer in the central repository workflow) reviews each topic branch and decides whether it is <a id="_idIndexMarker673" class="pcalibre1 pcalibre calibre6"/>ready for inclusion in the selected integration branch. If it is, then it will be merged (perhaps with the <code>--</code><code>no-ff</code> option).</p>
<h3 class="calibre9">Graduation branches in a topic branch workflow</h3>
<p class="calibre3">The simplest variant of the topic<a id="_idIndexMarker674" class="pcalibre1 pcalibre calibre6"/> branches workflow uses only one integration branch. Usually, however, you would combine the graduation branches workflow with topic branches.</p>
<div><div><img alt="Figure 8.5 – The topic branches workflow with two graduation branches. Among topic branches, there is one that is stable enough to be merged into both graduation branches" src="img/B21194_08_05.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.5 – The topic branches workflow with two graduation branches. Among topic branches, there is one that is stable enough to be merged into both graduation branches</p>
<p class="calibre3">In this often-used variant, the feature branch is started from the tip of a given stable branch (usually) or the last major release, unless the branch requires some other feature. In the latter case, the branch needs to be forked from (created from) the topic branch it depends on, such as the <code>feat</code> branch in <em class="italic">Figure 8</em><em class="italic">.5</em>. Bugfix topic branches are created on top of the maintenance branch.</p>
<p class="calibre3">When the topic is considered done, it is merged into the development-work integration branch (for example, <code>next</code>) to be tested. For example, in <em class="italic">Figure 8</em><em class="italic">.5</em>, topic branches <code>idea</code> and <code>iss92</code> are both merged into <code>next</code>, while <code>feat</code> is not considered ready yet. Adventurous users can use builds from a given unstable branch to exercise the feature, though must take into account the possibility of crashes and data loss.</p>
<p class="calibre3">After this examination, when<a id="_idIndexMarker675" class="pcalibre1 pcalibre calibre6"/> the feature is considered to be ready to be included in the next release, it is merged into the stable-work integration branch (for example, <code>master</code>). <em class="italic">Figure 8</em><em class="italic">.5</em> includes one such branch: <code>iss92</code>. At this point, after merging it into the stable integration branch, the topic branch can be deleted.</p>
<p class="calibre3">Using a feature branch allows topical revision to be kept together and not mixed with other commits. The topic branch workflow allows you to easily undo topics as a whole and remove all bad commits together (removing a series of commits as a whole unit), instead of using a series of reverts.</p>
<p class="calibre3">If the feature turns out not to be ready, it is simply not merged into the stable branch, and it remains present only in the development-work branch. However, if we realize that it wasn’t ready too late, after the topic was merged into the stable branch, we would need to revert the merge. This is a slightly more advanced operation than reverting a single commit, but it is less troublesome than reverting commits one by one, while ensuring that all the commits get correctly reverted. Problems with reverting merges will be covered in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping </em><em class="italic">History Clean</em>.</p>
<p class="calibre3">The workflow for topic branches containing bug fixes is similar. The only difference is that you need to consider which of the integration branches the bugfix branch is to be merged into. This, of course, depends on the situation. Perhaps the bugfix applies only to the maintenance branch, because it was accidentally fixed by a new feature in the stable-work and development-work branches; then, it is merged only to this branch. Perhaps the bug only applies to the stable-work and development-work branches because it is about the feature that was not present in the previous version, thus the maintenance branch is excluded from being merged into.</p>
<p class="calibre3">Using a separate topic branch for bug fixing, instead of committing a bugfix directly, has an additional advantage: it allows us to easily correct the misstep if it turns out after the fact that the fix applies to more branches than we thought.</p>
<p class="calibre3">For example, if it turns out that the fix needs to also be applied to the maintained version and not only to the current work, with the topic branch you can simply merge the fix into additional branches. This is not the case if we were to commit the fix directly to the stable branch. In<a id="_idIndexMarker676" class="pcalibre1 pcalibre calibre6"/> the latter situation, you cannot use merging as it would destabilize the maintenance branch. You would need to copy the revision with the fix by <strong class="bold">cherry-picking</strong> it from the branch it was committed to into the maintenance<a id="_idIndexMarker677" class="pcalibre1 pcalibre calibre6"/> branch (see <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>, for a detailed description of this operation). But it means that duplicated commits are present in the history of the project, and cherry-picked commits can sometimes interact wrongly with the act of merging.</p>
<p class="calibre3">The topic branches workflow also allows us to check whether the features conflict with each other, and then fix them as necessary. You can simply create a throw-away integration branch and merge into it topic branches containing these features, to test the interaction between them. You can even publish such branches meant for integration testing (named <code>proposed-updates</code> or just <code>pu</code>, for example) to allow other developers to examine the works in progress. However, you should state explicitly in the developer documentation that said branch should not be used as a basis to work on, as it is recreated each time from scratch.</p>
<h3 class="calibre9">Branch management for a release in a topic branch workflow</h3>
<p class="calibre3">Let’s assume that we’re using three graduation (integration) branches: <code>maint</code> for maintenance work on the last release, <code>master</code> for stable work, and <code>next</code> for development.</p>
<p class="calibre3">The first thing that the maintainer (the release manager) needs to do before creating a new release is to verify that <code>master</code> is a superset of <code>maint</code> – that is, all the bugs are also fixed in the version being considered for the next release. You can do this by checking whether the following command gives an empty output (see <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring </em><em class="italic">Project History</em>):</p>
<pre class="console">
$ git log master..maint</pre>
<p class="calibre3">If the preceding command shows some unmerged commits, the maintainer needs to decide what to do with them. If these bug fixes don’t break anything, they can simply merge <code>maint</code> into <code>master</code> (as it’s merging the more stable branch into the less stable one).</p>
<p class="calibre3">Now that the maintainer knows that <code>master</code> is a superset of <code>maint</code>, they can create the new release from the remote <code>master</code> branch by tagging it and push the just-created tag to the distribution point (to the public repository) with the following command:</p>
<pre class="console">
$ git tag -s -m "Foo version 1.4" v1.4 master
$ git push origin v1.4 master</pre>
<p class="calibre3">The preceding command <a id="_idIndexMarker678" class="pcalibre1 pcalibre calibre6"/>assumed that the public repository of the Foo project is the one described by <code>origin</code> and that we use the double-digit version for major releases (following the semantic versioning specification).</p>
<p class="callout-heading">Tip</p>
<p class="callout">If the maintainer wants to support more than one older version, they would need to copy an old maintenance branch, as the next step would be to prepare it for maintaining the just-released revision: <strong class="source-inline1">git branch </strong><strong class="source-inline1">maint-1.3.x maint</strong>.</p>
<p class="calibre3">Then, the maintainer updates <code>maint</code> to the new release, advancing the branch (note that step one ensured that <code>maint</code> was a subset of <code>master</code>):</p>
<pre class="console">
$ git checkout maint
$ git merge --ff-only master</pre>
<p class="calibre3">If the second command fails, it means that some commits on the <code>maint</code> branch are not present in <code>master</code>, or to be more exact that <code>master</code> is not a strict descendant of <code>maint</code>.</p>
<p class="calibre3">Because we usually consider features for inclusion in <code>master</code> one by one, there might be some topic branches that are merged into <code>next</code>, but they were abandoned before they were merged into <code>master</code> (or they are not merged because they were not ready). This means that though the <code>next</code> branch contains a superset of topic branches that compose the <code>master</code> branch, <code>master</code> is not necessarily the ancestor of <code>next</code>.</p>
<p class="calibre3">That’s why advancing the <code>next</code> branch<a id="_idIndexMarker679" class="pcalibre1 pcalibre calibre6"/> after a release can be more complicated than advancing the <code>maint</code> branch. One solution is to rewind and rebuild the <code>next</code> branch:</p>
<pre class="console">
$ git checkout next
$ git reset --hard master
$ git merge ai/topic_in_next_only_1...</pre>
<p class="calibre3">You can find unmerged topics to be merged to rebuild <code>next</code> by running the following command:</p>
<pre class="console">
$ git branch --no-merged next</pre>
<p class="calibre3">After creating the release after rebuilding <code>next</code>, other developers would have to force fetch the <code>next</code> branch (see the next section) as it would not fast-forward if it were not already configured to force fetch:</p>
<pre class="console">
$ git pull
From git://git.example.com/pub/scm/project
   62b553c..c2e8e4b  maint      -&gt; origin/maint
   a9583af..c5b9256  master     -&gt; origin/master
 + 990ffec...cc831f2 next       -&gt; origin/next  (forced update)</pre>
<p class="calibre3">Notice the forced update for the <code>next</code> branch here.</p>
<h2 id="_idParaDest-193" class="calibre7"><a id="_idTextAnchor215" class="pcalibre1 pcalibre calibre6"/>git-flow – a successful Git branching model</h2>
<p class="calibre3">The more advanced version of the topic branching workflow builds on top of the graduation branch’s one. In some cases, an<a id="_idIndexMarker680" class="pcalibre1 pcalibre calibre6"/> even more involved branching model might be necessary, utilizing more <a id="_idIndexMarker681" class="pcalibre1 pcalibre calibre6"/>types of branches: graduation branches, release branches, hotfix branches, and topic branches. One such model is <code>git-flow</code>.</p>
<p class="calibre3">This development model uses two main long-running <code>master</code> (stable work) and <code>develop</code> (gathers changes for the next release). The latter can be used for nightly builds. These two integration branches have an infinite lifetime.</p>
<p class="calibre3">These branches are <a id="_idIndexMarker683" class="pcalibre1 pcalibre calibre6"/>accompanied by <strong class="bold">supporting branches</strong> – that is, <em class="italic">feature branches</em>, <em class="italic">release branches</em>, and <em class="italic">hotfix branches</em>.</p>
<p class="calibre3">Each new feature is <a id="_idIndexMarker684" class="pcalibre1 pcalibre calibre6"/>developed on a <code>devel</code> or <code>master</code> branch, depending on the requirements of the feature in question. When work on a feature is finished, its topic branch is merged with the <code>--no-ff</code> option (so that there is always a merge commit where a feature can be described) into <code>devel</code> for integration testing. When they are ready for the next release, they are merged into the <code>master</code> branch. A topic branch exists only as long as a feature is in development and is deleted when merged (or when abandoned).</p>
<p class="calibre3">The purpose of a <strong class="bold">release branch</strong> is twofold. When<a id="_idIndexMarker685" class="pcalibre1 pcalibre calibre6"/> created, the goal is to prepare a new production release. This means doing last-minute cleanup, applying minor bug fixes, and preparing metadata for a release (for example, version numbers, release names, and so on). All but the last should be done using topic branches; metadata can be prepared directly on the release branch. This use of the release branch allows us to separate the quality assurance for the upcoming release from the work developing features for the next big release.</p>
<p class="calibre3">Such release branches are forked off when the stable state reflects, or is close to, the desired state planned for the new release. Each such branch is named after a release, usually something such as <code>release-1.4</code> or <code>release-v1.4.x</code>. You would usually create a few release candidates from this branch (tagging them <code>v1.4-rc1</code> and so on) before tagging the final state of the new release (for example, <code>v1.4</code>).</p>
<p class="calibre3">The release branch might exist only until the time the project release it was created for is rolled out, or it might be left to gather maintenance work: bug fixes for the given. In the latter situation, it replaces the <code>maint</code> branch of other workflows.</p>
<p class="calibre3"><code>hotfix-1.4.1</code> or something similar. A hotfix branch is created out of an old release tag if the respective release (maintenance) branch does not exist. The purpose of this type of branch is to resolve critical bugs found in a production version. After putting a fix on such branches, the minor release is cut (for each such branch).</p>
<h2 id="_idParaDest-194" class="calibre7"><a id="_idTextAnchor216" class="pcalibre1 pcalibre calibre6"/>Ship/Show/Ask – a modern branching strategy</h2>
<p class="calibre3">This approach tries to provide a balance between the advantages of doing pre-integration code reviews with pull requests and feature branches, and high-frequency integration and release-ready mainline that scaled trunk-based development provides.</p>
<p class="calibre3">In this workflow, you choose one of the three options – <em class="italic">Ship</em>, <em class="italic">Show</em>, or <em class="italic">Ask</em> – every time you make a change. With <strong class="bold">Ship</strong>, you<a id="_idIndexMarker687" class="pcalibre1 pcalibre calibre6"/> add a change directly into the mainline (like in trunk-based development). This is useful if you want fast integration while being sure that the change is healthy – for<a id="_idIndexMarker688" class="pcalibre1 pcalibre calibre6"/> example, if you add a feature using an established pattern, fix a simple bug, or update documentation.</p>
<p class="calibre3">With <strong class="bold">Show</strong>, you open a <a id="_idIndexMarker689" class="pcalibre1 pcalibre calibre6"/>pull request but merge it straight away (if the automated checks pass). This allows for easy post-integration review while not making the feature wait.</p>
<p class="calibre3">Finally, with <strong class="bold">Ask</strong>, you follow the topic <a id="_idIndexMarker690" class="pcalibre1 pcalibre calibre6"/>branch workflow and wait for the code review before integration.</p>
<h2 id="_idParaDest-195" class="calibre7"><a id="_idTextAnchor217" class="pcalibre1 pcalibre calibre6"/>Fixing a security issue</h2>
<p class="calibre3">Let’s examine another situation: how we<a id="_idIndexMarker691" class="pcalibre1 pcalibre calibre6"/> can use branches to fix a bug, such as a security issue. This requires a slightly different technique than in ordinary development.</p>
<p class="calibre3">As explained in the <em class="italic">The topic branches workflow</em> section, while it is possible to create a bugfix commit directly on the most stable of the integration branches that is affected by the bug, it is usually better to <a id="_idIndexMarker692" class="pcalibre1 pcalibre calibre6"/>create a separate bugfix branch.</p>
<p class="calibre3">You start by forking from the oldest (most stable) integration branch the fix needs to be applied to, perhaps even at the branching point of all the branches it would apply to. You put the fix (perhaps consisting of multiple commits) on the branch that you have just created. After testing it, you simply merge the bugfix branch into each of the integration branches that need the fix.</p>
<p class="calibre3">This model can be also used to resolve conflicts (dependencies) between branches at an early stage. Let’s assume that you are working on some new feature (on a topic branch) that is not ready yet. While <a id="_idIndexMarker693" class="pcalibre1 pcalibre calibre6"/>writing it, you noticed some bugs in the development version and you know how to fix them. You want to work on top of the fixed state, but you realize that other developers would also want the bugfix. Committing the fix on top of the feature branch takes the bugfix hostage. Fixing the bug directly on an integration branch has a risk of forgetting to merge the bugfix into the feature in progress.</p>
<p class="calibre3">The solution is to create a fix on a separate topic branch and merge it into both the topic branch for the feature being <a id="_idIndexMarker694" class="pcalibre1 pcalibre calibre6"/>developed and into the test integration branch (and possibly the graduation branches).</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can use similar techniques to create and manage some features that are requested by a subset of customers. You need to simply create a separate topic branch for each such feature and merge it into the individual, per-customer branches.</p>
<p class="calibre3">The matter is a bit more complicated if there is security involved. In the case of a severe security bug, you would want to fix it not only in the current version but also in all the widely used versions.</p>
<p class="calibre3">To do this, you need to create a hotfix branch for various maintenance tracks (forking it from the specified version):</p>
<pre class="console">
$ git checkout -b hotfix-1.9.x v1.9.4</pre>
<p class="calibre3">Then, you need to merge the topic branch with the fix in question into the just created hotfix branch, to finally create<a id="_idIndexMarker695" class="pcalibre1 pcalibre calibre6"/> the bugfix release:</p>
<pre class="console">
$ git merge CVE-2014-1234
$ git tag -s -m "Project 1.9.5" v1.9.5</pre>
<h1 id="_idParaDest-196" class="calibre5"><a id="_idTextAnchor218" class="pcalibre1 pcalibre calibre6"/>Interacting with branches in remote repositories</h1>
<p class="calibre3">As we’ve seen, having many branches in a single repository is very useful. Easy branching and merging allow for powerful <a id="_idIndexMarker696" class="pcalibre1 pcalibre calibre6"/>development models that utilize advanced branching techniques, such as topic branches. This means that remote repositories will also contain many branches. Therefore, we have to go beyond just the repository to the repository interaction, as described in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>. We have to consider how to interact with multiple branches in the remote repositories.</p>
<p class="calibre3">We also need to think about how many local branches in our repository relate to the branches in the remote repositories (or, in general, other refs). The other important knowledge is how the tags in the local repository relate to the tags in other repositories.</p>
<p class="calibre3">Understanding the interaction between repositories, the branches in these repositories, and how to merge changes (as described in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>) is required to truly master collaboration with Git.</p>
<h2 id="_idParaDest-197" class="calibre7"><a id="_idTextAnchor219" class="pcalibre1 pcalibre calibre6"/>Upstream and downstream</h2>
<p class="calibre3">In software development, <strong class="bold">upstream</strong> refers to a direction toward the original authors or the maintainers of the project. We can <a id="_idIndexMarker697" class="pcalibre1 pcalibre calibre6"/>say that the <em class="italic">repository</em> is upstream from us if it is closer (in the repository-to-repository steps) to the blessed repository – the canonical source of the software. If a change (a patch or a commit) is accepted upstream, it will be<a id="_idIndexMarker698" class="pcalibre1 pcalibre calibre6"/> included either immediately or in a future release of an application, and all the people <strong class="bold">downstream</strong> will receive it.</p>
<p class="calibre3">Similarly, we can say that a given <em class="italic">branch</em> in a remote repository (the maintainer repository) is an <strong class="bold">upstream branch</strong> for a given<a id="_idIndexMarker699" class="pcalibre1 pcalibre calibre6"/> local branch if changes in that local branch are to be ultimately merged and included in the remote branch.</p>
<p class="callout-heading">Configuring what is considered upstream</p>
<p class="callout">A quick reminder: the upstream repository and the upstream branch in the said remote repository for a given branch are<a id="_idIndexMarker700" class="pcalibre1 pcalibre calibre6"/> defined by the <strong class="source-inline1">branch.&lt;branchname&gt;.remote</strong> and <strong class="source-inline1">branch.&lt;branchname&gt;.merge</strong> configuration variables, respectively. The <a id="_idIndexMarker701" class="pcalibre1 pcalibre calibre6"/>upstream branch can be referred to with the <strong class="source-inline1">@{upstream}</strong> or <strong class="source-inline1">@{</strong><strong class="source-inline1">u}</strong> shortcut.</p>
<p class="callout">The upstream branch is usually set while creating a branch out of the remote-tracking branch, and it can be modified using either <strong class="source-inline1">git branch --set-upstream-to</strong> or <strong class="source-inline1">git </strong><strong class="source-inline1">push --set-upstream</strong>.</p>
<p class="calibre3">The upstream branch does not need to be a branch in the remote repository. It can be a local branch, though we usually <a id="_idIndexMarker702" class="pcalibre1 pcalibre calibre6"/>say that it is a <strong class="bold">tracked branch</strong> rather than saying that it is an upstream one. This feature can be useful when one local branch is based on another local branch, such as when a topic branch is forked from another topic branch (because it contains the feature that is a prerequisite for the latter work).</p>
<h2 id="_idParaDest-198" class="calibre7"><a id="_idTextAnchor220" class="pcalibre1 pcalibre calibre6"/>Remote-tracking branches and refspec</h2>
<p class="calibre3">While collaborating on a project, you will be interacting with many repositories (see <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>). Each of these remote repositories you are interacting with will have a notion of the position of the branches. For example, the <code>master</code> branch in the remote repository, <code>origin</code>, doesn’t need to be at the same place as your local <code>master</code> branch in your clone of the repository. In other words, they don’t need to point to the same commit in the graph of revisions.</p>
<h3 class="calibre9">Remote-tracking branches</h3>
<p class="calibre3">To be able to check the integration status to see what changes there are in the <code>origin</code> remote repository that are not yet in yours, or what changes you made in your working repository that you have not<a id="_idIndexMarker703" class="pcalibre1 pcalibre calibre6"/> published yet, you need to know where the branches in the remote repositories are (well, where they were the last time you contacted these repositories). This is the task of <strong class="bold">remote-tracking branches</strong> – the references that track where the branch was in the remote repository:</p>
<div><div><img alt="Figure 8.6 – Remote repository and local repository with local branches and remote-tracking branches. The grayed-out text in the fetch command denotes the default implicit parameters﻿." src="img/B21194_08_06.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 8.6 – Remote repository and local repository with local branches and remote-tracking branches. The grayed-out text in the fetch command denotes the default implicit parameters.</p>
<p class="calibre3">To track what happens in the remote repository, remote-tracking branches are updated automatically; this <a id="_idIndexMarker704" class="pcalibre1 pcalibre calibre6"/>means that you cannot create new local commits on top of them (as you would lose these commits during updates). You need to create a local branch for it. This can be done, for example, by running <code>git checkout &lt;branchname&gt;</code>, assuming that the local branch with the given name does not already exist. This <a id="_idTextAnchor221" class="pcalibre1 pcalibre calibre6"/>command creates a new local branch out of the remote branch’s <code>&lt;branchname&gt;</code> and sets <a id="_idIndexMarker705" class="pcalibre1 pcalibre calibre6"/>the upstream information for it.</p>
<h3 class="calibre9">Refspec – remote to local branch mapping specification</h3>
<p class="calibre3">As described in <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>, local branches are in the <code>refs/heads/</code> namespace, while remote-tracking branches for a given remote are in the <code>refs/remotes/&lt;remote name&gt;/</code> namespace. But that’s just the default. The <code>fetch</code> (and <code>push</code>) lines in the <code>remote.&lt;remote name&gt;</code> configuration describe the mapping between branches (or refs in general) in the remote repository and the remote-tracking <a id="_idIndexMarker706" class="pcalibre1 pcalibre calibre6"/>branches (or other refs) in the local repository.</p>
<p class="calibre3">This mapping is called <strong class="bold">refspec</strong>; it can be either explicit, mapping branches one by one, or globbing, describing a mapping pattern.</p>
<p class="calibre3">For example, the default mapping for the <code>origin</code> repository is as follows:</p>
<pre class="source-code">
[remote "origin"]
    fetch = +refs/heads/*:refs/remotes/origin/*</pre>
<p class="calibre3">This says that, for example, the content of the <code>master</code> branch (whose full name is <code>refs/heads/master</code>) in the remote repository, <code>origin</code>, is to be stored in the local clone of a repository in the remote-tracking branch, <code>origin/master</code> (whose full name is <code>refs/remotes/origin/master</code>). The plus (<code>+</code>) sign at the beginning of the pattern tells Git to accept the updates to the remote-tracking branch that are not fast-forwarded – that is, they are not descendants of the previous value.</p>
<p class="calibre3">The mapping can be given using the fetch lines in the configuration for the remote, as shown previously, or can be also passed as arguments to a command (it is often enough to specify just the short name of the reference instead of the full refspec). The configuration is only taken into account if there are no refspecs on the command line.</p>
<h2 id="_idParaDest-199" class="calibre7"><a id="_idTextAnchor222" class="pcalibre1 pcalibre calibre6"/>Fetching and pulling versus pushing</h2>
<p class="calibre3">Sending changes (publishing) to the remote repository can be done with <code>git push</code>, while getting changes from it can be done with <code>git fetch</code>. These commands send changes in the opposite direction. However, note that your local repository has a very important difference – it has you<a id="_idIndexMarker707" class="pcalibre1 pcalibre calibre6"/> sitting next to you’re keyboard so that you’re available to run other Git commands.</p>
<p class="calibre3">That’s why there is no <a id="_idIndexMarker708" class="pcalibre1 pcalibre calibre6"/>equivalent in the local-to-remote direction to <code>git pull</code>, which combines getting and integrating changes (see the next section). There is simply nobody there to resolve possible conflicts (problems occurring during doing automated integration).</p>
<p class="calibre3">In particular, there is a difference between how branches and tags are fetched and how they are pushed. This will be explained in detail later.</p>
<h3 class="calibre9">Pull – fetching and updating the current branch</h3>
<p class="calibre3">Many times, you want to incorporate changes from a specific branch of a remote repository into the current branch. The <code>git fetch</code> with the parameters given); then, it<a id="_idIndexMarker709" class="pcalibre1 pcalibre calibre6"/> automatically integrates the retrieved branch head into the current branch. Depending on the configuration, it either calls <code>git merge</code> or <code>git rebase</code> to do that. You can use the <code>--rebase=false</code> or <code>--rebase</code> option to override the default, something that can be configured globally with the <code>pull.rebase</code> configuration option or <code>branch.&lt;branch name&gt;.rebase </code>per-branch configuration option.</p>
<p class="calibre3">Note that if there is no configuration for the remote (you are doing the pull by URL), Git uses the <code>FETCH_HEAD</code> ref to store tips of the fetched branches.</p>
<p class="calibre3">There is also the <code>git request-pull</code> command to create information about published or pending changes for the pull-based workflows – for example, for a variant of the blessed repository workflow. It creates a plain text equivalent of the GitHub merge requests, one that is particularly suitable to send by email.</p>
<h3 class="calibre9">Pushing to the current branch in a non-bare remote repository</h3>
<p class="calibre3">Usually, the repositories you <a id="_idIndexMarker710" class="pcalibre1 pcalibre calibre6"/>push to are created for synchronization and are <code>HEAD</code>) – there is no worktree, so there is no checked-out branch.</p>
<p class="calibre3">Sometimes, however, you might want to push to the non-bare repository. This may happen, for example, as a way of synchronizing two repositories, or as a mechanism for deployment (for example, of<a id="_idIndexMarker711" class="pcalibre1 pcalibre calibre6"/> a web page or a web application). By default, Git on the server will deny the ref update to the currently checked-out branch. This is because it brings <code>HEAD</code> out of sync with the worktree and the staging area, which is very confusing if you don’t expect it. You can, however, enable such a push by setting <code>receive.denyCurrentBranch</code> to <code>warn</code> or <code>ignore</code> (changing it from the default value of <code>refuse</code>). You can even make Git update the working directory (which must be clean – that is, without any uncommitted changes) by setting the said configuration variable to <code>updateInstead</code>.</p>
<p class="calibre3">An alternative and a more flexible solution to using <code>git push</code> for deployment is to configure appropriate hooks on the receiving side – see <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and Extending Git</em>, for information on hooks in general, and <a href="B21194_14.xhtml#_idTextAnchor349" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 14</em></a>, <em class="italic">Git Administration</em>, for details on their use on the server.</p>
<h3 class="calibre9">The default fetch refspec and push modes</h3>
<p class="calibre3">We usually fetch from public repositories with all the branches made public. Often, we want to get a full update of all the branches. That’s why <code>git clone</code> sets up the default <code>git pull &lt;</code><code>URL&gt; &lt;branch&gt;</code>.</p>
<p class="calibre3">On the other side, in the private working repository, there are usually many branches that we don’t want to publish or, at least, we don’t want to publish them yet. In most cases, we would want to publish a single branch: the one we were working on and the one we know is ready. However, if you are the integration manager, you would want to publish a carefully selected subset of the branches instead of just one single branch.</p>
<p class="calibre3">This is yet another difference between fetching and pushing. That’s why Git doesn’t set up push refspec by default (you can configure it manually nonetheless), but instead relies on the so-called <code>push.default</code> configuration variable<a id="_idIndexMarker713" class="pcalibre1 pcalibre calibre6"/> used to configure this applies only while running the <code>git push</code> command without branches to push stated explicitly.</p>
<p class="callout-heading">Using git push to sync out of a host that one cannot pull from</p>
<p class="callout">When you work on two machines, <strong class="source-inline1">machineA</strong> and <strong class="source-inline1">machineB</strong>, each with its own worktree, a typical way to<a id="_idIndexMarker714" class="pcalibre1 pcalibre calibre6"/> synchronize between them is to run <strong class="source-inline1">git pull</strong> from each other. However, in certain situations, you may only be able to make the connection in one direction (for example, because of a firewall or intermittent connectivity). Let’s assume that you can fetch and push from <strong class="source-inline1">machineB</strong>, but you cannot fetch from <strong class="source-inline1">machineA</strong>.</p>
<p class="callout">You want to perform a push from <strong class="source-inline1">machineB</strong> to <strong class="source-inline1">machineA</strong> in such a way that the result of the operation is practically indistinguishable from doing a fetch while being on <strong class="source-inline1">machineA</strong>. For this, you need to specify, via refspec, that you want to push the local branch into its remote-tracking branch:</p>
<p class="callout"><strong class="source-inline1">machineB$ git push </strong><strong class="source-inline1">machineA:repo.git \</strong></p>
<p class="callout"><strong class="source-inline1">   </strong><strong class="source-inline1">refs/heads/master:refs/remotes/machineB/master</strong></p>
<p class="callout">The first parameter is the URL in the <strong class="source-inline1">scp</strong>-like syntax, while the second parameter is refspec. You can set this in the config file, in case you need to do something like this more often.</p>
<h2 id="_idParaDest-200" class="calibre7"><a id="_idTextAnchor223" class="pcalibre1 pcalibre calibre6"/>Fetching and pushing branches and tags</h2>
<p class="calibre3">The next section will describe <a id="_idIndexMarker715" class="pcalibre1 pcalibre calibre6"/>which push modes are available, and when to use them (for which <a id="_idIndexMarker716" class="pcalibre1 pcalibre calibre6"/>collaboration workflows). But first, we need to<a id="_idIndexMarker717" class="pcalibre1 pcalibre calibre6"/> know how Git behaves <a id="_idIndexMarker718" class="pcalibre1 pcalibre calibre6"/>concerning tags and branches while interacting with remote repositories.</p>
<p class="calibre3">Because pushing is not the exact opposite of fetching, and because branches and tags have different objectives (branches point to the lines of development, and tags point to name-specific revisions), their behavior is subtly different.</p>
<h3 class="calibre9">Fetching branches</h3>
<p class="calibre3">Fetching branches is quite simple. With <a id="_idIndexMarker719" class="pcalibre1 pcalibre calibre6"/>the default configuration, the <code>git fetch</code> command downloads changes and updates remote-tracking branches (if possible). The latter is done according to the fetch refspec for the remote.</p>
<p class="calibre3">There are, of course, exceptions to this rule. One such <a id="_idIndexMarker720" class="pcalibre1 pcalibre calibre6"/>exception is <code>git clone --mirror</code> would generate the following configuration for <code>origin</code>:</p>
<pre class="source-code">
[remote "origin"]
    url = https://git.example.com/project
    fetch = +refs/*:refs/*
    mirror = true</pre>
<p class="calibre3">The names of refs that are fetched, together with the object names they point at, are written to the <code>.git/FETCH_HEAD</code> file. This information is used, for example, by <code>git pull</code>; this is necessary if we are fetching via URL and not via a remote name. This is done because, when we fetch by the URL, there are simply no remote-tracking branches to store the information about the fetched branch to be integrated.</p>
<p class="calibre3">You can delete remote-tracking branches on a case-by-case basis with <code>git branch -r -d</code>; you can also remove them on a case-by-case basis for which the  corresponding branch in the remote repository <a id="_idIndexMarker721" class="pcalibre1 pcalibre calibre6"/>no longer exists with <code>git remote prune</code> (or with <code>git fetch -- prune</code> in modern Git).</p>
<h3 class="calibre9">Fetching tags and automatic tag following</h3>
<p class="calibre3">The situation with tags is a bit <a id="_idIndexMarker722" class="pcalibre1 pcalibre calibre6"/>different. While we would want to make it possible for different developers to work independently on the same branch (for example, an integration branch such as <code>master</code>), in different repositories, we would need for all developers to have one specific tag to always refer to the same specific revision. That’s why the position of branches in remote repositories is stored using a separate per-remote namespace, <code>refs/remotes/&lt;remote name&gt;/*</code>, in remote-tracking branches, but tags are mirrored – each tag is stored with the same name in the <code>refs/tags/*</code> namespace.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Note that the positions of tags in the remote repository can be configured with the appropriate fetch refspec; Git is that flexible. One example where it might be necessary is fetching a subproject, where we want to store its tags in a separate namespace (more information on this issue in <a href="B21194_11.xhtml#_idTextAnchor270" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 11</em></a>, <em class="italic">Managing Subprojects</em>).</p>
<p class="calibre3">This is also why, by default, while downloading changes, Git will also fetch and store all the tags that point to the downloaded objects locally. You <a id="_idIndexMarker723" class="pcalibre1 pcalibre calibre6"/>can disable this <code>--no-tags</code> option. This option can be set on the command line as a parameter, or it can be configured with the <code>remote.&lt;remote </code><code>name&gt;.tagopt</code> setting.</p>
<p class="calibre3">You can also make Git download all the tags with the <code>--tags</code> option, or by adding the appropriate fetch refspec value for tags:</p>
<pre class="source-code">
    fetch = +refs/tags/*:refs/tags/*</pre>
<h3 class="calibre9">Pushing branches and tags</h3>
<p class="calibre3">Pushing is different. Pushing branches is (usually) governed by the selected push mode. You push a local branch (usually just a single current branch) to update a specific branch in the remote repository, from <code>refs/heads/</code> locally to <code>refs/heads/</code> in remote. It is usually a branch with the same name, but it might be a differently named branch configured as upstream – details will be provided later. You don’t need to specify the full refspec: using the ref name (for example, the name of a branch) means pushing to the ref with the same name in the remote repository, creating it if it doesn’t exist. Pushing <code>HEAD</code> means pushing the current branch into the branch with the same name (not to <code>HEAD</code> in remote – it usually <a id="_idIndexMarker724" class="pcalibre1 pcalibre calibre6"/>doesn’t exist).</p>
<p class="calibre3">Usually, you push tags explicitly<a id="_idIndexMarker725" class="pcalibre1 pcalibre calibre6"/> with <code>git push &lt;remote repository&gt; &lt;tag&gt;</code> (or <code>tag &lt;tag&gt;</code> if there is both a tag and branch with the same name – both mean the <code>+refs/tags/&lt;tag&gt;:refs/tags/&lt;tag&gt;</code> refspec). You can push all the tags with <code>--tags</code> (and with appropriate refspec) and turn on the automatic tag with <code>--follow-tags</code> (it is not turned on by default as it is for fetch).</p>
<p class="calibre3">As a special case of refspec, pushing an “empty” source into some ref in remote deletes it. The <code>--delete</code> option to <code>git push</code> is just a shortcut for using this type of refspec. For example, to delete a ref matching <code>experimental</code> in the remote repository, you can run the following command:</p>
<pre class="console">
$ git push origin :experimental</pre>
<p class="calibre3">Note that the remote server might forbid the deletion of refs with <code>receive.denyDeletes</code> configuration option or with hooks.</p>
<h2 id="_idParaDest-201" class="calibre7"><a id="_idTextAnchor224" class="pcalibre1 pcalibre calibre6"/>Push modes and their use</h2>
<p class="calibre3">The behavior of <code>git push</code>, in the absence of the parameters specifying what to push, and in the absence of the configured <a id="_idIndexMarker726" class="pcalibre1 pcalibre calibre6"/>push refspec, is <a id="_idIndexMarker727" class="pcalibre1 pcalibre calibre6"/>specified by the <strong class="bold">push mode</strong>.</p>
<p class="calibre3">Different modes are available, each suitable for different collaborative workflows, which was shown in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development </em><em class="italic">with Git</em>.</p>
<h3 class="calibre9">The “simple” push mode – the default</h3>
<p class="calibre3">The default push mode in Git 2.0 and later is the so-called <code>simple</code> mode. It was designed with the idea of <em class="italic">minimum surprise</em>: the idea that it is better to prevent publishing a branch than to make some private changes accidentally public.</p>
<p class="calibre3">With this mode, you<a id="_idIndexMarker728" class="pcalibre1 pcalibre calibre6"/> always push the current local branch into the same named branch in the remote repository. If you push into the same repository you fetch from (the centralized <a id="_idIndexMarker729" class="pcalibre1 pcalibre calibre6"/>workflow), it requires the upstream to be set for the current branch. The upstream is named the same as the branch.</p>
<p class="calibre3">This means that in the centralized workflow (push into the same repository you fetch from), it works like <code>upstream</code> with the additional safety that the upstream must have the same name as the current (pushed) branch. With a triangular workflow, while pushing to a remote that is different from the remote you normally pull from, it works like <code>current</code>.</p>
<p class="calibre3">This is the safest option; it is well-suited for beginners, which is why it is the default mode. You can turn it on explicitly with <code>git config </code><code>push.default simple</code>.</p>
<h3 class="calibre9">The “matching” push mode for maintainers</h3>
<p class="calibre3">Before version 2.0 of Git, the default push mode was <code>matching</code>. This mode is most useful for the <a id="_idIndexMarker730" class="pcalibre1 pcalibre calibre6"/>maintainer (also known as the integration manager) in a blessed repository workflow. But <a id="_idIndexMarker731" class="pcalibre1 pcalibre calibre6"/>most Git users are not maintainers; that’s why the default push<a id="_idIndexMarker732" class="pcalibre1 pcalibre calibre6"/> mode was changed to <code>simple</code>.</p>
<p class="calibre3">The maintainer would get contributions from other developers, be it via pull requests or patches sent in an email, and put them into topic branches. They could also create topic branches for their own contributions. Then, the topic branches considered to be suitable were merged into the appropriate integration branches (for example, <code>maint</code>, <code>master</code>, and <code>next</code>) – merging will be covered in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>. All this is done in the maintainer’s private repository.</p>
<p class="calibre3">The public blessed repository (one that everyone fetches from, as described in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em>) should only contain long-running branches (otherwise, other developers could start basing their work on a branch that suddenly vanishes). Git cannot know by itself which branches are long-lived and which are short-lived.</p>
<p class="calibre3">With the matching mode, Git will push all the local branches that have their equivalent with the same name in the remote<a id="_idIndexMarker733" class="pcalibre1 pcalibre calibre6"/> repository. This means that only the branches that are already published will be <a id="_idIndexMarker734" class="pcalibre1 pcalibre calibre6"/>pushed to the remote repository. To make a new branch public, you need to push it explicitly the first time, like so:</p>
<pre class="console">
$ git push origin maint-1.4</pre>
<p class="callout-heading">Important note</p>
<p class="callout">Note that with this mode, unlike with other modes, using the <strong class="source-inline1">git push</strong> command without providing a list of branches to push can publish multiple branches at once, and may not publish the current branch.</p>
<p class="calibre3">To turn on the matching mode globally, you can run the following command:</p>
<pre class="console">
$ git config push.default matching</pre>
<p class="calibre3">If you want to turn it on for a specific repository, you need to use a special refspec composed of a sole colon. Assuming that the said repository is named <code>origin</code> and that we want a not forced push, it can be done with the following command:</p>
<pre class="console">
$ git config remote.origin.push :</pre>
<p class="calibre3">You can, of course, push matching branches by using the following refspec on the command line:</p>
<pre class="console">
$ git push origin :</pre>
<h3 class="calibre9">The “upstream” push mode for the centralized workflow</h3>
<p class="calibre3">In the centralized workflow, there is a<a id="_idIndexMarker735" class="pcalibre1 pcalibre calibre6"/> single shared central repository that every developer with commit access pushes to. This shared repository will only have long-lived integration branches, usually only <code>maint</code> and <code>master</code>, and sometimes <a id="_idIndexMarker736" class="pcalibre1 pcalibre calibre6"/>only <code>master</code>.</p>
<p class="calibre3">You should rather never work directly on <code>master</code> (perhaps except for simple single-commit topics), but rather<a id="_idIndexMarker737" class="pcalibre1 pcalibre calibre6"/> fork a topic branch for each separate feature out of the remote-tracking branch:</p>
<pre class="console">
$ git checkout -b feature-foo origin/master</pre>
<p class="calibre3">In the centralized workflow, the integration is distributed: each developer is responsible for merging changes (in their topic branches), and publishing the result  to the <code>master</code> branch in the central repository. You would need to update the local <code>master</code> branch, merge the topic branch to it, and push it:</p>
<pre class="console">
$ git checkout master
$ git pull
$ git merge feature-foo
$ git push origin master</pre>
<p class="calibre3">An alternate solution is to rebase the topic branch on the top of the remote-tracking branch rather than merging it. After rebasing, the topic branch should be an ancestor of  <code>master</code> in the remote repository, so we can simply push it into <code>master</code>:</p>
<pre class="console">
$ git checkout feature-foo
$ git pull --rebase
$ git push origin feature-foo:master</pre>
<p class="calibre3">In both cases, you are pushing the local branch (<code>master</code> in the merge-based workflow and the feature branch in the rebase-based workflow) into the branch it tracks in the remote repository – in this case, origin’s <code>master</code>.</p>
<p class="calibre3">That is what the <code>upstream</code> push mode was created for:</p>
<pre class="console">
$ git config push.default upstream</pre>
<p class="calibre3">This mode makes Git push the current branch to the specific branch in the remote repository – the branch whose changes are usually integrated into the current branch. This branch in the remote repository is the upstream branch (and can be referenced as <code>@{upstream}</code>). Turning this mode on makes it possible to simplify the last command in both examples to the following:</p>
<pre class="console">
$ git push</pre>
<p class="calibre3">The information about the upstream is created either automatically (while forking off the remote-tracking<a id="_idIndexMarker738" class="pcalibre1 pcalibre calibre6"/> branch), or explicitly with the <code>--track</code> option. It is stored in the configuration file and it <a id="_idIndexMarker739" class="pcalibre1 pcalibre calibre6"/>can be edited with ordinary configuration tools.</p>
<p class="calibre3">Alternatively, it can be changed later with the following:</p>
<pre class="console">
$ git branch --set-upstream-to=&lt;branchname&gt;</pre>
<h3 class="calibre9">The “current” push mode for the blessed repository workflow</h3>
<p class="calibre3">In the blessed repository workflow, each <a id="_idIndexMarker740" class="pcalibre1 pcalibre calibre6"/>developer has a private and public repository. In this model, you fetch from the blessed repository and push it to your public repository.</p>
<p class="calibre3">In this workflow, you start working on a feature by creating a new topic branch for it:</p>
<pre class="console">
$ git checkout -b fix-tty-bug origin/master</pre>
<p class="calibre3">When the features are ready, you<a id="_idIndexMarker741" class="pcalibre1 pcalibre calibre6"/> push it into your public repository, perhaps rebasing it first to make it easier for the maintainer to merge it:</p>
<pre class="console">
$ git push origin fix-tty-bug</pre>
<p class="calibre3">Here, it is assumed that you used <code>pushurl</code> to configure the triangular workflow, and the push remote is <code>origin</code>. You would need to replace <code>origin</code> here with the appropriate name of the publishing remote if you are using a separate remote for your public repository (using a separate repository makes it possible to use it not only for publishing but also for synchronization between different machines).</p>
<p class="calibre3">You can configure Git in such a way that when you’re on the <code>fix-tty-bug</code> branch, it is enough to just run <code>git push</code>. To do this, you need to set up Git to use the <code>current</code> push mode, like so:</p>
<pre class="console">
$ git config push.default current</pre>
<p class="calibre3">This mode will push the current branch to the branch with the same name at the receiving end.</p>
<p class="calibre3">Note that if you’re using a<a id="_idIndexMarker742" class="pcalibre1 pcalibre calibre6"/> separate remote for the publishing repository, you would <a id="_idIndexMarker743" class="pcalibre1 pcalibre calibre6"/>need to set up the <code>remote.pushDefault</code> configuration option to be able to use just <code>git push</code> for publishing.</p>
<h1 id="_idParaDest-202" class="calibre5"><a id="_idTextAnchor225" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">This chapter has shown how to effectively use branches for development and collaboration. You also got to know a few useful tricks.</p>
<p class="calibre3">First, we learned about the various uses of branches, from integration, through release management and the parallel development of features, to fixing bugs. You learned about different branching patterns and branching workflows. This knowledge should help you branch and customize workflows so that they fit the needs of the project and your team’s preferences.</p>
<p class="calibre3">You also learned how to deal with multiple branches per repository while downloading or publishing changes. Git provides flexibility in how the information on branches and other refs in the remote repository is managed using the so-called refspecs to define a mapping to local refs: remote-tracking branches, local branches, and tags. Usually, fetching is governed by fetch refspec, but pushing is managed by the configured push mode. Various collaborative workflows require branch publishing to be handled differently; this chapter described which push mode to use with which workflow and explains why.</p>
<p class="calibre3">The next chapter, <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging Changes Together</em>, will explain how to integrate changes from other branches and other developers. You will learn about merging and rebasing, and how to deal with situations where Git can’t do this automatically (how to handle various types of merge conflicts). You will also learn about cherry-picking and reverting commits.</p>
<h1 id="_idParaDest-203" class="calibre5"><a id="_idTextAnchor226" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">What are the advantages of frequent integration?</li>
<li class="calibre15">What are the advantages of topic branches?</li>
<li class="calibre15">How can you store a project web page or its GitOps configuration in the same repository as the code, while keeping their histories and files separate?</li>
<li class="calibre15">How can you synchronize the working directory of the Git repository hosted on other computers?</li>
</ol>
<h1 id="_idParaDest-204" class="calibre5"><a id="_idTextAnchor227" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to this chapter’s questions:</p>
<ol class="calibre14">
<li class="calibre15">More frequent integration leads to easier integration because with smaller differences, there is less chance of conflict, and because conflicts are discovered earlier. It also makes it easier to maintain a production-ready mainline, decreasing the time it takes to put the feature into the production environment.</li>
<li class="calibre15">Using topic branches makes it easier to review and examine the steps it took to create a feature and remove it if needed. The use of topic branches also plays nicely with the requirement of pre-integration code review.</li>
<li class="calibre15">You can use the “orphan” branch trick – for example, with <strong class="source-inline1">git checkout -- orphan</strong> – to have two or more unrelated histories in a single repository.</li>
<li class="calibre15">Log in to the other computer and use <strong class="source-inline1">git pull</strong>; if this is not possible, you can <strong class="source-inline1">git push</strong> into a non-bare repository (configuring what should happen to checked-out branches).</li>
</ol>
<h1 id="_idParaDest-205" class="calibre5"><a id="_idTextAnchor228" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Martin Fowler, <em class="italic">Patterns for Managing Source Code Branches</em> (2020): <a href="https://martinfowler.com/articles/branching-patterns.html" class="pcalibre1 pcalibre calibre6">https://martinfowler.com/articles/branching-patterns.html</a></li>
<li class="calibre15">Rouan Wilsenach, <em class="italic">Ship / Show / Ask: A modern branching strategy</em> (2021): <a href="https://martinfowler.com/articles/ship-show-ask.html" class="pcalibre1 pcalibre calibre6">https://martinfowler.com/articles/ship-show-ask.html</a></li>
<li class="calibre15">Vincent Driessen, <em class="italic">git-flow - A successful Git branching model</em> (2010): <a href="https://nvie.com/posts/a-successful-git-branching-model/" class="pcalibre1 pcalibre calibre6">https://nvie.com/posts/a-successful-git-branching-model/</a></li>
<li class="calibre15"><em class="italic">gitworkflows - An overview of recommended workflows with </em><em class="italic">Git</em>: <a href="https://git-scm.com/docs/gitworkflows" class="pcalibre1 pcalibre calibre6">https://git-scm.com/docs/gitworkflows</a></li>
<li class="calibre15">Paul Hammant and others, <em class="italic">Trunk Based </em><em class="italic">Development</em>: <a href="https://trunkbaseddevelopment.com/" class="pcalibre1 pcalibre calibre6">https://trunkbaseddevelopment.com/</a></li>
<li class="calibre15">Junio C Hamano: <em class="italic">Resolving conflicts/dependencies between topic branches early</em> (2009): <a href="https://gitster.livejournal.com/27297.html" class="pcalibre1 pcalibre calibre6">https://gitster.livejournal.com/27297.html</a></li>
<li class="calibre15">Junio C Hamano, <em class="italic">Fun with various workflows 1</em> and <em class="italic">2</em> (2013): <a href="https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-1.html" class="pcalibre1 pcalibre calibre6">https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-1.html</a> and <a href="https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-2.html" class="pcalibre1 pcalibre calibre6">https://git-blame.blogspot.com/2013/06/fun-with-various-workflows-2.html</a></li>
</ul>
</div>
</body></html>