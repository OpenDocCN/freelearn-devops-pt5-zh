- en: Chapter 2. Simple Playbooks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ansible can be used as a command-line tool for making small changes. However,
    its real power lies in its scripting abilities. While setting up machines, we
    almost always need to do more than one thing at a time. Ansible uses a concept
    named **playbook** to do this. Using playbooks, we can perform many actions at
    once, and across multiple systems. They provide a way to orchestrate deployments,
    ensure a consistent configuration, or simply perform a common task.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks are expressed in **YAML,** and for the most part, Ansible uses a standard
    YAML parser. This means that we have all the features of YAML available to us
    as we write them. For example, we can use the same commenting system in playbook
    as we would in YAML. Many lines of a playbook can also be written and represented
    in YAML data types. See [http://www.yaml.org/](http://www.yaml.org/) for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: Playbooks also open up many opportunities. They allow us to carry the state
    from one command to the other. For example, we can grab the content of a file
    on one machine, register it as a variable, and then use the value on another machine.
    This allows us to make complex deployment mechanisms that will be impossible with
    the Ansible command alone. Additionally, since each module tries to be idempotent,
    we should be able to run a playbook several times and changes will only be made
    if they need to be.
  prefs: []
  type: TYPE_NORMAL
- en: 'The command to execute a playbook is `ansible-playbook`. It accepts arguments
    similar to the Ansible command-line tool. For example, `-k` (`--ask-pass`) and
    `-K` (`--ask-sudo`) make Ansible prompt for the SSH and sudo passwords, respectively;
    `-u` can be used to set the user to use for SSH. However, these options can also
    be set inside the playbooks themselves in the target section. For example, to
    use the play named `example-play.yml`, we can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The Ansible playbooks are made up of one or more plays. A play consists of
    three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The **target section** defines the hosts on which the play will be run, and
    how it will be run. This is where we set the SSH username and other SSH-related
    settings.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **variable section** defines variables, which will be made available to
    the play while running.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **task section** lists all the modules in the order we want them to be run
    by Ansible.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can include as many plays as we want in a single YAML file. YAML files start
    with `---` and contain many key values and lists. In YAML line indentation is
    used to indicate variable nesting to the parser, which also makes the file easier
    to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full example of an Ansible play looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the next few sections, we will examine each section and explain in detail
    how they work.
  prefs: []
  type: TYPE_NORMAL
- en: The target section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The target section looks like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is an incredibly simple version, but likely to be all we need in most cases.
    Each play exists within a list. As per the YAML syntax, the line must start with
    a dash. The hosts that a play will be run on must be set in the value of `hosts`.
    This value uses the same syntax as the one used when selecting hosts using the
    Ansible command line, which we discussed in the previous chapter. The host-pattern-matching
    features of Ansible were also discussed in the previous chapter. In the next line,
    the user tells the Ansible playbook which user to connect to the machine as.
  prefs: []
  type: TYPE_NORMAL
- en: 'The other lines that we can provide in this section are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sudo` | Set this to `yes` if you want Ansible to use `sudo` to become the
    root once it is connected to the machines in the play. |'
  prefs: []
  type: TYPE_TB
- en: '| `user` | This defines the username to connect to the machine originally,
    before running `sudo` if configured. |'
  prefs: []
  type: TYPE_TB
- en: '| `sudo_user` | This is the user that Ansible will try and become using `sudo`.
    For example, if we set `sudo` to `yes` and `user` to `daniel`, setting `sudo_user`
    to `kate` will cause Ansible to use `sudo` to get from `daniel` to `kate` once
    logged in. If you were doing this in an interactive SSH session, we could use
    `sudo -u kate` while you are logged in as `daniel`. |'
  prefs: []
  type: TYPE_TB
- en: '| `connection` | This allows us to tell Ansible what transport to use to connect
    to the remote host. We will mostly use `ssh` or `paramiko` for remote hosts. However,
    we could also use `local` to avoid a connection overhead when running things on
    the `localhost`. Most of the time we will be using either `local`, `winrm` or
    `ssh` here. |'
  prefs: []
  type: TYPE_TB
- en: '| `gather_facts` | Ansible will automatically run the setup module on the remote
    hosts unless we tell it not to. If we don''t need the variables from the setup
    module, we could set this now and save some time. |'
  prefs: []
  type: TYPE_TB
- en: The variable section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here, we can define variables that apply to the entire play on all machines.
    We can also make Ansible prompt for variables if they weren't supplied on the
    command line. This allows us to make easily maintainable plays, and prevents us
    from changing the same thing in several parts of the play. This also allows us
    to have the entire configuration for the play stored at the top, where we can
    easily read and modify it without worrying about what the rest of the play does.
  prefs: []
  type: TYPE_NORMAL
- en: Variables in this section of a play can be overridden by machine facts (those
    that are set by modules), but they themselves override the facts we set in our
    inventory. So they are useful to define defaults that we might collect in a module
    later, but they can't be used to keep defaults for inventory variables as they
    will override those defaults.
  prefs: []
  type: TYPE_NORMAL
- en: 'Variable declarations, which happen in the `vars` section, look like the values
    in the target section and contain a YAML dictionary or a list. An example looks
    like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Variables can also be loaded from external YAML files by giving Ansible a list
    of variable files to load. This is done in a similar way using the `vars_files`
    directive. Then simply provide the name of another YAML file that contains its
    own dictionary. This means that instead of storing the variables in the same file,
    they can be stored and distributed separately, allowing us to share our playbook
    with others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using `vars_files`, the files look like the following code snippet in our playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, Ansible looks for `country-AU.yml`, `datacenter-SYD.yml`,
    and `cluster-mysql.yml` in the `conf` folder relative to the playbook path. Each
    YAML file looks similar to the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can make Ansible ask the user for each variable interactively. This
    is useful when we have variables that we don't want to make available for automation,
    and instead require human input. One example where this is useful is when prompting
    for the passphrases used to decrypt secret keys for the HTTPS servers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can instruct Ansible to prompt for variables with the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, `https_passphrase` is where the entered data will be
    stored. The user will be prompted with `Key Passphrase`, and because `private`
    is set to `yes`, the value will not be printed on the screen as the user enters
    it.
  prefs: []
  type: TYPE_NORMAL
- en: We can use variables, facts, and inventory variables with the help of `{{ variablename
    }}`. We can even refer to complex variables, such as dictionaries, with a dotted
    notation. For example a variable named `httpd`, with a key in it named `maxclients`,
    will be accessed as `{{ httpd.maxclients }}`. This works with facts from the setup
    module too. For example, we can get the IPv4 address of a network interface named
    `eth0` using `{{ ansible_eth0.ipv4.address }}`.
  prefs: []
  type: TYPE_NORMAL
- en: Variables that are set in the variable section do not survive between different
    plays in the same playbook. However, facts gathered by the setup module or set
    by `set_fact` do. This means if we are running a second play on the same machines,
    or a subset of the machines in an earlier play, we can set `gather_facts` in the
    target section to `false`. The `setup` module can sometimes take a while to run,
    so this can dramatically speed up plays, especially in plays where the serial
    is set to a low value.
  prefs: []
  type: TYPE_NORMAL
- en: The task section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The task section is the last section of each play. It contains a list of actions
    that we want Ansible to perform in the order we want them to be performed. There
    are several styles in which we can express each module''s arguments. We suggest
    you try to stick with one as much as possible, and use the others only when required.
    This makes our playbooks easier to read and maintain. The following code snippet
    is what a task section looks like with all three styles shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we see the three different styles of syntax being used to install, configure,
    and start the Apache web server as it will look on a CentOS machine. The first
    task shows us how to install Apache using the original syntax, which requires
    us to call the module as the first keyword inside an `action` key. The second
    task copies Apache's configuration file into place using the second style of the
    task. In this style, use the module name in place of the `action` keyword and
    its value simply becomes its argument. Finally, the last task, the third style,
    shows how to use the service module to restart Apache. In this style, we use the
    module name as the key, as usual, but we supply the arguments as a YAML dictionary.
    This can come in handy when we are providing a large number of arguments to a
    single module, or if the module wants the arguments in a complex form, such as
    the cloud formation module. The latter style is quickly becoming the preferred
    way of writing playbooks, as an increasing number of modules require complex arguments.
    In this book, we will be using this style in order to save space for the examples
    and prevent line wrapping.
  prefs: []
  type: TYPE_NORMAL
- en: Note that names are not required for tasks. However, they make good documentation
    and allow us to refer to each task later on, if required. This will become useful
    especially when we come to handlers. The names are also outputted to the console
    when the playbook is run, so that the user can tell what is happening. If we don't
    provide a name, Ansible will just use the action line of the task or the handler.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike other configuration management tools, Ansible does not provide a fully
    featured dependency system. This is a blessing and a curse; with a complete dependency
    system, we can get to a point where we are never quite sure what changes will
    be applied to a particular machine. Ansible, however, does guarantee that our
    changes will be executed in the order they are written. So, if one module depends
    on another module that is executed before it, simply place one before the other
    in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The handlers section
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The handlers section is syntactically the same as the task section and supports
    the same format for calling modules. Handlers are called only when the task they
    were called from, records that something changed during execution. To trigger
    a handler, add a notify key to the task with the value set to the name of the
    task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Handlers are run if previously triggered when Ansible has finished running
    the task list. They are run in the order that they are listed in the handlers
    section, and even if they are called multiple times in the task section, they
    will run only once. This is often used to restart daemons after they have been
    upgraded and configured. The following play demonstrates how we will upgrade an
    **ISC** **DHCP** (**Dynamic Host Configuration Protocol**) server to the latest
    version, configure it, and set it to start at boot. If this playbook is run on
    a server where the ISC DHCP daemon is already running the latest version and the
    config files are not changed, the handler will not be called and DHCP will not
    be restarted. Consider the following code for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Each handler can only be a single module, but we can notify a list of handlers
    from a single task. This allows us to trigger many handlers from a single step
    in the task list. For example, if we have just checked out a newer version of
    any Django application, we can set a handler to migrate the database, deploy the
    static files, and restart Apache. We can do this by simply using a YAML list on
    the notify action. This might look something like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the `git` module is used to check out some public GitHub code,
    and if that caused anything to change, it triggers the `migrate db`, `generate
    static`, and `restart httpd` actions.
  prefs: []
  type: TYPE_NORMAL
- en: The playbook modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using modules in playbooks is a little bit different from using them in the
    command line. This is mainly because we have many facts available from the previous
    modules and the `setup` module. Certain modules don't work in the Ansible command
    line because they require access to those variables. Other modules will work in
    the command-line version, but are able to provide enhanced functionalities when
    used in a playbook.
  prefs: []
  type: TYPE_NORMAL
- en: The template module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the most frequently used examples of a module that requires facts from
    Ansible is the `template` module. This module allows us to design an outline of
    a configuration file and then have Ansible insert values in the right places.
    To perform this, Ansible uses the Jinja2 templating language. In reality, the
    Jinja2 templates can be much more complicated than this, including things such
    as conditionals, `for` loops, and macros. The following is an example of a Jinja2
    configuration template for configuring BIND:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By convention, Jinja2 templates are named with the file extension of `.j2`;
    however, this is not strictly required. Now let''s break this example down into
    its parts. The example starts with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This line adds a comment at the top of the file that shows which template the
    file came from, the host, modification time of the template, and the owner. Putting
    this somewhere in the template as a comment is a good practice, and it ensures
    that people know what they should edit if they wish to alter it permanently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later, on the fifth line, there is a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '`For` loops go through all the elements of a list once for each item in the
    list. They optionally assign the item to the variable of our choice so that we
    can use it inside the loop. This one loops across all the values in `ansible_all_ipv4_addresses`,
    which is a list provided by the `setup` module that contains all the IPv4 addresses
    that the machine has. Inside the `for` loop, it simply adds each of them into
    the configuration to make sure BIND will listen on that interface.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Comments are also possible in templates such as the one on line 24:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Anything in between `{#` and `#}` is simply ignored by the Jinja2 template processor.
    This allows us to add comments in the template that do not make it into the final
    file. This is especially handy if we are doing something complicated, setting
    variables within the template, or if the configuration file does not allow comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next few lines are part of an `if` statement, which sets up `zone_type`
    and `zone_dir` variables for use later in the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Anything between `{% if %}` and `{% else %}` is ignored if the statement in
    the `if` tag is `false`. Here we check whether the value `authorativenames` is
    in the list of group names that apply to this host. If this is `true`, the next
    two lines are set two custom variables. `zone_type` is set to master and `zone_dir`
    is set to data. If this host is not in the `authorativenames` group, `zone_type`
    and `zone_dir` will be set to `slave` and `slaves`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, starting at line 33, we provide the actual configuration for the zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We set the type to the `zone_type` variable we created earlier, and the location
    to `zone_dir`. Finally we check whether the zone type is a slave, and if it is,
    we configure its master to a particular IP address.
  prefs: []
  type: TYPE_NORMAL
- en: To get this template to set up an authoritative nameserver, we need to create
    a group in our inventory file named `authorativenames` and add some hosts under
    it. How to do this was discussed back in [Chapter 1](part0014.xhtml "Chapter 1. Getting
    Started with Ansible"), *Getting Started with Ansible*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply call the `templates` module and the facts from the machines will
    be sent through, including the groups the machine is in. This is as simple as
    calling any other module. The `template` module also accepts similar arguments
    to the `copy` module such as owner, group, and mode. Consider the following code
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The set_fact module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `set_fact` module allows us to build our own facts on the machine inside
    an Ansible play. These facts can then be used inside templates or as variables
    in the playbook. Facts act just like arguments that come from modules such as
    the `setup` module, in that they work on a per-host basis. We should use this
    to avoid putting complex logic into templates. For example, if we are trying to
    configure a buffer to take a certain percentage of RAM, we should calculate the
    value in the playbook.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to use `set_fact` to configure a MySQL server
    to have an InnoDB buffer size of approximately half of the total RAM available
    on the machine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The first task here simply installs MySQL using yum. The second task creates
    a fact by getting the total memory of the managed machine, dividing it by two,
    losing any non-integer remainder, and putting it in a fact called `innodb_buffer_pool_size_mb`.
    The next line then loads a template into `/etc/my.cnf` to configure MySQL. Finally,
    MySQL is started and set to start at boot time. A handler is also included to
    restart MySQL when its configuration changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The template then only needs to get the value of `innodb_buffer_pool_size`
    and place it into the configuration. This means we can re-use the same template
    in places where the buffer pool should be one-fifth of the RAM, or one-eighth,
    and simply change the playbook for those hosts. In this case, the template will
    look something like the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We can see that in the previous template, we are simply putting the variables
    we get from the play into the template. If the template doesn't see the `innodb_buffer_pool_size_mb`
    fact, it simply uses a default of `128`.
  prefs: []
  type: TYPE_NORMAL
- en: The pause module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `pause` module stops the execution of a playbook for a certain period of
    time. We can configure it to wait for a particular period, or we can make it prompt
    for the user to continue. While effectively useless when used from the Ansible
    command line, it can be very handy when used inside a playbook.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, the `pause` module is used when we want the user to provide confirmation
    to continue, or if manual intervention is required at a particular point. For
    example, if we have just deployed a new version of a web application to a server,
    and we need to have the user check manually to make sure it looks okay before
    we configure them to receive production traffic, we can put a pause there. It
    is also handy to warn the user of a possible problem and give them the option
    of continuing. This will make Ansible print out the names of the servers and ask
    the user to press *Enter* to continue. If used with the serial key in the target
    section, it will ask once for each group of hosts that Ansible is running on.
    This way we can give the user the flexibility of running the deployment at our
    own pace while they interactively monitor the progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Less usefully, this module can simply wait for a specified period of time.
    This is not useful always as we usually don''t know how long a particular action
    might take, and guessing might have disastrous outcomes. We should not use it
    for waiting for networked daemons to start up; instead we should use the `wait_for`
    module (described in the next section) for this task. The following play demonstrates
    using the `pause` module first in the user interactive mode and then in the timed
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The wait_for module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `wait_for` module is used to poll a particular TCP port and not continue
    until that port accepts a remote connection. The polling is done from the remote
    machine. If we only provide a port, or set the host argument to `localhost`, the
    poll will try to connect to the managed machine. We can utilize `local_action`
    to run the command from the controller machine and use the `ansible_hostname`
    variable as our host argument to make it try and connect to the managed machine
    from the controller machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'This module is particularly useful for daemons that can take a while to start,
    or things that we want to run in the background. Apache Tomcat ships with an init
    script, which immediately returns when we try to start it, leaving Tomcat starting
    in the background. Depending on the application that Tomcat is configured to load,
    it might take anywhere between two seconds to 10 minutes to fully start up and
    be ready for connections. We can time our application''s start up and use the
    `pause` module. However, the next deployment might take longer or shorter, and
    this will break our deployment mechanism. With the `wait_for` module, we have
    Ansible to recognize when Tomcat is ready to accept connections. The following
    is a play that does exactly this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: After the completion of this play, Tomcat should be installed, started, and
    ready to accept requests. We can append further modules to this example and depend
    on Tomcat being available and listening.
  prefs: []
  type: TYPE_NORMAL
- en: The assemble module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `assemble` module combines several files on the managed machine and saves
    them to another file on the managed machine. This is useful in playbooks when
    we have a `config` file which does not allow includes or globbing in its includes.
    This is useful for the `authorized_keys` file for say, the root user. The following
    play will send a bunch of SSH public keys to the managed machine, then make it
    assemble them all together and place it in the root user''s home directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: By now, this should all look familiar. We might note the `with_items` key in
    the task that copies the keys over, and the `{{ items }}` variable. These will
    be explained later in [Chapter 3](part0028.xhtml "Chapter 3. Advanced Playbooks"),
    *Advanced Playbooks*, but all we need to know now is that whatever item we supply
    to the `with_items` key is substituted into the `{{ items }}` variable, similar
    to how a `for` loop works. This simply lets us easily copy many files to the remote
    host at once.
  prefs: []
  type: TYPE_NORMAL
- en: The last task shows the usage of the `assemble` module. We pass the directory
    containing the files to be concatenated into the output as the `src` argument,
    and then pass `dest` as the output file. It also accepts many of the same arguments
    (`owner`, `group`, and `mode`) as the other modules that create files. It also
    combines the files in the same order as the `ls -1` command lists them. This means
    we can use the same approach as `udev` and `rc.d`, and prepend numbers to the
    files to ensure that they end up in the correct order.
  prefs: []
  type: TYPE_NORMAL
- en: The add_host module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `add_host` module is one of the most powerful modules that are available
    in playbooks. `add_host` lets us dynamically add new machines inside a play. We
    can do this using the `uri` module to get a host from our **Configuration Management
    Database** (**CMDB**) and then adding it to the current play. This module will
    also add our host to a group, dynamically creating that group if it does not already
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: The module simply takes a `name` and a `groups` argument, which are rather self-explanatory,
    and sets the hostname and groups. We can also send extra arguments, and these
    are treated in the same way in which extra values in the inventory file are treated.
    This means we can set `ansible_ssh_user`, `ansible_ssh_port`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we are using a cloud provider, such as RackSpace or Amazon EC2, there are
    modules available in Ansible that will let us manage our compute resources. We
    might decide to create machines at the start of the play, if we can''t find them
    in the inventory. If we do this, we can use this module to add the machines to
    the inventory so that we can configure them later. Here is an example of using
    Google Compute Modules to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The group_by module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to creating hosts dynamically in our play, we can also create groups.
    The `group_by` module can create groups based on the facts about the machines,
    including the ones we set up ourselves using the `add_fact` module explained earlier.
    The `group_by` module accepts one argument, `key`, which takes the name of a group
    the machine will be added to. By combining this with the use of variables, we
    can make the module add a server to a group based on its operating system, virtualization
    technology, or any other fact that we have access to. We can then use this group
    in the target section of any subsequent plays, or in templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'So if we want to create a group that groups the hosts by the operating system,
    we will call the module as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use these groups to install packages using the right packager.
    In practice, this is often used to avoid Ansible outputting lots of "skipped"
    messages while it is executing. Instead of adding `when` clauses to each task
    that needs to be skipped, we can create a group for machines where the action
    should happen and then use a separate play to configure those machines separately.
    Here is an example of installing an ssl private key across Debian and RedHat machines
    without using a `when` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The slurp module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `slurp` module grabs a file from the remote system, encodes it with base
    64, and then returns the result. We can utilize the register keyword in order
    to place the contents into a fact. When using the `slurp` module to fetch files,
    we should be wary of the file size. This module loads the entire file into memory,
    so using `slurp` with large files can consume all available RAM and cause our
    system to crash. Files also need to be transferred from the managed machine to
    the controller machine, and for large files, this could take a considerable amount
    of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combining this module with the copy module provides a way to copy files between
    two machines. This is demonstrated in the following playbook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that because the `slurp` module encodes the data with base 64, we have
    to use the jinja2 filter named `b64decode` to decode the data before the copy
    module can use it. Filters will be covered in more detail in [Chapter 3](part0028.xhtml
    "Chapter 3. Advanced Playbooks"), *Advanced Playbooks*.
  prefs: []
  type: TYPE_NORMAL
- en: Windows playbook modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Windows support is new to Ansible and as such, there aren't many modules available
    for it. Modules that are windows only are named beginning with `win_`. There are
    also a few modules available, which work on both Windows and Unix systems such
    as the `slurp` module, which we covered earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extra care should be taken in Windows modules to quote the path strings. Backslashes
    are an important character in both YAML, where they escape characters and in windows
    paths, where they denote directories. Because of this, YAML might confuse parts
    of our paths for escape sequences. To prevent this, we use single quotes on our
    strings. Additionally, if our path is a directory itself, we should leave off
    the trailing backspace so that YAML doesn''t confuse the end of the string with
    an escape sequence. If we have to end our path with a backslash, make it a double
    backslash, and the second one will be ignored. The following are some examples
    of correct and incorrect strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Cloud Infrastructure modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Infrastructure modules allow us to not only manage the setup of our machines,
    but also the creation of those machines themselves. Apart from this, we can also
    automate much of the infrastructure surrounding them. This can be used as a simple
    replacement for services such as Amazon Cloud Formation.
  prefs: []
  type: TYPE_NORMAL
- en: When creating machines that we want to manage in a later play in the same playbook,
    we will want to use the `add_hosts` module that we discussed earlier in the chapter
    to add the machine to the in-memory inventory so that it can be the target of
    further plays. We might also wish to run the `group_by` module to arrange them
    into groups as we would arrange other machines. The `wait_for` module should also
    be used to check that the machine is responding to SSH connections before trying
    to manage it.
  prefs: []
  type: TYPE_NORMAL
- en: The Cloud Infrastructure modules can be a bit complicated to use, so we will
    be showing how to setup and install the Amazon modules. For details on how to
    configure the other modules, see their documentation using `ansible-doc`.
  prefs: []
  type: TYPE_NORMAL
- en: The AWS modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The AWS modules work similar to how most AWS tools work. This is because they
    use the python **boto** library, which is popular with many other tools and follows
    the conventions of the original AWS tools that were released by Amazon.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is best to install boto the same way that we installed Ansible. For most
    use cases, we will be running the module on the managed machine, so we will only
    need to install the boto module there. We can install the boto library in the
    following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Centos/RHEL/Fedora: `yum install python-boto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Ubuntu: `apt-get install python-boto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pip: `pip install boto`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then we need to setup the correct environment variables. The easiest way to
    do this is by running the modules using the localhost connection on our local
    machine. If we do this, then the variables from our shell are passed through and
    automatically become available to the Ansible module. Here, are the variables
    that the boto library uses to connect to AWS:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Variable Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS_ACCESS_KEY` | This is the access key for a valid IAM account |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS_SECRET_KEY` | This is the secret key corresponding to the access key
    above |'
  prefs: []
  type: TYPE_TB
- en: '| `AWS_REGION` | This is the default region to use unless overridden |'
  prefs: []
  type: TYPE_TB
- en: 'We can set these environment variables in our example using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'These are just example credentials and will not work. Once we have these set,
    we can then use the AWS modules. In the next block of code, we combine several
    modules from this chapter to create a machine and add it to the inventory. Several
    features not yet discussed, such as `register` and `delegate_to`, are used in
    the following example, which will be covered in [Chapter 3](part0028.xhtml "Chapter 3. Advanced
    Playbooks"), *Advanced Playbooks*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the sections that are available in the playbook
    file. We also learned how to use variables to make our playbooks maintainable,
    how to trigger handlers when changes have been made, and finally, we looked at
    how certain modules are more useful when used inside a playbook. You can explore
    further modules provided with Ansible using the official documentation at [http://docs.ansible.com/modules_by_category.html](http://docs.ansible.com/modules_by_category.html).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking into the more complex features of playbooks.
    This will allow us to build more complex playbooks capable of deploying and configuring
    entire systems.
  prefs: []
  type: TYPE_NORMAL
