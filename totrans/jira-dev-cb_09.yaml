- en: Chapter 9. Remote Access to JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SOAP client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an issue via SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with custom fields and SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attachments and SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Work logs and time tracking via SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commenting on an issue via SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User and Group Management via SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Progressing an issue in workflow using SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing versions via SOAP
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Administration methods in SOAP API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a SOAP service in JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy a XML-RPC service within JIRA
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a Java XML-RPC client
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exposing services and data entities as REST APIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing Java client for REST API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen various ways to enhance the JIRA functionality in the previous
    chapters, but how do we communicate with JIRA from another application? What are
    the various methods of integrating third-party applications with JIRA? Or in simple
    words, how does JIRA expose its functionalities to the outside world?
  prefs: []
  type: TYPE_NORMAL
- en: JIRA exposes its functionalities via **REST**, **SOAP**, or **XML/RPC** interfaces.
    Only a handful of the full JIRA functionality is exposed via these interfaces
    but JIRA also lets us extend these interfaces. In this chapter, we will learn
    how to communicate with JIRA using these interfaces and add more methods into
    these interfaces by developing plugins. The focus of this chapter is more on SOAP
    with examples for other interfaces as well. The core principle for all the interfaces
    is the same.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a lot of methods in SOAP, most of which can be understood well
    from the API at [http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html](http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html).
    But there are some methods that need better understanding and those are the ones
    we will concentrate on in this chapter leaving the rest to the readers.
  prefs: []
  type: TYPE_NORMAL
- en: 'SOAP is usually the most preferred method of remote access but Atlassian is
    slowly moving towards REST as the preferred mode. A more detailed explanation
    of these interfaces can be found at: [http://confluence.atlassian.com/display/JIRADEV/JIRA+RPC+Services](http://confluence.atlassian.com/display/JIRADEV/JIRA+RPC+Services).'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a SOAP client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned previously, SOAP is currently the preferred mode of remote access
    in JIRA though Atlassian is slowly moving towards REST. SOAP has the most number
    of methods compared to REST or XML/RPC and is probably used the most in the plugins
    that we find around us. In this recipe, we will start with the basics and see
    how we can write a simple SOAP client.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Install Maven2 and configure a Java development environment. Make sure the RPC
    plugin is enabled in JIRA and the **Accept** **remote** **API** **calls** option
    is turned ON at **Administration** | **Global** **Settings** | **General** **Configuration**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to create a JIRA SOAP client:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the latest demo SOAP client distribution from the Atlassian public
    repository at: [http://svn.atlassian.com/svn/public/atlassian/rpc-jira-plugin/tags/](http://svn.atlassian.com/svn/public/atlassian/rpc-jira-plugin/tags/).
    This contains a Maven 2 project configured to use Apache Axis, and a sample Java
    SOAP client, which creates test issues at [http://jira.atlassian.com](http://jira.atlassian.com).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modify the `jira.soapclient.jiraurl` property in the `pom.xml` to point to your
    JIRA instance, the instance you want to connect to. By default, it points to [http://jira.atlassian.com](http://jira.atlassian.com).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Download the WSDL file of the instance you want to connect to. You can find
    the WSDL file under the `/src/main/wsdl` location. If it is not there, or if you
    want to download the WSDL afresh, run the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will download the WSDL from the configured JIRA instance (as in *Step*
    *2*) to `/src/main/wsdl/`. Skip the `jira.soapclient.jiraurl` property to download
    the Atlassian JIRA WSDL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create the client JAR. We can do this by running the following command to generate
    the sources from the WSDL and create the SOAP client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will generate a JAR file with all the necessary classes required. There
    is a second JAR file created with the dependencies (such as the axis) embedded
    in it. The latter will do a world of good if you are executing it from an environment
    without axis and other dependencies already configured in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the client program. Let us go with the simplest approach in this recipe,
    that is, to create a simple standalone Java class in Eclipse. Start by creating
    an Eclipse project by running the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: You can alternatively try other IDEs or even run from the command prompt, whichever
    is convenient. Make sure you add the client JAR created in *Step* *4* in the classpath.
    All set to write a simple program that just logs into our JIRA instance. From
    now on, it is just another web service invocation as detailed in the following
    steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the standalone Java class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Get the SOAP service locator:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Get the SOAP service instance from the locator by passing the URL of your JIRA
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start accessing the methods using the SOAP service instance. For example, the
    log in can be done as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The token retrieved here is used for all the other operations instead of logging
    in every time. You can see the token as the first argument in all other operations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, our SOAP Client is ready. Let us just try getting an issue using
    the key and print its key and ID to prove that this stuff works!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will find the output printed with the issue key and ID.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Hopefully, this gives you a fair idea to get started with your first SOAP client!
    There is a lot more you can do with the SOAP client some of which we will see
    in the coming recipes.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an issue via SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have seen how to create a SOAP client. We also saw
    how to use the client to connect to the JIRA instance and perform the operations,
    by taking 'browsing an issue' as an example. In this recipe, we will see how to
    create an issue using SOAP API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a JIRA SOAP client as mentioned in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Following are the steps to create an issue with the standard fields populated
    on it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As mentioned in the previous recipe, get the JIRA SOAP service stub and log
    in to the box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an instance of `RemoteIssue`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Populate the standard fields on the `RemoteIssue` as appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the `PROJECT_KEY`, `ISSUE_TYPE_ID`, `PRIORITY_ID` , and so on, are
    all valid values in your JIRA instance. `ISSUE_TYPE_ID` and `PRIORITY_ID` are
    IDs and not the name of the issue type and priority.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Set the components on the issue. An issue can have multiple components and
    hence we need to set an array of `RemoteComponent` objects as shown in the following
    block of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can have as many components as we want, provided the `id` instances are
    valid component IDs in the project we are creating the issue. Here, `id` is the
    unique ID you will find for the component when we browse a component, as shown
    in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-09-01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Set the **Fix** **for** **Versions** or **Affected** **Versions** similar to
    how we set the components:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, `VERSION_ID` the unique ID of the version and can be found while browsing
    the version as we did with components.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Invoke the create issue operation on the soap client by passing the authentication
    token and the `RemoteIssue` object we constructed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The issue should now be created and its details like the ID are available on
    the returned `RemoteIssue` object, which can be printed as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is just a classic example of invoking a web service from a Java application
    using Axis2\. Once the Java client is written as explained before, we can run
    the same and the issue will be created in the instance we have referenced in the
    client.
  prefs: []
  type: TYPE_NORMAL
- en: Following is a screenshot of an issue created in the TEST project at [http://jira.atlassian.com](http://jira.atlassian.com).
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-09-02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the issue gets populated with all the fields we have set on
    the `RemoteIssue` object.
  prefs: []
  type: TYPE_NORMAL
- en: Working with custom fields and SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to create an issue with its standard fields. In this recipe,
    we will deal with custom fields—**create**, **update,** and **read** their values.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in the previous recipe, create a JIRA SOAP client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, we will see the creation, updating, and browsing of custom
    field values separately in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an issue with custom field values
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating an issue with custom fields is pretty similar to creating issues with
    components or versions. All the custom fields are set on the issue using a single
    method `setCustomFieldValues`, which takes an array of `RemoteCustomFieldValue`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps explain how it''s done:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the custom fields that need to be set on the issue and find their IDs.
    The ID of a custom field is of the form `customfield_[id]` where `[id]` is the
    database ID of the custom field. This ID can be determined from the database,
    or by editing a custom field in the admin interface, and copying its ID from the
    URL, as shown in the following screenshot:![Creating an issue with custom field
    values](img/1803-09-03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `RemoteCustomFieldValue` for each of the custom fields identified.
    `RemoteCustomFieldValue` can be created as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The values that we pass—`CUSTOM_FIELD_VALUE1`, `CUSTOM_FIELD_VALUE2`, and so
    on—should be valid for the field or else will result in validation errors in the
    server. For single-value custom fields, the array will consist only of a single
    value. The second attribute takes a `parentKey` value that is used only for multidimensional
    fields such as Cascading select lists. For single-value and multi-value fields
    like select lists, multi select, and so on, the `parentKey` will be an empty string.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, `RemoteCustomFieldValue` is constructed for a cascading select
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The parent key will be used to construct the full key of the custom field.
    For example, a cascading select will have the full custom field key as `customfield_10061:1`
    where `customfield_10061` is the key of the parent and `:1` indicates the first
    child. In fact, the following two represent the same thing:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set the array of all the custom field values on the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the issue as usual:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Updating custom fields on an issue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Updating a custom field is much similar. However in the `updateIssue` method,
    it takes an array of `RemoteFieldValue` which could be a standard field or a custom
    field. In the case of a custom field, we should set the ID of the custom field
    (full ID if it''s a multidimensional field as `RemoteFieldValue` doesn''t take
    a parent key!) and an array of String values as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The issue can now be updated as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Here, `ISSUE_KEY` is the key of the issue to be updated.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the same `updateIssue()` method is used for updating standard fields
    as well but the only difference is that the `key` used in `RemoteFieldValue` will
    be the key of the standard field. The key of the standard field can be found from
    the `IssueFieldConstants` class.
  prefs: []
  type: TYPE_NORMAL
- en: Browsing custom fields on an issue
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Custom fields on an issue can be retrieved using the `getCustomFieldValues`
    method on `RemoteIssue`. It can then be printed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, `remoteCustomFieldValue.getValues()` returns an array of String representation
    of the custom field value.
  prefs: []
  type: TYPE_NORMAL
- en: Attachments and SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to add attachments on an issue via SOAP and
    browse existing attachments.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As in the previous recipes, create a JIRA SOAP client. Also, make sure attachments
    are enabled on the JIRA instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since JIRA4, attachments are added into an issue using `addBase64EncodedAttachmentsToIssue`
    method where as pre JIRA4 `addAttachmentsToIssue` method was used. The latter
    is still available though it is deprecated. There is also a known issue with the
    latter where it fails on large attachments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps to add attachments on an issue using `addBase64EncodedAttachmentsToIssue`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a File object using the path of the file to be uploaded. The file should
    be accessible via a valid URL.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The path should be valid in the context.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Read the contents of file into a Byte array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Create an encoded String from the Byte array using the `BASE64Encoder`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Do *Step* *1* to *Step* *3* for all the attachments that need to be uploaded
    and create a String array of the all the encoded data. In our case, we have only
    one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use the `encodedData` in the `addBase64EncodedAttachmentsToIssue` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: where ISSUE_KEY is the key of the issue where the files are attached and the
    String array (third argument) holds the names using which the attachments will
    be stored on issue.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `addAttachmentsToIssue` method will also work and is similar to the one
    mentioned earlier, except that we don''t encode the data. Instead of sending the
    files as a String array of encoded data, this method needs sending the files as
    an array of Byte arrays. Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the file into a Byte array as before:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create an array of these Byte arrays and add the read files into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can read as many files as you want and each will be read as a Byte array
    and will be added into files array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Invoke the `addAttachmentsToIssue` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Browsing the attachments on an issue can be done using the `getAttachmentsFromIssue`
    method. It returns an array of `RemoteAttachment` objects from which the details,
    such as `name`, `id`, and so on, can be retrieved. We can then construct the URL
    to the attachment using the information retrieved. Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Get the array of `RemoteAttachment` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `ISSUE_KEY` is the key of the issue we are browsing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Information about the attachment can be read from the `RemoteAttachment` object
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The URL of the attachment on the JIRA instance can be constructed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `BASE_URL` is the JIRA's base URL including context path.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Worklogs and time tracking via SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Time tracking in JIRA is a great feature that allows the users to track the
    time they spent on a particular issue. It lets the users to log the work as and
    when they spend time on an issue and JIRA will keep track of the original estimated
    time, actual time spent, and the remaining time. It also lets the users to adjust
    the remaining time to be spent on the issue, if needed!
  prefs: []
  type: TYPE_NORMAL
- en: While JIRA has a great user interface to let users log the work they are doing
    there at times, like when integrating with the third-party products, it is necessary
    to log the work using SOAP. In this recipe, we will see logging work using the
    SOAP API.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As shown in the previous recipes, create a JIRA SOAP client. Also, make sure
    that time tracking is enabled on the JIRA instance.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are different methods available to log work on an issue depending on
    what we need to with the remaining estimate on the issue. In all the cases, we
    need to create a `RemoteWorklog` object that holds the details of the work we
    are logging. The following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the `RemoteWorklog` object with the details as required:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the `setStartDate()` method takes a `Calendar` object as opposed to
    the `Date` object mentioned in the Javadocs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the appropriate method to add the previous worklog. For example, if you
    want to automatically adjust the remaining estimate on the issue, we can use the
    `addWorklogAndAutoAdjustRemainingEstimatenethod`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If you want to retain the remaining estimate, use `addWorklogAndRetainRemainingEstimate`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you want to add a new remaining estimate, use `addWorklogWithNewRemainingEstimate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will add the work done as `1d` `3h` and will reset the remaining estimate
    to `1d` (1 day) no matter how much the original estimate was.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step, we used the setter methods to populate the fields. As you
    might have guessed, the most important field is `timeSpent` which specifies a
    time duration in JIRA duration format, representing the time spent working on
    the worklog. In our example, we have used `1d 3h` which is translated to 1 day
    and 3 hours.
  prefs: []
  type: TYPE_NORMAL
- en: As in the previous code, we can also specify a `startDate` for the logged work,
    `groupLevel,` or `roleId`, which are used to restrict the visibility of the logged
    work and add a comment. Note that the ID shouldn't be set on the object as it
    will be automatically generated when the worklog is added on the issue. Also,
    the visibility can be set only for a group or for a role, not for both.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Updating and deleting worklogs works in the same way using the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`updateWorklogAndAutoAdjustRemainingEstimate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateWorklogAndRetainRemainingEstimate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateWorklogWithNewRemainingEstimate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteWorklogAndAutoAdjustRemainingEstimate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`deleteWorklogAndRetainRemainingEstimate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`updateWorklogWithNewRemainingEstimate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example for an update and a delete call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: All the existing worklogs on an issue can be browsed using `getWorklogs` method
    that returns an array of `RemoteWorklog` objects.
  prefs: []
  type: TYPE_NORMAL
- en: Commenting on an issue via SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will see how to manage comments on an issue.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a JIRA SOAP client as mentioned in the first recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Adding a comment on an issue using SOAP can be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a `RemoteCommentobject` and set the necessary fields using the setter
    methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the ID shouldn't be set on the object as it will be generated automatically
    when the comment is created on the issue. Also, the visibility can be set only
    for a group or for a role, not for both at the same time.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add the comment to the issue:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Comments on an issue can be retrieved using the `getComments` method, which
    returns an array of `RemoteComment` objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A comment can be edited using the `editComment` operation but we should check
    if we have the edit permission or not by using the `hasPermissionToEditComment`
    method as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a comment is not exposed via SOAP yet!
  prefs: []
  type: TYPE_NORMAL
- en: User and group management via SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let us now have a look at the user and group management using SOAP. This is
    really useful when the users and groups need to be managed from a third-party
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a SOAP client as mentioned in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating a group and user are pretty straightforward. The following is how
    we do it once the client is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Here, the first snippet creates a group with name `jtricks-test-group`. The
    third argument is a `RemoteUser` who can be added to the group as the first user
    when the group is created. We can leave it as null if the group has to be created
    empty.
  prefs: []
  type: TYPE_NORMAL
- en: The second snippet creates a user with the relevant details, such as `Name`,
    `Password`, `Full` `Name`, and `Email`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A user can be added to a group as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Here, group and user are `RemoteGroup` and `RemoteUser` objects respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'An existing user or group can be retrieved as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'The users in a group can be retrieved from the `RemoteGroup` object as shown
    next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Deleting a user or group is also straightforward as shown next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Here, `swapGroup` identifies the group to change the comment and work log visibility
    to.
  prefs: []
  type: TYPE_NORMAL
- en: Progressing an issue in workflow using SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is something everyone wants to do when JIRA is integrated with third-party
    applications. The status of an issue needs to be changed for various use cases
    and the right way to do this is to progress the issue through its workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Progressing will move the issue to the appropriate statuses and will fire the
    appropriate post functions and events. In this recipe, we will see how to do the
    same.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, create a SOAP client if you have not already done so.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'JIRA exposes the method, `progressWorkflowAction` to progress an issue through
    its workflow. The following are the steps to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the ID of the action that we should execute from the current state.
    For every issue status, there is a step associated with it and there are zero
    or more transitions to the other steps in the workflow.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The action ID can be identified from the workflow screen within brackets alongside
    the transition name, as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![How to do it...](img/1803-09-04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: The previous screenshot shows the JIRA default workflow and the action ID for
    **Resolve** **Issue** from **Open** status is **5**. Note that the same action
    from different states can have a different ID if they are not sharing the common
    actions. So, it is important that we identify the action ID before proceeding
    to *Step* *2*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might have to store these action IDs on the client side when implementing
    a full-fledged application as JIRA doesn't expose a method to retrieve action
    ID based on the current *state*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The ID can also be retrieved from the XML by looking up the `action` element:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A workflow can be exported to XML from the **Administration** | **Workflows**
    screen by clicking on the XML link.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Identify the set of fields that need to be modified during the transition and
    create a `RemoteFieldValue` object for each of them. You can only modify those
    fields that are available on the workflow transition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In our example, we use the JIRA default workflow''s **Resolve** **Issue** action
    and it has the **Resolve** **Screen** associated with it. We have the fields **Assignee**
    and **Resolution** on the screen and hence we can create the `RemoteFieldValue`
    objects for them as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `RemoteFieldValue` takes the ID and an array of String values representing
    the value we need to set. In our example, the fields are single value fields and
    hence the array has only a single element. Multidimensional fields such as cascade
    fields should have the fully qualified ID as we have seen earlier in this chapter
    while updating custom fields. The full list of standard field IDs can be found
    at the `IssueFieldConstants` class. Any fields that are not in the transition
    screen will be ignored.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Execute the `progressWorkflowAction` using these attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we wind up this recipe, the current status on an issue can be found from
    the `RemoteIssue` object using the `getStatus` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Managing versions via SOAP
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen how to add versions as a fix for versions or affected versions
    on an issue. But how do we create those versions using SOAP? In this recipe, we
    will see how to create versions in a project and manage them!
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As usual, create the SOAP client.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A new version can be added into a project as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a `RemoteVersion` object with the necessary details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `sequence` defines the order in which the version will appear in the
    version list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create the version using `addVersion` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: where `TST` is the project key in which the new version is created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once a version is created, you can release the version using `releaseVersion`
    method. It takes a `RemoteVersion` as an input and needs the released flag to
    be set on it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: The same method can be used to `unrelease` a version. All you need to do is
    to set the `released` flag to `false`!
  prefs: []
  type: TYPE_NORMAL
- en: If the `released` flag is set to `true` and the version is already released,
    an error is thrown. This is the same case while trying to `unrelease` a version
    that is not yet released.
  prefs: []
  type: TYPE_NORMAL
- en: Archiving a version works similar to releasing a version. Here, the archived
    flag is passed as an argument instead of setting the released flag. Also, here
    the version name is used instead of a `RemoteVersion` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: All the versions in a project can be retrieved using the `getVersions` method,
    which returns an array of `RemoteVersion` objects.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: Administration methods in SOAP API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we wind up the various useful methods in SOAP API, we can have a look
    at the administration methods. In this recipe, we will be concentrating on some
    methods revolving around the creation of projects and permissions. Remaining methods
    are an easy read once you have a fair idea on the ones we are discussing in this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create the SOAP client as we discussed in the previous recipes.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can have a look at the journey of creating a permission scheme, creating
    a project using it and adding some users into the project roles. Other schemes
    used during creation of the project like notification scheme and issue security
    scheme are not supported via SOAP.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following are the steps for our journey:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create the new Permission scheme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we use the `createPermissionScheme` method to create a new permission
    scheme by passing the authentication token, a name, and a description. Note that
    we can instead get an existing permission scheme from the list retrieved using
    the `getPermissionSchemes` method.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add relevant permissions to the newly created permission scheme using the `addPermissionTo`
    method. This step is relevant only if we are creating a new permission scheme:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, `adminPermission` should be a `RemotePermission` which is in the list
    of `RemotePermission` objects retrieved using `getAllPermissions` method. For
    example, the **Administer** **Project** permission can be obtained as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `23L` is the ID of the **Administer** **Project** permission. The IDs
    of other permissions can be found at `com.atlassian.jira.security.Permissions`
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The final argument to `addPermissionTo` method is a `RemoteEntity`, which can
    be a `RemoteUser` or a `RemoteGroup` object. We have seen accessing users and
    groups via SOAP in the previous recipes. In our example, we get a user by name
    as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the project using `createProject` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are the arguments:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**token - Authentication Token**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**key - Project Key**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**name - Project Name**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**description - Project Description**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**url - URL of the project**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**lead - Project Lead**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**permissionScheme - Permission Scheme for the project of type RemotePermissionScheme**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**notificationScheme - Notification Scheme for the project of type RemoteScheme**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**issueSecurityScheme - Issue Security Scheme for the project of type RemoteScheme**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the schemes, we use the newly created permissions schemes and leave the
    other two as null. We can specify a specific notification scheme or issue security
    scheme with a `RemoteScheme` object created by populating the correct ID of the
    relevant schemes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add an actor to the newly created Project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the `addActorsToProjectRole` method takes an array of actors (only `jobinkk`
    in this case), the role to which the actor should be added, project we have created,
    and the type of the actor.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The project role can be retrieved using the role ID as shown :'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The actor type can either be `atlassian-user-role-actor` or `atlassian-group-role-actor`
    depending on whether the actor we have added in the array is a user or a group.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We should now have the project created with the new permission scheme and with
    the member(s) we added to the relevant roles.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the method is executed, we can find the project created as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-09-05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The new permission scheme is created as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-09-06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here only one permission is added, that is to administer the project. We can
    add the rest in a similar fashion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the project members are added as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-09-07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the default actors will be part of the membership in addition
    to the one we have added!
  prefs: []
  type: TYPE_NORMAL
- en: 'There are lot of other useful methods in the SOAP API which can be found at:
    [http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html](http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/soap/JiraSoapService.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you look at the right Java Docs for your version of JIRA!
  prefs: []
  type: TYPE_NORMAL
- en: Deploy a SOAP service in JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far we have seen various methods to perform various operations in JIRA via
    SOAP. But what about operations that are not supported by SOAP? That little something
    which prevents you from integrating your JIRA with your third-party app? Here
    is where the **RPC** **Endpoint** **Plugin** **Module** is useful.
  prefs: []
  type: TYPE_NORMAL
- en: The RPC End Point Plugin module lets us deploy new SOAP and XML-RPC end points
    within JIRA. The new end points added will not be a part of the existing WSDL.
    Instead, they are available on a new URL and hence you will have to access both
    the web services if you want to access the new methods and other existing methods.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to deploy a new SOAP end point to perform a
    new operation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK. As I write this, PRC plugin
    is still v1, so make sure to create a v1 plugin if [https://jira.atlassian.com/browse/JRA-22596](https://jira.atlassian.com/browse/JRA-22596)
    isn't resolved yet!
  prefs: []
  type: TYPE_NORMAL
- en: Also, make sure **Accept** **Remote** **API** **Calls** option is turned on
    under **Administration** | **General** **Configurations**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us create a SOAP RPC plugin to expose a new method, `getProjectCategories`,
    that retrieves all the project categories in the JIRA instance This is a simple
    method but will hopefully help us in covering all the basics of creating a new
    SOAP RPC end point.
  prefs: []
  type: TYPE_NORMAL
- en: Add the RPC plugin dependency in the `pom.xml` to get hold of the existing RPC
    classes. Change the version accordingly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This JAR is a part of the JIRA installation. So, if your maven build fails
    looking for the JAR, just navigate to `WEB-INF/lib` folder and install the JAR
    into your local maven repository as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Declare the new RPC service in the `atlassian-plugin.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the SOAP RPC plugin module has a unique `key` and it declares a new `interface`
    for your SOAP module and an implementation `class` for it. In this case, we have
    `JTricksSoapService` and `JTricksSoapServiceImpl`. The service path `jtricksservice`
    defines where in the URL namespace the services will be published and will appear
    in the URL of the WSDL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Create a **Component** **Plugins** module for this new class to avoid the client
    getting a null pointer exception:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the new method in the interface as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see we have added a method `getProjectCategories` that returns an
    array of `RemoteCategory` objects. We have added a login method as well so that
    we can test this by accessing just the new WSDL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the `RemoteCategory` bean. Make sure the new bean extends `AbstractNamedRemoteEntity`
    class. The bean should have all the required attributes with getters and setters
    defined for it. `AbstractNamedRemoteEntity` already exposes the field name and
    hence will be available for `RemoteCategory`. We will add a new field `description`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the constructor takes a `GenericValue` and sets the description
    from it. In the super class, `AbstractNamedRemoteEntity`, name is set likewise.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Implement the `getProjectCategories` method in the implementation class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, all we do is to get the collection of project categories and return an
    array of `RemoteCategory` objects initialized using the category `GenericValue`
    objects. Note that the `getProjectCategories()` method is deprecated from JIRA
    4.4 and it is advised to use `getAllProjectCategories()` method that returns a
    Collection of `ProjectCategory` objects instead of the `GenericValue`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you have noticed, we validate the *token* first before returning the categories.
    The validation is done as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We retrieve the user using the token and throws the appropriate error if the
    token is not valid. The `ProjectManager` and `TokenManager` classes can be injected
    in the constructor as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that from JIRA 4.4, `retrieveUserNoPermissioncheck` method should be used
    instead of `retrieveUser` as some JIRA instances may want to allow anonymous access.
    Individual methods will do the permission checks.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Implement the `login` method to return the token.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It simply uses `TokenManager` to return a *token* created from the username
    and password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compile the plugin and deploy it. As it is v1, make sure the plugin is dropped
    into the `WEB-INF/lib` folder.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once the plugin is deployed, the new WSDL should be available at: `{your_jira_url}/rpc/soap/jtricksservice?WSDL`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-09-08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the new methods that we exposed via the interface are now visible
    in the WSDL file at the circled locations in the previous screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: Deploy a XML-RPC service within JIRA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipe, we have seen how to deploy a SOAP service within JIRA.
    In this one, we will see how to deploy a XML-RPC service.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK. Here again, we are developing
    a v1 plugin. So, make sure the `atlassian-plugin.xml` doesn't have the Version
    2 attribute in it.
  prefs: []
  type: TYPE_NORMAL
- en: And yes, make sure **Accept** **Remote** **API** **Calls** option is turned
    **ON**, as in the previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in the case of SOAP plugin, let us expose a new method, `getProjectCategories`,
    that retrieves all the project categories in the project. The following are the
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the RPC plugin dependency in the `pom.xml` to get hold of the existing
    RPC classes. Change the version accordingly:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare the new RPC service in the `atlassian-plugin.xml`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we define a class, `XmlRpcServiceImpl` and a `service-path`. The service
    path, jtricks, is used to access the new methods in place of the default `jira1`
    path used in accessing the existing methods.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create an interface for the class, with `XmlRpcServiceImpl` named as `XmlRpcService`
    and define the new methods in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As before, we have a `login` method as well. If you have noticed, the return
    type of the `getprojectCategories` method is a `Vector` instead of an array of
    `RemoteCategory` objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: All the methods in the RPC interface should return a `Vector` if it is returning
    a list of objects and a `HashTable` if it is returning a single object (`GenericValue`).
    The Vector will be made of one or more `Hashtables` each representing a `GenericValue`
    in the list.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `RemoteCategory` as defined in the previous recipe. We will create
    a `Vector` from an array of `RemoteCategory` objects to return the project category
    details:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `XmlRpcServiceImpl` class. The `getprojectCategories` method
    is implemented as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we create an array of `RemoteCategory` objects and then create a Vector
    from it using the `RpcUtils` utility class. The class, behind the scenes, converts
    the array of `RemoteCategory` objects into a Vector of `Hashtables`, each `Hashtable`
    representing a `RemoteCategory`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we want to return a single `RemoteCategory` object instead of an array,
    we should return it as a `Hashtable` constructed as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As mentioned earlier, use the `getAllProjectCategories` method from JIRA4.4\.
    Implement the `login` and `validateToken` methods, as discussed in the previous
    recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Compile the plugin and deploy it. As it is v1, make sure the plugin is dropped
    into the `WEB-INF/lib` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the plugin is deployed, the new methods can be accessed using the new service
    path as `jtricks.getprojectCategories`. More details about how to access an XML-RPC
    method can be found in the next recipe.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Writing a Java XML-RPC client*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a Java XML-RPC client
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous recipes, we saw how to create a SOAP client and use it to connect
    to JIRA from an external third-party application. We have also seen ways of exposing
    new methods in JIRA through SOAP and XML-RPC interfaces. In this recipe, we will
    see how to invoke an XML-RPC method from a client application written in Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Javadocs for XML-RPC client can be found at: [http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/xmlrpc/XmlRpcService.html](http://docs.atlassian.com/software/jira/docs/api/rpc-jira-plugin/latest/com/atlassian/jira/rpc/xmlrpc/XmlRpcService.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure **Accept** **Remote** **API** **Calls** option is turned **ON** in
    JIRA under **Administration** **|** **Global** **Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let us try to retrieve the list of projects using XML-RPC service deployed
    within JIRA. Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Maven2 project and add the dependency for `Apache2 xml-rpc` libraries.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the version of `xml-rpc` libraries we have used in this recipe is
    Version 1.1.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Java client. In this example, we will create a standalone Java class
    with all the libraries in the `classpath`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Instantiate the `XmlRpcClient` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, the `JIRA_URI` is the URI of your JIRA instance, [http://jira.atlassian.com](http://jira.atlassian.com),
    for example, `RPC_PATH` will be `/rpc/xmlrpc`, which will be the same even for
    new methods exposed via plugins. In this case, the full path will be: [http://jira.atlassian.com/rpc/xmlrpc](http://jira.atlassian.com/rpc/xmlrpc).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we are using XML-RPC v2 here. Check out the syntax for the version
    you are using!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Log in to JIRA by invoking the `login` method as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can learn from the Javadocs, the method expects a username and password,
    which are passed into the execute method on the client as a Vector object. The
    first argument is the method name which is preceded with the namespace under which
    the methods are exposed. In this case, it is `jira1` and is equivalent to the
    service path we have seen in the previous recipe. The full method name will hence
    become `jira1.login`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the case of the `login` method, the return object is an authentication token
    which is a String object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Retrieve the list projects using the `getProjectsNoSchemes` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here again, we need to send a `Vector` as input along with the method name,
    in this case, with the authentication token in the `Vector`. If we need to invoke
    a method that needs a complex object in scenarios like creating an issue, we should
    create a `HashTable` with the input parameters as key/value pairs and add it into
    the `Vector`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The return type in this case is type cast into a `List`. This will be a `List`
    of map objects, each map representing a `RemoteProject` with the details of the
    project in it as key/value pairs. For example, the name of the project can be
    accessed from the map using the key name, as shown in the next step.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Retrieve the details of projects from the list. Details will be the attributes
    of the project published with the getter/setter methods in the `RemoteProject`
    object, such as name, lead, and so on.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As mentioned in the previous step, the details can be retrieved as key/value
    pairs from the Map objects representing a project. This same logic applies to
    all XML-RPC methods where complex objects are retrieved as Maps with key/value
    pairs in it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Log out from JIRA:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here the output is converted to Boolean as the method returns a Boolean.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we try to get the list of categories using the new method exposed in the
    previous recipe, the code will look similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that the method name here is prefixed with jtricks as it is the service
    path used in the RPC Endpoint Plugin Module. Everything else works the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Expose services and data entities as REST APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to expose JIRA functionalities via SOAP and XML-RPC
    interfaces, it is time to move to REST APIs. Similar to the RPC Endpoint Plugin
    Module Type, JIRA also has a REST Plugin module type using which services or data
    can be exposed to the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will see how to expose the `getProjectCategories` method
    we have used as examples in the previous recipes using the REST interface.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Create a skeleton plugin using Atlassian Plugin SDK. The plugin should be v2
    for it to work.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following is a step-by-step procedure to create a REST plugin to expose the
    `getProjectCategories` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the maven dependencies require for REST to the `pom.xml` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that all the dependencies are of scope provided as they are already available
    in the JIRA runtime.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add the REST plugin module into the `atlassian-plugin.xml`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the path and version defines the full path where the resources will be
    available only after the plugin is deployed. In this case, the full path will
    become `BASE_URL/rest/jtricks/1.0/` where `BASE_URL` is the JIRA base URL.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Define the data that will be returned to the client. JAXB Annotations are used
    to map these objects to XML and JSON formats.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In our example, the `getCategories` method should return a List of Category
    objects and hence we need to define a Categories object and a Category object,
    the former containing a List of the latter. For both the objects, we should use
    the Annotations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `Category` object as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure the annotations are used properly. The `@XmlRootElement` annotation
    maps a class or an Enum type to an XML element and is used for the categories
    in this case. `@XmlElement` maps a property or field to an XML Element. Other
    annotations available are `@XmlAccessorType` and `@XmlAttribute` used for controlling
    whether fields or properties are serialized by default and mapping a property
    or field to an XML Attribute respectively.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The details can be read at: [http://jaxb.java.net/nonav/jaxb20-pfd/api/javax/xml/bind/annotation/package-summary.html](http://jaxb.java.net/nonav/jaxb20-pfd/api/javax/xml/bind/annotation/package-summary.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Make sure a public non-argument constructor is available so as to render the
    output properly when accessed via the direct URL. Also, note that only the annotated
    elements will be exposed via the REST API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Define the `Categories` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Same rules apply here as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create the `Resource` class. On the package level or the class level or the
    method level, we can have `@Path` annotations to define the path where the resource
    should be available. If it is available on all the levels, the final path will
    be a cumulative output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This means that if you have `@Path("/X")` at package level, `@Path("/Y")` at
    class level, and `@Path("/Z")` at method level, the resource is accessed at:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Different methods can have different paths to differentiate between each other.
    In our example, let us define a path `/categories` at class level:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Write the method to return the `Categories` resource:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, the method doesn't have a `@Path` annotation and hence will
    be invoked at the URL, `BASE_URL/rest/jtricks/1.0/category`. Here, we normally
    construct a `Categories` object with a simple bean class and then use the `ResponseBuilder`
    to create the response.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `@GET` annotation mentioned earlier denotes that the class method will handle
    requests for a GET HTTP message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Other valid annotations include POST, PUT, DELETE, and so on, and can be viewed
    in detail at:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[http://jsr311.java.net/nonav/javadoc/javax/ws/rs/package-summary.html](http://jsr311.java.net/nonav/javadoc/javax/ws/rs/package-summary.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`@AnonymousAllowed` indicates that the method can be called without supplying
    user credentials. `@Produces` specifies the content types the method may return.
    The method can return any type if this annotation is absent. In our case, the
    method must return an XML or JSON object.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Two other useful annotations are: `@PathParam` and `@QueryParam`. `@PathParam`
    maps a method variable to an element in the `@Path` whereas `@QueryParam` maps
    a method variable to a query parameter.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The following is how we use each of them:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Following is an example of how `@QueryParam` is used:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we take a query parameter named `dummyParam,` which can then be used
    within our method. The resource will then be accessed as follows: `BASE_URL/rest/jtricks/1.0/category?dummyParam=xyz`.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In this case, you will see that the value xyz is printed into the console.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let us say we want to pass the ID of a category as well in the path and get
    the details of that `Category` alone; we can use the `PathParam` here as shown
    earlier. In that case, the URL to this method will be as shown:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, 10010 is the category ID passed into the previously described method as
    id.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When query parameters are used, the resource will not be cached by a proxy or
    your browser. So if you are passing in an ID to find some information about some
    sort of entity, then use a path parameter. This information will then be cached.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Package the plugin and deploy it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you have deployed the plugin with both the `getCategories()` method and
    `getCategoryFromId()` method seen earlier, the list of categories can be retrieved
    at the URL: `BASE_URL/rest/jtricks/1.0/category`, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-09-09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The details of a particular category can be retrieved using the ID in the path,
    `BASE_URL/rest/jtricks/1.0/category/10001` for example, as shown in the next screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1803-09-10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Atlassian has published some guidelines at: [http://confluence.atlassian.com/display/REST/Atlassian+REST+API+Design+Guidelines+version+1](http://confluence.atlassian.com/display/REST/Atlassian+REST+API+Design+Guidelines+version+1),
    which is a very useful read before developing your production version of REST
    service plugin. Check out: [http://confluence.atlassian.com/display/REST/REST+API+Developer+Documentation](http://confluence.atlassian.com/display/REST/REST+API+Developer+Documentation)
    for more details.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing Java client for REST API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will quickly see how we can create a Java client to communicate
    with JIRA using the REST APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Make sure **Accept** **Remote** **API** **Calls** option is turned **ON** in
    JIRA under **Administration** | **Global** **Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In order to connect to JIRA using REST APIs, Atlassian has developed a JIRA
    REST Java Client Library, called JRJC in short. It provides a thin layer of abstraction
    on top of the REST API and related HTTP(S) communication and gives a domain object
    model to represent the JIRA entities, such as issues, priorities, resolutions,
    statuses, users, and so on. The REST API and the JRJC Library are in alpha phase
    and are quickly evolving! The status of the library can be viewed at: [https://studio.atlassian.com/wiki/display/JRJC/Home](https://studio.atlassian.com/wiki/display/JRJC/Home).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using JRJC to connect to our JIRA instance using the standalone
    Java program. Following are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Maven project and add the JRJC dependency to the `pom.xml` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Make sure you use the appropriate version of JRJC. All the versions can be found
    in the maven repository under [https://maven.atlassian.com/public/com/atlassian/jira/jira-rest-java-client/](https://maven.atlassian.com/public/com/atlassian/jira/jira-rest-java-client/).
    If you are not using Maven, the full dependencies are listed in the Atlassian
    documentation at [https://studio.atlassian.com/wiki/display/JRJC/Project+Dependencies](https://studio.atlassian.com/wiki/display/JRJC/Project+Dependencies).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Create a Java project by running `maven eclipse:eclipse` if you are using Maven
    or create the project using your favorite IDE and add all dependencies listed
    earlier in the class path. Once done, create a standalone Java class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a connection to the JIRA server
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we instantiate the `JerseyJiraRestClientFactory` and use the `createWithBasicHttpAuthentication`
    method to instantiate the REST client by passing the username and password.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: RESTful architecture promotes stateless connection and hence there is no notion
    of the user session. This means the credentials will be send back and forth in
    plain text, just encoded with `Base64`, for each request and so it is not safe
    to use it outside a firewall or company network.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initiate the `ProgressMonitor`. All REST remote calls take this as a parameter.
    As per Atlassian docs, first, it serves as a clear marker of a remote call and
    second, in the future, they plan to make this interface capable of reporting the
    progress and cancelling (where possible) the remote requests taking too much time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As of now, we initiate it as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the appropriate client needed for the operation. The `jiraRestClient`
    exposes a set of clients, such as `IssueRestClient`, `ProjectRestClient`, `SearchClient`,
    and so on, each one exposing the related set of operations. In this example, we
    will try to retrieve an issue and hence will go for the `IssueRestClient`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Retrieve the issue details and print it. Alternatively, perform the required
    operation as appropriate:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, the issue is `com.atlassian.jira.rest.client.domain.Issue!`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Various other operations can be performed on the issue, details of which can
    be found in the Javadocs at [http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html](http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For example, we can vote on the issue as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The API for this is available at [http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html](http://docs.atlassian.com/jira-rest-java-client/0.2.1/apidocs/com/atlassian/jira/rest/client/IssueRestClient.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Some operations are a little more complex. For example, in order to progress
    the issue through its workflow, you will need the appropriate transition ID, the
    fields needed during the transition, and optionally a comment. We can do it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the available transitions from the issue.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Find the relevant transition by name or ID as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a list of fields needed during the transition. This can be empty if
    the fields are not mandatory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a `Comment` object if needed:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Transition the issue as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You will see that the issue is progressed in the workflow by executing the transition
    we selected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the various methods can be executed using the appropriate clients.
    Given the fact that JIRA REST API is evolving so quickly, JRJC has a lot of potential
    and is worth investing time in.
  prefs: []
  type: TYPE_NORMAL
