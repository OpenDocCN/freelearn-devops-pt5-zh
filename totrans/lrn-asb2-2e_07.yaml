- en: Chapter 7.  Creating a Custom Module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on how to write and test custom modules. We've already
    discussed how modules work and how to use them within your tasks. Well, just for
    a quick recap, a module in Ansible is a piece of code, which is transferred and
    executed on your remote host every time you run an Ansible task (it can also run
    locally if you've used `local_action`).
  prefs: []
  type: TYPE_NORMAL
- en: From my experience, I've seen custom modules being written whenever a certain
    functionality needs to be exposed as a first-class task. The same functionality
    could have been achieved without the module, but it would have required a series
    of tasks with existing modules to accomplish the end goal and often also command
    and shell modules. For example, let's say you wanted to provision a server via
    **Preboot Execution Environment** (**PXE**). Without a custom module, you would
    have probably used a few shell or command tasks to accomplish the same. However,
    with a custom module, you would just pass the required parameters to it and the
    business logic will be embedded within the custom module in order to perform the
    PXE boot. This gives you the ability to write playbooks that are much simpler
    to read and a bigger reusability of the code, since you create the module once
    and you can use it everywhere, in your roles and playbooks.
  prefs: []
  type: TYPE_NORMAL
- en: The arguments that you pass to a module, provided they are in a key-value format,
    will be forwarded in a separate file along with the module. Ansible expects at
    least two variables in your module output, (that is, the result of the module
    run) whether it passed or failed, and a message for the user, and they both have
    to be in the JSON format. If you adhere to this simple rule, you can customize
    as much as you want!
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Python modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bash modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ruby modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you choose a particular technology or tool, you generally start with what
    it offers. You slowly understand the philosophy behind building the tool and what
    problems it helps you solve. However, you truly feel comfortable and in control
    only when you understand in depth how it works. At some stage, to utilize the
    complete power of a tool, you'll have to customize it in ways and means that suit
    your particular needs. Over a period of time, tools that provide you with an easy
    way to plug in new functionalities stay, and those that don't, disappear from
    the market. It's a similar story with Ansible as well. All tasks in Ansible playbooks
    are modules of some kind and it comes loaded with hundreds of modules. You will
    find a module for almost everything you might need. However, there are always
    exceptions. This is where the power to extend it comes in.
  prefs: []
  type: TYPE_NORMAL
- en: Chef provides **Lightweight Resources and Providers** (**LWRPs**) to perform
    this activity and Ansible allows you to extend its functionality using custom
    modules. The significant difference, however, is that you can write the module
    in any language of your choice (provided you have an interpreter of that language),
    whereas in Chef, the module has to be in Ruby. Ansible developers recommend using
    Python for any complex module, as there is out-of-the-box support to parse arguments;
    almost all ***nix** systems have Python installed by default and Ansible itself
    is written in Python. To be complete, in this chapter we will also see how you
    can write modules in other languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make your custom modules available to Ansible, you can do one of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Specify the path to your custom module in the environment variable `ANSIBLE_LIBRARY`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `--module-path` command-line option
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drop the modules in the `library` directory in your Ansible top-level directory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this background information, let's look at some code!
  prefs: []
  type: TYPE_NORMAL
- en: Using Python modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Ansible intends to allow users to write modules in any language. Writing the
    module in Python, however, has its own advantages. You can take advantage of Ansible''s
    libraries to shorten your code, an advantage not available for modules in other
    languages. Parsing user arguments, handling errors, and returning the required
    values becomes easier with the help of the Ansible libraries. We will see two
    examples for a custom Python module, one with and one without using the Ansible
    library, to give you a glimpse of how custom modules work. Make sure you organize
    your directory structure as mentioned in the previous section before creating
    the module. The first example creates a module named `check_user`. To do so, we
    will need to create the `check_user` file in the `library` folder within the Ansible
    top-level directory, with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding custom module, `check_user`, will check whether a user exists
    on a host. The module expects a user argument from Ansible. Let''s break down
    the preceding module and see what it does. We first declare the **Interpreter**
    (Python) and import the libraries required to parse the arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `sys` library, we then parse the arguments, which are passed in a
    file by Ansible. The arguments are in the format `param1=value1 param2=value2`
    where `param1` and `param2` are parameters and `value1` and `value2` are values
    of the parameters. There are multiple ways to split arguments and create a dictionary
    and we''ve chosen an easy way to perform the operation. We first create a list
    of arguments by splitting the arguments with a whitespace character, and then
    separate the key and value by splitting the arguments with an `=` character and
    assigning it to a Python dictionary. For example, if you have a string such as
    `user=foo gid=1000`, then you will first create a list, which will look like `["user=foo",
    "gid=1000"]` and then loop over this list to create a dictionary. This dictionary
    will look like `{"user": "foo", "gid": 1000}`. This is performed by the following
    lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We separate the arguments based on a whitespace character because this is the
    standard followed by core Ansible modules. You can use any separator instead of
    a whitespace, but we would encourage you to maintain uniformity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the user argument, we then check whether that user exists on the
    host as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `pwd` library to check the `passwd` file for the user. For the sake
    of simplicity, we use two variables: one to store the success or failure message
    and the other to store the message for the user. Finally, we use the variables
    created in the `try-catch` block to check if the module succeeded or failed, as
    you can see in this snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If the module succeeds, then we will exit the execution with an exit code 0
    [`exit(0)`]; else, we will exit with a non-zero code. Ansible will look for the
    failed variable and if it is set to `True`, it will exit unless you have explicitly
    asked Ansible to ignore errors using the `ignore_errors` parameter. You can use
    customized modules like any other core module of Ansible. To test the custom module,
    we will need a playbook, so let''s create the file `playbooks/check_user.yaml`
    with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we used the `check_user` module like any other core module.
    Ansible will execute this module on the remote host by copying the module to the
    remote host with arguments in a separate file. Let''s see how this playbook runs
    with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As expected, since we have the `root` user, but not the `this_user_does_not_exists`,
    it passed the first check, but failed at the second.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible also provides a Python library to parse user arguments and handle errors
    and returns. It''s time to see how the Ansible Python library is useful to make
    your code shorter, faster, and less error prone. To do so, let''s create a file
    called `library/check_user_py2.py` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the preceding module and see how it works, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we do not import `sys`, `shlex` and `json`; we are not using
    them anymore, since all the operations that required them are now done by Ansible
    `module_utils`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Previously, we performed a lot of processing on the argument file to get the
    final user arguments. Ansible makes it easy by providing an `AnsibleModule` class,
    which does all the processing on its own and provides us with the final arguments.
    The `required=True` parameter means that the argument is mandatory and the execution
    will fail if the argument is not passed. The default value for required is `False`,
    which will allow users to skip the argument. You can then access the value of
    the arguments through the `module.params` dictionary by calling the `get` method
    on `module.params`. The logic to check users on the remote host will remain the
    same, but the error handling and return aspect will change as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: One of the advantages of using the `AnsibleModule` object, is that you have
    very nice facility to handle returning values to the playbook. We will go into
    more depth in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could have condensed the logic to check user and the return section, but
    we kept them divided for readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify that everything works as expected, we can create a new playbook in
    `playbooks/check_user_py2.yaml` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Which is consistent with our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: Working with exit_json and fail_json
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ansible provides a shorter way to handle success and failure by providing the
    `exit_json` and `fail_json` methods, respectively. You can directly pass a message
    to these methods and Ansible will take care of the rest. You can also pass additional
    variables to these methods and Ansible will print those variables to `stdout`.
    For example, apart from the message, you might also want to print the `uid` and
    `gid` parameters of the user. You can do this by passing these variables to the
    `exit_json` method separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how you can return multiple values to `stdout`, which is demonstrated
    in the following code placed in `library/check_user_id.py`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we return the `uid` and `gid` of the user along with the message,
    `msg`. You can have multiple values and Ansible will print all of them in a dictionary
    format. We can create a playbook in `playbooks/check_user_id.yaml` with the following
    content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Run it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Testing Python modules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As we have seen, you can test your modules creating very simple playbooks that
    run them. You can also test your module by running it more directly. To do so,
    we''ll need to clone the Ansible official repository (if you haven''t done it
    yet):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Source an environmental file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the `test-module` utility to run the script passing the filename
    as a command-line argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The result will be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's also simple to execute the script directly, if you have not used the `AnsibleModule`,
    this is due the fact that this module requires lots of Ansible-specific variables,
    so it's more complex to "simulate" an Ansible run than to actually run Ansible
    itself.
  prefs: []
  type: TYPE_NORMAL
- en: Using bash modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bash modules in Ansible are no different than any other bash scripts, except
    the way it prints the data on `stdout`. Bash modules could be as simple as checking
    if a process is running on the remote host to running some complex commands.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As previously stated, the general recommendation is to use Python for modules.
    In my opinion the second-best choice (only for very easy modules) is `bash` module
    due to its simplicity and user base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the file `library/kill_java.sh` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding `bash` module will take the `service_name` argument and forcefully
    kill all of the Java processes that belong to that service. As you know, Ansible
    passes the argument file to the module. We then source the arguments file using
    source `$1`. This will actually set the environment variable with the name, `service_name`.
    We then access this variable using `$service_name` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check to see if we obtained any PIDs for the service and run a loop
    over it to forcefully kill all of the Java processes that match `service_name`.
    Once they''re killed, we exit the module with `failed=False` and a message with
    an exit code of `0`, as you can see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'If we do not find any running process for the service, we will still exit the
    module with an exit code of `0` because terminating the Ansible run might not
    make sense; this is in the following part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also terminate the Ansible run by printing `failed=True` with an exit
    code of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ansible allows you to return a key-value output if the language itself doesn''t
    support JSON. This makes Ansible more developer/sysadmin-friendly and allows custom
    modules to be written in any language of one''s choice. Let''s test the `bash`
    module by passing the arguments file to the module. We can now create an arguments
    file in `/tmp/arguments` that has the `service_name` parameter set to Jenkins,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can run the module like any other bash script. Let''s see what happens
    when we run it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'We should receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the module did not fail even though there was no Jenkins process
    running on the localhost.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ruby modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Writing modules in Ruby is as easy as writing a module in Python or bash. You
    just need to take care of the arguments, errors, return statements, and of course,
    know basic Ruby! Let''s create the `library/rsync.rb` file with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding module, we first process the user arguments, then copy the
    file using the `rsync` library, and finally, return the output. Let's break down
    the preceding code and see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'We first wrote a method, `print_message`, which will print the output in a
    JSON format. By doing this, we can reuse the same code in multiple places. Remember,
    the output of your module should contain `failed=true` if you want the Ansible
    run to fail; otherwise, Ansible will think that the module succeeded and will
    continue with the next task. The output obtained is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'We then process the arguments file, which contains a key-value pair separated
    by a whitespace character. This is similar to what we did with the Python module
    earlier, where we took care of parsing out the arguments. We also perform some
    checks to make sure that the user has not missed any required argument. In this
    case, we check if the `src` and `dest` parameters have been specified and print
    a message if the arguments are not provided. Further checks could include the
    format and type of arguments. You can add these checks and any other checks you
    deem important. For example, if one of your parameters is a `date`, then you''d
    like to verify that the input is actually the right date. Consider the following
    piece of code, which shows the discussed parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have the required arguments, we will go ahead and copy the file using
    the `rsync` library as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we check if the `rsync` task passed or failed and call the `print_message`
    function to print the output on `stdout` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can test your Ruby module by simply passing the arguments file to the module.
    To do so, we can create the file `/tmp/arguments` with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now run the module, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We will receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We will leave the `serverspec` testing for you to complete.
  prefs: []
  type: TYPE_NORMAL
- en: Testing modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is often undervalued due to lack of understanding of its purpose and
    the benefits it can bring to the business. Testing modules is as important as
    testing any other part of the Ansible playbook because a small change in a module
    can break your entire playbook. We will take an example of the Python module that
    we wrote in the first section of this chapter and write an integration test using
    Python's nose test framework. Unit tests are also encouraged, but for our scenario
    where we check if a user exists remotely, an integration test makes more sense.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`nose` is a Python test framework. For more information, visit [https://nose.readthedocs.org/en/latest/](https://nose.readthedocs.org/en/latest/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To `test` the module, we convert our previous module into a Python class so
    that we can directly import the class in our test, and run only the main logic
    of the module. The following code shows the `library/check_user_py3.py` restructured
    module, which will check whether a user exists on a remote host:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see in the preceding code, we created a class named `User`. We instantiated
    the class, and called the `check_if_user_exists` method to check if the user actually
    exists on the remote machine. It''s time to write an integration test now. We
    assume that you have the `nose` package installed on your system. If not, don''t
    worry! You can still install the package by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now write the integration test file in `library/test_check_user_py3.py`
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding integration test, we import the `nose` package and our module,
    `check_user`. We call the `User` class by passing the user we want to check. We
    then check whether the user exists on the remote host by calling the `check_if_user_exists()`
    method. The `nose` methods, `assert_true`, `assert_false`, and `assert_equals`
    can be used to compare the expected value against the actual. Only if the assert
    methods pass, will the test pass. You can have multiple tests inside the same
    file by having multiple methods whose names start with `test_`, for example, the
    `test_check_user_positive()` and `test_check_user_negative()` methods. Nose tests
    will take all the methods that start with `test_` and execute them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As you can see, we actually created two tests for just one function. This is
    a key part of tests. Always try cases where you know it will work, but also do
    not forget to test cases where you expect it to fail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now test if it works running nose in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'You should receive output similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test passed because the `root` user existed on the host
    while the `this_user_does_not_exists` user does not exist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We use the `-v` option with  `nose` tests for the **verbose** mode.
  prefs: []
  type: TYPE_NORMAL
- en: For more complicated modules, we recommend that you write unit tests and integration
    tests. You might wonder why we didn't use `serverspec` to test the module.
  prefs: []
  type: TYPE_NORMAL
- en: We still recommend running `serverspec` tests for functional testing as part
    of playbooks, but for unit and integration tests, it's recommended to use well-known
    frameworks. Similarly, if you write Ruby modules, we recommend you write tests
    for them with a framework such as `rspec`. If your custom Ansible module has multiple
    parameters with multiple combinations, then you will write more tests to test
    each scenario. Finally, we recommend that your run all these tests as part of
    your CI system, be it Jenkins, Travis, or any other system.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs: []
  type: TYPE_NORMAL
- en: 'A couple of questions to think about are given in the this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Can you think of common tasks that you perform daily and how you would write
    Ansible modules for them? List them down in terms of how you would invoke the
    module from a playbook.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Which language do you think your team would be comfortable using for your modules?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Can you revisit the roles that you might have written after [Chapter 3](ch03.html
    "Chapter 3. Scaling to Multiple Hosts"), *Scaling to Multiple Hosts*, and see
    which of them can potentially be converted into custom modules?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this, we come to the end of this rather small but important chapter, which
    focused on how you can extend Ansible by writing your own custom modules. You
    learned how to use Python, Bash, and Ruby in order to write your modules. We've
    also seen how to write integration tests for modules so that they can be integrated
    into your CI system. In future, hopefully, extending your Ansible functionality
    using modules should be way easier!
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will step into the world of provisioning, deployment, and orchestration
    and look at how Ansible solves our infrastructure problems when we provision new
    instances or want to deploy software updates to various instances in our environments.
    We promise that the journey is going to be fun!
  prefs: []
  type: TYPE_NORMAL
