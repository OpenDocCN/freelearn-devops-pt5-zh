- en: Chapter 6. Orchestrating SDN Controllers Using Ansible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will focus on SDN controllers and the ways they can enable network
    teams to simplify their daily tasks.
  prefs: []
  type: TYPE_NORMAL
- en: We will look at why SDN Controllers have been adopted and highlight some of
    the immediate business benefits they will bring if utilized correctly. It will
    focus on ways in which network operations need to be divided so network operations
    can scale, by utilizing automation.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will discuss the benefits of utilizing software-defined networking
    and look at practical configuration management processes that can be used to orchestrate
    SDN Controller APIs and object models. Finally, we will look at how Ansible can
    be used to execute and wrap some of these configuration management processes,
    using Nuage VSP as a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, the following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Arguments against software defined networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why would a company utilize SDN?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Splitting up network operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immutable networking
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Ansible to orchestrate SDN controllers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments against software-defined networking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the emergence of public clouds such as AWS, Microsoft Azure, and Google
    Cloud, networking is now being treated more like a commodity and has moved from
    silicon to software. This has allowed developers the ability to mutate the network
    to best serve the applications, rather than retrofit applications into an aging
    network, that is probably not optimized for modern microservice applications.
  prefs: []
  type: TYPE_NORMAL
- en: It would therefore seem nonsensical if any business would want to treat their
    internal data center networking any differently. However, like all new ideas,
    before acceptance and adoption comes fear and uncertainty, inherently co-related
    with the new or different ways of working.
  prefs: []
  type: TYPE_NORMAL
- en: 'Common arguments against using a clos Leaf-Spine architecture and SDN controllers
    center around one common theme, that it requires change and change is hard. We
    then harp back to the mythical 8th layer of the OSI model, and that is the **User**
    layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Arguments against software-defined networking](img/B05559_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The network operators have to feel comfortable with any solution that is implemented.
    This is very important, but by the same token, the **User** layer is equally important
    as it is the networking service provided by the network team to end users. So
    ease of use is important on two levels, both network operations and the self-service
    operations provided to the consumers of the network.
  prefs: []
  type: TYPE_NORMAL
- en: Before a company considers putting in software-defined networking, they need
    to be doing it for the correct reasons and make it requirements-based. Simply
    implementing a new tool, in this case an SDN Controller, will not solve operational
    issues alone.
  prefs: []
  type: TYPE_NORMAL
- en: Organizations need to work out what the new operational model should be and
    utilize software-defined networking as a facilitator for those new business processes,
    focusing on speed of operations with the aim of removing networking as the bottleneck
    for application delivery. In short, network operations need to be DevOps friendly
    or they will inhibit software delivery and slow down the whole application lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Added network complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Some of the arguments used against using overlay networks are that they are
    more complex than traditional layer 2 networks, with many more moving parts that
    could cause a bigger variety of failures.
  prefs: []
  type: TYPE_NORMAL
- en: Although the constructs of an overlay and underlay network may be different,
    it is fair to say software-defined networking is still a relatively new concept
    and a lot of people fear change. As long as the base requirements in terms of
    network availability, redundancy, performance, and speed of change are met, then
    there should be no reason not to implement software-defined networking.
  prefs: []
  type: TYPE_NORMAL
- en: The fear of software-defined overlay networks can be likened to operations staff's
    initial skepticism towards server virtualization when they initially argued against
    the introduction of hypervisors. These new concepts were initially viewed as an
    added layer of complexity and added abstraction layer that would probably not
    be as performant.
  prefs: []
  type: TYPE_NORMAL
- en: However, the portability and opportunities introduced by running a hypervisor
    greatly outweighed any performance implications for the vast majority of application
    use cases. The benefits included increased portability, flexibility, and speed
    of operations.
  prefs: []
  type: TYPE_NORMAL
- en: There are of course edge cases and some applications that don't fit into the
    virtualized model, but the benefits that virtualization brings for 99 percent
    of the data center mean that as a business solution it can't really be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: Overlay networks give the same benefits to networking as hypervisors did to
    servers. Of course, when implementing a software-defined overlay network, the
    underlay should be built for redundancy, so that if a failure occurs, it occurs
    on the underlay and does not impact the overlay.
  prefs: []
  type: TYPE_NORMAL
- en: The underlay network should be horizontally scaleable and simple, in the case
    of a Leaf-Spine architecture, which has a series of Spine switches connected to
    Leaf switches that sit on top of each rack. The introduction of more racks paired
    with Leaf switches, or even a new Spine to prevent over-subscription of links,
    allow horizontal scalability.
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of overlay networks adding complexity, Any systems reliability
    engineer or network engineer that has spent hours debugging an ill-performing
    link in a layer 2 Spanning Tree network will testify that Spanning Tree networks
    are themselves very complex by nature. The systems reliability engineer or network
    engineer will also probably be able to show you the network diagram they had to
    draw in an attempt to solve the issue as evidence of the complexity.
  prefs: []
  type: TYPE_NORMAL
- en: So networks are complex beasts at the best of times; however, when utilizing
    underlay and overlay networks, the main focus on the underlay network should be
    horizontal scalability and performance. It should ensure that network operators
    can easily scale out the network based on demand.
  prefs: []
  type: TYPE_NORMAL
- en: Alternatively, the focus of the overlay network is simplicity, so it should
    have easy-to-understand software constructs while at the same time ensure that
    the API endpoints can cope with the desired number of concurrent requests from
    consumers.
  prefs: []
  type: TYPE_NORMAL
- en: If implemented correctly, networks should be componentized into two distinct
    sections. The overlay user friendly software, much like AWS, Microsoft Azure,
    Google Cloud, or OpenStack, and the underlay is the gritty, hardcore, networking
    that needs to be well designed by a network architect and built for scale.
  prefs: []
  type: TYPE_NORMAL
- en: Lack of software-defined networking skills
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another argument against not implementing a software-defined network is lack
    of skills in the industry currently; with any new technology there is initially
    a lack of skilled people to support it. One viewpoint is that companies will have
    to hire completely new staff to implement software defined networking.
  prefs: []
  type: TYPE_NORMAL
- en: However, this can be offset by partnering with an SDN vendor or utilizing provided
    training programs for staff. It is a business transformation and as such, network
    staff will need to build new skills over a period of time.
  prefs: []
  type: TYPE_NORMAL
- en: But networking staff will need to evolve with the changes software-defined networking
    bring and build new skills like other teams in IT. Implementing software defined
    networking is a big change at first, but good networking staff should be excited
    and embrace these changes. The efficiency and benefits that can be had from implementing
    software-defined networking are undeniable.
  prefs: []
  type: TYPE_NORMAL
- en: Change can be daunting at first and can seem like a monumental cultural shift
    or effort at times. To initiate successful change in large or even small companies
    it usually has to come with top-down sponsorship or backing.
  prefs: []
  type: TYPE_NORMAL
- en: Adopting software-defined networking will mean changing the business's operational
    model and automation will need to be embraced at every level; network tasks in
    the overlay simply can't be manual when using an SDN controller. An organization
    implementing software-defined networking also needs to look at ways of automating
    the underlay. In this book we have already looked at ways in which APIs can be
    utilized to configure network devices, so really, both the underlay and overlay
    need to be automated.
  prefs: []
  type: TYPE_NORMAL
- en: The term software-defined data center is somewhat overused by vendors, but the
    principles behind it can't be ignored if a network team wants to provide a great
    user experience to the rest of the business. If a company puts in a software-defined
    networking solution as a standalone initiative, then it will add no true value
    if automation isn't written to speed up network operations utilizing the rich
    set of APIs that are provided. If companies are going to put in a software-defined
    network and have network engineers manually enter commands on network devices
    or use a GUI, the company may as well not bother, as they can do that with any
    out-of-the-box switch or router; they are wasting the opportunity a software-defined
    overlay network offers.
  prefs: []
  type: TYPE_NORMAL
- en: Just putting in the software-defined networking solution and still having developers
    raise network tickets will give zero business value; it will not increase efficiency,
    time to market, or the reliability of changes. To ensure organizations extract
    the significant business benefits out of software-defined networking, you need
    an all-or-nothing approach; network operations are either completely automated
    or over time become fragmented and broken.
  prefs: []
  type: TYPE_NORMAL
- en: If network engineers persist with doing manual updates outside the automated
    workflows, then it has the opportunity to break the whole operational mode. It
    changes the desired state of the network, and it could break the automation completely.
  prefs: []
  type: TYPE_NORMAL
- en: When putting in software-defined networking, automate all the common operations
    first and allow developers to serve themselves and make it immutable if possible.
    Being able to rebuild the network from source control management systems should
    be the aim as it acts as a record of change.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 3](ch03.html "Chapter 3. Bringing DevOps to Network Operations"),
    *Bringing DevOps to Network Operations,* we looked at ways of initiating cultural
    change. Humans are creatures of habit, they tend to stick with what they know;
    network engineers have spent years gathering networking certifications on ways
    to configure Spanning Tree algorithms and layer 2 networks, so this is a huge
    cultural shift.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful firewalling to support regularity requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the main issues highlighted with software-defined networking has been
    the lack of stateful firewalling, due to Open vSwitch being based on flow data
    and being traditionally stateless. Until recently, reflexive rules were utilized
    to emulate stateful firewalling at the kernel user space level.
  prefs: []
  type: TYPE_NORMAL
- en: However, recent feature developments with Open vSwitch has allowed stateful
    firewalling to be implemented. So the lack of stateful firewalling is no longer
    an issue with Open vSwitch. **Connection tracking** (**conntrack**), previously
    only available as part of iptables, has now been decoupled from iptables, meaning
    that it is now possible to match on connections as well as flow data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Nuage VSP platform has introduced stateful firewalling as part of its 4.x
    release. The Nuage VSP platform has replaced reflexive rules for stateful rules,
    to govern all ICMP and TCP ACL rules on the Nuage VRS (Nuage''s customized version
    of Open vSwitch):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stateful firewalling to support regularity requirements](img/B05559_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Why would organizations need software-defined networking?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Any good enterprise networks should be built with the following goals in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redundancy
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The network, first and foremost, needs to be *performant* to meet customer needs.
    Customers can be end users in the data center or end users of the application
    in the public domain. With Continuous Delivery and deployment, if networking blocks
    a developer in a test environment, it is hampering a potential feature or bug
    fix reaching production, so it is not acceptable to have sub-standard pre-production
    networks and they should be designed as scaled-down functional replicas of production.
  prefs: []
  type: TYPE_NORMAL
- en: '*Scalability* focuses on the ability to scale out the network to support company
    growth and demand. As more applications are added, how does the network horizontally
    scale? Is it cost effective? Can it easily be adapted to cater for new services
    such as third-party VPN access or point-to-point network integration? All these
    points need to be given proper consideration when creating a flexible and robust
    network design.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Redundancy* is built on the concept that any enterprise network should have
    no single points of failure. This is so that the network can recover from a switch
    failure or an issue with a core router and not cause outages to customers. Every
    part of the network should be set up to maximize uptime.'
  prefs: []
  type: TYPE_NORMAL
- en: These three points seem to have been the staple on which good networks were
    designed and built in the past. However, as applications have moved from monoliths
    to microservices, additional requirements are necessary for successful network
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: Traditionally, monolithic applications have tended to have one setup operation
    and then remained fairly static, while microservice applications on the other
    hand have required more dynamic networks that are subject to greater variance
    of change.
  prefs: []
  type: TYPE_NORMAL
- en: The needs of the modern network have evolved and networks need to be updated
    rapidly to deal with the requirements of microservice architectures, without having
    to wait on a network engineer to process a ticket. With Continuous Delivery forming
    feedback loops, it is imperative that the process is quick and lean, and issues
    can be fixed quickly otherwise the whole process will break down and grind to
    a stand-still.
  prefs: []
  type: TYPE_NORMAL
- en: Software-defined networking adds agility and precision
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Software-defined networking or in particular overlay networking, still focuses
    on *performance*, *scalability,* and *redundancy*; they should never be compromised,
    but also introduces the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Agility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mean time to recover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Precision and repeatability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Software-defined networking puts the network into a software overlay network
    with associated object model, which allows the network to be programmable by exposing
    a rich set of APIs. This means that workflows can be used to set up network functions,
    the same way infrastructure can be controlled in a cloud or virtualization environment.
  prefs: []
  type: TYPE_NORMAL
- en: As the network is programmable, requesting a new subnet or making an ACL change
    can be done as quickly as spinning up a virtual machine on a hypervisor. Software-defined
    networking removes the traditional blockers or operational inhibitors. These have
    often included being required to raise a ticket to a network operation team to
    mutate the network, which was subject to a lengthy change control process. Instead,
    when utilizing software-defined networking, a developer can control a subnet of
    network operations via an API call so changes can be carried out at pace.
  prefs: []
  type: TYPE_NORMAL
- en: '*Mean time to recover* has also improved when utilizing software-defined networking
    because network changes are programmable, so network inventory can be stored in
    source control management systems. This versions the network so any change is
    delivered via source control management and allows network changes to be modular,
    auditable, and easy to track.'
  prefs: []
  type: TYPE_NORMAL
- en: If a breaking change has occurred to the overlay network, a version tree in
    the source control management system can be used to see what has changed since
    the network's last working release. The same programmable script can then be used
    to quickly roll back the network change back to the previous version and remove
    the issue. This is, of course, the beauty of implementing an immutable network
    rather than static networks, where the state is always as clean as the day one
    network and can be rolled forward or back on demand.
  prefs: []
  type: TYPE_NORMAL
- en: '*Repeatability* in software-defined networking is catered for using programmatic
    operational workflows, so that all network changes are carried out in an identical
    way by all users. These operations can be executed using the API workflows approved
    by the network team against the overlay network.'
  prefs: []
  type: TYPE_NORMAL
- en: The use of programmatic workflows means that network changes can be integrated
    into application deployment processes such as Continuous Delivery. This means
    network changes, like code, will be checked into source control management systems,
    pushed to a test environment using programmatic workflow actions (to manage the
    desired state of the network), tested and verified, and only then promoted onto
    the next test environment or production.
  prefs: []
  type: TYPE_NORMAL
- en: This repeatability of using an overlay network ensures all the constructs of
    a quality assurance test environment can be the same as a production environment,
    as all networking constructs are described in software and are easy to reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: A good understanding of Continuous Delivery is key
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Organizations looking to utilize software-defined networking should ideally
    already have a well-established Continuous Delivery model for code and infrastructure
    before tackling network operations. Companies committed to investing in a DevOps
    transformation would also benefit greatly from designing their new operational
    model around a software-defined network.
  prefs: []
  type: TYPE_NORMAL
- en: Companies which have mandated their business functions to automate all IT operations,
    inclusive of networking functions, would receive immeasurable quantifiable benefits
    from using an SDN controller to help their teams automate the network. Companies
    with an inherit understanding of DevOps, **continuous integration**, and **Continuous
    Delivery** are more likely to utilize SDN controllers to their full capabilities
    and drive innovation.
  prefs: []
  type: TYPE_NORMAL
- en: To emphasize the point, if overlay networks are modified by network engineers
    by hand rather than programmatically, it will bring no business value and the
    company will have missed the point.
  prefs: []
  type: TYPE_NORMAL
- en: Operational models need to change when implementing software-defined networking
    and if an issue occurs it needs to be built back into the automation to fix the
    issue so it doesn't re-occur. Any complex process, when initially automated, will
    probably hit some unexpected edge cases and fail under unexpected conditions.
    As a result, it is important that automated processes are continually iterated
    and improved on. Having teams adopt a continuous improvement methodology will
    ensure that automated processes are iterated and improved so they become more
    and more robust over time.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to appreciate that edge cases will occur and to not panic when
    they do; fixing a problem with the automation fixes it for all users, but by the
    same token a problem with the automation can cause multiple users to be impacted,
    so it is a double-edged sword. Creating sufficient testing when creating automated
    processes to try and catch these edge cases in test environments becomes vitally
    important.
  prefs: []
  type: TYPE_NORMAL
- en: One of the benefits automation brings is that that all changes can be carried
    out with the precision of a highly skilled network engineer who can supply all
    their knowledge to automation. This means that every automated network change
    is done with the same care and precision as the best network engineer in the company.
  prefs: []
  type: TYPE_NORMAL
- en: The pre-approved and well-defined changes to automated workflows can be carried
    out by anyone in the company, not just the best engineer, if they are automated,
    so the bottleneck is removed from the network team freeing them up to work on
    more interesting tasks than the mundane repeatable **Business as Usual** (**BAU**)
    tasks that are more accurately done using automation.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying complex networks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Organizations that have very complex legacy networks would also be a prime candidate
    for benefiting from software-defined networking instead of fixing the existing
    network, which may not be possible due to having to adhere to 99 percent uptime
    targets. Instead, a new green-field network could be created in parallel with
    the existing network.
  prefs: []
  type: TYPE_NORMAL
- en: This will allow application workloads to be migrated to the new network over
    time and simplify the complexity of the existing network in the process. During
    the period of migration where both the new green-field network and old legacy
    network co-exist, the SDN overlay network can be used to route back to the legacy
    network for application dependencies that have yet to be migrated.
  prefs: []
  type: TYPE_NORMAL
- en: Another benefit of software-defined networking is that it allows private cloud
    solutions to run at increased scale. If private clouds are running more than 100
    hypervisors, this is a scale at which an SDN solution would be of benefit, such
    as extending OpenStack Neutron capabilities to allow companies to run OpenStack
    at scale, as opposed to deploying multiple smaller OpenStack clouds to cope with
    bottlenecks.
  prefs: []
  type: TYPE_NORMAL
- en: Splitting up network operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the introduction of software-defined networking in a company or business
    there has to be a shift in operational responsibilities. If an organization runs
    multiple microservice applications, a fairly typical situation is that a company
    has 100 developers that develop those 200 microservices.
  prefs: []
  type: TYPE_NORMAL
- en: Each of those 200 microservices are combined together to deploy the company's
    customer facing website.
  prefs: []
  type: TYPE_NORMAL
- en: The company may use agile software development so each of the 100 developers
    are split into a set of delivery teams that contain 10 or so developers, each
    forming scrum teams, and each delivery team looks after a set amount of microservices
    relative to their complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The company has 10 network engineers that are required to serve the networking
    needs of the 100 developers, as well as maintaining uptime of the network.
  prefs: []
  type: TYPE_NORMAL
- en: However, in this model, if all network operations are done manually, then the
    network engineers will not be able to keep up with the necessary change requests,
    so they will either have to work late nights and subsequently become burned out,
    so their productivity will drop. In this model, they are in reactive firefighting
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: In this model, the productivity of the developers will probably be impacted
    too as the network engineers will become the bottleneck for throughput. The model
    described will simply not scale, so operational change is required.
  prefs: []
  type: TYPE_NORMAL
- en: In the scenario described, one network engineer will be required for every ten
    developers, and in future as the company expands it will want to invest in development
    staff to create more products. It is undoubtedly a harder sell for organizations
    to scale up their network teams to support those network operations, so network
    automation becomes a must in this scenario and the network team needs to work
    smarter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Introducing new products and developers without changing the way a networking
    team operates can lead to burnout, so a network engineer will be able to support
    ten developers but not 20 when doing all network operations manually. Therefore,
    considering the developer to network engineer ratio is important when making the
    case for automation, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Splitting up network operations](img/B05559_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The business may then look at software-defined networking as the solution to
    solve their scaling problems, with the mindset of simplifying the network. This
    means that network engineers can carry out network changes more quickly to support
    developer demand.
  prefs: []
  type: TYPE_NORMAL
- en: But simply putting in a software defined networking solution such as CISCO ACI,
    Juniper Contrail, VMware NSX, or Nuage Networks will not help the situation unless
    processes are automated and the inefficient business processes are addressed.
  prefs: []
  type: TYPE_NORMAL
- en: New responsibilities in API-driven networking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The role of a network engineer in a software-defined network therefore has to
    evolve; they have to devolve some power to the developers like operations staff
    were required to for the creation of the infrastructure. But software-defined
    networking shouldn't mean giving complete, open access of the API to developer.
    This is also a recipe for disaster. Efficient controls need to be put in place
    that act as a quality gate, not as an inhibitor of productivity.
  prefs: []
  type: TYPE_NORMAL
- en: Some operational workflows in an overlay network should still be controlled
    by a qualified network engineer and governed by security, but not to the detriment
    of developer's productivity and requirements.
  prefs: []
  type: TYPE_NORMAL
- en: It wouldn't be fair to expect a developer to be well versed enough in networking
    to log onto a router and set up their routing requirements for their application
    unaided, so there has to be some middleground.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing a developer access to network devices in an uncontrolled manner poses
    the risk of a network outage, which goes against one of the three main networking
    principles and compromises redundancy, and network engineers have a responsibility
    for uptime of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Overlay architecture setup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When setting up an overlay network, it will normally be built in a green-field
    environment as part of an application migration program and target environment
    for a legacy network. The application migration could either be done in a piecemeal
    format or done in one step, where everything is migrated, then switched on as
    part of a migration big bang, go live activity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Regardless of the application migration approach, it is very important that
    the overlay network is set up to achieve the following goals:'
  prefs: []
  type: TYPE_NORMAL
- en: Agility
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimize mean time to recover
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Repeatability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The performance of the network will be determined by the underlay components
    and silicon used, but the definition of the overlay network in terms of constructs
    and workflow of the SDN object model need to be correct to make sure that any
    operation can easily be carried out quickly, is repeatable, and that the design
    scales and can support roll-back. The SDN before implementation should be performance
    tested to make sure the virtualization overhead does not impact performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s quickly recap on the Nuage VSP object model that was covered in
    [Chapter 2](ch02.html "Chapter 2. The Emergence of Software-defined Networking"),
    *The Emergence of Software-defined Networking*:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Organization**: Governs all layer 3 domains![Overlay architecture setup](img/B05559_06_04.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3 domain template**: A **Company L3 Domain Template** is required before
    child layer 3 domains are created. The **Company L3 Domain Template** is used
    to govern overarching default policies that will be propagated to all child layer
    3 domains. If a **Company L3 Domain Template** is updated at template level, then
    the update will be implemented on all layer 3 domains that have been created underneath
    it, immediately.![Overlay architecture setup](img/B05559_06_05.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3 domain**: Can be used to segment different environments so users
    cannot hop from subnets deployed in a layer 3 **Test** domain to a layer 3 **Production**
    domain.![Overlay architecture setup](img/B05559_06_06.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Zones**: A zone segment''s firewall policies are at application level, so
    each micro-service application can have its own zone and associated Ingress and
    Egress policy per layer 3 domain.![Overlay architecture setup](img/B05559_06_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3 Subnet**: This is where VMs or bare-metal servers are deployed. In
    this example, we see **Subnet Application1** and **Subnet Application2:**![Overlay
    architecture setup](img/B05559_06_08.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Specific Egress Policy**: Unique application policies for Egress
    rules that can be used to view each individual application''s connectivity rules:![Overlay
    architecture setup](img/B05559_06_09.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Specific Ingress Policy**: Unique application policies for ingress
    rules that can be used to view each individual application''s connectivity rules:![Overlay
    architecture setup](img/B05559_06_10.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaking Domain**: This is used to leak routes into the overlay network via
    a layer 3 subnet to bridge connectivity between the green-field network and a
    legacy network:![Overlay architecture setup](img/B05559_06_11.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, utilizing Nuage VSP as an example, we had an organization with two layer
    3 domains dictating Test and Production, with a zone for each micro-service application
    encapsulating its unique micro-subnets and virtual machines:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Overlay architecture setup](img/B05559_06_12.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In terms of network setup, automation could be used by the network team and
    they would be in control of the following constructs in the overlay network:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Organization**: Governs all layer 3 domains:![Overlay architecture setup](img/B05559_06_13.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3 domain template**: Used to govern default policies:![Overlay architecture
    setup](img/B05559_06_14.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3 domain**: Used to separate responsibilities between environments
    such as development and production:![Overlay architecture setup](img/B05559_06_15.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Leaking Domain**: Used to make the legacy network accessible from the overlay
    network:![Overlay architecture setup](img/B05559_06_16.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The organization is most likely a *day-one* setup activity, while the domain
    template policies can be defined and dictated by the network and security team.
    Any security policies applied across all networks, regardless of the domain they
    are deployed in, are governed by the domain template. So test environments will
    have identical template policies to production and meet all security, governance,
    and regularity requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Development teams then have the ability to create unique test environments under
    the **Test** layer 3 domain with the same subsequent policies, without the need
    for the network team to audit each and every one. The application security rules
    that developers use can then be agreed between security and development teams
    without network teams having to become involved directly unless they are asked
    to advise on particular best practice ways of setting up ACL rules.
  prefs: []
  type: TYPE_NORMAL
- en: The other *day-one* setup activity will probably be setting up access to a legacy
    network that teams will be migrating applications from for a time, so they will
    still have dependent applications residing in that network.
  prefs: []
  type: TYPE_NORMAL
- en: Nuage VSG, which is a hardware gateway device that connects external networks
    to the Nuage VSP platform and its associated leaking domain, can be used to do
    this. The Nuage VSG leaks routes from external networks into the overlay network
    and into specific layer 3 domains.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Nuage VSP Platform allows network teams to define the **GRThubDomain**
    leaking domain in software that utilizes VSG. In this example, a leaking domain
    is set as IP host interfaces are connected into the **Front End**, **Business
    Logic** and **Back End** routers in the legacy network:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlay architecture setup](img/B05559_06_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Nuage VSP platform then allows the newly-created **GRThubDomain** to be
    associated with the **Production** or **Test** layer 3 domains by associating
    a leaking domain against them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the **GRThubDomain** leaking domain is associated
    with the **Production** layer 3 domain to allow legacy network routes to be accessible
    from zones and subnets residing under the **Production** layer 3 domain:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overlay architecture setup](img/B05559_06_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The network team will also be responsible for monitoring the network underlay
    and making sure that it is scaled out appropriately as more compute is introduced,
    so Leaf switches will be introduced and ordered as and when new racks are scaled
    out, while new Spine switches are introduced to avoid the saturation of links.
  prefs: []
  type: TYPE_NORMAL
- en: Self-service networking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to focus on the network operations that developers typically
    require network tickets for as a start point. These are the common pain points
    for developers that prove to be blockers to productivity. Network operations can
    be effectively separated by looking at the common themes on network ticketing
    systems that have been raised by development teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the more mundane BAU operations that network operators should make
    self-service:'
  prefs: []
  type: TYPE_NORMAL
- en: Opening firewall ports
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of new development environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connectivity to other applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These operations should be set up as self-service operations in a software-defined
    network.
  prefs: []
  type: TYPE_NORMAL
- en: 'In terms of the Nuage VSP object model, network operators should allow developers
    the ability to control the following object model entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Zones**: They encapsulate a microservice application:![Self-service networking](img/B05559_06_19.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layer 3 Subnet**: These define the IP range available to a microservice application![Self-service
    networking](img/B05559_06_20.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Specific Egress Policy**: This defines the Egress ACL policies
    for the microservice application:![Self-service networking](img/B05559_06_21.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application Specific Ingress Policy**: This defines the Ingress ACL policies
    for the microservice application:![Self-service networking](img/B05559_06_22.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will allow the network operations team to provide development teams with
    the organization, layer 3 domains, and the layer 3 domain template.
  prefs: []
  type: TYPE_NORMAL
- en: Underneath either the **Test** or **Production** layer 3 domains, development
    teams have the flexibility to create new zones unique to each microservice application,
    then any associated subnets and virtual machines that they need to provision.
  prefs: []
  type: TYPE_NORMAL
- en: The subnets will be micro subnets, so something akin to a `/26`, `/27`, or `/28`
    may be acceptable. The network team will provide the subnet schema and a booking
    system where teams can reserve the address space in an IPAM solution if they are
    on-boarding an application or creating a new application, to prevent clashes with
    other teams.
  prefs: []
  type: TYPE_NORMAL
- en: As long as each delivery team follows those constructs, the networking team
    does not need to be involved in the provisioning of new applications or onboarding,
    it will become self-service, like AWS, Microsoft Azure, or Google Cloud.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, in order to properly facilitate development teams, the network team
    should ideally create the self-service automation that the development teams can
    use to carry out the following in Nuage VSP along with the operations team:'
  prefs: []
  type: TYPE_NORMAL
- en: Creation of zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion of zones
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of subnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion of subnets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of Ingress rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion of Ingress rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of Egress rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion of Egress rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creation of network macros (external subnets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deletion of network macros (external subnets)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No matter the SDN solution implemented, the self-service constructs required
    will be similar, in order to scale network operations, a lot of the operations
    have to be automated and made self-service.
  prefs: []
  type: TYPE_NORMAL
- en: Ideally, these self-service workflow actions could be added to Ansible playbooks
    or roles and included in the deployment pipelines to provision the networking
    along with the infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: Immutable networking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To fully take advantage of the benefits of software-defined networking, utilizing
    immutable networking brings multiple benefits over static networking. Like infrastructure
    as code before it, networking as code and the utilization of immutable networking
    means that every time an application is deployed, its networking is freshly deployed
    from a source control management system that describes the desired state of the
    network. This means that network configurations don't drift over time.
  prefs: []
  type: TYPE_NORMAL
- en: Using a networking as code model to drive immutable networking allows application
    connectivity to be tested prior to production. Test environments mirroring production
    should be used to check application connectivity prior to releasing any network
    changes to production.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing network changes as part of a Continuous Delivery model means that
    if application connectivity is proven to be wrong when it is tested in a test
    environment, then the application connectivity will be wrong in production environments.
    As a result, wrong connectivity changes should never reach production and should
    be caught prior to production by creating feedback loops that alert teams that
    the network change is not fit for purpose. Catching such issues will prevent outages
    and application downtime.
  prefs: []
  type: TYPE_NORMAL
- en: A/B immutable networking
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Networking, as a result, should ideally be integrated and become part of the
    application release cycle, with networks being built from scratch every single
    release and loaded from the source control management system. Networks can be
    deployed using immutable A/B networking.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the Nuage VSP integrated with OpenStack as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: A network will reside under a layer 3 domain
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each zone will be unique to a particular microservice application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Underneath the zone, a subnet will be created in both Nuage and OpenStack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Virtual machines for each release will be created in OpenStack and associated
    with the Nuage subnet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The first release of **Application1** version 1.1 is deployed to the **Test**
    layer 3 domain, deploying two virtual machines on **Subnet A Application1**, sitting
    under the **Application1** zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A/B immutable networking](img/B05559_06_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The second release of application version 1.2 is deployed to the **Test** layer
    3 domain, scaling down the release and deploying one virtual machine on **Subnet
    B Application1**, sitting under the **Application1** zone:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A/B immutable networking](img/B05559_06_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once release 1.2 has been put into service on the load balancer, doing a rolling
    deployment, the new virtual machine on **Subnet B Application1** will be in service,
    **Subnet A Application1** can then be destroyed along with its virtual machines
    as part of the deployment clean-up phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A/B immutable networking](img/B05559_06_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next release of **Application1**, release 1.3, will then be deployed into
    **Subnet A Application1**, and scaled up again to two virtual machines:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A/B immutable networking](img/B05559_06_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once release 1.2 has been put into service on the load balancer, doing a rolling
    deployment, the new virtual machines on **Subnet A Application1** will be in service,
    **Subnet B Application1** can then be destroyed along with its associated virtual
    machine as part of the deployment clean-up phase:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A/B immutable networking](img/B05559_06_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Releases will alternate between **Subnet A Application1** and **Subnet B Application1**
    for every release, building the network from source control each time and cleaning
    up the previous release each time.
  prefs: []
  type: TYPE_NORMAL
- en: The clean-up of redundant firewall rules
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the major tech debt issues with firewalls is that over time they accumulate
    lots of out of date ACL rules as applications are retired or network connectivity
    changes. It is often a risk to do clean-up as network engineers are scared that
    they will potentially cause an outage. As a result, manual clean-up of firewall
    rules is required by the network team.
  prefs: []
  type: TYPE_NORMAL
- en: When utilizing A/B immutable network deployments, egress and ingress policies
    are associated with subnets, meaning that in Nuage VSP when a subnet is deleted,
    all ACL policies associated with that subnet will be automatically cleaned up
    too as part of the release process.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, **Subnet A Application1** has the following connectivity,
    so when the subnet is deleted as part of the release process, all these subnet-specific
    ACL rules will be cleaned up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The clean-up of redundant firewall rules](img/B05559_06_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It is important to note that as ACL rules exist subnet to zone for application
    dependencies, if the A subnet deployment is in service, then the B subnet deployment
    will be brought up in parallel with its associated ACL Ingress and Egress rules
    to replace the A deployment.
  prefs: []
  type: TYPE_NORMAL
- en: All applications dependent on **Application1** will be required to have an ACL
    rule pointing at the zone rather than the subnet, this means they will not lose
    connectivity to the application as their rules will be zone-dependent rather than
    subnet-dependent. Having subnet to subnet rules would not work in an immutable
    subnet model.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this, in the following example, currently deployed subnet **Application1**
    has a subnet to zone ACL rule to connect to **Application2**. So, despite **Application2**
    Egress and Ingress policies alternating between A and B deployments each time
    it is released as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The clean-up of redundant firewall rules](img/B05559_06_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The required ACL rules are always available for **Application1** as a dependency
    as it subscribes to connectivity at the zone level as opposed to the subnet level:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The clean-up of redundant firewall rules](img/B05559_06_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Application decommissioning
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of immutable subnets makes the decommissioning of applications easy
    when they are no longer required. The clean-up logic already exists for subnets
    and associated ACL rules so that already-created automation can be re-used to
    do a full clean-up of the microservice application when it needs to be retired.
  prefs: []
  type: TYPE_NORMAL
- en: A clean-up pipeline can easily be provided by the operations and networking
    team for development teams to clean up applications that are no longer required.
    Their allocated subnet ranges can then be released by the IPAM solution so they
    are available to new microservice applications that need to be on-boarded onto
    the platform.
  prefs: []
  type: TYPE_NORMAL
- en: Using Ansible to orchestrate SDN controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Ansible, as discussed in [Chapter 5](ch05.html "Chapter 5. Orchestrating Load
    Balancers Using Ansible"), *Orchestrating Load Balancers Using Ansible*, can be
    used to issue and configure servers as well as issue commands directly to an **SDK**
    or **REST** **API**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Ansible to orchestrate SDN controllers](img/B05559_06_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is very useful when orchestrating SDN controllers that provide Restful
    API endpoints and an array of SDKs to control software-defined object models that
    allow network operators to automate all network operations.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of the Nuage VSP platform, the VSD component, which builds the overlay
    network, is all REST API calls behind the scenes, so all operations can be orchestrated
    using the Nuage Java or Python SDK, which wrap REST API calls.
  prefs: []
  type: TYPE_NORMAL
- en: The Nuage VSPK SDK would simply need to be installed on the Ansible control
    host, and then it can be used to orchestrate Nuage. As Ansible is written in Python,
    modules can be easily created to orchestrate each object model in the Nuage entity
    tree.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Nuage VSPK modules could alternately be written in any programming
    language that is available, such as Java, but Ansible's boilerplate for Python
    is probably the simplest way of creating modules.
  prefs: []
  type: TYPE_NORMAL
- en: The Nuage VSPK object model has parent and child relationships between entities,
    so lookups need to be done on parent objects to return the child entities using
    the unique identifier associated with the entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example highlights the list of operations required to build the
    Nuage VSPK object tree:'
  prefs: []
  type: TYPE_NORMAL
- en: A new Nuage `session` is started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `user` is used to create a child `enterprises`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `domain_templates` is created as a child of the enterprise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A `domains` is an instantiated as child of the domain template.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A child `zone` is created against the domain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A child `subnet` is created against the zone.![Using Ansible to orchestrate
    SDN controllers](img/B05559_06_32.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using SDN for disaster recovery
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the main benefits of using Ansible for orchestration is that it can be
    used to create a set of day one playbooks to build out the initial network prior
    to it being used for self-service by developers. So the initial setup of the Nuage
    **organization**, **Company L3 Domain Template**, and layer 3 domains can be created
    among any other necessary operations as a day one playbook or role.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Nuage Python VSPK can be utilized to easily create the organization called
    **Company**, layer 3 domain template called **L3 Domain Template**, and two layer
    3 domains called **Test** and **Prod** as per the Nuage VSPK object model, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using SDN for disaster recovery](img/B05559_06_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Each of these Python commands can easily be wrapped in Ansible to create a set
    of modules to create a day one playbook utilizing `delegate_to` localhost. which
    will execute each module on the Ansible control host and then connect to the Nuage
    APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Each module, by default, should be written so that it is idempotent and detects
    if the entity exists, before issuing a `Create` command. If the entity already
    exists, then it shouldn't issue a `Create` command if the overlay network is already
    in the desired state.
  prefs: []
  type: TYPE_NORMAL
- en: The day one playbook can be used to build the whole network from scratch in
    the event of a disaster if the whole network needs to be restored. The day one
    playbook should be stored in source control. While each deployment pipeline will
    build the application zones, subnets, and virtual machines under the initially
    defined structure.
  prefs: []
  type: TYPE_NORMAL
- en: A leaking domain governing legacy network connectivity and leaking domain association
    can also be added to the day one playbook if required.
  prefs: []
  type: TYPE_NORMAL
- en: Storing A/B subnets and ACL rules in YAML files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ansible can also be utilized to store self-service subnet and ACL rule information
    in `var` files that will be called from a set of self-service playbooks as part
    of each development team's deployment pipelines. Each application environment
    can be stored in a set of `var` files defining each of the A/B subnets.
  prefs: []
  type: TYPE_NORMAL
- en: A playbook to create A or B subnets would be used to run `delegate_to` localhost
    to carry out the creation actions against the Nuage VSD API.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook would be set up to do the following things:'
  prefs: []
  type: TYPE_NORMAL
- en: Create the zone, if one has not already been created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create the subnet in Nuage mapped to OpenStack using a subnet YAML file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Apply ACL policies for Ingress and Egress rules to the policies applying them
    directly to the subnet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As with the day one playbook, unique modules can be written for each of the
    VSPK commands; in this example, the Python VSPK creates a zone called **Application1**
    and a subnet called **Subnet A Application1**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing A/B subnets and ACL rules in YAML files](img/B05559_06_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So these commands can also be wrapped in Ansible modules, should be completely
    idempotent, and the desired state of the network is determined by the `var` files
    that are stored in source control.
  prefs: []
  type: TYPE_NORMAL
- en: The logic in the playbook would load the `var` files by pulling them from source
    control at deployment time. The playbook would then use the Jinja2 filter conditions
    to detect if either the A or B subnet or neither was present using the when conditions.
  prefs: []
  type: TYPE_NORMAL
- en: If neither subnet was present, subnet A would be created, or if subnet A was
    present, then subnet B would be created.
  prefs: []
  type: TYPE_NORMAL
- en: 'The playbook could read this information from the environment specific `var`
    file that is specified in the following screenshot. As it is idempotent, it will
    run over the zone, creating it if it doesn''t already exist, and use the jinja2
    playbook when conditions to either create subnet A or B:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing A/B subnets and ACL rules in YAML files](img/B05559_06_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A unique set of A and B subnets would be checked into source control as a prerequisite
    for every required environment, with one or more environments per layer 3 domain.
  prefs: []
  type: TYPE_NORMAL
- en: ACL rules should ideally be consistent across all environments encapsulated
    in a layer 3 domain, so an explicit set of ACL rules would be created and assigned
    to the application's unique policy for Ingress and Egress rules that would span
    all environments.
  prefs: []
  type: TYPE_NORMAL
- en: Each environment could have its own unique policy for Egress and Ingress per
    layer 3 subnet. The Ansible playbook could then append a unique identifier for
    the environment to the policy name if multiple environments existed under the
    **Test** layer 3 domain to server integration, UAT, or other test environments.
  prefs: []
  type: TYPE_NORMAL
- en: The unique ACL rules for an application can be filled in by development teams
    as part of the on-boarding to the new platform based on the minimum connectivity
    required to make the application function, with a deny all applied to the layer
    3 domain template.
  prefs: []
  type: TYPE_NORMAL
- en: The ACL rules should always be subnet to zone for inter-dependencies and each
    ACL rule will be created with the subnet as the source, so that when subnets are
    destroyed, the ACL rules will automatically be cleaned up.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of how the self-service ACL rules file would look is displayed as
    follows It would create two ingress rules and one Egress rule against the **Application1**
    policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Storing A/B subnets and ACL rules in YAML files](img/B05559_06_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The self-service playbook could be provided to development teams so that they
    always have a standard way to create zones and subnets. The YAML structure of
    the `var` files will also provide templates of what the desired state of the network
    should be. This means that pointing the automated pipelines at another Nuage endpoint
    would mean the whole network could be built out programmatically from source control.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have looked at different networking operations that SDN
    controllers can help automate, and sought to debunk some of the common misconceptions
    associated with software-defined networking.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at ways in which companies can benefit from using software-defined
    networking and looked at ways in which SDN solutions can help solve some of the
    challenges associated with network operations.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then focused on ways that network operations need to adapt and embrace
    automation so development teams can self-serve a subset of different networking
    tasks, and ways in which networking can be divided and responsibilities shared.
    We then focused on the benefits of immutable A/B networking and how it can help
    simplify the network and build consistent programmatically controlled networks
    while keeping firewall rules clean.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you should have learned why software-defined networking is
    important to organizations looking to scale network operations. We have also covered
    ways in which overlay network object models can be utilized by microservice applications
    and the benefits of immutable networking and A/B subnets.
  prefs: []
  type: TYPE_NORMAL
- en: Key takeaways from this chapter also include different ways that SDN controllers
    can help network operators to build out day one networks, which pieces of network
    operations can be made self-service, and the ways in which Ansible can be used
    to programmatically control network operations using Rest API calls or an SDK.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at continuous integration and how network
    operations can take some of the best practices from development teams and apply
    them to networking operations, so that networking is versioned properly and can
    be used to roll forward and roll back changes.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have established a basis for continuous integration, we will move onto
    chapters that cover network testing and Continuous Delivery, which will outline
    a set of best practices that should allow network teams to integrate network automation
    into deployment pipelines.
  prefs: []
  type: TYPE_NORMAL
