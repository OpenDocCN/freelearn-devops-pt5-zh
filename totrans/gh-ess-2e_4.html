<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Collaboration Using the GitHub Workflow</h1>
                
            
            
                
<p class="calibre3">In <a target="_blank" href="part0066.html#1UU540-184576c1044a4350bd24f18b869c0732" class="calibre10">Chapter 3</a>, <em class="calibre14">Managing Organizations and Teams</em>, we explored how you can create and manage organizations and teams that will further help you in collaborating with others.</p>
<p class="calibre3">GitHub is a great tool for collaboration and, as such, it has come up with a workflow based on the features it provides and the power of Git. It has named it the GitHub workflow (<a href="https://guides.github.com/introduction/flow" class="calibre10">https://guides.github.com/introduction/flow</a>).</p>
<p class="calibre3">In this chapter, we will learn how to work with branches and pull requests, which are the most powerful features of GitHub. Here's what we will cover:</p>
<ul class="calibre11">
<li class="calibre12">Learning about pull requests</li>
<li class="calibre12">Peer review and inline comments</li>
<li class="calibre12">Merging the pull request</li>
<li class="calibre12">Tips and tricks</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Learning about pull requests</h1>
                
            
            
                
<p class="calibre3">Pull request is the number one feature in GitHub that made it what it is today. It was introduced in early 2008 and has been used extensively among projects since then.</p>
<div><p class="calibre19">While everything else can be pretty much disabled in a project's settings (such as issues and the wiki), pull requests are always enabled.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Why pull requests are a powerful asset to work with</h1>
                
            
            
                
<p class="calibre3">Whether you are working on a personal project where you are the sole contributor, or on a big open source project with contributors from all over the globe, working with pull requests will certainly make your life easier.</p>
<p class="calibre3">Think of pull requests like chunks of commits, and the GitHub UI helps you clearly visualize what is about to be merged in the default branch or the branch of your choice. Pull requests are reviewable with an enhanced different view. You can easily revert them with a simple button on GitHub and they can be tested before merging, provided a CI service is enabled in the repository.</p>
<div><strong class="calibre108">CI</strong> stands for <strong class="calibre108">continuous integration</strong>. For more details, you can refer to the applications that GitHub integrates at <a href="https://github.com/marketplace/category/continuous-integration" class="calibre25">https://github.com/marketplace/category/continuous-integration</a>. <strong class="calibre108"><br class="calibre109"/></strong></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The connection between branches and pull requests</h1>
                
            
            
                
<p class="calibre3">There is a special connection between branches and pull requests. In this connection, GitHub will automatically show you a button to create a new pull request if you push a new branch in your repository. As we will explore in the following sections, this is tightly coupled to the GitHub workflow, and GitHub uses some special words to describe the <em class="calibre14">from</em> and <em class="calibre14">to</em> branches. As per GitHub's documentation:</p>
<div><p class="calibre3"><em class="calibre14">The base branch is where you think changes should be applied, the head branch is what you would like to be applied.</em><br class="calibre7"/></p>
</div>
<p class="calibre3">So, in GitHub terms, head is your branch, and base is the branch you would like to merge into.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating branches directly in a project – the shared repository model</h1>
                
            
            
                
<p class="calibre3">The shared repository model, as GitHub aptly calls it, is when you push new branches directly to the source repository. From there, you can create a new pull request by comparing between branches, as we will see in the following sections.</p>
<p class="calibre3">Of course, in order to be able to push to a repository, you either have to be the owner or a collaborator; in other words, you must have write access.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating branches in your fork – the fork and pull model</h1>
                
            
            
                
<p class="calibre3">Forked repositories are related to their parent in a way that GitHub uses in order to compare their branches. The fork and pull model is usually used in projects when you do not have write access, but are willing to contribute.</p>
<p class="calibre3">After forking a repository, you push a branch to your fork and then create a pull request in the parent repository, asking its maintainer to merge the changes. This is common practice for contributing to open source projects hosted on GitHub. You will not have access to their repository, but, being open source, you can fork the public repository and work on your own copy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">How to create and submit a pull request</h1>
                
            
            
                
<p class="calibre3">There are quite a few ways to initiate the creation of a pull request, as we will see in the following sections.</p>
<p class="calibre3">The most common one is to push a branch to your repository and let GitHub's UI guide you. Let's explore this option first.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the Compare &amp; pull request button</h1>
                
            
            
                
<p class="calibre3">Whenever a new branch is pushed to a repository, GitHub shows a quick button to create a pull request. In reality, you are taken to the compare page, as we will explore in the next section, but some values are already filled out for you.</p>
<p class="calibre3">Let's create, for example, a new branch named <kbd class="calibre13">add-gitignore</kbd> where we will add a <kbd class="calibre13">.gitignore</kbd> file with the following content:</p>
<pre class="calibre18"><strong class="calibre1">git checkout -b add-gitignore
echo 'password' &gt; .gitignore
git add .gitignore
git commit -m 'Add .gitignore'
git push origin add-gitignore</strong></pre>
<p class="calibre3">Next, head over to your repository's main page and you will notice the Compare &amp; pull request button:</p>
<div><img src="img/00099.jpeg" class="calibre110"/></div>
<p class="calibre3">From here on, if you hit this button, you will be taken to the compare page. Note that I am pushing to my repository following the shared repository model, so this is how GitHub greets me:</p>
<div><img src="img/00100.jpeg" class="calibre111"/></div>
<p class="calibre3">What would happen if I used the fork and pull repository model? For this purpose, I created another user to fork my repository and followed the same instructions to add a new branch named <kbd class="calibre13">add-gitignore-2</kbd> with the same changes. From here on, when you push the branch to your fork, the Compare &amp; pull request button appears whether you are on your fork's page or on the parent repository.</p>
<p class="calibre3">This is how it looks if you visit your fork:</p>
<div><img src="img/00101.jpeg" class="calibre112"/></div>
<p class="calibre3">The following screenshot will appear if you visit the parent repository:</p>
<div><img src="img/00102.jpeg" class="calibre113"/></div>
<p class="calibre3">In the last case, you can see from which user this branch came from (axil42:add-gitignore-2).</p>
<p class="calibre3">In either case, when using the fork and pull model, hitting the Compare &amp; pull request button will take you to the compare page with slightly different options:</p>
<div><img src="img/00103.jpeg" class="calibre114"/></div>
<p class="calibre3">Since you are comparing across forks, there are more details. In particular, you can see the base fork and branch as well as the head fork and branch that you are the owner of.</p>
<p class="calibre3">GitHub considers the default branch set in your repository to be the one you want to merge into (base) when the Create pull request button appears.</p>
<p class="calibre3">Before submitting it, let's explore the other two options that you can use to create a pull request. You can jump to the <em class="calibre14">Submitting a pull request</em> section if you like.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the compare function directly</h1>
                
            
            
                
<p class="calibre3">As mentioned in the previous section, the Compare &amp; pull request button takes you to the compare page with some predefined values. The button appears right after you push a new branch and is there only for a few moments. In this section, we will see how to use the compare function directly in order to create a pull request.</p>
<p class="calibre3">You can access the compare function by clicking on the New pull request button next to the branch drop-down list on a repository's main page:</p>
<div><img src="img/00104.jpeg" class="calibre115"/></div>
<p class="calibre3">This is pretty powerful as you can compare across forks or, in the same repository, pretty much everything—branches, tags, single commits, and time ranges.</p>
<p class="calibre3">The default page when you land on the compare page is as follows; you start by comparing your default branch with GitHub, proposing a list of recently created branches to choose from and compare:</p>
<div><img src="img/00105.jpeg" class="calibre116"/></div>
<div><p class="calibre19">In order to have something to compare to, the commits of the base branch must be older than what you are comparing to.</p>
</div>
<p class="calibre3">From here, if I choose the <kbd class="calibre13">add-gitignore</kbd> branch, GitHub compares it to a master and shows the differences along with the message that it is able to be merged into the base branch without any conflicts. Finally, you can create the pull request:</p>
<div><img src="img/00106.jpeg" class="calibre117"/></div>
<p class="calibre3">Notice that I am using the compare function while I'm at my own repository. When comparing in a repository that is a fork of another, the compare function slightly changes and automatically includes more options, as we have seen in the previous section.</p>
<p class="calibre3">As you may have noticed, the New pull request quick button is just a shortcut for using the compare function manually. If you want to have more fine-grained control on the repositories and the branches compared, use the compare feature directly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the GitHub web editor</h1>
                
            
            
                
<p class="calibre3">So far, we have seen the two most well-known method for initiating a pull request. There is a third way as well: using the web editor that GitHub provides in its entirety. This can prove useful for people who are not too familiar with Git and the Terminal, and can also be used by more advanced Git users who want to propose a quick change.</p>
<p class="calibre3">As always, according to the model you are using (shared repository or fork and pull), the process is a little different. Let's first explore the shared repository model flow using the web editor, which means editing files in a repository that you own.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The shared repository model</h1>
                
            
            
                
<p class="calibre3">Firstly, make sure that you are on the branch that you wish to branch off; then, head over to a file that you wish to change and press the edit button with the pencil icon:</p>
<div><img src="img/00107.jpeg" class="calibre118"/></div>
<p class="calibre3">Make the change you want to that file, add a proper commit message, and choose Create a new branch, giving the name of the branch you wish to create. By default, the branch name is <kbd class="calibre13">username-patch-i</kbd>, where <kbd class="calibre13">username</kbd> is your username and <kbd class="calibre13">i</kbd> is an increasing integer starting from <kbd class="calibre13">1</kbd>. Consecutive edits on files will create branches such as <kbd class="calibre13">username-patch-1</kbd>, <kbd class="calibre13">username-patch-2</kbd>, and so on. In our example, I decided to give the branch a name of my own:</p>
<div><img src="img/00108.jpeg" class="calibre119"/></div>
<p class="calibre3">When ready, press the Propose file change button. From this moment on, the branch is created with the file edits you made. Even if you close the next page, your changes will not be lost. Let's skip the pull request submission for the time being and see how the fork and pull model works.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The fork and pull model</h1>
                
            
            
                
<p class="calibre3">In the fork and pull model, you fork a repository and submit a pull request from the changes you make in your fork. In the case of using the web editor, there is a caveat. In order to get GitHub to automatically recognize that you wish to perform a pull request in the parent repository, you have to start the web editor from the parent repository and not your fork. In the following screenshot, you can see what happens in this case:</p>
<div><img src="img/00109.jpeg" class="calibre120"/></div>
<p class="calibre3">GitHub informs you that a new branch will be created in your repository (fork) with the new changes in order to submit a pull request. Hitting the Propose file change button will take you to the form to submit the pull request:</p>
<div><img src="img/00110.jpeg" class="calibre32"/></div>
<p class="calibre3">Contrary to the shared repository model, you can now see the base/head repositories and branches that are compared. Also, notice that the default name for the new branch is <kbd class="calibre13">patch-i</kbd>, where <kbd class="calibre13">i</kbd> is an increasing integer number. In our case, this was the first branch created that way, so it was named <kbd class="calibre13">patch-1</kbd>.</p>
<p class="calibre3">If you would like to have the ability to name the branch the way you like, you should follow the shared repository model instructions, as explained in the preceding section. Following that route, edit the file in your fork where you have write access, add your own branch name, hit the Propose file change button for the branch to be created, and then abort when asked to create the pull request. You can then use the New pull request quick button or use the compare function directly to propose a pull request to the parent repository.</p>
<p class="calibre3">One last thing to consider when using the web editor is the limitation of editing one file at a time. If you wish to include more changes in the same branch that GitHub created for you when you first edited a file, you must first change to that branch and then make any subsequent changes. How to change the branch? Simply choose it from the drop-down menu, as shown in the following screenshot:</p>
<div><img src="img/00111.jpeg" class="calibre121"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Submitting a pull request</h1>
                
            
            
                
<p class="calibre3">So far, we have explored the various ways to initiate a pull request. In this section, we will finally submit it.</p>
<p class="calibre3">The pull request form is identical to the form when creating a new issue. For more details, refer to <a target="_blank" href="part0020.html#J2B80-184576c1044a4350bd24f18b869c0732" class="calibre10">Chapter 1</a>, <em class="calibre14">Brief Repository Overview and Usage of the Issue Tracker</em>, the <em class="calibre14">Learning how to use the powerful benefits of the issue tracker</em> section.</p>
<p class="calibre3">If you have write access to the repository that you are making the pull request to, then you are able to set labels, milestones, and assignees.</p>
<p class="calibre3">The title of the pull request is automatically filled by the last commit message that the branch has or, if there are multiple commits, it will just fill in the branch name. In either case, you can change it as you see fit. In the following screenshot, you can see that the title is taken from the branch name after GitHub has stripped the special characters. In a sense, the title gets humanized:</p>
<div><img src="img/00112.jpeg" class="calibre122"/></div>
<p class="calibre3">You can add an optional description and images if you want. Whenever ready, hit the Create pull request button. In the following sections, we will explore how the peer review works and eventually merge the pull request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Peer review and inline comments</h1>
                
            
            
                
<p class="calibre3">The cool thing about pull requests is that you have a nice and clear view of what is about to get merged. You can see only the changes that matter, and the best part is that you can fire up a discussion concerning those changes.</p>
<p class="calibre3">In the previous section, we submitted the pull request so that it can be reviewed and eventually get merged. Suppose that we are collaborating with a team and they chime in to discuss the changes. Let's first check the layout of a pull request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The layout of a pull request</h1>
                
            
            
                
<p class="calibre3">Every pull request pretty much looks as follows:</p>
<div><img src="img/00113.jpeg" class="calibre123"/></div>
<p class="calibre3">From the previous screenshot, you can tell what the specific number of the pull request is. It is like an identifier within the repository and it is not separated from the issues count. Issues and pull requests share the same ID counter. So, in the preceding example, you can see that although this is our first pull request, it is numbered #6; the previous five were issues:</p>
<div><img src="img/00114.jpeg" class="calibre124"/></div>
<p class="calibre3">Then, there is the information that the pull request is Open and who wants to merge how many commits into which branch from which other branch:</p>
<div><img src="img/00115.jpeg" class="calibre125"/></div>
<p class="calibre3">Right below the information we just described, there are four tabs: Conversation, Commits, Checks, and Files changed. In Conversation, except for the comments that we will see in the following screenshots, GitHub also adds information about the events concerning the particular pull request. You can see the action and the time it occurred. For example, take a look at the following screenshot; even little changes such as adding a label are being recorded:</p>
<div><img src="img/00116.jpeg" class="calibre126"/></div>
<p class="calibre3">The Conversation tab is also where the final call takes place. This is where the button to merge the pull request resides, and you can see its status. The button is green, which means there are no conflicts between the changed files and the ones that are in the repository:</p>
<div><img src="img/00117.jpeg" class="calibre127"/></div>
<p class="calibre3">Finally, there is the comment form that is the same as in the issue tracker that we explored in <a target="_blank" href="part0020.html#J2B80-184576c1044a4350bd24f18b869c0732" class="calibre10">Chapter 1</a>, <em class="calibre14">Brief Repository Overview and Usage of the Issue Tracker</em>. You can leave any comments concerning the pull request here.</p>
<p class="calibre3">The Commits tab shows the commits made in this branch and the commits that are not yet in the branch you are merging into. For example, the <kbd class="calibre13">update-readme</kbd> branch has two commits that do not exist in <kbd class="calibre13">master</kbd>. GitHub shows the commits in chronological order along with other information, such as who the author is, and links to the commits:</p>
<div><img src="img/00118.jpeg" class="calibre128"/></div>
<p class="calibre3">The Checks tab is reserved for external services that talk to GitHub's API and can perform checks on the pull request. That can be a continuous integration service that tests the code, or one that checks if the pull request conforms to some guidelines. We won't get into any details since this is a very broad area outside the scope of this book, but you're free to read more on GitHub's documentation at <a href="https://help.github.com/articles/about-status-checks/#checks" class="calibre10">https://help.github.com/articles/about-status-checks/#checks.</a></p>
<p class="calibre3">Finally, the Files changed tab shows the files that are changed in this pull request. There are two ways to see the differences in the commits. The default one is to see the changes in a unified way, with additions and deletions on the same page, as shown in the following screenshot:</p>
<div><img src="img/00119.jpeg" class="calibre129"/></div>
<div><p class="calibre19">Note that for each addition, GitHub marks a line with a green background color. On the contrary, if you were to remove some lines, they would show in pink. I will leave that to you as an exercise.</p>
</div>
<p class="calibre3">The other way is to choose Split, and GitHub will show the differences in a side-by-side view. Under the Diff settings drop-down menu, there's the option to see the changes in Split mode. Choose it and hit Apply and reload for the changes to take effect:</p>
<div><img src="img/00120.jpeg" class="calibre32"/></div>
<p class="calibre3">In the next section, we will further explore the Files changed tab since this is where the review process takes place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The review process</h1>
                
            
            
                
<p class="calibre3">To make the review process a bit easier to follow, there are a couple of features that are useful when dealing with a lot of commits and changed files.</p>
<p class="calibre3">The Changes from drop-down menu is helpful if you want to see the changes introduced by a single commit or a range of commits:</p>
<div><img src="img/00121.jpeg" class="calibre130"/></div>
<p class="calibre3">Next to it, the Jump to dropdown provides a list of all changed files that you can choose and jump to:</p>
<div><img src="img/00122.jpeg" class="calibre131"/></div>
<p class="calibre3">This might seem redundant when there's only two files, but it's powerful if there's a dozen of them as you don't have to manually scroll down the page and find what you're looking for.</p>
<p class="calibre3">In addition, this menu will become sticky as you scroll down a long page of changes so that you don't have to scroll all the way back up:</p>
<div><img src="img/00123.jpeg" class="calibre32"/></div>
<p class="calibre3">GitHub supports inline comments, so you can leave a comment under every changed line, as seen in the Files changed tab. When hovering over a line, you will notice the cross image, as shown in the following screenshot; click on it and the comment form will appear:</p>
<div><img src="img/00124.jpeg" class="calibre132"/></div>
<p class="calibre3">When writing a comment, you can either submit it right away as a single comment or start a review. When starting a review, the comment is submitted, but it doesn't notify the repository members. That way, you can submit comments in batches and notify the submitter of the pull request in one go. In the following example, there are two comments on the proposed changed files:</p>
<div><img src="img/00125.jpeg" class="calibre133"/></div>
<p class="calibre3">Notice that they are in pending status and they wait to be finally submitted for review. Once you're ready to finish your review, hit the Finish your review button under your comments or use the Review changes drop-down menu.</p>
<div><img src="img/00126.jpeg" class="calibre134"/></div>
<p class="calibre3">From there on, you have three options. The first one is just to Comment and ask nothing else from the submitter. The second option is to Approve the changes while leaving your feedback. Finally, the last one is to Request changes, usually in the lines where you commented on. Optionally, leave a review summary and click <strong class="calibre5">Submit review</strong>.</p>
<p class="calibre3">With a few comments on the diff and a request for changes, we can see a couple of things. First of all, inline comments count towards the overall conversation, so the Conversation tab should pick that number. Furthermore, since changes were requested, that is shown in the pull request widget at the bottom:</p>
<div><img src="img/00127.jpeg" class="calibre135"/></div>
<p class="calibre3">As the submitter of the pull request, you can click on the <strong class="calibre5">See review</strong> link and be taken to the review comments or hit <strong class="calibre5">Dismiss review</strong> if you think you have addressed all the comments. In the latter case, you will need to add a comment justifying your action.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Correcting mistakes</h1>
                
            
            
                
<p class="calibre3">So far, we have seen how conversations begin, but what happens when the changes you made need some tweaking to be considered as ready to merge?</p>
<p class="calibre3">In this case, you can push new commits to the branch associated with the pull request and GitHub will pick up those changes and amend it. The new changes will show up and further feedback can be given. In <em class="calibre14">The review process</em> section, my evil twin, user <kbd class="calibre13">axil42</kbd>, raised a concern about a wrong line being committed. We will now make a new commit and push it to the <kbd class="calibre13">update-readme</kbd> branch and see what happens:</p>
<pre class="calibre18"><strong class="calibre1">git checkout update-readme
sed -i 's/Test change/For more info, check the wiki/' README.md # replace text
git add README.md
git commit -m 'Correct line in README.md'
git push origin update-readme</strong></pre>
<p class="calibre3">Back in GitHub, three changes occurred. Firstly, there was another commit added to the Commits tab. Then, in the Files changed tab, since the line on which the comments were relying on was removed, the comments no longer appeared. Instead, you can see that in the Conversation tab, this particular discussion was marked as outdated:</p>
<div><img src="img/00128.jpeg" class="calibre136"/></div>
<p class="calibre3">If you were by, any chance, in the Files changed tab while the last commit was pushed, GitHub would inform you about the changes and would urge you to refresh the page:</p>
<div><img src="img/00129.jpeg" class="calibre137"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Merging the pull request</h1>
                
            
            
                
<p class="calibre3">After the conversation took place, changes were made, and the peer review worked as expected, so it's now time to finally merge the pull request.</p>
<p class="calibre3">If you don't have access to merge the pull request, you should see the following result:</p>
<div><img src="img/00130.jpeg" class="calibre138"/></div>
<p class="calibre3">On the other hand, owners or collaborators with write access can also merge pull requests. In this case, you should see the Merge pull request green button. From the arrow next to it, you can optionally choose the merge method before merging it. There are three options, with the default one being the creation of a merge commit. Pick the one you want and hit merge:</p>
<div><img src="img/00131.jpeg" class="calibre139"/></div>
<p class="calibre3">Pressing this button will not merge it immediately, but you will have another chance to confirm:</p>
<div><img src="img/00132.jpeg" class="calibre140"/></div>
<p class="calibre3">The commit message of this merge is the one in bold, and the one below that can be edited is the extended commit message, which, by default, grabs the pull request title. In the extended commit message, you can reference issue numbers with a special meaning. Read more in the <em class="calibre14">Tips and tricks</em> section of this chapter to learn how to automatically close issues from pull requests.</p>
<p class="calibre3">Once merged, you can see the green icons turning to purple. This indicates a merged pull request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Removing/restoring a branch after the pull request is merged</h1>
                
            
            
                
<p class="calibre3">In order to have everything cleaned up and tidy, GitHub offers removing the merged branch with a simple button right after the pull request is merged:</p>
<div><img src="img/00133.jpeg" class="calibre141"/></div>
<p class="calibre3">After the deletion is completed, GitHub makes this an action event. If you changed your mind, you can always restore the removed branch again using the Restore branch button, as shown in the following screenshot:</p>
<div><img src="img/00134.jpeg" class="calibre142"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Reverting a pull request</h1>
                
            
            
                
<p class="calibre3">There are cases where you might want to revert a pull request, and GitHub makes this extremely easy. Right after the merge happens, there will be a Revert button next to the merge action:</p>
<div><img src="img/00135.jpeg" class="calibre143"/></div>
<p class="calibre3">Pressing this button will create a new pull request with opposite commits to the ones the previous pull request included.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Tips and tricks</h1>
                
            
            
                
<p class="calibre3">So far, we have explored most of the functionality of pull requests. Let's see a couple of things that leverage their power even more.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Closing issues via commit messages</h1>
                
            
            
                
<p class="calibre3">In <a target="_blank" href="part0020.html#J2B80-184576c1044a4350bd24f18b869c0732" class="calibre10">Chapter 1</a>, <em class="calibre14">Brief Repository Overview and Usage of the Issue Tracker</em>, in the <em class="calibre14">Tips and tricks</em> section, you learned how to reference issues inside the issue tracker. Extending this ability, you can reference issue numbers in commit messages in order to close some issues when the commit is merged to the default branch.</p>
<p class="calibre3">For this action to be triggered, you have to use some keywords. For example, <kbd class="calibre13">Closes #42</kbd> in the commit message will close issue 42 when that commit is merged with the default branch.</p>
<p class="calibre3">As per the GitHub documentation, the following keywords will close an issue via a commit message:</p>
<ul class="calibre11">
<li class="calibre12">close</li>
<li class="calibre12">closes</li>
<li class="calibre12">closed</li>
<li class="calibre12">fix</li>
<li class="calibre12">fixes</li>
</ul>
<ul class="calibre11">
<li class="calibre12">fixed</li>
<li class="calibre12">resolve</li>
<li class="calibre12">resolves</li>
<li class="calibre12">resolved</li>
</ul>
<p class="calibre3">Let's take, for example, an open issue such as the following one and note down its number, which in this case is 2:</p>
<div><img src="img/00136.jpeg" class="calibre144"/></div>
<p class="calibre3">Then, make a commit, which, in its message, has one of the preceding keywords, referencing the preceding issue number. We will follow the GitHub flow that we learned in this chapter, so first create a new branch:</p>
<pre class="calibre18"><strong class="calibre1">git checkout master</strong><br class="title-page-name"/><strong class="calibre1">git checkout -b fix-issue-2</strong></pre>
<p class="calibre3">For the sake of our example, I modified one file in the repository and then committed it with the following:</p>
<pre class="calibre18"><strong class="calibre1">git commit -m 'Demo example of closing issues. Closes #2'
git push origin fix-issue-2</strong></pre>
<p class="calibre3">Then, open a new pull request to merge the branch we just created, and merge it like you learned in this chapter.</p>
<p class="mce-root1">Going back to the issue tracker, you will no longer see issue <kbd class="calibre13">#2</kbd> among the open issues. Instead, go to the closed ones and you will see that issue <kbd class="calibre13">#2</kbd> is closed. GitHub provides all the necessary information:</p>
<div><img src="img/00137.jpeg" class="calibre145"/></div>
<p class="calibre3">For more information on closing issues via commit messages, check out GitHub's documentation at <a href="https://help.github.com/articles/closing-issues-using-keywords/" class="calibre10">https://help.github.com/articles/closing-issues-using-keywords/</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Task lists in pull requests</h1>
                
            
            
                
<p class="calibre3">A nice feature when submitting a pull request, which is a work in progress, is the task lists. A work in progress pull request would mean that you work on a specific feature/bug, and so on, but there are many changes that cannot be committed in one go and you also need someone to peer review your progress while working on it.</p>
<p class="calibre3">In this case, you will find task lists quite handy. Let's create a pull request and, in the description box, add the following:</p>
<pre class="calibre18">- [ ] First item
- [ ] Second item
- [ ] Third item
  - [ ] Fourth nested item
  - [ ] Fifth nested item
- [x] Sixth item , closes #2 (marked as resolved)</pre>
<p class="calibre3">The result will be a list with checkboxes where you can manually check/uncheck the items whenever you complete a task:</p>
<div><img src="img/00138.jpeg" class="calibre146"/></div>
<p class="calibre3">If you head over to the pull request tracker for an overview, you will see the task list showing the following pull request:</p>
<div><img src="img/00139.jpeg" class="calibre147"/></div>
<p class="calibre3">This works for cross references as well, and since we referenced issue 2 in the task list, this will be recorded in the issue:</p>
<div><img src="img/00140.jpeg" class="calibre148"/></div>
<div><p class="calibre19">Task lists can also exist in issues.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Downloading the diff of pull requests</h1>
                
            
            
                
<p class="calibre3">For the hardcore fans of patch and diff files, GitHub has this nice feature where you can view and download the changes that a pull request introduces in the format of a patch. Simply append <kbd class="calibre13">.patch</kbd> to the URL of a pull request. For example, <a href="https://github.com/github-essentials/github-essentials-v2/pull/6" class="calibre10">https://github.com/github-essentials/github-essentials-v2/pull/6</a> becomes <a href="https://github.com/github-essentials/github-essentials-v2/pull/6.patch" class="calibre10">https://github.com/github-essentials/github-essentials-v2/pull/6.patch</a>. The content of this file includes all the commits of a pull request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">A global list of your open pull requests</h1>
                
            
            
                
<p class="calibre3">Right next to the search bar at the top, there is a link named Pull requests that takes you to a page where you can find all your pull requests that are open. Go to <a href="https://github.com/pulls" class="calibre10">https://github.com/pulls</a> directly to visit this page.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding a LICENSE file using the web editor</h1>
                
            
            
                
<p class="calibre3">Much like you can edit the already existing files, you can also create new ones. In this case, we want to add a license file, and GitHub provides a way of choosing among a variety of them. On your repository's initial page, under the Code tab, click the Create new file button:</p>
<div><img src="img/00141.jpeg" class="calibre149"/></div>
<p class="calibre3">On the next page, type <kbd class="calibre13">LICENSE</kbd> so that the Choose a license template button appears:</p>
<div><img src="img/00142.jpeg" class="calibre150"/></div>
<p class="calibre3">Click on it and choose a license from the ones GitHub provides. Once done, hit Review and submit:</p>
<div><img src="img/00143.jpeg" class="calibre32"/></div>
<p class="calibre3">In the next step, you are called to commit your changes straight to the default branch or create a pull request. Once the changes are merged, if you navigate to the repository's main page, you will see a link to the license file that you just committed:</p>
<div><img src="img/00144.jpeg" class="calibre151"/></div>
<p>Here is an easter egg. You can type <kbd class="calibre23">LICENCE</kbd> the British way or type <kbd class="calibre23">LICENSE</kbd> the American way. GitHub is smart enough to respect this language quirk and, in fact, it doesn't even care about the case of the letters. For what it's worth, typing <kbd class="calibre23">LiCENce</kbd> or <kbd class="calibre23">liCEnSe</kbd> is still considered the same! Lastly, the word <kbd class="calibre23">copying</kbd> is also considered to be a synonym to license, so the previous examples apply to this word as well.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Creating new directories using the web editor</h1>
                
            
            
                
<p class="calibre3">Apart from creating new files, you can also create new directories via the web editor. Just click on the Create new file button, like we demonstrated in the previous trick of choosing a license, and type the name of the directory ending with a slash (<kbd class="calibre13">/</kbd>). You can repeat this process as many times as you like.</p>
<p class="calibre3">The only caveat is that empty directories are not being picked up by Git and, by extension, by GitHub, so you will have to provide a file at the end if you want to commit this change.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre3">In this chapter, we explored the GitHub workflow and the various ways to perform a pull request, as well as the many features that GitHub provides to make that workflow even smoother. This is how the majority of open source projects work when there are dozens of contributors involved.</p>
<p class="calibre3">In the next chapter, we will see how to make pretty, static web pages that are hosted solely on GitHub and how to read the analytics that GitHub provides for each project.</p>


            

            
        
    </body></html>