<html><head></head><body>
        

                            
                    Modern Infrastructures and Applications with Docker
                
            
            
                
<p class="mce-root">Microservices and containers have probably been the most frequently mentioned buzzwords in recent years. These days, we can still hear about them at conferences across the globe. Although both terms are definitely related when talking about modern applications, they are not the same. In fact, we can execute microservices without containers and run big monolithic applications in containers. In the middle of the container world, there is a well-known word that comes to mind when we find ourselves talking about them – Docker.</p>
<p class="mce-root">This book is a guide to passing the Docker Certified Associate exam, which is a certification of knowledge pertaining to this technology. We will cover each topic needed to pass this exam. In this chapter, we will start with what microservices are and why they are important in modern applications. We will also cover how Docker manages the requirements of this application's logical components. </p>
<p>This chapter will guide you through Docker's main concepts and will give you a basic idea of the tools and resources provided to manage containers.  </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Understanding the evolution of applications</li>
<li>Infrastructures</li>
<li>Processes</li>
<li>Microservices and processes</li>
<li>What are containers?</li>
<li>Learning about the main concepts of containers</li>
<li>Docker components</li>
<li>Building, shipping, and running workflows</li>
<li>Windows containers</li>
<li>Customizing Docker</li>
<li>Docker security</li>
</ul>
<p>Let's get started!</p>
<h1 id="uuid-89c64a5a-2545-43c7-8409-cf0031fb9f30">Technical requirements</h1>
<p>In this chapter, we will learn about various Docker Engine concepts. We'll provide some labs at the end of this chapter that will help you understand and learn about the concepts shown. These labs can be run on your laptop or PC using the provided Vagrant standalone environment or any already deployed Docker host that you own. You can find additional information in this book's GitHub repository: <a href="https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git">https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git</a></p>
<p>Check out the following video to see the Code in Action:</p>
<p>"<a href="https://bit.ly/3jikiSl" target="_blank">https://bit.ly/3jikiSl</a>"</p>
<h1 id="uuid-5510c7c7-5d26-47c0-97e4-6db42aa39347">Understanding the evolution of applications</h1>
<p>As we will probably read about on every IT medium, the concept of microservices is key in the development of new modern applications. Let's go back in time a little to see how applications have been developed over the years.</p>
<p class="mce-root">Monolithic applications are applications in which all components are combined into a single program that usually runs on a single platform. These applications were not designed with reusability in mind, nor any kind of modularity, for that matter. This means that every time a part of their code required an update, all the applications had to be involved in the process; for example, having to recompile all the application code in order for it to work. Of course, things were not so strict then.</p>
<p class="mce-root">Applications grew in number in terms of tasks and functionalities, with some of these tasks being distributed to other systems or even other smaller applications. However, the core components were kept immutable. We used this model of programming because running all application components together, on the same host, was better than trying to find some required information from other hosts. Network speed was insufficient in this regard, however. These applications were difficult to scale and difficult to upgrade. In fact, certain applications were locked to specific hardware and operating systems, which meant that developers needed to have the same hardware architectures at development stages to evolve applications.</p>
<p class="mce-root">We will discuss the infrastructure associated with these monolithic applications in the next section. The following diagram represents how the decoupling of tasks or functionalities has evolved from monolithic applications to <strong>Simple Object Access Protocol</strong> (<strong>SOAP</strong>) applications and the new paradigm of microservices:<br/></p>
<div><img src="img/4a2e3633-c533-4089-a8d4-d12cd4478860.png" style=""/></div>
<p class="mce-root">In trying to achieve better application performance and decoupling components, we moved to three-tier architectures, based on a presentation tier, an application tier, and a data tier. This allowed different types of administrators and developers to be involved in application updates and upgrades. Each layer could be running on different hosts, but components only talked to one another inside the same application.</p>
<p class="mce-root">This model is still present in our data centers right now, separating frontends from application backends before reaching the database, where all the requisite data is stored. These components evolved to provide scalability, high availability, and management. On occasion, we had to include new middleware components to achieve these functionalities (thus adding to the final equation; for example, application servers, applications for distributed transactions, queueing, and load balancers). Updates and upgrades were easier, and we isolated components to focus our developers on those different application functionalities.</p>
<p class="mce-root">This model was extended and it got even better with the emergence of virtual machines in our data centers. We will cover how virtual machines have improved the application of this model in more detail in the next section.</p>
<p>As Linux systems have grown in popularity, the interaction between different components, and eventually different applications, has become a requirement. SOAP and other queueing message integration have helped applications and components exchange their information, and networking improvements in our data centers have allowed us to start distributing these elements in different nodes, or even locations. </p>
<p>Microservices are a step further to decoupling application components into smaller units. We usually define a microservice as a small unit of business functionality that we can develop and deploy standalone. With this definition, an application will be a compound of many microservices. Microservices are very light in terms of host resource usage, and this allows them to start and stop very quickly. Also, it allows us to move application health from a high availability concept to resilience, assuming that the process dies (this can be caused by problems or just a component code update) and we need to start a new one as quickly as possible to keep our main functionality healthy.</p>
<p>Microservices architecture comes with stateless in mind. This means that the microservice state should be managed outside of its own logic because we need to be able to run many replicas for our microservice (scale up or down) and run its content on all nodes of our environment, as required by our global load, for example. We decoupled the functionality from the infrastructure (we will see how far this concept of "run everywhere" can go in the next chapter).</p>
<p>Microservices provide the following features:</p>
<ul>
<li style="font-weight: 400">Managing an application in pieces allows us to substitute a component for a newer version or even a completely new functionality without losing application functionality.</li>
<li style="font-weight: 400">Developers can focus on one particular application feature or functionality, and will just need to know how to interact with other, similar pieces.</li>
<li style="font-weight: 400">Microservices interaction will usually be effected using standard HTTP/HTTPS API <strong>Representational State Transfer</strong> (<strong>REST</strong>) calls. The objective of RESTful systems is to increase the speed of performance, reliability, and the ability to scale.</li>
<li>Microservices are components that are prepared to have isolated life cycles. This means that one unhealthy component will not wholly affect application usage. We will provide resilience to each component, and an application will not have full outages.</li>
<li>Each microservice can be written in different programming languages, allowing us to choose the best one for maximum performance and portability.</li>
</ul>
<p>Now that we have briefly reviewed the well-known application architectures that have developed over the years, let's take a look at the concept of modern applications.</p>
<p>A modern application has the following features:</p>
<ul>
<li style="font-weight: 400">The components will be based on microservices.</li>
<li style="font-weight: 400">The application component's health will be based on resilience.</li>
<li style="font-weight: 400">The component's states will be managed externally.</li>
<li style="font-weight: 400">It will run everywhere.</li>
<li>It will be prepared for easy component updates.</li>
<li>Each application component will be able to run on its own but will provide a way to be consumed by other components.</li>
</ul>
<p>Let's take a look.</p>
<h1 id="uuid-f052d798-1bc6-4467-8ba3-b2c57e940af7">Infrastructures</h1>
<p>For every described application model that developers are using for their applications, we need to provide some aligned infrastructure architecture.</p>
<p>On monolithic applications, as we have seen, all application functionalities run together. In some cases, applications were built for a specific architecture, operating system, libraries, binary versions, and so on. This means that we need at least one hardware node for production and the same node architecture, and eventually resources, for development. If we add the previous environments to this equation, such as certification or preproduction for performance testing, for example, the number of nodes for each application would be very important in terms of physical space, resources, and money spent on an application.</p>
<p>For each application release, developers usually need to have a full production-like environment, meaning that only configurations will be different between environments. This is hard because when any operating system component or feature gets updated, changes must be replicated on all application environments. There are many tools to help us with these tasks, but it is not easy, and the cost of having almost-replicated environments is something to look at. And, on the other hand, node provision could take months because, in many cases, a new application release would mean having to buy new hardware.</p>
<p>Third-tier applications would usually be deployed on old infrastructures using application servers to allow application administrators to scale up components whenever possible and prioritize some components over others.</p>
<p>With virtual machines in our data centers, we were able to distribute host hardware resources between virtual nodes. This was a revolution in terms of node provision time and the costs of maintenance and licensing. Virtual machines worked very well on monolithic and third-tier applications, but application performance depends on the host shared resources that are applied to the virtual node. Deploying application components on different virtual nodes was a common use case because it allowed us to run these virtually everywhere. On the other hand, we were still dependent on operating system resources and releases, so building a new release was dependent on the operating system.</p>
<p>From a developer's perspective, having different environments for building components, testing them side by side, and certificating applications became very easy. However, these new infrastructure components needed new administrators and efforts to provide nodes for development and deployment. In fast-growing enterprises with many changes in their applications, this model helps significantly in providing tools and environments to developers. However, agility problems persist when new applications have to be created weekly or if we need to accomplish many releases/fixes per day. New provisioning tools such as Ansible or Puppet allowed virtualization administrators to provide these nodes faster than ever, but as infrastructures grew, management became complicated.</p>
<p>Local data centers were rendered obsolete and although it took time, infrastructure teams started to use computer cloud providers. They started with a couple of services, such as <strong>Infrastructure as a Service</strong> (<strong>IaaS</strong>), that allowed us to deploy virtual nodes on the cloud as if they were on our data center. With new networking speeds and reliability, it was easy to start deploying our applications everywhere, data centers started to get smaller, and applications began to run on distributed environments on different cloud providers. For easy automation, cloud providers prepared their infrastructure's API for us, allowing users to deploy virtual machines in minutes.</p>
<p>However, as many virtualization options appeared, other options based on Linux kernel features and its isolation models came into being, reclaiming some old projects from the past, such as chroot and jail environments (quite common on <strong>Berkeley Software Distribution </strong>(<strong>BSD</strong>) operating systems) or Solaris zones.</p>
<p>The concept of process containers is not new; in fact, it is more than 10 years old. Process containers were designed to isolate certain resources, such as CPU, memory, disk I/O, or the network, to a group of processes. This concept is what is now known as <strong>control groups</strong> (also known as <strong>cgroups</strong>).</p>
<p>This following diagram shows a rough timeline regarding the introduction of containers to enterprise environments:</p>
<div><img src="img/7a084f41-a694-415e-abb7-62f49b0094a6.png" style=""/></div>
<p>A few years later, a container manager implementation was released to provide an easy way to control the usage of cgroups, while also integrating Linux namespaces. This project was named <strong>Linux Containers</strong> (<strong>LXC</strong>), is still available today, and was crucial for others in finding an easy way to improve process isolation usage.</p>
<p>In 2013, a new vision of how containers should run on our environments was introduced, providing an easy-to-use interface for containers. It started with an open source solution, and Solomon Hykes, among others, started what became known as Docker, Inc. They quickly provided a set of tools for running, creating, and sharing containers with the community. Docker, Inc. started to grow very rapidly as containers became increasingly popular.</p>
<p>Containers have been a great revolution for our applications and infrastructures and we are going to explore this area further as we progress.</p>
<h1 id="uuid-a4960ff9-d952-4459-86c4-cfe206ca2ef5">Processes</h1>
<p>A process is a way in which we can interact with an underlying operating system. We can describe a program as a set of coded instructions to execute on our system; a process will be that code in action. During process execution, it will use system resources, such as CPU and memory, and although it will run on its own environment, it can share information with another process that runs in parallel on the same system. Operating systems provide tools that allow us to manipulate the behavior of this process during execution.</p>
<p>Each process in a system is identified uniquely by what is called the process identifier. Parent-child relations between processes are created when a process calls a new one during its execution. The second process becomes a subprocess of the first one (this is its child process) and we will have information regarding this relationship with what is called the parent PID.</p>
<p>Processes run because a user or other process launched it. This allows the system to know who launched that action, and the owner of that process will be known by their user ID. Effective ownership of child processes is implicit when the main process uses impersonation to create them. New processes will use the main process designated user. </p>
<p>For interaction with the underlying system, each process runs with its own environment variables and we can also manipulate this environment with the built-in features of the operating system.</p>
<p>Processes can open, write, and close files as needed and use pointers to descriptors during execution for easy access to this filesystem's resources.</p>
<p>All processes running on a system are managed by operating system kernels and have also been scheduled on CPU by the kernel. The operating system kernel will be responsible for providing system resources to process and interact with system devices.</p>
<p>To summarize, we can say that the kernel is the part of the operating system that interfaces with host hardware, using different forms of isolation for operating system processes under the definition of <strong>kernel space</strong>. Other processes will run under the definition of <strong>user space</strong>. Kernel space has a higher priority for resources and manages user space.  </p>
<p>These definitions are common to all modern operating systems and will be crucial in understanding containers. Now that we know how processes are identified and that there is isolation between the system and its users, we can move on to the next section and understand how containers match microservices programming.</p>
<h1 id="uuid-4f45800f-ce51-4e10-a5b9-b5e117c7d5c9">Microservices and processes</h1>
<p>So far, we have briefly reviewed a number of different application models (monolith, SOAP, and the new microservices architecture) and we have defined microservices as the minimum piece of software with functionality that we can build as a component for an application.</p>
<p>With this definition, we will associate a microservice with a process. This is the most common way of running microservices. A process with full functionality can be described as a microservice.</p>
<p>An application is composed of microservices, and hence processes, as expected. The interaction between them will usually be made using HTTP/HTTPS/API REST.</p>
<p>This is, of course, a definition, but we recommend this approach to ensure proper microservice health management.</p>
<h1 id="uuid-e49870e5-815b-4bcc-83f9-e6c727c76b21">What are containers?</h1>
<p>So far, we have defined microservices and how processes fit in this model. As we saw previously, containers are related to process isolation. We will define a container as a process with all its requirements isolated with kernel features. This package-like object will contain all the code and its dependencies, libraries, binaries, and settings that are required to run our process. With this definition, it is easy to understand why containers are so popular in microservices environments, but, of course, we can execute microservices without containers. On the contrary, we can run containers with a full application, with many processes that don't need to be isolated from each other inside this package-like object.</p>
<p>In terms of multi-process containers, what is the difference between a virtual machine and containers? Let's review container features against virtual machines.</p>
<p>Containers are mainly based on cgroups and kernel namespaces.</p>
<p>Virtual machines, on the other hand, are based on hypervisor software. This software, which can run as part of the operating system in many cases, will provide sandboxed resources to the guest virtualized hardware that runs a virtual machine operating system. This means that each virtual machine will run its own operating system and allow us to execute different operating systems on the same hardware host. When virtual machines arrived, people started to use them as sandboxed environments for testing, but as hypervisors gained in maturity, data centers started to have virtual machines in production, and now this is common and standard practice in cloud providers (cloud providers currently offer hardware as a service, too). </p>
<p>In this schema, we're showing the different logic layers, beginning with the machine hardware. We will have many layers for executing a process inside virtual machines. Each virtual machine will have its own operating system and services, even if we are just running a single process:</p>
<div><img src="img/90237020-cbfc-4a3d-b539-b736f91d5177.png" style=""/></div>
<p>Each virtual machine will get a portion of resources and guest operating systems, and the kernel will manage how they are shared among different running processes. Each virtual machine will execute its own kernel and the operating system running on top of those of the host. There is complete isolation between the guest operating systems because hypervisor software will keep them separated. On the other hand, there is an overhead associated with running multiple operating systems side by side and when microservices come to mind, this solution wastes numerous host resources. Just running the operating system will consume a lot of resources. Even the fastest hardware nodes with fast SSD disks require resources and time to start and stop virtual machines. As we have seen, microservices are just a process with complete functionality inside an application, so running the entire operating system for just a couple of processes doesn't seem like a good idea.</p>
<p>On each guest host, we need to configure everything needed for our microservice. This means access, users, configurations, networking, and more. In fact, we need administrators for these systems as if they were bare-metal nodes. This requires a significant amount of effort and is the reason why configuration management tools are so popular these days. Ansible, Puppet, Chef, and SaltStack, among others, help us to homogenize our environments. However, remember that developers need their own environments, too, so multiply these resources by all the required environments in the development pipeline. </p>
<p>How can we scale up on service peaks? Well, we have virtual machine templates and, currently, almost all hypervisors allow us to interact with them using the command line or their own administrative API implementations, so it is easy to copy or clone a node for scaling application components. But this will require double the resources – remember that we will run another complete operating system with its own resources, filesystems, network, and so on. Virtual machines are not the perfect solution for elastic services (which can scale up and down, run everywhere, and are created on-demand in many cases).</p>
<p>Containers will share the same kernel because they are just isolated processes. We will just add a templated filesystem and resources (CPU, memory, disk I/O, network, and so on, and, in some cases, host devices) to a process. It will run sandboxed inside and will only use its defined environment. As a result, containers are lightweight and start and stop as fast as their main processes. In fact, containers are as lightweight as the processes they run, since we don't have anything else running inside a container. All the resources that are consumed by a container are process-related. This is great in terms of hardware resource allocation. We can find out the real consumption of our application by observing the load of all of its microservices.</p>
<p>Containers are a perfect solution for microservices as they will run only one process inside. This process should have all the required functionality for a specific task, as we described in terms of microservices.</p>
<p>Similar to virtual machines, there is the concept of a template for container creation called Image. Docker images are standard for many container runtimes. They ensure that all containers that are created from a container image will run with the same properties and features. In other words, this eliminates the <em>it works on my computer!</em> problem.</p>
<p>Docker containers improve security in our environments because they are secure by default. Kernel isolation and the kind of resources managed inside containers provide a secure environment during execution. There are many ways to improve this security further, as we will see in the following chapters. By default, containers will run with a limited set of system calls allowed.</p>
<p>This schema describes the main differences between running processes on different virtual machines and using containers:</p>
<div><img src="img/24bca328-db2b-4fa0-9d47-42caa9b18020.png" style=""/></div>
<p>Containers are faster to deploy and manage, lightweight, and secure by default. Because of their speed upon execution, containers are aligned with the concept of resilience. And because of the package-like environment, we can run containers everywhere. We only need a container runtime to execute deployments on any cloud provider, as we do on our data centers. The same concept will be applied to all development stages, so integration and performance tests can be run with confidence. If the previous tests were passed, since we are using the same artifact across all stages, we can ensure its execution in production.</p>
<p>In the following chapters, we will dive deep into Docker container components. For now, however, just think of a Docker container as a sandboxed process that runs in our system, isolated from all other running processes on the same host, based on a template named Docker Image.</p>
<h1 id="uuid-07088d03-9635-43e8-85ca-d9e63283d09c">Learning about the main concepts of containers <br/></h1>
<p>When talking about containers, we need to understand the main concepts behind the scenes. Let's decouple the container concept into different pieces and try to understand each one in turn.</p>
<h2 id="uuid-d5bb76c5-c1ea-4f15-a388-830b8afa3e22">Container runtime</h2>
<p>The runtime for running containers will be the software and operating system features that make process execution and isolation possible.</p>
<p>Docker, Inc. provides a container runtime named Docker, based on open source projects sponsored by them and other well-known enterprises that empower container movement (Red Hat/IBM and Google, among many others). This container runtime comes packaged with other components and tools. We will analyze each one in detail in the <em>Docker components</em> section.</p>
<h2 id="uuid-096406a2-41c8-407c-ba46-4459c400b7bb">Images</h2>
<p>We use images as templates for creating containers. Images will contain everything required by our process or processes to run correctly. These components can be binaries, libraries, configuration files, and so on that can be a part of operating system files or just components built by yourself for this application.</p>
<p>Images, like templates, are immutable. This means that they don't change between executions. Every time we use an image, we will get the same results. We will only change configuration and environment to manage the behavior of different processes between environments. Developers will create their application component template and they can be sure that if the application passed all the tests, it will work in production as expected. These features ensure faster workflows and less time to market. </p>
<p>Docker images are built up from a series of layers, and all these layers packaged together contain everything required for running our application process. All these layers are read-only and the changes are stored in the next upper layer during image creation. This way, each layer only has a set of differences from the layer before it.</p>
<p>Layers are packaged to allow ease of transport between different systems or environments, and they include meta-information about the required architecture to run (will it run on Linux or Windows, or does it require an ARM processor, for example?). Images include information about how the process should be run, which user will execute the main process, where persistent data will be stored, what ports your process will expose in order to communicate with other components or users, and more. </p>
<p>Images can be built with reproducible methods using Dockerfiles or store changes made on running containers to obtain a new image:</p>
<div><img src="img/ff4eb34d-600f-4247-b621-7c868bc877b1.png" style=""/></div>
<p>This was a quick review of images. Now, let's take a look at containers.</p>
<h2 id="uuid-1a5da664-fb76-4e56-bdb0-83255dde9e78">Containers</h2>
<p>As we described earlier, a container is a process with all its requirements that runs separately from all the other processes running on the same host. Now that we know what templates are, we can say that containers are created using images as templates. In fact, a container adds a new read-write layer on top of image layers in order to store filesystem differences from these layers. The following diagram represents the different layers involved in container execution. As we can observe, the top layer is what we really call the container because it is read-write and allows changes to be stored on the host disk:</p>
<div><img src="img/d56a8c6f-8016-41da-b0a7-7a1df1d9ecfa.png" style=""/></div>
<p>All image layers are read-only layers, which means all the changes are stored in the container's read-write layer. This means that all these changes will be lost when we remove a container from a host, but the image will remain until we remove it. Images are immutable and always remain unchanged.</p>
<p>This container behavior lets us run many containers using the same underlying image, and each one will store changes on its own read-write layer. The following diagram represents how different images will use the same image layers. All three containers are based on the same image:</p>
<div><img src="img/65827040-d4ff-4669-b122-aa61240f621a.png" style=""/></div>
<p>There are different approaches to managing image layers when building and container layers on execution. Docker uses storage drivers to manage this content, on read-only layers and read-write ones. These drivers are operating system-dependent, but they all implement what is known as copy-on-write filesystems.</p>
<p>A storage driver (known as <strong>graph-driver</strong>) will manage how Docker will store and manage the interactions between layers. As we mentioned previously, there are different drivers integrations available, and Docker will choose the best one for your system, depending on your host's kernel and operating system. <strong>Overlay2</strong> is the most common and preferred driver for Linux operating systems. Others, such as aufs, overlay, and btfs, among others, are also available, but keep in mind that overlay2 is recommended for production environments on modern operating systems.</p>
<p>Devicemapper is also a supported graph driver and it was very common on Red Hat environments before overlay2 was supported on modern operating system releases (Red Hat 7.6 and above). Devicemapper uses block devices for storing layers and can be deployed in observance of two different strategies: <kbd>loopback-lvm</kbd> (by default and only for testing purposes) and <kbd>direct-lvm</kbd> (requires additional block device pool configurations and is intended for production environments). This link provides the required steps for deploying: <kbd>direct-lvm</kbd>: <a href="https://docs.docker.com/storage/storagedriver/device-mapper-driver/">https://docs.docker.com/storage/storagedriver/device-mapper-driver/</a></p>
<p>As you may have noticed, using copy-on-write filesystems will make containers very small in terms of disk space usage. All common files are shared between the same image-based containers. They just store differences from immutable files that are part of image layers. Consequently, container layers will be very small (of course, this depends on what you are storing on containers, but keep in mind that good containers are small). When an existing file in a container has to be modified (remember a file that comes from underlying layers), the storage driver will perform a copy operation to the container layer. This process is fast, but keep in mind that everything that is going to be changed on containers will follow this process. As a reference, don't use copy-on-write with heavy I/O operations, nor process logs.</p>
<p>Copy-on-write is a strategy for creating maximum efficiency and small layer-based filesystems. This storage strategy works by copying files between layers. When a layer needs to change a file from another underlaying layer, it will be copied to this top one. If it just needs read access, it will use it from underlying layers. This way, I/O access is minimized and the size of the layers is very small.</p>
<p>A common question that many people ask is whether containers are ephemeral. The short answer is <em>no</em>. In fact, containers are not ephemeral for a host. This means that when we create or run a container on that host, it will remain there until someone removes it. We can start a stopped container on the same host if it is not deleted yet. Everything that was inside this container before will be there, but it is not a good place to store process state because it is only local to that host. If we want to be able to run containers everywhere and use orchestration tools to manage their states, processes must use external resources to store their status.</p>
<p>As we'll see in later chapters, Swarm or Kubernetes will manage service or application component status and, if a required container fails, it will create a new container. Orchestration will create a new container instead of reusing the old one because, in many cases, this new process will be executed elsewhere in the clustered pool of hosts. So, it is important to understand that your application components that will run as containers must be logically ephemeral and that their status should be managed outside containers (database, external filesystem, inform other services, and so on).</p>
<p>The same concept will be applied in terms of networking. Usually, you will let a container runtime or orchestrator manage container IP addresses for simplicity and dynamism. Unless strictly necessary, don't use fixed IP addresses, and let internal IPAMs configure them for you.</p>
<p>Networking in containers is based on host bridge interfaces and firewall-level NAT rules. A Docker container runtime will manage the creation of virtual interfaces for containers and process isolation between different logical networks creating mentioned rules. We will see all the network options provided and their use cases in <a href="e7804d8c-ed8c-4013-8449-b746ee654210.xhtml">Chapter 4</a>, <em>Container Persistency and Networking</em>. In addition, publishing an application is managed by the runtime and orchestration will add different properties and many other options.</p>
<p>Using volumes will let us manage the interaction between the process and the container filesystem. Volumes will bypass the copy-on-write filesystem and hence writing will be much faster. In addition to this, data stored in a volume will not follow the container life cycle. This means that even if we delete the container that was using that volume, all the data that was stored there will remain until someone deletes it. We can define a volume as the mechanism we will use to persist data between containers. We will learn that volumes are an easy way to share data between containers and deploy applications that need to persist their data during the life of the application (for example, databases or static content). Using volumes will not increase container layer size, but using them locally will require additional host disk resources under the Docker filesystem/directory tree.</p>
<h2 id="uuid-3c03bb64-8797-427d-91f8-52de45142da9">Process isolation</h2>
<p>As we mentioned previously, a kernel provides namespaces for process isolation. Let's review what each namespace provides. Each container runs with its own kernel namespaces for the following:</p>
<ul>
<li><strong>Processes</strong>: The main process will be the parent of all other ones within the container.</li>
<li><strong>Network</strong>: Each container will get its own network stack with its own interfaces and IP addresses and will use host interfaces.</li>
<li><strong>Users</strong>: We will be able to map container user IDs with different host user IDs.</li>
<li><strong>IPC</strong>: Each container will have its own shared memory, semaphores, and message queues without conflicting other processes on the host. </li>
<li><strong>Mounts</strong>: Each container will have its own root filesystem and we can provide external mounts, which we will learn about in upcoming chapters. </li>
<li style="font-weight: 400"><strong>UTS</strong>: Each container will get its own hostname and time will be synced with the host. </li>
</ul>
<p>The following diagram represents a process tree from the host perspective and inside a container. Processes inside a container are namespaced and, as a result, their parent PID will be the main process, with its own PID of 1:</p>
<div><img src="img/e1385aa3-f6dd-4342-b1f1-2ffececa05e0.jpg" style=""/></div>
<p>Namespaces have been available in Linux since version 2.6.26 (July 2008), and they provide the first level of isolation for a process running within a container so that it won't see others. This means they cannot affect other processes running on the host or in any other container. The maturity level of these kernel features allows us to trust in Docker namespace isolation implementation.</p>
<p>Networking is isolated too, as each container gets its own network stack, but communications will pass through host bridge interfaces. Every time we create a Docker network for containers, we will create a new network bridge, which we will learn more about in <a href="e7804d8c-ed8c-4013-8449-b746ee654210.xhtml">Chapter 4</a>, <em>Container Persistency and Networking</em>. This means that containers sharing a network, which is a host bridge interface, will see one another, but all other containers running on a different interface will not have access to them. Orchestration will add different approaches to container runtime networking but, at the host level, described rules are applied.</p>
<p>Host resources available to a container are managed by control groups. This isolation will not allow a container to bring down a host by exhausting its resources. You should not allow containers with non-limited resources in production. This must be mandatory in multi-tenant environments.</p>
<h2 id="uuid-315e11cf-4201-4d66-96a9-7f2faf9859d0">Orchestration</h2>
<p>This book contains a general chapter about orchestration, <a href="3b13261c-9b4d-46e2-b115-fc323563f646.xhtml">Chapter 7</a>, <em>Introduction to Orchestration</em>, and two specific chapters devoted to Swarm and Kubernetes, respectively, <a href="78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml">Chapter 8</a>, <em>Orchestration Using Docker Swarm</em>, and <a href="abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml">Chapter 9</a>, <em>Orchestration Using Kubernetes</em>. Orchestration is the mechanism that will manage container interactions, publishing, and health in clustered pools of hosts. It will allow us to deploy an application based on many components or containers and keep it healthy during its entire life cycle. With orchestration, component updates are easy because it will take care of the required changes in the platform to accomplish a new, appropriate state.</p>
<p>Deploying an application using orchestration will require a number of instances for our process or processes, the expected state, and instructions for managing its life during execution. Orchestration will provide new objects, communication between containers running on different hosts, features for running containers on specific nodes within the cluster, and the mechanisms to keep the required number of process replicas alive with the desired release version.</p>
<p>Swarm is included inside Docker binaries and comes as standard. It is easy to deploy and manage. Its unit of deployment is known as a <strong>service</strong>. In a Swarm environment, we don't deploy containers because containers are not managed by orchestration. Instead, we deploy services and those services will be represented by tasks, which will run containers to maintain its state.</p>
<p>Currently, Kubernetes is the most widely used form of orchestration. It requires extra deployment effort using a Docker community container runtime. It adds many features, multi-container objects known as <strong>pods</strong> that share a networking layer, and flat networking for all orchestrated pods, among other things. Kubernetes is community-driven and evolves very fast. One of the features that makes this platform so popular is the availability to create your own kind of resources, allowing us to develop new extensions when they are not available.</p>
<p>We will analyze the features of pods and Kubernetes in detail in <a href="abcbf266-c469-4d84-ad4f-abd321a64b53.xhtml">Chapter 9</a>, <em>Orchestration Using Kubernetes</em>.</p>
<p>Docker Enterprise provides orchestrators deployed under Universal Control Plane with high availability on all components.</p>
<h2 id="uuid-60ecbd33-1831-4c6b-bcf6-caab6f689daf">Registry</h2>
<p>We have already learned that containers execute processes within an isolated environment, created from a template image. So, the only requirements for deploying that container on a new node will be the container runtime and the template used to create that container. This template can be shared between nodes using simple Docker command options. But this procedure can become more difficult as the number of nodes grows. To improve image distribution, we will use image registries, which are storage points for these kinds of objects. Each image will be stored in its own repository. This concept is similar to code repositories, allowing us to use tags to describe these images, aligning code releases with image versioning.</p>
<p>An application deployment pipeline has different environments, and having a common point of truth between them will help us to manage these objects through the different workflow stages.</p>
<p>Docker provides two different approaches for registry: the community version and Docker Trusted Registry. The community version does not provide any security at all, nor role-based access to image repositories. On the other hand, Docker Trusted Registry comes with the Docker Enterprise solution and is an enterprise-grade registry, with included security, image vulnerability scanning, integrated workflows, and role-based access. We will learn about Docker Enterprise's registry in <a href="108b5948-15a9-40fb-b8dd-5a44c54efd7d.xhtml">Chapter 13</a>, <em>Implementing an Enterprise-Grade Registry with DTR</em>.</p>
<h1 id="uuid-90110af4-ae78-473c-957e-3464c0685578">Docker components</h1>
<p>In this section, we are going to describe the main Docker components and binaries used for building, distributing, and deploying containers in all execution stages. </p>
<p>Docker Engine is the core component of container platforms. Docker is a client-server application and Docker Engine will provide the server side. This means that we have the main process that runs as a daemon on the host, and a client-side application that communicates with the server using REST API calls.</p>
<p>Docker Engine's latest version provides separate packages for the client and the server. On Ubuntu, for example, if we take a look at the available packages, we will have something like this:<br/>
 <kbd>- docker-ce-cli</kbd> – Docker CLI: The open source application container engine<br/>
 <kbd>- docker-ce</kbd> – Docker: The open source application container engine<br/>
<br/></p>
<p>The following diagram represents Docker daemon and its different levels of management:</p>
<div><img src="img/869e5251-5150-40b1-95ba-cc5be82a7c16.jpg" style=""/></div>
<p>Docker daemon listens for Docker API requests and will be responsible for all Docker object actions, such as creating an image, list volumes, and running a container.</p>
<p>Docker API is available using a Unix socket by default. Docker API can be used from within code-using interfaces that are available for many programming languages. Querying for running containers can be managed using a Docker client or its API directly; for example, with<em><strong> </strong></em><kbd>curl --no-buffer -XGET --unix-socket /var/run/docker.sock http://localhost/v1.24/containers/json</kbd>.<br/></p>
<p>When deploying cluster-wide environments with Swarm orchestration, daemons will share information between them to allow the execution of distributed services within the pool of nodes.</p>
<p>On the other hand, the Docker client will provide users with the command line required to interact with the daemon. It will construct the required API calls with their payloads to tell the daemon which actions it should execute.</p>
<p>Now, let's deep dive into a Docker daemon component to find out more about its behavior and usage.</p>
<h2 id="uuid-c80c13a5-530d-4a89-8788-a29d17ba7633" class="mce-root">Docker daemon</h2>
<p>Docker daemon will usually run as a systemd-managed service, although it can run as a standalone process (it is very useful when debugging daemon errors, for example). As we have seen previously, <kbd>dockerd</kbd> provides an API interface that allows clients to send commands and interact with this daemon. <kbd>containerd</kbd>, in fact, manages containers. It was introduced as a separate daemon in Docker 1.11 and is responsible for managing storage, networking, and interaction between namespaces. Also, it will manage image shipping and then, finally, it will run containers using another external component. This external component, <kbd>RunC</kbd>, will be the real executor of containers. Its function just receives an order to run a container. These components are part of the community, so the only one that Docker provides is <kbd>dockerd</kbd>. All other daemon components are community-driven and use standard image specifications (<strong>Open Containers Initiative</strong> – <strong>OCI</strong>). In 2017, Docker donated <kbd>containerd</kbd> as part of their contribution to the open source community and is now part of the <strong>Cloud Native Computing Foundation</strong> (<strong>CNCF</strong>). OCI was founded as an open governance structure for the express purpose of creating open industry standards around container formats and runtimes in 2015. The CNCF hosts and manages most of the currently most-used components of the newest technology infrastructures. It is a part of the nonprofit Linux Foundation and is involved in projects such as Kubernetes, Containerd, and The Update Framework.</p>
<p>By way of a summary, <kbd>dockerd</kbd> will manage interaction with the Docker client. To run a container, first, the configuration needs to be created so that daemon triggers <kbd>containerd</kbd> (using gRPC) to create it. This piece will create an OCI definition that will use <kbd>RunC</kbd> to run this new container. Docker implements these components with different names (changed between releases), but the concept is still valid.</p>
<p>Docker daemon can listen for Docker Engine API requests on different types of sockets: <kbd>unix</kbd>, <kbd>tcp</kbd>, and <kbd>fd</kbd>. By default, Daemon on Linux will use a Unix domain socket (or IPC socket) that's created at <kbd>/var/run/docker.sock</kbd> when starting the daemon. Only root and Docker groups can access this socket, so only root and members of the Docker group will be able to create containers, build images, and so on. In fact, access to a socket is required for any Docker action.</p>
<h2 id="uuid-96285586-6bdd-44c1-be23-ed79e48d9ba3" class="mce-root">Docker client</h2>
<p>Docker client is used to interact with a server. It needs to be connected to a Docker daemon to perform any action, such as building an image or running a container. </p>
<p>A Docker daemon and client can run on the same host system, or we can manage a connected remote daemon. The Docker client and daemon communicate using a server-side REST API. This communication can be executed over UNIX sockets (by default) or a network interface, as we learned earlier.</p>
<h2 id="uuid-b1c95c43-9cd2-4081-a671-d74158edc884" class="mce-root">Docker objects</h2>
<p>The Docker daemon will manage all kinds of Docker objects using the Docker client command line.</p>
<p>The following are the most common objects at the time of writing this book:</p>
<ul>
<li><kbd>IMAGE</kbd></li>
<li><kbd>CONTAINER</kbd></li>
<li><kbd>VOLUME</kbd></li>
<li><kbd>NETWORK</kbd></li>
<li><kbd>PLUGIN</kbd></li>
</ul>
<p>There are other objects that are only available when we deploy Docker Swarm orchestration:</p>
<ul>
<li style="font-weight: 400"><kbd>NODE</kbd></li>
<li style="font-weight: 400"><kbd>SERVICE</kbd></li>
<li style="font-weight: 400"><kbd>SECRET</kbd></li>
</ul>
<ul>
<li style="font-weight: 400"><kbd>CONFIG</kbd></li>
<li style="font-weight: 400"><kbd>STACK</kbd></li>
<li style="font-weight: 400"><kbd>SWARM</kbd></li>
</ul>
<p>The Docker command line provides the actions that Docker daemon is allowed to execute via REST API calls. There are common actions such as list (or <kbd>ls</kbd>), <kbd>create</kbd>, <kbd>rm</kbd> (for remove), and <kbd>inspect</kbd>, and other actions that are restricted to specific objects, such as <kbd>cp</kbd> (for coping).</p>
<p>For example, we can get a list of running containers on a host by running the following command:</p>
<pre><strong>$ docker container ls</strong></pre>
<p>There are many commonly used aliases, such as <kbd>docker ps</kbd> for <kbd>docker container ls</kbd> or <kbd>docker run</kbd> for <kbd>docker container run</kbd>. I recommend using a long command-line format because it is easier to remember if we understand which actions are allowed for each object. </p>
<p>There are other tools available on the Docker ecosystem, such as <kbd>docker-machine</kbd> and <kbd>docker-compose</kbd>.</p>
<p>Docker Machine is a community tool created by Docker that allows users and administrators to easily deploy Docker Engine on hosts. It was developed in order to fast provision Docker Engine on cloud providers such as Azure and AWS, but it evolved to offer other implementations, and nowadays, it is possible to use many different drivers for many different environments. We can use <kbd>docker-machine</kbd> to deploy <kbd>docker-engine</kbd> on VMWare (over Cloud Air, Fusion, Workstation, or vSphere), Microsoft Hyper-V, and OpenStack, among others. It is also very useful for quick labs, or demonstration and test environments on VirtualBox or KVM, and it even allows us to provision <kbd>docker-engine</kbd> software using SSH. <kbd>docker-machine</kbd> runs on Windows and Linux, and provides an integration between client and provisioned Docker host daemons. This way, we can interact with its Docker daemon remotely, without being connected using SSH, for example.</p>
<p>On the other hand, Docker Compose is a tool that will allow us to run multi-container applications on a single host. We will just introduce this concept here in relation to multi-service applications that will run on Swarm or Kubernetes clusters. We will learn about <kbd>docker-compose</kbd> in <a href="1c86479c-e4f5-4508-9eca-d29bb3dbaf4b.xhtml">Chapter 5</a>, <em>Deploying Multi-Container Applications</em>.</p>
<h1 id="uuid-934671aa-62a3-4074-aeae-661e833667be">Building, shipping, and running workflows</h1>
<p>Docker provides the tools for creating images (templates for containers, remember), distributing those images to systems other than the one used for building the image, and finally, running containers based on these images:</p>
<div><img src="img/e5b4a773-3969-4635-8355-3ef34ed67026.jpg" style=""/></div>
<p>Docker Engine will participate in all workflow steps, and we can use just one host or many during these processes, including our developers' laptops.</p>
<p>Let's provide a quick review of the usual workflow processes.</p>
<h2 id="uuid-86e7df31-cda4-4dee-a69e-fe8afc846692">Building</h2>
<p>Building applications using containers is easy. Here are the standard steps:</p>
<ol>
<li style="font-weight: 400">The developer usually codes an application on their own computer.</li>
<li style="font-weight: 400">When the code is ready, or there is a new release, new functionalities, or a bug has simply been fixed, a commit is deployed.</li>
<li style="font-weight: 400">If our code has to be compiled, we can do it at this stage. If we are using an interpreted language for our code, we will just add it to the next stage.</li>
<li style="font-weight: 400">Either manually or using continuous integration orchestration, we can create a Docker image integrating compiled binary or interpreted code with the required runtime and all its dependencies. Images are our new component artifacts. </li>
</ol>
<p>We have passed the building stage and the built image, with everything included, must be deployed to production. But first, we need to ensure its functionality and health (Will it work? How about performance?). We can do all these tests on different environments using the image artifact we created.</p>
<h2 id="uuid-308d7705-324f-41d7-b0ca-7e7b1c9d659e">Shipping</h2>
<p>Sharing created artifacts is easier with containers. Here are some of the new steps:</p>
<ol>
<li style="font-weight: 400">The created image is on our build host system (or even on our laptop). We will push this artifact to an image registry to ensure that it is available for the next workflow processes.</li>
<li style="font-weight: 400">Docker Enterprise provides integrations on Docker Trusted Registry to follow separate steps from the first push, image scanning to look for vulnerabilities, and different image pulls from different environments during continuous integration stages.</li>
<li style="font-weight: 400">All pushes and pulls are managed by Docker Engine and triggered by Docker clients.</li>
</ol>
<p>Now that the image has been shipped on different environments, during integration and performance tests, we need to launch containers using environment variables or configurations for each stage.</p>
<h2 id="uuid-e5a43d28-bda1-4ab3-b240-a9a1534d3d78">Running</h2>
<p>So, we have new artifacts that are easy to share between different environments, but we need to execute them in production. Here are some of the benefits of containers for our applications:</p>
<ul>
<li style="font-weight: 400">All environments will use Docker Engine to execute our containers (processes), but that's all. We don't really need any portion of software other than Docker Engine to execute the image correctly (naturally, we have simplified this idea because we will need volumes and external resources in many cases).</li>
<li style="font-weight: 400">If our image passed all the tests defined in the workflow, it is ready for production, and this step will be as simple as deploying the image built originally on the previous environment, using all the required arguments and environment variables or configurations for production.</li>
<li style="font-weight: 400">If our environments were orchestration-managed using Swarm or Kubernetes, all these steps would have been run securely, with resilience, using internal load balancers, and with required replicas, among other properties, that this kind of platform provides. </li>
</ul>
<p>As a summary, keep in mind that Docker Engine provides all the actions required for building, shipping, and running container-based applications.</p>
<h1 id="uuid-17b1ca8c-51f2-4306-9da2-ba2fdecd9633">Windows containers</h1>
<p class="mce-root">Containers started with Linux, but nowadays, we can run and orchestrate containers on Windows. Microsoft integrated containers on Windows in Windows 2016. With this release, they consolidated a partnership with Docker to create a container engine that runs containers natively on Windows.</p>
<p>After a few releases, Microsoft decided to have two different approaches to containers on Windows, these being the following:</p>
<ul>
<li><strong>Windows Server Containers</strong> (<strong>WSC</strong>), or process containers</li>
<li>Hyper-V Containers</li>
</ul>
<p>Because of the nature of Windows operating system implementation, we can share kernels but we can't isolate processes from the system services and DLLs. In this situation, process containers need a copy of the required system services and many DLLs to be able to make API calls to the underlying host operating system. This means that containers that use process container isolation will run with many system processes and DLLs inside. In this case, images are very big and will have a different kind of portability; we will only be able to run Windows containers based on the same underlying operating system version.</p>
<p>As we have seen, process containers need to copy a portion of the underlying operating system inside in order to run. This means that we can only run the same operating system containers. For example, running containers on top of Windows Server 2016 will require a Windows Server 2016 base image.</p>
<p>On the other hand, Hyper-V containers will not have these limitations because they will run on top of a virtualized kernel. This adds overhead, but the isolation is substantially better. In this case, we won't be able to run these kinds of containers on older Microsoft Windows versions. These containers will use optimized virtualization to isolate the new kernel for our process.</p>
<p>The following diagram represents both types of MS Windows container isolation:</p>
<div><img src="img/bfa4c480-9fa6-480a-ad8e-c9c2bfb55e00.jpg" style=""/></div>
<p>Process isolation is a default container isolation on Windows Server, but Windows 10 Pro and Enterprise will run Hyper-V isolation. Since the Windows 10 October 2018 update, we can choose to use old-style process isolation with the <kbd>--isolation=process</kbd> flag on Windows 10 Pro and Enterprise.<br/>
Please check the Windows operating system's portability because this is a very common problem on Windows containers.</p>
<p>Networking in Windows containers is different from Linux. The Docker host uses a Hyper-V virtual switch to provide connectivity to containers and connects them to virtual switches using either a host virtual interface (Windows Server containers) or a synthetic VM interface (Hyper-V containers). </p>
<h1 id="uuid-1d4d742b-73c9-4752-81be-f5241c6b1c51">Customizing Docker </h1>
<p>Docker behavior can be managed at daemon and client levels. These configurations can be executed using command-line arguments, environment variables, or definitions on configuration files. </p>
<h2 id="uuid-60e83d80-f01a-479e-b757-2a3cba7366ad">Customizing the Docker daemon </h2>
<p>Docker daemon behavior is managed by various configuration files and variables:</p>
<ul>
<li style="font-weight: 400"><strong>key.json</strong>: This file contains a unique identifier for this daemon; in fact, it is the daemon's public key that uses the JSON web key format.</li>
<li style="font-weight: 400"><strong>daemon.json</strong>: This is the Docker daemon configuration file. It contains all its parameters in JSON format. It has a key-value (or list of values) format in which all the daemon's flags will be available to modify its behavior. Be careful with configurations implemented on the <kbd>systemd</kbd> service file because they must not conflict with options set via the JSON file; otherwise, the daemon will fail to start.</li>
<li style="font-weight: 400"><strong>Environment variables</strong>: <kbd>HTTPS_PROXY</kbd>, <kbd>HTTP_PROXY</kbd>, and <kbd>NO_PROXY</kbd> (or using lowercase) will manage the utilization of Docker daemon and the client behind the proxies. The configuration can be implemented in the Docker daemon <kbd>systemd</kbd> unit config files using, for example, <kbd>/etc/systemd/system/docker.service.d/http-proxy.conf</kbd>, and following the content for <kbd>HTTPS_PROXY</kbd> (the same configuration might be applied to <kbd>HTTP_PROXY</kbd>):</li>
</ul>
<pre style="padding-left: 60px">[Service]<br/>Environment="HTTPS_PROXY=https://proxy.example.com:443/" "NO_PROXY=localhost,127.0.0.1,docker-registry.example.com,.corp"</pre>
<div><p>Be careful with the <kbd>key.json</kbd> file while cloning virtual machines because using the same keys on different daemons will result in strange behaviors. This file is owned by system administrators, so you will need to use a privileged user to review its content. This JSON file contains Docker Daemon's certificate in JSON Web Key format. We can just review the <kbd>key.json</kbd> file's content using the <kbd>cat</kbd> and <kbd>jq</kbd> commands <kbd>(jq</kbd> is not required, but I used it to format output. This command will help with JSON files or JSON output):</p>
<kbd><strong>$ sudo cat /etc/docker/key.json |jq</strong></kbd><br/>
<kbd>{</kbd><br/>
<kbd>  "crv": "P-256",</kbd><br/>
<kbd>  "d": "f_RvzIUEPu3oo7GLohd9cxqDlT9gQyXSfeWoOnM0ZLU",</kbd><br/>
<kbd>  "kid": "QP6X:5YVF:FZAC:ETDZ:HOHI:KJV2:JIZW:<br/>
            IG47:3GU6:YQJ4:YRGF:VKMP",</kbd><br/>
<kbd>  "kty": "EC",</kbd><br/>
<kbd>  "x": "y4HbXr4BKRi5zECbJdGYvFE2KtMp9DZfPL81r_qe52I",</kbd><br/>
<kbd>  "y": "ami9cOOKSA8joCMwW-y96G2mBGwcXthYz3FuK-mZe14"</kbd><br/>
<kbd>}</kbd></div>
<p>The daemon configuration file, <kbd>daemon.json</kbd>, will be located by default at the following locations:</p>
<ul>
<li style="font-weight: 400"><kbd>/etc/docker/daemon.json</kbd> on Linux systems</li>
<li style="font-weight: 400"><kbd>%programdata%\docker\config\daemon.json</kbd> on Windows systems</li>
</ul>
<p>In both cases, the configuration file's location can be changed using <kbd>--config-file</kbd> to specify a custom non-default file.</p>
<p>Let's provide a quick review of the most common and important flags or keys we will configure for Docker daemon. Some of these options are so important that they are usually referenced in the Docker Certified Associate exam. Don't worry; we will learn about the most important ones, along with their corresponding JSON keys, here:</p>
<table style="border-collapse: collapse;width: 100%" border="1">
<tbody>
<tr>
<td class="CDPAlignCenter CDPAlign"><strong>Daemon argument</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>JSON key</strong></td>
<td class="CDPAlignCenter CDPAlign"><strong>Argument description</strong></td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>-b</kbd>, <kbd>--bridge</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>bridge</kbd></td>
<td>Attach containers to a network bridge. This option allows us to change the default bridge behavior. In some cases, it's useful to create your own bridge interfaces and use the Docker daemon attached to one of them.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--cgroup-parent</kbd> string </td>
<td class="CDPAlignCenter CDPAlign"><kbd>cgroup-parent</kbd> </td>
<td>Set the parent cgroup for all containers.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>-D</kbd>, <kbd>--debug</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>debug</kbd></td>
<td>This option enables debug mode, which is fundamental to resolving issues. Usually, it's better to stop Docker service and run the Docker daemon by hand using the <kbd>-D</kbd> option to review all <kbd>dockerd</kbd> debugging events. </td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--data-root</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>data-root</kbd></td>
<td>This is the root directory of the persistent Docker state (default <kbd>/var/lib/docker</kbd>). With this option, we can change the path to store all Docker data (Swarm KeyValue, images, internal volumes, and so on).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--dns</kbd> list </td>
<td class="CDPAlignCenter CDPAlign"><kbd>dns</kbd></td>
<td>This is the DNS server to use (default <kbd>[]</kbd>). These three options allow us to change the container DNS behavior, for example, to use a specific DNS for the container environment.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"> <kbd>--dns-opt</kbd> list </td>
<td class="CDPAlignCenter CDPAlign"><kbd>dns-opt</kbd></td>
<td>These are the DNS options to use (default <kbd>[]</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--dns-search</kbd> list</td>
<td class="CDPAlignCenter CDPAlign"><kbd>dns-search</kbd></td>
<td>These are the DNS search domains to use (default <kbd>[]</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--experimental</kbd> </td>
<td class="CDPAlignCenter CDPAlign"><kbd>experimental</kbd></td>
<td>This enables experimental features; don't use it in production.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>-G</kbd>, <kbd>--group</kbd> string </td>
<td class="CDPAlignCenter CDPAlign"><kbd>group</kbd></td>
<td>This is the group for the Unix socket (default <kbd>docker</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>-H</kbd>, <kbd>--host</kbd> list</td>
<td class="CDPAlignCenter CDPAlign"><kbd>host</kbd></td>
<td>This is the option that allows us to specify the socket(s) to use.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--icc</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>icc</kbd></td>
<td>This enables inter-container communication (default <kbd>true</kbd>). With this option, we can disable any container's internal communications.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"> <kbd>--ip</kbd> IP</td>
<td class="CDPAlignCenter CDPAlign"><kbd>ip</kbd></td>
<td>This is the default IP when binding container ports (default <kbd>0.0.0.0</kbd>). With this option, we can ensure that only specific subnets will have access to container-exposed ports.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"> <kbd>--label</kbd> list</td>
<td class="CDPAlignCenter CDPAlign"><kbd>label</kbd></td>
<td>Set key=value labels to the daemon (default <kbd>[]</kbd>). With labels, we can configure environment properties for container location when using a cluster of hosts. There is a better tagging method you can use when using Swarm, as we will learn in <a href="78af3b70-773d-4f5d-9835-71d1c15a104a.xhtml">Chapter 8</a>, <em>Orchestration Using Docker Swarm</em>. </td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--live-restore</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>live-restore</kbd></td>
<td>This enables the live restoration of Docker when containers are still running.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--log-driver</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>log-driver</kbd></td>
<td>This is the default driver for container logs (default <kbd>json-file</kbd>) if we need to use an external log manager (ELK framework or just a Syslog Server, for example).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>-l</kbd>, <kbd>--log-level</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>log-level</kbd></td>
<td>This sets the logging level (<kbd>debug</kbd>, <kbd>info</kbd>, <kbd>warn</kbd>, <kbd>error</kbd>, <kbd>fatal</kbd>) (default <kbd>info</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--seccomp-profile</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>seccomp-profile</kbd></td>
<td>This is the path to the seccomp profile if we want to use anything other than the default option.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--selinux-enabled</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>selinux-enabled</kbd></td>
<td>Enables SELinux support. This option is crucial for production environments using Red Hat Linux/CentOS. It is disabled by default.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>-s</kbd>, <kbd>--storage-driver</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>storage-driver</kbd></td>
<td>This is the storage driver to use. This argument allows us to change the default driver selected by Docker. In the latest versions, we will use <kbd>overlay2</kbd> because of its stability and performance. Other options include <kbd>aufs</kbd>, <kbd>btrfs</kbd>, and <kbd>devicemapper</kbd>.</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--storage-opt</kbd> list</td>
<td class="CDPAlignCenter CDPAlign"><kbd>storage-opts</kbd></td>
<td>Storage driver options (default <kbd>[]</kbd>). Depending on the storage driver used, we will need to add options as arguments, for example, using <kbd>devicemapper</kbd> or for specifying a maximum container size on <kbd>overlay2</kbd> or Windows filter (MS Windows copy-on-write implementation).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--tls</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>tls</kbd></td>
<td>This option enables TLS encryption between client and server (implied by <kbd>--tlsverify</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"> <kbd>--tlscacert</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>tlscacert</kbd></td>
<td>Trust certs signed only by this CA (default <kbd>~/.docker/ca.pem</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--tlscert</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>tlscert</kbd></td>
<td>This is the path to the TLS certificate file (default <kbd>~/.docker/cert.pem</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--tlskey</kbd> string</td>
<td class="CDPAlignCenter CDPAlign"><kbd>tlskey</kbd></td>
<td>This is the path to the TLS key file (default <kbd>~/.docker/key.pem</kbd>).</td>
</tr>
<tr>
<td class="CDPAlignCenter CDPAlign"><kbd>--tlsverify</kbd></td>
<td class="CDPAlignCenter CDPAlign"><kbd>tlsverify</kbd></td>
<td>Use TLS and verify the remote.</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Logging information in container environments can be deployed using different layers of knowledge. As shown in the previous table, Docker daemon has its own logging configuration using <kbd>--log-driver</kbd>. This configuration will be applied to all containers by default if we do not specify any configuration during container execution. Therefore, we can redirect all container logs to some remote logging system using the ELK framework, for example (<a href="https://www.elastic.co/es/what-is/elk-stack">https://www.elastic.co/es/what-is/elk-stack</a>), while some specific containers can be redirected to another logging backend. This can also be applied locally using different logging drivers.</p>
<h2 id="uuid-26983f5e-6019-4e18-8498-4f21f4737487">Docker client customization</h2>
<p>The client will store its configuration under the users' home directory on <kbd>.docker</kbd>. There is a config file where the Docker client will look for its configurations (<kbd>$HOME/.docker/config.json</kbd> on Linux or <kbd>%USERPROFILE%/.docker/config.json</kbd> on Windows). In this file, we will set a proxy for our containers if it's needed to connect to the internet or other external services, for example.</p>
<p class="mce-root">If we need to pass proxy settings to containers upon startup, we will configure the <kbd>proxies</kbd> key in <kbd>.docker/config.json</kbd> for our user, for example, using <kbd>my-company-proxy</kbd>:</p>
<pre style="padding-left: 60px">"proxies":<br/>{<br/>    "default":<br/>    {<br/>        "httpProxy": "http://my-company-proxy:3001",<br/>        "httpsProxy": "http://my-company-proxy:3001",<br/>        "noProxy": "*.test.example.com,.example2.com"<br/>    }<br/>}</pre>
<p>These configurations can be added as arguments when starting up the Docker container, as follows:</p>
<pre><strong>--env HTTP_PROXY="http://my-company-proxy:3001"</strong><br/><strong>--env HTTPS_PROXY="https://my-company-proxy:3001"</strong><br/><strong>--env NO_PROXY="*.test.example.com,.example2.com"</strong></pre>
<p>We will see what "environment option" means in <a href="c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml">Chapter 3</a>, <em>Running Docker Containers</em>. Just keep in mind that, sometimes, our corporate environment will need applications to use proxies and that there are methods to configure these settings, either as user variables or using client configurations. </p>
<p>Other client features, such as experimental flags or output formatting, will be configured in the <kbd>config.json</kbd> file. Here is an example of some configurations:</p>
<pre>{<br/> "psFormat": "table {{.ID}}\\t{{.Image}}\\t{{.Command}}\\t{{.Labels}}",<br/>  "imagesFormat": "table {{.ID}}\\t{{.Repository}}\\t{{.Tag}}\\t{{.CreatedAt}}",<br/>  "statsFormat": "table {{.Container}}\t{{.CPUPerc}}\t{{.MemUsage}}"<br/>}</pre>
<h1 id="uuid-9e6f9182-8c0c-48c1-8507-19c0a7410487">Docker security</h1>
<p>There are many topics related to container security. In this chapter, we will review the ones related to the container runtime.</p>
<p>As we have seen, Docker provides a client-server environment. From the client side, there are a few things that will improve the way in which we will be able to access the environment.</p>
<p>Configuration files and certificates for different clusters on hosts must be secured using filesystem security at the operating system level. However, as you should have noticed, a Docker client always needs a server in order to do anything with containers. Docker client is just the tool to connect to servers. With this picture in mind, client-server security is a must. Now, let's take a look at different kinds of access to the Docker daemon.</p>
<h2 id="uuid-edb107ed-a799-4690-8135-52cad1a8b28f">Docker client-server security</h2>
<p>The Docker daemon will listen on system sockets (<kbd>unix</kbd>, <kbd>tcp</kbd>, and <kbd>fd</kbd>). We have seen that we can change this behavior and that, by default, the daemon will listen on the <kbd>/var/run/docker.sock</kbd> local Unix socket.</p>
<p>Giving users RW access to <kbd>/var/run/docker.sock</kbd> will add access to the local Docker daemon. This allows them to create images, run containers (even privileged, root user containers, and mount local filesystems inside them), create images, and more. It is very important to know who can use your Docker engine. If you deployed a Docker Swarm cluster, this is even worse because if the accessed host has a master role, the user will be able to create a service that will run containers across the entirety of the cluster. So keep your Docker daemon socket safe from non-trusted users and only allow authorized ones (in fact, we will look at other advanced mechanisms to provide secure user access to the container platform).</p>
<p>Docker daemon is secure by default because it does not export its service. We can enable remote TCP accesses by adding <kbd>-H tcp://&lt;HOST_IP&gt;</kbd> to the Docker daemon start process. By default, port <kbd>2375</kbd> will be used. If we use 0.0.0.0 as the host IP address, Docker daemon will listen on all interfaces.</p>
<p>We can enable remote access to Docker daemon using a TCP socket. By default, communication will not be secure and the daemon will listen on port <kbd>2375</kbd>. To ensure that the client-to-daemon connection is encrypted, you will need to use either a reverse proxy or built-in TLS-based HTTPS encrypted socket. We can allow the daemon to listen on all host interface IP addresses or just one using this IP when starting the daemon. To use TLS-based communications, we need to follow this procedure (assuming your server hostname is in the <kbd>$HOST</kbd> variable):</p>
<ol>
<li>Create a <strong>certificate authority</strong> (<strong>CA</strong>). The following commands will create its private and public keys:<a href="mailto:Sven@home.org.au"/></li>
</ol>
<pre style="padding-left: 60px"><strong>$ openssl genrsa -aes256 -out ca-key.pem 4096</strong><br/><strong> Generating RSA private key, 4096 bit long modulus</strong><br/><strong> ............................................................................................................................................................................................++</strong><br/><strong> ........++</strong><br/><strong> e is 65537 (0x10001)</strong><br/><strong> Enter pass phrase for ca-key.pem:</strong><br/><strong> Verifying - Enter pass phrase for ca-key.pem:</strong><br/><strong> $ openssl req -new -x509 -days 365 -key ca-key.pem -sha256 -out ca.pem</strong><br/><strong> Enter pass phrase for ca-key.pem:</strong><br/><strong> You are about to be asked to enter information that will be incorporated</strong><br/><strong> into your certificate request.</strong><br/><strong> What you are about to enter is what is called a Distinguished Name or a DN.</strong><br/><strong> There are quite a few fields but you can leave some blank</strong><br/><strong> For some fields there will be a default value,</strong><br/><strong> If you enter '.', the field will be left blank.</strong><br/><strong> -----</strong><br/><strong> Country Name (2 letter code) [AU]:</strong><br/><strong> State or Province Name (full name) [Some-State]:Queensland</strong><br/><strong> Locality Name (eg, city) []:Brisbane</strong><br/><strong> Organization Name (eg, company) [Internet Widgits Pty Ltd]:Docker Inc</strong><br/><strong> Organizational Unit Name (eg, section) []:Sales</strong><br/><strong> Common Name (e.g. server FQDN or YOUR name) []:$HOST</strong><br/><strong> Email Address []:Sven@home.org.au</strong></pre>
<ol start="2">
<li>Create a server CA-signed key, ensuring that the common name matches the hostname you use to connect to Docker daemon from the client:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>$ openssl genrsa -out server-key.pem 4096</strong><br/><strong> Generating RSA private key, 4096 bit long modulus</strong><br/><strong> .....................................................................++</strong><br/><strong> .................................................................................................++</strong><br/><strong> e is 65537 (0x10001)</strong><br/><br/><strong>$ openssl req -subj "/CN=$HOST" -sha256 -new -key server-key.pem -out server.csr</strong><br/><strong> $ echo subjectAltName = DNS:$HOST,IP:10.10.10.20,IP:127.0.0.1 &gt;&gt; extfile.cnf</strong><br/><strong> $ echo extendedKeyUsage = serverAuth &gt;&gt; extfile.cnf</strong><br/><strong> $ openssl x509 -req -days 365 -sha256 -in server.csr -CA ca.pem -CAkey ca-key.pem \</strong><br/><strong> -CAcreateserial -out server-cert.pem -extfile extfile.cnf</strong><br/><br/><strong>Signature ok</strong><br/><strong> subject=/CN=your.host.com</strong><br/><strong> Getting CA Private Key</strong><br/><strong> Enter pass phrase for ca-key.pem:</strong></pre>
<ol start="3">
<li>Start Docker daemon with TLS enabled and use arguments for the CA, server certificate, and CA-signed key. This time, Docker daemon using TLS will run on port <kbd>2376</kbd> (which is standard for the daemon TLS):</li>
</ol>
<pre style="padding-left: 60px"><strong>$ chmod -v 0400 ca-key.pem key.pem server-key.pem</strong><br/><strong>$ chmod -v 0444 ca.pem server-cert.pem cert.pem</strong><br/><strong>$ dockerd --tlsverify --tlscacert=ca.pem --tlscert=server-cert.pem --tlskey=server-key.pem \</strong><br/><strong> -H=0.0.0.0:2376</strong></pre>
<ol start="4">
<li>Using the same CA, create a client CA-signed key, specifying that this key will be used for client authentication:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ openssl genrsa -out key.pem 4096</strong><br/><strong> Generating RSA private key, 4096 bit long modulus</strong><br/><strong> .........................................................++</strong><br/><strong> ................++</strong><br/><strong> e is 65537 (0x10001)</strong><br/><strong> $ openssl req -subj '/CN=client' -new -key key.pem -out client.csr</strong><br/><strong> $ echo extendedKeyUsage = clientAuth &gt; extfile-client.cnf</strong><br/><strong> $ openssl x509 -req -days 365 -sha256 -in client.csr -CA ca.pem -CAkey ca-key.pem \</strong><br/><strong> -CAcreateserial -out cert.pem -extfile extfile-client.cnf</strong><br/><strong> Signature ok</strong><br/><strong> subject=/CN=client</strong><br/><strong> Getting CA Private Key</strong><br/><strong> Enter pass phrase for ca-key.pem:</strong></pre>
<ol start="5">
<li>We will move generated client certificates to the client's host (the client's laptop, for example). We will also copy the public CA certificate file. With its own client certificates and the CA, we will be able to connect to a remote Docker daemon using TLS to secure the communications. We will use the Docker command line with <kbd>--tlsverify</kbd> and other arguments to specify the server's same CA, the client certificate, and its signed key (the daemon's default port for TLS communications is <kbd>2376</kbd>). Let's review an example using <kbd>docker version</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>$ docker --tlsverify --tlscacert=ca.pem --tlscert=cert.pem --tlskey=key.pem -H=$HOST:2376 version</strong></pre>
<p>All these steps should be done to provide TLS communications, and <em>steps 4</em> and <em>5</em> should be undertaken for all client connections if we want to identify their connections (if you don't want to use a unique client certificate/key pair, for example). On enterprise environments, with hundreds or even thousands of users, this is ungovernable and Docker Enterprise will provide a better solution with all these steps included automatically, thereby providing granulated accesses.</p>
<p>Since Docker version 18.09, we can interact with Docker daemon using the <kbd>$ docker -H ssh://me@example.com:22 ps</kbd> command, for example. To use the SSH connection, you need to set up an ssh public key authentication.</p>
<h2 id="uuid-eff35707-2092-4ee4-a1bd-4e28375074bd">Docker daemon security</h2>
<p>Docker container runtime security is based on the following: </p>
<ul>
<li>Security provided by the kernel to containers</li>
<li>The attack surface of the runtime itself</li>
<li>Operating system security applied to the runtime</li>
</ul>
<p>Let's take a look at these in more detail.</p>
<h3 id="uuid-f2b74d1b-c926-49d0-be0c-e9829d0cf67d">Namespaces</h3>
<p>We have been talking about kernel namespaces and how they implement the required isolation for containers. Every container runs with the following namespaces:</p>
<ul>
<li><kbd>pid</kbd>: Process isolation (<strong>Process ID</strong> – <strong>PID</strong>)</li>
<li><kbd>net</kbd>: Manages network interfaces (<strong>Networking</strong> – <strong>NET</strong>)</li>
<li><kbd>ipc</kbd>: Manages access to IPC resources (<strong>InterProcess Communication</strong> – <strong>IPC</strong>)</li>
<li><kbd>mnt</kbd>: Manages filesystem mount points (<strong>Mount</strong> – <strong>MNT</strong>)</li>
<li><kbd>uts</kbd>: Isolates kernel and version identifiers (<strong>Unix Timesharing System</strong> – <strong>UTS</strong>)</li>
</ul>
<p>As each container runs with its own <kbd>pid</kbd> namespace, it will only have access to the listed process on this namespace. The <kbd>net</kbd> namespace will provide its own interfaces, which will allow us to start many processes using the same port on different containers. Container visibility is enabled by default. All containers will have access to external networks using host bridge interfaces.</p>
<p>A complete root filesystem will be inside each container, and it will use this as a standard Unix filesystem (with its own <kbd>/tmp</kbd>, and network files such as <kbd>/etc/hosts</kbd> and <kbd>/etc/resolv.conf</kbd>). This dedicated filesystem is based on copy-on-write, using different layers from images.</p>
<p>Namespaces provide layers of isolation for the container, and control groups will manage how many resources will be available for the container. This will ensure that the host will not get exhausted. In multi-tenant environments, or just for production, it is very important to manage the resources of containers and to not allow non-limited containers.</p>
<p>The attack surface of the daemon is based on user access. By default, Docker daemon does not provide any role-based access solution, but we have seen that we can ensure an encrypted communication for external clients.</p>
<p>As Docker daemon runs as root (the experimental mode will allow us to run rootless), all containers will be able to, for example, mount any directory on your host. This can be a real problem and that is why it's so important to ensure that only required users have access to the Docker socket (local or remote).</p>
<p>As we will see in <a href="c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml">Chapter 3</a>, <em>Running Docker Containers</em>, containers will run as root if we don't specify a user on image building or container startup. We will review this topic later and improve this default user usage.</p>
<p>It is recommended to run just Docker daemon on server-dedicated hosts because Docker can be dangerous in the wrong hands when it comes to other services running on the same host.</p>
<h3 id="uuid-3d1111fe-2a7f-4dc8-ae13-9bab2415cf10">User namespace</h3>
<p>As we've already seen, Linux namespaces provide isolation for processes. These processes just see what cgroups and these namespaces offer, and for these processes, they are running along on their own.</p>
<p>We always recommend running processes inside containers as non-root users (<kbd>nginx</kbd>, for example, does not require root to be running if we use upper ports), but there are some cases where they must be run as root. To prevent privilege escalation from within these root containers, we can apply user remapping. This mechanism will map a root user (UID 0) inside the container, with the user's non-root (UID 30000).</p>
<p>User remapping is managed by two files:</p>
<ul>
<li><kbd>/etc/subid</kbd>: This sets the user ID range for subordinates.</li>
<li><kbd>/etc/subgid</kbd>: This sets the group ID range for subordinates.</li>
</ul>
<p>With these files, we set the first sequence ID for users and groups, respectively. This is an example format for the subordinate ID, <kbd>nonroot:30000:65536</kbd>. This means that UID 0 inside the container will be mapped as UID <kbd>30000</kbd> on the Docker host and so forth.</p>
<p>We will configure Docker daemon to use this user remapping with the <kbd>--userns-remap</kbd> flag or the <kbd>userns-remap</kbd> key in JSON format. In special cases, we can change the user namespace behavior when running the container.</p>
<h3 id="uuid-297a49b1-a3ce-4090-9871-5ac6d7768f67">Kernel capabilities (seccomp) </h3>
<p>By default, Docker starts containers with a restricted set of capabilities. This means that containers will run unprivileged by default. So, running processes inside containers improves application security by default.</p>
<p>These are the 14 capabilities available by default to any container running in your system: <kbd>SETPCAP</kbd>, <kbd>MKNOD</kbd>, <kbd>AUDIT_WRITE</kbd>, <kbd>CHOWN</kbd>, <kbd>NET_RAW</kbd>, <kbd>DAC_OVERRIDE</kbd>, <kbd>FOWNER</kbd>, <kbd>FSETID</kbd>, <kbd>KILL</kbd>, <kbd>SETGID</kbd>, <kbd>SETUID</kbd>, <kbd>NET_BIND_SERVICE</kbd>, <kbd>SYS_CHROOT</kbd>, and <kbd>SETFCAP</kbd>.</p>
<p>The most important thing to understand at this point is that we can run processes inside a container listening on ports under 1024 because we have <kbd>NET_BIND_SERVICE</kbd> capability, for example, or that we can use ICMP inside containers because we have <kbd>NET_RAW</kbd> capability enabled.</p>
<p>On the other hand, there are many capabilities not enabled by default. For example, there are many system operations that will need <kbd>SYS_ADMIN</kbd> capability, or we will need <kbd>NET_ADMIN</kbd> capability to create new interfaces (running <kbd>openvpn</kbd> inside Docker containers will require it).</p>
<p>Processes will not have real root privileges inside containers. Using seccomp capabilities, it is possible to do the following:</p>
<ul>
<li class="mce-root">Deny <kbd>mount</kbd> operations</li>
<li class="mce-root">Deny access to raw sockets (to prevent packet spoofing)</li>
<li class="mce-root">Deny access to some filesystem operations, such as file ownership</li>
<li class="mce-root">Deny module loading, and many others</li>
</ul>
<p>The permitted capabilities are defined using a default <kbd>seccomp</kbd> profile. Docker uses <kbd>seccomp</kbd> in filter mode, disabling all non-whitelisted calls defined on its own JSON format in profile files. There is a default profile that will be used when running containers. We can use our own <kbd>seccomp</kbd> profile using the <kbd>--security-opt</kbd> flag on launch. So, manipulating allowed capabilities is easy during container execution. We will learn more about how to manipulate the behavior of any container at the start of <a href="c2dd78c4-066f-40b4-94e7-a7e2904d7ec2.xhtml">Chapter 3</a><em>, Running Docker Containers</em>:</p>
<pre><strong>$ docker container run --cap-add=NET_ADMIN--rm -it --security-opt seccomp=custom-profile.json alpine sh</strong></pre>
<p>This line will run our container, adding the <kbd>NET_ADMIN</kbd> capability. Using a custom <kbd>seccomp</kbd> profile, we will be adding even more, as defined on <kbd>custom-profile.json</kbd>. For security reasons, we can even use <kbd>--cap-drop</kbd> to drop some of the default capabilities if we are sure that we don't need them.</p>
<p>Avoid using the <kbd>--privileged</kbd> flag as your container will run unconfined, which means that it will run nearly with the same access to the host as processes running outside containers on the host. In this case, resources will be unlimited for this container (the <kbd>SYS_RESOURCE</kbd> capability will be enabled and limit flags will not be used). Best practice for users would be to remove all capabilities except those required by the process to work.</p>
<h3 id="uuid-6b57fc2a-11da-4c04-8766-b81a8bc1e3a5">Linux security modules</h3>
<p>Linux operating systems provide tools to ensure security. In some cases, they come installed and configured by default in out-of-the-box installations, while in other cases, they will require additional administrator interaction.</p>
<p>AppArmor and SELinux are probably the most common. Both provide finer-grained control over file operations and other security features. For example, we can ensure that only the allowed process can modify some special files or directories (for example, <kbd>/etc/passwd</kbd>). </p>
<p>Docker provides templates and policies that are installed with the product that ensures complete integration with these tools to harden Docker hosts. Never disable SELinux or AppArmor on production and use policies to add features or accesses for your processes. </p>
<p>We can review which security modules are enabled in our Docker runtime by looking at the <kbd>SecurityOptions</kbd> section of the <kbd>Docker system info</kbd> output.</p>
<p>We can easily review Docker runtime features using <kbd>docker system info</kbd>. It is good to know that the output can be displayed in JSON format using <kbd>docker system info --format '{{json .}}'</kbd> and that we can filter by using the <kbd>--filter</kbd> option. Filtering allows us, for example, to retrieve only security options applied to the <kbd>docker system info --format '{{json .SecurityOptions}}'</kbd> daemon.<br/>
<br/></p>
<p>By default, Red Hat flavor hosts will not have SELinux enabled, but, on the other hand, Ubuntu will run by default with AppArmor.</p>
<p>There is a very common issue when we move the default Docker data root path to another location in Red Hat Linux. If SELinux is enabled (by default on these systems), you will need to add a new path to the allowed context by using <kbd># semanage fcontext -a -e /var/lib/docker _MY_NEW_DATA-ROOT_PATH</kbd> and then <kbd># restorecon -R -v _MY_NEW_DATA-ROOT_PATH</kbd>.</p>
<h3 id="uuid-d12ab1a4-d41d-4e01-8ec7-35eb97253189">Docker Content Trust</h3>
<p>Docker Content Trust is the mechanism provided by Docker to improve content security. It will provide image ownership and verification of immutability. This option, which is applied at Docker runtime, will help to harden content execution. We can ensure that only certain images can run on Docker hosts. This will provide two different levels of security:</p>
<ul>
<li>Only allow signed images</li>
<li>Only allow signed images by certain users or groups/teams (we will learn about the concepts that are integrated with Docker UCP in <a href="1879ea92-ae47-4230-ac84-784d4bc73185.xhtml">Chapter 11</a>, <em>Universal Control Plane</em>)</li>
</ul>
<p>We will learn about volumes, which are the objects used for container persistent storage, in <a href="e7804d8c-ed8c-4013-8449-b746ee654210.xhtml">Chapter 4</a>, <em>Container Persistency and Networking</em>.</p>
<p>Enabling and disabling Docker Content Trust can be managed by setting the <kbd>DOCKER_CONTENT_TRUST=1</kbd> environment variable in a client session, in the <kbd>systemd</kbd> Docker unit. Alternatively, we can use <kbd>--disable-content-trust=false</kbd> (true by default) on image and container operations.</p>
<p>With any of these flags enabling content trust, all Docker operations will be trusted, which means that we won't be able to download and execute any non-trusted flags (signed images).</p>
<h1 id="uuid-bd0b045d-4a0c-4a3a-9090-838828449c72">Chapter labs</h1>
<p>We will use CentOS 7 as the operating system for the node labs in this book, unless otherwise indicated. We will install Docker Community Edition now and Docker Enterprise for the specific chapters pertaining to this platform.</p>
<p>Deploy <kbd>environments/standalone-environment</kbd> from this book's GitHub repository (<a href="https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git">https://github.com/PacktPublishing/Docker-Certified-Associate-DCA-Exam-Guide.git</a>) if you have not done so yet. You can use your own CentOS 7 server. Use <kbd>vagrant up</kbd> from the <kbd>environments/standalone-environment</kbd><em> </em>folder to start your virtual environment.</p>
<p>If you are using a standalone environment, wait until it is running. We can check the statuses of the nodes using <kbd>vagrant status</kbd>. Connect to your lab node using <kbd>vagrant ssh standalone</kbd>. <kbd>standalone</kbd> is the name of your node. You will be using the <kbd>vagrant</kbd> user with root privileges using <kbd>sudo</kbd>. You should get the following output:</p>
<pre><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$ vagrant up</strong><br/><strong>Bringing machine 'standalone' up with 'virtualbox' provider...</strong><br/><strong>==&gt; standalone: Cloning VM...</strong><br/><strong>==&gt; standalone: Matching MAC address for NAT networking...</strong><br/><strong>==&gt; standalone: Checking if box 'frjaraur/centos7' version '1.4' is up to date...</strong><br/><strong>==&gt; standalone: Setting the name of the VM: standalone</strong><br/><strong>...</strong><br/><strong>==&gt; standalone: Running provisioner: shell...</strong><br/><strong> standalone: Running: inline script</strong><br/><strong> standalone: Delta RPMs disabled because /usr/bin/applydeltarpm not installed.</strong><br/><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$ vagrant status</strong><br/><strong>Current machine states:</strong><br/><strong>standalone running (virtualbox)</strong><br/><strong>...</strong><br/><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$</strong></pre>
<p class="mce-root">We can now connect to a standalone node using <kbd>vagrant ssh standalone</kbd>. This process may vary if you've already deployed a standalone virtual node before and you just started it using <kbd>vagrant up</kbd>:</p>
<pre><strong>Docker-Certified-Associate-DCA-Exam-Guide/environments/standalone$ vagrant ssh standalone</strong><br/><strong>[vagrant@standalone ~]$</strong> </pre>
<p>Now, you are ready to start the labs.</p>
<h2 id="uuid-a3710ca5-6d1b-4014-9976-fd72c16300c2">Installing the Docker runtime and executing a "hello world" container </h2>
<p>This lab will guide you through the Docker runtime installation steps and running your first container. Let's get started:</p>
<ol>
<li>To ensure that no previous versions are installed, we will remove any <kbd>docker*</kbd> packages:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo yum remove docker*</strong><br/></pre>
<ol start="2">
<li>Add the required packages by running the following command:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo yum install -y yum-utils   device-mapper-persistent-data   lvm2</strong></pre>
<ol start="3">
<li>We will be using a stable release, so we will add its package repository, as follows:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo yum-config-manager \<br/>--add-repo https://download.docker.com/linux/centos/docker-ce.repo</strong></pre>
<ol start="4">
<li>Now, install Docker packages and <kbd>containerd</kbd>. We are installing the server and client on this host (since version 18.06, Docker provides different packages for <kbd>docker-cli</kbd> and Docker daemon):</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo yum install -y docker-ce docker-ce-cli containerd.io</strong><br/></pre>
<ol start="5">
<li>Docker is installed, but on Red Hat-like operating systems, it is not enabled on boot by default and will not start. Verify this situation and enable and start the Docker service:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>[vagrant@standalone ~]$ sudo systemctl enable docker</strong><br/><strong>[vagrant@standalone ~]$ sudo systemctl start docker</strong></pre>
<ol start="6">
<li>Now that Docker is installed and running, we can run our first container:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo docker container run hello-world</strong><br/><strong> Unable to find image 'hello-world:latest' locally</strong><br/><strong> latest: Pulling from library/hello-world</strong><br/><strong> 1b930d010525: Pull complete</strong><br/><strong> Digest: </strong><br/><strong>sha256:b8ba256769a0ac28dd126d584e0a2011cd2877f3f76e093a7ae560f2a5301c00</strong><br/><strong> Status: Downloaded newer image for hello-world:latest</strong><br/><br/><strong>Hello from Docker!</strong><br/><br/><strong>This message shows that your installation appears to be working correctly. To generate this message, Docker took the following steps:<br/>1. The Docker client contacted the Docker daemon.</strong><br/><strong>2. The Docker daemon pulled the "hello-world" image from the Docker Hub. (amd64)</strong><br/><strong>3. The Docker daemon created a new container from that image that runs the executable, which produces the output you are currently reading.</strong><br/><strong>4. The Docker daemon streamed that output to the Docker client, which sent it to your terminal.</strong><br/><br/><strong>To try something more ambitious, you can run an Ubuntu container with:</strong><br/><strong>$ docker run -it ubuntu bash</strong><br/><br/><strong>Share images, automate workflows, and more with a free Docker ID: <br/>https://hub.docker.com/.</strong><br/><br/><strong>For more examples and ideas, visit: <br/>https://docs.docker.com/get-started/.</strong></pre>
<p style="padding-left: 60px">This command will send a request to Docker daemon to run a container based on the <kbd>hello-world</kbd> image, located on Docker Hub (<a href="http://hub.docker.com">http://hub.docker.com</a>). To use this image, Docker daemon downloads all the layers if we have not executed any container with this image before; in other words, if the image is not present on the local Docker host. Once all the image layers have been downloaded, Docker daemon will start a <kbd>hello-world</kbd> container.</p>
<p>This book is a guide for the DCA exam and is the simplest lab we can easily deploy. However, you should be able to understand and describe this simple process, as well as think about all the common issues that we may encounter. For example, what happens if the image is on your host and is different, but with the same name and tags? What happens if one layer cannot be downloaded? What happens if you are connected to a remote daemon? We will review some of these questions at the end of this chapter. </p>
<ol start="7">
<li>As you should have noticed, we are always using <kbd>sudo</kbd> to root because our user has not got access to the Docker UNIX socket. This is the first security layer an attacker must bypass on your system. We usually enable a user to run containers in production environments because we want to isolate operating system responsibilities and management from Docker. Just add our user to the Docker group, or add a new group of users with access to the socket. In this case, we will just add our lab user to the Docker group:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ docker container ls</strong><br/><strong>Got permission denied while trying to connect to the Docker daemon socket at unix:///var/run/docker.sock: Get http://%2Fvar%2Frun%2Fdocker.sock/v1.40/containers/json</strong><br/><strong>: dial unix /var/run/docker.sock: connect: permission denied</strong><br/> <br/><strong>[vagrant@standalone ~]$ sudo usermod -a -G docker $USER</strong><br/> <br/><strong>[vagrant@standalone ~]$ newgrp docker</strong><br/> <br/><strong>[vagrant@standalone ~]$ docker container ls -a</strong><br/><strong>CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES</strong><br/><strong>5f7abd49b3e7 hello-world "/hello" 19 minutes ago Exited (0) 19 minutes ago  festive_feynman</strong></pre>
<h2 id="uuid-91fc72ee-c6b3-40fb-976a-fed226a7c56e">Docker runtime processes and namespace isolation</h2>
<p>In this lab, we are going to review what we learned about process isolation and Docker daemon components and execution workflow. Let's get started:</p>
<ol>
<li>Briefly review the Docker <kbd>systemd</kbd> daemon:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo systemctl status docker</strong><br/><strong> ● docker.service - Docker Application Container Engine</strong><br/><strong>   Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; vendor preset: disabled)</strong><br/><strong>   Active: active (running) since sáb 2019-09-28 19:34:30 CEST; 25min ago</strong><br/><strong>     Docs: https://docs.docker.com</strong><br/><strong> Main PID: 20407 (dockerd)</strong><br/><strong>    Tasks: 10</strong><br/><strong>   Memory: 58.9M</strong><br/><strong>   CGroup: /system.slice/docker.service</strong><br/><strong>           └─20407 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</strong><br/> <br/><strong> sep 28 19:34:30 centos7-base dockerd[20407]: time="2019-09-28T19:34:30.222200934+02:00" level=info msg="[graphdriver] using prior storage driver: overlay2"</strong><br/><strong> sep 28 19:34:30 centos7-base dockerd[20407]: time="2019-09-28T19:34:30.234170886+02:00" level=info msg="Loading containers: start."</strong><br/><strong> sep 28 19:34:30 centos7-base dockerd[20407]: time="2019-09-28T19:34:30.645048459+02:00" level=info msg="Default bridge (docker0) is assigned with an IP a... address"</strong><br/><strong> sep 28 19:34:30 centos7-base dockerd[20407]: time="2019-09-28T19:34:30.806432227+02:00" level=info msg="Loading containers: done."</strong><br/><strong> sep 28 19:34:30 centos7-base dockerd[20407]: time="2019-09-28T19:34:30.834047449+02:00" level=info msg="Docker daemon" commit=6a30dfc graphdriver(s)=over...n=19.03.2</strong><br/><strong> sep 28 19:34:30 centos7-base dockerd[20407]: time="2019-09-28T19:34:30.834108635+02:00" level=info msg="Daemon has completed initialization"</strong><br/><strong> sep 28 19:34:30 centos7-base dockerd[20407]: time="2019-09-28T19:34:30.850703030+02:00" level=info msg="API listen on /var/run/docker.sock"</strong><br/><strong> sep 28 19:34:30 centos7-base systemd[1]: Started Docker Application Container Engine.</strong><br/><strong> sep 28 19:34:43 centos7-base dockerd[20407]: time="2019-09-28T19:34:43.558580560+02:00" level=info msg="ignoring event" module=libcontainerd namespace=mo...skDelete"</strong><br/><strong> sep 28 19:34:43 centos7-base dockerd[20407]: time="2019-09-28T19:34:43.586395281+02:00" level=warning msg="5f7abd49b3e75c58922c6e9d655d1f6279cf98d9c325ba2d3e53c36...</strong><br/></pre>
<p style="padding-left: 60px">This output shows that the service is using a default <kbd>systemd</kbd> unit configuration and that <kbd>dockerd</kbd> is using the default parameters; that is, it's using the file descriptor socket on <kbd>/var/run/docker.sock</kbd> and the default <kbd>docker0</kbd> bridge interface. </p>
<ol start="2">
<li>Notice that <kbd>dockerd</kbd> uses a separate <kbd>containerd</kbd> process to execute containers. Let's run some containers in the background and review their processes. We will run a simple alpine with an <kbd>nginx</kbd> daemon:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ docker run -d nginx:alpine</strong><br/><strong> Unable to find image 'nginx:alpine' locally</strong><br/><strong> alpine: Pulling from library/nginx</strong><br/><strong> 9d48c3bd43c5: Already exists  </strong><br/><strong> 1ae95a11626f: Pull complete  </strong><br/><strong> Digest: sha256:77f340700d08fd45026823f44fc0010a5bd2237c2d049178b473cd2ad977d071</strong><br/><strong> Status: Downloaded newer image for nginx:alpine</strong><br/><strong> dcda734db454a6ca72a9b9eef98aae6aefaa6f9b768a7d53bf30665d8ff70fe7</strong><br/></pre>
<ol start="3">
<li>Now, we will look for the <kbd>nginx</kbd> and <kbd>containerd</kbd> processes (process IDs will be completely different on your system; you just need to understand the workflow):</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ ps -efa|grep -v grep|egrep -e containerd -e nginx  </strong><br/><strong> root     15755     1  0 sep27 ?        00:00:42 /usr/bin/containerd</strong><br/><strong> root     20407     1  0 19:34 ?        00:00:02 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock</strong><br/><strong> root     20848 15755  0 20:06 ?        00:00:00 containerd-shim -namespace moby -workdir /var/lib/containerd/io.containerd.runtime.v1.linux/moby/dcda734db454a6ca72a9</strong><br/><strong> b9eef98aae6aefaa6f9b768a7d53bf30665d8ff70fe7 -address /run/containerd/containerd.sock -containerd-binary /usr/bin/containerd -runtime-root /var/run/docker/runtime-runc</strong><br/><strong> root     20863 20848  0 20:06 ?        00:00:00 nginx: master process nginx -g daemon off;</strong><br/><strong> 101      20901 20863  0 20:06 ?        00:00:00 nginx: worker process</strong><br/></pre>
<ol start="4">
<li>Notice that, at the end, the container started from <kbd>20848</kbd> PID. Following the <kbd>runtime-runc</kbd> location, we discover <kbd>state.json</kbd>, which is the container state file:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo ls -laRt /var/run/docker/runtime-runc/moby</strong><br/><strong> /var/run/docker/runtime-runc/moby:</strong><br/><strong> total 0</strong><br/><strong> drwx--x--x. 2 root root 60 sep 28 20:06 dcda734db454a6ca72a9b9eef98aae6aefaa6f9b768a7d53bf30665d8ff70fe7</strong><br/><strong> drwx------. 3 root root 60 sep 28 20:06 .</strong><br/><strong> drwx------. 3 root root 60 sep 28 13:42 ..</strong><br/><strong> /var/run/docker/runtime-runc/moby/dcda734db454a6ca72a9b9eef98aae6aefaa6f9b768a7d53bf30665d8ff70fe7:</strong><br/><strong> total 28</strong><br/><strong> drwx--x--x. 2 root root    60 sep 28 20:06 .</strong><br/><strong> -rw-r--r--. 1 root root 24966 sep 28 20:06 state.json</strong><br/><strong> drwx------. 3 root root    60 sep 28 20:06 ..</strong></pre>
<p style="padding-left: 60px">This file contains container runtime information: PID, mounts, devices, capabilities applied, resources, and more. </p>
<ol start="5">
<li>Our NGINX server runs under PID <kbd>20863</kbd> and the <kbd>nginx</kbd> child process with PID <kbd>20901</kbd> on the Docker host, but let's take a look inside:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ docker container exec dcda734db454 ps -ef</strong><br/><strong> PID USER TIME COMMAND</strong><br/><strong> 1 root 0:00 nginx: master process nginx -g daemon off;</strong><br/><strong> 6 nginx 0:00 nginx: worker process</strong><br/><strong> 7 root 0:00 ps -ef</strong><br/></pre>
<p style="padding-left: 60px">Using <kbd>docker container exec</kbd>, we can run a new process using a container namespace. This is like running a new process inside the container.</p>
<p style="padding-left: 60px">As you can observe, inside the container, <kbd>nginx</kbd> has PID <kbd>1</kbd> and it is the worker process parent. And, of course, we see our command, <kbd>ps -ef</kbd>, because it was launched using its namespaces. </p>
<p style="padding-left: 60px">We can run other containers using the same image and we will obtain the same results. Processes inside each container are isolated from other containers and host processes, but users on the Docker host will see all the processes, along with their real PIDs.</p>
<ol start="6">
<li>Let's take a look at <kbd>nginx</kbd> process namespaces. We will use the <kbd>lsns</kbd> command to review all the host-running process's namespaces. We will obtain a list of all running processes and their namespaces. We will look for <kbd>nginx</kbd> processes (we will not use <kbd>grep</kbd> to filter the output because we want to read the headers):</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ sudo lsns</strong><br/><strong> NS TYPE NPROCS PID USER COMMAND</strong><br/><strong> ..............</strong><br/><strong> ..............</strong><br/><strong> 4026532197 mnt 2 20863 root nginx: master process nginx -g daemon off</strong><br/><strong> 4026532198 uts 2 20863 root nginx: master process nginx -g daemon off</strong><br/><strong> 4026532199 ipc 2 20863 root nginx: master process nginx -g daemon off</strong><br/><strong> 4026532200 pid 2 20863 root nginx: master process nginx -g daemon off</strong><br/><strong> 4026532202 net 2 20863 root nginx: master process nginx -g daemon off</strong></pre>
<p>This lab demonstrated process isolation within a process running inside containers.</p>
<h2 id="uuid-dbdb6e18-f64d-45e0-bccc-a36ec8d0c34e">Docker capabilities</h2>
<p class="mce-root">This lab will cover seccomp capability management. We will launch containers using dropped capabilities to ensure that, by using seccomp to avoid some system calls, processes in containers will only execute allowed actions. Let's get started:</p>
<ol>
<li class="mce-root">First, run a container using the default allowed capabilities. During the execution of this alpine container, we will change the ownership of the <kbd>/etc/passwd</kbd> file:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>[vagrant@standalone ~]$ docker container run --rm -it alpine sh -c "chown nobody /etc/passwd; ls -l /etc/passwd"</strong><br/><strong> -rw-r--r-- 1 nobody root 1230 Jun 17 09:00 /etc/passwd</strong></pre>
<p style="padding-left: 60px" class="mce-root">As we can see, there is nothing to stop us from changing whatever file ownership resides inside the container's filesystem because the main process (in this case, <kbd>/bin/sh</kbd>) runs as the root user.</p>
<ol start="2">
<li class="mce-root">Drop all the capabilities. Let's see what happens:</li>
</ol>
<pre style="padding-left: 60px" class="mce-root"><strong>[vagrant@standalone ~]$ docker container run --rm -it --cap-drop=ALL alpine sh -c "chown nobody /etc/passwd; ls -l /etc/passwd"</strong><br/><strong> chown: /etc/passwd: Operation not permitted</strong><br/><strong> -rw-r--r-- 1 root root 1230 Jun 17 09:00 /etc/passwd</strong></pre>
<p style="padding-left: 60px">You will observe that the operation was forbidden. Since containers run without any capabilities, the <kbd>chown</kbd> command is not allowed to change file ownership.</p>
<ol start="3">
<li>Now, just add the <kbd>CHOWN</kbd> capability to allow a change of ownership for files inside the container:</li>
</ol>
<pre style="padding-left: 60px"><strong>[vagrant@standalone ~]$ docker container run --rm -it --cap-drop=ALL --cap-add CHOWN alpine sh -c "chown nobody /etc/passwd; ls -l /etc/passwd"</strong><br/><strong> -rw-r--r-- 1 nobody root 1230 Jun 17 09:00 /etc/passwd</strong></pre>
<h1 id="uuid-d4c8d190-7311-448a-862c-eeb4a6a779f5">Summary</h1>
<p>In this chapter, we have seen how modern applications are based on microservices. We learned what containers are and their benefits, and how microservices and containers match when we associate a process with specific functionality or a task (microservice) and we run it inside a container. We reviewed container concepts. Then, we talked about images, containers, and the mechanisms that isolate processes from the host. We introduced orchestration and registries as requirements for deploying applications with resilience on cluster environments and the ways in which we can manage images.</p>
<p>We then have learned about Docker's main components and how Docker Client interacts with Docker Engine securely. We introduced the most common Docker objects and the workflow we will use to create, share, and deploy new applications based on containers.</p>
<p>Nowadays, we can use containers on Microsoft Windows, but this all started with Linux. We compared both approaches to understand the similarities and differences between them and the advanced methods used to isolate processes on Windows using Hyper-V.</p>
<p>Finally, we reviewed how to configure Docker Engine using JSON files and environment variables, learned that containers are secure by default, and reviewed the different mechanisms used to accomplish this.</p>
<p>In the next chapter, we will build images using different methods and learn the processes and primitives necessary to create good images.</p>
<h1 id="uuid-0815b77f-4570-40cf-84c9-3ffb2e6af4f0" class="mce-root">Questions</h1>
<ol>
<li>Is it true that we can only run one process per container? (select which sentences are true)</li>
</ol>
<p style="padding-left: 90px">a) We cannot execute more than one process per container. This is a limitation.<br/>
b) We can run more than one process per container, but it is not recommended.<br/>
c) We will only run one process per container to follow microservices logic.<br/>
d) All of the above sentences are false.</p>
<ol start="2">
<li>What kernel facilities provide host CPU resource isolation on containers?</li>
</ol>
<p style="padding-left: 90px">a) Kernel namespaces.<br/>
b) Cgroups (control groups).<br/>
c) Kernel domains.<br/>
d) None of them. It is not possible to isolate host resources.</p>
<ol start="3">
<li>Which of the following sentences are true?</li>
</ol>
<p style="padding-left: 90px">a) All containers will run as root by default.<br/>
b) The user namespace will allow us to map UID 0 to another one on our host system, controlled and without any non-required privileges.<br/>
c) As the Docker daemon runs as root, only root users can run containers on Docker hosts.<br/>
d) All of the above sentences are false.</p>
<ol start="4">
<li>What have we learned about Windows Docker hosts?</li>
</ol>
<p style="padding-left: 90px">a) Linux containers can run on Windows hosts too.<br/>
b) Windows Hyper-V containers will run a small virtual machine, providing the required resources for containers and do not have any Windows operating system dependencies.<br/>
c) Windows Process Isolation requires system DLLs and services on containers to run properly, and do not provide complete portability.<br/>
d) Windows images are bigger than Linux ones because Windows operating system component integrations are required in many cases to run even small processes.</p>
<ol start="5">
<li>Which of the following sentences are true regarding the Docker daemon configuration?</li>
</ol>
<p style="padding-left: 90px">a) We will configure Docker daemon on Linux using JSON format keys and values on <kbd>/etc/docker/daemon.json</kbd> or <kbd>systemd</kbd> unit files.<br/>
b) On Windows hosts, we will use <kbd>%programdata%\docker\config\daemon.json</kbd> to configure Docker daemon.<br/>
c) By default, the Docker client connection to the remote Docker daemon is insecure.<br/>
d) None of the above sentences are true.</p>
<h1 id="uuid-7ed03f01-1937-4a54-8d80-8798ef629780">Further reading</h1>
<ul>
<li>What are microservices?: <a href="https://microservices.io/">https://microservices.io/</a></li>
<li>What is a container?: <a href="https://www.docker.com/resources/what-container">https://www.docker.com/resources/what-container</a></li>
<li>What is Docker?: <a href="https://www.redhat.com/en/topics/containers/what-is-docker">https://www.redhat.com/en/topics/containers/what-is-docker</a></li>
<li>Docker Engine installation and configuration: <a href="https://docs.docker.com/engine/">https://docs.docker.com/engine/</a></li>
<li>Docker storage drivers: <a href="https://docs.docker.com/storage/storagedriver/">https://docs.docker.com/storage/storagedriver/</a></li>
</ul>


            

            
        
    </body></html>