- en: Running a Containerized App in the Cloud
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在云中运行容器化应用
- en: In the previous chapter, we learned how to deploy, monitor, and troubleshoot
    an application in production.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了如何在生产环境中部署、监控和排除应用故障。
- en: In this chapter, we will give an overview of some of the most popular ways of
    running containerized applications in the cloud. We will explore self-hosting
    and hosted solutions and discuss their pros and cons. Fully managed offerings
    from vendors such as Microsoft Azure and Google Cloud Engine will be briefly discussed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将概述一些在云中运行容器化应用的流行方式。我们将探讨自托管和托管解决方案，并讨论它们的优缺点。微软Azure和谷歌云引擎等供应商提供的完全托管服务也将简要讨论。
- en: 'Here are the topics we will be discussing in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论以下主题：
- en: Deploying and using Docker **Enterprise Edition** (**EE**) on **Amazon Web Services**
    (**AWS**)
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**亚马逊网络服务**（**AWS**）上部署并使用Docker **企业版**（**EE**）
- en: Exploring Microsoft's **Azure Kubernetes Service** (**AKS**)
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索微软的**Azure Kubernetes 服务**（**AKS**）
- en: Understanding **Google Kubernetes Engine** (**GKE**)
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解**谷歌 Kubernetes 引擎**（**GKE**）
- en: 'After reading this chapter, you will be able to do the following:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读完本章后，您将能够执行以下操作：
- en: Create a Kubernetes cluster in AWS using Docker EE
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS中使用Docker EE创建一个Kubernetes集群
- en: Deploy and run a simple distributed application in a Docker EE cluster in AWS
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS的Docker EE集群中部署并运行一个简单的分布式应用
- en: Deploy and run a simple distributed application on Microsoft's AKS
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在微软的AKS上部署并运行一个简单的分布式应用
- en: Deploy and run a simple distributed application on GKE
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在GKE上部署并运行一个简单的分布式应用
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: We are going to use AWS, Microsoft Azure, and Google Cloud in this chapter.
    Therefore, it is necessary to have an account for each platform. If you do not
    have an existing account, you can ask for a trial account for all of these cloud
    providers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将使用AWS、微软Azure和谷歌云。因此，需要为每个平台准备一个账户。如果您没有现有账户，可以申请这些云服务提供商的试用账户。
- en: We'll also use the files in the `~/fod-solution/ch18` folder of our `labs` repository
    from GitHub at [https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18](https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将使用来自GitHub的`labs`仓库中`~/fod-solution/ch18`文件夹中的文件，链接为：[https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18](https://github.com/PacktPublishing/Learn-Docker---Fundamentals-of-Docker-19.x-Second-Edition/tree/master/ch18)。
- en: Deploying and using Docker EE on AWS
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在AWS上部署和使用Docker EE
- en: In this section, we're going to install Docker **Universal Control Plane** (**UCP**)
    version 3.0\. UCP is part of Docker's enterprise offering and supports two orchestration engines,
    Docker Swarm and Kubernetes. UCP can be installed in the cloud or on-premises.
    Even hybrid clouds are possible with UCP.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将安装Docker **统一控制平面**（**UCP**）3.0版本。UCP是Docker企业版的一部分，支持Docker Swarm和Kubernetes两种编排引擎。UCP可以在云中或本地安装，甚至可以在混合云环境中使用UCP。
- en: To try this, you need a valid license for Docker EE or you can claim a free
    test license on Docker Store.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要尝试此操作，您需要一个有效的Docker EE许可证，或者您可以在Docker Store申请一个免费测试许可证。
- en: Provisioning the infrastructure
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置基础设施
- en: 'In this first section, we are going to set up the infrastructure needed to
    install Docker UCP. This is relatively straightforward if you are somewhat familiar
    with AWS. Let''s do this by following these steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置安装Docker UCP所需的基础设施。如果您对AWS有所了解，这一步相对简单。我们通过以下步骤来完成：
- en: 'Create an **A****uto Scaling group** (**ASG**) in AWS using the Ubuntu 16.04
    server AMI. Configure the ASG to contain three instances of size `t2.xlarge`.
    Here is the result of this:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在AWS中使用Ubuntu 16.04服务器AMI创建一个**自动扩展组**（**ASG**）。配置该ASG包含三个`t2.xlarge`大小的实例。以下是结果：
- en: '![](img/3aef6cd3-8664-4019-8eff-5ef9712222f7.png)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3aef6cd3-8664-4019-8eff-5ef9712222f7.png)'
- en: ASG on AWS ready for Docker EE
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: AWS上的ASG为Docker EE准备就绪
- en: Once the ASG has been created, and before we continue, we need to open the **security
    group** (**SG**) a bit (which our ASG is part of) so that we can access it through
    SSH from our laptop and also so that the **virtual machines** (**VMs**) can communicate
    with each other.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦ASG创建完成，在继续之前，我们需要稍微开放**安全组**（**SG**），以便能够通过SSH从我们的笔记本电脑访问它，并且**虚拟机**（**VMs**）之间能够相互通信。
- en: 'Navigate to your SG and add two new inbound rules, which are shown here:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到您的安全组（SG）并添加两个新的入站规则，具体如下所示：
- en: '![](img/00df1c32-a142-4c54-9890-8f69a6fa1a88.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![](img/00df1c32-a142-4c54-9890-8f69a6fa1a88.png)'
- en: AWS SG settings
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: AWS 安全组（SG）设置
- en: In the preceding screenshot, the first rule allows any traffic from my personal
    laptop (with the IP address `70.113.114.234`) to access any resource in the SG. The
    second rule allows any traffic inside the SG itself. These settings are not meant
    to be used in a production-like environment as they are way too permissive. However,
    for this demo environment, they work well.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的截图中，第一个规则允许任何来自我个人笔记本（IP 地址为`70.113.114.234`）的流量访问安全组中的任何资源。第二个规则允许安全组内部的所有流量。这些设置不适合用于生产环境，因为它们过于宽松。但是在这个演示环境中，它们非常有效。
- en: Next, we will show you how to install Docker on the VMs we just prepared.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何在刚才准备好的虚拟机上安装 Docker。
- en: Installing Docker
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker
- en: 'After having provisioned the cluster nodes, we need to install Docker on each
    of them. This can be easily achieved by following these steps:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置好集群节点后，我们需要在每个节点上安装 Docker。通过以下步骤可以轻松完成：
- en: 'SSH into all three instances and install Docker. Using the downloaded key,
    SSH into the first machine:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SSH 连接到所有三个实例并安装 Docker。使用下载的密钥，SSH 连接到第一台机器：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here, `<IP address>` is the public IP address of the VM we want to SSH into.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<IP 地址>`是我们想要 SSH 连接的虚拟机的公网 IP 地址。
- en: Now we can install Docker. For detailed instructions, refer to [https://dockr.ly/2HiWfBc](https://dockr.ly/2HiWfBc).
    We have a script in the `~/fod/ch18/aws` folder called `install-docker.sh` that
    we can use.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以安装 Docker。有关详细说明，请参考[https://dockr.ly/2HiWfBc](https://dockr.ly/2HiWfBc)。我们在`~/fod/ch18/aws`文件夹中有一个名为`install-docker.sh`的脚本，可以使用这个脚本进行安装。
- en: 'First, we need to clone the `labs` GitHub repository to the VM:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将`labs` GitHub 仓库克隆到虚拟机：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we run the script to install Docker:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们运行脚本来安装 Docker：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Once the script is finished, we can verify that Docker is indeed installed using `sudo
    docker version`. Repeat the preceding code for the two other VMs.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本完成后，我们可以通过`sudo docker version`来验证 Docker 是否已正确安装。为另外两台虚拟机重复之前的步骤。
- en: '`sudo` is only necessary until the next SSH session is opened to this VM since
    we have added the `ubuntu` user to the `docker` group. So, we need to exit the
    current SSH session and connect again. This time, `sudo` should not be needed
    in conjunction with `docker`.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo` 只在下次打开此虚拟机的 SSH 会话时才需要，因为我们已经将`ubuntu`用户添加到`docker`组。所以，我们需要退出当前的 SSH
    会话并重新连接。这时，`sudo` 不应该与`docker`一起使用。'
- en: Next, we will show how to install Docker UCP on the infrastructure we just prepared.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将展示如何在刚才准备的基础设施上安装 Docker UCP。
- en: Installing Docker UCP
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Docker UCP
- en: 'We need to set a few environment variables, as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要设置一些环境变量，具体如下：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Here, `<IP address>` and `<FQDN>` are the public IP address and the public DNS
    name of the AWS EC2 instance we're installing in UCP.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`<IP 地址>`和`<FQDN>`分别是我们在 UCP 中安装的 AWS EC2 实例的公网 IP 地址和公有 DNS 名称。
- en: 'After that, we can use the following command to download all the images that
    UCP needs:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们可以使用以下命令下载 UCP 需要的所有镜像：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we can install UCP:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以安装 UCP：
- en: '![](img/cd7dc52c-302c-4bee-8746-89a1bde6a8da.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cd7dc52c-302c-4bee-8746-89a1bde6a8da.png)'
- en: Installing UCP 3.0.0-beta2 on a VM in AWS
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 AWS 的虚拟机（VM）上安装 UCP 3.0.0-beta2
- en: Now, we can open a browser window and navigate to `https://<IP address>`. Log
    in with your username, `admin`, and password, `adminadmin`. When asked for the
    license, upload your license key or follow the link to procure a trial license.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以打开浏览器窗口并导航到`https://<IP 地址>`。使用用户名`admin`和密码`adminadmin`登录。当系统要求提供许可证时，上传你的许可证密钥，或者点击链接获取试用许可证。
- en: 'Once logged in, on the left-hand side under the Shared Resources section, select Nodes and
    then click on the Add Node button:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，在左侧的共享资源（Shared Resources）部分，选择节点（Nodes），然后点击添加节点（Add Node）按钮：
- en: '![](img/fbd3044c-9c09-4899-ab0b-8dd5ba14112b.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbd3044c-9c09-4899-ab0b-8dd5ba14112b.png)'
- en: Adding a new node to UCP
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 向 UCP 添加新节点
- en: 'In the subsequent Add Node dialog box, make sure that the node type is Linux and
    the Worker node role is selected. Then, copy the `docker swarm join` command at
    the bottom of the dialog box. SSH into the other two VMs you created and run this
    command to have the respective node join the Docker swarm as a worker node:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在随后的添加节点（Add Node）对话框中，确保节点类型选择为 Linux，并且选择了工作节点（Worker）角色。然后，复制对话框底部的`docker
    swarm join`命令。通过 SSH 连接到你创建的另外两个虚拟机，并运行此命令，让相应的节点作为工作节点加入 Docker swarm：
- en: '![](img/a45a4a6d-6e7d-4c02-be40-c3175c9511b8.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a45a4a6d-6e7d-4c02-be40-c3175c9511b8.png)'
- en: Joining a node as a worker to the UCP cluster
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将节点作为工作节点加入 UCP 集群
- en: 'Back in the web UI of UCP, you should see that we now have three nodes ready,
    as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到 UCP 的 Web 界面，你应该可以看到我们现在有三个节点已准备好，如下所示：
- en: '![](img/ee9b3da4-5b1e-4a53-be1a-72c52291bd58.png)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ee9b3da4-5b1e-4a53-be1a-72c52291bd58.png)'
- en: List of nodes in the UCP cluster
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: UCP 集群中的节点列表
- en: 'By default, worker nodes are configured so that they can only run the Docker
    Swarm workload. This can be changed in the node details, though. In this, three settings are
    possible: Swarm only, Kubernetes only, or mixed workload. Let''s start with Docker
    Swarm as the orchestration engine and deploy our pets application.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，工作节点被配置为只能运行 Docker Swarm 工作负载。不过，这可以在节点详情中更改。在此，有三种设置方式：仅 Swarm、仅 Kubernetes
    或混合工作负载。让我们从 Docker Swarm 作为编排引擎开始，并部署我们的宠物应用程序。
- en: Using remote admin for the UCP cluster
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用远程管理员管理 UCP 集群
- en: 'To be able to manage our UCP cluster remotely from our laptop, we need to create and
    download a so-called **client bundle** from UCP. Proceed with the following steps:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够从笔记本电脑远程管理 UCP 集群，我们需要从 UCP 创建并下载一个所谓的**客户端捆绑包**。请按照以下步骤操作：
- en: In the UCP web UI, on the left-hand side under admin, select the My Profile option.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UCP Web UI 中，在左侧的 admin 下，选择我的个人资料（My Profile）选项。
- en: 'In the subsequent dialog, select the New Client Bundle option and then Generate
    Client Bundle:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在随后的对话框中，选择“新客户端捆绑包”（New Client Bundle）选项，然后点击“生成客户端捆绑包”（Generate Client Bundle）：
- en: '![](img/e6dd0c9c-f925-4ae3-a78f-5113da2f806d.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e6dd0c9c-f925-4ae3-a78f-5113da2f806d.png)'
- en: Generating and downloading a UCP client bundle
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 生成并下载 UCP 客户端捆绑包
- en: Locate the downloaded bundle on your disk and unzip it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到你下载的捆绑包，并解压它。
- en: 'In a new Terminal window, navigate to that folder and source the `env.sh` file:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新的终端窗口中，导航到该文件夹，并加载 `env.sh` 文件：
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should get an output similar to this:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到类似以下的输出：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can verify that we can indeed remotely access the UCP cluster by, for
    example, listing all the nodes of the cluster:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过例如列出集群中所有节点来验证是否能够远程访问 UCP 集群：
- en: '![](img/8d630be3-12cd-4a63-9a0b-d9b2a8aab377.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d630be3-12cd-4a63-9a0b-d9b2a8aab377.png)'
- en: Listing all the nodes of our remote UCP cluster
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 列出我们远程 UCP 集群的所有节点
- en: In the next section, we will look at how to deploy the pets application as a
    stack using Docker Swarm as the orchestration engine.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将学习如何使用 Docker Swarm 作为编排引擎将宠物应用程序作为堆栈部署。
- en: Deploying to Docker Swarm
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Docker Swarm
- en: 'It is now time to deploy our distributed application to our cluster orchestrated
    by Docker Swarm. Follow these steps to do so:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候将我们的分布式应用程序部署到由 Docker Swarm 编排的集群中了。请按照以下步骤进行：
- en: 'In the Terminal, navigate to the `~/fod/ch18/ucp` folder and create the `pets` stack
    using the `stack.yml` file:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在终端中，导航到 `~/fod/ch18/ucp` 文件夹，并使用 `stack.yml` 文件创建 `pets` 堆栈：
- en: '![](img/b83cbe73-2b3b-4b9b-9812-f81f645566b5.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b83cbe73-2b3b-4b9b-9812-f81f645566b5.png)'
- en: Deploying the pets stack into the UCP cluster
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 将宠物堆栈部署到 UCP 集群
- en: 'In the UCP web UI, we can verify that the stack has been created:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 UCP Web UI 中，我们可以验证堆栈是否已创建：
- en: '![](img/a520aaa1-33d0-4ec8-9365-8f17118a6a54.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a520aaa1-33d0-4ec8-9365-8f17118a6a54.png)'
- en: The pets stack listing in the UCP web UI
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: UCP Web UI 中的宠物堆栈列表
- en: 'To test the application, we can navigate to Services under the main menu, Swarm.
    The list of services running in the cluster will be displayed as follows:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试应用程序，我们可以在主菜单中的服务（Services）下，点击 Swarm。集群中运行的服务列表将如下所示：
- en: '![](img/738af281-8a2d-4e01-a299-c9580ae9e18c.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/738af281-8a2d-4e01-a299-c9580ae9e18c.png)'
- en: Details of the 'web' services of the pets stack
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 宠物堆栈的“web”服务详细信息
- en: In the preceding screenshot, we see our two services, `web` and `db`, of the `pets` stack.
    If we click on the `web` service, its details are displayed on the right-hand
    side. There we find an entry, Published Endpoints.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们看到我们的两个服务，`web` 和 `db`，它们属于 `pets` 堆栈。如果我们点击 `web` 服务，其详细信息会显示在右侧。在那里，我们可以找到一个条目，“已发布的端点”（Published
    Endpoints）。
- en: Click on the link and our `pets` application should be displayed in the browser.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击链接，我们的`pets`应用程序应该会在浏览器中显示。
- en: 'When done, remove the stack from the console with the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，用以下命令从控制台中删除堆栈：
- en: '[PRE7]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Alternatively, you can try to remove that stack from within the UCP web UI.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以尝试从 UCP Web UI 中删除该堆栈。
- en: Deploying to Kubernetes
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 部署到 Kubernetes
- en: From the same Terminal that you used to remotely access the UCP cluster to deploy
    the pets application as a stack using Docker Swarm as the orchestration engine,
    we can now try to deploy the pets application to the UCP cluster using Kubernetes
    as the orchestration engine.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从你之前用来远程访问 UCP 集群以部署宠物应用程序的终端，现在我们可以尝试使用 Kubernetes 作为编排引擎，将宠物应用程序部署到 UCP 集群。
- en: 'Make sure you''re still in the `~/fod/ch18/ucp` folder. Use `kubectl` to deploy
    the pets application. First, we need to test that we can get all the nodes of
    the cluster with the Kubernetes CLI:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你仍然在 `~/fod/ch18/ucp` 文件夹中。使用 `kubectl` 部署宠物应用程序。首先，我们需要测试是否能通过 Kubernetes
    CLI 获取集群的所有节点：
- en: '![](img/cf58df9f-5abd-4502-8992-0b22ae829ff9.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/cf58df9f-5abd-4502-8992-0b22ae829ff9.png)'
- en: Getting all the nodes of the UCP cluster using the Kubernetes CLI
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes CLI 获取 UCP 集群的所有节点
- en: 'Apparently, my environment is configured correctly and `kubectl` can indeed
    list all the nodes in the UCP cluster. That means I can now deploy the pets application
    using the definitions in the `pets.yaml` file:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，我的环境配置正确，`kubectl` 确实可以列出 UCP 集群中的所有节点。这意味着我现在可以使用 `pets.yaml` 文件中的定义来部署宠物应用程序：
- en: '![](img/ea01cf48-9dc5-4983-8d4d-b0febc33cb13.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ea01cf48-9dc5-4983-8d4d-b0febc33cb13.png)'
- en: Creating the pets application in the UCP cluster using the Kubernetes CLI
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Kubernetes CLI 在 UCP 集群中创建宠物应用程序
- en: We can list the objects created by using `kubectl get all`. In a browser, we
    can then navigate to `http://<IP address>:<port>` to access the pets application,
    where `<IP address>` is the public IP address of one of the UCP cluster nodes
    and `<port>` is the port published by the `web` Kubernetes service.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `kubectl get all` 列出创建的对象。然后，在浏览器中，我们可以访问 `http://<IP 地址>:<端口>` 来访问宠物应用程序，其中
    `<IP 地址>` 是 UCP 集群节点之一的公共 IP 地址，`<端口>` 是由 `web` Kubernetes 服务发布的端口。
- en: We have created a cluster of three VMs in an AWS ASG and have installed Docker
    and UCP 3.0 on them. We then deployed our famous pets application into the UCP
    cluster, once using Docker Swarm as the orchestration engine and once Kubernetes.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 AWS ASG 中创建了一个由三台虚拟机组成的集群，并在它们上安装了 Docker 和 UCP 3.0。然后，我们将著名的宠物应用程序部署到 UCP
    集群中，一次使用 Docker Swarm 作为编排引擎，另一次使用 Kubernetes。
- en: Docker UCP is a platform-agnostic container platform that offers a secure enterprise-grade
    software supply chain in any cloud and on-premises, on bare metal, or in virtualized
    environments. It even offers freedom of choice when it comes to orchestration
    engines. The user can choose between Docker Swarm and Kubernetes. It is also possible
    to run applications in both orchestrators in the same cluster.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Docker UCP 是一个平台无关的容器平台，提供安全的企业级软件供应链，支持任何云环境、本地环境、裸金属或虚拟化环境。它甚至在编排引擎方面提供了选择自由，用户可以在
    Docker Swarm 和 Kubernetes 之间进行选择。还可以在同一集群中同时运行两个编排器中的应用程序。
- en: Exploring Microsoft's Azure Kubernetes Service (AKS)
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索 Microsoft 的 Azure Kubernetes 服务（AKS）
- en: To experiment with Microsoft's container-related offerings in Azure, we need an
    account on Azure. You can create a trial account or use an existing account. You
    can get a free trial account here: [https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 Azure 上试验 Microsoft 的容器相关服务，我们需要一个 Azure 账户。你可以创建一个试用账户或使用现有账户。你可以在这里获取免费的试用账户：[https://azure.microsoft.com/en-us/free/](https://azure.microsoft.com/en-us/free/)。
- en: Microsoft offers different container-related services on Azure. The easiest one
    to use is probably Azure Container Instances, which promises the fastest and simplest
    way to run a container in Azure, without having to provision any virtual machines
    and without having to adopt a higher-level service. This service is only really
    useful if you want to run a single container in a hosted environment. The setup
    is quite easy. In the Azure portal ([portal.azure.com](http://portal.azure.com)),
    you first create a new resource group and then create an Azure container instance.
    You only need to fill out a short form with properties such as the name of the
    container, the image to use, and the port to open. The container can be made available
    on a public or private IP address and will be automatically restarted if it crashes.
    There is a decent management console available, for example, to monitor resource
    consumption such as CPU and memory.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Microsoft 在 Azure 上提供了不同的容器相关服务。最容易使用的可能是 Azure 容器实例，它承诺是运行容器在 Azure 中的最快、最简单的方式，无需配置虚拟机，也无需采用更高级的服务。如果你只想在托管环境中运行单个容器，这项服务非常有用。设置过程非常简单。在
    Azure 门户（[portal.azure.com](http://portal.azure.com)）中，首先创建一个新的资源组，然后创建一个 Azure
    容器实例。你只需填写一个简短的表单，填写容器名称、使用的镜像和要打开的端口等属性。容器可以通过公共或私有 IP 地址提供，并且如果容器崩溃，它将自动重启。还提供了一个不错的管理控制台，例如用来监控资源消耗（如
    CPU 和内存）。
- en: 'The second choice is **Azure Container Service** (**ACS**), which provides
    a way to simplify the creation, configuration, and management of a cluster of
    VMs that are preconfigured to run containerized applications. ACS uses Docker
    images and provides a choice between three orchestrators: Kubernetes, Docker Swarm,
    and DC/OS (powered by Apache Mesos). Microsoft claims that their service can be
    scaled to tens of thousands of containers. ACS is free and you are only charged
    for computing resources.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个选择是**Azure容器服务**（**ACS**），它提供了一种简化创建、配置和管理预先配置好的虚拟机集群（用于运行容器化应用程序）的方法。ACS使用Docker镜像，并提供三种编排器供选择：Kubernetes、Docker
    Swarm和DC/OS（由Apache Mesos提供支持）。微软声称，他们的服务可以扩展到数万个容器。ACS是免费的，您只需为计算资源付费。
- en: In this section, we will concentrate on the most popular offering, based on
    Kubernetes. It is called AKS and can be found here: [https://azure.microsoft.com/en-us/services/kubernetes-service/](https://azure.microsoft.com/en-us/services/kubernetes-service/).
    AKS makes it easy for you to deploy applications into the cloud and run them on
    Kubernetes. All the difficult and tedious management tasks are handled by Microsoft
    and you can concentrate fully on your applications. What that means is that you
    will never have to deal with tasks such as installing and managing Kubernetes,
    upgrading Kubernetes, or upgrading the operating system of the underlying Kubernetes
    nodes. All this is handled by the experts at Microsoft Azure. Furthermore, you
    will never have to deal with `etc` or Kubernetes master nodes. This is all hidden
    from you, and the only things you will interact with are the Kubernetes worker
    nodes that run your applications.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将集中讨论最受欢迎的Kubernetes基础的服务。它叫做AKS，可以在此找到：[https://azure.microsoft.com/en-us/services/kubernetes-service/](https://azure.microsoft.com/en-us/services/kubernetes-service/)。AKS让您可以轻松将应用程序部署到云端，并在Kubernetes上运行它们。所有困难且繁琐的管理任务都由微软处理，您可以全身心地专注于应用程序。这意味着您永远不需要处理诸如安装和管理Kubernetes、升级Kubernetes或升级Kubernetes节点底层操作系统等任务。所有这些都由微软Azure的专家处理。此外，您永远不需要处理`etc`或Kubernetes主节点。这一切对您来说都是隐藏的，您唯一需要与之交互的是运行应用程序的Kubernetes工作节点。
- en: Preparing the Azure CLI
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备Azure CLI
- en: That said, let's start. We assume that you have created a free trial account
    or that you are using an existing account on Azure. There are various ways to
    interact with your Azure account. We will use the Azure CLI running on our local
    computer. We can either download and install the Azure CLI natively on our computer
    or run it from within a container running on our local Docker for Desktop. Since
    this book is all about containers, let's select the latter approach.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，开始吧。我们假设你已经创建了一个免费试用账户，或者正在使用Azure上的现有账户。有多种方式可以与Azure账户进行交互。我们将使用在本地计算机上运行的Azure
    CLI。我们可以选择在计算机上本地下载并安装Azure CLI，或者在本地的Docker for Desktop容器内运行它。由于本书内容全是关于容器的，所以我们选择后一种方法。
- en: 'The latest version of the Azure CLI can be found on Docker Hub. Let''s pull
    it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 最新版本的Azure CLI可以在Docker Hub上找到。让我们拉取它：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We will be running a container from this CLI and executing all subsequent commands
    from within the shell running inside this container. Now, there is a little problem
    we need to overcome. This container will not have a Docker client installed. But
    we will also run some Docker commands, so we have to create a custom image derived
    from the preceding image, which contains a Docker client. The `Dockerfile` that''s
    needed to do so can be found in the `~/fod/ch18` folder and has this content:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从这个CLI运行一个容器，并在该容器内的Shell中执行所有后续命令。现在，我们需要克服一个小问题。这个容器中不会安装Docker客户端。但是我们也需要运行一些Docker命令，因此我们必须创建一个从前一个镜像派生的自定义镜像，其中包含Docker客户端。为了做到这一点，我们需要的`Dockerfile`文件可以在`~/fod/ch18`文件夹中找到，内容如下：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'On line 2, we are just using the Alpine package manager, `apk`, to install
    Docker. We can then use Docker Compose to build and run this custom image. The
    corresponding `docker-compose.yml` file looks like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二行，我们只是使用Alpine包管理器`apk`来安装Docker。然后，我们可以使用Docker Compose构建并运行这个自定义镜像。相应的`docker-compose.yml`文件如下所示：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Please note the command that is used to keep the container running, as well
    as the mounting of the Docker socket and the current folder in the `volumes` section.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意用于保持容器运行的命令，以及在`volumes`部分挂载Docker套接字和当前文件夹的设置。
- en: If you are running Docker for Desktop on Windows, then you need to define the `COMPOSE_CONVERT_WINDOWS_PATHS`
    environment variable to be able to mount the Docker socket. Use
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在Windows上运行Docker for Desktop，那么你需要定义`COMPOSE_CONVERT_WINDOWS_PATHS`环境变量才能挂载Docker套接字。使用
- en: '`export COMPOSE_CONVERT_WINDOWS_PATHS=1` from a Bash shell or `$Env:COMPOSE_CONVERT_WINDOWS_PATHS=1`
    when running PowerShell. Please refer to the following link for more details: [https://github.com/docker/compose/issues/4240](https://github.com/docker/compose/issues/4240).'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 从Bash shell中使用`export COMPOSE_CONVERT_WINDOWS_PATHS=1`，或者在运行PowerShell时使用`$Env:COMPOSE_CONVERT_WINDOWS_PATHS=1`。有关更多详细信息，请参阅以下链接：[https://github.com/docker/compose/issues/4240](https://github.com/docker/compose/issues/4240)。
- en: 'Now, let''s build and run this container:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行这个容器：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, let''s execute into the `az` container and run a Bash shell in it with
    the following:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，让我们进入`az`容器，并使用以下命令在其中运行Bash shell：
- en: '[PRE12]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We will find ourselves running in a Bash shell inside the container. Let''s
    first check the version of the CLI:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将发现自己在容器内运行的是Bash shell。让我们首先检查CLI的版本：
- en: '[PRE13]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This should result in an output similar to this (shortened):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会生成类似于此的输出（简化版）：
- en: '[PRE14]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'OK, we''re running on version `2.0.78`. Next, we need to log in to our account.
    Execute this command:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们运行的版本是`2.0.78`。接下来，我们需要登录到我们的账户。执行以下命令：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You will be presented with the following message:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到以下提示信息：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Follow the instructions and log in through the browser. Once you have successfully
    authenticated your Azure account, you can go back to your Terminal and you should
    be logged in, as indicated by the output you''ll get:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 按照指示操作并通过浏览器登录。一旦成功验证了你的Azure帐户，你可以返回终端，应该已经登录，输出中会有相关信息：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, we are ready to first move our container images to Azure.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好将容器镜像首先迁移到Azure。
- en: Creating a container registry on Azure
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Azure上创建一个容器注册表
- en: 'First, we create a new resource group named `animal-rg`. In Azure, resource
    groups are used to logically group a collection of associated resources. To have
    an optimal cloud experience and keep latency low, it is important that you select
    a data center located in a region near you. You can use the following command
    to list all regions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`animal-rg`的新资源组。在Azure中，资源组用于逻辑地分组一组相关的资源。为了获得最佳的云体验并保持低延迟，选择一个靠近你的数据中心非常重要。你可以使用以下命令列出所有区域：
- en: '[PRE18]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will give you a rather long list of all possible regions you can select
    from. Use the `name`, for example, `eastasia`, to identify the region of your
    choice. In my case, I will be selecting `westeurope`. Please note that not all
    locations listed are valid for resource groups.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将给你一个相当长的列表，列出所有你可以选择的区域。使用`name`，例如`eastasia`，来识别你选择的区域。在我的案例中，我将选择`westeurope`。请注意，并非所有列出的地点都适用于资源组。
- en: 'The command to create a resource group is simple; we just need a name for the
    group and the location:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建资源组的命令很简单；我们只需要为该组指定名称和位置：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Make sure that your output shows `"provisioningState": "Succeeded"`.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '确保你的输出显示`"provisioningState": "Succeeded"`。'
- en: When running a containerized application in production, we want to make sure
    that we can freely download the corresponding container images from a container
    registry. So far, we have always downloaded our images from Docker Hub. But this
    is often not possible. For security reasons, the servers of a production system
    often have no direct access to the internet and thus are not able to reach out
    to Docker Hub. Let's follow this best practice and assume the same for our Kubernetes
    cluster that we are going to create in an instant.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产环境中运行容器化应用时，我们希望确保能够从容器注册表中自由下载相应的容器镜像。到目前为止，我们一直从Docker Hub下载镜像。但这通常不可行。出于安全原因，生产系统的服务器通常无法直接访问互联网，因此无法访问Docker
    Hub。让我们遵循这一最佳实践，并假设我们的Kubernetes集群在创建时也有相同的限制。
- en: 'So, what can we do? Well, the solution is to use a container image registry
    that is close to our cluster and that is in the same security context. In Azure,
    we can create an **Azure container registry** (**ACR**) and host our images there.
    Let''s first create such a registry:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们该怎么办呢？解决方案是使用一个靠近我们的集群并且位于相同安全上下文中的容器镜像注册表。在Azure中，我们可以创建一个**Azure容器注册表**（**ACR**）并在那里托管我们的镜像。让我们首先创建这样的注册表：
- en: '[PRE20]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Note that `<acr-name>` needs to be unique. In my case, I have chosen the name
    `fodanimalsacr`. The (shortened) output looks like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`<acr-name>`需要是唯一的。在我的情况下，我选择了名称`fodanimalsacr`。输出（简化版）如下：
- en: '[PRE21]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After successfully creating the container registry, we need to log in to that
    registry using the following:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 成功创建容器注册表后，我们需要使用以下命令登录该注册表：
- en: '[PRE22]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Once we are successfully logged in to the container registry on Azure, we need
    to tag our containers correctly so that we can then push them to ACR. Tagging
    and pushing images to ACR will be described next.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功登录到 Azure 上的容器注册表，我们需要正确标记我们的容器，以便之后能够推送到 ACR。接下来将描述如何标记和推送镜像到 ACR。
- en: Pushing our images to ACR
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的镜像推送到 ACR
- en: 'Once we have successfully logged in to ACR, we can tag our images such that
    they can be pushed to the registry. For this, we need to get the URL of our ACR
    instance. We can do so with this command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦成功登录到 ACR，我们可以标记我们的镜像，以便它们可以被推送到注册表。为此，我们需要获取我们的 ACR 实例的 URL。我们可以使用以下命令来完成：
- en: '[PRE23]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We now use the preceding URL to tag our images:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们使用前面的 URL 来标记我们的镜像：
- en: '[PRE24]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we can push them to our ACR:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以将它们推送到我们的 ACR：
- en: '[PRE25]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'To double-check that our images are indeed in our ACR, we can use this command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了双重检查我们的镜像是否确实在 ACR 中，我们可以使用以下命令：
- en: '[PRE26]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Indeed, the two images we just pushed are listed. With that, we are ready to
    create our Kubernetes cluster.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 确实，我们刚刚推送的两个镜像已经列出。这样，我们就可以准备创建我们的 Kubernetes 集群了。
- en: Creating a Kubernetes cluster
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Kubernetes 集群
- en: 'Once again, we will be using our custom Azure CLI to create the Kubernetes
    cluster. We will have to make sure that the cluster can access our ACR instance,
    which we just created and is where our container images reside. So, the command
    to create a cluster named `animals-cluster` with two worker nodes looks like this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们将使用自定义的 Azure CLI 来创建 Kubernetes 集群。我们必须确保集群能够访问我们刚刚创建的 ACR 实例，而该实例是我们容器镜像所在的地方。因此，创建一个名为
    `animals-cluster` 并具有两个工作节点的集群的命令如下：
- en: '[PRE27]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This command takes a while, but after a few minutes, we should receive some
    JSON-formatted output with all the details about the newly created cluster.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令需要一些时间，但几分钟后，我们应该会收到一个 JSON 格式的输出，显示新创建的集群的所有详细信息。
- en: 'To access the cluster, we need `kubectl`. We can easily get it installed in
    our Azure CLI container using this command:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问集群，我们需要 `kubectl`。我们可以使用以下命令轻松地在 Azure CLI 容器中安装它：
- en: '[PRE28]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Having installed `kubectl`, we need the necessary credentials to use the tool
    to operate on our new Kubernetes cluster in Azure. We can get the necessary credentials
    with this:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 安装好 `kubectl` 后，我们需要必要的凭据，以便使用该工具在 Azure 上操作我们的新 Kubernetes 集群。我们可以通过以下命令获取必要的凭据：
- en: '[PRE29]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After the success of the preceding command, we can list all the nodes in our
    cluster:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的命令成功执行后，我们可以列出我们集群中的所有节点：
- en: '[PRE30]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: As expected, we have two worker nodes up and running. The version of Kubernetes
    that is running on those nodes is `1.14.8`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 正如预期的那样，我们有两个工作节点正在运行。那些节点上运行的 Kubernetes 版本是 `1.14.8`。
- en: We are now ready to deploy our application to this cluster. In the next section,
    we are going to learn how we can do this.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好将应用程序部署到这个集群了。在接下来的部分中，我们将学习如何执行这个操作。
- en: Deploying our application to the Kubernetes cluster
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将我们的应用程序部署到 Kubernetes 集群
- en: 'To deploy the application, we can use the `kubectl apply` command:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 要部署应用程序，我们可以使用 `kubectl apply` 命令：
- en: '[PRE31]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The output of the preceding command should look similar to this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的命令执行后的输出应该类似于这样：
- en: '[PRE32]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, we want to test the application. Remember that we had created a service
    of type `LoadBalancer` for the web component. This service exposes the application
    to the internet. This process can take a moment, as AKS, among other tasks, needs
    to assign a public IP address to this service. We can observe this with the following
    command:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们想要测试应用程序。记得我们为 web 组件创建了一个类型为 `LoadBalancer` 的服务。该服务将应用程序暴露到互联网。这一过程可能需要一些时间，因为
    AKS 等任务需要为该服务分配一个公共 IP 地址。我们可以通过以下命令来观察这一过程：
- en: '[PRE33]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Please note the `--watch` parameter in the preceding command. It allows us
    to monitor the progress of the command over time. Initially, we should see output
    like this:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意前面命令中的 `--watch` 参数。它允许我们随着时间的推移监控命令的进度。最初，我们应该看到类似以下的输出：
- en: '[PRE34]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The public IP address is marked as pending. After a few minutes, that should
    change to this:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 公共 IP 地址显示为待定。几分钟后，这应该会变成如下所示：
- en: '[PRE35]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Our application is now ready at the IP address `51.105.229.192` and port number
    `3000`. Note that the load balancer maps the internal port `32618` to the external
    port `3000`; this was not evident to me the first time.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序现在已经准备好，可以通过 IP 地址 `51.105.229.192` 和端口号 `3000` 进行访问。请注意，负载均衡器将内部端口 `32618`
    映射到外部端口 `3000`；这是我第一次没有注意到的。
- en: 'Let''s check it out. In a new browser tab, navigate to `http://51.105.229.192:3000/pet`
    and you should see our familiar application:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看一下。在新浏览器标签页中，访问 `http://51.105.229.192:3000/pet`，你应该能看到我们熟悉的应用程序：
- en: '![](img/f45ab4b8-610f-4909-b6ce-4fce569200c8.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f45ab4b8-610f-4909-b6ce-4fce569200c8.png)'
- en: Our sample application running on AKS
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 AKS 上运行的示例应用程序
- en: With that, we have successfully deployed our distributed application to Kubernetes
    hosted in Azure. We did not have to worry about installing or managing Kubernetes;
    we could concentrate on the application itself.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 至此，我们已成功将我们的分布式应用程序部署到托管在 Azure 上的 Kubernetes 中。我们不需要担心安装或管理 Kubernetes；可以专注于应用程序本身。
- en: 'Now that we are done experimenting with the application, we should not forget
    to delete all resources on Azure to avoid incurring unnecessary costs. We can
    delete all resources created by deleting the resource group as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了应用程序的实验，应该记得删除 Azure 上的所有资源，以避免产生不必要的费用。我们可以通过删除资源组来删除所有资源，操作如下：
- en: '[PRE36]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Azure has a few compelling offerings regarding the container workload, and the
    lock-in is not as evident as it is on AWS due to the fact that Azure does mainly offer open
    source orchestration engines, such as Kubernetes, Docker Swarm, DC/OS, and Rancher.
    Technically, we remain mobile if we initially run our containerized applications
    in Azure and later decide to move to another cloud provider. The cost should be
    limited.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 在容器工作负载方面有一些引人注目的产品，而且由于 Azure 主要提供开源的编排引擎，如 Kubernetes、Docker Swarm、DC/OS
    和 Rancher，因此锁定效应不像 AWS 那样明显。从技术角度来说，如果我们最初在 Azure 上运行我们的容器化应用程序，之后决定迁移到其他云提供商，我们仍然可以保持灵活性。成本也应保持在可控范围内。
- en: It is worth noting that, when you delete your resource group, the Azure Active
    Directory service principal used by the AKS cluster is not removed. Refer to the
    online help for details on how to delete the service principal.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，当你删除资源组时，AKS 集群使用的 Azure Active Directory 服务主体不会被删除。有关如何删除服务主体的详细信息，请参阅在线帮助。
- en: Next on the list is Google with their Kubernetes Engine.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 下一项是 Google 的 Kubernetes 引擎。
- en: Understanding GKE
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 GKE
- en: 'Google is the inventor of Kubernetes and, to this date, the driving force behind
    it. You would therefore expect that Google has a compelling offering around hosted
    Kubernetes. Let''s have a peek into it now. To continue, you need to either have
    an existing account with Google Cloud or create a test account here: [https://console.cloud.google.com/freetrial](https://console.cloud.google.com/freetrial).
    Proceed with the following steps:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Google 是 Kubernetes 的发明者，并且至今仍是其背后的推动力。因此，你可以预期 Google 在托管 Kubernetes 方面有强有力的产品。现在让我们一探究竟。要继续，你需要拥有一个
    Google Cloud 帐户，或者在此创建一个测试帐户：[https://console.cloud.google.com/freetrial](https://console.cloud.google.com/freetrial)。继续以下步骤：
- en: In the main menu, select Kubernetes Engine. The first time you do that, it will
    take a few moments until the Kubernetes engine is initialized.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在主菜单中选择 Kubernetes 引擎。第一次选择时，可能需要一些时间来初始化 Kubernetes 引擎。
- en: Next, create a new project and name it `massai-mara`; this may take a moment.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新项目并命名为 `massai-mara`；这可能需要一点时间。
- en: Once this is ready, we can create a cluster by clicking on Create Cluster in
    the popup.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 准备好后，我们可以通过点击弹窗中的创建集群来创建一个集群。
- en: Select the **Your first cluster** template on the left-hand side of the form.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在表单左侧选择**你的第一个集群**模板。
- en: Name the cluster `animals-cluster`, select the region or zone that's closest
    to you, leave all other settings in the Create a Kubernetes Cluster form with
    their default values, and click on Create at the bottom of the form.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将集群命名为`animals-cluster`，选择离你最近的区域或可用区，保持创建 Kubernetes 集群表单中的所有其他设置为默认值，然后点击表单底部的创建按钮。
- en: 'It will again take a few moments to provision the cluster for us. Once the
    cluster has been created, we can open Cloud Shellby clicking on the shell icon
    in the upper-right corner of the view. This should look similar to the following
    screenshot:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 它将再次花费一些时间为我们配置集群。一旦集群创建完成，我们可以通过点击视图右上角的 Shell 图标来打开 Cloud Shell。这应该看起来像下面的截图：
- en: '![](img/f1bd8565-7c02-4260-bb8e-0dc482fc8051.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f1bd8565-7c02-4260-bb8e-0dc482fc8051.png)'
- en: The first Kubernetes cluster ready and Cloud Shell open in GKE
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GKE 中准备好第一个 Kubernetes 集群并打开 Cloud Shell
- en: 'We can now clone our `labs` GitHub repository to this environment with the
    following command:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下命令将我们的`labs` GitHub 仓库克隆到此环境中：
- en: '[PRE37]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We should now find an `animals.yaml` file in the current folder, which we can
    use to deploy the animals application into our Kubernetes cluster. Have a look
    at the file:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该在当前文件夹中找到一个 `animals.yaml` 文件， 可以用它将动物应用程序部署到我们的 Kubernetes 集群中。看看这个文件：
- en: '[PRE38]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'It has pretty much the same content as the same file we used in the previous
    chapter. The two differences are these:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 它的内容几乎与我们在前一章中使用的文件相同。两个不同之处在于：
- en: We use a service of type `LoadBalancer` (instead of `NodePort`) to publicly
    expose the `web` component.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用的是类型为 `LoadBalancer` 的服务（而不是 `NodePort`）来公开暴露 `web` 组件。
- en: We do not use volumes for the PostgreSQL database since configuring StatefulSets
    correctly on GKE is a bit more involved than in Minikube. The consequence of this
    is that our animals application will not persist the state if the `db` pod crashes.
    How to use persistent volumes on GKE lies outside the scope of this book.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们没有为 PostgreSQL 数据库使用卷，因为在 GKE 上正确配置 StatefulSets 比在 Minikube 中更复杂。这样做的后果是，如果
    `db` pod 崩溃，我们的动物应用程序将无法保存状态。如何在 GKE 上使用持久卷超出了本书的范围。
- en: Also, note that we are not using Google Container Registry to host the container
    images but are instead directly pulling them from Docker Hub. It is very easy,
    and similar to what we have learned in the section about AKS, to create such a
    container registry in Google Cloud.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 另外，请注意，我们没有使用 Google 容器注册中心来托管容器镜像，而是直接从 Docker Hub 拉取它们。这非常简单，类似于我们在 AKS 部分学到的内容，在
    Google Cloud 中创建这样一个容器注册中心也很容易。
- en: 'Before we can continue, we need to set up `gcloud` and `kubectl` credentials:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，我们需要设置 `gcloud` 和 `kubectl` 凭证：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Having done that, it''s time to deploy the application:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 做完这些之后，就可以部署应用程序了：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Once the objects have been created, we can observe the `LoadBalancer` service `web` until
    it is assigned a public IP address:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象创建完成，我们可以观察 `LoadBalancer` 服务 `web`，直到它分配一个公共 IP 地址：
- en: '[PRE41]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The second line in the output is showing the situation while the creation of
    the load balancer is still pending, and the third one gives the final state. Press
    *Ctrl* + *C* to quit the `watch` command. Apparently, we got the public IP address
    `146.148.23.70` assigned and the port is `3000`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 输出的第二行显示的是创建负载均衡器仍在等待中的情况，第三行则给出了最终状态。按 *Ctrl* + *C* 退出 `watch` 命令。显然，我们已经分配了公共
    IP 地址 `146.148.23.70`，端口是 `3000`。
- en: We can then use this IP address and navigate to `http://<IP address>:3000/pet`, and
    we should be greeted by the familiar animal image.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用这个 IP 地址并访问 `http://<IP 地址>:3000/pet`，此时应该会看到熟悉的动物图片。
- en: Once you are done playing with the application, delete the cluster and the project
    in the Google Cloud console to avoid any unnecessary costs.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 完成应用程序的操作后，删除 Google Cloud 控制台中的集群和项目，以避免不必要的费用。
- en: We have created a hosted Kubernetes cluster in GKE. We have then used Cloud
    Shell, provided through the GKE portal, to first clone our `labs` GitHub repository
    and then the `kubectl` tool to deploy the animals application into the Kubernetes
    cluster.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在 GKE 中创建了托管的 Kubernetes 集群。然后，我们使用通过 GKE 门户提供的 Cloud Shell，首先克隆了我们的 `labs`
    GitHub 仓库，然后使用 `kubectl` 工具将动物应用程序部署到 Kubernetes 集群中。
- en: When looking into a hosted Kubernetes solution, GKE is a compelling offering.
    It makes it very easy to start, and since Google is the main driving force behind
    Kubernetes, we can rest assured that we will always be able to leverage the full
    functionality of Kubernetes.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 当考虑托管的 Kubernetes 解决方案时，GKE 是一个非常有吸引力的选择。它让启动变得非常简单，并且由于 Google 是 Kubernetes
    背后的主要推动力，我们可以放心地使用 Kubernetes 的全部功能。
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 总结
- en: In this final chapter of the book, you first got a quick introduction to how
    to install and use Docker's UCP, which is part of Docker's enterprise offering
    on AWS. Then, you learned how to create a hosted Kubernetes cluster in AKS and
    run the animals application on it, followed by the same for Google's own hosted
    Kubernetes offering, GKE.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的最后一章，你首先了解了如何安装和使用 Docker 的 UCP，这是 Docker 在 AWS 上的企业级产品的一部分。然后，你学会了如何在 AKS
    中创建托管的 Kubernetes 集群并运行动物应用程序，接着是 Google 自己的托管 Kubernetes 解决方案 GKE。
- en: I am honored that you selected this book, and I want to thank you for accompanying
    me on this journey, where we explored Docker containers and container orchestration
    engines. I hope that this book has served as a valuable resource on your learning
    journey. I wish you all the best and much success when using containers in your
    current and future projects.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我很荣幸您选择了这本书，我也要感谢您与我一同走过这段旅程，在这段旅程中我们一起探讨了 Docker 容器及容器编排引擎。我希望这本书能成为您学习旅程中的宝贵资源。祝愿您在当前和未来的项目中使用容器时取得成功！
- en: Questions
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'To assess your knowledge, please answer the following questions:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 为了评估您的知识，请回答以下问题：
- en: Give a high-level description of the tasks needed to provision and run Docker
    UPC on AWS.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给出在 AWS 上配置和运行 Docker UPC 所需任务的高级描述。
- en: List a few reasons why you would select a hosted Kubernetes offering, such as
    Microsoft's AKS or Google's GKE, to run your applications on Kubernetes.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列举选择托管 Kubernetes 服务（如微软的 AKS 或谷歌的 GKE）来运行应用程序的一些原因。
- en: Name two reasons when using a hosted Kubernetes solution, such as AKS or GKE,
    to consider hosting your container images in the container registry of the respective
    cloud provider.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用托管 Kubernetes 解决方案（如 AKS 或 GKE）时，列出两个考虑将容器镜像托管在相应云服务提供商的容器注册表中的理由。
- en: Further reading
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The following articles give you some more information related to the topics
    we discussed in this chapter:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 以下文章为您提供了一些与本章讨论的主题相关的更多信息：
- en: Install individual Docker EE components on Linux servers at [https://dockr.ly/2vH5dpN](https://dockr.ly/2vH5dpN)
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Linux 服务器上安装独立的 Docker EE 组件，请参见 [https://dockr.ly/2vH5dpN](https://dockr.ly/2vH5dpN)
- en: Azure Container Service (AKS) at [https://bit.ly/2JglX9d](https://bit.ly/2JglX9d)
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 容器服务 (AKS) 相关信息请见 [https://bit.ly/2JglX9d](https://bit.ly/2JglX9d)
- en: Google Kubernetes Engine at [https://bit.ly/2I8MjJx](https://bit.ly/2I8MjJx)
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Google Kubernetes Engine 相关信息请见 [https://bit.ly/2I8MjJx](https://bit.ly/2I8MjJx)
