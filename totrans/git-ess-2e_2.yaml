- en: Git Fundamentals - Working Locally
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will dive deep into some of the fundamentals of Git; it
    is essential to understand well how Git thinks about files, its way of tracking
    the history of commits, and all the basic commands that we need to master, in
    order to become proficient.
  prefs: []
  type: TYPE_NORMAL
- en: Digging into Git internals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this second edition of *Git Essentials*, I slightly changed my approach in
    explaining how Git works; instead of explaining with words and figures, this time
    I want to show you how Git works internally with only the help of the shell, allowing
    you to follow all the steps on your computer and hoping that these will be clear
    enough for you to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Once you know the fundamentals of the Git working system, I think the rest of
    the commands and patterns will be clearer, allowing you to accomplish proficiently
    your daily work, getting out of trouble when needed.
  prefs: []
  type: TYPE_NORMAL
- en: So, it's time to start digging inside the true nature of Git; in this chapter,
    we will get in touch with the essence of this powerful tool.
  prefs: []
  type: TYPE_NORMAL
- en: Git objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](831d785f-1ea2-4ea1-b175-21a22d9fb26a.xhtml), *Getting Started
    with Git*, we created an empty folder (in `C:\Repos\MyFirstRepo`) and then we
    initialized a new Git repository, using the `git init` command.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new repository to refresh our memory and then start learning
    a little bit more about Git.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we use Git to track our shopping list before going to the
    grocery; so, create a new grocery folder, and then initialize a new Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we have already seen before, the result of the `git init` command is the
    creation of a `.git` folder, where Git stores all the files it needs to manage
    our repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'So, we can move this `grocery` folder wherever we want, and no data will be
    lost. Another important thing to highlight is that we don''t need any server:
    we can create a repository locally and work with it whenever we want, even with
    no LAN or internet connection. We only need them if we want to share our repository
    with someone else, directly or using a central server.'
  prefs: []
  type: TYPE_NORMAL
- en: In fact, during this example, we won't use any remote server, as it is not necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go on and create a new `README.md` file to remember the purpose of this repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Then add a banana to the shopping list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, as you already know, before doing a commit, we have to add files
    to the *staging area*; add both the files using the shortcut `git add .`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: With this trick (the dot after the `git add` command), you can add all the new
    or modified files in one shot.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, if you didn''t set up a global username and email like we did
    in [Chapter 1](831d785f-1ea2-4ea1-b175-21a22d9fb26a.xhtml), *Getting Started with
    Git*, this is a thing that could happen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First of all, take a look at the second line, where Git says something like
    **`root commit`**; this means this is **the first commit** of your repository,
    and this is like a root in a tree (or a root on a disk partition; maybe you nerds
    will understand this better). Later we will come back to this concept.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, Git shows a message that says: "*You didn''t set a global username and
    email; I used ones I found configured in your system, but if you don''t like it,
    you can go back and remake your commit with another pair of data*".'
  prefs: []
  type: TYPE_NORMAL
- en: 'I prefer not to set up a global username and password in Git, as I usually
    work on different repositories using different usernames and emails; if I don''t
    pay attention, I end up doing a job commit with my hobby profile or vice versa,
    and this is annoying. So, I prefer setting up usernames and emails per repository;
    in Git, you can set up your config variables at three levels: *repository* (with
    the `--local` option, the default one), *user* (with the `--global` option), and
    *system-wide* (with the `--system` option). Later we will learn something more
    about configuration, but this is what you need for now to go on with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s change these settings and *amend* our commit (amending a commit
    is a way to redo the last commit and fix up some little mistakes, such as adding
    a forgotten file, changing the message or the author, as we are going to do; later
    we will learn in detail what this means):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As I didn't specify the config level, these parameters will be set at *repository
    level* (the same as `--local`); from now on, all the commits I will do in this
    repository will be signed by `"Ferdinando Santacroce"`, with the `ferdinando.santacroce@gmail.com`
    email (now you know how to get in touch with me, just in case).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now it''s time to type this command, `git commit --amend --reset-author`. When
    amending a commit this way, Git opens the default editor to let you change even
    the commit message, if you like; as we have seen in [Chapter 1](831d785f-1ea2-4ea1-b175-21a22d9fb26a.xhtml),
    *Getting Started with Git*, in Windows the default editor is *Vim*. For the purpose
    of this exercise, please leave the message as it is, press *Esc*, and then input
    the `:wq` (or `:x`) command and press *Enter* to save and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now I have a commit with the right author and email.
  prefs: []
  type: TYPE_NORMAL
- en: Commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to start investigating commits.
  prefs: []
  type: TYPE_NORMAL
- en: 'To verify the commit we have just created, we can use the `git log` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, `git log` shows the commit we did in this repository; `git log`
    shows all the commits, in reverse chronological order; we have only a commit for
    now, but next we will see this behavior in action.
  prefs: []
  type: TYPE_NORMAL
- en: The hash
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is now time to analyze the information provided. The first line contains
    the commit's **SHA-1** ([https://en.wikipedia.org/wiki/SHA-1](https://en.wikipedia.org/wiki/SHA-1)),
    an alphanumeric sequence of 40 characters representing a hexadecimal number. This
    *code*, or **hash**, as it is usually called, uniquely identifies the commit within
    the repository, and it's thanks to it that from now on we can refer to it doing
    some actions.
  prefs: []
  type: TYPE_NORMAL
- en: The author and the commit creation date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We already talked about authors just a couple of paragraphs before; the **author**
    is who performed the commit, and the **date** is the full date when the commit
    was generated. Since that instance, this commit is part of the repository.
  prefs: []
  type: TYPE_NORMAL
- en: The commit message
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just under the author and date, after a blank line, we can see the message we
    attached to the commit we made; even the message is part of the commit itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'But there''s something more under the hood; let''s try to use the `git log`
    command with the `--format=fuller` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The committer and the committing date
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Other than the author, a commit preserves even the **committer**, and the **committing
    date**; what''s the difference compared to author and author date? First of all,
    don''t worry too much about this: 99% of commits in your repository will have
    the same values for the author and committer, and the same dates.'
  prefs: []
  type: TYPE_NORMAL
- en: In some situations, such as the *cherry-pick*, you carry an existing commit
    on top of another branch, making a brand-new commit that applies the same changes
    of the previous. In this case, the author and author date will remain the same,
    while the committer and the committing date will be related to the person who
    performed this operation and the date they did it. Later we will get in touch
    with this useful Git command.
  prefs: []
  type: TYPE_NORMAL
- en: Going deeper
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We analyzed a commit, and the information supplied by a simple `git log`; but
    we are not yet satisfied, so go deeper and see what's inside.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the `git log` command again, we can enable x-ray vision using the `--format=raw`
    option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This time the output format is different; we can see the author and committer,
    as we saw before, but in a more compact form; then there is the commit message,
    but something new appears: it''s a *tree*. Please be patient, we will talk about
    trees in a couple of paragraphs.'
  prefs: []
  type: TYPE_NORMAL
- en: What I want to show now is another command, this time a little bit more obscure;
    it's `git cat-file -p`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's try this command. To make it work, we need to specify the **object** we
    want to investigate; we can use the hash of the object, our first commit in this
    case. You don't need to specify the entire hash, but the first five-six characters
    are enough for small repositories. Git is smart enough to understand what's the
    object even with less than the 40 characters; the minimum is four characters,
    and the number increases as the total amount of Git objects in the repository
    increases. Just to give you an idea, the Linux kernel is currently 15 million
    lines of code, with millions of tracked files and folders; in that Git repository[1],
    you need to specify 12 characters to get the right object.
  prefs: []
  type: TYPE_NORMAL
- en: When in need, I usually try typing only the first five characters; if they are
    not sufficient to make Git aware of the object I need, it will warn me to input
    a character or two more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Back on topic; type the command, specifying the first characters of the commit''s
    hash (`a57d7` in my case):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Okay, as you can see, the output is the same of `git log --format=raw`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not unusual in Git: there are different commands and options that end
    up doing the same thing; this is a common *feature* of Git, and it''s due to its
    organic growth across the years. Git changed (and changes) continuously, so the
    developers have to guarantee some backward compatibility when introducing new
    commands; this is one of the side effects.'
  prefs: []
  type: TYPE_NORMAL
- en: I introduced this command only to have the chance of introducing another peculiarity
    of Git, the separation between *porcelain commands* and *plumbing commands*.
  prefs: []
  type: TYPE_NORMAL
- en: Porcelain commands and plumbing commands
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git, as we know, has a myriad of commands, some of which are practically never
    used by the average user; as by example, the previous `git cat-file`. These commands
    are called **plumbing commands**, while those we have already learned about, such
    as `git add`, `git commit`, and so on, are among the so-called **porcelain commands**.
  prefs: []
  type: TYPE_NORMAL
- en: The metaphor originates directly from the fervent imagination of Linus Torvalds,
    the dad of Git, and has to do with plumbers. They, as is well known, also take
    care of the maintenance of the toilets; here Linus refers to the toilet bowl.
    The bowl is a porcelain artifact, which makes us sit comfortably; using then a
    series of pipes and devices, it allows us a correct discharge of what you know
    down into the sewerage system.
  prefs: []
  type: TYPE_NORMAL
- en: Linus has used this refined metaphor to divide the Git commands into two families,
    the highest-level ones, comfortable for a user interested in the most common operations
    (*porcelain*) and those used internally by the same (but usable at the discretion
    of the more experienced users) to perform lower-level operations (*plumbing*).
  prefs: []
  type: TYPE_NORMAL
- en: We can, therefore, consider porcelain commands as *interface* commands to the
    user, while the plumbing works at a *low level*. This also means that porcelain
    commands stay more *stable* over time (usage patterns and options vary with more
    caution and delayed time), as they are used directly, but are also implemented
    in numerous graphic tools, editors, and so on, while plumbing generally evolves
    with less restrictions.
  prefs: []
  type: TYPE_NORMAL
- en: There is no precise subdivision between these two categories of commands, as
    the border is often quite lively; we will still use them, in order to better understand
    the internal functioning of Git.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go back to the topic now; we were talking about Git objects.
  prefs: []
  type: TYPE_NORMAL
- en: Git uses four different types of **objects**, and *commit* is one of these.
    Then there are *tree*, *blob*, and *annotated tag*. Let's leave the annotated
    tags aside for a moment (whoever already uses a versioning system knows what tags
    are) and focus on blobs and trees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, for convenience, there is the output of the `git cat-file -p` command
    typed before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we can understand now, this plumbing command lets you peek into the Git objects;
    with the `-p` option (which means *pretty-print* here), we ask Git to show an
    easier way to read what the contents of the object are.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, it''s time to learn what a tree is in Git; in fact, in the command
    output, we can see this line: `tree a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40`.'
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean? Let's see it together.
  prefs: []
  type: TYPE_NORMAL
- en: Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **tree** is a **container** for blobs and other trees. The easiest way to
    understand how it works is to think about folders in your operating system, which
    also collect files and other subfolders inside them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to see what this additional Git object holds, using again the `git
    cat-file -p` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This tree, which we said is something that Git uses to identify a folder, also
    contains some additional objects, called **blobs.**
  prefs: []
  type: TYPE_NORMAL
- en: Blobs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you can see, at the right of the previous command output, we have `README.md` and
    `shoppinglist.txt`, which makes us guess that Git blobs represent the **files**.
    As before, we can verify its contents; let''s see what''s inside `637a0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Wow! Its content is exactly the content of our `shoppingFile.txt` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'To confirm, we can use the `cat` command, which on `*nix` systems allows you
    to see the contents of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the result is the same.
  prefs: []
  type: TYPE_NORMAL
- en: Blobs are binary files, nothing more and nothing less. These byte sequences,
    which cannot be interpreted with the naked eye, retain inside information belonging
    to any file, whether binary or textual, images, source code, archives, and so
    on. Everything is compressed and transformed into a blob before archiving it into
    a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: As already mentioned previously, each file is marked with a *hash*; this hash
    uniquely identifies the file within our repository, and it is thanks to this ID
    that Git can then retrieve it when needed, and detect any changes when the same
    file is altered (files with different content will have different hashes).
  prefs: []
  type: TYPE_NORMAL
- en: We said SHA-1 hashes are unique; but what does it mean?
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to understand it better with an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open a shell and try to play a bit with another plumbing command, `git hash-object`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `git hash-object` command is the plumbing command to calculate the hash
    of any object; in this example, we used the `--stdin` option to pass as a command
    argument the result of the preceding command, `echo "banana";` in a few words,
    we calculated the hash of the string `"banana"`, and it came out `637a09b86af61897fb72f26bfb874f2ae726db82`.
  prefs: []
  type: TYPE_NORMAL
- en: And on your computer, did you try it? What is the result?
  prefs: []
  type: TYPE_NORMAL
- en: A bit of suspense... That's incredible, it's the same!
  prefs: []
  type: TYPE_NORMAL
- en: You can try to rerun the command as many times as you want, the resulting hash
    will always be the same (if not, it can be due to different line endings in your
    operating system or shell).
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes us understand something very important: **an object**, whatever
    it is, **will always have the same hash in any repository**, in any computer,
    on the face of the Earth.'
  prefs: []
  type: TYPE_NORMAL
- en: The experienced and the smart ones probably had "*smelt a rat*" for some time
    now, but I hope that in the rest of the readers I have pulled up the same amazement
    that caught me when I did this for the first time. This behavior has some interesting
    implications, as we will see soon.
  prefs: []
  type: TYPE_NORMAL
- en: 'Last, but not least, I want to highlight how **Git calculates the hash on the
    content of the file, not in the file itself**; in fact, the `637a09b86af61897fb72f26bfb874f2ae726db82`
    hash calculated using `git hash-object` is the same as the blob we inspect previously
    using `git cat-file -p`. This teaches us an important lesson: if you have two
    different files with the same content, even if they have different names and paths,
    in Git you will end up having only one blob.'
  prefs: []
  type: TYPE_NORMAL
- en: Even deeper - the Git storage object model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, now we know there are different Git objects, and we can inspect inside
    them using some plumbing commands. But how and where does Git store them?
  prefs: []
  type: TYPE_NORMAL
- en: 'Do you remember the `.git` folder? Let''s put our nose inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Within it, there is an `objects` subfolder; let''s take a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than `info` and `pack` folders, which are not interesting for us right
    now, as you can see there are some other folders with a strange two-character
    name; let''s go inside the `63` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Hmmm...
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the file within it, and think: `63` + `7a09b86af61897fb72f26bfb874f2ae726db82`
    is actually the hash of our `shoppingList.txt` blob!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git is amazingly smart and simple: to be quicker while searching through the
    filesystem, Git creates a set of folders where the name is two characters long,
    and those two characters represent the first two characters of a hash code; inside
    those folders, Git writes all the objects using as a name the other 38 characters
    of the hash, regardless of the kind of Git object.'
  prefs: []
  type: TYPE_NORMAL
- en: So, the `a31c31cb8d7cc16eeae1d2c15e61ed7382cebf40` tree is stored in the `a3`
    folder, and the `a57d783905e6a35032d9b0583f052fb42d5a1308` commit in the `a5`
    one.
  prefs: []
  type: TYPE_NORMAL
- en: Isn't that the most clever and simple thing you have ever seen?
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if you try to inspect those files with a common `cat` command, you will
    be deluded: those files are plain text files, but Git compresses them using the
    `zlib` library to reserve space on your disk. This is why we use the `git cat-file
    -p` command, which decompresses them on the fly for us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This highlights once again the simplicity of Git: no metadata, no internal
    databases, or useless complexity, but simple files and folders are enough to make
    it possible to manage any repository.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we know how Git stores objects, and where they are archived;
    we also know that there is no database, no central repository or stuff like that,
    so how is Git able to reconstruct the history of our repository? How can it define
    which commit precedes or follows another one?
  prefs: []
  type: TYPE_NORMAL
- en: 'To become aware of this, we need a new commit. So, let''s now proceed modifying
    the `shoppingList.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Use the `git log` command to check the new commit; the `--oneline` option allows
    us to see the log in a more compact way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we have a new commit, with its hash. Time to see what''s inside it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: There's something new!
  prefs: []
  type: TYPE_NORMAL
- en: I'm talking about the `parent a57d783905e6a35032d9b0583f052fb42d5a1308` row;
    did you see? A **parent** of a commit is simply the commit that precedes it. In
    fact, the `a57d783` hash is actually the hash of the first commit we made. So,
    every commit has a parent, and following these relations between commits, we can
    always navigate from a random one down to the first one, the already mentioned
    **root commit**.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, the first commit did not have a parent, and this is the main
    (and only) difference between all commits and the first one. Git, while navigating
    and reconstructing our repository, simply knows it is done when it finds a commit
    without a parent.
  prefs: []
  type: TYPE_NORMAL
- en: Git doesn't use deltas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to investigate another well-known difference between Git and
    other versioning systems. Take Subversion as an example: when you do a new commit,
    Subversion creates a new numbered revision that only contains deltas between the
    previous one; this is a smart way to archive changes to files, especially among
    big text files, because if only a line of text changes, the size of the new commit
    will be much smaller.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, in Git even if you change only a char in a big text file, it always
    stores a new version of the file: **Git doesn''t do deltas** (at least not in
    this case), and **every commit is actually a snapshot of the entire repository**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, people usually exclaim: <q>"Gosh, Git waste a large amount of
    disk space in vain!"</q>. Well, this is simply untrue.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a common source code repository, with a certain amount of commit, Git usually
    won''t need more space than other versioning systems. As an example, when Mozilla
    went from Subversion to Git, the exact same repository went from 12GB to 420MB
    disk space required; look at this comparison page to learn more: [https://git.wiki.kernel.org/index.php/GitSvnComparsion](https://git.wiki.kernel.org/index.php/GitSvnComparsion)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, Git has a clever way to deal with files; let''s take a look again
    at the last commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now to the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Annotate the two hashes on a notepad; now we have to look at the tree of the
    first commit; cat-file the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then cat-file the tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Guess what! The hash of the `README.md` file is the same in the two trees of
    the first and second commit; this allows us to understand another simple but clever
    strategy that Git adopts to manage files; when a file is untouched, while committing
    Git creates a tree where the blob for the file points to the already existing
    one, *recycling* it and avoiding waste of disk space.
  prefs: []
  type: TYPE_NORMAL
- en: 'The same applies to the trees: if my working directory has some folders and
    files within them that will remain untouched, when we do a new commit Git recycles
    the same trees.'
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's time to summarize all the concepts illustrated since now.
  prefs: []
  type: TYPE_NORMAL
- en: 'An image, as they say, is worth a thousand words, so here you can find a picture
    representing the actual state of our repository, thanks to the **git-draw** tool
    ([https://github.com/sensorflo/git-draw](https://github.com/sensorflo/git-draw)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2108beaa-0538-4922-b88f-f3efa0370e76.png)'
  prefs: []
  type: TYPE_IMG
- en: In this graphic representation, you will find a detailed diagram that represents
    the current structure of the newly created repository; you can see trees (yellow),
    blobs (white), commits (green), and all relationships between them, represented
    by oriented arrows.
  prefs: []
  type: TYPE_NORMAL
- en: Note how the direction of the arrow joining the commit comes from the second
    commit and goes to the first, or from descendant to its ancestor; it may seem
    a detail, but it is important that graphic representations such as these are properly
    indicated in order to correctly highlight the relationship that binds the commits
    between them (it is always the child who depends on the parent).
  prefs: []
  type: TYPE_NORMAL
- en: 'I just want to highlight some other things; such as:'
  prefs: []
  type: TYPE_NORMAL
- en: The two different trees refer to the same `README.md` blob
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are two different blobs for the `shoppingList.txt` files, one containing
    only the `banana` text line and one containing `banana` and `apple`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second commit refers to the first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first commit has no parent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are three commits!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What the heck?!
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, don''t panic. Look at the commit at the right of the picture, and read
    author and email: that was the first commit we did using the *wrong* user and
    email; after that, we amended the commit, changing the author, remember?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, but why is it already there? And why do we see it in this picture, but
    we don't see it in `git log`?
  prefs: []
  type: TYPE_NORMAL
- en: It's about **reachability** of the commit, a topic that we will talk about in
    the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Git references
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we have seen that a Git repository can be imagined
    as a tree that, starting from a root (the root-commit), grows upward through one
    or more branches.
  prefs: []
  type: TYPE_NORMAL
- en: These branches are generally distinguished by a name. In this Git is no exception;
    if you remember, the experiments conducted so far led us to commit to the `master`
    branch of our test repository. *Master* is precisely the name of the *default
    branch* of a Git repository, somewhat like `trunk` is for Subversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'But Subversion analogies end here: we will now see how Git handles branches,
    and for Subversion users it will be a little surprising.'
  prefs: []
  type: TYPE_NORMAL
- en: It's all about labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Git, **a branch is nothing more than a label**, a *mobile label* placed on
    a commit.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, every leaf on a Git branch has to be labeled with a meaningful name
    to allow us to reach it and then move around, go back, merge, rebase, or discard
    some commits when needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start exploring this topic by checking the current status of our `grocery`
    repository; we do it using the well-known `git log` command, this time adding
    some new options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s look at those options in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--graph`: In this case it just adds an asterisk to the left, before the commit
    hash, but when you have more branches, this option will draw them for us giving
    a simple but effective graphical representation of the repository'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--decorate`: This option prints out the labels attached to any commits that
    are shown; in this case, it prints `(HEAD ->``master)` on the `e4a5e7b` commit'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--oneline`: This is easy to understand: it reports every commit using one
    line, shortening things when necessary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll now do a new commit and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Have you noticed? After adding an orange to the `shopingList.txt`, I made a
    commit without first making `git add`; the *trick* is in the `-a` (`--add`) option
    added to the `git commit` command, which means *add to this commit all the modified
    files that I have already committed at least one time before*. In our case, this
    option allowed us to go faster and skip the `git add` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, use it carefully, especially while learning and using Git at the beginning:
    you easily end up doing commit with more files than you want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, go on now and take a look at the current repository situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Interesting! Both `HEAD` and `master` have now moved on the last commit, the
    third one; what does it mean?
  prefs: []
  type: TYPE_NORMAL
- en: Branches are movable labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have seen in the previous sections how the commits are linked to each other
    by a parent-and-son relationship: each commit contains a reference to the previous
    commit.'
  prefs: []
  type: TYPE_NORMAL
- en: This means that, for example, to *navigate* within a repository I cannot start
    from the first commit and try to go to the next, because a commit has no reference
    to who comes next, but to who comes first. By staying in our *arboreal* metaphor,
    this means that our tree is only navigable from *leaves*, from the extreme *top* of
    a branch, and then down to root-commit.
  prefs: []
  type: TYPE_NORMAL
- en: So, branches are nothing but labels that are on the tip commit, the last one.
    This commit, our leaf, must always be identified by a label so that its ancestors
    commits can be reached while browsing within a repository. Otherwise, we should
    remember for every branch of our repository the hash code of the tip commit, and
    you can imagine how easy it would be for humans.
  prefs: []
  type: TYPE_NORMAL
- en: How references work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, every time we make a commit to a branch, the **reference** that identifies
    that branch will move accordingly to always stay associated with the tip commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'But how will Git handle this feature? Let''s go back to putting the nose again
    in the `.git` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a `refs` folder: let''s take a look inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now go to `heads`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a `master` file inside! Let''s see what''s the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: As you could imagine, Git manages all this articulated reference system... with
    a trivial text file! It contains the hash of the last commit made on the branch;
    in fact, if you look at the previous `git log` output, you can see the hash of
    the last commit is `0e8b5cf`.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays it has been time since the first time, but I continue to be amazed
    by how essential and effective the internal structure of Git is.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new branch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have warmed up, the fun begins. Let''s see what happens when you
    ask Git to create a new branch. Since we are going to serve a delicious fruit
    salad, it''s time to set a branch apart for a *berries-flavored* variant recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: That's all! To create a new branch, all you need to do is call the `git branch`
    followed by the name of the branch you'd like to use. And this is super-fast;
    always working locally, Git does this kind of work in a blink of an eye.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be true, there are some (complicated) rules to be respected and things to
    know about the possible name of a branch (all you need to know is here: [https://git-scm.com/docs/git-check-ref-format](https://git-scm.com/docs/git-check-ref-format)),
    but for now it is not relevant.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, `git log` again:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Wonderful! Now Git tells us there's a new branch, `berries`, and it refers to
    the same commit as a `master` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, at the moment we continue to be located in the `master` branch; in
    fact, as you can see in the shell output prompt, it continues to appear `(master)`
    between the round parenthesis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'How can I switch branch? By using the `git checkout` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Do a `git log` to see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Mmm, interesting! Now there''s a `(berries)` sign into the shell prompt, and
    more, something happened to that `HEAD` thing: now the arrows points to `berries`,
    not more to `master`. What does it mean?'
  prefs: []
  type: TYPE_NORMAL
- en: HEAD, or you are here
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: During previous exercises we continued to see that `HEAD` thing while using
    `git log`, and now it's time to investigate a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, what is `HEAD`? As branches are, `HEAD` is a **reference**. It
    represents a pointer to the place on where we are right now, nothing more, nothing
    less. In practice instead, it is just another plain text file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The difference between the `HEAD` file and branches text file is that the `HEAD`
    file usually refers to a branch, and not directly to a commit as branches do.
    The `ref:` part is the convention Git uses internally to declare a pointer to
    another branch, while `refs/heads/berries` is of course the relative path to the
    `berries` branch text file.
  prefs: []
  type: TYPE_NORMAL
- en: So, having checked out the `berries` branch, in fact we moved that pointer from
    the `master` branch to the `berries` one; from now on, every commit we do will
    be part of the `berries` branch. Let's give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a blackberry to the shopping list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then perform a commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look on what happened with the usual `git log` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice! Something happened here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `berries` branch moved to the last commit we performed, confirming what
    we said before: a branch is just a label that follows you while doing new commits,
    getting stuck to the last one'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `HEAD` pointer moved too, following the branch it is actually pointing to,
    the `berries` one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `master` branch remains where it was, stuck to the penultimate commit, the
    last one we did before switching to the `berries` branch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, so now our `shoppingList.txt` file appears to contain these text lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: What happens if we move back to the `master` branch? Let's see.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the master branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Look at the `shoppingFile.txt` content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We actually moved back to where we were before adding the blackberry; as it
    is being added in the `berries` branch, here in the `master` branch it does not
    exist: sounds good, doesn''t it?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even the `HEAD` file has been updated accordingly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'But at this point someone could raise their hand and say: <q>"That''s weird!
    In Subversion, we usually have different folders for each different branch; here
    Git seems to always overwrite the content of the same folder, isn''t it?"</q>.'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, it is. This is how Git works. When you switch a branch, Git goes
    to the commit the branch is pointing to, and following the parent relationship
    and analyzing trees and blobs, rebuilds the content on the **working directory**
    accordingly, getting hold of that files and folders (that is the same Subversion
    can do with the *switch branch* feature, actually).
  prefs: []
  type: TYPE_NORMAL
- en: This is a big difference between Git and Subversion (and other similar versioning
    systems); people used to Subversion often argue that in this manner you cannot
    easily compare branches file by file, or open in your favorite IDE two different
    *versions* of your in-development software. Yes, this is true, in Git you cannot
    do the same, but there are some tricks to work around this issue (if it is an
    issue for you).
  prefs: []
  type: TYPE_NORMAL
- en: Another important thing to say is that in Git you cannot check out only a folder
    of the repository, as you can do in Subversion; when you check out a branch, you
    get all its content.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go back to the repository now; let''s do the usual `git log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Uh-oh: where is the `berries` branch? Don''t worry: `git log` usually displays
    only the branch you are on, and the commit that belongs to it. To see all branches,
    you only need to add the `--all` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let''s see: we are on the `master` branch, as the shell prompts and as
    `HEAD` remembers us, with that arrow that points to `master`; then there is a
    `berries` branch, with a commit more than `master`.'
  prefs: []
  type: TYPE_NORMAL
- en: Reachability and undoing commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now let''s imagine this scenario: we have a new commit on the `berries` branch,
    but we realized it is a wrong one, so we want the `berries` branch to go back
    where `master` is. We actually want to discard the last commit on the `berries`
    branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, check out the `berries` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'New trick: using the dash (`-`), you actually are saying to Git: "*Move me
    to the branch I was before switching*"; and Git obeys, moving us to the `berries`
    branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now a new command, `git reset` (please don''t care about the `--hard` option
    for now):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In Git, this is simple as this. The `git reset` actually **moves a branch from
    the current position to a new one**; here we said Git to move the current `berries`
    branch to where `master` is, and the result is that now we have all the two branches
    pointing to the same commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'You can double-check this looking at `refs` files; this is the `berries` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is the `master` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Same hash, same commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'A *side effect* of this operation is losing the last commit we did in `berries`,
    as we already said: but why? And how?'
  prefs: []
  type: TYPE_NORMAL
- en: This is due to the **reachability** of commits. A commit is not more reachable
    when no branches points to it directly, nor it figures as a parent of another
    commit in a branch. Our *blackberry commit* was the last commit on the `berries`
    branch, so moving the `berries` branch away from it, made it unreachable, and
    it *disappears* from our repository.
  prefs: []
  type: TYPE_NORMAL
- en: But are you sure it is gone? Want to make a bet?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try another trick: we can use `git reset` to move the actual branch
    directly to a commit. And to make things more interesting, let''s try to point
    the *blackberry commit* (if you scroll your shell window backwards, you can see
    its hash, which for me is `ef6c382`) so, `git reset` to the `ef6c382` commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'And then do the usual `git log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: That's magic! We actually recovered the lost commit!
  prefs: []
  type: TYPE_NORMAL
- en: Okay, jokes aside, there's no magic in Git; it simply won't delete unreachable
    commits, at least not immediately. It makes some housekeeping automatically at
    a given time, as it has some powerful **garbage collection** features (look at
    the `git gc` command help page if you are curious; I want you to remember that
    any Git command, followed by the `--help` option, will open for you the internal
    man page for it).
  prefs: []
  type: TYPE_NORMAL
- en: So, we have seen what reachability of commits means, and then learnt how to
    undo a commit using the `git reset` command, that is a thing to know to take advantage
    of Git features while working on a repository.
  prefs: []
  type: TYPE_NORMAL
- en: But let's continue experimenting with branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you want to add a watermelon to the shopping list, but later you realize
    you added it to the wrong `berries` branch; so, add `"watermelon"` to the `shoppingList.txt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Then do the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'And do a `git log` to check the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'Now our aim here is: have a new `melons` branch, which the *watermelon commit* have
    to belong to, then set the house in order and move the `berries` branch back to
    the *blackberry commit*. To keep the *watermelon commit*, first create a `melon`
    branch that points to it with the well-known `git branch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Okay, so now we have both `berries` and `melons` branches pointing to the watermelon
    commit.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can move the `berries` branch back to the previous commit; let's get
    advantage of the opportunity to learn something new.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Git, you often have the need to point to a preceding commit, like in this
    case, the one before; for this scope, we can use `HEAD` reference, followed by
    one of two different special characters, the *tilde*`~` and the *caret*`^`. A
    **caret** basically means *a back step*, while two carets means two steps back,
    and so on. As you probably don''t want to type dozens of carets, when you need
    to step back a lot, you can use **tilde**: similarly, `~1` means *a back step*,
    while `~25` means 25 steps back, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more to know about this mechanism, but it is enough for now; for all
    the details check [http://www.paulboxley.com/blog/2011/06/git-caret-and-tilde](http://www.paulboxley.com/blog/2011/06/git-caret-and-tilde).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s step back our `berries` branch using caret; do a `git reset --hard
    HEAD^`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Well done! We successfully recovered the mistake, and learnt how to use the
    `HEAD` reference and `git reset` command to move branches from here to there.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to remark concepts, let''s take a look at the `shoppingList.txt` file
    here in the `berries` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Okay, here we have blackberry, other than the other previously added fruits.
  prefs: []
  type: TYPE_NORMAL
- en: 'Switch to `master` and check again; check out the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `cat` the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Okay, no blackberry here, but only fruits added before the `berries` branch
    creation.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now a last check on the `melons` branch; check out the branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'And `cat` the `shoppingList.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Fantastic! Here there is the watermelon, other than fruits previously added
    while in the `berries` and `master` branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Quick tip: while writing the branch name, use *Tab* to autocomplete: Git will
    write the complete branch name for you.'
  prefs: []
  type: TYPE_NORMAL
- en: Detached HEAD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it's time to explore another important concept about Git and its references,
    the `detached HEAD` state.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of the explanation, go back to the `master` branch and see what
    happens when we check out the previous commit, moving `HEAD` backward; perform
    a `git checkout HEAD^`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow, a lot of new things to see here. But don''t be scared, it''s not that
    complicated: let''s take some baby steps into the long message Git showed us.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, think about it: Git is very kind and often tells us loads of useful
    information in its output messages. Don''t under evaluate this behavior: especially
    at the beginning, reading Git messages allows you to learn a lot, so read them
    carefully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, Git says we are in a `detached HEAD` state. Being in this state basically
    means that `HEAD` does not reference a branch, but directly a commit, the `e4a5e7b`
    one in this case; do a `git log` and see:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: First of all, in the shell prompt you can see that between rounds, that now
    are doubled, there is not a branch name, but the first seven characters of the
    commit, `((e4a5e7b...))`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, `HEAD` is now stuck to that commit, while branches, especially the `master`
    one, remains at their own place. As a result, the `HEAD` file now contains the
    hash of that commit, not a ref to a branch as before:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: Going on, Git says that in this state we can look around, make experiments,
    doing new commits if we like, and then discard them simply by checking out an
    existing branch, or save them if you like creating a new branch. Can you say why
    this is true?
  prefs: []
  type: TYPE_NORMAL
- en: Due to reachability of commits, of course. If we do some commits, then move
    `HEAD` to an existing branch, those commits become unreachable. They stay in a
    reachable state until `HEAD` is on top of the last of them, but when you move
    `HEAD` with a `git checkout`, they are gone. At the same time, if you create a
    new branch before moving `HEAD`, there will be a label, a pointer Git can use
    to reach those commits, so they are safe.
  prefs: []
  type: TYPE_NORMAL
- en: Want to try?
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s have some fun; modify the `shoppingList.txt` file, adding a `bug`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'Then `commit` this voluntary mistake:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s `cat` the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Ouch, we actually erased all your shopping list files!
  prefs: []
  type: TYPE_NORMAL
- en: What happened in the repository then?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Nice! We have a new commit, the bug one, and we can see as `HEAD` followed
    us, so now it points to it. Then, the console drew two different `paths`, because
    starting from `apple commit`, we traced two routes: one that goes to the `master`
    branch (then to `berries` and `melons`), and one that goes to the `bug commit`
    we just made.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so if we now check out `master` again, what happens? Give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we have already seen this message: Git is aware that we are leaving a
    commit behind; but in this case, it''s not a problem for us, indeed it''s actually
    what we really want.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'Yay! The bug commit is gone, so nothing is compromised. In the previous message,
    Git was kind enough to remind us how to recover that commit, just in case; the
    trick is to directly create a branch that points to that commit, and Git pinned
    us even the complete command. Let''s try it, creating a `bug` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: Wow, that's amazingly simple! The commit is here again, and now we have even
    a branch to check out if we like.
  prefs: []
  type: TYPE_NORMAL
- en: The reflogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Okay, but what if we ignore the Git message the first time, then time goes and
    at the end, we can't remember the hash of the commit we want to retrieve?
  prefs: []
  type: TYPE_NORMAL
- en: Git never forgets you. It has another powerful tool in its wrench box, and that
    is called the **reference log**, or reflog for short. Basically, the reflog (or
    better the reflogs, as there is one for every reference) records what happens
    in the repository while you commit, reset, check out, and so on. To be more precise,
    every reflog records all the times that tips of the branches and other references
    (such as `HEAD`) where updated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take a look at it with a convenient Git command, `git reflog show`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Actually, here there are all the movements the `HEAD` reference made in my repository
    since the beginning, in reverse order, as you may have already noticed.
  prefs: []
  type: TYPE_NORMAL
- en: 'In fact, the last one (`HEAD@{0}`) says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: Actually, this is the very last thing we did, apart from the creation on the
    `bug` branch. As we never moved into it, the `HEAD` reflog doesn't log anything
    about `bug` branch creation.
  prefs: []
  type: TYPE_NORMAL
- en: The reflog is a quite complex topic to be discussed in depth, so here we only
    learn how to open and read it, and how to interpret information from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only things I want you to know are that this log will be cleared at some
    point; the default retention is 90 days. Then, there is a reflog for every reference;
    what we are seeing now is the `HEAD` reflog (`HEAD@` is a hint about this), but
    if you type `git reflog show berries` you will see the movements `berries` branch
    did in the past:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: To go back to our problem, if we want to check out a currently unreachable commit,
    we can go to the `HEAD` reflog and look for a line where we did the commit (in
    this example, I would look for a `commit:` logline, searching the one where the
    commit message says something that helps me to remind, something like `bug` in
    this case).
  prefs: []
  type: TYPE_NORMAL
- en: Well done, that's enough for now; later we will use reflog again.
  prefs: []
  type: TYPE_NORMAL
- en: Tags are fixed labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Tags** are labels you can pin to a commit, but unlike branches, they will
    stay there.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a tag is simple: you only need the `git tag` command, followed by
    a tag name; we can create one in the tip commit of `bug` branch to give it a try;
    check out the `bug` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: 'Then use the `git tag` command followed by the funny `bugTag` name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what `git log` says:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: As you can see in the log, now on the tip of the `bug` branch there is even
    a tag named `bugTag`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you do a commit in this branch, you will see the `bugTag` will remain at
    its place; add a new line to the same old shopping list file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform a `commit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'Then look at the current situation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: That's exactly what we predict.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tags are useful to give a particular meaning to some particular commits; for
    instance, as a developer, you maybe want to tag every release of your software:
    in that case, this is all you need to know to do that job.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even tags are references, and they are stored, as branches, as simple text
    files in the tags subfolder within the `.git` folder; take a look under the `.git/refs/tags`
    folder, you will see a `bugTag` file; look at the content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: As you maybe have already predicted, it contains the hash of the commit it refers
    to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To delete a tag, you have to simply append the `-d` option: `git tag -d <tag
    name>`.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can't move a tag, if you need to move it you have to delete the previous
    tag and then create a new one with the same name that points to the commit you
    want; you can create a tag that points a commit wherever you want, appending the
    hash of the commit as an argument, for example, `git tag myTag 07b1858`.
  prefs: []
  type: TYPE_NORMAL
- en: Annotated tags
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Git has two kinds of tags; this is because in some situations you may want to
    add a message to the tag, or because you like to have the author stick to it.
  prefs: []
  type: TYPE_NORMAL
- en: We already have seen the first type, the simpler one; tags containing this extra
    information load belong to the second type, the **annotated tag**.
  prefs: []
  type: TYPE_NORMAL
- en: An annotated tag is both a *reference* and a *git object* such as commits, trees,
    and blobs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create one, simply append `-a` to the command; let''s create another one
    to give this a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point Git opens the default editor, to allow you to write the tag message,
    as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efb244ea-c2fa-48f6-acda-7d0dd2fba54f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Save and exit, and then see the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: Okay, there are two tags now on the same commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'A new ref has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'But even a new object: try to `cat-file` the hash you see in the reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: This is how an annotated tag looks like.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, the `git tag` command has many other options, but I only highlighted
    the ones I think are worth knowing at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to look at all the options of a command, remember you can always
    do a `git <command> --help` to see the complete guide.
  prefs: []
  type: TYPE_NORMAL
- en: Time to spend some words on the staging area, as we have only scratched the
    surface.
  prefs: []
  type: TYPE_NORMAL
- en: Staging area, working tree, and HEAD commit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have barely named the **staging area** (also known as an **index**),
    while preparing files to make a new commit with the `git add` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the staging area purpose is actually this. When you change the content
    of a file, when you add a new one or delete an existing one, you have to tell
    Git what of these modifications will be part of the next commit: the staging area
    is the container for this kind of data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus on this right now; move to the `master` branch, if not already
    there, then type the `git status` command; it allows us to see the actual status
    of the staging area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: Git says there's nothing to commit, our working tree is clean. But what's a
    **working tree**? Is it the same as the working directory we talked about? Well,
    yes and no, and it's confusing, I know.
  prefs: []
  type: TYPE_NORMAL
- en: Git had (and still have) some troubles with names; in fact, as we said a couple
    of lines before, even for the staging area we have two names (the other one is
    index). Git uses both in its messages and commands output, and the same often
    does people, blogs, and books like this one while talking about Git. Having two
    names for the same thing is not always a good idea, especially when they represent
    exactly the same thing, but being aware of this is enough (time will give us a
    less confusing Git, I'm sure).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the working tree and working directory, the story is this. At some point,
    someone argued: *If I''m in the root of the repository I''m in a working directory,
    but if I walk through a subfolder, I''m in another working directory*. This is
    technically true by a filesystem perspective, but while in Git, doing some operations
    such as checkout or reset does not affect the current working directory, but the
    entire... working tree. So, to avoid confusion, Git stopped talking about working
    directory in its messages and "renamed" it as working tree. This is the commit
    on Git repository that made this change: [https://github.com/git/git/commit/2a0e6cdedab306eccbd297c051035c13d0266343](https://github.com/git/git/commit/2a0e6cdedab306eccbd297c051035c13d0266343),
    if you want to go in deep. Hope I''ve clarified a little bit.'
  prefs: []
  type: TYPE_NORMAL
- en: Back on topic now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `peach` to the `shoppingList.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: 'Then make use of this new learnt command again, `git status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now it's time to learn about **staged** changes; with the word `staged`,
    Git means modifications we already added to the staging area, so they will be
    part of the next commit. In the current situation, we modified the `shoppingList.txt`
    file, but we have not added it yet to the staging area (using the good old `git
    add` command).
  prefs: []
  type: TYPE_NORMAL
- en: 'So, Git informs us: it tells that there is a modified file (in red color),
    and then offers two possibilities: *stage* it (add it to the staging area), or
    *discard* the modification, using the `git checkout -- <file> command`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's try to add it; we will see the second option later.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, try a `git add` command, with nothing more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, new thing learnt: `git add` wants you to specify something to add. A
    common thing is to use the dot `.` as a wildcard, and this by default means, *add
    all the files in this folder and subfolders to the staging area*. This is the
    same as `git add -A` (or `--all`), and by "all" I mean:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Files in this folder and sub-folders I added in the past at least one time**:
    This set of files is also known as the **tracked files**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**New files**: These are called **untracked files**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files marked for deletion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Be aware that this behavior changed over time: before Git 2.x, `git add .`
    and `git add -A` had different effects. Here is a table for quickly understanding
    the differences.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Git version 1.x:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **New files** | **Modified files** | **Deleted files** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `git add -A` | yes | yes | yes | Stage all (new, modified, deleted) files
    |'
  prefs: []
  type: TYPE_TB
- en: '| `git add .` | yes | yes | no | Stage new and modified files only |'
  prefs: []
  type: TYPE_TB
- en: '| `git add -u` | no | yes | yes | Stage modified and deleted files only |'
  prefs: []
  type: TYPE_TB
- en: 'Git version 2.x:'
  prefs: []
  type: TYPE_NORMAL
- en: '|  | **New files** | **Modified files** | **Deleted files** |  |'
  prefs: []
  type: TYPE_TB
- en: '| `git add -A` | yes | yes | yes | Stage all (new, modified, deleted) files
    |'
  prefs: []
  type: TYPE_TB
- en: '| `git add .` | yes | yes | **yes** | Stage all (new, modified, deleted) files
    |'
  prefs: []
  type: TYPE_TB
- en: '| `git add --ignore-removal .` | **yes** | **yes** | **no** | Stage new and
    modified files only |'
  prefs: []
  type: TYPE_TB
- en: '| `git add -u` | no | yes | yes | Stage modified and deleted files only |'
  prefs: []
  type: TYPE_TB
- en: As you can see, in Git 2.x there's a new way to stage new and modified files
    only, the `git add --ignore-removal .` way, and then `git add .` became the same
    as `git add -A`. If you are wondering, the `-u` option is the equivalent of `--update`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another basic usage is to specify the file we want to add; let''s give it a
    try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, when `git add` goes right, Git says nothing, no messages: let''s
    consider it a tacit approval.'
  prefs: []
  type: TYPE_NORMAL
- en: Other ways to add files is specifying a directory to add all the changed files
    within it, using wildcards such as the star `*` with or without something else
    (for example, `*.txt` for adding all `txt` files, `foo*` for adding all files
    starting with `foo` and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Please refer to [https://git-scm.com/docs/git-add#git-add-ltpathspecgt82308203](https://git-scm.com/docs/git-add#git-add-ltpathspecgt82308203)
    for all the information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, time to look back at our repository; go with a `git status` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: Nice! Our file has been added to the staging area, and now it is one of the
    changes that will be part of the next commit, the only one actually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at what Git says then: if you want to `unstage` the change,
    you can use the `git reset HEAD` command: what does it mean? **Unstage** is a
    word to say *remove a change from the staging area*, for example, because we realized
    we want to add that change not in the next commit, but later.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, leave things how they are, and do a `commit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: Okay, now we have a new `commit` and our working tree is clean again; yes, because
    the effect of `git commit` is to create a new commit with the content of the staging
    area, and then empty it.
  prefs: []
  type: TYPE_NORMAL
- en: Now we can make some experiments and see how to deal with the staging area and
    working tree, undoing changes when in need.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, follow me and make things more interesting; add an onion to the shopping
    list and then add it to the staging area, and then add a garlic and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: Okay, good! We are in a very interesting state now. Our `shoppingList.txt` file
    has been modified two times, and only the first modification has been added to
    the staging area. This means that at this point if we would commit the file, only
    the `onion` modification would be part of the commit, but not the `garlic` one.
    This is a thing to underline, as in other versioning systems it is not so simple
    to do this kind of work.
  prefs: []
  type: TYPE_NORMAL
- en: 'To highlight the modification we did, and take a brief look, we can use the
    `git diff` command; for example, if you want to see the difference between the
    working tree version and the staging area one, try to input only the `git diff`
    command without any option or argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Git highlights the fact that in the working tree we have a `garlic`
    more than the staging area version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last part of the output of the `git diff` command is not difficult to understand:
    green lines starting with a plus `+` symbol are new lines added (there would be
    red lines starting with a minus `-` for deleted lines). A modified line will be
    usually highlighted by Git with a minus red deleted line and a plus green added
    line; to be `true`, Git can be instructed to use different `diff` algorithms,
    but this is out of the scope of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: Other than this, the first part of the `git diff` output is a little bit too
    difficult to explain in a few words; please refer to [https://git-scm.com/docs/git-diff](https://git-scm.com/docs/git-diff)
    for all the details.
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want to see the differences between the last committed version
    of the `shoppingList.txt` file and the one added into the staging area?
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to use the `git diff --cached HEAD` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to dissect this command to better understand what''s the purpose; appending
    the `HEAD` argument, we are asking to use the last commit we did as a subject
    of the compare. To be `true`, in this case, the `HEAD` reference is optional,
    as it is the default: `git diff --cached` would return the same result.'
  prefs: []
  type: TYPE_NORMAL
- en: Instead, the `--cached` option says, *compare the argument (HEAD in this case)
    with the version in the staging area*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, dear friends: the staging area, also known as an `index`, sometimes is
    called `cache`, hence the `--cached` option.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The last experiment that we can do is compare the `HEAD` version with the working
    tree one; let''s do it with a `git diff HEAD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Okay, it works as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to take a break from the console and spend a couple of words to
    talk about these three `locations` we compared.
  prefs: []
  type: TYPE_NORMAL
- en: The three areas of Git
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In Git, we work at three different levels:'
  prefs: []
  type: TYPE_NORMAL
- en: The **working tree** (or working directory)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **staging area** (or index, or cache)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **HEAD ****commit** (or the last commit or tip commit on the current branch)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we modify a file, we are doing it at working tree level; when we do a
    `git add`, we are actually copying the changes from the working tree to the staging
    area. At the end, when we do a `git commit`, we finally move the changes from
    the staging area to a brand new commit, referenced by `HEAD`, which will become
    part of our repository history: this is what I mean with the HEAD commit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure draws those three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/41b68d6e-bdb8-4894-9a6f-81baafcd030e.png)'
  prefs: []
  type: TYPE_IMG
- en: We can move changes between these areas forward, from the working tree to the
    `HEAD` commit, but we can even go backward, undoing changes if we like.
  prefs: []
  type: TYPE_NORMAL
- en: We already know how to go forward using `git add` then `git commit`; let's take
    a look at the commands to go backward.
  prefs: []
  type: TYPE_NORMAL
- en: Removing changes from the staging area
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It happens that you add changes to the staging area, then you realize they fit
    better in a future commit, not in the commit you are composing right now.
  prefs: []
  type: TYPE_NORMAL
- en: To remove those changes to one or more files from the staging area, you can
    use the `git reset HEAD <file>` command; get back the shell and follow me.
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the repository current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: This is the actual situation, remember? We have an `onion` in the staging area
    and a `garlic` more in the working tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go with a `git reset HEAD`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, Git confirms we unstaged changes. The `M` on the left side means `Modified`;
    here Git is telling us we have unstaged a modification to a file. If you create
    a new file and you add it to the staging area, Git knows this is a new file; if
    you try to unstage it, Git would put an `A` for `Added` in the left, to remember
    that you just unstaged the addition of a new file. Same if you unstage the deletion
    of an existing file: on the left would appear a `D` for `Deleted`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, time to verify what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: Okay, by using `git status` we see that now the staging area is empty, there's
    nothing staged. We only have some unstaged modification, but what modification?
    Did the `git reset HEAD` actually delete the onion?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s verify this using the `git diff` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: No, fortunately! The `git reset HEAD` command won't destroy your modification;
    it only moves away them from the staging area, so they will not be part of the
    next commit.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure shows a quick summary of `git diff` different behaviors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0e8a66c7-9317-47fb-8777-0206751c5d8c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now imagine that we completely messed up: the modification we did to the `shoppingList.txt`
    file is wrong (in fact they are, no tasty fruit salad with onion and garlic),
    so we need to undo them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The command for that is `git checkout -- <file>`, as Git gently reminds in
    `the git status` output message. Give it a try:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the content of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! We actually removed onion and garlic from the shopping list file.
    But be aware: we lost them! As those modifications were only in the working tree,
    there''s no way to reclaim them, so be careful: `git checkout --` is a `destructive`
    command, use it carefully.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than this, we need to remember that `git checkout` overwrites even the
    staging area; as per the preceding figure, working tree and `HEAD` commit are
    in direct relationship: changes always go through the staging area. Later we will
    grasp this concept better while delving into `git reset` options.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point you maybe have noticed here we used `git reset` and `git checkout`
    commands in a different way than we did in the preceding sections, and this is
    true.
  prefs: []
  type: TYPE_NORMAL
- en: At the beginning, this can be a little confusing for the newcomers, because
    mentally you cannot associate a single command to a single operation as it can
    be used to do more than one. For example, you cannot say, *git checkout is for
    branch switching* (or for commit inspection, going to a detaching `HEAD` state),
    as it can be used even to discard changes in a working tree, as we just did.
  prefs: []
  type: TYPE_NORMAL
- en: The trick you can use to differentiate the two variations for these commands
    is to take into account that double-dash `--` notation. So, you can remember *git
    checkout is for switching branches* and *git checkout -- is for discarding local
    changes*.
  prefs: []
  type: TYPE_NORMAL
- en: This is `true` even for the `git reset` command; in fact, do a `git reset --
    <file>` is actually the same as doing a `git reset HEAD <file>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be true, the double-dash `--` notation is not mandatory; if you do a `git
    checkout <file>` or `git reset <file>` without `--`, in 99% of cases Git does
    what you expect. The double-dash is needed when, due to a coincidence, there is
    a file and a branch with the same name: in that case, Git has to know if you want
    to deal with branches, for example switching to another one with `git checkout`,
    or if you want to manage files. In this situation, the double-dash is the way
    to tell Git *I want to handle files, not branches*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure summarizes the commands to move changes between those
    three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7aa9ce86-1772-40a9-97c2-f5ea48dd5f4e.png)'
  prefs: []
  type: TYPE_IMG
- en: Now it's time to complete our cultural baggage about file status lifecycle within
    a repository.
  prefs: []
  type: TYPE_NORMAL
- en: File status lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a Git repository, files pass through some different states. When you first
    create a file in the working tree, Git notices it and tells you there''s a new
    untracked file; let''s try to create a new `file.txt` in our `grocery` repository
    and see the output of `git status`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, Git explicitly says that there's an **untracked** file; an untracked
    file is basically a new file Git has never seen before.
  prefs: []
  type: TYPE_NORMAL
- en: When you add it, it becomes a **tracked** file.
  prefs: []
  type: TYPE_NORMAL
- en: If you commit the file, then it goes in an **unmodified** state; this means
    Git knows it, and the current version of the file in the working tree is the same
    as the one in the `HEAD` commit.
  prefs: []
  type: TYPE_NORMAL
- en: If you make some changes, the file goes to a **modified** state.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a modified file to the staging area makes it a **staged** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure summarizes these states:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/765544f9-0219-4db1-ad35-15a0ffdcc754.png)'
  prefs: []
  type: TYPE_IMG
- en: Knowing this terminology is important to better understand Git messages, and
    it helps me and you to go smoothly while talking about files in a Git repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to go a little bit deep with `git reset` and `git checkout` commands.
  prefs: []
  type: TYPE_NORMAL
- en: All you need to know about checkout and reset
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First of all, we need to do some housekeeping. Go back to the `grocery` repository
    and clean up the working tree; double-check that you are in the `master` branch,
    and then do a `git reset --hard master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: This allows us to discard all the latest changes and go back to the latest commit
    on `master`, cleaning up even the staging area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, delete the `bug` branch we created some time ago; the command to delete
    a branch is again the `git branch` command, this time followed by a `-d` option
    and then the branch name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, Git has an objection. It says the branch is not fully merged, in other
    words, *if you delete it, the commit within it will be lost*. No problem, we don''t
    need that commit; so, use the capital `-D` option to force the deletion:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now we are done, and the repository is in good shape, as the `git log`
    command shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: Git checkout overwrites all the tree areas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now switch to the `melons` branch using the `git checkout` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: Okay, what happened?
  prefs: []
  type: TYPE_NORMAL
- en: Git took the tip commit in the `melons` branch, analyzed it, and then rebuilt
    the snapshot the commit represents into our working tree. It basically copied
    all those files and folders into the staging area and then into the working tree.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `git checkout` can destroy changes in your working tree; in fact,
    if you have some local modification Git will block you.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try it; add a `potato` to the shopping list file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: 'Then checkout `master`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, you cannot switch branch if you are not in a clean state.
  prefs: []
  type: TYPE_NORMAL
- en: Now please remove the potato from the shopping list file, by an editor or by
    Git (I leave this to you as an exercise).
  prefs: []
  type: TYPE_NORMAL
- en: Git reset can be hard, soft, or mixed
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Finally, you will see what `git reset --hard` means, and what are the other
    reset options that we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid messing up our repo again, go into a detached `HEAD` state, so at
    the end it will be easier to throw all the things away. To do this, checkout directly
    the penultimate commit on the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, this is the content of the `shoppingList.txt` file in this commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'Now just replicate the `onion` and `garlic` situation we used before: append
    an `onion` to the file and add it to the staging area, and then add a `garlic`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: 'Now use the `git diff` command to be sure we are in the situation we desire;
    check the differences with the staging area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the differences between the working tree and `HEAD` commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: Okay, we have a `HEAD` commit with only fruits, and then a staging area with
    an onion more and working tree with a garlic more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now try to do a **soft reset** to the `master` branch, with the `git reset
    --soft master` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: 'Diff to the staging area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: 'What did Git do? It basically moved the `HEAD` reference to the last commit
    in the `master` branch, the `603b9d1`. Small break: note as when in detached `HEAD`
    state, even if you reset to a commit with a branch label, Git continues to reference
    directly the commit, not the branch.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, having done this, now the differences between the `HEAD` commit and staging
    area are those we see in the output: the peach that was part of the `shoppingList.txt`
    file in the `HEAD` commit is not part of the currently staged `shoppingList.txt`
    file, so Git marks a `peach` text line in red with a preceding minus, to tell
    you *actually this line has been deleted*, while the `onion` one has been added.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The same is if you compare the `HEAD` commit with a working tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: In this case, Git even notes that two new lines have been added, `onion` and
    `garlic`.
  prefs: []
  type: TYPE_NORMAL
- en: This soft-reset technique can help you quickly compare changes between two commits,
    as it only overwrites the `HEAD` commit area.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is the **mixed reset**; you can do it using the `--mixed` option
    (or simply using no options, as this is the default):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, there''s something different here: Git tells us about unstaged changes.
    In fact, the `--mixed` option makes Git overwrite even the staging area, not only
    the `HEAD` commit. If you check differences between the `HEAD` commit and staging
    area with `git diff`, you will see that there are no differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead, differences arise between the `HEAD` commit and working tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: This mixed-reset technique can be useful, for example, to clean up all the staged
    changes in one shot, with a simple `git reset HEAD`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, you can presume what is the purpose of the `--hard` option:
    it overwrites all the three areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: In fact, now there are no differences at any level.
  prefs: []
  type: TYPE_NORMAL
- en: This hard-reset technique is used to completely discard all the changes we did,
    with a `git reset --hard HEAD` command, as we did in our previous experiments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done. Now we know a little more about both the `git checkout` and `git
    reset` command; but before leaving, go back in a non-detached `HEAD` state, checking
    out the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: Rebasing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now I want to tell you something about the `git rebase` command; a **rebase**
    is a common term while using a versioning system, and even in Git this is a hot
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Basically, with `git rebase` you **rewrite history**; with this statement,
    I mean you can use rebase command to achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Combine two or more commits into a new one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discard a previous commit you did
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Change the starting point of a branch, split it, and much more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reassembling commits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the widest uses of the `git rebase` command is for reordering or combining
    commits. For this first approach, imagine you have to combine two different commits.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose we erroneously added half a grape in the `shoppingList.txt` file, then
    the other half, but at the end we want to have only one commit for the entire
    grape; follow me with these steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a `gr` to the shopping list file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: The `-n` option is for not adding a new line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cat the file to be sure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: 'Now perform the first commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, we have a commit with half a grape. Go on and add the other half, `ape`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: 'Perform the second commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: 'Well, this is inconvenient: I''d like to have only a commit with the entire
    `grape`.'
  prefs: []
  type: TYPE_NORMAL
- en: We can repair the mistake with an **interactive rebase**. To do this, we have
    to rebase the last two commits, creating a new one that is, in fact, the sum of
    the two.
  prefs: []
  type: TYPE_NORMAL
- en: So, type `git rebase -i HEAD~2` and see what happen; `-i` means *interactive*,
    while the `HEAD~2` argument means *I want to rebase the last two commits*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a screenshot of the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6c3b58b3-d761-44d9-a2c6-06def3d85f88.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the preceding screenshot, Git opens the default editor, Vim.
    Then it tells us how to edit this temporary file (you can see the location at
    the bottom of the screenshot) using some commented lines (those starting with
    `#`).
  prefs: []
  type: TYPE_NORMAL
- en: Let's read this message carefully.
  prefs: []
  type: TYPE_NORMAL
- en: Here we can reorder the commit lines; doing only this, we basically change the
    order of commits in our repository. Maybe this can seem a not-so-useful feature,
    but it can be so if you plan to create new branches after this rebase and you
    want to clear the ground before.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then you can delete lines: if you delete a line, basically you drop the corresponding
    commit.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, for every line (every commit), you can use one of the following commands,
    as per the comments showed in the Vi editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**# p, pick = use commit**: If you pick a commit, the commit will continue
    to be part of your repo. Think at it as, *Okay, I want to preserve this commit
    as is*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# r, reword = use commit, but edit the commit message**: Reword allows you
    to change the commit message, useful if you realized you wrote something wrong
    in it. It''s kind of, *Okay, I want to preserve this commit, but I want to change
    the message*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# e, edit = use commit, but stop for amending**: When you amend a commit
    you basically want to reassemble it. For example, you forgot to include a file
    in it, or you added one too many. If you mark a commit to be edited, Git will
    stop the subsequent rebase operations to let you do what you need. So, the commit
    will be preserved, but it will be altered.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# s, squash = use commit, but meld into previous commit**: Squash is a term
    we will see again; it basically means put together two commits or more. In this
    case, if you squash a commit, it will be removed, but the changes within it will
    be part of the preceding commit. This is maybe the command we need?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# f, fixup = like "squash", but discard this commit''s log message**: Fixup
    is like squash, but let''s provide you with a new commit message. This is definitely
    what I need; as I want the new `grape` commit to have a new message.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# x, exec = run command (the rest of the line) using shell**: Exec is, well,
    advanced stuff. You basically tell Git to run a particular command when it will
    manipulate this commit during the following rebase actions. This can be useful
    to do something you forgot between two commits, rerun some tests, or whatever.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**# d, drop = remove commit**: Drop simply removes the commit, the same as
    deleting the entire line.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Okay, now we can proceed. We have to modify this file using those commands,
    and then save it and exit: Git will then continue the rebase process executing
    every command in order, from top to bottom.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To resolve our issue, I will *reword* the first commit and then *fixup* the
    second; the following is a screenshot of my console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/17444bdb-82fd-422e-b472-548ee5187224.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that you can use the long format of the command or the short one (for example,
    `f ->` short, fixup `->` long).
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now Git does the work and then opens a new temporary file to allow us
    to write the new message for the commit we decided to reword, that is, the first
    one. The following is the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a0dd0337-87a3-4c40-a7dd-7186152eead4.png)'
  prefs: []
  type: TYPE_IMG
- en: Note as Git tell us word for word what it is going to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now edit the message, and then save and exit, like in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aabe28e4-58ff-4834-b2c7-9aef6c1ae508.png)'
  prefs: []
  type: TYPE_IMG
- en: Press `ENTER` and we're done.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the final message from Git:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: 'Take a look at the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: Wonderful! We just accomplished our mission.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's make a little experiment on rebasing branches.
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the `git rebase` command you can also modify the story of branches; one
    of the things you do more often inside a repository is to change - or better to
    say - move the point where a branch started, bringing it to another point of the
    tree. This operation makes it possible to keep low the level of ramifications
    that would instead be generated using the command `git merge`, which we will see
    later.
  prefs: []
  type: TYPE_NORMAL
- en: In order to better understand this, let me give you an example.
  prefs: []
  type: TYPE_NORMAL
- en: Let's imagine that to the commit where the orange was added, a branch `nuts`
    was created in the past, to which a walnut was added.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, let's imagine that we want to move this branch above, to the
    point where it is now `master` as if this branch had been created starting from
    there and not from the orange commit.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how this can be achieved using the `git rebase` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new branch that points to commit `0e8b5cf`, the
    orange one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: 'This time I used the `git branch` command followed by two arguments, the name
    of the branch and the commit where to stick the label. As a result, a new `nuts`
    branch has been created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: 'Move `HEAD` to the new branch with the `git checkout` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now it''s time to add a `walnut`; add it to the `shoppingList.txt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: 'Then do the commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Check the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the graph is now a little bit more complicated; starting from
    the `orange` commit, there are three branches: the `berries`, the `master`, and
    the `nuts` ones.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we want to move the `nuts` branch starting point, form an orange commit
    to a `grape` commit, as if the `nuts` branch is just one commit next to the `master`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do it, rebasing the `nuts` branch on top of `master`; double-check that
    you actually are in the `nuts` branch, as a rebase command basically rebases the
    current branch (`nuts`) to the target one, `master`; so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, don''t be scared: the rebase failed, but that''s not a problem. In fact,
    it failed because Git cannot merge differences between `shoppingList.txt` file
    versions automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Read the message: Now you have three choices:'
  prefs: []
  type: TYPE_NORMAL
- en: Fix the merge conflicts and then continue, with `git rebase -continue.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Skip this step, and discard the modification using `git rebase -skip.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abort the rebase, using `git rebase -abort.`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will choose the first option, but I want to tell you something about the
    second and third ones.
  prefs: []
  type: TYPE_NORMAL
- en: While rebasing, Git internally creates patches and applies them to the commits
    we are moving; in fact, while rebasing a branch you actually move all its commits
    on top of another commit of choice, in this case the last commit on the `master`
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, the `nuts` branch has only one commit, so Git compared the destination
    commit (the grape commit on `master`) with a walnut commit on the `nuts` branch.
    At the end, only one comparing and patching step will be necessary (this is the
    meaning of the `REBASE 1/1` message on the console: you are rebasing commit 1
    of 1 total commits to rebase).'
  prefs: []
  type: TYPE_NORMAL
- en: 'That being said, you can now understand what `git rebase --skip` means: if
    you find the current patching step not useful nor necessary, you can skip it and
    move on to the next one.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, with `git rebase --abort` you simply stop the current rebase operation,
    backing to the previous pre-rebase situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back to our repository; if you open the file with Vim, you can see the
    generated conflict:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '![](img/cf8277b3-82eb-4c16-9171-ad489b64c34a.png)'
  prefs: []
  type: TYPE_IMG
- en: Walnut has been added at line 4, but in the `master` branch, that line is occupied
    by the peach, and then there's a `grape`.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will fix it adding the `walnut` at the end of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/95de9c5a-c0be-45a1-8320-365519b5ac09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, the next step is to `git add` the `shoppingList.txt` file to the staging
    area, and then go on with the `git rebase --continue` command, as the previous
    message suggested:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, after the `git rebase --continue` command, the rebase ends successfully
    (no errors and no more `REBASE` message in shell prompt at step `[11]`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the repo using `git log` as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: Well done! The `nuts` branch is now just a commit beyond the `master` one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now to keep the simplest and most compact repository, we cancel the `walnut`
    commit and put everything back in place as it was before this little experiment,
    even removing the `nuts` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: Well done.
  prefs: []
  type: TYPE_NORMAL
- en: Rebasing is a wide and fairly complex topic; we would need another entire chapter
    (or book) to tell everything about it, but this is basically what we need to know
    about rewriting history.
  prefs: []
  type: TYPE_NORMAL
- en: Merging branches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Yes, I know, probably there''s a thought on your mind since we start playing
    with branches: *why he doesn''t talk about merging?*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now the moment has arrived.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Git, merging two (or more!) branches is the act of making their personal
    history meet each other. When they meet, two things can happen:'
  prefs: []
  type: TYPE_NORMAL
- en: Files in their tip commit are different, so some conflict will rise
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Files do not conflict
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Commits of the target branch are directly behind commits of the branch we are
    merging, so a fast-forward will happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the first two cases, Git will guide us assembling a new commit, a so-called
    **merge commit**; in the fast-forward case instead, no new commit is needed: Git
    will simply move the target branch label to the tip commit of the branch we are
    merging.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's give it a try.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can try to merge the `melons` branch into the `master` one; to do so, you
    have to check out the target branch, `master` in this case, and then fire a `git
    merge <branch name>` command; as I''m already on the `master` branch, I go straight
    with the `merge` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: Uh-oh, conflicts here. Git always tries to auto-merge a file (it uses complex
    algorithms to reduce your manual work on files), but if you're in doubt, pretend
    you fix the issues by hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'See the conflict with `git diff`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, it''s clear that the fourth and fifth line of our `shoppingList.txt`
    diverged in the two branches: in `master`, they are occupied respectively by `peach`
    and `grape`, in the `melons` branch the place is taken by `blackberry` and `watermelon`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the shell prompt: it has that `MERGING` word after the branch name to
    remind us that we are in the middle of a merge. Instead, don''t mind the `- grape
    ++grape` part: it is a due line ending mismatch between my Windows computer and
    the GNU/Linux Git subsystem.'
  prefs: []
  type: TYPE_NORMAL
- en: To resolve the merge, you have to edit the file accordingly, and then add and
    commit it; let's go.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will edit the file enqueuing `blackberry` and `watermelon` after `peach`
    and `grape`, as per the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/86e857bb-9653-4a83-a1a2-cd60e09c73f1.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After saving the file, add it to the staging area and then commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: The commit is done, and the merge is finished. Perfect!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now take a look at the log:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: Wow, that's cool!
  prefs: []
  type: TYPE_NORMAL
- en: 'Look at the green path, the one on the right: this is now the new history of
    the `master` branch. It starts from the beginning, the banana commit, goes to
    `apple`, `orange`, and then to `peach`, `grape`, `blackberry`, and the `watermelon`
    commit.'
  prefs: []
  type: TYPE_NORMAL
- en: The tip commit on the `master` branch is the merge commit, the result of the
    merge. Can you tell how Git is able to draw this graph?
  prefs: []
  type: TYPE_NORMAL
- en: 'Suggestion: look at the merge commit with `git cat-file -p`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: A-ha! This commit has **two parents**! In fact, this is the result of the merge
    of two previous commits, and this is how Git handles merges. Storing the two parents
    inside the commit, Git can keep track of the merge, and use the information to
    draw the graph and let you remember, even after years, when and how you merged
    two branches.
  prefs: []
  type: TYPE_NORMAL
- en: Fast forwarding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A merge not always generates a new commit; to test this case, try to merge
    the `melons` branch into a `berries` one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: 'As `melons` contained only a commit more than the `berries` branch, and as
    it changes between the two are not in conflict, doing a merge here is just a matter
    of a second: Git only needs to move the `berries` label to the same tip commit
    of the `melons` branch.'
  prefs: []
  type: TYPE_NORMAL
- en: This is called **fast-forwarding**.
  prefs: []
  type: TYPE_NORMAL
- en: This time there's no merge commit, as it is not necessary; someone will argue
    that in this manner you lose the information that tells you when two branches
    have been merged. If you want to force Git always create a new merge commit, you
    can use the `--no-ff` (no fast-forward) option.
  prefs: []
  type: TYPE_NORMAL
- en: Wanna try? Okay, good chance to make another exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Move back the `berries` branch where it was using `git reset`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: We have just undone a merge, did you realize it?
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, now do the merge again with the `--no-ff` option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: 'Git will now open your default editor to allow you to specify a commit message,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc6314d3-748b-4263-a060-aeae22a7dfb4.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when Git can automatically merge the changes, it does; it then
    asks you for a commit message, suggesting a default one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Accept the default message, save and exit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: Merge done.
  prefs: []
  type: TYPE_NORMAL
- en: Git tells us what merging strategy is adopted for the automatic merge, and then
    what changed in terms of files and changes to them (insertions or deletions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now a `git log`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now the graph highlights the merge between the two branches. As you can
    see, the graph is a little bit more complicated now, and this is why doing a fast-forward
    merge is normally preferable: it ends with a more compact and simple repository
    structure.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are done with these experiments; anyway, I want to undo this merge, because
    I want to keep the repository as simple as possible to allow you to better understand
    the exercise we do together; go with a `git reset --hard HEAD^`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, now undo even the past merge we did on the `master` branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: 'I''m sure you get the point now: undoing a merge in Git is easy. I wanted to
    show you this more and more because sometimes merging branches is scaring; after
    doing it, sometimes you realize you messed up your project, and you go out of
    mind. Instead, don''t worry about it: recovering from this situation is simple.'
  prefs: []
  type: TYPE_NORMAL
- en: Cherry picking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes you don''t want to merge two branches, but simply your desire is
    to apply the same changes in a commit on top to another branch. This situation
    is very common when working on bugs: you fix a bug in a branch, and then you want
    to apply the same fix on top of another branch.'
  prefs: []
  type: TYPE_NORMAL
- en: Git has a convenient way to do it; this is the `git cherry-pick` command.
  prefs: []
  type: TYPE_NORMAL
- en: Let's play with it a little bit.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assume you want to pick the `blackberry` from the `berries` branch, and then
    apply it into the `master` branch; this is the way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: For the argument, you usually specify the hash of the commit you want to pick;
    in this case, as that commit is referenced even by the `berries` branch label,
    doing a `git cherry-pick berries` would have been the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, the cherry pick raised a conflict, of course:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: 'The fourth line of both the `shoppingList.txt` file versions has been modified
    with different fruits. Resolve the conflict and then add a commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a screenshot of my Vim console, and the files are arranged
    as I like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/47c3e1ba-8bf7-48b9-a0f3-fa5842f76cc3.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: 'Note the `git status` output: you always have some suggestions; in this case,
    to abort a `cherry-pick` and undo all you did, you can do a `git cherry-pick --abort`
    (you can do the same even while rebasing or merging).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now go on and commit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: Okay, as you can see a new commit appeared, but there are no new paths in the
    graph. Unlike the merging feature, with cherry-picking you only pick changes made
    inside the specified commit, and no relationship will be stored between the cherry-picked
    commit and the new one created.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to track what was the commit you cherry-picked, you can append
    the `-x` option to the `git cherry-pick` command; then, while committing, don''t
    append the message in the `git commit` command using the `-m` option, but type
    `git commit` and then press `ENTER` to allow Git to open the editor: it will suggest
    you a message that contains the hash of the cherry-picked commit, as you can see
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebae889b-b086-45c0-9a24-bd918685c9bd.png)'
  prefs: []
  type: TYPE_IMG
- en: This is the only way to track a cherry pick, if you want.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This has been a very long chapter, I know.
  prefs: []
  type: TYPE_NORMAL
- en: But now I think you know all you need to work proficiently with Git, at least
    in your own local repository. You know about working tree, staging area, and `HEAD`
    commit; you know about references as branches and `HEAD`; you know how to merge
    rebase, and cherry pick; and finally, you know how Git works under the hood, and
    this will help you from here on out.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to deal with **remotes**, and pushing
    and pulling changes from a server such as GitHub.
  prefs: []
  type: TYPE_NORMAL
