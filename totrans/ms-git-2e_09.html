<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-158"><a id="_idTextAnchor172" class="pcalibre1 pcalibre calibre6"/>7</h1>
<h1 id="_idParaDest-159" class="calibre5"><a id="_idTextAnchor173" class="pcalibre1 pcalibre calibre6"/>Publishing Your Changes</h1>
<p class="calibre3"><a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em> (the previous chapter), taught you how to use Git to work together as a team, focusing on repository-to-repository interaction. It described different ways of setting up repositories for collaboration, presenting different collaborative workflows, such as centralized and integration manager workflows. It also showed how Git manages information about remote repositories.</p>
<p class="calibre3">In this chapter, you will find out how you can exchange information between your local repository and remote repositories, and how Git can manage credentials that might be needed to access remote repositories.</p>
<p class="calibre3">This chapter will also teach you how to provide your changes upstream, so that they appear in the official history of the project, in its canonical repository. This can be done by pushing your changes to a central repository, pushing them to your own publishing repository and sending some kind of a pull request to the integration manager, or even exchanging patches.</p>
<p class="calibre3">This chapter will cover the following topics:</p>
<ul class="calibre16">
<li class="calibre15">Transport protocols used by Git and their advantages and disadvantages</li>
<li class="calibre15">Managing credentials (passwords, keys) for remote repositories</li>
<li class="calibre15">Publishing changes: push and pull requests, and exchanging patches</li>
<li class="calibre15">Using bundles for offline transfer and speeding up the initial clone</li>
<li class="calibre15">Remote transport helpers and their use</li>
</ul>
<h1 id="_idParaDest-160" class="calibre5"><a id="_idTextAnchor174" class="pcalibre1 pcalibre calibre6"/><a id="_idTextAnchor175" class="pcalibre1 pcalibre calibre6"/><a id="_idTextAnchor176" class="pcalibre1 pcalibre calibre6"/><a id="_idTextAnchor177" class="pcalibre1 pcalibre calibre6"/><a id="_idTextAnchor178" class="pcalibre1 pcalibre calibre6"/>Transport protocols and remote helpers</h1>
<p class="calibre3">In general, URLs in the<a id="_idIndexMarker507" class="pcalibre1 pcalibre calibre6"/> configuration of remote repository contain information about the transport protocol, the address of the remote server (where appropriate), and the path to the repository. Sometimes, the server that provides access to the remote repository supports various transport protocols; you need to select which one to use. This section is intended to help with this choice.</p>
<h2 id="_idParaDest-161" class="calibre7"><a id="_idTextAnchor179" class="pcalibre1 pcalibre calibre6"/>Local transport</h2>
<p class="calibre3">If the remote repository is on the same<a id="_idIndexMarker508" class="pcalibre1 pcalibre calibre6"/> local filesystem, you can use either the<a id="_idIndexMarker509" class="pcalibre1 pcalibre calibre6"/> path to the repository or the <code>file://</code> schema to specify the repository URL:</p>
<pre class="source-code">
/path/to/repo.git/
file:///path/to/repo.git/</pre>
<p class="calibre3">The former implies the <code>--local</code> option to the Git clone, which bypasses the smart Git-aware mechanism and simply makes a copy (or a hard link for immutable files under <code>.git/objects</code>, though you can avoid this with the <code>--no-hardlinks</code> option); the latter is slower but can be used to get a clean copy of a repository (for example, after history rewriting done to remove an accidentally committed password or another secret; which is described in <a href="B21194_10_split_000.xhtml#_idTextAnchor247" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 10</em></a>, <em class="italic">Keeping History Clean</em>, in the <em class="italic">Rewriting </em><em class="italic">history</em> section).</p>
<p class="calibre3">This transport is a nice option for quickly grabbing work from someone else’s working repository, or for sharing work using a shared filesystem with the appropriate permissions.</p>
<p class="calibre3">As a special case, a single dot (<code>.</code>) denotes the current repository. This means that</p>
<pre class="console">
$ git pull . next</pre>
<p class="calibre3">is, assuming that <code>pull.rebase</code> is set to false, roughly equivalent to</p>
<pre class="console">
$ git merge next</pre>
<h2 id="_idParaDest-162" class="calibre7"><a id="_idTextAnchor180" class="pcalibre1 pcalibre calibre6"/>Smart transports</h2>
<p class="calibre3">When the repository you want to fetch from is on <a id="_idIndexMarker510" class="pcalibre1 pcalibre calibre6"/>another machine, you need to access the Git server. Nowadays, Git-aware smart servers are most commonly <a id="_idIndexMarker511" class="pcalibre1 pcalibre calibre6"/>encountered. The smart downloader negotiates which revisions are necessary, and creates a customized <code>packfile</code> to send to a client. Similarly, during the push, the Git server talks to Git on the user’s machine (to the client) to find which revisions to upload.</p>
<p class="calibre3">Git-aware smart servers use the <code>git upload-pack</code> downloader for fetching and <code>git receive-pack</code> for pushing. You can tell Git where to find them if they are not in <code>PATH</code> (but, for example, are installed in one’s home directory) with the <code>--upload-pack</code> and <code>--receive-pack</code> options for fetching and pushing, or the <code>uploadpack</code> and <code>receivepack</code> configuration variables in the <code>remote.&lt;name&gt;</code> section.</p>
<p class="calibre3">With very few exceptions (such as <a id="_idIndexMarker512" class="pcalibre1 pcalibre calibre6"/>the repository using submodules accessed by an ancient Git instance that does not understand them), Git transport is backward- and forward-compatible—the client and server negotiate what capabilities they can both use.</p>
<h3 class="calibre9">The native Git protocol</h3>
<p class="calibre3">The native transport, using <code>git://</code> URLs, provides read-only anonymous access (though you could, in theory, configure Git to allow pushing by enabling the <code>receive-pack</code> service, either from the <a id="_idIndexMarker513" class="pcalibre1 pcalibre calibre6"/>command line via the <code>--enable=receive-pack</code> option, or via the <code>daemon.receivePack</code> boolean-valued configuration variable—using this mechanism is not recommended at all, even in a closed local network).</p>
<p class="calibre3">The Git protocol does no authentication, including no server authentication, and should be used with caution on unsecured networks. The <code>git daemon</code> TCP server for this protocol normally listens on port <code>9418</code>; you need to be able to access this port (through the firewall) to be able to use the native Git protocol.</p>
<p class="callout-heading">Trivia</p>
<p class="callout">There is no secure version of the <strong class="source-inline1">git://</strong> protocol. There is no <strong class="source-inline1">git://</strong> over TLS like there is for the FTP and HTTP protocols—namely, FTPS and HTTPS. On the other hand, one can consider SSH transport, as used by Git, to be the <strong class="source-inline1">git://</strong> protocol over SSH.</p>
<h3 class="calibre9">The SSH protocol</h3>
<p class="calibre3">The <code>git upload-pack</code> or <code>git receive-pack</code> on the server, using SSH to execute the remote command. There is no possibility for anonymous, unauthenticated access, though you could, as a workaround, set up a guest account for it (passwordless or with an empty password).</p>
<p class="calibre3">Using public-private key authentication allows access without requiring you to provide a password on every connection. You might, however, need to provide it once to unlock a password-protected private key. You can read more about authentication in the <em class="italic">Credentials/password management</em> section in this chapter. Many Git hosting sites and software forges require key authentication for accessing repositories via SSH.</p>
<p class="calibre3">For the SSH protocol, you<a id="_idIndexMarker516" class="pcalibre1 pcalibre calibre6"/> can use the URL syntax with <code>ssh://</code> as the protocol part:</p>
<pre class="source-code">
ssh://[user@]host.example.com[:port]/path/to/repo.git/</pre>
<p class="calibre3">Alternatively, you can use the <code>scp</code>-like syntax:</p>
<pre class="source-code">
[user@]host.example.com:path/to/repo.git/</pre>
<p class="calibre3">The SSH protocol additionally supports the <code>~username</code> expansion, just like the native Git transport (<code>~</code> is the home directory of the user you log in as, and <code>~user</code> is the home directory of <code>user</code>), in both syntax forms:</p>
<pre class="source-code">
ssh://[user@]host.example.com/~[user]/path/to/repo.git/
[user@]host.example.com:~[user]/path/to/repo.git/</pre>
<p class="calibre3">SSH uses the first contact authentication for servers (<strong class="bold">TOFU</strong>—short for <strong class="bold">Trust On First Use</strong>)—it remembers the key that the<a id="_idIndexMarker517" class="pcalibre1 pcalibre calibre6"/> server side previously used, and warns the user if it has changed, asking for confirmation (the server key could have been changed legitimately, for example, due to an SSH server reinstall). You can check the server key fingerprint on the first connection.</p>
<h3 class="calibre9">The smart HTTP(S) protocol</h3>
<p class="calibre3">Git also supports the smart HTTP(S) protocol, which<a id="_idIndexMarker518" class="pcalibre1 pcalibre calibre6"/> requires a Git-aware CGI or server module—for example, <code>git-http-backend</code> (itself a CGI module). This protocol uses the following URL syntax:</p>
<pre class="source-code">
http[s]://[user@]host.example.com[:port]/path/to/repo.git/</pre>
<p class="calibre3">By default, without any other configuration, Git allows anonymous downloads (<code>git fetch</code>, <code>git pull</code>, <code>git clone</code>, and <code>git ls-remote</code>), but requires that the client is authenticated for upload (<code>git push</code>).</p>
<p class="calibre3">Standard HTTP authentication is used if authentication is required to access a repository, which is done by the HTTP server software. Using SSL/TLS with HTTPS ensures that if the <a id="_idIndexMarker519" class="pcalibre1 pcalibre calibre6"/>password is required (for example, if the server uses basic HTTP authentication), then it is sent encrypted and the server identity is verified (using server CA ce<a id="_idTextAnchor181" class="pcalibre1 pcalibre calibre6"/>rtificate).</p>
<h2 id="_idParaDest-163" class="calibre7"><a id="_idTextAnchor182" class="pcalibre1 pcalibre calibre6"/>Legacy (dumb) transports</h2>
<p class="calibre3">Some transports do not require any<a id="_idIndexMarker520" class="pcalibre1 pcalibre calibre6"/> Git-aware smart server—they don’t need Git installed on the server (for smart transports, at least <code>git-upload-pack</code> and/or <code>git-receive-pack</code> is needed). Those <a id="_idIndexMarker521" class="pcalibre1 pcalibre calibre6"/>are the FTP(S) and dumb HTTP(S) protocol transports (nowadays, implemented using the <code>remote-curl</code> helper).</p>
<p class="calibre3">These transports need only the appropriate stock server (an FTP server, or a web server), and up-to-date data from <code>git update-server-info</code>. When fetching from such a server, Git uses the so-called <strong class="bold">commit walker</strong> downloader: going down from fetched branches and tags, Git walks down<a id="_idIndexMarker522" class="pcalibre1 pcalibre calibre6"/> the commit chain, and <a id="_idIndexMarker523" class="pcalibre1 pcalibre calibre6"/>downloads objects or packs containing missing revisions and other data (for example, file content at revision).</p>
<p class="calibre3">This transport is inefficient (in terms of bandwidth, but especially in terms of latency), but on the other hand, it can be resumed if interrupted. Nevertheless, there are better solutions than using dumb protocols—namely, involving bundles (see the <em class="italic">Offline transport with bundles</em> section in this chapter), when the network connection to the server is unreliable enough that you can’t get the clone operation to finish.</p>
<p class="calibre3">Pushing to a dumb server is possible only via the HTTP and HTTPS protocols. It requires the web server to support WebDAV, and Git has to be built with the <em class="italic">expat</em> library linked. The FTP and FTPS protocols are read-only (supporting only <code>clone</code>, <code>fetch</code>, and <code>pull</code>).</p>
<p class="calibre3">As a design feature, Git can automatically upgrade dumb protocol URLs to smart URLs. Conversely, a Git-aware HTTP server can downgrade to the backward-compatible dumb protocol (at least for fetching: smart HTTP servers don’t support WebDAV-based dumb HTTP push operation). This feature allows the use of the same HTTP(S) URL for both dumb and smart access:</p>
<pre class="source-code">
http[s]://[user@]host.example.com[:port]/path/to/repo.git/</pre>
<h2 id="_idParaDest-164" class="calibre7"><a id="_idTextAnchor183" class="pcalibre1 pcalibre calibre6"/>Offline transport with bundles</h2>
<p class="calibre3">Sometimes, there is no direct connection<a id="_idIndexMarker524" class="pcalibre1 pcalibre calibre6"/> between your machine and the server holding the Git repository that you want to fetch from. Or, perhaps there is <a id="_idIndexMarker525" class="pcalibre1 pcalibre calibre6"/>no server running, and you want to copy changes to another machine anyway. Maybe your network is down. Perhaps you’re working somewhere on-site and don’t have access to the local network for security reasons. Maybe your wireless/Ethernet card just broke.</p>
<p class="calibre3">Enter the <code>git bundle</code> command. This command will package up everything that would normally be<a id="_idIndexMarker526" class="pcalibre1 pcalibre calibre6"/> transferred over the wire, putting objects and references into a special binary archive file called <code>bundle</code> (like <code>packfile</code>, only with branches and so on). You need to specify which commits are to be packed—something that network protocols do automatically for you for online transport.</p>
<p class="callout-heading">Trivia</p>
<p class="callout">When you are using one of the smart transports, a <strong class="bold">want/have negotiation</strong> phase takes place, where the client tells the server what it does have in its repository and which advertised references on the server it wants, to find common revisions. This is then used by the server to create a packfile, and to send the client only what’s necessary, minimizing the bandwidth use.</p>
<p class="calibre3">Next, you need to move this bundle (this archive) by some means to your machine. It can be done, for example, by so-called <code>git clone</code> or <code>git fetch</code> with the filename of the bundle in place of the repository URL.</p>
<h3 class="calibre9">Proxies for Git transports</h3>
<p class="calibre3">When direct<a id="_idIndexMarker528" class="pcalibre1 pcalibre calibre6"/> access to the server is not possible, for example, from within a firewalled LAN, sometimes you can connect via a proxy.</p>
<p class="calibre3">For the native Git protocol (<code>git://</code>), you can use the <code>core.gitProxy </code>configuration variable, or the <code>GIT_PROXY_COMMAND</code> environment variable to specify a proxy command—for example, <code>ssh</code>. This can be set on a per-remote basis with special syntax for the <code>core.gitProxy</code> value—namely, <code>&lt;command&gt; for &lt;remote&gt;;</code> for example, <code>"ssh" </code><code>for kernel.org</code>.</p>
<p class="calibre3">You can use the <code>http.proxy</code> configuration variable or appropriate <em class="italic">curl</em> environment variables such as <code>http_proxy</code> to specify the HTTP proxy server to use for the HTTP(S) protocol (<code>http(s)://</code>). This can be set on a per-remote basis with the <code>remote.&lt;remote name&gt;.proxy</code> configuration variable.</p>
<p class="calibre3">You can configure SSH (using its configuration files—for example, <code>~/.ssh/config</code>) to use tunneling (port<a id="_idIndexMarker529" class="pcalibre1 pcalibre calibre6"/> forwarding) or a proxy command (for example, the <code>netcat/nc;</code> or <code>netcat</code> mode of SSH—that is, <code>ssh -W –</code>—if your SSH implementation supports this feature). It is a recommended solution for the SSH proxy; if neither tunneling nor using a proxy is possible, you can use the <code>ext::</code> transport-helper, as shown later in this chapter, in the <em class="italic">Transport relay with remote </em><em class="italic">helpers</em> section.</p>
<h3 class="calibre9">Cloning and updating with bundles</h3>
<p class="calibre3">Let’s assume that you want to<a id="_idIndexMarker530" class="pcalibre1 pcalibre calibre6"/> transfer the history of a project (say, limited to the <code>master</code> branch for simplicity) from <code>machineA</code> (for example, your work computer) to <code>machineB</code> (for example, an onsite computer). There is, however, no direct connection between those two machines.</p>
<p class="calibre3">First, we create a bundle that contains the whole history of the <code>master</code> branch (see <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>,<em class="italic"> Exploring Project History</em>), and tag this point of history to know what we bundled, which will be needed later:</p>
<pre class="console">
user@machineA ~$ cd repo
user@machineA repo$ git bundle create ../repo.bundle master
user@machineA repo$ git tag -f lastbundle master</pre>
<p class="calibre3">Here, the bundle file was created outside the working directory. This is a matter of choice; storing it outside of the repository means that you don’t have to worry about accidentally adding it to your project history, or having to add a new <code>ignore</code> rule. The <code>*.bundle</code> file extension is OR simply a matter of the naming convention.</p>
<p class="callout-heading">Important note</p>
<p class="callout">For security reasons, to avoid information disclosure about the parts of history that were deleted but not purged (for example, an accidentally committed file with a password), Git only allows fetching from <strong class="source-inline1">git show-ref</strong>-compatible references: branches, remote-tracking branches, and tags.</p>
<p class="callout">The same restrictions apply when creating a bundle. This means, for example, that (for implementation reasons) you cannot run <strong class="source-inline1">git bundle creates master^1</strong>. Though, of course, because you control the server end, as a workaround you can create a new branch for <strong class="source-inline1">master^</strong>, (temporarily) rewind <strong class="source-inline1">master</strong>, or check out the detached <strong class="source-inline1">HEAD</strong> at <strong class="source-inline1">master^</strong>.</p>
<p class="calibre3">Then you transfer the<a id="_idIndexMarker531" class="pcalibre1 pcalibre calibre6"/> just-created <code>repo.bundle</code> file to <code>machineB</code> (via email, on a USB pen drive, and so on). Because this bundle consists of a self-contained, whole subset of the history, down to the first (parent-less) root commit, you can create a new repository by cloning from it, by simply putting the bundle filename in place of the repository URL:</p>
<pre class="console">
user@machineB ~$ git clone repo.bundle repo
Cloning into 'repo'...
warning: remote HEAD refers to non-existent ref, unable to checkout.
user@machineB ~$ cd repo
user@machineB repo$ git branch -a
  remotes/origin/master</pre>
<p class="calibre3">Oops. We didn’t bundle <code>HEAD</code>, so the Git clone didn’t know which branch is current and therefore should be checked out:</p>
<pre class="console">
user@machineB repo$ git bundle list-heads ../repo.bundle
5d2584867fe4e94ab7d211a206bc0bc3804d37a9 refs/heads/master</pre>
<p class="callout-heading">Tip</p>
<p class="callout">Because a bundle can be treated as a remote repository, we could have simply used the <strong class="source-inline1">git ls-remote ../repo.bundle</strong> command here instead of <strong class="source-inline1">git bundle </strong><strong class="source-inline1">list-heads ../repo.bundle</strong>.</p>
<p class="calibre3">Therefore, with this <a id="_idIndexMarker532" class="pcalibre1 pcalibre calibre6"/>bundle being as it is, we need to specify which branch to check out to avoid the problem (this would not be necessary if we had bundled <code>HEAD</code> too):</p>
<pre class="console">
user@machineB ~$ git clone repo.bundle --branch master repo</pre>
<p class="calibre3">Instead of cloning again, we can fix the problem with the failed checkout by selecting the current branch:</p>
<pre class="console">
user@machineB repo$ git switch master
Already on 'master'
Branch 'master' set up to track remote branch 'master' from 'origin'.</pre>
<p class="calibre3">As you can see, here, Git guessed that when trying to switch to a non-existent local branch, <code>master</code>, what we actually wanted was to create a local branch to create new commits to submit to the remote <code>master</code> branch. In other words, create a local branch following (tracking) the remote branch with the same name existing in the <code>origin</code> remote. What Git did is the same as if we ran the following command:</p>
<pre class="console">
$ git switch --create master --track origin/master</pre>
<p class="calibre3">To update the repository on <code>machineB</code> cloned from the bundle, you can fetch or pull after replacing the original bundle stored at <code>/home/user/repo.bundle</code> with the one with incremental updates.</p>
<p class="calibre3">To create a bundle containing changes since the last transfer in our example, go to <code>machineA</code> and run the following command:</p>
<pre class="console">
user@machineA repo$ git bundle create ../repo.bundle \
  lastbundle..master
user@machineA repo$ git tag -f lastbundle master</pre>
<p class="calibre3">This will bundle all changes since the <code>lastbundle</code> tag; this tag denotes what was copied with the previous bundle (see <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>, the <em class="italic">Double-dot notation</em> section, for an explanation of double-dot syntax). After creating a bundle, this will update the tag (using <code>-f</code> or <code>--force</code> to replace it), like was done the first time when creating a bundle, so that the next bundle can also be created incrementally from<a id="_idIndexMarker533" class="pcalibre1 pcalibre calibre6"/> the now current point.</p>
<p class="calibre3">Then, you need to copy the bundle to <code>machineB</code>, <em class="italic">replacing</em> the old one. At this point, one can simply perform the pull operation to update the repository, as shown in the following example:</p>
<pre class="console">
user@machineB repo$ git pullFrom /home/user/repo.bundle
   ba5807e..5d25848  master     -&gt; origin/master
Updating ba5807e..5d25848
Fast-forward</pre>
<h3 class="calibre9">Using a bundle to update an existing repository</h3>
<p class="calibre3">Sometimes, you might have a repository cloned already, only for the network to fail. Or, perhaps you <a id="_idIndexMarker534" class="pcalibre1 pcalibre calibre6"/>moved outside the <strong class="bold">local area network</strong> (<strong class="bold">LAN</strong>), and now you have no access to the server. The end <a id="_idIndexMarker535" class="pcalibre1 pcalibre calibre6"/>result is that you have an existing repository, but no direct connection to the upstream (to the repository we cloned from).</p>
<p class="calibre3">Now, if you don’t want to bundle up the whole repository, which is wasteful, like in the <em class="italic">Cloning and updating with bundles</em> section, you need to find some way to specify the cut-off point (the base) in such a way that it is surely present in the target repository (which you want to update). You can specify the range of revisions to pack into the bundle using almost any technique from <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>, <em class="italic">Exploring Project History</em>. The only limitation is that the history, as was said earlier, must start at a branch or tag (anything that <code>git show-ref</code> accepts). You can, of course, check the range with the <code>git </code><code>log</code> command.</p>
<p class="calibre3">Commonly used solutions for specifying the range of revisions to pack into a bundle are as follows:</p>
<ul class="calibre16">
<li class="calibre15">Use the tag that is present in both repositories:<p class="calibre3"><code>git bundle create ../</code><code>repo.bundle v0.1..master</code></p></li>
<li class="calibre15">Create a cut-off based on the time of commit creation:<p class="calibre3"><code>git bundle create ../repo.bundle --</code><code>since=1.week master</code></p></li>
<li class="calibre15">Bundle just the last <a id="_idIndexMarker536" class="pcalibre1 pcalibre calibre6"/>few revisions, limiting the revision range by the number of commits:<p class="calibre3"><code>git bundle create ../repo.bundle -</code><code>5 master</code></p></li>
</ul>
<p class="callout-heading">Tip</p>
<p class="callout">It’s better to pack in too much than too little. You can check whether the repository has the requisite commits to fetch from the bundle with <strong class="source-inline1">git bundle verify</strong>. If you pack in too little, you’ll get the following error:</p>
<p class="callout"><strong class="source-inline1">user@machineB repo$ git pull ../</strong><strong class="source-inline1">repo.bundle master</strong></p>
<p class="callout"><strong class="source-inline1">error: Repository lacks these </strong><strong class="source-inline1">prerequisite commits:</strong></p>
<p class="callout"><strong class="source-inline1">error: ca3cdd6bb3fcd0c162a690d5383bdb8e8144b0d2</strong></p>
<p class="calibre3">Then, after transporting it to <code>machineB</code>, you can use the bundle file just like a regular repository to do a one-off pull (putting the bundle filename in place of the URL or the remote name):</p>
<pre class="console">
user@machineB repo$ git pull ../repo.bundle master
From ../repo.bundle
 * branch            master     -&gt; FETCH_HEAD
Updating ba5807e..5d25848</pre>
<p class="calibre3">If you don’t want to deal with <a id="_idIndexMarker537" class="pcalibre1 pcalibre calibre6"/>the merge, you can fetch into the remote-tracking branch (the <code>&lt;remote branch&gt;:&lt;remote-tracking branch&gt;</code> notation used here, which is known as <em class="italic">refspec</em>, will be explained in <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>, <em class="italic">Advanced </em><em class="italic">Branching Techniques</em>):</p>
<pre class="console">
user@machineB repo$ git fetch ../repo.bundle \
   refs/heads/master:refs/remotes/origin/master
From ../repo.bundle
   ba5807e..5d25848  master     -&gt; origin/master
Updating ba5807e..5d25848</pre>
<p class="calibre3">Alternatively, you can use <code>git remote add</code> to create a new shortcut, using the path to the bundle file in place<a id="_idIndexMarker538" class="pcalibre1 pcalibre calibre6"/> of the repository URL. Then, you can simply deal with bundles as described in the previous section.</p>
<h3 class="calibre9">Utilizing a bundle to help with the initial clone</h3>
<p class="calibre3">Smart transports provide much more effective transport than dumb ones. On the other hand, the concept of a <a id="_idIndexMarker539" class="pcalibre1 pcalibre calibre6"/>resumable clone using smart transport remains elusive to this day (it is not available in Git version 2.34, though perhaps somebody will implement it in the future). For large projects with a long history and with a large number of files, the initial clone might be quite large (for example, <code>linux-next</code> is more than 2.7 GB) and take a pretty long time. This might be a problem if the network is unreliable.</p>
<p class="callout-heading">Tip – workaround</p>
<p class="callout">You can work around the issue of an unreliable network by using a shallow clone or a sparse clone (see <a href="B21194_12.xhtml#_idTextAnchor302" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 12</em></a>, <em class="italic">Managing</em><em class="italic"> Large Repositories</em>) and widening it step by step until you arrive at the full repository. There are some third-party tools that do this automatically.</p>
<p class="calibre3">You can create a bundle from the source repository, for example, with the following command (which needs to run on the server):</p>
<pre class="console">
$ git –git-dir=/dir/repo.git bundle create -- all HEAD</pre>
<p class="calibre3">Some servers may offer such bundles to help with the initial clone. There is a practice where a bundle intended for cloning is available at the same URL as the repository, but with a <code>.bundle</code> suffix instead of <code>.git</code>. For example, <code>https://git.example.com/user/repo.git</code> has its bundle available at <code>https://git.example.com/user/repo.bundle</code>.</p>
<p class="calibre3">You can then download such a bundle, which is an ordinary static file, using any resumable transport: HTTP(S), FTP(S), rsync, or even BitTorrent (with the appropriate client that supports resuming the download).</p>
<p class="calibre3">With modern Git, the user can specify the bundle URI with the <code>--bundle-uri</code> command-line option, or a bundle<a id="_idIndexMarker540" class="pcalibre1 pcalibre calibre6"/> list can be advertised by a Git server. A list of bundle URIs can also be saved in a config file. Fetching from bundle servers (such as <a href="https://github.com/git-ecosystem/git-bundle-server" class="pcalibre1 pcalibre calibre6">https://github.com/git-ecosystem/git-bundle-server</a>) is then automatic.</p>
<h2 id="_idParaDest-165" class="calibre7"><a id="_idTextAnchor184" class="pcalibre1 pcalibre calibre6"/>Remote transport helpers</h2>
<p class="calibre3">When Git doesn’t know how to handle a certain transport protocol (when one tries to use a protocol that doesn’t have built-in <a id="_idIndexMarker541" class="pcalibre1 pcalibre calibre6"/>support), it attempts to use the appropriate <strong class="bold">remote helper</strong> for a protocol, if one exists. That’s why if there is an<a id="_idIndexMarker542" class="pcalibre1 pcalibre calibre6"/> error within the protocol part of the repository URL—Git responds with an error message that looks like the following:</p>
<pre class="console">
$ git clone shh://git@example.com:repo
Cloning into 'repo'…
fatal: Unable to find remote helper for 'shh'
git: 'remote-shh' is not a git command. See 'git --help'.</pre>
<p class="calibre3">This error message means that Git tried to find <code>git-remote-shh</code> to handle the <code>shh</code> protocol (actually a typo for <code>ssh</code>), but didn’t find an executable with such a name.</p>
<p class="calibre3">You can explicitly request a specific remote helper with the <code>&lt;transport&gt;::&lt;address&gt;</code> syntax, where <code>&lt;transport&gt;</code> defines the helper (<code>git remote-&lt;transport&gt;</code>), and <code>&lt;address&gt;</code> is a string that the helper uses to find the repository.</p>
<p class="calibre3">Modern Git implements support for the dumb HTTP, HTTPS, FTP, and FTPS protocols with the <code>curl</code> family of remote helpers: <code>git-remote-http</code>, <code>git-remote-https</code>, <code>git-remote-ftp</code>, and <code>git-remote-ftps</code>, respectively.</p>
<h3 class="calibre9">Transport relay with remote helpers</h3>
<p class="calibre3">Git includes two generic remote<a id="_idIndexMarker543" class="pcalibre1 pcalibre calibre6"/> helpers that can be used to proxy smart transports: the <code>git-remote-fd</code> helper to connect to the remote server via either a bidirectional socket or a pair of pipes, and the <code>git-remote-ext</code> helper to use an external command to connect to the remote server.</p>
<p class="calibre3">In the case of the latter, which uses the <code>"ext::&lt;command&gt; &lt;arguments"&gt;"</code> syntax for the repository URL, Git runs the specified command to connect to the server, passing data for the server to<a id="_idIndexMarker544" class="pcalibre1 pcalibre calibre6"/> the standard input of the command, and receiving a response on its standard output. This data is assumed to be passed to a <code>git://</code> server, <code>git-upload-pack</code>, <code>git-receive-pack</code>, or <code>git-upload-archive</code> (depending on the situation).</p>
<p class="calibre3">For example, let’s assume that you have your repository on a LAN host where you can log in using SSH. However, for security reasons, this host is not visible on the internet, and you need to go through the gateway host: <code>login.example.com</code>:</p>
<pre class="console">
user@home ~$ ssh user@login.example.com
user@login ~$ ssh work
user@work ~$ find . -name .git -type d -print
./repo/.git</pre>
<p class="calibre3">The trouble is that—also for security reasons—this gateway host either doesn’t have Git installed (reducing the attack surface) or doesn’t have your repository present (it uses a different filesystem). This means that you cannot use the ordinary SSH protocol—not unless you can set up an <code>ssh -L</code>). The SSH transport is just <code>git-receive-pack</code> / <code>git-upload-pack</code> accessed remotely via SSH, with the path to the repository as a parameter. This means that you can use the <code>ext::</code> remote helper:</p>
<pre class="console">
user@home ~$ git clone \
   "ext::ssh -t  ssh work %S 'repo'" repo
Cloning into 'repo'...
Checking connectivity... done.</pre>
<p class="calibre3">Here, <code>%S</code> will be expanded by Git into the full name of the appropriate service—<code>git-upload-pack</code> for fetching and <code>git-receive-pack</code> for pushing. The <code>-t</code> option is needed if logging to the internal host uses interactive authentication (for example, a password). Note that you need to give the name (<code>repo</code>, here) to the result of cloning; otherwise, Git will use the command (<code>ssh</code>) as the repository name.</p>
<p class="callout-heading">Tip</p>
<p class="callout">You can also use <strong class="source-inline1">"ext::ssh [&lt;parameters&gt;...] %S '&lt;repository&gt;'"</strong> to use specific options for SSH transport—for example, selecting the keypair to use without needing to edit <strong class="source-inline1">.ssh/config</strong>.</p>
<p class="calibre3">This is not the only possible solution—though there is no built-in support for sending the SSH transport through a proxy like<a id="_idIndexMarker546" class="pcalibre1 pcalibre calibre6"/> there is for the native <code>git://</code> protocol (among others, <code>core.gitProxy</code>) and for HTTP (among others, <code>http.proxy</code>), you can do it by configuring the SSH using the <code>ProxyCommand</code> config option, or by creating an SSH tunnel.</p>
<p class="calibre3">On the other hand, you can also use the <code>ext::</code> remote helper to proxy the <code>git://</code> protocol—for example, with the help of <code>socat</code>—including using a single proxy for multiple servers. See the <code>git-remote-ext(1)</code> manpage for details and examples.</p>
<h3 class="calibre9">Using foreign SCM repositories as remotes</h3>
<p class="calibre3">The remote helper mechanism<a id="_idIndexMarker547" class="pcalibre1 pcalibre calibre6"/> is very powerful. It can also be used to interact with other version control systems, transparently using their repositories as if they were native Git repositories. Though there is no such built-in helper (unless you count the <code>contrib/</code> area in the Git sources), you can find the <code>git-remote-hg</code>, <code>gitifyhg</code>, or <code>git-cinnabar</code> helper to access Mercurial repositories, and <code>git-remote-bzr</code> to access Bazaar repositories.</p>
<p class="calibre3">Once installed, those remote helper bridges will allow you to clone, fetch, and push to and from the Mercurial or Bazaar repositories as if they were Git ones, using the <code>&lt;helper&gt;::&lt;URL&gt;</code> syntax. For example, to clone the Mercurial repository, you can simply run the following command:</p>
<pre class="console">
$ git clone "hg::https://hg.example.com/repo"</pre>
<p class="calibre3">There is also the <code>remote.&lt;remote name&gt;.vcs</code> configuration variable, if you don’t like using the <code>&lt;helper&gt;::</code> prefix in the repository URL. With this method, you can use the same URL for<a id="_idIndexMarker548" class="pcalibre1 pcalibre calibre6"/> Git as for the original <strong class="bold">version control </strong><strong class="bold">system</strong> (<strong class="bold">VCS</strong>).</p>
<p class="callout-heading">Foreign version control system clients</p>
<p class="callout">The alternative approach to using remote helper bridges is to use a specialized client, such as <strong class="source-inline1">git-svn</strong> for Subversion, or <strong class="source-inline1">git-p4</strong> for Perforce. Those clients interact with the foreign VCS (usually a centralized VCS), manage and update the Git repository based on this interaction, and update the foreign repository based on changes present in the Git repository.</p>
<p class="calibre3">Of course, one needs to remember impedance mismatches between different version control systems, and the limitations of the remote helper mechanism. Some features do not translate at all or do not<a id="_idIndexMarker549" class="pcalibre1 pcalibre calibre6"/> translate well—for example, octopus merges (with more than two parent commits) in Git, or multiple anonymous branches (heads) in Mercurial.</p>
<p class="calibre3">With remote helpers, there is also no place to fix mistakes, replace references to other revisions with target native syntax, and otherwise clean up artifacts created by repository conversions—as can and should be done with one-time conversion when changing version control systems. (Such a cleanup can be done with, for example, the help of the <code>reposurgeon</code> third-party tool.)</p>
<p class="calibre3">With remote helpers, you can even use things that are not version control repositories in the strict sense; for example, with the <em class="italic">Git-Mediawiki</em> project, you can use Git to view and edit a MediaWiki-based wiki (for example, Wikipedia), treating the history of pages as a Git repository:</p>
<pre class="console">
$ git clone "mediawiki::https://wiki.example.com"</pre>
<p class="calibre3">Besides that, there are remote helpers that allow additional transport protocols, or storage options—such as <code>git-remote-s3bundle</code> to store the repository as a bundle file on Amazon S3, or <code>git-remote-codecommit</code> for AWS CodeCommit (if you don’t want to or cannot use HTTPS authentication with static credentials). There is also <code>git-ssb</code> to encode repositories in a peer-to-peer log <a id="_idTextAnchor185" class="pcalibre1 pcalibre calibre6"/>store via the Secure ScuttleButt protocol.</p>
<h2 id="_idParaDest-166" class="calibre7"><a id="_idTextAnchor186" class="pcalibre1 pcalibre calibre6"/>Credentials/password management</h2>
<p class="calibre3">In most cases, with the exception of the local transport (where filesystem permissions control access), publishing changes<a id="_idIndexMarker550" class="pcalibre1 pcalibre calibre6"/> to the remote repository<a id="_idIndexMarker551" class="pcalibre1 pcalibre calibre6"/> requires authentication (the user identifies itself) and authorization (the given user has permission to perform the push operation). Sometimes, fetching the repository also requires authentication and authorization, like with private repositories.</p>
<p class="calibre3">Commonly used <strong class="bold">credentials</strong> for authentication are <em class="italic">username</em> and <em class="italic">password</em>. You can put the username in the HTTP and SSH repository URLs if you are not concerned about information leakage (in respect of leaking the <a id="_idIndexMarker552" class="pcalibre1 pcalibre calibre6"/>information about valid usernames), or you can use the <strong class="bold">credential helper</strong> mechanism. You should <em class="italic">never</em> put passwords in URLs, even though it is technically possible for HTTP ones—the password can be visible to other people, for example when<a id="_idIndexMarker553" class="pcalibre1 pcalibre calibre6"/> they are listing processes.</p>
<p class="calibre3">Besides the mechanism inherent in the underlying transport engine, be it <code>SSH_ASKPASS</code> for SSH or the <code>~/.netrc</code> file for curl-based transport, Git provides its own integrated solutions.</p>
<h3 class="calibre9">Asking for passwords</h3>
<p class="calibre3">Some of the Git commands that interactively ask for a password (and a username if it is not known)—such as <code>git svn</code>, the HTTP interface, or IMAP authentication—can be told to use an external program. The <a id="_idIndexMarker554" class="pcalibre1 pcalibre calibre6"/>program is invoked with a suitable <a id="_idIndexMarker555" class="pcalibre1 pcalibre calibre6"/>prompt (a so-called <strong class="bold">authentication domain</strong>, describing what the password is for), and Git reads the password from the standard output of this program.</p>
<p class="calibre3">Git will try the following places to ask the user for usernames and passwords; see the <code>gitcredentials(7)</code> manpage:</p>
<ul class="calibre16">
<li class="calibre15">The program specified by the <strong class="source-inline1">GIT_ASKPASS</strong> environment variable, if set (Git-specific environment variables always have higher precedence than configuration variables)</li>
<li class="calibre15">Otherwise, the <strong class="source-inline1">core.askpass</strong> configuration variable is used, if set</li>
<li class="calibre15">Otherwise, the <strong class="source-inline1">SSH_ASKPASS</strong> environment variable is used, if set (it is not Git-specific, that is why it is consulted later in the sequence)</li>
<li class="calibre15">Otherwise, the user is prompted on the terminal</li>
</ul>
<p class="calibre3">This <code>askpass</code> external program is usually selected according to the desktop environment of the user (after installing it, if necessary):</p>
<ul class="calibre16">
<li class="calibre15">(<strong class="source-inline1">x11-</strong>)<strong class="source-inline1">ssh-askpass</strong> provides a plain X-window dialog asking for the username and password</li>
<li class="calibre15">There is <strong class="source-inline1">ssh-askpass-gnome</strong> for GNOME and <strong class="source-inline1">ksshaskpass</strong> for KDE</li>
<li class="calibre15"><strong class="source-inline1">mac-ssh-askpass</strong> can be used for macOS</li>
<li class="calibre15"><strong class="source-inline1">win-ssh-askpass</strong> can be used for MS Windows</li>
</ul>
<p class="calibre3">Git comes with a cross-platform <a id="_idIndexMarker556" class="pcalibre1 pcalibre calibre6"/>password dialog in Tcl/Tk—<code>git-gui--askpass</code>—to accompany the <code>git gui</code> graphical interface and the <code>gitk</code> history viewer.</p>
<p class="calibre3">The Git configuration precedence (that we have seen an example of here) will be described in more detail in <a href="B21194_13_split_000.xhtml#_idTextAnchor320" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 13</em></a>, <em class="italic">Customizing and </em><em class="italic">Extending Git</em>.</p>
<h3 class="calibre9">Public key authentication for SSH</h3>
<p class="calibre3">For the SSH transport<a id="_idIndexMarker557" class="pcalibre1 pcalibre calibre6"/> protocol, there are additional authentication mechanisms besides passwords. One of them is <code>gitolite</code> uses—<a href="https://gitolite.com" class="pcalibre1 pcalibre calibre6">https://gitolite.com</a>).</p>
<p class="calibre3">The idea of public key authentication is that the<a id="_idIndexMarker560" class="pcalibre1 pcalibre calibre6"/> user creates a <code>ssh-keygen</code>. The public key is then sent to the server, for example, by using <code>ssh-copy-id</code> (which also adds the public key, <code>*.pub</code>, at the end of the <code>~/.ssh/authorized_keys</code> file on the remote server), or by pasting it into a web form on a hosting service. You can then log in with your private key that is on your local machine, for example, as <code>~/.ssh/id_rsa</code>. You might need to configure SSH (in <code>~/.ssh/config</code> on Linux, and a similar configuration file on MS Windows) to use a specific identity file for a given connection (hostname) if it is not the default identity key.</p>
<p class="calibre3">Another convenient way to use public key authentication is with an authentication agent such as <code>ssh-agent</code> (or Pageant from PuTTY on MS Windows). Utilizing an agent also makes it more convenient to work with passphrase-protected private keys—you need to provide the password only once, to the agent, at the time of adding the key (which might require user action, for example, running <code>ssh-add</code> for <code>ssh-agent</code>).</p>
<h3 class="calibre9">Credential helpers</h3>
<p class="calibre3">It can be cumbersome to input the same credentials over and over. For SSH, you can use public key authentication, but there is no true<a id="_idIndexMarker561" class="pcalibre1 pcalibre calibre6"/> equivalent for other transports. Git credential configuration provides two methods to at least reduce the number of questions.</p>
<p class="calibre3">The first is the static configuration of default usernames (if one is not provided in the URL) for a given <strong class="bold">authentication context</strong>—for example, hostname:</p>
<pre class="source-code">
[credential "https://git.example.com"]
    username = user</pre>
<p class="calibre3">It helps if you don’t have secure storage for credentials.</p>
<p class="calibre3">The second is to use external programs from which Git can request both usernames and passwords—<strong class="bold">credential helpers</strong>. These programs<a id="_idIndexMarker562" class="pcalibre1 pcalibre calibre6"/> usually interface with secure storage (a keychain, keyring, wallet, credentials manager, and so on) provided by the desktop environment or the operating system.</p>
<p class="calibre3">Git, by default, includes at least the <code>cache</code> and <code>store</code> helpers. The <code>cache</code> helper (<code>git-credential-cache</code>) stores credentials in memory for a short period of time; by default, it caches usernames and passwords for 15 minutes. The <code>store</code> helper (<code>git-credential-store</code>) stores <em class="italic">unencrypted</em> credentials for an indefinitely long time on disk, in files readable only by the user (similar to <code>~/.netrc</code>); there is also a third-party <code>netrc</code> helper (<code>git-credential-netrc</code>) for GPG-encrypted <code>netrc/authinfo</code> files.</p>
<p class="calibre3">Selecting a credential helper to use (and its options) can be configured either globally or per authentication context, as in the previous example. Global credentials configuration looks like the following:</p>
<pre class="source-code">
[credential]
    helper = cache --timeout=300</pre>
<p class="calibre3">This will make Git use the <code>cache</code> credential helper, which will then cache credentials for 300 seconds (5 minutes). If the credential helper name is not an absolute path (for example, <code>/usr/local/bin/git-kde-credentials-helper</code>), Git will prepend the <code>git credential-</code> prefix to the helper’s name. You can check what types of credential helpers are available with <code>git help -a | grep credential-</code>. Git for Windows also includes, optionally, <code>git credential-helper-selection</code>.</p>
<p class="calibre3">There exist credential helpers that use secure storage of the desktop environment. When you are using them, you<a id="_idIndexMarker563" class="pcalibre1 pcalibre calibre6"/> need to provide the password only once, to unlock the storage (some helpers can be found in the <code>contrib/</code> area in Git sources). There is <code>git-credential-libsecret</code> for GNOME and KDE, <code>git-credential-osxkeychain</code> for the macOS Keychain, and <code>git-credential-manager</code> for <a id="_idIndexMarker564" class="pcalibre1 pcalibre calibre6"/>Microsoft’s cross-platform <strong class="bold">Git Credential </strong><strong class="bold">Manager</strong> (<strong class="bold">GCM</strong>).</p>
<p class="calibre3">You can also use <code>git-credential-oauth</code> to avoid having to set up personal access tokens or SSH keys. With this solution, the first time you authenticate, the helper opens a browser window to the host. Subsequent access uses cached credentials. Here, one can use the fact that Git supports multiple credential helpers. GitHub, GitLab, and Bitbucket are among the Git hosting services that support OAuth authentication.</p>
<p class="calibre3">Git will use credential configuration for the most specific authentication context, though if you want to distinguish the HTTP URL by pathname (for example, providing different usernames to different repositories on the same host), you need to set the <code>useHttpPath</code> configuration variable to <code>true</code>. If there are multiple helpers configured for context, each will be tried in turn, until Git acquires both a username and a password.</p>
<p class="callout-heading">Historical note</p>
<p class="callout">Before the introduction of credential helpers, one could use <em class="italic">askpass</em> programs that interface with the desktop environment keychain—for example, <strong class="source-inline1">kwalletaskpass</strong> (for KDE Wallet) or <strong class="source-inline1">git-password</strong> (for the macOS Keychain).</p>
<h1 id="_idParaDest-167" class="calibre5"><a id="_idTextAnchor187" class="pcalibre1 pcalibre calibre6"/>Publishing your changes upstream</h1>
<p class="calibre3">The <em class="italic">Collaborative workflows</em> section in <a href="B21194_06.xhtml#_idTextAnchor140" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 6</em></a>, <em class="italic">Collaborative Development with Git</em> explained various repository setups. Here, we’ll learn <a id="_idIndexMarker565" class="pcalibre1 pcalibre calibre6"/>about a few common patterns for contributing to a project. We’ll see what our main options for publishing changes are.</p>
<p class="calibre3">Before starting work on new changes, you should usually sync with the main development, incorporating the official version into your repository. This, and the work of the maintainer, is left to be<a id="_idIndexMarker566" class="pcalibre1 pcalibre calibre6"/> described in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>, <em class="italic">Merging </em><em class="italic">Changes Together</em>.</p>
<h2 id="_idParaDest-168" class="calibre7"><a id="_idTextAnchor188" class="pcalibre1 pcalibre calibre6"/>Pushing to a public repository</h2>
<p class="calibre3">In a <strong class="bold">centralized workflow</strong>, publishing your changes consists simply of <strong class="bold">pushing</strong> them to the central server, as<a id="_idIndexMarker567" class="pcalibre1 pcalibre calibre6"/> shown in <em class="italic">Figure 6</em><em class="italic">.2</em>. Because you share this central repository with other developers, it can happen that somebody has already pushed to the branch you are trying to update (the non-fast-forward case). In this scenario, you need to pull (fetch and merge, or fetch and<a id="_idIndexMarker568" class="pcalibre1 pcalibre calibre6"/> rebase) others’ changes, before being able to push yours. This case is shown at the start of the <em class="italic">Updating your repository (with merge)</em> section in <a href="B21194_01.xhtml#_idTextAnchor015" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 1</em></a>, <em class="italic">Git Basics </em><em class="italic">in Practice</em>.</p>
<p class="calibre3">Another possible system with a similar workflow is when your team submits each set of changes to the code review system—for example, Gerrit. One available option is to push to a special ref, <code>refs/for/&lt;branchname&gt;</code> (which is named after a target branch), in a special repository. Then, the change review server makes each set of changes land automatically on a separate per-set ref (for example, <code>refs/changes/&lt;change-id&gt;</code> for commits belonging to a series with the given change ID).</p>
<p class="callout-heading">Important note</p>
<p class="callout">In both peer-to-peer (see <em class="italic">Figure 6</em><em class="italic">.3</em>) and maintainer workflows, or the hierarchical workflow variant (<em class="italic">Figure 6</em><em class="italic">.4</em> and <em class="italic">Figure 6</em><em class="italic">.5</em>, respectively), the first step in getting your changes included in the project is to perform the push operation, but pushing to <em class="italic">your own</em> “public” repository (visible to the appropriate group) of your fork of the project. Then, you need to ask your co-developers, or the project maintainer, to merge your changes. You can do this, f<a id="_idTextAnchor189" class="pcalibre1 pcalibre calibre6"/>or example, by generating a <strong class="bold">pull request</strong>, as described below.</p>
<h2 id="_idParaDest-169" class="calibre7"><a id="_idTextAnchor190" class="pcalibre1 pcalibre calibre6"/>Generating a pull request</h2>
<p class="calibre3">In all workflows other than the <a id="_idIndexMarker569" class="pcalibre1 pcalibre calibre6"/>centralized workflow, one needs to send a notification that changes are available in the<a id="_idIndexMarker570" class="pcalibre1 pcalibre calibre6"/> public repository to co-developers, to the maintainer, or to integration managers. The <code>git request-pull</code> command can help with this step. Given the starting point (the bottom of the revision range of interest), the URL or the name of the remote public repository, and optionally, the commit to end at (if it is not the <code>HEAD</code>), this command will generate a summary of changes:</p>
<pre class="console">
$ git request-pull origin/master publish
The following changes since commit  ba5807e44d75285244e1d2eacb1c10cbc5cf3935:
  Merge: strtol() + checks (2014-05-31 20:43:42 +0200)
are available in the Git repository at:
  https://git.example.com/random master
for you to fetch changes up to 82006acd359717624fb33a7ae554cba6be717911:
  Merge branch 'master' of https://git.company.com/random (2021-05-30 00:58:23 +0200)
-----------------------------------------------------------
Alice Developer (1):
      Support optional &lt;count&gt; parameter
 src/rand.c |   26 +++++++++++++++++++++-----
 1 files changed, 21 insertions(+), 5 deletions(-)</pre>
<p class="calibre3">The pull request <a id="_idIndexMarker571" class="pcalibre1 pcalibre calibre6"/>contains the SHA-1 of the base of the changes (which is the revision just before the first commit, in<a id="_idIndexMarker572" class="pcalibre1 pcalibre calibre6"/> the series proposed for pull), the title of the base commit, the URL, the branch of the public repository (suitable as <code>git pull</code> parameters), the title of the final <a id="_idIndexMarker573" class="pcalibre1 pcalibre calibre6"/>commit, the <code>git shortlog</code> output), and <code>git diff --stat</code> output) of the changes. This output can<a id="_idIndexMarker574" class="pcalibre1 pcalibre calibre6"/> be sent to the maintainer—for example, by email.</p>
<div><div><img alt="" role="presentation" src="img/B21194_07_01.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 7.1 – “New pull request” action shown in a list of branches on GitHub</p>
<p class="calibre3">A lot of Git hosting software <a id="_idIndexMarker575" class="pcalibre1 pcalibre calibre6"/>and services include a built-in equivalent of <code>git request-pull</code> (for example, the <strong class="bold">Create pull request</strong> action in GitHub).</p>
<h2 id="_idParaDest-170" class="calibre7"><a id="_idTextAnchor191" class="pcalibre1 pcalibre calibre6"/>Exchanging patches</h2>
<p class="calibre3">Many larger projects (and many <a id="_idIndexMarker576" class="pcalibre1 pcalibre calibre6"/>open source projects) have established procedures for accepting changes in the form of <strong class="bold">patches</strong>, for example, to lower the barrier to entry for contributing. If you want to send a one-off code proposal to a project but do not plan to be a regular contributor, sending patches might be easier than a full collaboration setup (acquiring permission to commit in the centralized workflow, setting up a personal public repository for forking and similar workflows—on GitHub, that would consist of <strong class="bold">forking</strong> the project). Besides, one can generate patches <a id="_idIndexMarker577" class="pcalibre1 pcalibre calibre6"/>with any compatible tool, and the project can accept patches no matter what is the version control setup.</p>
<p class="callout-heading">Tip</p>
<p class="callout">Nowadays, with the proliferation of various free Git hosting services, it might be more difficult to set up an email client for sending properly formatted patch emails—though services such as <em class="italic">GitGitGadget</em> (for submitting patches to the Git project mailing list), or the older <em class="italic">submitGit</em> service, could help. Git itself also includes commands for sending mail, namely <strong class="source-inline1">git send-email</strong> and <strong class="source-inline1">git imap-send</strong>, both of which need configuration.</p>
<p class="calibre3">Additionally, patches, being a text representation of changes, can be easily understood by computers and humans alike. This makes them universally appealing, and very useful for <em class="italic">code review</em> purposes. Many open source projects historically used the public mailing list for that purpose: you can email a patch to this list and the public can review and comment on your changes (with services such as <em class="italic">public-inbox</em> and <em class="italic">lore+lei</em>, it is possible even without subscribing to the mailing list).</p>
<p class="calibre3">To generate email<a id="_idIndexMarker578" class="pcalibre1 pcalibre calibre6"/> versions of each commit series, turning them into mbox-formatted patches, you can use the <code>git format-patch</code> command, as follows:</p>
<pre class="console">
$ git format-patch -M -1
0001-Support-optional-count-parameter.patch</pre>
<p class="calibre3">You can use any revision range specifier with this command. The most commonly used is limiting by the number of commits, as in the preceding example, or by using the double-dot revision range syntax—for example, <code>@{u}..</code> (see <a href="B21194_04.xhtml#_idTextAnchor083" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 4</em></a>,<em class="italic"> Exploring Project History</em>, the <em class="italic">Double-dot notation</em> section). When generating a larger number of patches, it is often useful to select a directory to save generated patches. This can be done with the <code>-o &lt;directory&gt;</code> option. The <code>-M</code> option for <code>git format-patch</code> (passed to <code>git diff</code>) turns on rename detection; this can make patches smaller and easier to review.</p>
<p class="calibre3">The patch files end up looking like this:</p>
<pre class="source-code">
From db23d0eb16f553dd17ed476bec731d65cf37cbdc Mon Sep 17 00:00:00 2001
From: Alice Developer &lt;alice@company.com&gt;
Date: Sat, 31 May 2014 20:25:40 +0200
Subject: [PATCH] Initialize random number generator
Signed-off-by: Alice Developer
---
 random.c |    2 ++
 1 files changed, 2 insertions(+), 0 deletions(-)
diff --git a/random.c b/random.c
index cc09a47..5e095ce 100644
--- a/random.c
+++ b/random.c
@@ -1,5 +1,6 @@
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
+#include &lt;time.h&gt;
 int random_int(int max)
@@ -15,6 +16,7 @@ int main(int argc, char *argv[])
int max = atoi(argv[1]);
+    srand(time(NULL));
     int result = random_int(max);
     printf("%d\n", result);
--
2.42.0</pre>
<p class="calibre3">It is actually a complete email in the mbox format. The subject (after stripping the <code>[PATCH]</code> prefix) and everything up to the three-dash line (<code>---</code>) forms the commit message—the description of<a id="_idIndexMarker579" class="pcalibre1 pcalibre calibre6"/> the change. To email this to a mailing list or a developer, you can use either <code>git send-email</code> or <code>git imap-send</code>, or any email client capable of sending plain text email. The maintainer can then use <code>git am</code> to apply the patch series, creating commits automatically; there’s more about this in <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>,<em class="italic"> Merging Changes Together</em>, in the <em class="italic">Applying a series of commits from </em><em class="italic">patches</em> section.</p>
<p class="callout-heading">Email subject convention for patches</p>
<p class="callout">The <strong class="bold">[PATCH]</strong> prefix is there to make it easier to distinguish patches from other emails. This prefix can—and often does—include additional information, such as the number in the series (set) of <a id="_idIndexMarker580" class="pcalibre1 pcalibre calibre6"/>patches, the revision of the series, the information about it being a <strong class="bold">work in progress</strong> (<strong class="bold">WIP</strong>), or the <strong class="bold">Request For Comments</strong> (<strong class="bold">RFC</strong>) status—for <a id="_idIndexMarker581" class="pcalibre1 pcalibre calibre6"/>example, <strong class="source-inline1">[</strong><strong class="source-inline1">RFC/PATCHv4 3/8]</strong>.</p>
<p class="calibre3">You can also edit these patch files to add more information for prospective reviewers—for example, information about alternative approaches, the differences between previous revisions of the patch (previous attempts), or a summary and/or references to the discussion on implementing the patch (for example, on a mailing list). You add such text between the <code>---</code> line and the beginning of the patch, before the summary of changes (<code>diffstat</code>); it will be ignored by <code>git am</code>.</p>
<p class="callout-heading">Tip – range diff</p>
<p class="callout">If the series of patches is undergoing revision and needs to be redone in a different way, it is recommended practice to provide in the cover letter the <strong class="source-inline1">git range-diff</strong> output, showing the differences between one iteration of the series and the other.</p>
<h1 id="_idParaDest-171" class="calibre5"><a id="_idTextAnchor192" class="pcalibre1 pcalibre calibre6"/>Summary</h1>
<p class="calibre3">In this chapter, we have learned how to choose a transport protocol (if the remote server offers such a choice), and a few tricks such as using foreign repositories as if they were native Git repositories and offline transport with bundles.</p>
<p class="calibre3">Contact with remote repositories can require providing credentials—usually, the username and password, to be able to, for example, push to the repository. This chapter described how Git can help make this part easier thanks to credential helpers.</p>
<p class="calibre3">Publishing your changes and sending them upstream may involve different mechanisms, depending on the workflow. This chapter described push, pull request, and patch-based techniques.</p>
<p class="calibre3">The two following chapters expand on the topic of collaboration: <a href="B21194_08_split_000.xhtml#_idTextAnchor196" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 8</em></a>,<em class="italic"> Advanced Branching Techniques</em>, explores relations between local branches and branches in a remote repository, and how to set up branches for collaboration, while <a href="B21194_09.xhtml#_idTextAnchor229" class="pcalibre1 pcalibre calibre6"><em class="italic">Chapter 9</em></a>,<em class="italic"> Merging Changes Together</em>, talks about the opposite issue—how to join the results of parallel work.</p>
<h1 id="_idParaDest-172" class="calibre5"><a id="_idTextAnchor193" class="pcalibre1 pcalibre calibre6"/>Questions</h1>
<p class="calibre3">Answer the following questions to test your knowledge of this chapter:</p>
<ol class="calibre14">
<li class="calibre15">How can one clone a large repository when the connection to the host is quite unreliable, but you can log in to the host with the remote repository?</li>
<li class="calibre15">What do you need to get your changes into the canonical repository in the centralized workflow, and what do you need to do in the integration manager workflow?</li>
<li class="calibre15">How can you set up Git so you would need to provide a password only once, and not for each contact with the remote?</li>
<li class="calibre15">Can you use Git to interact with foreign version-control system repositories, to submit commits and download updates?</li>
</ol>
<h1 id="_idParaDest-173" class="calibre5"><a id="_idTextAnchor194" class="pcalibre1 pcalibre calibre6"/>Answers</h1>
<p class="calibre3">Here are the answers to the questions given above:</p>
<ol class="calibre14">
<li value="1" class="calibre15">One possible solution is to use <strong class="source-inline1">git bundle</strong> on the remote host, and send the generated file via resumable transport such as HTTPS, rsync, or BitTorrent, or simply transport it via removable media such as a USB stick.</li>
<li class="calibre15">In the centralized workflow, you need to push to said central canonical repository, which might require merging changes from others first; in the integration manager workflow, you need to either push to your public repository and send some kind of pull request (for example, with <strong class="source-inline1">git request-pull</strong> and email) against the canonical repository, or send patches by email to the maintainer.</li>
<li class="calibre15">You can set up a credential helper appropriate for the operating system and desktop environment used; for SSH transport, you can also use <strong class="source-inline1">ssh-agent</strong> or the equivalent.</li>
<li class="calibre15">With appropriate tools, you can either use Git to work as a client for a foreign version control system (for example, <strong class="source-inline1">git svn</strong>) or use a remote transport helper to treat a foreign repository as a Git remote (for example, <strong class="source-inline1">git-cinnabar</strong>).</li>
</ol>
<h1 id="_idParaDest-174" class="calibre5"><a id="_idTextAnchor195" class="pcalibre1 pcalibre calibre6"/>Further reading</h1>
<p class="calibre3">To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
<ul class="calibre16">
<li class="calibre15">Scott Chacon and Ben Straub: <em class="italic">Pro Git, 2nd Edition</em> (2014) <a href="https://git-scm.com/book/en/v2" class="pcalibre1 pcalibre calibre6">https://git-scm.com/book/en/v2</a><ul class="calibre18"><li class="calibre15"><em class="italic">Chapter 7.12 Git Tools – </em><em class="italic">Bundling</em></li><li class="calibre15"><em class="italic">Chapter 7.14 Git Tools - </em><em class="italic">Credential Storage</em></li></ul></li>
<li class="calibre15">Bundle URI: <a href="https://git-scm.com/docs/bundle-uri" class="pcalibre1 pcalibre calibre6">https://git-scm.com/docs/bundle-uri</a></li>
<li class="calibre15">Anthony Heddings: <em class="italic">Should You Use HTTPS or SSH For Git?</em> (2021) <a href="https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https" class="pcalibre1 pcalibre calibre6">https://www.howtogeek.com/devops/should-you-use-https-or-ssh-for-git/#why-use-https</a></li>
<li class="calibre15"><em class="italic">A visual guide to SSH </em><em class="italic">tunnels </em><a href="https://robotmoon.com/ssh-tunnels/" class="pcalibre1 pcalibre calibre6">https://robotmoon.com/ssh-tunnels/</a></li>
<li class="calibre15">Carl Tashian: <em class="italic">SSH Tips &amp; Trick</em> – <em class="italic">Add a second factor to your SSH login</em> (2020) <a href="https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh" class="pcalibre1 pcalibre calibre6">https://smallstep.com/blog/ssh-tricks-and-tips/#add-a-second-factor-to-your-ssh</a></li>
<li class="calibre15">Greg Kroah-Hartman: <em class="italic">“Patches carved into stone tablets”, or why the Linux kernel developers rely on plain text email</em>, a Kernel Recipes 2016 talk <a href="https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/" class="pcalibre1 pcalibre calibre6">https://kernel-recipes.org/en/2016/talks/patches-carved-into-stone-tablets/</a></li>
</ul>
</div>
</body></html>